ve->GetDiskType(type));
			if (type == PHDT_DVD_ROM)
				GNREASSERT(cdvdDrive->DVDIsEncrypted(isEncrypted));
			else
				isEncrypted = FALSE;
			isEncryptedValid = TRUE;
			}
		else
			GNRAISE(GNR_NO_DRIVE);
		}

	enc = isEncrypted;
	GNRAISE_OK;
	}

//
//  Do authentication command
//

Error CDVDVolume::DoAuthenticationCommand(DVDAuthenticationCommand com, DWORD sector, BYTE * key)
	{
	VDAutoMutex mutex(&monitor);

	if (genericDrive)
		{
		Error err = cdvdDrive->DoAuthenticationCommand(com, sector, key);
		// for unmarked encrypted discs
		if (com == DAC_COMPLETE_AUTHENTICATION && !IS_ERROR(err))
			isEncrypted = TRUE;
		GNRAISE(err);
		}
	else
		GNRAISE(GNR_NO_DRIVE);
	}

//
//  Get RPC data
//

Error CDVDVolume::GetRPCData(BOOL & isRPC2, BYTE & regionCode, BYTE & availSets)
	{
	VDAutoMutex mutex(&monitor);

	if (genericDrive)
		GNRAISE(cdvdDrive->GetRPCData(isRPC2, regionCode, availSets));
	else
		GNRAISE(GNR_NO_DRIVE);
	}

//
//  Set region code
//

Error CDVDVolume::SetRegionCode(BYTE region)
	{
	VDAutoMutex mutex(&monitor);

	if (genericDrive)
		GNRAISE(cdvdDrive->SetRegionCode(region));
	else
		GNRAISE(GNR_NO_DRIVE);
	}

//
//  Get number of sessions
//

Error CDVDVolume::GetNumberOfSessions(WORD & sessions)
	{
	VDAutoMutex mutex(&monitor);

	if (genericDrive)
		GNRAISE(cdvdDrive->GetNumberOfSessions(sessions));
	else
		GNRAISE(GNR_NO_DRIVE);
	}

//
//  Read CD Toc
//

Error CDVDVolume::ReadCDTOC(WORD session, CDSessionType & sessionType, CDTocEntry * & toc, WORD & tocEntryNum, RequestHandle * rh)
	{
	VDAutoMutex mutex(&monitor);

	if (genericDrive)
		GNRAISE(cdvdDrive->ReadCDTOC(session, sessionType, toc, tocEntryNum, rh));
	else
		GNRAISE(GNR_NO_DRIVE);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\files\DiskItemName.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  Disk Item Name Handling
//
////////////////////////////////////////////////////////////////////

#ifndef DISKITEMNAME_H
#define DISKITEMNAME_H

#include "library/common/krnlstr.h"

//
//  Flags for DiskItemName::Matches()
//

#define DINM_NONE					0x00000000		// Nothing at all
#define DINM_CASE_SENSITIVE	0x00000001		// Match must be case sensitive

////////////////////////////////////////////////////////////////////
//
//  Disk Item Name Class
//  A disk item name consists of a path and a file name
//
////////////////////////////////////////////////////////////////////

class DiskItemName
	{
	protected:
		KernelString name;								// The name
		KernelString separators;						// Allowed separators for path components

		void Normalize(void);							// Normalize path so it only has default separators
		BOOL Matches(const DiskItemName & mask, int maskRead, int nameRead, DWORD flags) const;
		BOOL MatchChar(const DiskItemName & mask, int maskRead, int nameRead, int len, DWORD flags) const;

	public:
		DiskItemName(void);									// Create empty path name
		DiskItemName(const TCHAR c);						// Create path name from single character (e.g. drive letter)
		DiskItemName(const TCHAR * name);				// Create path name
		DiskItemName(const TCHAR * name, int len);	// Create path name from not '0' terminated string
		DiskItemName(const KernelString & name);		// Create path name
		DiskItemName(const DiskItemName & name);		// Copy constructor
		virtual ~DiskItemName(void);

		//
		//  Separator handling
		//

		void			 SetSeparators(const KernelString & sep);	// Set allowed separators for path components
		KernelString GetSeparators(void) const;					// Get allowed separators for path components
		void			 SetDefaultSeparator(TCHAR c);				// Set the default separator
		TCHAR			 GetDefaultSeparator(void) const;			// Get the default separator

		//
		//  Construct name
		//

		Error AddFrontComp(const KernelString & comp);		// Add path component to front of path
		Error AddEndComp(const KernelString & comp);			// Add path component to end of path
		Error RemoveFrontComp(void);								// Remove first path component
		Error RemoveEndComp(void);									// Remove last path component
		void	SetToRoot(void);										// Set path to root path and clear file name
		Error SetPathName(const KernelString & name);		// Set path name only
		Error SetFileName(const KernelString & name);		// Set complete file name (including extension)
		Error SetFileExt(const KernelString & ext);			// Set extension only (ext shall not contain '.')

		//
		//  Get path name/components
		//

		DiskItemName GetPath(void) const;					// Path name without file name
		DiskItemName GetFront(void) const;					// First component of path
		DiskItemName GetTail(void) const;					// Get path without first component

		DiskItemName GetFileName(void) const;				// File name with extension
		DiskItemName GetBaseName(void) const;				// File name without extension
		DiskItemName GetFileExt(void) const;				// File extension

		DiskItemName GetPathAndBaseName(void) const;		// Path and file name without extension

		//
		//  Misc. inquiry
		//

		BOOL IsPath(void) const;								// Test if item name points to path or file
		BOOL IsFileOnly(void) const;							// Test if item name has no path components
		BOOL IsRelative(void) const;							// Test if path name is relative (leading separator)
		BOOL IsRoot(void) const;								// Test if item name describes root dir
		BOOL Matches(const DiskItemName & mask, DWORD flags) const;	// Test if item name matches a given mask
		int  Length(void) const;

		//
		//  Operators
		//

		friend DiskItemName operator+(const DiskItemName & u, const DiskItemName & v);
		DiskItemName & operator+= (const DiskItemName & u);
		DiskItemName & operator=(const KernelString & str);

		friend BOOL operator==(const DiskItemName & u, const DiskItemName & v) { return u.name == v.name; }
		friend BOOL operator!=(const DiskItemName & u, const DiskItemName & v) { return u.name != v.name; }

		TCHAR & operator[] (const int index);
		const TCHAR & operator[] (const int index) const;

		operator KernelString * (void);
		operator TCHAR * (void);
	};

//
//  Default Constructor
//

inline DiskItemName::DiskItemName(void)
	{
	separators = "/\\";
	name = "";
	}

//
//  Constructor by single character
//

inline DiskItemName::DiskItemName(const TCHAR c)
	{
	separators = "/\\";
	this->name = c;
	Normalize();
	}

//
//  Constructor by C string
//

inline DiskItemName::DiskItemName(const TCHAR * name)
	{
	separators = "/\\";
	this->name = name;
	Normalize();
	}

//
//  Constructor by C string with length
//

inline DiskItemName::DiskItemName(const TCHAR * name, int len)
	{
	TCHAR * str = new TCHAR[len + 1];

	separators = "/\\";
	strncpy(str, name, len);
	str[len] = '\0';
	this->name = str;
	delete[] str;
	Normalize();
	}

//
//  Constructor by KernelString
//

inline DiskItemName::DiskItemName(const KernelString & name)
	{
	separators = "/\\";
	this->name = name;
	Normalize();
	}

//
//  Copy constructor
//

inline DiskItemName::DiskItemName(const DiskItemName & din)
	{
	name = din.name;
	separators = din.separators;
	}

//
//  Destructor
//

inline DiskItemName::~DiskItemName(void)
	{
	}

//
//  Set path component separators
//  The first character in the string serves as default separator
//

inline void DiskItemName::SetSeparators(const KernelString & sep)
	{
	separators = sep;
	Normalize();
	}

//
//  Return separators
//

inline KernelString DiskItemName::GetSeparators(void) const
	{
	return separators;
	}

//
//  Set default separator
//

inline void DiskItemName::SetDefaultSeparator(TCHAR c)
	{
	separators[0] = c;
	Normalize();
	}

//
//  Set default separator
//

inline TCHAR DiskItemName::GetDefaultSeparator(void) const
	{
	return separators[0];
	}

//
//  Set path name, leave file component
//

inline Error DiskItemName::SetPathName(const KernelString & pathName)
	{
	name = pathName + (KernelString)GetDefaultSeparator() + GetFileName();
	Normalize();
	GNRAISE_OK;
	}

//
//  Add path component to front of path
//

inline Error DiskItemName::AddFrontComp(const KernelString & comp)
	{
	name = comp + (KernelString)GetDefaultSeparator() + name;
	Normalize();
	GNRAISE_OK;
	}

//
// Add path component to end of path
//

inline Error DiskItemName::AddEndComp(const KernelString & comp)
	{
	name = GetPath() + (KernelString)GetDefaultSeparator() + comp + (KernelString)GetDefaultSeparator() + GetFileName();
	Normalize();
	GNRAISE_OK;
	}

//
//  Set path to root dir and delete file name
//

inline void DiskItemName::SetToRoot(void)
	{
	name = KernelString(GetDefaultSeparator());
	}

//
//  Set complete name (incl. path and file)
//

inline DiskItemName & DiskItemName::operator=(const KernelString & name)
	{
	this->name = name;
	Normalize();
	return *this;
	}

//
//  Set file name (including extension)
//

inline Error DiskItemName::SetFileName(const KernelString & name)
	{
	this->name = GetPath() + name;
	GNRAISE_OK;
	}

//
//  Set file extension only (ext shall not contain '.')
//

inline Error DiskItemName::SetFileExt(const KernelString & ext)
	{
	int pos = name.Last('.');

	if (pos > 0)
		name = name.Seg(0, pos + 1) + ext;
	else
		name += "." + ext;

	GNRAISE_OK;
	}

//
//  Get path (without file name)
//

inline DiskItemName DiskItemName::GetPath(void) const
	{
	int pos = name.Last(GetDefaultSeparator());

	if (pos >= 0)
		return DiskItemName(name.Seg(0, pos));
	else
		return DiskItemName("");
	}

//
//  File name with extension
//

inline DiskItemName DiskItemName::GetFileName(void) const
	{
	int pos = name.Last(GetDefaultSeparator());

	if (pos >= 0)
		return DiskItemName(name.Seg(pos + 1, name.Length() - pos - 1));
	else
		return DiskItemName("");
	}

//
//  Get path and file name without extension
//

inline DiskItemName DiskItemName::GetPathAndBaseName(void) const
	{
	int pos = name.Last('.');

	if (pos >= 0)
		return DiskItemName(name.Seg(0, pos));
	else
		return DiskItemName(name);
	}

//
//  Get length
//

inline int DiskItemName::Length(void) const
	{
	return name.Length();
	}

//
//  Test if item name points to path or file
//

inline BOOL DiskItemName::IsPath(void) const
	{
	return name[name.Length() - 1] == GetDefaultSeparator();
	}

//
//  Test if item name has no path components
//

inline BOOL DiskItemName::IsFileOnly(void) const
	{
	return name.First(GetDefaultSeparator()) > 0;
	}

//
//  Test if path name is relative (leading separator)
//

inline BOOL DiskItemName::IsRelative(void) const
	{
	return IsFileOnly() || name[0] != GetDefaultSeparator();
	}

//
//  Test if item name describes root dir
//

inline BOOL DiskItemName::IsRoot(void) const
	{
	return name == GetDefaultSeparator();
	}

//
//  Convert to TCHAR string
//

inline DiskItemName::operator TCHAR * (void)
	{
	return (char*)name;
	}

//
//  Convert to KernelString
//

inline DiskItemName::operator KernelString * (void)
	{
	return &name;
	}

//
//  Operator []
//

inline TCHAR & DiskItemName::operator[] (const int index)
	{
	return name[index];
	}

//
//  Operator []
//

inline const TCHAR & DiskItemName::operator[] (const int index) const
	{
	return name[index];
	}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\files\FileErrors.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  File Error Declarations
//
////////////////////////////////////////////////////////////////////

#ifndef FILEERRORS_H
#define FILEERRORS_H

#include "library/common/gnerrors.h"

#define GNR_PATH_NOT_FOUND							MKERR(ERROR,	FILE,			OBJECT,			0x00)
// The path specified was not found

#define GNR_INVALID_PATH							MKERR(ERROR,	FILE,			OBJECT,			0x01)
// The path specified was invalid (e.g. contained invalid letters)

#define GNR_NO_FILE_SYSTEM							MKERR(ERROR,	FILE,			OBJECT,			0x02)
// There is no file system to execute operation

#define GNR_NO_VOLUME								MKERR(ERROR,	FILE,			OBJECT,			0x03)
// There is no volume to execute operation

#define GNR_VOLUME_INVALID							MKERR(ERROR,	FILE,			OBJECT,			0x04)
// Volume is invalid for some reason, e.g. not supported

#define GNR_ITEM_NOT_FOUND							MKERR(ERROR,	FILE,			OBJECT,			0x05)
// The item was not found or there is no more file in the directory

#define GNR_NOT_A_DIRECTORY						MKERR(ERROR,	FILE,			OBJECT,			0x06)
// Disk item is not a directory

#define GNR_ITEM_INVALID							MKERR(ERROR,	FILE,			OBJECT,			0x07)
// Item is invalid (e.g. for an operation)

#define GNR_FILE_READ_ONLY							MKERR(ERROR,	FILE,			OPERATION,		0x00)
// The file is read only

//#define GNR_FILE_IN_USE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\files\DiskItemName.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  Disk Item Name Handling
//
////////////////////////////////////////////////////////////////////

#include "DiskItemName.h"

//
//  Normalize pathname, i.e. set all separator signs to default separator
//

void DiskItemName::Normalize(void)
	{
	int read = 0;
	int len = name.Length();
	KernelString help = "";

	while (read < len)
		{
		//
		//  make sure we only have the default separator
		//

		if (separators.Contains(name[read]))
			{
			name[read] = GetDefaultSeparator();

			//
			//  Remove double separators
			//

			if (read > 0 && name[read - 1] == GetDefaultSeparator())
				{
				read++;
				continue;
				}
			}

		help += name[read];
		read++;
		}

	name = help;
	}

//
//  Remove first path component
//

Error DiskItemName::RemoveFrontComp(void)
	{
	int pos = name.First(GetDefaultSeparator());

	if (!pos)
		{
		pos = name.Next(GetDefaultSeparator(), 0);
		if (pos >= 0)
			name = name.Seg(pos + 1, name.Length() - pos - 1);
		else
			name = name.Seg(1, name.Length() - 1);
		}
	else if (pos > 0)
		name = name.Seg(pos + 1, name.Length() - pos - 1);

	GNRAISE_OK;
	}

//
//  Remove last path component
//

Error DiskItemName::RemoveEndComp(void)
	{
	int pos1 = name.Last(GetDefaultSeparator());
	int pos2;

	if (pos1 >= 0)
		{
		pos2 = name.Prev(GetDefaultSeparator(), pos1);

		if (pos2 >= 0)
			name = name.Head(pos2) + name.Tail(name.Length() - pos1);
		else
			name = name.Tail(name.Length() - pos1 - 1);
		}

	GNRAISE_OK;
	}

//
//  First component of path
//

DiskItemName DiskItemName::GetFront(void) const
	{
	int pos = name.First(GetDefaultSeparator());

	if (!pos)
		{
		pos = name.Next(GetDefaultSeparator(), 0);
		if (pos >= 0)
			return name.Seg(1, pos - 1);
		else
			return name.Seg(1, name.Length() - 1);
		}
	else if (pos > 0)
		return name.Head(pos);
	else
		return "";
	}

//
//  Get path without first component
//

DiskItemName DiskItemName::GetTail(void) const
	{
	int pos = name.First(GetDefaultSeparator());

	if (pos >= 0)
		return name.Tail(name.Length() - pos - 1);
	else
		return name;
	}

//
//  File name without extension
//

DiskItemName DiskItemName::GetBaseName(void) const
	{
	int pos1 = name.Last(GetDefaultSeparator());
	int pos2;

	if (pos1 >= 0)
		{
		pos2 = name.Last('.');
		if (pos2 > pos1)	// Excludes case when not found
			return name.Seg(pos2 + 1, pos2 - pos1);
		else
			return name.Tail(name.Length() - pos1 - 1);
		}
	else
		{
		//
		// File name only
		//

		pos2 = name.Last('.');
		if (pos2 > 0)
			return name.Head(pos2);
		else
			return name;
		}
	}

//
//  Get file extension (without '.')
//

DiskItemName DiskItemName::GetFileExt(void) const
	{
	int pos1 = name.Last('.');
	int pos2 = name.Last(GetDefaultSeparator());

	if (pos1 > pos2)
		return name.Tail(name.Length() - pos1 - 1);
	else
		return "";
	}

//
//  Concatenate two item names
//  If first one contains a file name this gets lost
//

DiskItemName operator+(const DiskItemName & u, const DiskItemName & v)
	{
	return DiskItemName(u.name + (KernelString)u.GetDefaultSeparator() + v.name);
	}

//
//  Add item name
//  If "this" has a file name this gets lost
//

DiskItemName & DiskItemName::operator+= (const DiskItemName & u)
	{
	name += GetDefaultSeparator() + u.name;
	Normalize();
	return *this;
	}

//
//  Check if name matches a given mask
//  Supported are * and ?
//

BOOL DiskItemName::Matches(const DiskItemName & mask, DWORD flags) const
	{
	return Matches(mask, 0, 0, flags);
	}

//
//  Internal match function
//

BOOL DiskItemName::Matches(const DiskItemName & mask, int maskRead, int nameRead, DWORD flags) const
	{
	int starPos = mask.name.Next((KernelString)'*', maskRead - 1);
	int segEnd;

	if (maskRead == mask.Length())
		{
		return nameRead == name.Length();
		}
	else
		{
		//
		//  If there is some mask left, but no name, then mask may only contains '*'s
		//

		if (nameRead == name.Length())
			{
			while (maskRead < mask.Length())
				{
				if (mask[maskRead] != '*')
					return FALSE;
				maskRead++;
				}
			return TRUE;
			}
		}

	//
	//  Treat wildcard *
	//

	if (starPos == maskRead)
		{
		segEnd = mask.name.Next((TCHAR)'*', maskRead);
		if (segEnd >= 0)
			{
			KernelString seg;
			int segPos;

			seg = mask.name.Seg(maskRead + 1, segEnd - maskRead - 1);
			segPos = name.Next(seg, nameRead);
			while (segPos < name.Length())
				{
				if (Matches(mask, maskRead + 1 + seg.Length(), segPos + seg.Length(), flags))
					return TRUE;

				segPos = name.Next(seg, segPos);
				}

			return FALSE;
			}
		else
			{
			//
			//  If there is only one wildcard * then the tails must match
			//

			if (maskRead == mask.Length() - 1)	// Star at the end matches everything
				return TRUE;
			else
				{
				if (name.Length() - nameRead < mask.Length() - maskRead - 1)
					return FALSE;
				else
					return MatchChar(mask, maskRead + 1, name.Length() - (mask.Length() - maskRead - 1),
										  mask.Length() - maskRead - 1, flags);
				}
			}
		}
	else if (starPos > maskRead)
		{
		return MatchChar(mask, maskRead, nameRead, starPos - maskRead, flags) &&
				 Matches(mask, starPos, nameRead + starPos - maskRead, flags);
		}
	else
		{
		//
		//  When there is no star wildcard just match the tails of the strings
		//

		if (mask.Length() - maskRead == name.Length() - nameRead)
			return MatchChar(mask, maskRead, nameRead, mask.Length() - maskRead, flags);
		else
			return FALSE;	// Length of tails does not match
		}
	}

//
//  Match sequence of chars including ('?')
//  Note that maskRead + len must be inside mask string
//

#define DIN_CAPS(x)	(x >='a' && x <= 'z' ? x - 'a' + 'A' : x)

BOOL DiskItemName::MatchChar(const DiskItemName & mask, int maskRead, int nameRead, int len, DWORD flags) const
	{
	int hlen = len;

	while (hlen && nameRead < name.Length())
		{
		if (mask[maskRead] !='?')
			{
			if (flags & DINM_CASE_SENSITIVE)
				{
				if (mask[maskRead] != name[nameRead])
					return FALSE;
				}
			else
				{
				if (DIN_CAPS(mask[maskRead]) != DIN_CAPS(name[nameRead]))
					return FALSE;
				}
			}

		maskRead++;
		nameRead++;
		hlen--;
		}

	//
	//  If there are characters left to check then we ran out of chars in name -> not equal

	if (hlen)
		return FALSE;
	else
		return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\files\GenericVolume.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  Generic Volume Implementation
//
////////////////////////////////////////////////////////////////////

#include "GenericVolume.h"

//
//  Constructor
//

GenericVolume::GenericVolume(void)
	{
	genericDrive = NULL;
	refCount = 0;
	}

//
//  Destructor
//

GenericVolume::~GenericVolume(void)
	{
	//DPF("~GenericVolume");
	if (genericDrive)
		{
		Flush();
		genericDrive = NULL;
		}
	}

//
//  Init
//

Error GenericVolume::Init(GenericDrive * drive, GenericProfile * profile)
	{
	DWORD size, minSize, step;

	//DPF("GenericVolume::Init, refCount 1");
	genericDrive = drive;
	refCount = 1;
	GNREASSERT(genericDrive->GetVolumeID(volumeID));
	return genericDrive->GetDriveBlockSize(DST_NONE, size, minSize, maxBlockSize, step); //we are only curious about maximum size here, so DST_NONE is OK
	}

//
//  Obtain volume
//

Error GenericVolume::Obtain(void)
	{
	VDAutoMutex mutex(&monitor);

	refCount++;
	//DPF("Obtain Volume, refCount %d\n", refCount);
	GNRAISE_OK;
	}

//
//  Release volume
//

Error GenericVolume::Release(void)
	{
		{
		VDAutoMutex mutex(&monitor);

		refCount--;
		}
	//DPF("Release Volume, refCount %d\n", refCount);

	if (refCount < 1)
		delete this;
	GNRAISE_OK;
	}

//
//  Detach drive
//

Error GenericVolume::DetachDrive(void)
	{
	VDAutoMutex mutex(&monitor);

	if (genericDrive)
		{
		Flush();
#if MSNDISC
		genericDrive->UnlockClamp();
#else
		genericDrive->UnlockTray();
#endif
		genericDrive = NULL;
		}

	GNRAISE_OK;
	}

//
//  Get Volume ID
//

Error GenericVolume::GetVolumeID(VolumeID & volumeID)
	{
	volumeID = this->volumeID;
	GNRAISE_OK;
	}

//
//  Get disk type
//

Error GenericVolume::GetDiskType(PhysicalDiskType & type)
	{
	VDAutoMutex mutex(&monitor);

	if (genericDrive)
		GNRAISE(genericDrive->GetDiskType(type));
	else
		GNRAISE(GNR_NO_DRIVE);
	}

//
//  Get volume information
//

Error GenericVolume::GetVolumeInfo(VolumeInfo & volumeInfo)
	{
	volumeInfo.attributes = VIA_NONE;
	GNRAISE_OK;
	}

//
//  Get drive name
//

Error GenericVolume::GetDriveName(KernelString & name)
	{
	VDAutoMutex mutex(&monitor);

	if (genericDrive)
		GNRAISE(genericDrive->GetDriveName(name));
	else
		GNRAISE(GNR_NO_DRIVE);
	}

//
//  Get drive capabilities
//

#if MSNDISC
Error GenericVolume::GetDriveCaps(GenericDriveType & type, DWORD & caps, DWORD & slots, DWORD& positions, DWORD& changerOpenOffset)
	{
	VDAutoMutex mutex(&monitor);

	if (genericDrive)
		GNRAISE(genericDrive->GetDriveCaps(type, caps, slots,positions,changerOpenOffset));
	else
		GNRAISE(GNR_NO_DRIVE);
	}
#else
Error GenericVolume::GetDriveCaps(GenericDriveType & type, DWORD & caps, DWORD & slots)
	{
	VDAutoMutex mutex(&monitor);

	if (genericDrive)
		GNRAISE(genericDrive->GetDriveCaps(type, caps, slots));
	else
		GNRAISE(GNR_NO_DRIVE);
	}
#endif
//
//  Spin drive up
//

Error	GenericVolume::SpinUpDrive(void)
	{
	VDAutoMutex mutex(&monitor);

	if (genericDrive)
		GNRAISE(genericDrive->SpinUp());
	else
		GNRAISE(GNR_NO_DRIVE);
	}

//
//  Spin drive down
//

Error GenericVolume::SpinDownDrive(void)
	{
	VDAutoMutex mutex(&monitor);

	if (genericDrive)
		GNRAISE(genericDrive->SpinDown());
	else
		GNRAISE(GNR_NO_DRIVE);
	}

//
//  Seek block
//

Error GenericVolume::SeekBlock(DWORD block, DWORD flags, RequestHandle * rh)
	{
	VDAutoMutex mutex(&monitor);

	if (genericDrive)
		GNRAISE(genericDrive->SeekBlock(block, flags, rh));
	else
		GNRAISE(GNR_NO_DRIVE);
	}

//
//  Lock drive blocks
//

Error GenericVolume::LockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh)
	{
	VDAutoMutex mutex(&monitor);

	if (genericDrive)
		GNRAISE(genericDrive->LockBlocks(block, num, blocks, flags, rh));
	else
		GNRAISE(GNR_NO_DRIVE);
	}

//
//  Unlock drive blocks
//

Error GenericVolume::UnlockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh)
	{
	VDAutoMutex mutex(&monitor);

	if (genericDrive)
		GNRAISE(genericDrive->UnlockBlocks(block, num, blocks, flags, rh));
	else
		GNRAISE(GNR_NO_DRIVE);
	}

//
//  Flush data
//

Error GenericVolume::Flush(void)
	{
	VDAutoMutex mutex(&monitor);

	if (genericDrive)
		GNRAISE(genericDrive->Flush());

	GNRAISE_OK;
	}

//
//  Get copy management mode
//

Error GenericVolume::GetCopyManagementInfo(DWORD block, GenericCopyManagementInfo & gcmi)
	{
	VDAutoMutex mutex(&monitor);

	if (genericDrive)
		GNRAISE(genericDrive->GetCopyManagementInfo(block, gcmi));
	else
		GNRAISE(GNR_NO_DRIVE);
	}

//
//  Terminate request
//

Error GenericVolume::TerminateRequest(RequestHandle * rh)
	{
	VDAutoMutex mutex(&monitor);

	if (genericDrive)
		GNRAISE(genericDrive->TerminateRequest(rh));
	else
		GNRAISE(GNR_NO_DRIVE);
	}

//
//  Get drive block size
//

Error GenericVolume::GetDriveBlockSize(DWORD sectorType, DWORD & currentSize, DWORD & minSize, DWORD & maxSize, DWORD & step)
	{
	VDAutoMutex mutex(&monitor);

	if (genericDrive)
		GNRAISE(genericDrive->GetDriveBlockSize(sectorType, currentSize, minSize, maxSize, step));
	else
		GNRAISE(GNR_NO_DRIVE);
	}

//
//  Set drive block size
//

Error GenericVolume::SetDriveBlockSize(DWORD size)
	{
	VDAutoMutex mutex(&monitor);

	if (genericDrive)
		return genericDrive->SetDriveBlockSize(size);
	else
		GNRAISE(GNR_NO_DRIVE);
	}

//
//  Get number of drive blocks
//

Error GenericVolume::GetNumberOfDriveBlocks(DWORD & num)
	{
	VDAutoMutex mutex(&monitor);

	if (genericDrive)
		return genericDrive->GetNumberOfDriveBlocks(num);
	else
		GNRAISE(GNR_NO_DRIVE);
	}

//
//  Set number of drive blocks
//

Error GenericVolume::SetNumberOfDriveBlocks(DWORD num)
	{
	VDAutoMutex mutex(&monitor);

	if (genericDrive)
		GNRAISE(genericDrive->SetNumberOfDriveBlocks(num));
	else
		GNRAISE(GNR_NO_DRIVE);
	}

//
//  Get block info
//

Error GenericVolume::GetBlockInfo(DWORD sectorType, DWORD & blockSize, DWORD & headerSize, DWORD & dataSize)
	{
	if (genericDrive)
		GNRAISE(genericDrive->GetBlockInfo(sectorType, blockSize, headerSize, dataSize));
	else
		GNRAISE(GNR_NO_DRIVE);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\files\GenericVolume.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  Generic Volume Classes
//
////////////////////////////////////////////////////////////////////

#ifndef GENERICVOLUME_H
#define GENERICVOLUME_H

class GenericVolume;

#include "library/hardware/drives/generic/GenericDrive.h"
#include "library/Files/VolumeCache.h"
#include "library/Files/GenericFile.h"
#include "library/common/krnlstr.h"
#include "library/common/krnlsync.h"

////////////////////////////////////////////////////////////////////
//
//  Volume Information
//
////////////////////////////////////////////////////////////////////

class VolumeInfo
	{
	public:
		DWORD attributes;
	};

//
//  Volume Information Attributes
//

#define VIA_NONE							0
#define VIA_CONTAINS_AUDIO_TRACKS	1

////////////////////////////////////////////////////////////////////
//
//  Generic Volume Declaration
//
////////////////////////////////////////////////////////////////////

class GenericVolume
	{
	protected:
		GenericDrive * genericDrive;
	public:
		int refCount;
	protected:
		VDLocalMutex monitor;
		DWORD maxBlockSize;
		VolumeID volumeID;

	public:
		GenericVolume(void);
		virtual ~GenericVolume(void);

		//
		//  Init/Cleanup
		//

		virtual Error Init(GenericDrive * drive, GenericProfile * profile);
		virtual Error Obtain(void);
		virtual Error Release(void);
		virtual Error DetachDrive(void);
		virtual Error GetVolumeID(VolumeID & volumeID);

		//
		//  Drive Handling
		//

		virtual Error GetDiskType(PhysicalDiskType & type);
		virtual Error GetVolumeInfo(VolumeInfo & volumeInfo);
		virtual Error GetDriveName(KernelString & name);
#if MSNDISC
		virtual Error GetDriveCaps(GenericDriveType & type, DWORD & caps, DWORD & slots, DWORD& positions, DWORD& changerOpenOffset);
#else
		virtual Error GetDriveCaps(GenericDriveType & type, DWORD & caps, DWORD & slots);
#endif
		virtual Error SpinUpDrive(void);
		virtual Error SpinDownDrive(void);
		virtual Error GetCopyManagementInfo(DWORD block, GenericCopyManagementInfo & mode);
		virtual Error TerminateRequest(RequestHandle * rh);

		//
		//  General Access Methods
		//

		virtual Error SeekBlock(DWORD block, DWORD flags, RequestHandle * rh);
		virtual Error LockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh);
		virtual Error UnlockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh);

		virtual Error Flush(void);

		virtual Error GetDriveBlockSize(DWORD sectorType, DWORD & size, DWORD & minSize, DWORD & maxSize, DWORD & step);
		virtual Error SetDriveBlockSize(DWORD size);

		virtual Error GetNumberOfDriveBlocks(DWORD & num);
		virtual Error SetNumberOfDriveBlocks(DWORD num);

		virtual Error GetBlockInfo(DWORD sectorType, DWORD & blockSize, DWORD & headerSize, DWORD & dataSize);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\files\GenericFile.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  Generic File Classes, Implementation
//
////////////////////////////////////////////////////////////////////

#include "GenericFile.h"

////////////////////////////////////////////////////////////////////
//
//  Generic Disk Item Implementation
//
////////////////////////////////////////////////////////////////////

//
//  Constructor
//

GenericDiskItem::GenericDiskItem(GenericFileSystem * gfs)
	{
	this->gfs = gfs;
	//DP("From GenericDiskItem - FS O: ");
	gfs->Obtain();
	}

//
//  Destructor
//

GenericDiskItem::~GenericDiskItem(void)
	{
	//DP("From ~GenericDiskItem - FS R:");
	gfs->Release();
	}

//
//  Flush
//

Error GenericDiskItem::Flush(void)
	{
	GNRAISE_OK;
	}

//
//  Terminate request
//

Error GenericDiskItem::TerminateRequest(RequestHandle * rh)
	{
	return gfs->TerminateRequest(rh);
	}


void PathStringCache::Add(DiskItemName name, DWORD block)
	{
	StringCacheElement * node = new StringCacheElement(block, name);
	InsertFirst((Node*) node);
	if (Num() > size)
		{
		node = (StringCacheElement*) Last();
		RemoveLast();
		delete (StringCacheElement*) node;
		}
	}

Error PathStringCache::Get(DWORD block, DiskItemName & name)
	{
	IteratorHandle h(CreateIterator());
	StringCacheElement * node = NULL;

	bool found = false;
	while (!found && (node = ((StringCacheElement*) h.Proceed())))		// order of expressions is important!
		{
		if (node->block == block)
			found = true;
		}

	if (!found)
		return GNR_ITEM_NOT_FOUND;

	// reorder - move to front
	Remove(node);
	InsertFirst(node);

	name = node->name;

	return GNR_OK;
	}


////////////////////////////////////////////////////////////////////
//
//  Generic File Class
//
////////////////////////////////////////////////////////////////////

//
//  Constructor
//

GenericFile::GenericFile(GenericFileSystem * gfs) : GenericDiskItem(gfs)
	{
	}

//
//  Destructor
//

GenericFile::~GenericFile(void)
	{
	}

//
//  Open file
//

Error GenericFile::Open(GenericFileSystemIterator * gfsi, DWORD accessType)
	{
	if (accessType & FAT_HEADER)
		headerFile = TRUE;
	else
		headerFile = FALSE;

	startBlock = 0;
	GNRAISE_OK;
	}

//
//  Get unique key
//

Error GenericFile::GetUniqueKey(BYTE * key)
	{
	if (!uniqueKey.valid)
		{
		uniqueKey.valid = FALSE;
		GNREASSERT(BuildUniqueKey());
		}

	uniqueKey.valid = TRUE;
	memcpy(key, uniqueKey.key, 8);
	GNRAISE_OK;
	}

//
//  Get start block of file (logical, i.e. physical block is computed by adding logicalBaseBlock of file system)
//

Error GenericFile::GetStartBlock(DWORD & startBlock)
	{
	startBlock = this->startBlock;
	GNRAISE_OK;
	}

Error GenericFile::ReadByte(DWORD pos, BYTE & b, DWORD flags, RequestHandle * rh)
	{
	DriveBlock db;
	DWORD headerSize, dataSize;
	DWORD sectorType, offset;
	DWORD block;
	Error err;

	//
	//  Determine sector type/data sizes
	//

	if (headerFile)
		{
		headerSize = gfs->GetHeaderHeaderSize();
		dataSize = gfs->GetHeaderDataSize();
		sectorType = gfs->GetHeaderSectorType();
		}
	else
		{
		headerSize = gfs->GetDataHeaderSize();
		dataSize = gfs->GetDataDataSize();
		sectorType = gfs->GetDataSectorType();
		}

	if (flags & FAT_RAW)
		{
		dataSize += headerSize;
		headerSize = 0;
		}

	//
	//  Determine position
	//

	block = (pos / dataSize);
	offset = (pos % dataSize) + headerSize;
	flags = (flags & ~GD_COMMAND_MASK & ~GD_SECTOR_TYPE_MASK) | sectorType;

	//
	//  Read data
	//

	if (!IS_ERROR(err = LockBlocks(block, 1, &db, flags | DAT_LOCK_AND_READ, rh)))
		b = db.data[offset];
	UnlockBlocks(block, 1, &db, flags | DAT_UNLOCK_CLEAN, rh);
	GNRAISE(err);
	}

//
//  Read word
//

Error GenericFile::ReadWord(DWORD pos, WORD & w, DWORD flags, RequestHandle * rh)
	{
	DriveBlock db[2];
	DWORD headerSize, dataSize;
	DWORD sectorType, offset;
	DWORD block, num = 1;
	Error err;

	//
	//  Determine sector type/data sizes
	//

	if (headerFile)
		{
		headerSize = gfs->GetHeaderHeaderSize();
		dataSize = gfs->GetHeaderDataSize();
		sectorType = gfs->GetHeaderSectorType();
		}
	else
		{
		headerSize = gfs->GetDataHeaderSize();
		dataSize = gfs->GetDataDataSize();
		sectorType = gfs->GetDataSectorType();
		}

	if (flags & FAT_RAW)
		{
		dataSize += headerSize;
		headerSize = 0;
		}

	//
	//  Determine position
	//

	block = (pos / dataSize);
	offset = (pos % dataSize) + headerSize;
	if (offset == dataSize - 1)	// We read over block boundary
		num = 2;
	flags = (flags & ~GD_COMMAND_MASK & ~GD_SECTOR_TYPE_MASK) | sectorType;

	//
	//  Read data
	//

	if (!IS_ERROR(err = LockBlocks(block, num, &(db[0]), flags | DAT_LOCK_AND_READ, rh)))
		{
		if (offset == dataSize - 1)
			w = MAKEWORD(db[1].data[headerSize], db[0].data[dataSize - 1]);
		else
			w = MAKEWORD(db[0].data[offset + 1], db[0].data[offset]);
		}
	UnlockBlocks(block, num, &(db[0]), flags | DAT_UNLOCK_CLEAN, rh);
	GNRAISE(err);
	}

//
//  Read dword
//

Error GenericFile::ReadDWord(DWORD pos, DWORD & d, DWORD flags, RequestHandle * rh)
	{
	DriveBlock db[2];
	DWORD headerSize, dataSize;
	DWORD sectorType, offset;
	DWORD block, num = 1;
	Error err;

	//
	//  Determine sector type/data sizes
	//

	if (headerFile)
		{
		headerSize = gfs->GetHeaderHeaderSize();
		dataSize = gfs->GetHeaderDataSize();
		sectorType = gfs->GetHeaderSectorType();
		}
	else
		{
		headerSize = gfs->GetDataHeaderSize();
		dataSize = gfs->GetDataDataSize();
		sectorType = gfs->GetDataSectorType();
		}

	if (flags & FAT_RAW)
		{
		dataSize += headerSize;
		headerSize = 0;
		}

	//
	//  Determine position
	//

	block = (pos / dataSize);
	offset = (pos % dataSize) + headerSize;
	if (offset > dataSize - 4)	// We read over block boundary
		num = 2;
	flags = (flags & ~GD_COMMAND_MASK & ~GD_SECTOR_TYPE_MASK) | sectorType;

	//
	//  Read data
	//

	if (!IS_ERROR(err = LockBlocks(block, num, &(db[0]), flags | DAT_LOCK_AND_READ, rh)))
		{
		switch (dataSize - offset)
			{
			case 1:
				d = MAKELONG4(db[1].data[headerSize + 2], db[headerSize + 1].data[1], db[1].data[headerSize], db[0].data[offset]);
				break;
			case 2:
				d = MAKELONG4(db[1].data[headerSize + 1], db[1].data[headerSize], db[0].data[offset + 1], db[0].data[offset]);
				break;
			case 3:
				d = MAKELONG4(db[1].data[headerSize], db[0].data[offset + 2], db[0].data[offset + 1], db[0].data[offset]);
				break;
			default:
				d = MAKELONG4(db[0].data[offset + 3], db[0].data[offset + 2], db[0].data[offset + 1], db[0].data[offset]);
				break;
			}
		}
	UnlockBlocks(block, num, &(db[0]), flags | DAT_UNLOCK_CLEAN, rh);
	GNRAISE(err);
	}

//
//  Read byte
//

Error GenericFile::ReadByte(KernelInt64 pos, BYTE & b, DWORD flags, RequestHandle * rh)
	{
	DriveBlock db;
	DWORD headerSize, dataSize;
	DWORD sectorType, offset;
	DWORD block;
	Error err;

	//
	//  Determine sector type/data sizes
	//

	if (headerFile)
		{
		headerSize = gfs->GetHeaderHeaderSize();
		dataSize = gfs->GetHeaderDataSize();
		sectorType = gfs->GetHeaderSectorType();
		}
	else
		{
		headerSize = gfs->GetDataHeaderSize();
		dataSize = gfs->GetDataDataSize();
		sectorType = gfs->GetDataSectorType();
		}

	if (flags & FAT_RAW)
		{
		dataSize += headerSize;
		headerSize = 0;
		}

	//
	//  Determine position
	//

	block = (pos / (KernelInt64)dataSize).ToDWORD();
	offset = (pos % dataSize).ToDWORD() + headerSize;
	flags = (flags & ~GD_COMMAND_MASK & ~GD_SECTOR_TYPE_MASK) | sectorType;

	//
	//  Read data
	//

	if (!IS_ERROR(err = LockBlocks(block, 1, &db, flags | DAT_LOCK_AND_READ, rh)))
		b = db.data[offset];
	UnlockBlocks(block, 1, &db, flags | DAT_UNLOCK_CLEAN, rh);
	GNRAISE(err);
	}

//
//  Read word
//

Error GenericFile::ReadWord(KernelInt64 pos, WORD & w, DWORD flags, RequestHandle * rh)
	{
	DriveBlock db[2];
	DWORD headerSize, dataSize;
	DWORD sectorType, offset;
	DWORD block, num = 1;
	Error err;

	//
	//  Determine sector type/data sizes
	//

	if (headerFile)
		{
		headerSize = gfs->GetHeaderHeaderSize();
		dataSize = gfs->GetHeaderDataSize();
		sectorType = gfs->GetHeaderSectorType();
		}
	else
		{
		headerSize = gfs->GetDataHeaderSize();
		dataSize = gfs->GetDataDataSize();
		sectorType = gfs->GetDataSectorType();
		}

	if (flags & FAT_RAW)
		{
		dataSize += headerSize;
		headerSize = 0;
		}

	//
	//  Determine position
	//

	block = (pos / (KernelInt64)dataSize).ToDWORD();
	offset = (pos % dataSize).ToDWORD() + headerSize;
	if (offset == dataSize - 1)	// We read over block boundary
		num = 2;
	flags = (flags & ~GD_COMMAND_MASK & ~GD_SECTOR_TYPE_MASK) | sectorType;

	//
	//  Read data
	//

	if (!IS_ERROR(err = LockBlocks(block, num, &(db[0]), flags | DAT_LOCK_AND_READ, rh)))
		{
		if (offset == dataSize - 1)
			w = MAKEWORD(db[1].data[headerSize], db[0].data[dataSize - 1]);
		else
			w = MAKEWORD(db[0].data[offset + 1], db[0].data[offset]);
		}
	UnlockBlocks(block, num, &(db[0]), flags | DAT_UNLOCK_CLEAN, rh);
	GNRAISE(err);
	}

//
//  Read dword
//

Error GenericFile::ReadDWord(KernelInt64 pos, DWORD & d, DWORD flags, RequestHandle * rh)
	{
	DriveBlock db[2];
	DWORD headerSize, dataSize;
	DWORD sectorType, offset;
	DWORD block, num = 1;
	Error err;

	//
	//  Determine sector type/data sizes
	//

	if (headerFile)
		{
		headerSize = gfs->GetHeaderHeaderSize();
		dataSize = gfs->GetHeaderDataSize();
		sectorType = gfs->GetHeaderSectorType();
		}
	else
		{
		headerSize = gfs->GetDataHeaderSize();
		dataSize = gfs->GetDataDataSize();
		sectorType = gfs->GetDataSectorType();
		}

	if (flags & FAT_RAW)
		{
		dataSize += headerSize;
		headerSize = 0;
		}

	//
	//  Determine position
	//

	block = (pos / (KernelInt64)dataSize).ToDWORD();
	offset = (pos % dataSize).ToDWORD() + headerSize;
	if (offset > dataSize - 4)	// We read over block boundary
		num = 2;
	flags = (flags & ~GD_COMMAND_MASK & ~GD_SECTOR_TYPE_MASK) | sectorType;

	//
	//  Read data
	//

	if (!IS_ERROR(err = LockBlocks(block, num, &(db[0]), flags | DAT_LOCK_AND_READ, rh)))
		{
		switch (dataSize - offset)
			{
			case 1:
				d = MAKELONG4(db[1].data[headerSize + 2], db[headerSize + 1].data[1], db[1].data[headerSize], db[0].data[offset]);
				break;
			case 2:
				d = MAKELONG4(db[1].data[headerSize + 1], db[1].data[headerSize], db[0].data[offset + 1], db[0].data[offset]);
				break;
			case 3:
				d = MAKELONG4(db[1].data[headerSize], db[0].data[offset + 2], db[0].data[offset + 1], db[0].data[offset]);
				break;
			default:
				d = MAKELONG4(db[0].data[offset + 3], db[0].data[offset + 2], db[0].data[offset + 1], db[0].data[offset]);
				break;
			}
		}
	UnlockBlocks(block, num, &(db[0]), flags | DAT_UNLOCK_CLEAN, rh);
	GNRAISE(err);
	}

//
//  Read bytes
//  NOTE: ReadBytes relies on LockBlocks. Bad data might be read if the last block of one file
//  is not completely filled with data, i.e. the file size is not a multiple of the block size.
//

Error GenericFile::ReadBytes(KernelInt64 pos, KernelInt64 num, BYTE * buffer, DWORD flags, RequestHandle * rh)
	{
	VDAutoMutex mutex(&lock);
	DriveBlock * db;
	DWORD firstBlock, lastBlock, numBlocks;
	DWORD blocksToRead, blocksAtOnce = 32;//27;		// This is because of the stupid ASPI limitation of 64K at most at once
	DWORD headerSize, dataSize;
	DWORD sectorType;
	DWORD bytes;
	Error err = GNR_OK;
	DWORD i;

	if (num == 0)
		GNRAISE_OK;

	//
	//  Determine sector type/data sizes
	//

	if (headerFile)
		{
		headerSize = gfs->GetHeaderHeaderSize();
		dataSize = gfs->GetHeaderDataSize();
		sectorType = gfs->GetHeaderSectorType();
		}
	else
		{
		headerSize = gfs->GetDataHeaderSize();
		dataSize = gfs->GetDataDataSize();
		sectorType = gfs->GetDataSectorType();
		}

	if (flags & FAT_RAW)
		{
		dataSize += headerSize;
		headerSize = 0;
		}

	//
	//  Determine number of blocks and allocate drive blocks
	//

	firstBlock = (pos / (KernelInt64)dataSize).ToDWORD();
	lastBlock = ((pos + num) / (KernelInt64)dataSize).ToDWORD();
	pos %= dataSize;
	numBlocks = lastBlock - firstBlock + 1;
	db = new DriveBlock[blocksAtOnce];
	if (!db)
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
	flags = (flags & ~GD_COMMAND_MASK & ~GD_SECTOR_TYPE_MASK) | sectorType;

	//
	//  Read data and copy it
	//

	while (numBlocks && !IS_ERROR(err))
		{
		blocksToRead = min(numBlocks, blocksAtOnce);
		err = LockBlocks(firstBlock, blocksToRead, db, flags | DAT_LOCK_AND_READ, rh);
		if (!IS_ERROR(err))
			{
			for (i=0; i<blocksToRead; i++)
				{
				bytes = (pos + num > dataSize ? dataSize - pos : num).ToDWORD();
				memcpy(buffer, db[i].data + pos.ToDWORD() + headerSize, bytes);
				buffer += bytes;
				num -= bytes;
				pos = 0;
				}

			UnlockBlocks(firstBlock, blocksToRead, db, flags | DAT_UNLOCK_CLEAN, rh);
			numBlocks -= blocksToRead;
			firstBlock += blocksToRead;
			}
		else if (err == GNR_NOT_ENOUGH_MEMORY && blocksAtOnce > 1)
			{
			blocksAtOnce >>= 1;	// If there were not enough free blocks try with less
			err = GNR_OK;
			continue;
			}
		else
			UnlockBlocks(firstBlock, blocksToRead, db, flags | DAT_UNLOCK_CLEAN, rh);
		}

	//
	//  Cleanup
	//

	delete[] db;
	GNRAISE(err);
	}

//
//  Write bytes
//

Error GenericFile::WriteBytes(KernelInt64 pos, KernelInt64 num, BYTE * buffer, DWORD flags, RequestHandle * rh)
	{
	GNRAISE(GNR_FILE_READ_ONLY);
	}

////////////////////////////////////////////////////////////////////
//
//  Generic Directory Class
//
////////////////////////////////////////////////////////////////////

//
//  Constructor
//

GenericDirectory::GenericDirectory(GenericFileSystem * gfs) : GenericDiskItem(gfs)
	{
	}

//
//  Destructor
//

GenericDirectory::~GenericDirectory(void)
	{
	}

//
//  Return size
//

Error GenericDirectory::GetSize(KernelInt64 & size)
	{
	size = 0;
	GNRAISE_OK;
	}

//
//  Find item
//

Error GenericDirectory::FindItem(const DiskItemName & name, DiskItemType type, DWORD flags, GenericFileSystemIterator * & gfsi)
	{
	GenericFileSystemIterator * where;
	Error err;

	GNREASSERT(GetIterator(where));
	err = gfs->FindItem(name, type, flags, where, gfsi);
	delete where;
	GNRAISE(err);
	}

////////////////////////////////////////////////////////////////////
//
//  Generic File System Iterator Implementation
//
////////////////////////////////////////////////////////////////////

//
//  Constructor
//

GenericFileSystemIterator::GenericFileSystemIterator(GenericFileSystem * gfs)
	{
	this->gfs = gfs;
#if _DEBUG
	//if (gfs->GetFileSystemType() != FS_ROOT) DP("From GenericFileSystemIterator - FS O: ");
#endif
	gfs->Obtain();
	}

//
//  Destructor
//

GenericFileSystemIterator::~GenericFileSystemIterator(void)
	{
#if _DEBUG
	//if (gfs->GetFileSystemType() != FS_ROOT) DP("From ~GenericFileSystemIterator - FS R: ");
#endif
	gfs->Release();
	}

//
//  Comparison operator
//

int operator==(GenericFileSystemIterator & gfsi1, GenericFileSystemIterator & gfsi2)
	{
	if (gfsi1.gfs == gfsi2.gfs)
		return gfsi1.Equals(&gfsi2);
	else
		return 0;
	}

//
//  Get the file system of the iterator
//

Error GenericFileSystemIterator::GetFileSystem(GenericFileSystem * & gfs)
	{
	gfs = this->gfs;
	GNRAISE_OK;
	}

//
//  Get the file system this iterator points to (only valid for RootIterator)
//

Error GenericFileSystemIterator::GetSubFileSystem(GenericFileSystem * & gfs)
	{
	GNRAISE(GNR_OBJECT_NOT_FOUND);
	}

Error GenericFileSystemIterator::GetPathName(DiskItemName & name)
	{
	return gfs->GetPathName(name, this);
	}

//
//  Get extended item information
//

Error GenericFileSystemIterator::GetExtItemInfo(ExtItemInfo & info)
	{
	return gfs->GetExtItemInfo(this, info);
	}

////////////////////////////////////////////////////////////////////
//
//  Generic File System Implementation
//
////////////////////////////////////////////////////////////////////

//
//  Constructor
//

GenericFileSystem::GenericFileSystem(void)
	{
	genericVolume = NULL;
	mountPoint = NULL;
	profile = NULL;
	volumeName = "";
	volumeSetName = "";
	volumeSetIndex = 0;
	volumeSetSize = 0;
	refCount = 0;
	fileSystemType = FS_GENERIC;
	//DP("GenericFileSystem constructor");
	}

//
//  Destructor
//

GenericFileSystem::~GenericFileSystem(void)
	{
	//DP("Delete FS type %d\n", fileSystemType);
	if (refCount != 0)
		DP("WARNING: GenericFileSystem Ref Counter was not ZERO!");

	if (genericVolume)
		{
		//DP("From ~GenericFileSystem - FS R:");
		genericVolume->Release();
		}

	delete mountPoint;
	}

//
//  Initialize (this also sets the reference counter to 1)
//

Error	GenericFileSystem::Init(GenericFileSystemIterator * mountPoint, GenericVolume * volume, GenericProfile * profile)
	{
	VDAutoMutex mutex(&lock);

	//DP("Init FS type %d\n", fileSystemType);
	refCount = 1;
	if (volume)
		{
		//DP("From GenericFileSystem::Init - V O:");
		GNREASSERT(volume->Obtain());
		}
	genericVolume = volume;
	GNREASSERT(mountPoint->Clone(this->mountPoint));
	this->profile = profile;
	logicalBaseBlock = 0;

	GNREASSERT(InitHeaderAndData(volume));
	GNREASSERT(GetCurrentDriveBlockSize(blockSize));

	GNRAISE_OK;
	}

//
// Initialize header and data related variables
//
Error	GenericFileSystem::InitHeaderAndData(GenericVolume * volume)
	{
	DWORD dummy;
	PhysicalDiskType diskType;

	GNREASSERT(volume->GetDiskType(diskType));

	switch (diskType)
		{
		case PHDT_CDDA:
			headerSectorType = DST_CDDA;
			dataSectorType = DST_CDDA;
			break;
		case PHDT_CDROM:
			headerSectorType = DST_CDROM_MODE1;
			dataSectorType = DST_CDROM_MODE2;
			break;
		case PHDT_CDI:
		case PHDT_CDROM_XA:
			headerSectorType = DST_CDROM_MODE2_XA_FORM1;
			dataSectorType = DST_CDROM_MODE2_XA_FORM2;
			break;
		case PHDT_DVD_ROM:
			headerSectorType = DST_DVD_ROM;
			dataSectorType = DST_DVD_ROM;
			break;
		default:
			GNRAISE(GNR_VOLUME_INVALID);
		}

	GNREASSERT(volume->GetBlockInfo(headerSectorType, dummy, headerHeaderSize, headerDataSize));
	GNREASSERT(volume->GetBlockInfo(dataSectorType, dummy, dataHeaderSize, dataDataSize));

	GNRAISE_OK;
	}


//
//  Obtain file system
//

Error GenericFileSystem::Obtain(void)
	{
	VDAutoMutex mutex(&lock);

	refCount++;
	//DP("Obtain FS type %d, refCount %d\n", fileSystemType, refCount);
	GNRAISE_OK;
	}

//
//  Release file system
//

Error GenericFileSystem::Release(void)
	{
		{
		VDAutoMutex mutex(&lock);

		if (refCount > 0)
			refCount--;
		//DP("Release FS type %d, refCount %d\n", fileSystemType, refCount);
		}

	if (!refCount)
		delete this;
	GNRAISE_OK;
	}

//
//  Create iterator
//

Error GenericFileSystem::CreateRootIterator(GenericFileSystemIterator * & gfsi)
	{
	if (mountPoint)
		GNRAISE(mountPoint->Clone(gfsi));
	else
		GNRAISE(CreateIterator(gfsi));
	}

//
//  Create directory
//

Error GenericFileSystem::CreateRootDirectory(GenericDirectory * & gd)
	{
	if (mountPoint)
		GNRAISE(mountPoint->gfs->CreateRootDirectory(gd));
	else
		GNRAISE(CreateDirectory(FAT_NONE, gd));
	}

//
//  Get disk type
//

Error GenericFileSystem::GetDiskType(PhysicalDiskType & type)
	{
	GNRAISE(genericVolume->GetDiskType(type));
	}

//
//  Get volume name
//

Error GenericFileSystem::GetVolumeName(KernelString & name)
	{
	VDAutoMutex mutex(&lock);

	name = volumeName;
	GNRAISE_OK;
	}

//
//  Get volume set name
//

Error GenericFileSystem::GetVolumeSetName(KernelString & name)
	{
	VDAutoMutex mutex(&lock);

	name = volumeSetName;
	GNRAISE_OK;
	}

//
//  Get volume set index
//

Error GenericFileSystem::GetVolumeSetIndex(int & index)
	{
	VDAutoMutex mutex(&lock);

	index = volumeSetIndex;
	GNRAISE_OK;
	}

//
//  Get volume set size
//

Error GenericFileSystem::GetVolumeSetSize(int & size)
	{
	VDAutoMutex mutex(&lock);

	size = volumeSetSize;
	GNRAISE_OK;
	}

//
//  Get unique key
//

Error GenericFileSystem::GetUniqueKey(BYTE * key)
	{
	if (!uniqueKey.valid)
		{
		uniqueKey.valid = FALSE;
		GNREASSERT(BuildUniqueKey());
		}

	uniqueKey.valid = TRUE;
	memcpy(key, uniqueKey.key, 8);
	GNRAISE_OK;
	}

//
//  Get logical base block
//

Error GenericFileSystem::GetLogicalBaseBlock(DWORD & logicalBaseBlock)
	{
	logicalBaseBlock = this->logicalBaseBlock;
	GNRAISE_OK;
	}

//
//  Get volume
//

Error GenericFileSystem::ObtainVolume(GenericVolume * & volume)
	{
	volume = genericVolume;
	if (volume)
		{
		//DP("From ObtainVolume - V O:");
		volume->Obtain();
		}
	GNRAISE_OK;
	}


//
//  Get drive block size
//

Error GenericFileSystem::GetCurrentDriveBlockSize(DWORD & size)
	{
	DWORD minSize, maxSize, step;

	VDAutoMutex mutex(&lock);

	if (genericVolume)
		{
		Error err;

		//Which size to ask for - header or data sector? Whichever - total size is the same for both, and file system relies on that.
		if (!IS_ERROR(err = genericVolume->GetDriveBlockSize(GetDataSectorType(), size, minSize, maxSize, step)))
			GNRAISE_OK;
		else
			GNRAISE(err);
		}
	else
		GNRAISE(GNR_NO_VOLUME);
	}

//
//  Set drive block size
//

Error GenericFileSystem::SetDriveBlockSize(DWORD size)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}

//
//  Get number of drive blocks
//

Error GenericFileSystem::GetNumberOfDriveBlocks(DWORD & num)
	{
	VDAutoMutex mutex(&lock);

	if (genericVolume)
		return genericVolume->GetNumberOfDriveBlocks(num);
	else
		GNRAISE(GNR_NO_VOLUME);
	}

//
//  Set number of drive blocks
//

Error GenericFileSystem::SetNumberOfDriveBlocks(DWORD num)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}

//
//  Seek block
//

Error GenericFileSystem::SeekBlock(DWORD block, DWORD flags, RequestHandle * rh)
	{
	VDAutoMutex mutex(&lock);

	if (genericVolume)
		return genericVolume->SeekBlock(logicalBaseBlock + block, flags, rh);
	else
		GNRAISE(GNR_NO_VOLUME);
	}

//
//  Lock blocks
//

Error GenericFileSystem::LockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh)
	{
	VDAutoMutex mutex(&lock);

	if (genericVolume)
		GNRAISE(genericVolume->LockBlocks(logicalBaseBlock + block, num, blocks, flags, rh));
	else
		GNRAISE(GNR_NO_VOLUME);
	}

//
//  Unlock blocks
//

Error GenericFileSystem::UnlockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh)
	{
	VDAutoMutex mutex(&lock);

	if (genericVolume)
		GNRAISE(genericVolume->UnlockBlocks(logicalBaseBlock + block, num, blocks, flags, rh));
	else
		GNRAISE(GNR_NO_VOLUME);
	}

//
//  Terminate current request
//

Error GenericFileSystem::TerminateRequest(RequestHandle * rh)
	{
	VDAutoMutex mutex(&lock);

	if (genericVolume)
		GNRAISE(genericVolume->TerminateRequest(rh));
	else
		GNRAISE(GNR_NO_VOLUME);
	}

//
//  Flush everything
//

Error GenericFileSystem::Flush(void)
	{
	VDAutoMutex mutex(&lock);

	if (genericVolume)
		GNRAISE(genericVolume->Flush());
	else
		GNRAISE(GNR_NO_VOLUME);
	}

//
//  Get name of drive
//

Error GenericFileSystem::GetDriveName(KernelString & name)
	{
	VDAutoMutex mutex(&lock);

	if (genericVolume)
		return genericVolume->GetDriveName(name);
	else
		GNRAISE(GNR_NO_VOLUME);
	}

//
//  Get drive capabilities
//

#if MSNDISC
Error GenericFileSystem::GetDriveCaps(GenericDriveType & type, DWORD & caps, DWORD & slots, DWORD& positions, DWORD& changerOpenOffset)
	{
	VDAutoMutex mutex(&lock);

	if (genericVolume)
		return genericVolume->GetDriveCaps(type, caps, slots,positions,changerOpenOffset);
	else
		GNRAISE(GNR_NO_VOLUME);
	}
#else
Error GenericFileSystem::GetDriveCaps(GenericDriveType & type, DWORD & caps, DWORD & slots)
	{
	VDAutoMutex mutex(&lock);

	if (genericVolume)
		return genericVolume->GetDriveCaps(type, caps, slots);
	else
		GNRAISE(GNR_NO_VOLUME);
	}
#endif
//
//  Wake up the drive
//

Error GenericFileSystem::SpinUpDrive(void)
	{
	VDAutoMutex mutex(&lock);

	if (genericVolume)
		GNRAISE(genericVolume->SpinUpDrive());
	else
		GNRAISE(GNR_NO_VOLUME);
	}

//
//  Stop the drive
//

Error GenericFileSystem::SpinDownDrive(void)
	{
	VDAutoMutex mutex(&lock);

	if (genericVolume)
		GNRAISE(genericVolume->SpinDownDrive());
	else
		GNRAISE(GNR_NO_VOLUME);
	}


//
// Get Path name of item
//
Error GenericFileSystem::GetPathName(DiskItemName & name, GenericFileSystemIterator * where)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}

Error GenericFileSystem::GetDTSInfo(BOOL & isDTS, GenericCopyManagementInfo & gcmi)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}


//
//  Find item in (sub)directory
//  GNR_OK: Item was found
//  GNR_ITEM_NOT_FOUND: Item was not found
//  GNR_...: Some error accessing the disk occurred
//

Error GenericFileSystem::FindItem(const DiskItemName & name, DiskItemType type, DWORD flags,
											 GenericFileSystemIterator * where, GenericFileSystemIterator * & result)
	{
	GenericFileSystemIterator * where2;
	DiskItemName frontComp;
	DiskItemName tail = name;
	Error err;

	if (name.IsRelative())
		{
		//
		//  If we have a relative path name then we have to go down all the directories (path components) specified
		//

		GNREASSERT(where->Clone(where2));
		}
	else
		{
		//
		//  With an absolute path name the search must start at the root directory
		//

		GNREASSERT(CreateIterator(where2));
		flags &= ~FIF_RECURSIVE;
		}

	//
	//  Now repeat search over all path components
	//

	while (TRUE)
		{
		frontComp = tail.GetFront();
		GNREASSERT(tail.RemoveFrontComp());
		if (frontComp.Length() == 0)		// We reached the last component, so the type must match
			{
			err = InternalFindItem(tail, type, flags, where2, result);
			break;
			}
		else
			{
			if (IS_ERROR(err = InternalFindItem(frontComp, DIT_DIR, flags, where2, result)))
				break;

			delete where2;
			err = result->GoToSubDir(where2);
			delete result;
			if (IS_ERROR(err))
				{
				where2 = NULL;
				break;
				}

			flags &= ~FIF_RECURSIVE;		// The first path component may be searched recursively, but them it has to be non-recursive
			}
		}

	delete where2;
	GNRAISE(err);
	}

//
//  Internal find item
//

Error GenericFileSystem::InternalFindItem(DiskItemName & name, DiskItemType type, DWORD flags,
														GenericFileSystemIterator * where, GenericFileSystemIterator * & result)
	{
	GenericFileSystemIterator * subDir;
	DiskItemType dit;
	DiskItemName itemName;
	Error err = GNR_OK;
	DWORD dinmFlags = ((flags & FIF_CASE_SENSITIVE) ? DINM_CASE_SENSITIVE : DINM_NONE);

	GNREASSERT(where->GoToFirstItem());

	while (!IS_ERROR(err))
		{
		GNREASSERT(where->GetItemType(dit));

		//
		//  Check if type and name match
		//

		if (dit == type || type == DIT_ALL)
			{
			GNREASSERT(where->GetItemName(itemName));
			if (itemName.Matches(name, dinmFlags))
				GNRAISE(where->Clone(result));
			}

		//
		//  If it's a dir the recursively check the sub dirs (if wanted)
		//

		if ((flags & FIF_RECURSIVE) && dit == DIT_DIR)
			{
			GNREASSERT(where->GoToSubDir(subDir));
			err = InternalFindItem(name, type, dinmFlags, subDir, result);
			delete subDir;

			if (err != GNR_ITEM_NOT_FOUND)
				GNRAISE(err);
			}

		err = where->GoToNextItem();
		}

	GNRAISE(GNR_ITEM_NOT_FOUND);
	}

//
//  Open item by name
//

Error GenericFileSystem::OpenItem(const DiskItemName & name, DWORD accessType, GenericDiskItem * & gdi)
	{
	GenericFileSystemIterator * where;
	GenericFileSystemIterator * item;
	DWORD findFlags = FIF_NONE;
	Error err;

	//
	//  Find item
	//

//	DiskItemName n = name;
//	DP("Open File %s", (char*)n);
	GNREASSERT(CreateIterator(where));

	if (accessType & FAT_RECURSIVE)
		findFlags = FIF_RECURSIVE;
	if (accessType & FAT_CASE_SENSITIVE)
		findFlags = FIF_CASE_SENSITIVE;

	err = FindItem(name, DIT_ALL, findFlags, where, item);

	if (!IS_ERROR(err))
		{
		err = item->OpenItem(accessType, gdi);
		delete item;
		}

	delete where;
	GNRAISE(err);
	}

//
//  Open item by iterator
//

Error GenericFileSystem::OpenItem(GenericFileSystemIterator * gfsi, DWORD accessType, GenericDiskItem * & gdi)
	{
	VDAutoMutex mutex(&lock);
	DiskItemType type;
	GenericFile * gf;
	GenericDirectory * gd;
	Error err;

	GNREASSERT(gfsi->GetItemType(type));
	switch (type)
		{
		case DIT_FILE:
			GNREASSERT(CreateFile(accessType, gf));
			gdi = gf;
			break;
		case DIT_DIR:
			GNREASSERT(CreateDirectory(accessType, gd));
			gdi = gd;
			break;
		default:
			GNRAISE(GNR_OBJECT_INVALID);
		}

	if (IS_ERROR(err = gdi->Open(gfsi, accessType)))
		delete gdi;

	GNRAISE(err);
	}

//
//  Get extended item information
//

Error GenericFileSystem::GetExtItemInfo(GenericFileSystemIterator * gfsi, ExtItemInfo & info)
	{
	info.exType = EDIT_NONE;
	GNRAISE_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\files\ISOFile.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  ISO 9660 File Classes
//
//  NOTE: ISOFile, ISODirectory and ISOIterator have protected
//  constructors so they can only be created by the file system
//  (must be friend). Only copy constructor is public.
//
////////////////////////////////////////////////////////////////////

#ifndef ISOFILE_H
#define ISOFILE_H

#include "library/Files/GenericFile.h"
#include "library/Files/CDVDVolume.h"

////////////////////////////////////////////////////////////////////
//
//  Defines
//
////////////////////////////////////////////////////////////////////

#define ISO_BLOCK_SIZE 2048

class ISOFile;
class ISODirectory;
class ISOIterator;
class ISOFileSystem;

////////////////////////////////////////////////////////////////////
//
//  ISO File Class
//
////////////////////////////////////////////////////////////////////

class ISOFile : public GenericFile
	{
	friend class ISOFileSystem;

	protected:
		ISOFileSystem * isofs;
		ISOIterator * isoi;
		KernelInt64 size;

		ISOFile(ISOFileSystem * isofs);

		virtual Error BuildUniqueKey(void);

	public:
		virtual ~ISOFile(void);

		virtual Error Open(GenericFileSystemIterator * gfsi, DWORD accesType);
		virtual Error Close(void);

		//
		//  Misc. inquiry
		//

		virtual Error GetName(DiskItemName & name);
		virtual Error GetPathName(DiskItemName & name);
		virtual Error GetSize(KernelInt64 & size);
		virtual Error GetIterator(GenericFileSystemIterator * & gfsi);
		virtual Error GetCopyManagementInfo(GenericCopyManagementInfo & gcmi);

		//
		//  Access functions
		//

		virtual Error SeekBlock(DWORD block, DWORD flags, RequestHandle * rh);
		virtual Error LockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh);
		virtual Error UnlockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh);
	};

////////////////////////////////////////////////////////////////////
//
//  ISO Directory Class
//
////////////////////////////////////////////////////////////////////

#if GFS_ENABLE_DIRECTORIES

class ISODirectory : public GenericDirectory
	{
	friend class ISOFileSystem;

	protected:
		ISOFileSystem * isofs;
		ISOIterator * isoi;

		ISODirectory(ISOFileSystem * isofs);

	public:
		virtual ~ISODirectory(void);

		virtual Error Open(GenericFileSystemIterator * gfsi, DWORD accessType);
		virtual Error Close(void);

		//
		//  Inquiry
		//

		virtual Error GetName(DiskItemName & name);
		virtual Error GetPathName(DiskItemName & name);
		virtual Error GetIterator(GenericFileSystemIterator * & gfsi);

		//
		//  Item handling
		//

		virtual Error CreateItem(DWORD diskItemType, const DiskItemName & name, GenericDiskItem * & gdi);
		virtual Error DeleteItem(GenericFileSystemIterator * gfsi);

		virtual Error GetNumberOfItems(DWORD & num);
		virtual Error FindItem(const DiskItemName & name, DiskItemType type, DWORD flags, GenericFileSystemIterator * & gfsi);
	};

#endif

////////////////////////////////////////////////////////////////////
//
//  ISO File System Iterator Class
//  Represents an ISO directory record (and a little more)
//
////////////////////////////////////////////////////////////////////

class ISOIterator : public GenericFileSystemIterator
	{
	friend class ISOFileSystem;

	protected:
		DWORD dirStart;		// Start block of the dir we are in
		DWORD dirSize;			// Length of the dir we are in
		DWORD entryOffset;	// Offset to this entry within entryBlock

		//
		//  Constructor
		//

		ISOIterator(GenericFileSystem * gfs, DWORD dirStart, DWORD dirSize);
		ISOIterator(GenericFileSystem * gfs, DWORD dirStart, DWORD dirSize, DWORD entryOffset);

		virtual BOOL Equals(GenericFileSystemIterator * gfsi);

	public:
		virtual ~ISOIterator(void);

		virtual Error Clone(GenericFileSystemIterator * & gfsi) const;
		virtual Error Clone(ISOIterator * & isoi) const;

		//
		//  Directory Handling
		//

		virtual Error GoToFirstItem(void);
		virtual Error GoToNextItem(void);
		virtual Error GoToSubDir(GenericFileSystemIterator * & gfsi);
		virtual Error GoToParentDir(GenericFileSystemIterator * & gfsi);

		//
		//  Inquiry
		//

		virtual Error GetPathName(DiskItemName & name);
		virtual Error GetItemType(DiskItemType & type);
		virtual Error GetItemName(DiskItemName & name);
		virtual Error GetItemSize(KernelInt64 & size);
		virtual Error GetNumberOfItems(DWORD & num);
		virtual Error GetCurrentDir(GenericDirectory * & gd);

		//
		//  File Access
		//

		virtual Error OpenItem(DWORD accessType, GenericDiskItem * & gdi);
	};

////////////////////////////////////////////////////////////////////
//
//   ISO File System Class
//
////////////////////////////////////////////////////////////////////

enum ISOUnicodeType
	{
	IUT_NONE,
	IUT_UCS2_L1,
	IUT_UCS2_L2,
	IUT_UCS2_L3
	};

class ISOFileSystem : public GenericFileSystem
	{
	friend class ISOFile;
	friend class ISODirectory;
	friend class ISOIterator;

	protected:
		CDVDVolume * cdvdVolume;

		RequestHandle rh;					// For internal directory operations
		DriveBlock driveBlock;			// For internal directory operations
		PathStringCache cache;			// For caching paths, marked by the dir start block
		DWORD rootDirStart;				// Start block of root directory
		DWORD rootDirSize;				// Size of root directory
		ISOUnicodeType	unicodeType;	// The type of unicode used for directory entries

		//
		//  Factory Methods
		//

				  Error CreateIterator(ISOIterator * & isoi, DWORD dirStart, DWORD dirSize);
		virtual Error CreateIterator(ISOIterator * & isoi);
		virtual Error CreateIterator(GenericFileSystemIterator * & gfsi);
		virtual Error CreateFile(DWORD flags, GenericFile * & gf);
		virtual Error CreateDirectory(DWORD flags, GenericDirectory * & gd);

		//
		//  Item handling
		//

		Error	GoToFirstItem(ISOIterator * isoi);
		Error	GoToNextItem(ISOIterator * isoi);
		Error	GoToSubDir(ISOIterator * isoi, GenericFileSystemIterator * & gfsi);
		Error	GoToParentDir(ISOIterator * isoi, GenericFileSystemIterator * & gfsi);

		Error GetPathName(ISOIterator * isoi, DiskItemName & name);
		Error GetItemType(ISOIterator * isoi, DiskItemType & type);
		Error GetItemName(ISOIterator * isoi, DiskItemName & name);
		Error GetItemSize(ISOIterator * isoi, KernelInt64 & size);

		Error GetDir(ISOIterator * isoi, GenericDirectory * & gd);
		Error GetNumberOfItems(ISOIterator * isoi, DWORD & num);

		//
		//  Internal helper functions
		//

		Error ReadByte(DWORD block, DWORD offset, BYTE & b);
		Error ReadWord(DWORD block, DWORD offset, WORD & w);
		Error ReadDWord(DWORD block, DWORD offset, DWORD & d);
		Error ReadQWord(DWORD block, DWORD offset, KernelInt64 & q);
		Error BuildUniqueKey(void);
		Error GetStartBlock(ISOIterator * isoi, DWORD & startBlock);
		Error ReadXASUInfo(ISOIterator * isoi, WORD & sui);

	public:
		//
		//  Con/Destruction, initialization
		//

		ISOFileSystem(void);
		virtual ~ISOFileSystem(void);

		virtual Error Init(GenericFileSystemIterator * mountPoint, GenericVolume * volume, GenericProfile * profile);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\files\ISOFile.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  ISO 9660 File Classes
//
////////////////////////////////////////////////////////////////////

#include "library/files/ISOFile.h"

////////////////////////////////////////////////////////////////////
//
//  Internal defines
//
////////////////////////////////////////////////////////////////////

//
//  Volume descriptor types
//

#define ISO_VDT_BOOT				0
#define ISO_VDT_PRIMARY			1
#define ISO_VDT_SUPPLEMENT		2
#define ISO_VDT_PARTITION		3
#define ISO_VDT_TERMINATOR		255

//
//  Directory record offsets
//

#define ISO_DR_LEN			0		// 1 byte
#define ISO_DR_EAD_LEN		1		// 1 byte
#define ISO_DR_EXT_LOC		2		// 8 bytes
#define ISO_DR_EXT_LEN		10		// 8 bytes
#define ISO_DR_FLAGS			25		// 1 byte
#define ISO_DR_FID_LEN		32		// 1 byte
#define ISO_DR_FID			33		// Beginning of file identifier

//
//  File flags in directory record (values are bit numbers)
//

#define ISO_FILE_EXIST		0x01		// 1 for a hidden file
#define ISO_FILE_DIR			0x02		// 1 if record identifies directory
#define ISO_FILE_ASSOC		0x04		// 1 if associated file
#define ISO_FILE_RECORD		0x08		// 1 if file format specified by extended attribute record
#define ISO_FILE_PROTECT	0x10		//	1 if access rights are specified
#define ISO_FILE_MULTIEXT	0x80		// 1 if record is not the final record of directory

//
//  Flags for System Use field (bytes 4 and 5, 5 being MSB)
//

#define ISO_SUI_OWNER_READ				0x0001
#define ISO_SUI_OWNER_EXEC				0x0004
#define ISO_SUI_GROUP_READ				0x0010
#define ISO_SUI_GROUP_EXEC				0x0040
#define ISO_SUI_WORLD_READ				0x0100
#define ISO_SUI_WORLD_EXEC				0x0400
#define ISO_SUI_FILE_FORM1				0x0800
#define ISO_SUI_FILE_FORM2				0x1000
#define ISO_SUI_FILE_INTERLEAVED		0x2000
#define ISO_SUI_FILE_CDDA				0x4000
#define ISO_SUI_FILE_IS_DIR			0x8000

//
//  Defines for Suplementary Volume Descriptor
//

#define ISO_SVD_ESCAPE		88
#define ISO_SVD_ESCAPE_LEN	32

//
//  Data access macros (d must be BYTE*)
//

#define ISO_DWORD(d)		(MAKELONG4((d)[0], (d)[1], (d)[2], (d)[3]))
#define ISO_WORD(d)		(MAKEWORD((d)[0], (d)[1]))
#define ISO_BYTE(d)		((d)[0])

////////////////////////////////////////////////////////////////////
//
//  ISO File Class
//
////////////////////////////////////////////////////////////////////

//
//  Constructor
//

ISOFile::ISOFile(ISOFileSystem * isofs) : GenericFile(isofs)
	{
	this->isofs = isofs;
	isoi = NULL;
	}

//
//  Destructor
//

ISOFile::~ISOFile(void)
	{
	Close();
	}

//
//  Open file
//

Error ISOFile::Open(GenericFileSystemIterator * gfsi, DWORD accessType)
	{
	GenericFileSystemIterator * gfsi2;
	Error err;

	if (accessType & FAT_WRITE)
		GNRAISE(GNR_FILE_READ_ONLY);

	GNREASSERT(GenericFile::Open(gfsi, accessType));

	GNREASSERT(gfsi->Clone(gfsi2));
	isoi = (ISOIterator*)gfsi2;

	err = isofs->GetStartBlock(isoi, startBlock);
	if (!IS_ERROR(err))
		err = isofs->GetItemSize(isoi, size);

	if (IS_ERROR(err))
		{
		delete isoi;
		isoi = NULL;
		}

	GNRAISE(err);
	}

//
//  Close file
//

Error ISOFile::Close(void)
	{
	delete isoi;
	isoi = NULL;
	GNRAISE_OK;
	}

//
//  Get name
//

Error ISOFile::GetName(DiskItemName & name)
	{
	return isofs->GetItemName(isoi, name);
	}

//
//  Get path name
//

Error ISOFile::GetPathName(DiskItemName & name)
	{
	return isofs->GetPathName(isoi, name);
	}

//
//  Get size
//

Error ISOFile::GetSize(KernelInt64 & size)
	{
	size = this->size;
	GNRAISE_OK;
	}

//
//  Get iterator
//

Error ISOFile::GetIterator(GenericFileSystemIterator * & gfsi)
	{
	return isoi->Clone(gfsi);
	}

//
//  Build unique key
//

Error ISOFile::BuildUniqueKey(void)
	{
	GNRAISE_OK;
	}

//
//  Get copy management mode
//

Error ISOFile::GetCopyManagementInfo(GenericCopyManagementInfo & gcmi)
	{
	gcmi = GCMI_COPY_FORBIDDEN;
	GNRAISE_OK;
	}

//
//  Seek block
//

Error ISOFile::SeekBlock(DWORD block, DWORD flags, RequestHandle * rh)
	{
	if (block * isofs->blockSize >= size)
		GNRAISE(GNR_INVALID_PARAMETERS);

	return isofs->SeekBlock(block, flags, rh);
	}

//
//  Lock blocks
//

Error ISOFile::LockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh)
	{
//	if ((block + num - 1) * isofs->blockSize >= size)
//		GNRAISE(GNR_INVALID_PARAMETERS);
	if (headerFile)
		flags = (flags & ~GD_SECTOR_TYPE_MASK) | isofs->GetHeaderSectorType();
	else
		flags = (flags & ~GD_SECTOR_TYPE_MASK) | isofs->GetDataSectorType();

	return isofs->LockBlocks(startBlock + block, num, blocks, flags, rh);
	}

//
//  Unlock blocks
//

Error ISOFile::UnlockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh)
	{
//	if ((block + num - 1) * isofs->blockSize >= size)
//		GNRAISE(GNR_INVALID_PARAMETERS);
	if (headerFile)
		flags = (flags & ~GD_SECTOR_TYPE_MASK) | isofs->GetHeaderSectorType();
	else
		flags = (flags & ~GD_SECTOR_TYPE_MASK) | isofs->GetDataSectorType();

	return isofs->UnlockBlocks(startBlock + block, num, blocks, flags, rh);
	}

////////////////////////////////////////////////////////////////////
//
//  ISO Directory Class
//
////////////////////////////////////////////////////////////////////

#if GFS_ENABLE_DIRECTORIES

//
//  Constructor
//

ISODirectory::ISODirectory(ISOFileSystem * isofs) : GenericDirectory(isofs)
	{
	this->isofs = isofs;
	isoi = NULL;
	}

//
//  Destructor
//

ISODirectory::~ISODirectory(void)
	{
	Close();
	}

//
//  Open directory
//

Error ISODirectory::Open(GenericFileSystemIterator * gfsi, DWORD accessType)
	{
	GenericFileSystemIterator * gfsi2;

	if (accessType & FAT_WRITE)
		GNRAISE(GNR_FILE_READ_ONLY);

	GNREASSERT(gfsi->Clone(gfsi2));
	isoi = (ISOIterator*)gfsi2;

	GNRAISE_OK;
	}

//
//  Close
//

Error ISODirectory::Close(void)
	{
	delete isoi;
	isoi = NULL;
	GNRAISE_OK;
	}

//
//  Get name
//

Error ISODirectory::GetName(DiskItemName & name)
	{
	return isofs->GetItemName(isoi, name);
	}

//
//  Get path name
//

Error ISODirectory::GetPathName(DiskItemName & name)
	{
	return isofs->GetPathName(isoi, name);
	}

//
//  Get iterator
//

Error ISODirectory::GetIterator(GenericFileSystemIterator * & gfsi)
	{
	return isoi->Clone(gfsi);
	}

//
//  Create item
//

Error ISODirectory::CreateItem(DWORD diskItemType, const DiskItemName & name, GenericDiskItem * & gdi)
	{
	GNRAISE(GNR_DISK_READ_ONLY);
	}

//
//  Delete item
//

Error ISODirectory::DeleteItem(GenericFileSystemIterator * gfsi)
	{
	GNRAISE(GNR_DISK_READ_ONLY);
	}

//
//  Get number of items in dir
//

Error ISODirectory::GetNumberOfItems(DWORD & num)
	{
	return isofs->GetNumberOfItems(isoi, num);
	}

//
//  Find item
//

Error ISODirectory::FindItem(const DiskItemName & name, DiskItemType type, DWORD flags, GenericFileSystemIterator * & gfsi)
	{
	GenericFileSystemIterator * where;
	Error err;

	GNREASSERT(GetIterator(where));
	if (!IS_ERROR(err = isofs->FindItem(name, type, flags, where, gfsi)))
		delete where;
	GNRAISE(err);
	}

#endif

////////////////////////////////////////////////////////////////////
//
//  ISO File System Iterator Class
//
////////////////////////////////////////////////////////////////////

//
//  Constructor
//

ISOIterator::ISOIterator(GenericFileSystem * gfs, DWORD dirStart, DWORD dirSize) : GenericFileSystemIterator(gfs)
	{
	this->dirStart = dirStart;
	this->dirSize = dirSize;
	((ISOFileSystem*)gfs)->GoToFirstItem(this);
	}

//
//  Constructor
//

ISOIterator::ISOIterator(GenericFileSystem * gfs, DWORD dirStart, DWORD dirSize, DWORD entryOffset) : GenericFileSystemIterator(gfs)
	{
	this->dirStart = dirStart;
	this->dirSize = dirSize;
	this->entryOffset = entryOffset;
	}

//
//  Destructor
//

ISOIterator::~ISOIterator(void)
	{
	}

//
//  Clone
//

Error ISOIterator::Clone(ISOIterator * & isoi) const
	{
	isoi = new ISOIterator(gfs, dirStart, dirSize, entryOffset);
	if (isoi)
		GNRAISE_OK;
	else
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
	}

//
//  Clone
//

Error ISOIterator::Clone(GenericFileSystemIterator * & gfsi) const
	{
	gfsi = new ISOIterator(gfs, dirStart, dirSize, entryOffset);
	if (gfsi)
		GNRAISE_OK;
	else
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
	}

//
//  Comparison function
//

BOOL ISOIterator::Equals(GenericFileSystemIterator * gfsi)
	{
	GNRAISE( (dirStart    == ((ISOIterator*)gfsi)->dirStart) &&
				(entryOffset == ((ISOIterator*)gfsi)->entryOffset));
	}

//
//  Go to first item
//

Error ISOIterator::GoToFirstItem(void)
	{
	GNRAISE(((ISOFileSystem*)gfs)->GoToFirstItem(this));
	}

//
//  Go to next item
//

Error ISOIterator::GoToNextItem(void)
	{
	GNRAISE(((ISOFileSystem*)gfs)->GoToNextItem(this));
	}

//
//  Go to sub dir
//

Error ISOIterator::GoToSubDir(GenericFileSystemIterator * & gfsi)
	{
	GNRAISE(((ISOFileSystem*)gfs)->GoToSubDir(this, gfsi));
	}

//
//  Go to parent dir
//

Error ISOIterator::GoToParentDir(GenericFileSystemIterator * & gfsi)
	{
	GNRAISE(((ISOFileSystem*)gfs)->GoToParentDir(this, gfsi));
	}

//
//  Get path name
//

Error ISOIterator::GetPathName(DiskItemName & name)
	{
	GNRAISE(((ISOFileSystem*)gfs)->GetPathName(this, name));
	}

//
//  Get item type
//

Error ISOIterator::GetItemType(DiskItemType & type)
	{
	GNRAISE(((ISOFileSystem*)gfs)->GetItemType(this, type));
	}

//
//  Get item name
//

Error ISOIterator::GetItemName(DiskItemName & name)
	{
	GNRAISE(((ISOFileSystem*)gfs)->GetItemName(this, name));
	}

//
//  Get item size
//

Error ISOIterator::GetItemSize(KernelInt64 & size)
	{
	GNRAISE(((ISOFileSystem*)gfs)->GetItemSize(this, size));
	}

//
//  Get number of items in the directory the iterator is in
//

Error ISOIterator::GetNumberOfItems(DWORD & num)
	{
	GNRAISE(((ISOFileSystem*)gfs)->GetNumberOfItems(this, num));
	}

//
//  Get current directory
//

Error ISOIterator::GetCurrentDir(GenericDirectory * & gd)
	{
	GNRAISE(((ISOFileSystem*)gfs)->GetDir(this, gd));
	}

//
//  Open item
//

Error ISOIterator::OpenItem(DWORD accessType, GenericDiskItem * & gdi)
	{
	GNRAISE(((ISOFileSystem*)gfs)->OpenItem(this, accessType, gdi));
	}

////////////////////////////////////////////////////////////////////
//
//   ISO File System Class
//
////////////////////////////////////////////////////////////////////

//
//  Constructor
//

ISOFileSystem::ISOFileSystem(void) : GenericFileSystem()
	{
	cdvdVolume = NULL;
	fileSystemType = FS_ISO;
	}

//
//  Destructor
//

ISOFileSystem::~ISOFileSystem(void)
	{
	}

//
//  Initialize
//

Error ISOFileSystem::Init(GenericFileSystemIterator * mountPoint, GenericVolume * volume, GenericProfile * profile)
	{
	VDAutoMutex mutex(&lock);
	DWORD pvdBlock;
	DWORD descSeqStart;	// The beginning of the volume descriptor sequence on either DVD or CD-ROM
	CDSessionType sessionType = CST_NONE;
	PhysicalDiskType diskType;
	Error err;
	BOOL valid = FALSE;
	WORD retry = 16;
	DriveBlock driveBlock;
	int pos;
	int i;

	if (cdvdVolume)
		GNRAISE(GNR_OBJECT_IN_USE);

	GNREASSERT(GenericFileSystem::Init(mountPoint, volume, profile));

	//
	//  Determine location of Volume descriptor sequence
	//  Must be in first track of last session (if this is a data track)
	//

	GNREASSERT(volume->GetDiskType(diskType));
	cdvdVolume = (CDVDVolume*)volume;
	switch (diskType)
		{
		case PHDT_CDROM:
		case PHDT_CDI:
		case PHDT_CDROM_XA:
			{
			WORD sessions;
			CDTocEntry * toc;
			WORD tocEntryNum;

			//
			//  Determine number of sessions
			//

			GNREASSERT(cdvdVolume->GetNumberOfSessions(sessions));
			if (sessions == 0)
				GNRAISE(GNR_VOLUME_INVALID);

			DP("There are %d sessions", sessions);

			//
			//  Get base block, which is first block of first track in first session
			//

			GNREASSERT(cdvdVolume->ReadCDTOC(1, sessionType, toc, tocEntryNum, &rh));
			logicalBaseBlock = toc[0].GetStartBlock();
			delete[] toc;

			//
			//  Get descriptor sequence start block, block 16 of first track of last session
			//

			if (sessions > 1)
				{
				GNREASSERT(cdvdVolume->ReadCDTOC(sessions, sessionType, toc, tocEntryNum, &rh));
				descSeqStart = toc[0].GetStartBlock() + 15 - logicalBaseBlock;		// Start with one less (should be 16) because we increment first
																										// Also this already includes the logicalBaseBlock
				delete[] toc;
				}
			else
				descSeqStart = 15;
			break;
			}
		case PHDT_DVD_ROM:
			descSeqStart = 15;
			logicalBaseBlock = 0;
			break;
		default:
			GNRAISE(GNR_VOLUME_INVALID);
		}

	//
	//  Find Primary And Supplementary Volume Descriptor
	//

	unicodeType = IUT_NONE;
	pvdBlock = descSeqStart;
	rootDirSize = 0;

	do
		{
		pvdBlock++;
		if (IS_ERROR(err = LockBlocks(pvdBlock, 1, &driveBlock, headerSectorType | DAT_LOCK_AND_READ, &rh)))
			{
			UnlockBlocks(pvdBlock, 1, &driveBlock, headerSectorType | DAT_UNLOCK_CLEAN, &rh);
			GNRAISE(err);
			}

		//
		//  Check standard identifier and on Volume Descriptor Set Terminator
		//  If standard is not correct or Terminator reached then we're f***ed
		//

		if (valid = ((driveBlock.data[dataHeaderSize + 1] == 'C') &&
						 (driveBlock.data[dataHeaderSize + 2] == 'D') &&
						 (driveBlock.data[dataHeaderSize + 3] == '0') &&
						 (driveBlock.data[dataHeaderSize + 4] == '0') &&
						 (driveBlock.data[dataHeaderSize + 5] == '1')))
			{
			//
			//  Now check which type of volume descriptor we have
			//

			if (driveBlock.data[dataHeaderSize] == ISO_VDT_TERMINATOR)
				{
				retry = 1;	// Exit loop
				}
			else if (driveBlock.data[dataHeaderSize] == ISO_VDT_PRIMARY)
				{
				//
				//  Initialize misc
				//

				volumeName = DiskItemName((char*)(driveBlock.data + dataHeaderSize + 40), 32);
				volumeSetSize = ISO_WORD(driveBlock.data + dataHeaderSize + 120);
				volumeSetIndex = ISO_WORD(driveBlock.data + dataHeaderSize + 124);
				volumeSetName = DiskItemName((char*)(driveBlock.data + dataHeaderSize + 190), 128);

				//
				//  Read root directory record
				//

				rootDirStart = ISO_DWORD(driveBlock.data + dataHeaderSize + 156 + 2);
				rootDirSize = ISO_DWORD(driveBlock.data + dataHeaderSize + 156 + 10);

				//
				//  Compute unique key from time stamp
				//

				for (i=0; i<8; i++)
					uniqueKey.key[i] = ISO_BYTE(driveBlock.data + dataHeaderSize + 813 + i) ^
											 ISO_BYTE(driveBlock.data + dataHeaderSize + 821 + i);
				}
			else if (driveBlock.data[dataHeaderSize] == ISO_VDT_SUPPLEMENT)
				{
				DWORD tmpRootDirStart = ISO_DWORD(driveBlock.data + dataHeaderSize + 156 + 2);
				DWORD tmpRootDirSize = ISO_DWORD(driveBlock.data + dataHeaderSize + 156 + 10);

				BYTE drLen = 0;
				GNREASSERT(ReadByte(tmpRootDirStart, ISO_DR_LEN, drLen));

 				if (drLen > 1)
					{
					rootDirStart = tmpRootDirStart;
					rootDirSize	= tmpRootDirSize;
					}

				//
				//  Look for Joliet Unicode character escape sequence
				//

				pos = dataHeaderSize + ISO_SVD_ESCAPE;
				for (i=0; i<ISO_SVD_ESCAPE_LEN -2 ; i++)
					{
					if (driveBlock.data[pos] == 0x25 && driveBlock.data[pos + 1] == 0x2f)
						{
						switch (driveBlock.data[pos + 2])
							{
							case 0x40:
								unicodeType = IUT_UCS2_L1;
								break;
							case 0x43:
								unicodeType = IUT_UCS2_L2;
								break;
							case 0x45:
								unicodeType = IUT_UCS2_L3;
								break;
							}
						}
					pos++;
					}
				}
			}

		UnlockBlocks(pvdBlock, 1, &driveBlock, headerSectorType | DAT_UNLOCK_CLEAN, &rh);
		retry--;
		}
	while (retry);

	if (!rootDirSize)		// No PVD found
		GNRAISE(GNR_VOLUME_INVALID);

	GNRAISE_OK;
	}

//
//  Read BYTE (directory block only)
//

Error ISOFileSystem::ReadByte(DWORD block, DWORD offset, BYTE & b)
	{
	Error err = GNR_OK;
	block += offset / headerDataSize;
	offset = (offset % headerDataSize) + headerHeaderSize;

	if (!IS_ERROR(err = LockBlocks(block, 1, &driveBlock, headerSectorType | DAT_LOCK_AND_READ | DAF_CACHED, &rh)))
		b = ISO_BYTE(driveBlock.data + offset);
	UnlockBlocks(block, 1, &driveBlock, headerSectorType | DAT_UNLOCK_CLEAN | DAF_CACHED, &rh);
	GNRAISE(err);
	}

//
//  Read WORD (directory block only)
//

Error ISOFileSystem::ReadWord(DWORD block, DWORD offset, WORD & w)
	{
	Error err = GNR_OK;
	block += offset / headerDataSize;
	offset = (offset % headerDataSize) + headerHeaderSize;

	if (offset + 2 < blockSize)
		{
		if (!IS_ERROR(err = LockBlocks(block, 1, &driveBlock, headerSectorType | DAT_LOCK_AND_READ | DAF_CACHED, &rh)))
			w = ISO_WORD(driveBlock.data + offset);
		UnlockBlocks(block, 1, &driveBlock, headerSectorType | DAT_UNLOCK_CLEAN | DAF_CACHED, &rh);
		GNRAISE(err);
		}
	else
		{
		GNREASSERT(ReadByte(block, offset, ((BYTE*)&w)[0]));
		return ReadByte(block, offset + 1, ((BYTE*)&w)[1]);
		}
	}

//
//  Read DWORD (directory block only)
//

Error ISOFileSystem::ReadDWord(DWORD block, DWORD offset, DWORD & d)
	{
	Error err = GNR_OK;
	block += offset / headerDataSize;
	offset = (offset % headerDataSize) + headerHeaderSize;

	if (offset + 4 < blockSize)
		{
		if (!IS_ERROR(err = LockBlocks(block, 1, &driveBlock, headerSectorType | DAT_LOCK_AND_READ | DAF_CACHED, &rh)))
			d = ISO_DWORD(driveBlock.data + offset);
		UnlockBlocks(block, 1, &driveBlock, headerSectorType | DAT_UNLOCK_CLEAN | DAF_CACHED, &rh);
		GNRAISE(err);
		}
	else
		{
		GNREASSERT(ReadByte(block, offset, ((BYTE*)&d)[0]));
		GNREASSERT(ReadByte(block, offset + 1, ((BYTE*)&d)[1]));
		GNREASSERT(ReadByte(block, offset + 2, ((BYTE*)&d)[2]));
		return ReadByte(block, offset + 3, ((BYTE*)&d)[3]);
		}
	}

//
//  Create iterator
//

Error ISOFileSystem::CreateIterator(ISOIterator * & isoi, DWORD dirStart, DWORD dirSize)
	{
	isoi = new ISOIterator(this, dirStart, dirSize);
	if (isoi)
		GNRAISE_OK;
	else
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
	}

//
//  Create iterator
//

Error ISOFileSystem::CreateIterator(ISOIterator * & isoi)
	{
	return CreateIterator(isoi, rootDirStart, rootDirSize);
	}

//  Create iterator
//

Error ISOFileSystem::CreateIterator(GenericFileSystemIterator * & gfsi)
	{
	ISOIterator * isoi;

	GNREASSERT(CreateIterator(isoi, rootDirStart, rootDirSize));
	gfsi = isoi;
	GNRAISE_OK;
	}

//
//	 Create file
//

Error ISOFileSystem::CreateFile(DWORD flags, GenericFile * & gf)
	{
	gf = new ISOFile(this);
	if (gf)
		GNRAISE_OK;
	else
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
	}

//
//  Create directory
//

Error ISOFileSystem::CreateDirectory(DWORD flags, GenericDirectory * & gd)
	{
#if GFS_ENABLE_DIRECTORIES
	gd = new ISODirectory(this);
	if (gd)
		GNRAISE_OK;
	else
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
#else
	GNRAISE(GNR_UNIMPLEMENTED);
#endif
	}



//
//  Go to first item
//

Error ISOFileSystem::GoToFirstItem(ISOIterator * isoi)
	{
	VDAutoMutex mutex(&lock);
	BYTE drLen;
	BYTE flags;

	//
	//  Find offset to third (first real) entry
	//

	isoi->entryOffset = isoi->dirStart;

	GNREASSERT(ReadByte(isoi->dirStart, ISO_DR_LEN, drLen));
	isoi->entryOffset = drLen;

	GNREASSERT(ReadByte(isoi->dirStart, isoi->entryOffset + ISO_DR_LEN, drLen));
	isoi->entryOffset += drLen;

	GNREASSERT(ReadByte(isoi->dirStart, isoi->entryOffset + ISO_DR_LEN, drLen));


	if ((isoi->entryOffset >= isoi->dirSize) || (!drLen))
		GNRAISE(GNR_ITEM_NOT_FOUND);
	else
		{
		//
		//  Check if file is an associated one. If so, the skip it.
		//  This fixes double directory entries created by Macintosh CD writing programs.
		//

		GNREASSERT(ReadByte(isoi->dirStart, isoi->entryOffset + ISO_DR_FLAGS, flags));
		if (flags & ISO_FILE_ASSOC)
			GNRAISE(GoToNextItem(isoi));
		GNRAISE_OK;
		}
	}

//
//  Go to next item
//

Error ISOFileSystem::GoToNextItem(ISOIterator * isoi)
	{
	VDAutoMutex mutex(&lock);
	BYTE drLen;
	BYTE flags;
	DWORD offset;

	GNREASSERT(ReadByte(isoi->dirStart, isoi->entryOffset + ISO_DR_LEN, drLen));

	offset = isoi->entryOffset + drLen;

	//
	//  If length byte of the next is 0 then the next record didn't fit into block
	//  (so we have to move to the next block) or we reached the end of the dir
	//

	GNREASSERT(ReadByte(isoi->dirStart, offset + ISO_DR_LEN, drLen));

	if (!drLen)
		{
		offset = isoi->entryOffset + headerDataSize - (isoi->entryOffset % headerDataSize);

		if (offset >= isoi->dirSize)
			GNRAISE(GNR_ITEM_NOT_FOUND);
		}

	isoi->entryOffset = offset;

	//
	//  Check if file is an associated one. If so, the skip it.
	//  This fixes double directory entries created by Macintosh CD writing programs.
	//

	GNREASSERT(ReadByte(isoi->dirStart, isoi->entryOffset + ISO_DR_FLAGS, flags));
	if (flags & ISO_FILE_ASSOC)
		GNRAISE(GoToNextItem(isoi));

	GNRAISE_OK;
	}

//
//  Go to sub dir
//

Error ISOFileSystem::GoToSubDir(ISOIterator * isoi, GenericFileSystemIterator * & gfsi)
	{
	VDAutoMutex mutex(&lock);
	ISOIterator * newIsoi;
	DWORD start;
	DWORD len;
	BYTE flags;
	Error err;

	//
	//  Make sure it's a dir
	//

	GNREASSERT(ReadByte(isoi->dirStart, isoi->entryOffset + ISO_DR_FLAGS, flags));
	if (!(flags & ISO_FILE_DIR))
		GNRAISE(GNR_NOT_A_DIRECTORY);

	//
	//  Read sub dir info and create iterator with it
	//

	GNREASSERT(ReadDWord(isoi->dirStart, isoi->entryOffset + ISO_DR_EXT_LOC, start));
	GNREASSERT(ReadDWord(isoi->dirStart, isoi->entryOffset + ISO_DR_EXT_LEN, len));

	err = CreateIterator(newIsoi, start, len);
	gfsi = newIsoi;
	GNRAISE(err);
	}

//
//  Go to parent dir
//

Error ISOFileSystem::GoToParentDir(ISOIterator * isoi, GenericFileSystemIterator * & gfsi)
	{
	VDAutoMutex mutex(&lock);
	ISOIterator * newIsoi;
	Error err;
	DWORD start;
	DWORD len;
	BYTE drLen;

	//
	//  Create new iterator from either parent dir entry (2nd) or parent file file system
	//

	if (isoi->dirStart == rootDirStart)
		return mountPoint->Clone(gfsi);

	//
	//  Find second entry (to parent), then read all we need to know,
	//  then create iterator from it
	//

	GNREASSERT(ReadByte(isoi->dirStart, ISO_DR_LEN, drLen));
	GNREASSERT(ReadDWord(isoi->dirStart, drLen + ISO_DR_EXT_LOC, start));
	GNREASSERT(ReadDWord(isoi->dirStart, drLen + ISO_DR_EXT_LEN, len));

	err = CreateIterator(newIsoi, start, len);
	gfsi = newIsoi;
	GNRAISE(err);

	}

//
//  Get path name to item
//

Error ISOFileSystem::GetPathName(ISOIterator *isoi, DiskItemName & name)
	{
	VDAutoMutex mutex(&lock);

	DiskItemName pname;	// used to take a look into the cache...
	name = DiskItemName("");

	ISOIterator * imisoi;
	ISOIterator * parenti = NULL;

	Error err = GNR_OK;

	GNREASSERT(isoi->Clone(imisoi));
	while ((IS_ERROR(err = cache.Get(imisoi->dirStart, pname))) &&  (imisoi->dirStart != this->rootDirStart) )
		{
		err = this->GoToParentDir(imisoi, (GenericFileSystemIterator * &) parenti);
		if (!IS_ERROR(err))
			err = this->GoToFirstItem(parenti);

		if (!IS_ERROR(err))
			{
			// search
			BOOL found = FALSE;
			while (!found)
				{
				DiskItemType type;
				err = this->GetItemType(parenti, type);
				if (!IS_ERROR(err))


					{
					if (type == DIT_DIR)
						{
						ISOIterator * isosubi = NULL;
						err = parenti->GoToSubDir((GenericFileSystemIterator *&) isosubi);
						if (!IS_ERROR(err))
							if (isosubi->dirStart == imisoi->dirStart)
								{
								DiskItemName rname;
								parenti->GetItemName(rname);
								name = rname + name;
								found = TRUE;
								}
						delete isosubi;
						}
					}

				if (IS_ERROR(err))
					{
					delete parenti;
					delete imisoi;
					}



				err = GoToNextItem(parenti);
				if ( (!found) && IS_ERROR(err) )
					{
					delete parenti;
					delete imisoi;
					GNRAISE(GNR_ITEM_NOT_FOUND);
					}
				}
			}

		delete imisoi;
		imisoi = parenti;
		}


	// found it in cache?
	if (err == GNR_OK)
		{
		name = pname + "/" + name;
		}
	// go through mount point...
	else if (this->mountPoint)
		{
		DiskItemName mpName;
		DiskItemName mpPath;
		if (IS_ERROR(err = this->mountPoint->GetPathName(mpPath)))
			{
			delete imisoi;
			GNRAISE(err);
			}
		if (IS_ERROR(err = this->mountPoint->GetItemName(mpName)))
			{
			delete imisoi;
			GNRAISE(err);
			}
		name = mpPath + (DiskItemName)"/" + mpName + name;
		cache.Add(name, isoi->dirStart);
		}
	else
		{
		// no mount point? Should not be, but do not panic. Claim to be root...
		name = (DiskItemName)"/" + name;
		}

	delete imisoi;
	GNRAISE_OK;
	}

//
//  Get type of item
//

Error ISOFileSystem::GetItemType(ISOIterator * isoi, DiskItemType & type)
	{
	VDAutoMutex mutex(&lock);
	BYTE flags;

	//
	//  Read file flags of entry
	//

	GNREASSERT(ReadByte(isoi->dirStart, isoi->entryOffset + ISO_DR_FLAGS, flags));

	if (flags & ISO_FILE_DIR)
		type = DIT_DIR;
	else
		type = DIT_FILE;

	GNRAISE_OK;
	}

//
//  Get name of item
//

Error ISOFileSystem::GetItemName(ISOIterator * isoi, DiskItemName & name)
	{
	VDAutoMutex mutex(&lock);
	RequestHandle rh;
	DWORD block;
	DWORD offset;
	BYTE buffer[256];
	BYTE identLen;
	BYTE len;
	BYTE inc;
	Error err;
	int i;

	//
	//  Read length of file identifier
	//

	GNREASSERT(ReadByte(isoi->dirStart, isoi->entryOffset + ISO_DR_FID_LEN, identLen));

	//
	//  Let's compute the block if the identifier, it can't cross block boundaries
	//

	offset = isoi->entryOffset + ISO_DR_FID;
	block = isoi->dirStart + (offset / headerDataSize);
	offset = (offset % headerDataSize) + headerHeaderSize;

	//
	//  Read file identifier
	//

	if (!IS_ERROR(err = LockBlocks(block, 1, &driveBlock, headerSectorType | DAT_LOCK_AND_READ | DAF_CACHED, &rh)))
		{
		int pos = 0;

		len = identLen;
		inc = 1;
		if (unicodeType != IUT_NONE)
			{
			if (!driveBlock.data[offset])
				{
				identLen >>= 1;	// Real length is only half of it
				offset++;			// Begin with the first non-zero byte
				inc = 2;
				}
			else
				unicodeType = IUT_NONE;		// This is a fake for some CD writing programs who claim to write unicode, but really do not
			}

		for (i=0; i<len; i+=inc)
			{
			buffer[pos] = driveBlock.data[offset + i];
			pos++;
			}
		}
	UnlockBlocks(block, 1, &driveBlock, headerSectorType | DAT_UNLOCK_CLEAN | DAF_CACHED, &rh);

	GNREASSERT(err);

	//
	//  Remove trailing separator/file version number
	//

	len = identLen - 1;
	while (len)
		{
		if (buffer[len] == 0x3b)	// Separator 2
			{
			name = DiskItemName((char*)buffer, len);
			GNRAISE_OK;
			}
		len--;
		}

	name = DiskItemName((char*)(buffer), identLen);
	GNRAISE_OK;
	}

//
//  Get size of item
//

Error ISOFileSystem::GetItemSize(ISOIterator * isoi, KernelInt64 & size)
	{
	VDAutoMutex mutex(&lock);
	DiskItemType type;
	DWORD hsize;

	GNREASSERT(GetItemType(isoi, type));
	if (type == DIT_DIR)
		{
		size = 0;
		GNRAISE_OK;
		}

	GNREASSERT(ReadDWord(isoi->dirStart, isoi->entryOffset + ISO_DR_EXT_LEN, hsize));
	size = (KernelInt64)hsize;
	GNRAISE_OK;
	}

//
//  Read CD-ROM XA System Use Information
//

Error ISOFileSystem::ReadXASUInfo(ISOIterator * isoi, WORD & sui)
	{
	BYTE drLen, fidLen, systemUsePos;

	//
	//  Now let's see what the system use field says (See "System Description CD-ROM XA, Chapter III.2")
	//

	GNREASSERT(ReadByte(isoi->dirStart, isoi->entryOffset + ISO_DR_LEN, drLen));
	GNREASSERT(ReadByte(isoi->dirStart, isoi->entryOffset + ISO_DR_FID_LEN, fidLen));
	systemUsePos = 33 + fidLen + 1 - (fidLen & 1);
	DP("Size of System use is %d", drLen - systemUsePos);

	if (drLen - systemUsePos == 14)		// According to System Description CD-ROM XA
		{
		//
		//  Check signature bytes
		//

		GNREASSERT(ReadWord(isoi->dirStart, isoi->entryOffset + systemUsePos + 6, sui));
		if (sui != 0x4158)
			{
			DP("No sui");
			GNRAISE(GNR_OBJECT_NOT_FOUND);
			}

		GNREASSERT(ReadWord(isoi->dirStart, isoi->entryOffset + systemUsePos + 4, sui));
		sui = MAKEWORD(HIBYTE(sui), LOBYTE(sui));
		DP("SUI: %04x", sui);
		}

	GNRAISE_OK;
	}

//
//  Get the number of items in the dir the iterator is currently in
//

Error ISOFileSystem::GetNumberOfItems(ISOIterator * isoi, DWORD & num)
	{
	VDAutoMutex mutex(&lock);
	BYTE drLen;
	DWORD offset;

	//
	//  Find offset to third (first real) entry
	//

	GNREASSERT(ReadByte(isoi->dirStart, ISO_DR_LEN, drLen));
	offset = drLen;
	GNREASSERT(ReadByte(isoi->dirStart, offset + ISO_DR_LEN, drLen));
	offset += drLen;

	//
	//  Now repeat going to next item until end of dir is reached
	//

	num = 0;
	while (offset < isoi->dirSize)
		{
		GNREASSERT(ReadByte(isoi->dirStart, offset + ISO_DR_LEN, drLen));
		if (!drLen)
			{
			offset = offset + headerDataSize - (offset % headerDataSize);
			}
		else
			{
			offset += drLen;
			num++;
			}
		}

	GNRAISE_OK;
	}

//
//  Get directory object for dir the iterator points to
//

Error ISOFileSystem::GetDir(ISOIterator * isoi, GenericDirectory * & gd)
	{
	VDAutoMutex mutex(&lock);

	GNRAISE_OK;
	}

//
//  Build unique key
//

Error ISOFileSystem::BuildUniqueKey(void)
	{
	GNRAISE_OK;
	}

//
//  Get start block of file/dir
//

Error ISOFileSystem::GetStartBlock(ISOIterator * isoi, DWORD & startBlock)
	{
	return ReadDWord(isoi->dirStart, isoi->entryOffset + ISO_DR_EXT_LOC, startBlock);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\files\GenericFile.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  Generic File Classes
//
//  NOTE: GenericDiskItem, GenericFile
//  GenericDirectory and GenericFileSystemIterator have protected
//  constructors so they can only be created by the file system
//  (must be friend). Only copy constructor is public.
//
////////////////////////////////////////////////////////////////////

#ifndef GENERICFILE_H
#define GENERICFILE_H

#define GFS_ENABLE_DIRECTORIES 0		// Set this if you want to enable directory objects

class GenericFileSystem;

#include "Library/Files/GenericVolume.h"
#include "Library/Files/DiskItemName.h"
#include "Library/Hardware/Drives/Generic/DriveErrors.h"
#include "Library/Files/FileErrors.h"
#include "Library/Common/KrnlInt.h"
#include "Library/Common/KrnlSync.h"
#include "Library/General/Lists.h"

////////////////////////////////////////////////////////////////////
//
//  Type Definitions
//
////////////////////////////////////////////////////////////////////

//
//  Disk Item Type
//

enum DiskItemType
	{
	DIT_NONE		= 0x0000,
	DIT_FILE		= 0x0001,
	DIT_DIR		= 0x0002,
//	DIT_DRIVE	= 0x0004,
	DIT_ALL		= 0xffff
	};

//
//  Extended Disk Item Type
//

enum ExtDiskItemType
	{
	EDIT_NONE,
	EDIT_AUDIO_TRACK,			// CD Audio Track
	EDIT_DATA_TRACK,			// CD Data Track
	EDIT_DRIVE					// A drive shown as directory
//	EDIT_SYS_DIR				// System directory
	};

//
// File system types
//
enum enumFileSystemType
	{
	FS_GENERIC = 0,
	FS_ROOT,
	FS_CD,
	FS_ISO,
	FS_UDF,
	FS_CDDA,
	FS_DVD,
	FS_VCD,
	FS_AVF
	};


//
//  File Access Type (for Open() call)
//

#define FAT_NONE					0x00000000
#define FAT_READ					0x00000001	// Open file to read
#define FAT_WRITE					0x00000002	// Open file to write
#define FAT_CHAIN					0x00000004	// Open file as chain file	(DVD data file only)
#define FAT_HEADER				0x00000008	// Open file as header file (i.e. form 1 sectors), else as data file (i.e. form 2 sectors)
#define FAT_RECURSIVE			0x00000010	// Search recursively for file
#define FAT_CASE_SENSITIVE		0x00000020	// Be case sensitive when opening file by name

//
//  Read flags
//

#define FAT_RAW			0x00000800	// Read raw data (i.e. include checksum data etc.)

//
//  FindItem flags
//

#define FIF_NONE					0x00000000		// Nothing at all
#define FIF_RECURSIVE			0x00000001		// Do recursive search
#define FIF_CASE_SENSITIVE		0x00000002		// Search is case sensitive

//
//  Forward declarations
//

class GenericFile;
class GenericDirectory;
class GenericFileSystemIterator;
class GenericFileSystem;

////////////////////////////////////////////////////////////////////
//
//  Extended item information
//
////////////////////////////////////////////////////////////////////

class ExtItemInfo
	{
	public:
		ExtItemInfo(void)							{ exType = EDIT_NONE; }
		ExtItemInfo(ExtDiskItemType type)	{ exType = type; }

		ExtDiskItemType	exType;
	};

////////////////////////////////////////////////////////////////////
//
//  Unique Key Class
//
////////////////////////////////////////////////////////////////////

class UniqueKey
	{
	public:
		BOOL valid;
		BYTE key[8];

		UniqueKey(void)	{ valid = FALSE; }
	};

////////////////////////////////////////////////////////////////////
//
//  Path cache class
//
////////////////////////////////////////////////////////////////////


#define PATHCACHESIZE 16

class StringCacheElement : protected Node
	{
	public:
		friend class PathStringCache;

	protected:
		StringCacheElement(DWORD b, const DiskItemName & name) : block(b), name(name) {};

		DWORD block;
		DiskItemName name;
	};


class PathStringCache : protected List
	{
	private:
		int size;
	public:
		PathStringCache(int size = PATHCACHESIZE)
			{
			this->size = size;
			}

		~PathStringCache(void)
			{
			StringCacheElement * node = NULL;

			IteratorHandle h(CreateIterator());
			while (node = ((StringCacheElement*) h.Proceed()))
				{
				Remove((Node*) node);
				delete (StringCacheElement*) node;
				}
			}

		void Add(DiskItemName name, DWORD block);

		Error Get(DWORD block, DiskItemName & name);
	};

////////////////////////////////////////////////////////////////////
//
//  Generic Disk Item Class
//
////////////////////////////////////////////////////////////////////

class GenericDiskItem
	{
	protected:
		GenericFileSystem * gfs;
		VDLocalMutex lock;

		GenericDiskItem(GenericFileSystem * gfs);

	public:
		virtual ~GenericDiskItem(void);

		virtual Error Open(GenericFileSystemIterator * gfsi, DWORD accessType) = 0;
		virtual Error Close(void) = 0;

		//
		//  Inquiry
		//

		virtual Error GetName(DiskItemName & name) = 0;
		virtual Error GetPathName(DiskItemName & name) = 0;
		virtual Error GetSize(KernelInt64 & size) = 0;
		virtual Error GetIterator(GenericFileSystemIterator * & gfsi) = 0;

		//
		//  Misc.
		//

		virtual Error Flush(void);
		virtual Error TerminateRequest(RequestHandle * rh);
	};

////////////////////////////////////////////////////////////////////
//
//  Generic File Class
//
////////////////////////////////////////////////////////////////////

class GenericFile : public GenericDiskItem
	{
	protected:
		UniqueKey uniqueKey;
		DWORD startBlock;
		BOOL headerFile;		// TRUE if header file, data file else

		GenericFile(GenericFileSystem * gfs);

		virtual Error BuildUniqueKey(void) = 0;

	public:
		virtual ~GenericFile(void);

		virtual Error Open(GenericFileSystemIterator * gfsi, DWORD accessType);

		//
		//  Misc. inquiry
		//

		virtual Error GetUniqueKey(BYTE * key);
		virtual Error GetCopyManagementInfo(GenericCopyManagementInfo & gcmi) = 0;
		virtual Error GetStartBlock(DWORD & startBlock);

		//
		//  Access functions
		//

		virtual Error SeekBlock(DWORD block, DWORD flags, RequestHandle * rh) = 0;
		virtual Error LockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh) = 0;
		virtual Error UnlockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh) = 0;

		virtual Error ReadByte(DWORD pos, BYTE & b, DWORD flags, RequestHandle * rh);
		virtual Error ReadWord(DWORD pos, WORD & w, DWORD flags, RequestHandle * rh);
		virtual Error ReadDWord(DWORD pos, DWORD & d, DWORD flags, RequestHandle * rh);

		virtual Error ReadByte(KernelInt64 pos, BYTE & b, DWORD flags, RequestHandle * rh);
		virtual Error ReadWord(KernelInt64 pos, WORD & w, DWORD flags, RequestHandle * rh);
		virtual Error ReadDWord(KernelInt64 pos, DWORD & d, DWORD flags, RequestHandle * rh);
		virtual Error ReadBytes(KernelInt64 pos, KernelInt64 num, BYTE * buffer, DWORD flags, RequestHandle * rh);
		virtual Error WriteBytes(KernelInt64 pos, KernelInt64 num, BYTE * buffer, DWORD flags, RequestHandle * rh);
	};

////////////////////////////////////////////////////////////////////
//
//  Generic Directory Class
//
////////////////////////////////////////////////////////////////////

class GenericDirectory : public GenericDiskItem
	{
	protected:
		GenericDirectory(GenericFileSystem * gfs);

	public:
		virtual ~GenericDirectory(void);

		//
		//  Misc
		//

		virtual Error GetSize(KernelInt64 & size);

		//
		//  Item handling
		//

		virtual Error CreateItem(DWORD diskItemType, const DiskItemName & name, GenericDiskItem * & gdi) = 0;
		virtual Error DeleteItem(GenericFileSystemIterator * gfsi) = 0;

		virtual Error GetNumberOfItems(DWORD & num) = 0;
		virtual Error FindItem(const DiskItemName & name, DiskItemType type, DWORD flags, GenericFileSystemIterator * & gfsi);
	};

////////////////////////////////////////////////////////////////////
//
//  Generic File System Iterator Class
//
////////////////////////////////////////////////////////////////////

class GenericFileSystemIterator
	{
	friend class GenericFileSystem;

	protected:
		GenericFileSystem * gfs;

		GenericFileSystemIterator(GenericFileSystem * gfs);

		virtual BOOL Equals(GenericFileSystemIterator * gfsi) = 0;

	public:
		virtual ~GenericFileSystemIterator(void);

		virtual Error Clone(GenericFileSystemIterator * & gfsi) const = 0;
		friend int operator==(GenericFileSystemIterator & gfsi1, GenericFileSystemIterator & gfsi2);

		//
		//  Directory Handling
		//

		virtual Error GoToFirstItem(void) = 0;
		virtual Error GoToNextItem(void) = 0;
		virtual Error GoToSubDir(GenericFileSystemIterator * & gfsi) = 0;
		virtual Error GoToParentDir(GenericFileSystemIterator * & gfsi) = 0;

		//
		//  Item inquiry
		//

		virtual Error GetPathName(DiskItemName & name);
		virtual Error GetItemType(DiskItemType & type) = 0;
		virtual Error GetItemName(DiskItemName & name) = 0;
		virtual Error GetItemSize(KernelInt64 & size) = 0;
		virtual Error GetExtItemInfo(ExtItemInfo & info);

		//
		//  Directory/FileSystem inquiry
		//

		virtual Error GetNumberOfItems(DWORD & num) = 0;
		virtual Error GetCurrentDir(GenericDirectory * & gd) = 0;
		virtual Error GetFileSystem(GenericFileSystem * & gfs);
		virtual Error GetSubFileSystem(GenericFileSystem * & gfs);

		//
		//  File Access
		//

		virtual Error OpenItem(DWORD accessType, GenericDiskItem * & gdi) = 0;
	};

////////////////////////////////////////////////////////////////////
//
//  Generic (Hierarchical) File System Class
//  File Systems act as creators and destructors for files,
//  directories, etc.
//
////////////////////////////////////////////////////////////////////

class GenericFileSystem
	{
	friend class GenericFile;
	friend class GenericDirectory;
	friend class GenericFileSystemIterator;

	protected:
		GenericVolume	*	genericVolume;
		GenericProfile	*	profile;
		enumFileSystemType		fileSystemType;
	public:
		int					refCount;
	protected:
		UniqueKey			uniqueKey;
		DWORD					logicalBaseBlock;

		GenericFileSystemIterator * mountPoint;		//	Mount point of FS (in parent FS)
		VDLocalMutex lock;

		//
		//  Volume information
		//

		KernelString	volumeName;			// The name of the volume
		KernelString	volumeSetName;		// The name of the volume set
		WORD				volumeSetIndex;	// Index of volume within set
		WORD				volumeSetSize;		// Number of volumes in set
		DWORD				blockSize;			// Size of the drive blocks

		//
		//  Sector types
		//

		DWORD headerSectorType;		// Sector type for header files
		DWORD headerHeaderSize;		// Size of header in header sectors
		DWORD headerDataSize;		//	Size of data in header sectors
		DWORD dataSectorType;		// Sector type for data files
		DWORD dataHeaderSize;		// Size of header in data sectors
		DWORD dataDataSize;			// Size of data in data sectors

		//
		//  Factory methods
		//

		virtual Error CreateFile(DWORD flags, GenericFile * & gf) = 0;
		virtual Error CreateDirectory(DWORD flags, GenericDirectory * & gd) = 0;			// Root dir by default

		//
		//  Data Access Methods
		//

		virtual Error SeekBlock(DWORD block, DWORD flags, RequestHandle * rh);
		virtual Error LockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh);
		virtual Error UnlockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh);

		//
		//  Internal helper functions
		//

		virtual Error InternalFindItem(DiskItemName & name, DiskItemType type, DWORD flags,
												 GenericFileSystemIterator * where, GenericFileSystemIterator * & result);
		virtual Error BuildUniqueKey(void) = 0;

		virtual Error GetPathName(DiskItemName & name, GenericFileSystemIterator * where);

	public:
		GenericFileSystem(void);
		virtual ~GenericFileSystem(void);

		virtual Error Init(GenericFileSystemIterator * mountPoint, GenericVolume * volume, GenericProfile * profile);
		virtual Error InitHeaderAndData(GenericVolume * volume);
		virtual Error Obtain(void);
		virtual Error Release(void);

		//
		//  Item handling
		//

		virtual Error FindItem(const DiskItemName & name, DiskItemType type, DWORD flags,
									  GenericFileSystemIterator * where, GenericFileSystemIterator * & result);
		virtual Error OpenItem(const DiskItemName & name, DWORD accessType, GenericDiskItem * & gdi);
		virtual Error OpenItem(GenericFileSystemIterator * gfsi, DWORD accessType, GenericDiskItem * & gdi);
		virtual Error GetExtItemInfo(GenericFileSystemIterator * gfsi, ExtItemInfo & info);

		//
		//  Factory Methods
		//

		virtual Error CreateIterator(GenericFileSystemIterator * & gfsi) = 0;		// In root dir of current file system
		virtual Error CreateRootIterator(GenericFileSystemIterator * & gfsi);		// In root dir of ALL file systems
		virtual Error CreateRootDirectory(GenericDirectory * & gd);

		//
		//  Volume Information
		//

		virtual Error GetDiskType(PhysicalDiskType & type);
		virtual Error GetVolumeName(KernelString & name);
		virtual Error GetVolumeSetName(KernelString & name);
		virtual Error GetVolumeSetIndex(int & index);
		virtual Error GetVolumeSetSize(int & size);
		virtual Error GetUniqueKey(BYTE * key);
		virtual Error GetLogicalBaseBlock(DWORD & logicalBaseBlock);
		virtual Error GetDTSInfo(BOOL & isDTS, GenericCopyManagementInfo & gcmi);
		virtual Error ObtainVolume(GenericVolume * & volume);

		DWORD GetHeaderSectorType(void)	{ return headerSectorType; }
		DWORD GetHeaderHeaderSize(void)	{ return headerHeaderSize; }
		DWORD GetHeaderDataSize(void)		{ return headerDataSize; }
		DWORD GetDataSectorType(void)		{ return dataSectorType; }
		DWORD GetDataHeaderSize(void)		{ return dataHeaderSize; }
		DWORD GetDataDataSize(void)		{ return dataDataSize; }

		//
		//  Drive "Pass Through" Functions
		//

		virtual Error GetCurrentDriveBlockSize(DWORD & size);
		virtual Error SetDriveBlockSize(DWORD size);

		virtual Error GetNumberOfDriveBlocks(DWORD & num);
		virtual Error SetNumberOfDriveBlocks(DWORD num);

		virtual Error TerminateRequest(RequestHandle * rh);
		virtual Error Flush(void);

		virtual Error GetDriveName(KernelString & name);
#if MSNDISC
		virtual Error GetDriveCaps(GenericDriveType & type, DWORD & caps, DWORD & slots, DWORD& positions, DWORD& changerOpenOffset);
#else
		virtual Error GetDriveCaps(GenericDriveType & type, DWORD & caps, DWORD & slots);
#endif
		virtual Error SpinUpDrive(void);
		virtual Error SpinDownDrive(void);

		enumFileSystemType GetFileSystemType(void) { return fileSystemType; }
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\files\RootFile.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  Root File Classes
//
//  NOTE: GenericDiskItem, GenericFile, GenericChainFile,
//  GenericDirectory and GenericFileSystemIterator have protected
//  constructors so they can only be created by the file system
//  (must be friend). Only copy constructor is public.
//
////////////////////////////////////////////////////////////////////

#ifndef ROOTFILE_H
#define ROOTFILE_H

#include "Library/hardware/drives/generic/DriveTable.h"
#include "Library/Files/GenericFile.h"
#include "Library/Files/UDFFile.h"
#include "Library/Files/ISOFile.h"
#include "Library/Files/CDFile.h"

class RootDirectory;
class RootIterator;
class RootFileSystem;
class MountNode;

//
// Flags for RootFileSystem::CreateFileSystem
//

#define FS_NONE								0x00
#define FS_CD_FILE_SYSTEM_REQUIRED		0x01

////////////////////////////////////////////////////////////////////
//
//  Disk information class
//
////////////////////////////////////////////////////////////////////

class DiskInformation
	{
	public:
		KernelString		driveName;
		PhysicalDiskType	diskType;
		KernelString		volumeName;
		BYTE					uniqueKey[8];
		BYTE					diskRegion;
		BOOL					isRPC2;
		BYTE					driveRegion;
		BYTE					availSets;
	};

////////////////////////////////////////////////////////////////////
//
//  Root Directory Class
//
////////////////////////////////////////////////////////////////////

#if GFS_ENABLE_DIRECTORIES

class RootDirectory : public GenericDirectory
	{
	friend class RootFileSystem;

	protected:
		RootFileSystem * rootfs;
		RootIterator * rit;

		RootDirectory(RootFileSystem * rootfs);

	public:
		virtual ~RootDirectory(void);

		//
		//  Open/close
		//

		virtual Error Open(GenericFileSystemIterator * gfsi, DWORD accessType);
		virtual Error Close(void);

		//
		//  Misc
		//

		virtual Error GetName(DiskItemName & name);
		virtual Error GetPathName(DiskItemName & name);
		virtual Error GetIterator(GenericFileSystemIterator * & gfsi);

		//
		//  Item handling
		//

		virtual Error CreateItem(DWORD diskItemType, const DiskItemName & name, GenericDiskItem * & gdi);
		virtual Error DeleteItem(GenericFileSystemIterator * gfsi);

		virtual Error GetNumberOfItems(DWORD & num);
		virtual Error FindItem(const DiskItemName & name, DiskItemType type, DWORD flags, GenericFileSystemIterator * & gfsi);
	};

#endif

////////////////////////////////////////////////////////////////////
//
//  Root File System Iterator Class
//
////////////////////////////////////////////////////////////////////

class RootIterator : public GenericFileSystemIterator
	{
	friend class RootFileSystem;

	protected:
		MountNode * mountNode;

		RootIterator(GenericFileSystem * gfs);

		virtual BOOL Equals(GenericFileSystemIterator * gfsi);

	public:
		virtual ~RootIterator(void);

		virtual Error Clone(GenericFileSystemIterator * & gfsi) const;
		virtual Error Clone(RootIterator * & gfsi) const;

		//
		//  Directory Handling
		//

		virtual Error GoToFirstItem(void);
		virtual Error GoToNextItem(void);
		virtual Error GoToSubDir(GenericFileSystemIterator * & gfsi);
		virtual Error GoToParentDir(GenericFileSystemIterator * & gfsi);

		//
		//  Inquiry
		//

		virtual Error GetPathName(DiskItemName & name);
		virtual Error GetItemType(DiskItemType & type);
		virtual Error GetItemName(DiskItemName & name);
		virtual Error GetItemSize(KernelInt64 & size);
		virtual Error GetNumberOfItems(DWORD & num);
		virtual Error GetCurrentDir(GenericDirectory * & gd);
		virtual Error ObtainSubFileSystem(GenericFileSystem * & gfs, DWORD dwFlags = 0);
		virtual Error ReleaseSubFileSystem(void);

		//
		//  File Access
		//

		virtual Error OpenItem(DWORD accessType, GenericDiskItem * & gdi);

		//
		//  Region handling
		//

		virtual Error GetRPCData(BOOL & isRPC2, BYTE & regionCode, BYTE & availSets);
		virtual Error SetRegionCode(BYTE region);
	};

////////////////////////////////////////////////////////////////////
//
//  Root File System Class
//
//  This class forms a single common tree out of all files/dirs
//
//  NOTE: In order to avoid circular references to it, for the time
//        being RootFileSystem doesn't support Obtain/Release, so it
//        should be removed by 'delete' operator at the end of session.
//
////////////////////////////////////////////////////////////////////

class RootFileSystem : public GenericFileSystem
	{
	friend class RootDirectory;
	friend class RootIterator;

	protected:
		List mounts;				// List of file systems/volumes/drives which are "mounted"

		//
		//  Mount point handling
		//

		Error CreateFileSystem(MountNode * mn, DWORD dwFlags);

		//
		//  Factory Methods
		//

		virtual Error CreateIterator(RootIterator * & rit);
		virtual Error CreateIterator(GenericFileSystemIterator * & gfsi);
		virtual Error CreateFile(DWORD flags, GenericFile * & gf);
		virtual Error CreateDirectory(DWORD flags, GenericDirectory * & gd);					// Root dir by default

		//
		//  Data Access Methods, all prohibited
		//

		virtual Error SeekBlock(DWORD block, DWORD flags, RequestHandle * rh);
		virtual Error LockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh);
		virtual Error UnlockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh);

		//
		//  Item Handling
		//

		Error GoToFirstItem(RootIterator * cdi);
		Error GoToNextItem(RootIterator * cdi);
		Error GoToSubDir(RootIterator * cdi, GenericFileSystemIterator * & gfsi);
		Error GoToParentDir(RootIterator * cdi, GenericFileSystemIterator * & gfsi);

		Error GetPathName(RootIterator * rit, DiskItemName & name);
		Error GetItemType(RootIterator * rit, DiskItemType & type);
		Error GetItemName(RootIterator * rit, DiskItemName & name);
		Error GetItemSize(RootIterator * rit, KernelInt64 & size);

		Error GetDir(RootIterator * rit, GenericDirectory * & gd);
		Error GetNumberOfItems(RootIterator * rit, DWORD & num);

		//
		//  Region code handling
		//

		virtual Error GetRPCData(RootIterator * rit, BOOL & isRPC2, BYTE & regionCode, BYTE & availSets);
		virtual Error SetRegionCode(RootIterator * rit, BYTE region);

		//
		//  Internal helper functions
		//
	public:
		virtual Error BuildUniqueKey(void);
		virtual Error ObtainSubFileSystem(RootIterator * rit, GenericFileSystem * & gfs, DWORD dwFlags = 0);
		virtual Error ObtainSubFileSystem(RootIterator * rit);
		virtual Error ReleaseSubFileSystem(RootIterator * rit, BOOL forced = FALSE);
		Error FillMountNode(MountNode * node, DWORD dwFlags = 0);
		Error ClearMountNode(MountNode * node);

	public:
		RootFileSystem(void);
		virtual ~RootFileSystem(void);

		virtual Error Init(GenericProfile * profile, DriveTable * driveTable);

		//RootFileSystem doesn't support Obtain/Release (see NOTE above)
		virtual Error Obtain(void){GNRAISE_OK;}
		virtual Error Release(void){GNRAISE_OK;}

//		virtual Error CheckPath(KernelString drivePath, DiskInformation * & di);

		//
		//  Volume Information
		//

		virtual Error GetUniqueKey(BYTE * key);

		//
		//  Drive "Pass Through" Functions
		//

		virtual Error GetCurrentDriveBlockSize(GenericFileSystemIterator * gfsi, DWORD & size);
		virtual Error SetDriveBlockSize(GenericFileSystemIterator * gfsi, DWORD size);

		virtual Error GetNumberOfDriveBlocks(GenericFileSystemIterator * gfsi, DWORD & num);
		virtual Error SetNumberOfDriveBlocks(GenericFileSystemIterator * gfsi, DWORD num);

		virtual Error TerminateRequest(RequestHandle * rh);
//		virtual Error Flush(GenericFileSystemIterator * gfsi);

		//
		//  Drive handling
		//

		virtual Error SpinUpDrive(RootIterator * rit);
		virtual Error SpinDownDrive(RootIterator * rit);

		virtual Error LoadMedia(RootIterator * rit, int slotNumber = 0, DWORD flags = LMF_WAIT);
		virtual Error UnloadMedia(RootIterator * rit, DWORD flags = UMF_WAIT);
#if MSNDISC
		virtual Error GetDriveCaps(RootIterator * rit, DWORD& caps, DWORD& slots, DWORD& positions, DWORD& changerOpenOffset );
		virtual Error MoveChanger(RootIterator * rit, DWORD operation, DWORD flags, DWORD param );
		virtual Error GetChangerStatus(RootIterator * rit, DWORD& status, DWORD& position);
		virtual Error GetSlotStatus( RootIterator * rot, DWORD slot, DWORD& status );
		virtual Error LockClamp(RootIterator * rit);
		virtual Error UnlockClamp(RootIterator * rit);
#else
		virtual Error LockTray(RootIterator * rit);
		virtual Error UnlockTray(RootIterator * rit);
		virtual Error GetTrayStatus(RootIterator * rit, GenericTrayStatus & status);
#endif
		virtual Error AbortAndDisableDiskRequests(RootIterator * rit);
		virtual Error EnableDiskRequests(RootIterator * rit);

		//
		//  Volume handling
		//

		virtual Error GetVolumeName(RootIterator * rit, KernelString name);
		virtual Error GetVolumeSetName(RootIterator * rit, KernelString name);
		virtual Error GetVolumeSetIndex(RootIterator * rit, int index);
		virtual Error GetVolumeSetSize(RootIterator * rit, int size);
		virtual Error GetUniqueKey(RootIterator * rit, BYTE * key);
		virtual Error GetDiskInformation(RootIterator * rit, DiskInformation * & di);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\files\UDFFile.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  UDF File Classes
//
//  NOTE: UDFFile, UDFDirectory and UDFIterator have protected
//  constructors so they can only be created by the file system
//  (must be friend). Only copy constructor is public.
//
////////////////////////////////////////////////////////////////////

#ifndef UDFFILE_H
#define UDFFILE_H

#include "library/Files/GenericFile.h"
#include "library/Files/CDVDVolume.h"

class UDFFile;
class UDFDirectory;
class UDFIterator;
class UDFFileSystem;

////////////////////////////////////////////////////////////////////
//
//  UDF File Class
//
////////////////////////////////////////////////////////////////////

class UDFFile : public GenericFile
	{
	friend class UDFFileSystem;

	protected:
		UDFFileSystem	*	udffs;
		UDFIterator		*	udfi;					// The iterator pointing to this file

		GenericCopyManagementInfo gcmi;	// Cached GCMI
		BOOL gcmiValid;						// Cached GCMI is valid

		//
		//  Construction/destruction
		//

		UDFFile(UDFFileSystem * udffs);

		virtual Error BuildUniqueKey(void);

	public:
		virtual ~UDFFile(void);

		virtual Error Open(GenericFileSystemIterator * gfsi, DWORD accessType);
		virtual Error Close(void);

		//
		//  Misc. inquiry
		//

		virtual Error GetName(DiskItemName & name);
		virtual Error GetPathName(DiskItemName & name);
		virtual Error GetSize(KernelInt64 & size);
		virtual Error GetIterator(GenericFileSystemIterator * & gfsi);
		virtual Error GetCopyManagementInfo(GenericCopyManagementInfo & gcmi);

		//
		//  Access functions
		//

		virtual Error SeekBlock(DWORD block, DWORD flags, RequestHandle * rh);
		virtual Error LockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh);
		virtual Error UnlockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh);
	};

////////////////////////////////////////////////////////////////////
//
//  UDF Directory Class
//
////////////////////////////////////////////////////////////////////

#if GFS_ENABLE_DIRECTORIES

class UDFDirectory : public GenericDirectory
	{
	friend class UDFFileSystem;

	protected:
		UDFFileSystem	*	udffs;			// The file system this directory belongs to
		UDFIterator		*	udfi;				// The iterator pointing to this dir

		//
		//  Construction/destruction
		//

		UDFDirectory(UDFFileSystem * udffs);

	public:
		virtual ~UDFDirectory(void);

		virtual Error Open(GenericFileSystemIterator * gfsi, DWORD accessType);
		virtual Error Close(void);

		//
		//  Inquiry
		//

		virtual Error GetName(DiskItemName & name);
		virtual Error GetPathName(DiskItemName & name);
		virtual Error GetIterator(GenericFileSystemIterator * & gfsi);

		//
		//  Item handling
		//

		virtual Error CreateItem(DWORD diskItemType, const DiskItemName & name, GenericDiskItem * & gdi);
		virtual Error DeleteItem(GenericFileSystemIterator * gfsi);

		virtual Error GetNumberOfItems(DWORD & num);
		virtual Error FindItem(const DiskItemName & name, DiskItemType type, DWORD flags, GenericFileSystemIterator * & gfsi);
	};

#endif

////////////////////////////////////////////////////////////////////
//
//  UDF File System Iterator Class
//  Corresponds to an UDF File Entry
//
////////////////////////////////////////////////////////////////////

class UDFIterator : public GenericFileSystemIterator
	{
	friend class UDFFileSystem;

	protected:
		DWORD dirICB;							// The ICB describing the dir the iterator is currently in
		DWORD dirStart;						// Start block of this dir
		DWORD dirSize;							// Size of this dir
		DWORD entryOffset;					// Offset of this entry within dir

		UDFIterator(GenericFileSystem * gfs);

		virtual BOOL Equals(GenericFileSystemIterator * gfsi);

	public:
		virtual ~UDFIterator(void);

		virtual Error Clone(GenericFileSystemIterator * & gfsi) const;
		virtual Error Clone(UDFIterator * & udfi) const;

		//
		//  Directory Handling
		//

		virtual Error GoToFirstItem(void);
		virtual Error GoToNextItem(void);
		virtual Error GoToSubDir(GenericFileSystemIterator * & gfsi);
		virtual Error GoToParentDir(GenericFileSystemIterator * & gfsi);

		//
		//  Inquiry
		//

		virtual Error GetPathName(DiskItemName & name);
		virtual Error GetItemType(DiskItemType & type);
		virtual Error GetItemName(DiskItemName & name);
		virtual Error GetItemSize(KernelInt64 & size);
		virtual Error GetNumberOfItems(DWORD & num);
		virtual Error GetCurrentDir(GenericDirectory * & gd);

		//
		//  File Access
		//

		virtual Error OpenItem(DWORD accessType, GenericDiskItem * & gdi);
	};

////////////////////////////////////////////////////////////////////
//
//   UDF File System Class
//
////////////////////////////////////////////////////////////////////

class UDFFileSystem : public GenericFileSystem
	{
	friend class UDFFile;
	friend class UDFDirectory;
	friend class UDFIterator;
	friend class UDFFileEntry;

	protected:
		CDVDVolume		*	cdvdVolume;						// The volume we are operating on (type cast only)
		DWORD					primaryVolumeDescriptor;	// Block address of PVD
		DWORD					rootICB;							// Root directory ICB block (logical)

		RequestHandle		rh;								// For directory handling purposes
		DriveBlock			driveBlock;						// For directory handling purposes

		PathStringCache	cache;							// For caching directory entries

		//
		//  Factory Methods
		//

		Error CreateIterator(UDFIterator * & udfi, DWORD dirICB);
		Error CreateIterator(GenericFileSystemIterator * & gfsi, DWORD dirICB);

		virtual Error CreateFile(DWORD flags, GenericFile * & gf);
		virtual Error CreateDirectory(DWORD flags, GenericDirectory * & gd);

		//
		//  Item Handling
		//

		Error GoToFirstItem(UDFIterator * udfi);
		Error GoToNextItem(UDFIterator * udfi);
		Error GoToSubDir(UDFIterator * udfi, GenericFileSystemIterator * & gfsi);
		Error GoToParentDir(UDFIterator * udfi, GenericFileSystemIterator * & gfsi);

		Error GetPathName(UDFIterator * udfi, DiskItemName & name);
		Error GetItemType(UDFIterator * udfi, DiskItemType & type);
		Error GetItemName(UDFIterator * udfi, DiskItemName & name);
		Error GetItemSize(UDFIterator * udfi, KernelInt64 & size);

		Error GetDir(UDFIterator * udfi, GenericDirectory * & gd);		// Returns the dir the iterator is currently in
		Error GetNumberOfItems(UDFIterator * udfi, DWORD & num);			// Returns the number of items in the dir the iterator is currently in

		//
		//  Internal helper functions
		//

		Error ReadByte(DWORD block, DWORD offset, BYTE & b);
		Error ReadWord(DWORD block, DWORD offset, WORD & w);
		Error ReadDWord(DWORD block, DWORD offset, DWORD & d);
		Error ReadQWord(DWORD block, DWORD offset, KernelInt64 & q);
		Error BuildUniqueKey(void);
		Error GetAllocDescriptor(UDFIterator * udfi, WORD index, DWORD & start, DWORD & length);
		Error GetCopyManagementInfo(UDFIterator * udfi, GenericCopyManagementInfo & gcmi);

	public:
		UDFFileSystem(void);
		virtual ~UDFFileSystem(void);

		virtual Error Init(GenericFileSystemIterator * mountPoint, GenericVolume * volume, GenericProfile * profile);

		//
		//  Factory methods
		//

		virtual Error CreateIterator(UDFIterator * & udfi);						// In root dir of UDF file system
		virtual Error CreateIterator(GenericFileSystemIterator * & gfsi);		// In root dir of UDF file system
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\files\VFI.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  Viona File Interface Implementation
//
////////////////////////////////////////////////////////////////////

#include "VFI.h"
#include <string.h>


//
//  Logging of VFI calls
//

#define LOGVFI_NONE			0x0000		// No VFI logging at all
#define LOGVFI_GENERAL		0x0001		//
#define LOGVFI_ITERATOR		0x0002
#define LOGVFI_ITEM			0x0004
#define LOGVFI_FILE			0x0008
#define LOGVFI_VOLUME		0x0010
#define LOGVFI_EXIT			0x0020		// Log termination of VFI call
#define LOGVFI_ALL			0xffff		// Log everything

#define LOGVFICALLS LOGVFI_NONE	 		// Use the LOGVFI_* flags above to configure logging

////////////////////////////////////////////////////////////////////
//
//  ST20LITE specific
//
////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////
//
//  Windows specific
//
////////////////////////////////////////////////////////////////////


#if LOGVFICALLS
#define LOGVFI(text, type) if (LOGVFI_##type & (LOGVFICALLS)) DP("VFI_%s", #text)
#define LOGVFIEXIT(text, type, err) if ( (LOGVFI_##type & (LOGVFICALLS)) && (LOGVFI_EXIT & (LOGVFICALLS)) ) DP("VFI_%s END (%08lx)", #text, err)
#else
#define LOGVFI(text, type)
#define LOGVFIEXIT(text, type, err)
#endif



////////////////////////////////////////////////////////////////////
//
//  Global variables
//
////////////////////////////////////////////////////////////////////

GenericFileSystem * pRootFileSystem = NULL;

//
//  Initialize VFI
//  Parameter must be a valid root file system. This is not tested.
//

Error VFI_Init(GenericFileSystem * pRootSystem)
	{
	Error err;

	LOGVFI(Init, GENERAL);

	//
	// Test parameters
	//

	if (pRootSystem)
		{
		pRootFileSystem = pRootSystem;
		pRootFileSystem->Obtain();
		err = GNR_OK;
		}
	else
		err = GNR_INVALID_PARAMETERS;

	LOGVFIEXIT(Init, GENERAL, err);

	GNRAISE(err);
	}

//
//  Clean up the VFI Interface
//  Objects still not given back to the interface are NOT deleted..
//

Error VFI_Cleanup()
	{
	Error err;

	LOGVFI(Cleanup, GENERAL);

	if (pRootFileSystem)
		{
		pRootFileSystem->Release();
		pRootFileSystem = NULL;
		err = GNR_OK;
		}
	else
		err = GNR_OBJECT_INVALID;

	LOGVFIEXIT(Cleanup, GENERAL, err);

	GNRAISE(err);
	}

//
//  Create Iterator to root file system
//

DLLCALL Error WINAPI VFI_CreateIterator(HIter & hIterator)
	{
	GenericFileSystemIterator * pIterator = NULL;
	Error err = GNR_OBJECT_INVALID;
	hIterator = (HIter) NULL;


	LOGVFI(CreateIterator, ITERATOR);

	//
	// Test internal state
	//

	if (pRootFileSystem)
		{
		//
		// Create iterator
		//

		err = pRootFileSystem->CreateIterator(pIterator);
		hIterator = (HIter) pIterator;
		}

	LOGVFIEXIT(CreateIterator, ITERATOR, err);

	GNRAISE(err);
	}

//
//  Duplicate existing iterator
//

DLLCALL Error WINAPI VFI_CloneIterator(HIter hIterator, HIter & hClone)
	{
	Error err = GNR_INVALID_PARAMETERS;
	GenericFileSystemIterator * pCloned = NULL;

	LOGVFI(CloneIterator, ITERATOR);

	if (hIterator)
		{
		//
		// Clone iterator
		//

		err = ((GenericFileSystemIterator*) hIterator)->Clone(pCloned);
		hClone = (HIter) pCloned;
		}

	LOGVFIEXIT(CloneIterator, ITERATOR, err);

	GNRAISE(err);
	}

//
//  Delete iterator.
//

DLLCALL Error WINAPI VFI_DeleteIterator(HIter hIterator)
	{
	LOGVFI(DeleteIterator, ITERATOR);

	delete (GenericFileSystemIterator*) hIterator;

	LOGVFIEXIT(DeleteIterator, ITERATOR, GNR_OK);

	GNRAISE_OK;
	}

//
//  Get Name of Item the given iterator actually points to
//  hIterator is checked against being invalid (==0) --> GNR_INVALID_PARAMETERS
//  if the buffer is too short --> GNR_NOT_ENOUGH_MEMORY. length is set to the required buffer length
//  but the buffer is filled with as much as fits in it. So GNR_NOT_ENOUGH_MEMORY only indicates
//  a truncated string.
//
//  the length returned in case of an error is the length of the string including the closing zero
//

DLLCALL Error WINAPI VFI_GetItemName(HIter hIterator, DWORD & length, char * name)
	{
	DiskItemName itemName;
	Error err;

	LOGVFI(GetItemName, ITEM);

	//
	// Test parameters
	//

	if (hIterator && name)
		{
		//
		// Get name from root file system
		//

		if (!IS_ERROR(err = ((GenericFileSystemIterator*)hIterator)->GetItemName(itemName)))
			{
			//
			// Set out parameter
			//

			if (itemName.Length() >= (int)length)
				{
				length = itemName.Length() + 1;
				strncpy(name, (char*)itemName, length - 1);
				name[length - 1] = '\0';
				err = GNR_NOT_ENOUGH_MEMORY;
				}
			else
				strcpy(name, (char*)itemName);
			}
		}
	else
		err = GNR_INVALID_PARAMETERS;

	LOGVFIEXIT(GetItemName, ITEM, err);

	GNRAISE(err);
	}

//
//  Get Item Path...
//  hIterator is checked against being invalid (==0) --> GNR_INVALID_PARAMETERS
//  if the buffer is too short --> GNR_NOT_ENOUGH_MEMORY. length is set to the required buffer length
//  but the buffer is filled with as much as fits in it. So GNR_NOT_ENOUGH_MEMORY only indicates
//  a truncated string.
//
//  the length returned in case of an error is the length of the string including the closing zero
//

DLLCALL Error WINAPI VFI_GetItemPath(HIter hIterator, DWORD & length, char * path)
	{
	DiskItemName pathName;
	Error err;

	LOGVFI(GetItemPath, ITEM);

	//
	// Test parameters
	//

	if (hIterator && path)
		{
		//
		// Get name from root file system
		//

		if (!IS_ERROR(err = ((GenericFileSystemIterator*)hIterator)->GetPathName(pathName)))
			{
			//
			// Set out parameter
			//

			if (pathName.Length() >= (int)length)
				{
				strncpy(path, (char*)pathName, length - 1);
				path[length - 1] = '\0';
				length = pathName.Length() + 1;
				err = GNR_NOT_ENOUGH_MEMORY;
				}
			else
				strcpy(path, (char*)pathName);
			}
		}
	else
		err = GNR_INVALID_PARAMETERS;

	LOGVFIEXIT(GetItemPath, ITEM, err);

	GNRAISE(err);
	}

//
//  Convert DiskItemType to VFIItemType
//

VFIItemType DITToVIT(DiskItemType dit)
	{
	switch (dit)
		{
		case DIT_FILE:
			return VIT_FILE;
		case DIT_DIR:
			return VIT_DIR;
		case DIT_ALL:
			return VIT_ALL;
		default:
			return VIT_NONE;
		}
	return VIT_NONE;
	}

//
//  Convert VFIItemType to DITItemType
//

DiskItemType VITToDIT(VFIItemType vit)
	{
	switch (vit)
		{
		case VIT_FILE:
			return DIT_FILE;
		case VIT_DIR:
			return DIT_DIR;
		case VIT_ALL:
			return DIT_ALL;
		default:
			return DIT_NONE;
		}
	return DIT_NONE;
	}

//
//  Get Disk Item Type
//  hIterator is checked against being invalid (==0) --> GNR_INVALID_PARAMETERS
//

DLLCALL Error WINAPI VFI_GetItemType(HIter hIterator, VFIItemType & type)
	{
	DiskItemType dit;
	Error err = GNR_INVALID_PARAMETERS;

	LOGVFI(GetItemType, ITEM);

	//
	// Test parameters ...
	//

	if (hIterator)
		{
		//
		// Get item type ...
		//

		err = ((GenericFileSystemIterator*)hIterator)->GetItemType(dit);
		type = DITToVIT(dit);
		}

	LOGVFIEXIT(GetItemType, ITEM, err);

	GNRAISE(err);
	}

//
//  Get Disk Item Size
//  hIterator is checked against being invalid (==0) --> GNR_INVALID_PARAMETERS
//

DLLCALL Error WINAPI VFI_GetItemSize(HIter hIterator, DWORD & sizeLo, DWORD & sizeHi)
	{
	GenericFileSystemIterator * pIterator = (GenericFileSystemIterator*) hIterator;
	KernelInt64 size64;
	Error err = GNR_INVALID_PARAMETERS;

	LOGVFI(GetItemSize, ITEM);

	//
	//  Test parameters
	//

	if (pIterator)
		{
		//
		//  Get item size
		//

		err = pIterator->GetItemSize(size64);

		sizeLo = size64.Lower();
		sizeHi = size64.Upper();
		}

	LOGVFIEXIT(GetItemSize, ITEM, err);

	GNRAISE(err);
	}

//
//  Get Number Of Items in Iterator
//  hIterator is checked against being invalid (==0) --> GNR_INVALID_PARAMETERS
//

DLLCALL Error WINAPI VFI_GetNumberOfItems(HIter hIterator, DWORD & num)
	{
	Error err = GNR_INVALID_PARAMETERS;

	LOGVFI(GetNumberOfItems, ITEM);

	if (hIterator)
		{
		//
		//  Get number of items from iterator
		//

		err = ((GenericFileSystemIterator*)hIterator)->GetNumberOfItems(num);
		}

	LOGVFIEXIT(GetNumberOfItems, ITEM, err);

	GNRAISE(err);
	}

//
//  Move iterator to next item
//  hIterator is checked against being invalid (==0) --> GNR_INVALID_PARAMETERS
//

DLLCALL Error WINAPI VFI_GoNext(HIter hIterator)
	{
	Error err = GNR_INVALID_PARAMETERS;

	LOGVFI(GoNext, ITERATOR);

	if (hIterator)
		err = ((GenericFileSystemIterator*)hIterator)->GoToNextItem();

	LOGVFIEXIT(GoNext, ITERATOR, err);

	GNRAISE(err);
	}

//
//  Go to first item on itereator, where the iterator started to iterate
//  hIterator is checked against being invalid (==0) --> GNR_INVALID_PARAMETERS
//

DLLCALL Error WINAPI VFI_GoFirst(HIter hIterator)
	{
	Error err = GNR_INVALID_PARAMETERS;

	LOGVFI(GoFirst, ITERATOR);

	if (hIterator)
		err = ((GenericFileSystemIterator*)hIterator)->GoToFirstItem();

	LOGVFIEXIT(GoFirst, ITERATOR, err);

	GNRAISE(err);
	}

//
//  Go down the tree (to the sub directory)
//  hIterator is checked against being invalid (==0) --> GNR_INVALID_PARAMETERS
//

DLLCALL Error WINAPI VFI_GoDown(HIter hIterator, HIter & hNewIterator)
	{
	GenericFileSystemIterator * pIterator = (GenericFileSystemIterator*) hIterator;
	GenericFileSystemIterator * pNewIterator;
	Error err = GNR_INVALID_PARAMETERS;

	LOGVFI(GoDown, ITERATOR);

	if (pIterator)
		{
		err = pIterator->GoToSubDir(pNewIterator);
		hNewIterator = (HIter) pNewIterator;
		}

	LOGVFIEXIT(GoDown, ITERATOR, err);

	GNRAISE(err);
	}

//
//  Go up the tree (to the parent directory)
//  hIterator is checked against being invalid (==0) --> GNR_INVALID_PARAMETERS
//

DLLCALL Error WINAPI VFI_GoUp(HIter hIterator, HIter & hParentIter)
	{
	GenericFileSystemIterator * pIterator = (GenericFileSystemIterator*) hIterator;
	GenericFileSystemIterator * pNewIterator;
	Error err = GNR_INVALID_PARAMETERS;

	LOGVFI(GoUp, ITERATOR);

	if (pIterator)
		{
		err = pIterator->GoToParentDir(pNewIterator);
		hParentIter = (HIter) pNewIterator;
		}

	LOGVFIEXIT(GoUp, ITERATOR, err);

	GNRAISE(err);
	}

//
//  Find Item
//  [in] name : '\0' terminated string that identifies the item to be found
//  [in] type : file, directory or everything
//  [in] flags : specify if search should be recusrive, case sensitive, ...
//  [in] where : start point in file system
//  [out] result : new iterator that identifies the item found
//

DLLCALL Error WINAPI VFI_FindItem(char * name, VFIItemType type, DWORD flags, HIter where, HIter & result)
	{
	GenericFileSystemIterator * gfsi;
	DWORD fifFlags = FIF_NONE;
	Error err = GNR_INVALID_PARAMETERS;

	LOGVFI(FindItem, ITERATOR);

	if (where)
		{
		if (flags & VFIF_RECURSIVE)
			fifFlags |= FIF_RECURSIVE;
		if (flags & VFIF_CASE_SENSITIVE)
			fifFlags |= FIF_CASE_SENSITIVE;

		err = pRootFileSystem->FindItem(DiskItemName(name), VITToDIT(type), fifFlags,
												  (GenericFileSystemIterator*)where, gfsi);
		result = (HIter)gfsi;
		}

	LOGVFIEXIT(FindItem, ITERATOR, err);

	GNRAISE(err);
	}

//
// Open file by name
// [in] name : '\0' terminated string that identifies the
// [in] accessType : the mode in which we access the file
// [out] hFile : pointer to handle to opened file handle
//

DLLCALL Error WINAPI VFI_OpenFileByName(char * name, DWORD accessType, HFile & hFile)
	{
	GenericDiskItem * gdi;
	DWORD flags = FAT_HEADER;
	Error err;

	LOGVFI(OpenFileByName, FILE);

	if (accessType & VOIF_RECURSIVE)
		flags |= FAT_RECURSIVE;
	if (accessType & VOIF_CASE_SENSITIVE)
		flags |= FAT_CASE_SENSITIVE;

	err = pRootFileSystem->OpenItem(DiskItemName(name), flags, gdi);
	hFile = (HFile)gdi;

	LOGVFIEXIT(OpenFileByName, FILE, err);

	GNRAISE(err);
	}

//
//  Open disk item with desired access mode
//  hIterator is checked against being invalid (==0) --> GNR_INVALID_PARAMETERS
//

DLLCALL Error WINAPI VFI_Open(HIter hIterator, DWORD access, HFile & hFile)
	{
	GenericFileSystemIterator * pIterator = (GenericFileSystemIterator*)hIterator;
	GenericDiskItem * pGDI = NULL;
	Error err = GNR_INVALID_PARAMETERS;

	LOGVFI(Open, FILE);

	if (pIterator)
		{
		//
		// Open disk item with iterator
		//

		err = pIterator->OpenItem(access, pGDI);
		hFile = (HFile)pGDI;
		}

	LOGVFIEXIT(Open, FILE, err);

	GNRAISE(err);
	}

//
//  Close disk item previously opened with VFI_Open
//  hFile is checked against being invalid (==0) --> GNR_INVALID_PARAMETERS
//

DLLCALL Error WINAPI VFI_Close(HFile hFile)
	{
	Error err = GNR_INVALID_PARAMETERS;
	GenericDiskItem * pGDI = (GenericDiskItem *)hFile;

	LOGVFI(Close, FILE);

	if (pGDI)
		{
		err = pGDI->Close();
		delete pGDI;
		}

	LOGVFIEXIT(Close, FILE, err);

	GNRAISE(err);
	}

//
//  Get File Size
//  hFile is checked against being invalid (==0) --> GNR_INVALID_PARAMETERS
//

DLLCALL Error WINAPI VFI_GetFileSize(HFile hFile, DWORD & sizeLo, DWORD & sizeHi)
	{
	GenericFile * gf = (GenericFile*)hFile;
	KernelInt64 size64;
	Error err = GNR_INVALID_PARAMETERS;

	LOGVFI(GetFileSize, FILE);

	if (gf)
		{
		err = gf->GetSize(size64);
		sizeLo = size64.Lower();
		sizeHi = size64.Upper();
		}

	LOGVFIEXIT(GetFileSize, FILE, err);

	GNRAISE(err);
	}

//
//  Get Volume name
//

DLLCALL Error WINAPI VFI_GetVolumeName(HIter hIterator, DWORD & maxBufferLength, char * name)
	{
	GenericFileSystemIterator * pIterator = (GenericFileSystemIterator*) hIterator;
	GenericFileSystem * pGfs;
	KernelString sName;
	Error err;

	LOGVFI(GetVolumeName, VOLUME);

	if (pIterator && name)
		{
		if (!IS_ERROR(err = pIterator->GetFileSystem(pGfs)))
			{
			if (!IS_ERROR(err = pGfs->GetVolumeName(sName)))
				{
				//
				// Set out parameter
				//

				if (sName.Length() >= (int)maxBufferLength)
					{
					maxBufferLength = sName.Length() + 1;
					strncpy(name, (char*)sName, maxBufferLength - 1);
					name[maxBufferLength - 1] = '\0';
					err = GNR_NOT_ENOUGH_MEMORY;
					}
				else
					strcpy(name, (char*)sName);
				}
			}
		}
	else
		err = GNR_INVALID_PARAMETERS;

	LOGVFIEXIT(GetVolumeName, VOLUME, err);

	GNRAISE(err);
	}

//
//  Get Volume Set Name
//

DLLCALL Error WINAPI VFI_GetVolumeSetName(HIter hIterator, DWORD & maxBufferLength, char * name)
	{
	GenericFileSystemIterator * pIterator = (GenericFileSystemIterator*) hIterator;
	GenericFileSystem * pGfs;
	KernelString sName;
	Error err;

	LOGVFI(GetVolumeSetName, VOLUME);

	if (pIterator && name)
		{
		if (!IS_ERROR(err = pIterator->GetFileSystem(pGfs)))
			{
			if (!IS_ERROR(err = pGfs->GetVolumeSetName(sName)))
				{
				//
				// Set out parameter
				//

				if (sName.Length() >= (int)maxBufferLength)
					{
					maxBufferLength = sName.Length() + 1;
					strncpy(name, (char*)sName, maxBufferLength - 1);
					name[maxBufferLength - 1] = '\0';
					err = GNR_NOT_ENOUGH_MEMORY;
					}
				else
					strcpy(name, (char*)sName);
				}
			}
		}
	else
		err = GNR_INVALID_PARAMETERS;

	LOGVFIEXIT(GetVolumeSetName, VOLUME, err);

	GNRAISE(err);
	}

//
//  Get Volume Set Index
//

DLLCALL Error WINAPI VFI_GetVolumeSetIndex(HIter hIterator, int & index)
	{
	Error err = GNR_INVALID_PARAMETERS;
	GenericFileSystem * gfs;

	LOGVFI(GetVolumeSetIndex, VOLUME);

	if (hIterator)
		{
		if (!IS_ERROR(err = ((GenericFileSystemIterator*)hIterator)->GetFileSystem(gfs)))
			err = gfs->GetVolumeSetIndex(index);
		}

	LOGVFIEXIT(GetVolumeSetIndex, VOLUME, err);

	GNRAISE(err);
	}

//
//  Get Volume Set Size
//

DLLCALL Error WINAPI VFI_GetVolumeSetSize(HIter hIterator, int & size)
	{
	Error err = GNR_INVALID_PARAMETERS;
	GenericFileSystem * gfs;

	LOGVFI(GetVolumeSetSize, VOLUME);

	if (hIterator)
		{
		if (!IS_ERROR(((GenericFileSystemIterator*)hIterator)->GetFileSystem(gfs)))
			err = gfs->GetVolumeSetSize(size);
		}

	LOGVFIEXIT(GetVolumeSetSize, VOLUME, err);

	GNRAISE(err);
	}

//
//  Get Unique key
//  sizeof (key) must be >= 8
//

DLLCALL Error WINAPI VFI_GetUniqueKey(HIter hIterator, BYTE * key)
	{
	Error err = GNR_INVALID_PARAMETERS;
	GenericFileSystem * pGfs;

	LOGVFI(GetUniqueKey, VOLUME);

	if (hIterator)
		{
		if (!IS_ERROR(err = ((GenericFileSystemIterator*)hIterator)->GetFileSystem(pGfs)))
			err =  pGfs->GetUniqueKey(key);
		}

	LOGVFIEXIT(GetUniqueKey, VOLUME, err);

	GNRAISE(err);
	}

//
//  Get request handle
//

DLLCALL Error WINAPI VFI_GetRequestHandle(HRequest & hReq)
	{
	Error err = GNR_OK;

	LOGVFI(GetRequestHandle, GENERAL);

	hReq = (HRequest)new RequestHandle();

	if (!hReq)
		err = GNR_NOT_ENOUGH_MEMORY;

	LOGVFIEXIT(GetRequestHandle, GENERAL, err);

	GNRAISE(err);
	}

//
//  Close request handle
//

DLLCALL Error WINAPI VFI_CloseRequestHandle(HRequest hReq)
	{
	LOGVFI(CloseRequestHandle, GENERAL);

	delete (RequestHandle*)hReq;

	LOGVFIEXIT(CloseRequestHandle, GENERAL, GNR_OK);

	GNRAISE_OK;
	}

//
//  Terminate request
//

DLLCALL Error WINAPI VFI_TerminateRequest(HRequest hReq)
	{
	Error err = GNR_INVALID_PARAMETERS;

	LOGVFI(TerminateRequest, GENERAL);

	if (hReq)
		err = pRootFileSystem->TerminateRequest((RequestHandle*)hReq);

	LOGVFIEXIT(TerminateRequest, GENERAL, err);

	GNRAISE(err);
	}

//
//  Read some bytes from file
//

DLLCALL Error WINAPI VFI_ReadBytes(HFile hFile, DWORD offset, DWORD offsetHi, DWORD num, BYTE * buffer, DWORD flag, HRequest hReq)
	{
	Error err = GNR_INVALID_PARAMETERS;

	LOGVFI(ReadBytes, GENERAL);

	if (hReq && hFile)
		err = ((GenericFile*)hFile)->ReadBytes(KernelInt64(offset, offsetHi), num, buffer, flag, (RequestHandle*)hReq);

	LOGVFIEXIT(ReadBytes, GENERAL, err);

	GNRAISE(err);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\files\RootFile.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  Root File Classes
//
////////////////////////////////////////////////////////////////////

#include "RootFile.h"

////////////////////////////////////////////////////////////////////
//
//  Internal constants
//
////////////////////////////////////////////////////////////////////

#define RF_INIT_DRIVE_BLOCK_NUM 150		// Defines the number of drive blocks a volume initially has

////////////////////////////////////////////////////////////////////
//
//  File system mount point (internal use only)
//
////////////////////////////////////////////////////////////////////

class MountNode : public Node
	{
	public:
		KernelString			mountName;
		GenericDrive		*	drive;			// This one is only valid if a drive is really connected
		GenericVolume		*	volume;			// The volume in that drive
		GenericFileSystem	*	fileSystem;		// One of the possible file systems on that volume
		WORD						userCount;		// Number of users for volume and file system

		MountNode(void) : Node() { drive = NULL; volume = NULL; fileSystem = NULL; userCount = 0; }
		~MountNode(void);
	};

//
//  Destructor
//

MountNode::~MountNode(void)
	{
	if (fileSystem)
		{
		//DP("From ~MountNode - FS R:");
		fileSystem->Release();
		}

	if (volume)
		{
		//DP("From ~MountNode - V R:");
		volume->Release();
		}
	}

////////////////////////////////////////////////////////////////////
//
//  Root directory class
//
////////////////////////////////////////////////////////////////////

#if GFS_ENABLE_DIRECTORIES

//
//  Constructor
//

RootDirectory::RootDirectory(RootFileSystem * rootfs) : GenericDirectory(rootfs)
	{
	this->rootfs = rootfs;
	}

//
//  Destructor
//

RootDirectory::~RootDirectory(void)
	{
	}

//
//  Open
//

Error RootDirectory::Open(GenericFileSystemIterator * gfsi, DWORD accessType)
	{
//	return rootfs->OpenDir(this, gfsi, accessType);
	GNRAISE_OK;
	}

//
//  Close
//

Error RootDirectory::Close(void)
	{
//	return rootfs->CloseDir(this);
	GNRAISE_OK;
	}

//
//  Get item name
//

Error RootDirectory::GetName(DiskItemName & name)
	{
	return rootfs->GetItemName(rit, name);
	}

//
//  Get path name
//

Error RootDirectory::GetPathName(DiskItemName & name)
	{
	return rootfs->GetPathName(rit, name);
	}

//
//  Get iterator
//

Error RootDirectory::GetIterator(GenericFileSystemIterator * & gfsi)
	{
	return rit->Clone(gfsi);
	}

//
//  Create item
//

Error RootDirectory::CreateItem(DWORD diskItemType, const DiskItemName & name, GenericDiskItem * & gdi)
	{
	GNRAISE(GNR_DISK_READ_ONLY);
	}

//
//  Delete item
//

Error RootDirectory::DeleteItem(GenericFileSystemIterator * gfsi)
	{
	GNRAISE(GNR_DISK_READ_ONLY);
	}

//
//  Get number of items in dir
//

Error RootDirectory::GetNumberOfItems(DWORD & num)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}

//
//  Find item
//

Error RootDirectory::FindItem(const DiskItemName & name, DiskItemType type, DWORD flags, GenericFileSystemIterator * & gfsi)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}

#endif

////////////////////////////////////////////////////////////////////
//
//  Root File System Iterator Class
//
////////////////////////////////////////////////////////////////////

//
//  Constructor
//

RootIterator::RootIterator(GenericFileSystem * gfs) : GenericFileSystemIterator(gfs)
	{
	mountNode = NULL;
	((RootFileSystem*)gfs)->GoToFirstItem(this);
	}

//
//  Destructor
//

RootIterator::~RootIterator(void)
	{
//	((RootFileSystem*)gfs)->ReleaseSubFileSystem(this);
	}

//
//  Clone iterator
//

Error RootIterator::Clone(GenericFileSystemIterator * & gfsi) const
	{
	RootIterator * rit;

	GNREASSERT(Clone(rit));
	gfsi = rit;
	GNRAISE_OK;
	}

//
//  Clone iterator
//

Error RootIterator::Clone(RootIterator * & rit) const
	{
	rit = new RootIterator(gfs);
	if (rit)
		{
		rit->mountNode = mountNode;
//		((RootFileSystem*)gfs)->ObtainSubFileSystem(rit);
		GNRAISE_OK;
		}
	else
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
	}

//
//  Comparison function
//

BOOL RootIterator::Equals(GenericFileSystemIterator * gfsi)
	{
	return mountNode == ((RootIterator*)gfsi)->mountNode;
	}

//
//  Go to first item
//

Error RootIterator::GoToFirstItem(void)
	{
	return ((RootFileSystem*)gfs)->GoToFirstItem(this);
	}

//
//  Go to next item
//

Error RootIterator::GoToNextItem(void)
	{
	return ((RootFileSystem*)gfs)->GoToNextItem(this);
	}

//
//  Get subdirectory iterator
//

Error RootIterator::GoToSubDir(GenericFileSystemIterator * & gfsi)
	{
	return ((RootFileSystem*)gfs)->GoToSubDir(this, gfsi);
	}

//
//  Get parent dir iterator
//

Error RootIterator::GoToParentDir(GenericFileSystemIterator * & gfsi)
	{
	GNRAISE(GNR_ITEM_NOT_FOUND);
	}

//
//  Get path name
//

Error RootIterator::GetPathName(DiskItemName & name)
	{
	name = DiskItemName("/");
	GNRAISE_OK;
	}

//
//  Get item type
//

Error RootIterator::GetItemType(DiskItemType & type)
	{
	return ((RootFileSystem*)gfs)->GetItemType(this, type);
	}

//
//  Get item name
//

Error RootIterator::GetItemName(DiskItemName & name)
	{
	return ((RootFileSystem*)gfs)->GetItemName(this, name);
	}

//
//  Get item size
//

Error RootIterator::GetItemSize(KernelInt64 & size)
	{
	return ((RootFileSystem*)gfs)->GetItemSize(this, size);
	}

//
//  Get number of items in dir
//

Error RootIterator::GetNumberOfItems(DWORD & num)
	{
	return ((RootFileSystem*)gfs)->GetNumberOfItems(this, num);
	}

//
//  Get current directory object
//

Error RootIterator::GetCurrentDir(GenericDirectory * & gd)
	{
	return ((RootFileSystem*)gfs)->GetDir(this, gd);
	}

//
//  Obtain sub file system
//

Error RootIterator::ObtainSubFileSystem(GenericFileSystem * & sfs, DWORD dwFlags)
	{
	return ((RootFileSystem*)gfs)->ObtainSubFileSystem(this, sfs, dwFlags);
	}

//
//  Release sub file system
//

Error RootIterator::ReleaseSubFileSystem(void)
	{
	return ((RootFileSystem*)gfs)->ReleaseSubFileSystem(this);
	}

//
//  Open item
//

Error RootIterator::OpenItem(DWORD accessType, GenericDiskItem * & gdi)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}

//
//  Get RPC data
//

Error RootIterator::GetRPCData(BOOL & isRPC2, BYTE & regionCode, BYTE & availSets)
	{
	return ((RootFileSystem*)gfs)->GetRPCData(this, isRPC2, regionCode, availSets);
	}

//
//  Set region code
//

Error RootIterator::SetRegionCode(BYTE region)
	{
	return ((RootFileSystem*)gfs)->SetRegionCode(this, region);
	}

////////////////////////////////////////////////////////////////////
//
//  Root File System Class
//
//  This class forms a single common tree out of all files/dirs
//
////////////////////////////////////////////////////////////////////

//
//  Constructor
//

RootFileSystem::RootFileSystem(void)
	{
	fileSystemType = FS_ROOT;
	}

//
//  Destructor
//

RootFileSystem::~RootFileSystem(void)
	{
	MountNode * mn;

	//DP("Deleting RootFileSystem...");
	while (!mounts.IsEmpty())
		{
		mn = (MountNode*)mounts.Pop();
		delete mn;
		}
	//DP("RootFileSystem deleted");
	}

//
//  Init (build drive tables and mount the drives)
//

Error RootFileSystem::Init(GenericProfile * profile, DriveTable * driveTable)
	{
	DriveIterator it;
	MountNode * mn;
	Error err;

	//
	//  Get all drives from drive table and mount them into directory structure
	//

	err = driveTable->GoFirstDrive(it);
	while (!IS_ERROR(err))
		{
		mn = new MountNode();
		driveTable->GetDriveName(it, mn->mountName);
		driveTable->GetDrive(it, mn->drive);
		mn->volume = NULL;
		mn->fileSystem = NULL;
		mounts.InsertLast(mn);
		err = driveTable->GoNextDrive(it);
		}

	//
	//  Now add the file system folders
	//


	//
	//  Further drive tables like network etc. should be added here
	//

	GNRAISE_OK;
	}

//
//  Create file system for mount node
//  NOTE: This call also does an implicit Obtain()
//  The MountNode will be overwritten, existance of a FS/Volume has to be checked before calling this
//

Error RootFileSystem::CreateFileSystem(MountNode * mn, DWORD dwFlags)
	{
	RootIterator * rit = NULL;
	GenericVolume * volume;
	GenericFileSystem * fileSystem = NULL;
	PhysicalDiskType diskType;
	Error err = GNR_OK;

	//DP("RootFileSystem::CreateFileSystem");
	if (mn->fileSystem)
		BREAKPOINT;

	//
	//  Now create volume according to disk type
	//

	GNREASSERT(mn->drive->GetDiskType(diskType));
	switch (diskType)
		{
		case PHDT_NONE:
			GNRAISE(GNR_OBJECT_NOT_FOUND);
		case PHDT_CDDA:
			volume = new CDVDVolume();
			break;
		case PHDT_CDROM:
		case PHDT_CDI:
		case PHDT_CDROM_XA:
			volume = new CDVDVolume();
			break;
		case PHDT_DVD_ROM:
			volume = new CDVDVolume();
			break;
		case PHDT_DVD_RAM:
		case PHDT_DVD_R:
		case PHDT_DVD_RW:
		case PHDT_HD:
		default:
			GNRAISE(GNR_OBJECT_INVALID);
		}

	if (!volume)
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);

	//
	//  Initialize volume
	//

	if (!IS_ERROR(err))
		err = volume->Init(mn->drive, profile);

	if (!IS_ERROR(err))
		err = volume->SetNumberOfDriveBlocks(RF_INIT_DRIVE_BLOCK_NUM);

	//
	//  Now create file system according to disk type
	//

	if (!IS_ERROR(err))
		{
		switch (diskType)
			{
			case PHDT_NONE:
				GNRAISE(GNR_OBJECT_NOT_FOUND);
			case PHDT_CDDA:
				fileSystem = new CDFileSystem();
				break;
			case PHDT_CDROM:
			case PHDT_CDI:
			case PHDT_CDROM_XA:
					if (dwFlags & FS_CD_FILE_SYSTEM_REQUIRED)
						fileSystem = new CDFileSystem();
					else
						fileSystem = new ISOFileSystem();
				break;
			case PHDT_DVD_ROM:
				fileSystem = new UDFFileSystem();
				break;
			case PHDT_DVD_RAM:
			case PHDT_DVD_R:
			case PHDT_DVD_RW:
			case PHDT_HD:
			default:
				GNRAISE(GNR_OBJECT_INVALID);
			}

		if (!fileSystem)
			{
			delete volume;
			GNRAISE(GNR_NOT_ENOUGH_MEMORY);
			}
		}

	//
	//  Create mount point iterator
	//

	if (!IS_ERROR(err))
		{
		err = CreateIterator(rit);
//		rit->mountNode = NULL;
		rit->mountNode = mn;
		}

	//
	//  Initialize file system
	//

	if (!IS_ERROR(err))
		err = fileSystem->Init(rit, volume, profile);	// The file system has to clone the iterator

	//
	//  Cleanup
	//

	if (IS_ERROR(err))
		{
		delete fileSystem;	// Here delete instead of Release() is correct since nobody else can have obtained
		delete volume;			// this object and at least the FileSystem is not initiated
		}
	else
		{
		mn->volume = volume;
		mn->fileSystem = fileSystem;
		}

	delete rit;
	GNRAISE(err);
	}

//
//  Fill mount node
//

Error RootFileSystem::FillMountNode(MountNode * node, DWORD dwFlags /* = 0 */)
	{
	VolumeID volumeID1;
	VolumeID volumeID2;

	if (!node)
		GNRAISE(GNR_OBJECT_NOT_ALLOCATED);

	if (node->volume)		// At the moment there is no FS without volume. This might change ???
		{
		GNREASSERT(node->volume->GetVolumeID(volumeID1));
		GNREASSERT(node->drive->GetVolumeID(volumeID2));
		if (volumeID1 == volumeID2)
			{
			if (dwFlags & FS_CD_FILE_SYSTEM_REQUIRED) //Use this flag with caution - the caller
				//must ensure that all the references to file system are released (ref. count
				//should be one at this point). This is in case node has to be cleared.
				{
				if (node->fileSystem->GetFileSystemType() == FS_CD)
					GNRAISE_OK;
				}
			else
				{
				GNRAISE_OK;
				}
			}

		ClearMountNode(node);
		}

	GNRAISE(CreateFileSystem(node, dwFlags));
	}

//
//  Clear Mount Node
//

Error RootFileSystem::ClearMountNode(MountNode * node)
	{
	//DP("ClearMountNode");
	if (node->fileSystem)
		{
		//DP("From ClearMountNode - FS R:");
		node->fileSystem->Release();
		node->fileSystem = NULL;
		}

	if (node->volume)
		{
		//DP("From ClearMountNode - V R:");
		node->volume->Release();
		node->volume = NULL;
		}

	GNRAISE_OK;
	}

//
//  Obtain sub file system
//

Error RootFileSystem::ObtainSubFileSystem(RootIterator * rit, GenericFileSystem * & gfs, DWORD dwFlags /* = 0 */)
	{
	GNREASSERT(FillMountNode(rit->mountNode, dwFlags));

	//DP("From ObtainSubFileSystem - FS O: ");
	rit->mountNode->fileSystem->Obtain();
	gfs = rit->mountNode->fileSystem;
	GNRAISE_OK;
	}

//
//  Obtain sub file system
//

Error RootFileSystem::ObtainSubFileSystem(RootIterator * rit)
	{
	GenericFileSystem * gfs;

//	DP("From ObtainSFS2: ");
	GNRAISE(ObtainSubFileSystem(rit, gfs));
	}

//
//  Release sub file system
//

Error RootFileSystem::ReleaseSubFileSystem(RootIterator * rit, BOOL forced)
	{
	if (!rit->mountNode || !rit->mountNode->fileSystem)
		GNRAISE(GNR_OBJECT_INVALID);

	//DP("From ReleaseSubFileSystem - FS R: ");
	GNRAISE(rit->mountNode->fileSystem->Release());
	}

//
//  Move iterator to first item
//

Error RootFileSystem::GoToFirstItem(RootIterator * rit)
	{
	//
	//  Obtain new node
	//

	rit->mountNode = (MountNode*)mounts.First();
	if (rit->mountNode)		// This ensures, that we have mounts at all
		GNRAISE_OK;
	else
		GNRAISE(GNR_ITEM_NOT_FOUND);
	}

//
//  Move iterator to next item
//

Error RootFileSystem::GoToNextItem(RootIterator * rit)
	{
	if (rit->mountNode && !rit->mountNode->IsLast())
		{
		rit->mountNode = (MountNode*)(rit->mountNode->Succ());
		GNRAISE_OK;
		}
	else
		GNRAISE(GNR_ITEM_NOT_FOUND);
	}

//
//  Create new iterator in sub dir
//

Error RootFileSystem::GoToSubDir(RootIterator * rit, GenericFileSystemIterator * & gfsi)
	{
	Error err;

	GNREASSERT(ObtainSubFileSystem(rit));
	err = rit->mountNode->fileSystem->CreateIterator(gfsi);
	GNREASSERT(ReleaseSubFileSystem(rit));
	GNRAISE(err);
	}

//
//  Access methods, all not supported here
//

Error RootFileSystem::SeekBlock(DWORD block, DWORD flags, RequestHandle * rh)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}

Error RootFileSystem::LockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}

Error RootFileSystem::UnlockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}

Error RootFileSystem::BuildUniqueKey(void)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}

Error RootFileSystem::GetUniqueKey(BYTE * key)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}

Error RootFileSystem::GetCurrentDriveBlockSize(GenericFileSystemIterator * gfsi, DWORD & size)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}

Error RootFileSystem::SetDriveBlockSize(GenericFileSystemIterator * gfsi, DWORD size)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}

Error RootFileSystem::GetNumberOfDriveBlocks(GenericFileSystemIterator * gfsi, DWORD & num)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}

Error RootFileSystem::SetNumberOfDriveBlocks(GenericFileSystemIterator * gfsi, DWORD num)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}

Error RootFileSystem::CreateFile(DWORD flags, GenericFile * & gf)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}

//
//  Create iterator
//

Error RootFileSystem::CreateIterator(RootIterator * & rit)
	{
	rit = new RootIterator(this);
	if (rit)
		GNRAISE_OK;
	else
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
	}

//
//  Create iterator
//

Error RootFileSystem::CreateIterator(GenericFileSystemIterator * & gfsi)
	{
	gfsi = new RootIterator(this);
	if (gfsi)
		GNRAISE_OK;
	else
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
	}

//
//  Create directory
//

Error RootFileSystem::CreateDirectory(DWORD flags, GenericDirectory * & gd)
	{
#if GFS_ENABLE_DIRECTORIES
	gd = new RootDirectory(this);
	if (gd)
		GNRAISE_OK;
	else
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
#else
	GNRAISE(GNR_UNIMPLEMENTED);
#endif
	}

//
//  Get path name
//

Error RootFileSystem::GetPathName(RootIterator * rit, DiskItemName & name)
	{
	return name.GetDefaultSeparator();
	}

//
//  Get item type
//

Error RootFileSystem::GetItemType(RootIterator * rit, DiskItemType & type)
	{
	type = DIT_DIR;
	GNRAISE_OK;
	}

//
//  Get item name
//

Error RootFileSystem::GetItemName(RootIterator * rit, DiskItemName & name)
	{
	name = rit->mountNode->mountName;
	GNRAISE_OK;
	}

//
//  Get item size
//

Error RootFileSystem::GetItemSize(RootIterator * rit, KernelInt64 & size)
	{
	size = 0;
	GNRAISE_OK;
	}

//
//  Get directory
//

Error RootFileSystem::GetDir(RootIterator * rit, GenericDirectory * & gd)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}

//
//  Get number of items in dir
//

Error RootFileSystem::GetNumberOfItems(RootIterator * rit, DWORD & num)
	{
	num = mounts.Num();
	GNRAISE_OK;
	}

//
//  Terminate request
//

Error RootFileSystem::TerminateRequest(RequestHandle * rh)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}

//
//  Spin up drive
//

Error RootFileSystem::SpinUpDrive(RootIterator * rit)
	{
	if (rit->mountNode && rit->mountNode->fileSystem)
		GNRAISE(rit->mountNode->fileSystem->SpinUpDrive());
	else
		GNRAISE(GNR_NO_FILE_SYSTEM);
	}

//
//  Spin down drive
//

Error RootFileSystem::SpinDownDrive(RootIterator * rit)
	{
	if (rit->mountNode && rit->mountNode->fileSystem)
		GNRAISE(rit->mountNode->fileSystem->SpinDownDrive());
	else
		GNRAISE(GNR_NO_FILE_SYSTEM);
	}


#if MSNDISC

Error RootFileSystem::GetDriveCaps(RootIterator * rit, DWORD& caps, DWORD& slots, DWORD& positions, DWORD& changerOpenOffset )
	{
	GenericDriveType	type;

	if (rit->mountNode && rit->mountNode->drive)
		GNRAISE(rit->mountNode->drive->GetDriveCaps(type,caps,slots,positions,changerOpenOffset));
	else
		GNRAISE(GNR_NO_DRIVE);
	}

Error RootFileSystem::MoveChanger(RootIterator * rit, DWORD operation, DWORD flags, DWORD param )
	{
	if (rit->mountNode && rit->mountNode->drive)
		GNRAISE(rit->mountNode->drive->MoveChanger(operation,flags,param));
	else
		GNRAISE(GNR_NO_DRIVE);
	}

Error RootFileSystem::GetChangerStatus(RootIterator * rit, DWORD& status, DWORD& position)
	{
	if (rit->mountNode && rit->mountNode->drive)
		GNRAISE(rit->mountNode->drive->GetChangerStatus(status, position));
	else
		GNRAISE(GNR_NO_DRIVE);
	}

Error RootFileSystem::GetSlotStatus(RootIterator * rit, DWORD slot, DWORD& status )
	{
	if (rit->mountNode && rit->mountNode->drive)
		GNRAISE(rit->mountNode->drive->GetSlotStatus(slot, status));
	else
		GNRAISE(GNR_NO_DRIVE);
	}

Error RootFileSystem::LockClamp(RootIterator * rit)
	{
	if (rit->mountNode && rit->mountNode->drive)
		GNRAISE(rit->mountNode->drive->LockClamp());
	else
		GNRAISE(GNR_NO_DRIVE);
	}

Error RootFileSystem::UnlockClamp(RootIterator * rit)
	{
	if (rit->mountNode && rit->mountNode->drive)
		GNRAISE(rit->mountNode->drive->UnlockClamp());
	else
		GNRAISE(GNR_NO_DRIVE);
	}

Error RootFileSystem::LoadMedia(RootIterator * rit, int slotNumber, DWORD flags)
	{
	DWORD changerStatus;
	DWORD changerPosition;
	GNREASSERT(GetChangerStatus(rit, changerStatus, changerPosition));
	if (rit->mountNode && rit->mountNode->drive)
		{
		GNREASSERT(rit->mountNode->drive->LoadMedia(slotNumber, flags));
		GNRAISE(LockClamp(rit));
		}
	else
		GNRAISE(GNR_NO_DRIVE);
	}

Error RootFileSystem::UnloadMedia(RootIterator * rit, DWORD flags)
	{
	if (rit->mountNode && rit->mountNode->drive)
		{
		GNREASSERT(UnlockClamp(rit));
		GNRAISE(rit->mountNode->drive->UnloadMedia(flags));
		}
	else
		GNRAISE(GNR_NO_DRIVE);
	}

Error RootFileSystem::GetRPCData(RootIterator * rit, BOOL & isRPC2, BYTE & regionCode, BYTE & availSets)
	{
	GenericDriveType type;
	DWORD caps;
	DWORD slots;
	DWORD positions;
	DWORD changerOpenOffset;

	GNREASSERT(rit->mountNode->drive->GetDriveCaps(type, caps, slots,positions,changerOpenOffset));
	if (type = GDRT_CDVD)
		GNRAISE(((CDVDDrive*)rit->mountNode->drive)->GetRPCData(isRPC2, regionCode, availSets));
	else
		GNRAISE(GNR_OBJECT_INVALID);
	}

Error RootFileSystem::SetRegionCode(RootIterator * rit, BYTE region)
	{
	GenericDriveType type;
	DWORD caps;
	DWORD slots;
	DWORD positions;
	DWORD changerOpenOffset;

	GNREASSERT(rit->mountNode->drive->GetDriveCaps(type, caps, slots,positions,changerOpenOffset));
	if (type = GDRT_CDVD)
		GNRAISE(((CDVDDrive*)rit->mountNode->drive)->SetRegionCode(region));
	else
		GNRAISE(GNR_OBJECT_INVALID);
	}

#else


//
//  Load media
//

Error RootFileSystem::LoadMedia(RootIterator * rit, int slotNumber, DWORD flags)
	{
	GenericTrayStatus trayStatus;

	GNREASSERT(GetTrayStatus(rit, trayStatus));
	if (rit->mountNode && rit->mountNode->drive)
		{
		GNREASSERT(rit->mountNode->drive->LoadMedia(slotNumber, flags));
		GNRAISE(LockTray(rit));
		}
	else
		GNRAISE(GNR_NO_DRIVE);
	}

//
//  Undload media
//

Error RootFileSystem::UnloadMedia(RootIterator * rit, DWORD flags)
	{
	if (rit->mountNode && rit->mountNode->drive)
		{
		GNREASSERT(UnlockTray(rit));
		GNRAISE(rit->mountNode->drive->UnloadMedia(flags));
		}
	else
		GNRAISE(GNR_NO_DRIVE);
	}

//
//  Get tray status
//

Error RootFileSystem::GetTrayStatus(RootIterator * rit, GenericTrayStatus & status)
	{
	if (rit->mountNode && rit->mountNode->drive)
		GNRAISE(rit->mountNode->drive->GetTrayStatus(status));
	else
		GNRAISE(GNR_NO_DRIVE);
	}

//
//  Lock tray
//

Error RootFileSystem::LockTray(RootIterator * rit)
	{
	if (rit->mountNode && rit->mountNode->drive)
		GNRAISE(rit->mountNode->drive->LockTray());
	else
		GNRAISE(GNR_NO_DRIVE);
	}

//
//  Unlock tray
//

Error RootFileSystem::UnlockTray(RootIterator * rit)
	{
	if (rit->mountNode && rit->mountNode->drive)
		GNRAISE(rit->mountNode->drive->UnlockTray());
	else
		GNRAISE(GNR_NO_DRIVE);
	}

#endif

//
// Abort current disk-access operation and disable all disk
// requests until EnableDiskRequests() is called
//

Error RootFileSystem::AbortAndDisableDiskRequests(RootIterator * rit)
	{
	if (rit->mountNode && rit->mountNode->drive)
		{
		GNREASSERT(rit->mountNode->drive->TerminateRequest(NULL));
		rit->mountNode->drive->DisableRequests();
		GNRAISE_OK;
		}
	else
		GNRAISE(GNR_NO_DRIVE);
	}

//
// Enable disk requests - to be used after AbortAndDisableDiskRequests()
//

Error RootFileSystem::EnableDiskRequests(RootIterator * rit)
	{
	if (rit->mountNode && rit->mountNode->drive)
		{
		rit->mountNode->drive->EnableRequests();
		//ClearMountNode(rit->mountNode);
		GNRAISE_OK;
		}
	else
		GNRAISE(GNR_NO_DRIVE);
	}

//
//  Get RPC data
//

#if MSNDISC
#else
Error RootFileSystem::GetRPCData(RootIterator * rit, BOOL & isRPC2, BYTE & regionCode, BYTE & availSets)
	{
	GenericDriveType type;
	DWORD caps;
	DWORD slots;

	GNREASSERT(rit->mountNode->drive->GetDriveCaps(type, caps, slots));
	if (type = GDRT_CDVD)
		GNRAISE(((CDVDDrive*)rit->mountNode->drive)->GetRPCData(isRPC2, regionCode, availSets));
	else
		GNRAISE(GNR_OBJECT_INVALID);
	}
#endif
//
//  Set region code
//

#if MSNDISC
#else
Error RootFileSystem::SetRegionCode(RootIterator * rit, BYTE region)
	{
	GenericDriveType type;
	DWORD caps;
	DWORD slots;

	GNREASSERT(rit->mountNode->drive->GetDriveCaps(type, caps, slots));
	if (type = GDRT_CDVD)
		GNRAISE(((CDVDDrive*)rit->mountNode->drive)->SetRegionCode(region));
	else
		GNRAISE(GNR_OBJECT_INVALID);
	}
#endif
//
//  Get volume name
//

Error RootFileSystem::GetVolumeName(RootIterator * rit, KernelString name)
	{
	Error err;

	GNREASSERT(ObtainSubFileSystem(rit));
	err = rit->mountNode->fileSystem->GetVolumeName(name);
	GNREASSERT(ReleaseSubFileSystem(rit));
	GNRAISE(err);
	}

//
//  Get volume set name
//

Error RootFileSystem::GetVolumeSetName(RootIterator * rit, KernelString name)
	{
	Error err;

	GNREASSERT(ObtainSubFileSystem(rit));
	err = rit->mountNode->fileSystem->GetVolumeSetName(name);
	GNREASSERT(ReleaseSubFileSystem(rit));
	GNRAISE(err);
	}

//
//  Get volume set index
//

Error RootFileSystem::GetVolumeSetIndex(RootIterator * rit, int index)
	{
	Error err;

	GNREASSERT(ObtainSubFileSystem(rit));
	err = rit->mountNode->fileSystem->GetVolumeSetIndex(index);
	GNREASSERT(ReleaseSubFileSystem(rit));
	GNRAISE(err);
	}

//
//  Get volume set size
//

Error RootFileSystem::GetVolumeSetSize(RootIterator * rit, int size)
	{
	Error err;

	GNREASSERT(ObtainSubFileSystem(rit));
	err = rit->mountNode->fileSystem->GetVolumeSetSize(size);
	GNREASSERT(ReleaseSubFileSystem(rit));
	GNRAISE(err);
	}

//
//  Get unique key for drive
//

Error RootFileSystem::GetUniqueKey(RootIterator * rit, BYTE * key)
	{
	Error err;

	GNREASSERT(ObtainSubFileSystem(rit));
	err = rit->mountNode->fileSystem->GetUniqueKey(key);
	GNREASSERT(ReleaseSubFileSystem(rit));
	GNRAISE(err);
	}

//
//  Get disk information
//

Error RootFileSystem::GetDiskInformation(RootIterator * rit, DiskInformation * & di)
	{
	GNREASSERT(ObtainSubFileSystem(rit));
	GNREASSERT(rit->mountNode->drive->GetDriveName(di->driveName));
	GNREASSERT(rit->mountNode->drive->GetDiskType(di->diskType));
	GNREASSERT(rit->mountNode->fileSystem->GetVolumeName(di->volumeName));
	GNREASSERT(rit->mountNode->fileSystem->GetUniqueKey(di->uniqueKey));
	GNREASSERT(GetRPCData(rit, di->isRPC2, di->driveRegion, di->availSets));
	GNREASSERT(ReleaseSubFileSystem(rit));
//	diskRegion;?????
	GNRAISE_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\files\VFI.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  VIONA File Interface
//
////////////////////////////////////////////////////////////////////

#ifndef VFI_H
#define VFI_H

#include "Library/Common/Prelude.h"
#include "Library/Common/GNErrors.h"

#ifndef ONLY_EXTERNAL_VISIBLE
#include "Library/Files/RootFile.h"
#endif

////////////////////////////////////////////////////////////////////
//
//  Type definitions
//
////////////////////////////////////////////////////////////////////

// Handle to iterator
typedef void * HIter;

// Handle to file
typedef void * HFile;

// Handle to request identifer
typedef void * HRequest;

//
//  Item type
//

enum VFIItemType
	{
	VIT_NONE		= 0x0000,
	VIT_FILE		= 0x0001,
	VIT_DIR		= 0x0002,
	VIT_ALL		= 0xffff
	};

//
//  VFI_FindItem flags
//

#define VFIF_NONE					0x00000000		// Nothing at all
#define VFIF_RECURSIVE			0x00000001		// Do recursive search
#define VFIF_CASE_SENSITIVE	0x00000002		// Search is case sensitive

//
//  VFI_OpenItem flags
//

#define VOIF_NONE					0x00000000		// Nothing at all
#define VOIF_RECURSIVE			0x00000001		// Do recursive search
#define VOIF_CASE_SENSITIVE	0x00000002		// When opening file by name search is case sensitive

////////////////////////////////////////////////////////////////////
//
//	VFI startup and shutdown
//
////////////////////////////////////////////////////////////////////

#ifndef ONLY_EXTERNAL_VISIBLE

Error VFI_Init(GenericFileSystem * pRootSystem);	// Should be called from DLL Entry routine

Error VFI_Cleanup(void);

#endif

////////////////////////////////////////////////////////////////////
//
// Iterator handling
//
////////////////////////////////////////////////////////////////////

//
//  Iterator creation and delete
//

// Create Iterator
DLLCALL Error WINAPI VFI_CreateIterator(HIter & pHIterator);

// Close Iterator
DLLCALL Error WINAPI VFI_DeleteIterator(HIter hIterator);

// Clone Iterator
DLLCALL Error WINAPI VFI_CloneIterator(HIter hIterator, HIter & clone);


//
//  Iterator item handling
//

// get name of item the iterator points to
DLLCALL Error WINAPI VFI_GetItemName(HIter hIterator, DWORD & maxBufferLength, char * psName);

// get path of item
DLLCALL Error WINAPI VFI_GetItemPath(HIter hIterator, DWORD & maxBufferLength, char * psPath);

// get item type
// [in] hIterator : iterator
// [out] pType : type of item the iterator points to
DLLCALL Error WINAPI VFI_GetItemType(HIter hIterator, VFIItemType & type);

// get size of item pointed to by the iterator
// [in] hIterator : handle to iterator that point to an item
// [out] size : size of item pointed to by the iterator
DLLCALL Error WINAPI VFI_GetItemSize(HIter hIterator, DWORD & size, DWORD & hiPart);

// get number of items
// [in] hIterator
// [out] num : number of items in the directory the iterator is pointing to
DLLCALL Error WINAPI VFI_GetNumberOfItems(HIter hIterator , DWORD & num);

//
//  Iterator navigation
//

// go to next item in iterator
// [in] hIterator : handle to iterator that should be set to next element in directory
DLLCALL Error WINAPI VFI_GoNext(HIter hIterator);

// got to first item in iterator
// the iterator given as parameter is set to the first element of the directory
// [in] hIterator : handle to iterator that should be set to the first element of the directory
DLLCALL Error WINAPI VFI_GoFirst(HIter hIterator);

// open the directory the iterator points to.
// [in] hIterator : Iterator that points to the directory
// [out] hNewIterator : pointer to new handle to iterator that points to the first element of the opened directory
DLLCALL Error WINAPI VFI_GoDown(HIter hIterator, HIter & hNewIterator);

// get iterator to parent directory
// [in] hIterator : Iterator that points somewhere in a directory
// [out] hParentIter : pointer to handle of iterator that points to the first element of the parent directory
DLLCALL Error WINAPI VFI_GoUp(HIter hIterator, HIter & hParentIter);

// Find Item
// [in] name : '\0' terminated string that identifies the item to be found
// [in] type : file, directory or everything
// [in] flags : specify if search should be recusrive, case sensitive, ...
// [in] where : start point in file system
// [out] result : new iterator that identifies the item found
DLLCALL Error WINAPI VFI_FindItem(char * name, VFIItemType type, DWORD flags, HIter where, HIter & result);

////////////////////////////////////////////////////////////////////
//
//  Volume handling
//
////////////////////////////////////////////////////////////////////


// get name of volume the given iterator is currently acting on
// [in] hIterator : Iterator used
// [in] maxBufferLength : buffer length for buffer sName
// [out] sChar : name of volume the iterator is acting on
DLLCALL Error WINAPI VFI_GetVolumeName(HIter hIterator, DWORD & maxBufferLength, char * &sName);


// get volume set name a given iterator is currently acting on
DLLCALL Error WINAPI VFI_GetVolumeSetName(HIter hIterator, DWORD & maxBufferLength, char * &sName);


// get index in volume set of the volume the given iterator is acting on
DLLCALL Error WINAPI VFI_GetVolumeSetIndex(HIter hIterator, int & index);


// get size of volume set the current volume the given iterator is acting on is part of
// [in] hIterator : handle of iterator to get the volume set size
// [out] size : size of volume set
DLLCALL Error WINAPI VFI_GetVolumeSetSize(HIter hIterator, int & size);


// get unique key
// get key sequence that represents an unique identifier of the volume the current iterator is acting on
DLLCALL Error WINAPI VFI_GetUniqueKey(HIter hIterator, BYTE * key);


////////////////////////////////////////////////////////////////////
//
//  Files
//
////////////////////////////////////////////////////////////////////

//
//  For some calls you need a request handle so you can abort the call identified by this handle
//

// Get request handle
DLLCALL Error WINAPI VFI_GetRequestHandle(HRequest & hReq);


// close request handle
DLLCALL Error WINAPI VFI_CloseRequestHandle(HRequest hReq);


// cancel request
DLLCALL Error WINAPI VFI_CancelRequest(HRequest hReq);

// Open file by name
// [in] name : '\0' terminated string that identifies the
// [in] accessType : the mode in which we access the file
// [out] hFile : pointer to handle to opened file handle
DLLCALL Error WINAPI VFI_OpenFileByName(char * name, DWORD accessType, HFile & hFile);

// open the file that an iterator handle points to
// [in] hIterator : Iterator that points to a file item
// [in] accessType : the mode in which we access the file
// [out] hFile : pointer to handle to opened file handle
DLLCALL Error WINAPI VFI_Open(HIter hIterator, DWORD accessType, HFile & hFile);

// close item
DLLCALL Error WINAPI VFI_Close(HFile hFile);

// get size of file
// [in] hFile : handle to file
// [out] size : size of item pointed to by the iterator
DLLCALL Error WINAPI VFI_GetFileSize(HFile hFile, DWORD & sizeLo, DWORD & sizeHi);

// read bytes from file
// the file must be created by calling Open(...)
// [in] hFile : handle of file, returned by Open(iterator, ..)
// [in] offset : offset in file to start read
// [in] offsetHi : hi part of offset
// [in] num	: number of bytes to be read
// [out] buffer : buffer filled with block data. Size must be at least num bytes
// [in] flag : flags
// [in] pReq : handle to request. Can be used to interrupt or cancel request
DLLCALL Error WINAPI VFI_ReadBytes(HFile hFile, DWORD offset, DWORD offsetHi, DWORD num, BYTE * buffer, DWORD flag, HRequest pReq);


#endif // VFI_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\files\VolumeCache.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  Volume Cache Classes
//
////////////////////////////////////////////////////////////////////

#ifndef VOLUMECACHE_H
#define VOLUMECACHE_H

#include "library/hardware/drives/generic/GenericDrive.h"

////////////////////////////////////////////////////////////////////
//
//  Volume Cache Block Class
//
////////////////////////////////////////////////////////////////////

class VolumeCacheBlock
	{
	friend class VolumeCache;

	protected:
		VolumeCacheBlock	*	next;
		DriveBlock				driveBlock;
		int						lockCnt;

	public:
		VolumeCacheBlock(DWORD blockSize);
		~VolumeCacheBlock(void);

		void Obtain(void) {lockCnt++;}
		void Release(void) {lockCnt--;}
	};

////////////////////////////////////////////////////////////////////
//
//  Volume Cache Class
//
////////////////////////////////////////////////////////////////////

class VolumeCache
	{
	protected:
		VDLocalMutex lock;
		VolumeCacheBlock * first;
		GenericDrive * drive;
		DWORD blockSize;

	public:
		VolumeCache(void);
		virtual ~VolumeCache(void);

		virtual Error Init(GenericDrive * drive, DWORD blockNum, DWORD blockSize);
		virtual Error Cleanup(void);

		virtual Error LockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh);
		virtual Error UnlockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh);
		virtual Error Flush(void);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\files\UDFFile.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  UDF File Classes
//
////////////////////////////////////////////////////////////////////

#include "library/files/UDFFile.h"

////////////////////////////////////////////////////////////////////
//
//  Defines
//
////////////////////////////////////////////////////////////////////

//
//  UDF descriptor tag values
//

#define UDF_TAG_TERMINATE			  8
#define UDF_TAG_FILESET_DESC		256
#define UDF_TAG_FILE_IDENT			257
#define UDF_TAG_ALLOC_EXTENT		258
#define UDF_TAG_INDIRECT_ENTRY	259
#define UDF_TAG_TERMINAL_ENTRY	260
#define UDF_TAG_FILE_ENTRY			261
#define UDF_TAG_EXT_ATTR_HEADER	262
#define UDF_TAG_UNALLOC_SPACE		263
#define UDF_TAG_SPACE_MAP			264
#define UDF_TAG_PARTITION_INTEG	265

//
//  UDF File Entry (ICB) Offsets
//

#define UDF_ICB_DESC_TAG			0		// 16 bytes
#define UDF_ICB_INFO_LEN			56		// 8 bytes
#define UDF_ICB_EXT_ATTR_LEN		168	// 4 bytes
#define UDF_ICB_ALLOC_DESC_LEN	172	// 4 bytes
#define UDF_ICB_EXT_ATTR			176

//
//  Offsets within Primary Volume Descriptor
//

#define UDF_PVD_VOLUME_IDENT		24
#define UDF_PVD_VOLUME_SET_INDEX	56
#define UDF_PVD_VOLUME_SET_SIZE	58
#define UDF_PVD_VOLUME_SET_IDENT	72
#define UDF_PVD_RECORDING_DATE	376

//
//  UDF File Identifier Descriptor Offsets
//

#define UDF_FID_DESC_TAG		0		// 16 bytes
#define UDF_FID_FILE_CHAR		18		// 1 byte
#define UDF_FID_IDENT_LEN		19		// 1 byte
#define UDF_FID_ICB				20		// 16 bytes
#define UDF_FID_IMP_USE_LEN	36		// 2 bytes

//
//  UDF file characteristics in file identifier descriptor
//

#define UDF_FILECHAR_EXIST			0x01		// If 1 the user shall not see this entry
#define UDF_FILECHAR_DIR			0x02  	// If 1 this is a directory entry
#define UDF_FILECHAR_DELETED		0x04		// If 1 this entry has been deleted
#define UDF_FILECHAR_PARENT		0x08		// If 1 this entry points to the parent dir
#define UDF_FILECHAR_METADATA		0x10		// Something with stream directories

//
//  Access macros
//

#define UDF_BYTE(d)	((d)[0])
#define UDF_WORD(d)	MAKEWORD((d)[0], (d)[1])
#define UDF_DWORD(d)	MAKELONG(MAKEWORD((d)[0], (d)[1]), MAKEWORD((d)[2], (d)[3]))
#define UDF_QWORD(d)	KernelInt64(UDF_DWORD(d), UDF_DWORD(d + 4))

////////////////////////////////////////////////////////////////////
//
//  UDF File Class
//
////////////////////////////////////////////////////////////////////

//
//  Constructor
//

UDFFile::UDFFile(UDFFileSystem * udffs) : GenericFile(udffs)
	{
	this->udffs = udffs;
	udfi = NULL;
	gcmiValid = FALSE;
	}

//
//  Destructor
//

UDFFile::~UDFFile(void)
	{
	delete udfi;
	}

//
//  Open
//

Error UDFFile::Open(GenericFileSystemIterator * gfsi, DWORD accessType)
	{
	GenericFileSystemIterator * gfsi2;
	DWORD dummy;
	Error err;

	if (accessType & FAT_WRITE)
		GNRAISE(GNR_FILE_READ_ONLY);

	GNREASSERT(GenericFile::Open(gfsi, accessType));

	GNREASSERT(gfsi->Clone(gfsi2));
	udfi = (UDFIterator *)gfsi2;

	err = udffs->GetAllocDescriptor(udfi, 0, startBlock, dummy);

	if (!IS_ERROR(err))
		err = udffs->GetCopyManagementInfo(udfi, gcmi);

	if (IS_ERROR(err))
		{
		delete udfi;
		udfi = NULL;
		}

	GNRAISE(err);
	}

//
//  Close
//

Error UDFFile::Close(void)
	{
	delete udfi;
	udfi = NULL;
	GNRAISE_OK;
	}

//
//  Get name
//

Error UDFFile::GetName(DiskItemName & name)
	{
	return udffs->GetItemName(udfi, name);
	}

//
//  Get path name
//

Error UDFFile::GetPathName(DiskItemName & name)
	{
	return udffs->GetPathName(udfi, name);
	}

//
//  Get size
//

Error UDFFile::GetSize(KernelInt64 & size)
	{
	return udffs->GetItemSize(udfi, size);
	}

//
//  Get iterator
//

Error UDFFile::GetIterator(GenericFileSystemIterator * & gfsi)
	{
	return udfi->Clone(gfsi);
	}

//
//  Build unique key
//

Error UDFFile::BuildUniqueKey(void)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}

//
//  Get copy management mode
//

Error UDFFile::GetCopyManagementInfo(GenericCopyManagementInfo & gcmi)
	{
	if (!gcmiValid)
		GNREASSERT(udffs->GetCopyManagementInfo(udfi, this->gcmi));

	gcmi = this->gcmi;
	gcmiValid = TRUE;
	GNRAISE_OK;
	}

//
//  Seek block
//

Error UDFFile::SeekBlock(DWORD block, DWORD flags, RequestHandle * rh)
	{
	return udffs->SeekBlock(startBlock + block, flags, rh);
	}

//
//  Lock blocks
//

Error UDFFile::LockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh)
	{
	if (headerFile)
		flags = (flags & ~GD_SECTOR_TYPE_MASK) | udffs->GetHeaderSectorType();
	else
		flags = (flags & ~GD_SECTOR_TYPE_MASK) | udffs->GetDataSectorType();

	return udffs->LockBlocks(startBlock + block, num, blocks, flags, rh);
	}

//
//  Unlock blocks
//

Error UDFFile::UnlockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh)
	{
	if (headerFile)
		flags = (flags & ~GD_SECTOR_TYPE_MASK) | udffs->GetHeaderSectorType();
	else
		flags = (flags & ~GD_SECTOR_TYPE_MASK) | udffs->GetDataSectorType();

	return udffs->UnlockBlocks(startBlock + block, num, blocks, flags, rh);
	}

////////////////////////////////////////////////////////////////////
//
//  UDF Directory Class
//
////////////////////////////////////////////////////////////////////

#if GFS_ENABLE_DIRECTORIES

//
//  Constructor
//

UDFDirectory::UDFDirectory(UDFFileSystem * udffs) : GenericDirectory(udffs)
	{
	this->udffs = udffs;
	udfi = NULL;
	}

//
//  Desctructor
//

UDFDirectory::~UDFDirectory(void)
	{
	delete udfi;
	}

//
//  Open directory
//

Error UDFDirectory::Open(GenericFileSystemIterator * gfsi, DWORD accessType)
	{
	GNRAISE_OK;
	}

//
//  Close
//

Error UDFDirectory::Close(void)
	{
	GNRAISE_OK;
	}

//
//  Get name
//

Error UDFDirectory::GetName(DiskItemName & name)
	{
	return udffs->GetItemName(udfi, name);
	}

//
//  Get path name
//

Error UDFDirectory::GetPathName(DiskItemName & name)
	{
	return udffs->GetPathName(udfi, name);
	}

//
//  Return iterator pointing to this directory
//

Error UDFDirectory::GetIterator(GenericFileSystemIterator * & gfsi)
	{
	return udfi->Clone(gfsi);
	}

//
//  Create item
//

Error UDFDirectory::CreateItem(DWORD diskItemType, const DiskItemName & name, GenericDiskItem * & gdi)
	{
	GNRAISE(GNR_DISK_READ_ONLY);
	}

//
//  Delete item
//

Error UDFDirectory::DeleteItem(GenericFileSystemIterator * gfsi)
	{
	GNRAISE(GNR_DISK_READ_ONLY);
	}

//
//  Get number of items
//

Error UDFDirectory::GetNumberOfItems(DWORD & num)
	{
	return udffs->GetNumberOfItems(udfi, num);
	}

//
//  Find item
//

Error UDFDirectory::FindItem(const DiskItemName & name, DiskItemType type, DWORD flags, GenericFileSystemIterator * & gfsi)
	{
	GenericFileSystemIterator * where;
	Error err;

	GNREASSERT(GetIterator(where));
	if (!IS_ERROR(err = udffs->FindItem(name, type, flags, where, gfsi)))
		delete where;
	GNRAISE(err);
	}

#endif

////////////////////////////////////////////////////////////////////
//
//  UDF File System Iterator Class
//  NOTE: This points to a UDF File Identifier Descriptor
//
////////////////////////////////////////////////////////////////////

//
//  Constructor
//

UDFIterator::UDFIterator(GenericFileSystem * gfs) : GenericFileSystemIterator(gfs)
	{
	}

//
//  Destructor
//

UDFIterator::~UDFIterator(void)
	{
	}

//
//  Clone
//

Error UDFIterator::Clone(UDFIterator * & udfi) const
	{
	udfi = new UDFIterator(gfs);
	if (udfi)
		{
		udfi->dirICB = dirICB;
		udfi->dirStart = dirStart;
		udfi->dirSize = dirSize;
		udfi->entryOffset = entryOffset;
		GNRAISE_OK;
		}
	else
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
	}

//
//  Clone
//

Error UDFIterator::Clone(GenericFileSystemIterator * & gfsi) const
	{
	UDFIterator * udfi;

	GNREASSERT(Clone(udfi));
	gfsi = udfi;
	GNRAISE_OK;
	}

//
//  Comparison function
//

BOOL UDFIterator::Equals(GenericFileSystemIterator * gfsi)
	{
	return (dirStart    == ((UDFIterator*)gfsi)->dirStart) &&
			 (entryOffset == ((UDFIterator*)gfsi)->entryOffset);
	}

//
//  Go to first item in directory
//

Error	UDFIterator::GoToFirstItem(void)
	{
	return ((UDFFileSystem*)gfs)->GoToFirstItem(this);
	}

//
//  Go to next item in directory
//

Error	UDFIterator::GoToNextItem(void)
	{
	return ((UDFFileSystem*)gfs)->GoToNextItem(this);
	}

//
//  Enter subdirectory
//

Error	UDFIterator::GoToSubDir(GenericFileSystemIterator * & gfsi)
	{
	return ((UDFFileSystem*)gfs)->GoToSubDir(this, gfsi);
	}

//
//  Go to parent directory
//

Error	UDFIterator::GoToParentDir(GenericFileSystemIterator * & gfsi)
	{
	return ((UDFFileSystem*)gfs)->GoToParentDir(this, gfsi);
	}

//
//  Get path name of current directory
//

Error UDFIterator::GetPathName(DiskItemName & name)
	{
	return ((UDFFileSystem*)gfs)->GetPathName(this, name);
	}

//
//  Get type of item pointed to
//

Error UDFIterator::GetItemType(DiskItemType & type)
	{
	return ((UDFFileSystem*)gfs)->GetItemType(this, type);
	}

//
//  Get name of item pointed to
//

Error UDFIterator::GetItemName(DiskItemName & name)
	{
	return ((UDFFileSystem*)gfs)->GetItemName(this, name);
	}

//
//  Get size of item pointed to
//

Error UDFIterator::GetItemSize(KernelInt64 & size)
	{
	return ((UDFFileSystem*)gfs)->GetItemSize(this, size);
	}

//
//  Get the number of items in the directory the iterator is in
//

Error UDFIterator::GetNumberOfItems(DWORD & num)
	{
	return ((UDFFileSystem*)gfs)->GetNumberOfItems(this, num);
	}

//
//  Get the directory the iterator is currently in
//

Error UDFIterator::GetCurrentDir(GenericDirectory * & gd)
	{
	return ((UDFFileSystem*)gfs)->GetDir(this, gd);
	}

//
//  Open item pointed to
//

Error	UDFIterator::OpenItem(DWORD fileAccessType, GenericDiskItem * & gdi)
	{
	return ((UDFFileSystem*)gfs)->OpenItem(this, fileAccessType, gdi);
	}

////////////////////////////////////////////////////////////////////
//
//  UDF File System Class
//
////////////////////////////////////////////////////////////////////

//
//  Constructor
//

UDFFileSystem::UDFFileSystem(void) : GenericFileSystem()
	{
	cdvdVolume = NULL;
	fileSystemType = FS_UDF;
	}

//
//  Destructor
//

UDFFileSystem::~UDFFileSystem(void)
	{
	}

//
//  Initialize
//

Error UDFFileSystem::Init(GenericFileSystemIterator * mountPoint, GenericVolume * volume, GenericProfile * profile)
	{
	VDAutoMutex mutex(&lock);
	RequestHandle rh;
	PhysicalDiskType type;
	DriveBlock db;
	Error err;
	int i;

	//
	//  Make sure we have the right volume type
	//

	GNREASSERT(volume->GetDiskType(type));
	if (type != PHDT_DVD_ROM)
		GNRAISE(GNR_VOLUME_INVALID);

	GNREASSERT(GenericFileSystem::Init(mountPoint, volume, profile));
	this->cdvdVolume = (CDVDVolume*)volume;

	//
	//  Read Anchor Volume Descriptor Pointer
	//  and find Primary Volume Descriptor
	//

	err = cdvdVolume->LockBlocks(256, 1, &db, DST_DVD_ROM | DAT_LOCK_AND_READ, &rh);
	if (!IS_ERROR(err) && UDF_BYTE(db.data) == 0x02)	// Make sure we have what we hope to have
		primaryVolumeDescriptor = UDF_DWORD(db.data + 20);

	cdvdVolume->UnlockBlocks(256, 1, &db, DST_DVD_ROM | DAT_UNLOCK_CLEAN, &rh);

	//
	//  Read Volume Name and compute unique id
	//

	if (!IS_ERROR(err))
		{
		err = cdvdVolume->LockBlocks(primaryVolumeDescriptor, 1, &db, DST_DVD_ROM | DAT_LOCK_AND_READ, &rh);

		if (!IS_ERROR(err))
			{
			char name[129];

			// Get volume name
			memcpy(name, db.data + UDF_PVD_VOLUME_IDENT + 1, 32-1); //+1/-1 for skipping leading 0x08 (Why is 0x08 there? No one knows...)
			name[32-1] = 0; //put the elephant in Cairo
			volumeName = name;
			volumeName = volumeName.Trim();

			// Get volume set name
			memcpy(name, db.data + UDF_PVD_VOLUME_SET_IDENT + 1, 128-1); //+1/-1 for skipping leading 0x08
			name[128-1] = 0;
			volumeSetName = name;
			volumeSetName = volumeSetName.Trim();

			// Get some more values
			volumeSetIndex = UDF_WORD(db.data + UDF_PVD_VOLUME_SET_INDEX);
			volumeSetSize = UDF_WORD(db.data + UDF_PVD_VOLUME_SET_SIZE);

			//
			// Read time stamp and compute unique id from it
			//

			for (i=0; i<8; i++)
				uniqueKey.key[i] = UDF_BYTE(db.data + UDF_PVD_RECORDING_DATE + i);
			}

		cdvdVolume->UnlockBlocks(primaryVolumeDescriptor, 1, &db, DST_DVD_ROM | DAT_UNLOCK_CLEAN, &rh);
		}

	//
	//  Read partition descriptor
	//  and initialize base for logical access
	//

	if (!IS_ERROR(err))
		{
		err = cdvdVolume->LockBlocks(primaryVolumeDescriptor + 2, 1, &db, DST_DVD_ROM | DAT_LOCK_AND_READ, &rh);

		if (!IS_ERROR(err) && UDF_BYTE(db.data))
			logicalBaseBlock = UDF_DWORD(db.data + 188);

		cdvdVolume->UnlockBlocks(primaryVolumeDescriptor + 2, 1, &db, DST_DVD_ROM | DAT_UNLOCK_CLEAN, &rh);
		}

	//
	//  Get root ICB
	//

	if (!IS_ERROR(err))
		{
		err = cdvdVolume->LockBlocks(logicalBaseBlock, 1, &db, DST_DVD_ROM | DAT_LOCK_AND_READ, &rh);

		if (!IS_ERROR(err))
			rootICB = UDF_DWORD(db.data + 404);

		cdvdVolume->UnlockBlocks(logicalBaseBlock, 1, &db, DST_DVD_ROM | DAT_UNLOCK_CLEAN, &rh);
		}

	//
	//  Cleanup
	//

	if (IS_ERROR(err))
		this->cdvdVolume = NULL;

	GNRAISE(err);
	}

//
//  Create iterator
//

Error UDFFileSystem::CreateIterator(UDFIterator * & udfi, DWORD dirICB)
	{
	DWORD extAttrLen;
	Error err = GNR_OK;

	udfi = new UDFIterator(this);

	if (!udfi)
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);

	udfi->dirICB = dirICB;
	GNREASSERT(ReadDWord(dirICB, UDF_ICB_INFO_LEN, udfi->dirSize));
	GNREASSERT(ReadDWord(dirICB, UDF_ICB_EXT_ATTR_LEN, extAttrLen));

	GNREASSERT(ReadDWord(dirICB, UDF_ICB_EXT_ATTR + extAttrLen + 4, udfi->dirStart));
	udfi->dirStart &= 0x3fffffff;	// Bits 30 and 31 characterize extent type (ignored)

	udfi->entryOffset = 0;

	if (IS_ERROR(err = GoToFirstItem(udfi)))
		{
		delete udfi;
		udfi = NULL;
		}

	GNRAISE(err);
	}

//
//  Create iterator
//

Error UDFFileSystem::CreateIterator(UDFIterator * & udfi)
	{
	return CreateIterator(udfi, rootICB);
	}

//
//  Create iterator
//

Error UDFFileSystem::CreateIterator(GenericFileSystemIterator * & gfsi, DWORD dirICB)
	{
	UDFIterator * udfi;		// Because of stupid type cast problems
	Error err;

	err = CreateIterator(udfi, dirICB);
	gfsi = udfi;
	GNRAISE(err);
	}

//
//  Create iterator
//

Error UDFFileSystem::CreateIterator(GenericFileSystemIterator * & gfsi)
	{
	UDFIterator * udfi;		// Because of stupid type cast problems
	Error err;

	err = CreateIterator(udfi, rootICB);
	gfsi = udfi;
	GNRAISE(err);
	}

//
//  Read BYTE
//

Error UDFFileSystem::ReadByte(DWORD block, DWORD offset, BYTE & b)
	{
	Error err = GNR_OK;
	block += offset / blockSize;
	offset %= blockSize;

	if (!IS_ERROR(err = LockBlocks(block, 1, &driveBlock, DST_DVD_ROM | DAT_LOCK_AND_READ | DAF_CACHED, &rh)))
		b = UDF_BYTE(driveBlock.data + offset);
	UnlockBlocks(block, 1, &driveBlock, DST_DVD_ROM | DAT_UNLOCK_CLEAN | DAF_CACHED, &rh);
	GNRAISE(err);
	}

//
//  Read WORD
//

Error UDFFileSystem::ReadWord(DWORD block, DWORD offset, WORD & w)
	{
	Error err = GNR_OK;
	block += offset / blockSize;
	offset %= blockSize;

	if (offset + 2 < blockSize)
		{
		if (!IS_ERROR(err = LockBlocks(block, 1, &driveBlock, DST_DVD_ROM | DAT_LOCK_AND_READ | DAF_CACHED, &rh)))
			w = UDF_WORD(driveBlock.data + offset);
		UnlockBlocks(block, 1, &driveBlock, DST_DVD_ROM | DAT_UNLOCK_CLEAN | DAF_CACHED, &rh);
		GNRAISE(err);
		}
	else
		{
		GNREASSERT(ReadByte(block, offset, ((BYTE*)&w)[0]));
		return ReadByte(block, offset + 1, ((BYTE*)&w)[1]);
		}
	}

//
//  Read DWORD
//

Error UDFFileSystem::ReadDWord(DWORD block, DWORD offset, DWORD & d)
	{
	Error err = GNR_OK;
	block += offset / blockSize;
	offset %= blockSize;

	if (offset + 4 < blockSize)
		{
		if (!IS_ERROR(err = LockBlocks(block, 1, &driveBlock, DST_DVD_ROM | DAT_LOCK_AND_READ | DAF_CACHED, &rh)))
			d = UDF_DWORD(driveBlock.data + offset);
		UnlockBlocks(block, 1, &driveBlock, DST_DVD_ROM | DAT_UNLOCK_CLEAN | DAF_CACHED, &rh);
		GNRAISE(err);
		}
	else
		{
		GNREASSERT(ReadByte(block, offset, ((BYTE*)&d)[0]));
		GNREASSERT(ReadByte(block, offset + 1, ((BYTE*)&d)[1]));
		GNREASSERT(ReadByte(block, offset + 2, ((BYTE*)&d)[2]));
		return ReadByte(block, offset + 3, ((BYTE*)&d)[3]);
		}
	}

//
//  Read QWORD
//

Error UDFFileSystem::ReadQWord(DWORD block, DWORD offset, KernelInt64 & q)
	{
	Error err = GNR_OK;
	block += offset / blockSize;
	offset %= blockSize;

	if (offset + 8 < blockSize)
		{
		if (!IS_ERROR(err = LockBlocks(block, 1, &driveBlock, DST_DVD_ROM | DAT_LOCK_AND_READ | DAF_CACHED, &rh)))
			q = UDF_QWORD(driveBlock.data + offset);
		UnlockBlocks(block, 1, &driveBlock, DST_DVD_ROM | DAT_UNLOCK_CLEAN | DAF_CACHED, &rh);
		GNRAISE(err);
		}
	else
		{
		GNREASSERT(ReadByte(block, offset, ((BYTE*)&q)[0]));
		GNREASSERT(ReadByte(block, offset + 1, ((BYTE*)&q)[1]));
		GNREASSERT(ReadByte(block, offset + 2, ((BYTE*)&q)[2]));
		GNREASSERT(ReadByte(block, offset + 3, ((BYTE*)&q)[3]));
		GNREASSERT(ReadByte(block, offset + 4, ((BYTE*)&q)[4]));
		GNREASSERT(ReadByte(block, offset + 5, ((BYTE*)&q)[5]));
		GNREASSERT(ReadByte(block, offset + 6, ((BYTE*)&q)[6]));
		return ReadByte(block, offset + 7, ((BYTE*)&q)[7]);
		}
	}

//
//	 Create file
//

Error UDFFileSystem::CreateFile(DWORD flags, GenericFile * & gf)
	{
	gf = new UDFFile(this);
	if (gf)
		GNRAISE_OK;
	else
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
	}

//
//  Create directory
//

Error UDFFileSystem::CreateDirectory(DWORD flags, GenericDirectory * & gd)
	{
#if GFS_ENABLE_DIRECTORIES
	gd = new UDFDirectory(this);
	if (gd)
		GNRAISE_OK;
	else
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
#else
	GNRAISE(GNR_UNIMPLEMENTED);
#endif
	}

//
//  Go to first item
//

Error UDFFileSystem::GoToFirstItem(class UDFIterator * udfi)
	{
	VDAutoMutex mutex(&lock);
	BYTE fileChar;

	udfi->entryOffset = 0;
	if (udfi->entryOffset < udfi->dirSize)
		{
		//
		//  Skip parent dir entry
		//

		GNREASSERT(ReadByte(udfi->dirStart, UDF_FID_FILE_CHAR, fileChar));
		if (fileChar & UDF_FILECHAR_PARENT)
			return GoToNextItem(udfi);
		else
			GNRAISE_OK;
		}
	else
		GNRAISE(GNR_ITEM_NOT_FOUND);
	}

//
//  Go to next item
//

Error UDFFileSystem::GoToNextItem(class UDFIterator * udfi)
	{
	VDAutoMutex mutex(&lock);
	BYTE identLen;
	WORD impUseLen;
	BYTE fileChar;
	WORD tag;

	GNREASSERT(ReadByte(udfi->dirStart, udfi->entryOffset + UDF_FID_IDENT_LEN, identLen));
	GNREASSERT(ReadWord(udfi->dirStart, udfi->entryOffset + UDF_FID_IMP_USE_LEN, impUseLen));

	udfi->entryOffset += 38 + identLen + impUseLen;
	udfi->entryOffset = (udfi->entryOffset + 3) & 0xfffffffc;		// Aligned on 4 bytes

	if (udfi->entryOffset + 1 < udfi->dirSize)
		{
		GNREASSERT(ReadWord(udfi->dirStart, udfi->entryOffset, tag));
		while (tag != UDF_TAG_FILE_IDENT && udfi->entryOffset + 2 < udfi->dirSize)
			{
			udfi->entryOffset++;
			GNREASSERT(ReadWord(udfi->dirStart, udfi->entryOffset, tag));
			}
		if (tag == UDF_TAG_FILE_IDENT)
			{
			//
			//  Skip parent dir entry
			//

			GNREASSERT(ReadByte(udfi->dirStart, udfi->entryOffset + UDF_FID_FILE_CHAR, fileChar));
			if (fileChar & UDF_FILECHAR_PARENT)
				return GoToNextItem(udfi);
			else
				GNRAISE_OK;
			}
		else
			GNRAISE(GNR_ITEM_NOT_FOUND);
		}
	else
		GNRAISE(GNR_ITEM_NOT_FOUND);
	}

//
//  Go to sub dir
//

Error UDFFileSystem::GoToSubDir(class UDFIterator * udfi, class GenericFileSystemIterator * & gfsi)
	{
	VDAutoMutex mutex(&lock);
	DWORD subICB;
	BYTE fileChar;

	GNREASSERT(ReadByte(udfi->dirStart, udfi->entryOffset + UDF_FID_FILE_CHAR, fileChar));
	if (!(fileChar & UDF_FILECHAR_DIR))
		GNRAISE(GNR_NOT_A_DIRECTORY);

	GNREASSERT(ReadDWord(udfi->dirStart, udfi->entryOffset + UDF_FID_ICB + 4, subICB));
	return CreateIterator(gfsi, subICB);
	}

//
//  Go to parent dir
//

Error UDFFileSystem::GoToParentDir(class UDFIterator * udfi, class GenericFileSystemIterator * & gfsi)
	{
	VDAutoMutex mutex(&lock);
	BYTE identLen;
	WORD impUseLen;
	BYTE fileChar;
	DWORD offset = 0;
	DWORD subICB;

	if (udfi->dirICB == rootICB)
		return mountPoint->Clone(gfsi);
	else
		{
		//
		//  Search for parent entry in dir
		//

		GNREASSERT(ReadByte(udfi->dirStart, UDF_FID_FILE_CHAR, fileChar));
		while (!(fileChar & UDF_FILECHAR_PARENT))
			{
			GNREASSERT(ReadByte(udfi->dirStart, offset + UDF_FID_IDENT_LEN, identLen));
			GNREASSERT(ReadWord(udfi->dirStart, offset + UDF_FID_IMP_USE_LEN, impUseLen));
			offset += 38 + identLen + impUseLen;
			offset = (offset + 3) & 4;		// Aligned on 4 bytes
			if (offset >= udfi->dirSize)
				break;
			GNREASSERT(ReadByte(udfi->dirStart, offset + UDF_FID_FILE_CHAR, fileChar));
			}

		//
		//  Make sure we actually found the parent entry
		//  Missing it should never happen since parent entry is mandatory, but you never know
		//

		if (offset > udfi->dirSize)
			return GNR_ITEM_NOT_FOUND;

		GNREASSERT(ReadDWord(udfi->dirStart, offset + UDF_FID_ICB + 4, subICB));
		return CreateIterator(gfsi, subICB);
		}
	}

//
//  Get path name
//

Error UDFFileSystem::GetPathName(UDFIterator * udfi, DiskItemName & name)
	{
	VDAutoMutex mutex(&lock);
	Error err = GNR_OK;
	DiskItemName pname;	// used to take a look into the cache...
	name = DiskItemName("");
	UDFIterator * imudfi;
	UDFIterator * parenti = NULL;
	DWORD extAttrLen = 0;
	DWORD rootDirStart = 0;

	// get directory start from rootICB;
	GNREASSERT(ReadDWord(this->rootICB, UDF_ICB_EXT_ATTR_LEN, extAttrLen));

	GNREASSERT(ReadDWord(this->rootICB, UDF_ICB_EXT_ATTR + extAttrLen + 4, rootDirStart));
	rootDirStart &= 0x3fffffff;	// Bits 30 and 31 characterize extent type (ignored)

	GNREASSERT(udfi->Clone(imudfi));

	while ( (imudfi->dirStart != rootDirStart) && (IS_ERROR(cache.Get(imudfi->dirStart, pname))) )
		{
		if (IS_ERROR(err = GoToParentDir(imudfi, (GenericFileSystemIterator * &) parenti)))
			{
			delete imudfi;
			GNRAISE(err);
			}
		if (IS_ERROR(parenti->GoToFirstItem()))
			{
			delete parenti;
			delete imudfi;
			GNRAISE(err);
			}

		// search
		bool found = false;
		while (!found)
			{
			DiskItemType type;
			this->GetItemType(parenti, type);
			if (type == DIT_DIR)
				{
				UDFIterator * udfsubi = NULL;
				if (IS_ERROR(err = parenti->GoToSubDir((GenericFileSystemIterator *&) udfsubi)))
					{
					delete parenti;
					delete udfsubi;
					delete imudfi;
					GNRAISE(err);
					}
				if (udfsubi->dirStart == imudfi->dirStart)
					{

					DiskItemName rname;
					parenti->GetItemName(rname);
					name = rname + "/" + name;
					found = true;
					}
				delete udfsubi;
				}

			if (!found)
				if (IS_ERROR(GoToNextItem(parenti)))
					{
					delete parenti;
					delete imudfi;
					GNRAISE(GNR_ITEM_NOT_FOUND);
					}
			}
		delete imudfi;
		imudfi = parenti;
		}

	// found it in cache?
	if (imudfi->dirStart != rootDirStart)
		{
		name = pname + "/" + name;
		}
	// go through mount point...
	else if (this->mountPoint)
		{
		DiskItemName mpName;
		DiskItemName mpPath;
		this->mountPoint->GetPathName(mpPath);
		this->mountPoint->GetItemName(mpName);
		name = mpPath + (DiskItemName)"/" + mpName + name;
		cache.Add(name, udfi->dirStart);
		}
	// no mount point? Should not be, but do not panic. Claim to be root...
	else
		{
		name = (DiskItemName)"/" + name;
		}

	delete imudfi;
	GNRAISE_OK;
	}


//
//  Get item type
//

Error UDFFileSystem::GetItemType(UDFIterator * udfi, DiskItemType & type)
	{
	VDAutoMutex mutex(&lock);
	BYTE fileChar;

	GNREASSERT(ReadByte(udfi->dirStart, udfi->entryOffset + UDF_FID_FILE_CHAR, fileChar));

	if (fileChar & UDF_FILECHAR_DIR)
		type = DIT_DIR;
	else
		type = DIT_FILE;

	GNRAISE_OK;
	}

//
//  Get item name
//

Error UDFFileSystem::GetItemName(UDFIterator * udfi, DiskItemName & name)
	{
	VDAutoMutex mutex(&lock);
	BYTE buffer[256];
	BYTE identLen;
	WORD impUseLen;
	int i;

	GNREASSERT(ReadByte(udfi->dirStart, udfi->entryOffset + UDF_FID_IDENT_LEN, identLen));
	if (identLen < 2)
		{
		name = DiskItemName();
		GNRAISE_OK;
		}
	GNREASSERT(ReadWord(udfi->dirStart, udfi->entryOffset + UDF_FID_IMP_USE_LEN, impUseLen));

	//
	//  Now read name. Note that leading 0x08 byte is skipped
	//

	for (i=0; i<identLen; i++)
		GNREASSERT(ReadByte(udfi->dirStart, udfi->entryOffset + 38 + impUseLen + 1 + i, buffer[i]));

	name = DiskItemName((char*)buffer, identLen - 1);
	GNRAISE_OK;
	}

//
//  Get item size
//

Error UDFFileSystem::GetItemSize(UDFIterator * udfi, KernelInt64 & size)
	{
	VDAutoMutex mutex(&lock);
	BYTE fileChar;
	DWORD entryICB;

	GNREASSERT(ReadByte(udfi->dirStart, udfi->entryOffset + UDF_FID_FILE_CHAR, fileChar));

	if (fileChar & UDF_FILECHAR_DIR)
		{
		size = 0;
		GNRAISE_OK;
		}

	GNREASSERT(ReadDWord(udfi->dirStart, udfi->entryOffset + UDF_FID_ICB + 4, entryICB));
	return ReadQWord(entryICB, UDF_ICB_INFO_LEN, size);
	}

//
//  Get the directory the iterator is currently in
//

Error UDFFileSystem::GetDir(UDFIterator * udfi, GenericDirectory * & gd)
	{
	VDAutoMutex mutex(&lock);

	GNRAISE(GNR_UNIMPLEMENTED);
	}

//
//  Get the number of items in the dir the iterator is currently in
//

Error UDFFileSystem::GetNumberOfItems(UDFIterator * udfi, DWORD & num)
	{
	VDAutoMutex mutex(&lock);
	DWORD offset = 0;
	BYTE identLen;
	WORD impUseLen;
	BYTE fileChar;

	//
	//  Search for parent entry in dir
	//

	num = 0;
	while (offset < udfi->dirSize)
		{
		GNREASSERT(ReadByte(udfi->dirStart, offset + UDF_FID_FILE_CHAR, fileChar));

		//
		//  Ignore parent entry
		//

		if (!(fileChar & UDF_FILECHAR_PARENT))
			num++;

		//
		//  Go to next entry
		//

		GNREASSERT(ReadByte(udfi->dirStart, offset + UDF_FID_IDENT_LEN, identLen));
		GNREASSERT(ReadWord(udfi->dirStart, offset + UDF_FID_IMP_USE_LEN, impUseLen));

		offset += 38 + identLen + impUseLen;
		offset = (offset + 3) & 0xfffffff0;		// Aligned on 4 bytes
		}

	GNRAISE_OK;
	}

//
//  Build unique key
//

Error UDFFileSystem::BuildUniqueKey(void)
	{
	GNRAISE_OK;		// We already do this in Init()
	}

//
//  Get allocation descriptor of file (only short ones here)
//  length is given in bytes
//

Error UDFFileSystem::GetAllocDescriptor(UDFIterator * udfi, WORD index, DWORD & start, DWORD & length)
	{
	DWORD extAttrLen;
	KernelInt64 allocDesc;
	DWORD entryICB;

	//
	//  Find ICB belonging to this item
	//

	GNREASSERT(ReadDWord(udfi->dirStart, udfi->entryOffset + UDF_FID_ICB + 4, entryICB));

	//
	//  Now read the allocation descriptor
	//

	index <<= 3;	// Size of alloc descriptor is 8 for the short alloc descs used on DVD
	GNREASSERT(ReadDWord(entryICB, UDF_ICB_EXT_ATTR_LEN, extAttrLen));
	GNREASSERT(ReadQWord(entryICB, UDF_ICB_EXT_ATTR + extAttrLen, allocDesc));
	length = allocDesc.Lower() & 0x3fffffff;
	start = allocDesc.Upper();
	GNRAISE_OK;
	}

//
//  Get copy management mode of item pointed to by iterator (DVD only)
//

Error UDFFileSystem::GetCopyManagementInfo(UDFIterator * udfi, GenericCopyManagementInfo & gcmi)
	{
	DWORD extAttrLen;
	DWORD help1, help2;
	DWORD impUseOffset;
	DWORD impUseSize;
	char cgmsStr[] = "*UDF DVD CGMS Info";
	DWORD cgmsStrLen = strlen(cgmsStr);
	BYTE cgms;
	WORD tag;
	DWORD i;
	BYTE b;
	BOOL found;
	DWORD entryICB;

	//
	//  Get item's ICB
	//

	gcmi = GCMI_COPY_FORBIDDEN;
	GNREASSERT(ReadDWord(udfi->dirStart, udfi->entryOffset + UDF_FID_ICB + 4, entryICB));

	//
	//  Get copyright generation management system (CGMS) information
	//  from extended attributes
	//

	GNREASSERT(ReadDWord(entryICB, UDF_ICB_EXT_ATTR_LEN, extAttrLen));
	if (!extAttrLen)
		GNRAISE_OK;

	GNREASSERT(ReadWord(entryICB, UDF_ICB_EXT_ATTR, tag));
	if (tag != UDF_TAG_EXT_ATTR_HEADER)
		GNRAISE_OK;

	GNREASSERT(ReadDWord(entryICB, UDF_ICB_EXT_ATTR + 16, impUseOffset));
	GNREASSERT(ReadDWord(entryICB, UDF_ICB_EXT_ATTR + 20, impUseSize));
	impUseSize -= impUseOffset;
	impUseOffset += UDF_ICB_EXT_ATTR;
	found = FALSE;

	while (impUseSize && !found)
		{
		//
		//  Check implementation use attribute type and subtype
		//

		GNREASSERT(ReadDWord(entryICB, impUseOffset, help1));
		GNREASSERT(ReadDWord(entryICB, impUseOffset + 4, help2));
		if (help1 == 2048 && help2 == 1)	// Tag for CGMS
			{
			//
			//  Now compare id string
			//

			for (i=0; i<cgmsStrLen; i++)
				{
				GNREASSERT(ReadByte(entryICB, impUseOffset + 17 + i, b));
				if (b != cgmsStr[i])
					break;
				}

			if (i == cgmsStrLen)
				found = TRUE;
			}

		//
		//  If found extract CGMS information, else advance to next attribute
		//

		if (found)
			{
			//
			//  Read copyright info
			//

			GNREASSERT(ReadByte(entryICB, impUseOffset + 48 + 2, cgms));
			switch (cgms & 0x30)
				{
				case 0x00:
				case 0x10:
					gcmi = GCMI_NO_RESTRICTION;
					break;
				case 0x20:
					gcmi = GCMI_ONE_GENERATION;
					break;
				case 0x30:
					gcmi = GCMI_COPY_FORBIDDEN;
					break;
				}

			GNRAISE_OK;
			}
		else
			{
			GNREASSERT(ReadDWord(entryICB, impUseOffset + 8, help1));
			impUseOffset += help1;
			impUseSize -= help1;
			}
		}

	GNRAISE_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\files\VolumeCache.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  Volume Cache Classes
//
////////////////////////////////////////////////////////////////////

#include "VolumeCache.h"


////////////////////////////////////////////////////////////////////
//
//  Volume Cache Block Class
//
////////////////////////////////////////////////////////////////////

//
//  Constructor
//

VolumeCacheBlock::VolumeCacheBlock(DWORD blockSize)
	{
	driveBlock.data = (BYTE *) ::VirtualAlloc(NULL, blockSize, MEM_COMMIT|MEM_RESERVE, PAGE_READWRITE);

	if (driveBlock.data == NULL)
		BREAKPOINT;

	driveBlock.block = 0xffffffff;
	lockCnt = 0;
	}

//
//  Destructor
//

VolumeCacheBlock::~VolumeCacheBlock(void)
	{
	::VirtualFree (driveBlock.data, 0, MEM_RELEASE);
	}

////////////////////////////////////////////////////////////////////
//
//  Volume Cache Class
//
////////////////////////////////////////////////////////////////////

//
//  Constructor
//

VolumeCache::VolumeCache(void)
	{
	first = NULL;
	}

//
//  Destructor
//

VolumeCache::~VolumeCache(void)
	{
	Cleanup();
	}

//
//  Initialize
//

Error VolumeCache::Init(GenericDrive * drive, DWORD blockNum, DWORD blockSize)
	{
	VDAutoMutex mutex(&lock);
	VolumeCacheBlock * block;
	DWORD i;

	//
	//  Make sure it is not initialized twice
	//

	if (first)
		GNRAISE(GNR_OBJECT_IN_USE);

	//
	//  Instantiate all the buffers
	//

	this->drive = drive;
	this->blockSize = blockSize;

	for (i=0; i<blockNum; i++)
		{
		block = new VolumeCacheBlock(blockSize);
		if (block)
			{
			block->next = first;
			first = block;
			}
		else
			{
			Cleanup();
			GNRAISE(GNR_NOT_ENOUGH_MEMORY);
			}
		}

	GNRAISE_OK;
	}

//
//  Cleanup
//

Error VolumeCache::Cleanup(void)
	{
	VDAutoMutex mutex(&lock);
	VolumeCacheBlock * block;

	while (first)
		{
		block = first;
		first = first->next;
		delete block;
		}

	first = NULL;
	GNRAISE_OK;
	}

//
//  Lock blocks
//

Error VolumeCache::LockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh)
	{
	VDAutoMutex mutex(&lock);
	VolumeCacheBlock * search, * searchPred, * lastFree, * lastFreePred;
	DriveBlock db;
	Error err = GNR_OK, helpErr;
	DWORD i;

	flags &= ~GD_COMMAND_MASK;
//	DP("LockBlocks %d %d", block, num);
	for (i=0; i<num; i++)
		{
		//
		//  Initialize search pointers
		//

		search = first;			// Search pointer
		searchPred = NULL;		// Predecessor of search pointer
		lastFree = NULL;			// Last free block in buffer (lock count == 0)
		lastFreePred = NULL;		// Predecessor of last free block

		//
		//  Find block in cache
		//

		while (search && (search->driveBlock.block != block + i))
			{
			if (search->lockCnt == 0)
				{
				lastFreePred = searchPred;
				lastFree =  search;
				}

			searchPred = search;
			search = search->next;
			}

		//
		//  If we found the block, then make it first one in order (LRU)
		//  else take least recently used and not locked block
		//

		if (search)
			{
			//
			//  Make if first if it is not already the first one
			//

			if (searchPred)
				{
				searchPred->next = search->next;
				search->next = first;
				first = search;
				}
			}
		else
			{
			//
			//  Make sure that we found a free block at all
			//

			if (!lastFree)
				GNRAISE(GNR_NOT_ENOUGH_MEMORY);

			//
			//  Make it first if it is not already the first one
			//

			if (lastFreePred)
				{
				lastFreePred->next = lastFree->next;
				lastFree->next = first;
				first = lastFree;
				}

			//
			//  Read data
			//

			search = lastFree;
			helpErr = drive->LockBlocks(block + i, 1, &db, flags | DAT_LOCK_AND_READ, rh);
			db.Copy(&(search->driveBlock));
			if (!IS_ERROR(helpErr))
				{
				memcpy(search->driveBlock.data, db.data, blockSize);
				}
			else
				{
				DP("Lock error occurred");
				if ((IS_WARNING(err) && IS_ERROR(helpErr)) || !IS_ERROR(err))
					err = helpErr;
				}
			drive->UnlockBlocks(block + i, 1, &db, flags | DAT_UNLOCK_CLEAN, rh);
			}

		//
		//  Lock the block and return its address
		//

		search->driveBlock.Copy(&(blocks[i]));
		blocks[i].data = search->driveBlock.data;
		search->Obtain();
		}

	GNRAISE(err);
	}

//
//  Unlock blocks
//

Error VolumeCache::UnlockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh)
	{
	VDAutoMutex mutex(&lock);
	VolumeCacheBlock * search;
	DWORD i;

//	DP("UnlockBlocks %d %d", block, num);
	for (i=0; i<num; i++)
		{
		search = first;
		while (search)
			{
			if (search->driveBlock.block == block + i)
				{
				search->Release();
				break;
				}
			search = search->next;
			}
		if (!search)
			DP("Couldn't find block %d", block + i);
		}

	GNRAISE_OK;
	}

//
//  Flush
//

Error VolumeCache::Flush(void)
	{
	VDAutoMutex mutex(&lock);
	VolumeCacheBlock * block;

	block = first;
	while (block)
		{
		block->driveBlock.block = 0xffffffff;
		block = block->next;
		}

	GNRAISE_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\hardware\audio\generic\ac3setup.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// FILE:			library\hardware\audio\generic\ac3setup.h
// AUTHOR:		U. Sigmund
// COPYRIGHT:	(c) 1996 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		20.11.1996
//
// PURPOSE:		Definitions for AC3 decoder setups
//
// HISTORY:

#ifndef AC3SETUP_H
#define AC3SETUP_H

enum AC3BassConfig
	{
	AC3BC_NO_REDIRECTION,
	AC3BC_REDIRECT_CENTER_BASS_TO_LEFT_AND_RIGHT,
	AC3BC_REDIRECT_LEFT_RIGHT_CENTER_BASS_TO_SUBWOOFER,
	AC3BC_REDIRECT_CENTER_BASS_TO_SUBWOOFER
	};

enum AC3SpeakerConfig
	{
	AC3SC_20_SURROUND_COMPATIBLE,
	AC3SC_10,
	AC3SC_20_NORMAL,
	AC3SC_30,
	AC3SC_21,
	AC3SC_31,
	AC3SC_22,
	AC3SC_32,
	AC3SC_KARAOKE		// This may only be available for MPEG-2 audio, but it is
							// added to the AC3 settings to avoid introducing new tags
	};

enum AC3DualModeConfig
	{
	AC3DMDM_DEFAULT,	// default is stereo
	AC3DMDM_STEREO = AC3DMDM_DEFAULT,
	AC3DMDM_CHANNEL1,	// channel 1 on both L/R
	AC3DMDM_CHANNEL2, // channel 2 on both L/R
	AC3DMDM_MIX			// mix channel 1 and 2 to mono, output on both L/R
	};

enum AC3KaraokeConfig
	{
	AC3KARA_AWARE,
	AC3KARA_DEFAULT,
	AC3KARA_OFF = AC3KARA_DEFAULT,
	AC3KARA_MULTICHANNEL	= 3,
	AC3KARA_CAPABLE_NO_VOCAL,
	AC3KARA_CAPABLE_V1,
	AC3KARA_CAPABLE_V2,
	AC3KARA_CAPABLE_BOTH_VOCAL
	};

enum DolbyProLogicConfig
	{
	DPLCFG_OFF,
	DPLCFG_DEFAULT = DPLCFG_OFF,
	DPLCFG_3_0 = 3,	// LCR three stereo
	DPLCFG_2_1,			// LRS phantom (= center not used)
	DPLCFG_3_1,			// LCRS
	DPLCFG_2_2,			// LRSS phantom
	DPLCFG_3_2			// LCRSS
	};

enum DolbyProLogicMode
	{
	DPLMODE_AUTOMATIC,	// Decoding depends on input fed into the PL decoder
	DPLMODE_DEFAULT = DPLMODE_AUTOMATIC,
	DPLMODE_ON,				// force it always on
	DPLMODE_OFF				// always off
	};

enum AC3DynamicRange
	{
	AC3DYNRG_DEFAULT,
	AC3DYNRG_COMPRESSED = AC3DYNRG_DEFAULT,	// Dynamic range sclae factor taken from MPEG-2 AC3 stream
	AC3DYNRG_MAXIMUM,									// Always use full dynamic range
	AC3DYNRG_MINIMUM,
	AC3DYNRG_TV
	};

// AC3 "acmod" property
enum AC3AudioCodingMode
	{
	AC3ACMOD_DUALMONO,
	AC3ACMOD_1_0,
	AC3ACMOD_2_0,
	AC3ACMOD_3_0,
	AC3ACMOD_2_1,
	AC3ACMOD_3_1,
	AC3ACMOD_2_2,
	AC3ACMOD_3_2,
	AC3ACMOD_UNKNOWN
	};

enum AC3DialogNorm
    {
	AC3DNORM_DEFAULT,
	AC3DNORM_ON = AC3DNORM_DEFAULT,
	AC3DNORM_OFF
	};

enum AC3OperationalMode
	{
	AC3OPMODE_DEFAULT,
	AC3OPMODE_LINE = AC3OPMODE_DEFAULT,
	AC3OPMODE_RF,
	AC3OPMODE_CUSTOM_0,
	AC3OPMODE_CUSTOM_1
	};





#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\hardware\audio\generic\aucodecs.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// FILE:			library\hardware\audio\generic\aucodecs.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1996 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		25.06.96
//
// PURPOSE:		Base class definition for audio codecs.
//
// HISTORY:

#ifndef AUCODECS_H
#define AUCODECS_H

#include "library/common/prelude.h"
#include "library/common/gnerrors.h"

// Error definition
#define GNR_AUD_CODEC_HALTED	MKERR(ERROR, AUDIO, GENERAL, 0x0666)

#define GNR_NO_AUDIO_HARDWARE	MKERR(ERROR, AUDIO, GENERAL, 0x0667)

class AudioCodec
	{
	protected:
		BOOL	playback;
		BOOL	capture;

		BOOL	playbackResume;
		BOOL	captureResume;

		int	haltCount;

	public:
		AudioCodec();

		virtual Error InitPlayback		(void);
		virtual Error EndPlayback		(void);

		virtual Error InitCapture		(void);
		virtual Error EndCapture		(void);

		virtual Error HaltTransfers	(void);			// Stop all transfers (capture & playback).
		virtual Error ResumeTransfers	(void);			// Resume all transfers.
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\hardware\audio\generic\audtypes.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// FILE:			library\hardware\audio\generic\audtypes.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1995 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		30.11.95
//
// PURPOSE:		Common audio data types.
//
// HISTORY:

#ifndef AUDTYPES_H
#define AUDTYPES_H


//
// Supported sample rates for codecs
//
enum AudioSampleRate		{
									RATE_11_025,				// 11.025 kHz
									RATE_22_05,					// 22.050 kHz
									RATE_44_10,					// 44.100 kHz
									RATE_8,						//  8.000 kHz
									RATE_32_0,					// 32.000 kHz
									RATE_48_0					// 48.000 kHz
								};

//
// Supported data formats for codecs
//
enum AudioDataFormat		{
									UNSIGNED_8 		= 0,		// 8 bit Unsigned
									ULAW_8,						// 8 bit u-Law encoded
									SIGNED_16_LE,				// 16 bit Signed Little Endian
									ALAW_8,						// 8 bit a-Law encoded
									ADPCM_4 			= 5,		// 4 bit ADPCM
									SIGNED_16_BE				// 16 bit Signed Big Endian
								};
//
// Distinction between stereo and mono for all audio devices
//
enum AudioMode 			{
									AUDIO_MONO,
									AUDIO_STEREO
								};

//
// Distinction between channels for all audio devices
//
enum AudioChannel 		{
									CHANNEL_LEFT,
									CHANNEL_RIGHT,
									CHANNEL_BOTH,					// Both left & right channel affected
									CHANNEL_CENTER,
									CHANNEL_SURROUND_LEFT,
									CHANNEL_SURROUND_RIGHT,
									CHANNEL_SUBWOOFER,
									CHANNEL_ALL_SURROUND			// All channels affected
								};

//
// Defines if front or rear fader
//
enum FaderType {FADER_FRONT, FADER_REAR};

//
// Possible values for Overrange Detection
//
enum AudioOverrange		{
									LESS_MINUS_1_DB,
									MINUS_1_TO_ZERO_DB,
									ZERO_TO_1_DB,
									GREATER_1_DB
								};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\hardware\audio\generic\karaokesetup.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// FILE:			library\hardware\audio\generic\karaokesetup.h
// AUTHOR:		Mark Spinnenweber
// COPYRIGHT:	(c) 1996 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		July 28, 2000
//
// PURPOSE:		Definitions for Karaoke data types (used by Karaoke tags)
//
// HISTORY:

#ifndef KARAOKESETUP_H
#define KARAOKESETUP_H

enum KaraokeVoiceEffectType
	{
	KARAOKE_VOICE_EFFECT_NONE = 0,
	KARAOKE_VOICE_EFFECT_ECHO = 1,
	KARAOKE_VOICE_EFFECT_CHORUS = 2,
	KARAOKE_VOICE_EFFECT_REVERB = 3
	};


enum KaraokeVoiceChannelSelection
	{
	KARAOKE_MUSIC_VOICE_TO_LR = 0,
	KARAOKE_VOICE_TO_CENTER   = 1
	};


enum KaraokeWordSizeType
	{
	KARAOKE_WORD_SIZE_16bit = 0,
	KARAOKE_WORD_SIZE_18bit = 1,
	KARAOKE_WORD_SIZE_20bit = 2,
	KARAOKE_WORD_SIZE_24bit = 3
	};

enum KaraokeJustificationType
	{
	KARAOKE_START_JUSTIFIED = 0,
	KARAOKE_END_JUSITIFIED  = 1
	};

enum KaraokePCMOutputModeType
	{
	KARAOKE_PCM_OUTPUT_MODE_2Channel = 0,
	KARAOKE_PCM_OUTPUT_MODE_6Channel = 1
	};

enum KaraokePCMByteOrderType
	{
	KARAOKE_PCM_BYTE_ORDER_LSB_FIRST = 0,
	KARAOKE_PCM_BYTE_ORDER_MSB_FIRST = 1
	};

enum KaraokeVoiceSamplingFrequencyType
	{
	KARAOKE_SAMPLING_FREQUENCY_12kHz = 0,
	KARAOKE_SAMPLING_FREQUENCY_11_025KHz = 1,
	KARAOKE_SAMPLING_FREQUENCY_10kHz = 2
	};

enum KaraokeMusicSamplingFrequencyType
	{
	KARAOKE_SAMPLING_FREQUENCY_48kHz = 0,
	KARAOKE_SAMPLING_FREQUENCY_44_1KHz = 1,
	KARAOKE_SAMPLING_FREQUENCY_32kHz = 2
	};

enum KaraokeSamplingFrequencyType
	{
	KARAOKE_SAMPLING_FREQUENCY_256Fs = 0,
	KARAOKE_SAMPLING_FREQUENCY_384Fs = 1
	};

enum KaraokeCanInputModeType
	{
	KARAOKE_16_SLOTS_MODE = 0,
	KARAOKE_16_SLOTS_MODE_LSB_FIRST = 1,
	KARAOKE_32_SLOTS_MODE_LEFT_ALIGNED = 2,
	KARAOKE_32_SLOTS_MODE_RIGHT_ALIGNED = 3,
	KARAOKE_32_SLOTS_MODE_I2S_MODE = 4,
	KARAOKE_32_SLOTS_MODE_SIGN_EXTENDED = 5,
	KARAOKE_32_SLOTS_MODE_8_BIT_DATA = 6,
	KARAOKE_32_SLOTS_MOD16_BIT_DATA = 7
	};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\general\Dictnary.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\general\dictnary.cpp
// AUTHOR:    U. Sigmund
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   21.03.95
//
// PURPOSE:
//
// HISTORY:
//
//

#include "Dictnary.h"
#include <string.h>

IntDictionary::IntDictionary(void)
	{
	int i;

	for (i=0; i<47; i++) hashTable[i]=NULL;
	size = 0;
	}

IntDictionary::~IntDictionary(void)
	{
	Clear ();
	}

void IntDictionary::Clear (void)
	{
	int i;
	DictNodePtr p, next;

	for (i = 0;  i < 47;  i++)
		{
		p = hashTable[i];
		while (p != NULL)
			{
			next = p->succ;
			delete p;
			p = next;
			}
		hashTable[i] = NULL;
		}
	size = 0;
	}

Error IntDictionary::Insert(DWORD key, APTR data)
	{
	int hash;
	DictNodePtr	n;

	hash = (int)(key % 47);
	n = hashTable[hash];

	while (n && (n->key!=key)) n=n->succ;

	if (n)
		GNRAISE(GNR_OBJECT_FOUND);
	else
		{
		n = new DictNode;
		n->succ = hashTable[hash];
		hashTable[hash] = n;
		n->key = key;
		n->data = data;
		size++;

		GNRAISE_OK;
		}

	}

Error IntDictionary::Change(DWORD key, APTR data)
	{
	int hash;
	DictNodePtr	n;

	hash = (int)(key % 47);
	n = hashTable[hash];

	while (n && (n->key!=key)) n=n->succ;

	if (!n)
		GNRAISE(GNR_OBJECT_NOT_FOUND);
	else
		{
		n->data = data;

		GNRAISE_OK;
		}
	}

Error IntDictionary::Lookup(DWORD key, APTR __far &data)
	{
	int hash;
	DictNodePtr	n;

	hash = (int)(key % 47);
	n = hashTable[hash];

	while (n && (n->key!=key)) n=n->succ;

	if (!n)
		GNRAISE(GNR_OBJECT_NOT_FOUND);
	else
		{
		data = n->data;

		GNRAISE_OK;
		}
	}

Error IntDictionary::Remove(DWORD key)
	{
	int hash;
	DictNodePtr	n, p;

	hash = (int)(key % 47);
	n = hashTable[hash];
	p = NULL;

	while (n && (n->key!=key)) {p=n;n=n->succ;}

	if (!n)
		GNRAISE(GNR_OBJECT_NOT_FOUND);
	else
		{
		if (p)
			p->succ = n->succ;
		else
			hashTable[hash] = n->succ;

		delete n;
		size--;

		GNRAISE_OK;
		}

	}

BOOL IntDictionary::Contains(DWORD key)
	{
	int hash;
	DictNodePtr	n;

	hash = (int)(key % 47);
	n = hashTable[hash];

	while (n && (n->key!=key)) n=n->succ;

	return n != NULL;
	}

class IntDictIterator : public Iterator {
	private:
		IntDictionary				*	dict;
		IntDictionary::DictNode *	node;
		int								num;
	public:
		IntDictIterator(IntDictionary * dict) : Iterator(dict) {this->dict = dict; node = NULL; num = 0;}
		APTR Proceed(void);
		~IntDictIterator(void) {}
	};

APTR IntDictIterator::Proceed(void)
	{
	if (node) node = node->succ;

	while (!node && (num < 47))
		{
		node = dict->hashTable[num++];
		}

	if (node) return node->data; else return NULL;
	}

Iterator * IntDictionary::CreateIterator(void)
	{
	return new IntDictIterator(this);
	}


int StringHash(const char * str)
	{
	DWORD val;

	val = 0;
	while (*str) val = val*2+*str++;

	return (int)(val % 47);
	}

StringDictionary::StringDictionary(void)
	{
	int i;

	for (i=0; i<47; i++) hashTable[i]=NULL;
	size = 0;
	}

StringDictionary::~StringDictionary(void)
	{
	Clear ();
	}


void StringDictionary::Clear (void)
	{
	int i;
	DictNodePtr p, next;

	for (i = 0;  i < 47;  i++)
		{
		p = hashTable[i];
		while (p != NULL)
			{
			next = p->succ;
			delete[] p->key;
			delete p;
			p = next;
			}
		hashTable[i] = NULL;
		}
	size = 0;
	}


Error StringDictionary::Insert(const char * key, APTR data)
	{
	int hash;
	DictNodePtr	n;

	hash = StringHash(key);
	n = hashTable[hash];

	while (n && (strcmp(n->key,key))) n=n->succ;

	if (n)
		GNRAISE(GNR_OBJECT_FOUND);
	else
		{
		n = new DictNode;
		n->succ = hashTable[hash];
		hashTable[hash] = n;
		n->key = new char[strlen(key)+1];
		strcpy(n->key,key);
		n->data = data;
		size++;

		GNRAISE_OK;
		}

	}

Error StringDictionary::Change(const char * key, APTR data)
	{
	int hash;
	DictNodePtr	n;

	hash = StringHash(key);
	n = hashTable[hash];

	while (n && (strcmp(n->key,key))) n=n->succ;

	if (!n)
		GNRAISE(GNR_OBJECT_NOT_FOUND);
	else
		{
		n->data = data;

		GNRAISE_OK;
		}
	}

Error StringDictionary::Lookup(const char * key, APTR __far &data)
	{
	int hash;
	DictNodePtr	n;

	hash = StringHash(key);
	n = hashTable[hash];

	while (n && (strcmp(n->key,key))) n=n->succ;

	if (!n)
		GNRAISE(GNR_OBJECT_NOT_FOUND);
	else
		{
		data = n->data;

		GNRAISE_OK;
		}
	}

Error StringDictionary::Remove(const char * key)
	{
	int hash;
	DictNodePtr	n, p;

	hash = StringHash(key);
	n = hashTable[hash];
	p = NULL;

	while (n && (strcmp(n->key,key))) {p=n;n=n->succ;}

	if (!n)
		GNRAISE(GNR_OBJECT_NOT_FOUND);
	else
		{
		if (p)
			p->succ = n->succ;
		else
			hashTable[hash] = n->succ;

		delete[] n->key;
		delete n;
		size--;

		GNRAISE_OK;
		}

	}

BOOL StringDictionary::Contains(const char * key)
	{
	int hash;
	DictNodePtr	n;

	hash = StringHash(key);
	n = hashTable[hash];

	while (n && (strcmp(n->key,key))) n=n->succ;

	return n != NULL;
	}

class StringDictIterator : public Iterator {
	private:
		StringDictionary				*	dict;
		StringDictionary::DictNode *	node;
		int									num;
	public:
		StringDictIterator(StringDictionary * dict) : Iterator(dict) {this->dict = dict; node = NULL; num = 0;}
		APTR Proceed(void);
		~StringDictIterator(void) {}
	};

APTR StringDictIterator::Proceed(void)
	{
	if (node) node = node->succ;

	while (!node && (num < 47))
		{
		node = dict->hashTable[num++];
		}

	if (node) return node->data; else return NULL;
	}

Iterator * StringDictionary::CreateIterator(void)
	{
	return new StringDictIterator(this);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\general\Iterator.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\general\iterator.h
// AUTHOR:    U. Sigmund
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   21.03.95
//
// PURPOSE:   Iterators for abstract data types
//
// HISTORY:
//
//

#ifndef ITERATOR_H
#define ITERATOR_H

class IteratorHost;
class IteratorHandle;

class Iterator {
	friend class IteratorHandle;
	friend class IteratorHost;
	private:
		IteratorHost	*	host;
		Iterator			*	succ;
		APTR					data;
		BOOL					skipped;

		APTR InternalProceed(void) {if (skipped) {skipped = FALSE; return data;} else return (data = Proceed());}
		void CheckRemove(APTR remove);
		virtual APTR Proceed(void) = 0;
	protected:
		inline virtual ~Iterator(void);
	public:
		Iterator(IteratorHost * host);
	};

class __far IteratorHandle {
	private:
		Iterator	*	iter;
	public:
		IteratorHandle(Iterator * iter) {this->iter = iter;}
		~IteratorHandle(void) {delete iter;}
		APTR Proceed(void) {return iter->InternalProceed();}
	};

class IteratorHost {
	friend class Iterator;
	private:
		Iterator		*	head;
	protected:
		void CheckIteratorRemove(APTR data);
	public:
		IteratorHost(void) {head = NULL;}
		virtual Iterator * CreateIterator(void) = 0;
	};

inline Iterator::Iterator(IteratorHost * host)
	{
	this->host = host;
	succ = host->head;
	host->head = this;
	skipped = FALSE;
	data = NULL;
	}

inline void Iterator::CheckRemove(APTR removed)
	{
	if (data == removed)
		{
		data = Proceed();
		skipped = TRUE;
		}
	}

inline void IteratorHost::CheckIteratorRemove(APTR data)
	{
	Iterator	*	p = head;

	while (p)
		{
		p->CheckRemove(data);
		p = p->succ;
		}
	}

inline Iterator::~Iterator(void)
	{
	host->head = succ;
	}


#define ITERATE(element, host) \
	{ IteratorHandle _xcrsr((host)->CreateIterator()); \
	while ((APTR &)element = _xcrsr.Proceed()) {

#define ITERATE_UNTIL(element, host, condition) \
	{ IteratorHandle _xcrsr((host)->CreateIterator()); \
	while (((APTR &)element = _xcrsr.Proceed()) && !(condition)) {

#define ITERATE_FIND(element, host, condition) \
	{ IteratorHandle _xcrsr((host)->CreateIterator()); \
	while (((APTR &)element = _xcrsr.Proceed()) && !(condition)) ; }

#define ITERATE_WHILE(element, host, condition) \
	{ IteratorHandle _xcrsr((host)->CreateIterator()); \
	while (((APTR &)element = _xcrsr.Proceed()) && (condition)) {

#define ITERATE_IF(element, host, condition) \
	{ IteratorHandle _xcrsr((host)->CreateIterator()); \
	while ((APTR &)element = _xcrsr.Proceed()) if (condition) {

#define ITERATE_END } }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\general\Dictnary.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\general\dictnary.h
// AUTHOR:    U. Sigmund
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   21.03.95
//
// PURPOSE:   Dictionaries for sparse integer arrays, and string
//				  to pointer association
//
// HISTORY:
//
//


#ifndef DICTNARY_H
#define DICTNARY_H

#include "library/common/prelude.h"
#include "library/common/gnerrors.h"
#include "Iterator.h"

class IntDictIterator;

class IntDictionary : public IteratorHost {
	friend class IntDictIterator;
	private:
		typedef struct DictNode {
			struct DictNode * succ;
			DWORD 				key;
			APTR					data;
		} * DictNodePtr;
		DictNodePtr	hashTable[47];
		int size;
	public:
		IntDictionary(void);
		~IntDictionary(void);

		// Clear the dictionary from all contents.
		void Clear (void);

		//
		// Insert an element into a dictionary, fails with GNR_OBJECT_FOUND, when the
		// given key does already exist.
		//
		Error Insert(DWORD key, APTR data);

		//
		// Change an element in a dictionary, fails with GNR_OBJECT_NOT_FOUND, when the
		// given key does not exist.
		//
		Error Change(DWORD key, APTR data);

		//
		// Remove an element from a dictionary, fails with GNR_OBJECT_NOT_FOUND, when the
		// given key does not exist.
		//
		Error Remove(DWORD key);

		//
		// Remove an element from a dictionary, fails with GNR_OBJECT_NOT_FOUND, when the
		// given key does not exist.
		//
		Error Lookup(DWORD key, APTR __far &data);

		//
		// Checks whether an key is included in a dictionary
		//
		BOOL Contains(DWORD key);
		int Size(void) {return size;}

		Iterator * CreateIterator(void);
	};

class StringDictIterator;

class StringDictionary : public IteratorHost {
friend class StringDictIterator;
	private:
		typedef struct DictNode {
			struct DictNode * succ;
			char 				 *	key;
			APTR					data;
		} * DictNodePtr;
		DictNodePtr	hashTable[47];
		int size;
	public:
		StringDictionary(void);
		~StringDictionary(void);

		// Clear the dictionary from all contents.
		void Clear (void);

		//
		// Insert an element into a dictionary, fails with GNR_OBJECT_FOUND, when the
		// given key does already exist.
		//
		Error Insert(const char * key, APTR data);

		//
		// Change an element in a dictionary, fails with GNR_OBJECT_NOT_FOUND, when the
		// given key does not exist.
		//
		Error Change(const char * key, APTR data);

		//
		// Remove an element from a dictionary, fails with GNR_OBJECT_NOT_FOUND, when the
		// given key does not exist.
		//
		Error Remove(const char * key);

		//
		// Remove an element from a dictionary, fails with GNR_OBJECT_NOT_FOUND, when the
		// given key does not exist.
		//
		Error Lookup(const char * key, APTR __far &data);

		//
		// Checks whether an key is included in a dictionary
		//
		BOOL Contains(const char * key);
		int Size(void) {return size;}

		Iterator * CreateIterator(void);
	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\general\Lists.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\general\lists.cpp
// AUTHOR:    U. Sigmund
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   21.03.95
//
// PURPOSE:
//
// HISTORY:
//
//

#include "Lists.h"

BOOL List::Contains(Node * n)
	{
	Node * p = first;

	while (p && (p!=n)) p=p->succ;

	return (p == n);
	}

void List::InsertFirst(Node * n)
	{
	n->succ = first;
	n->pred = NULL;
	if (first)
		first->pred = n;
	else
		last = n;
	first = n;
	num++;
	}

void List::InsertLast(Node * n)
	{
	n->succ = NULL;
	n->pred = last;
	if (last)
		last->succ = n;
	else
		first = n;
	last = n;
	num++;
	}

void List::InsertBefore(Node * n, Node * before)
	{
	if (before)
		{
		n->succ = before;
		n->pred = before->pred;
		if (before->pred)
			before->pred->succ = n;
		else
			first = n;
		before->pred = n;
		num++;
		}
	else
		InsertLast(n);
	}

void List::InsertAfter(Node * n, Node * after)
	{
	if (after)
		{
		n->succ = after->succ;
		n->pred = after;
		if (after->succ)
			after->succ->pred = n;
		else
			last = n;

      after->succ = n;
		num++;
		}
	else
		InsertFirst(n);
	}

void List::InsertByPriority(Node * n)
	{
	Node * p = first;

	while (p && p->HigherPriorityThan(n)) p = p->succ;

	InsertBefore(n, p);
	}

void List::SortByPriority(Node * n)
	{
	}

void List::RemoveFirst(void)
	{
	CheckIteratorRemove(first);

	first = first->succ;
	if (first)
		first->pred = NULL;
	else
		last = NULL;
	num--;
	}

void List::RemoveLast(void)
	{
	CheckIteratorRemove(last);

	last = last->pred;
	if (last)
		last->succ = NULL;
	else
		first = NULL;
	num--;
	}

void List::Remove(Node * n)
	{
	CheckIteratorRemove(n);

	if (n->pred)
		n->pred->succ = n->succ;
	else
		first = n->succ;
	if (n->succ)
		n->succ->pred = n->pred;
	else
		last = n->pred;
	num--;
	}

class ListIterator : public Iterator
	{
	private:
		List	*	list;
		Node	*	node;
	public:
		ListIterator(List * list) : Iterator(list) {this->list = list; node = NULL;}
		APTR Proceed(void);
		~ListIterator(void) {}
	};

APTR ListIterator::Proceed(void)
	{
	if (node)
		return (node = node->Succ());
	else
		return (node = list->First());
	}

Iterator * List::CreateIterator(void)
	{
	return new ListIterator(this);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\hardware\audio\generic\audmix.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// FILE:			library\hardware\audio\generic\audmix.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1995 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		30.11.95
//
// PURPOSE:		Base class for audio mixers.
//
// HISTORY:

#ifndef AUDMIX_H
#define AUDMIX_H

#include "library/common/gnerrors.h"
#include "library/common/tags.h"
#include "library/common/tagunits.h"
#include "library/common/virtunit.h"
#include "library/common/hooks.h"
#include "audtypes.h"

/////////////////////////////////////////////////////////////////////////////////////////////
// Input capabilities
/////////////////////////////////////////////////////////////////////////////////////////////

#define INPUT_NO_CAPTURE			0x00000001		// This input cannot be captured (digitized).
#define INPUT_STEREO					0x00000002		// This is a stereo input.
#define INPUT_CAPTURE_LOOPBACK	0x00000004		// Capture is only possible via loopback mode.
#define INPUT_MIXABLE				0x00000008		// Input may be mixed to output (i.e. gain/att. may be set).
#define INPUT_MUTABLE				0x00000010		// Input may be muted (concerns mix with output).

/////////////////////////////////////////////////////////////////////////////////////////////
// Definition of input types.
/////////////////////////////////////////////////////////////////////////////////////////////

enum MixerInputType {IN_MIC, IN_LINE, IN_AUX, IN_MONO, IN_OTHER, IN_NOT_CONNECTED};

/////////////////////////////////////////////////////////////////////////////////////////////
// Description structure for each input.
/////////////////////////////////////////////////////////////////////////////////////////////

struct MixerInput {
	MixerInputType	type;			// Type of mixer input.
	DWORD				caps;			// Capabilities (see above).
	char				name[50];	// Name for this input.
	};


typedef MixerInput __far * MixerInputArrayPtr;

/////////////////////////////////////////////////////////////////////////////////////////////
// Definition of callback hook for Direct Tag changes
/////////////////////////////////////////////////////////////////////////////////////////////


struct DirectTagChangeMsg
	{
	DWORD		flags;		// See definitions above
	DWORD		inputs;		// If DTCM_AFFECTS_INPUT is contained in flags, this tells which
								// inputs have been affected (see specific mixer implementations).
	};

// Flag definitions for Direct Tag Change Message "flags" field
#define DTCM_CHANGED_GENERAL			0x00000001		// The general Direct Tags have been changed
																// General means: Not specifically for a certain
																// input.
#define DTCM_CHANGED_INPUTS			0x00000002		// The Direct Tag values were changed for
																// specific inputs.
// Flags specific for inputs
#define DTCM_CHANGED_INPUTS_GENERAL	0x00001000	// Changed general settings for an input


MKHOOK(DirectTagChange, DirectTagChangeMsg)

typedef DirectTagChangeHook __far * DirectTagChangeHookPtr;



struct NotificationMsg
	{
	DWORD	senderID;
	DWORD	id;
	DWORD	type;
	DWORD	msg;
	DWORD	data;
	};

MKHOOK(Notification, NotificationMsg)

typedef NotificationHook * NotificationHookPtr;

// Use this for notifications that have to be transferred to different process instances
// through the kernel mode driver. As it may happen that there is only one virtual unit
// for all process instances (like for a High Level Windows Mixer), we need to identify
// the hook, which we do by using "id".
// To remove the hook, set "hook" to NULL, but keep "id" valid.
struct IdentifiedNotification
	{
	NotificationHookPtr	hook;
	DWORD						id;
	};

typedef IdentifiedNotification __far * IdentifiedNotificationPtr;

#define NOTIFY_MIXER	MKFLAG(0)



/////////////////////////////////////////////////////////////////////////////////////////////
// Tag Definitions
/////////////////////////////////////////////////////////////////////////////////////////////

// General tags for Audio Mixer
//
MKTAG (AUDMIX_CAPTURE_SELECT,					AUDIO_MIXER_UNIT, 0x0001, WORD)	// Selects input to capture.
MKTAG (AUDMIX_CAPTURE_SELECT_LEFT,			AUDIO_MIXER_UNIT, 0x0002, WORD)	//   dto. for left channel only.
MKTAG (AUDMIX_CAPTURE_SELECT_RIGHT,			AUDIO_MIXER_UNIT, 0x0003, WORD)	//   dto. for right channel only.
MKTAG (AUDMIX_GAIN,								AUDIO_MIXER_UNIT, 0x0004, WORD)	// Sets ADC gain.
MKTAG (AUDMIX_GAIN_LEFT,						AUDIO_MIXER_UNIT, 0x0005, WORD)
MKTAG (AUDMIX_GAIN_RIGHT,						AUDIO_MIXER_UNIT, 0x0006, WORD)
MKTAG (AUDMIX_GAIN_ENABLE_LEFT,				AUDIO_MIXER_UNIT, 0x0007, BOOL)	// Enables ADC extra gain for mic.
MKTAG (AUDMIX_GAIN_ENABLE_RIGHT,				AUDIO_MIXER_UNIT, 0x0008, BOOL)
MKTAG (AUDMIX_ATTENUATE,						AUDIO_MIXER_UNIT, 0x0009, WORD)	// Sets DAC attenuation.
MKTAG (AUDMIX_ATTENUATE_LEFT,					AUDIO_MIXER_UNIT, 0x000a, WORD)
MKTAG (AUDMIX_ATTENUATE_RIGHT,				AUDIO_MIXER_UNIT, 0x000b, WORD)
MKTAG (AUDMIX_MUTE,								AUDIO_MIXER_UNIT, 0x000c, BOOL)	// Sets DAC mute.
MKTAG (AUDMIX_MUTE_LEFT,						AUDIO_MIXER_UNIT, 0x000d, BOOL)
MKTAG (AUDMIX_MUTE_RIGHT,						AUDIO_MIXER_UNIT, 0x000e, BOOL)

// Tags for input properties/selection
//
MKTAG (AUDMIX_INPUT_NUMBER, 					AUDIO_MIXER_UNIT, 0x000f, WORD)	// Delivers total number of inputs.
MKTAG (AUDMIX_MIXER_DESCRIPTION,				AUDIO_MIXER_UNIT, 0x0010, MixerInputArrayPtr)
// The next tag selects one of the inputs, for which the following tags can then be applied.
MKTAG (AUDMIX_INPUT_SELECT,					AUDIO_MIXER_UNIT, 0x0000011, WORD)
//
// The following tags are used to set the properties of an input.
// Use QUERY_... to find out the capabilities for a certain input. If tags like AUDMIX_INPUT_GAIN
// deliver FALSE (i.e. input is stereo), then you MUST check AUDMIX_INPUT_GAIN_LEFT/_RIGHT.
// If it is TRUE, then this is not necessary.
//
MKTAG (AUDMIX_INPUT_GAIN,						AUDIO_MIXER_UNIT, 0x0012, WORD)	// Gain (to the ADC) is changeable (mono).
MKTAG (AUDMIX_INPUT_GAIN_LEFT,				AUDIO_MIXER_UNIT, 0x0013, WORD)	// Gain is independently changeable for
MKTAG (AUDMIX_INPUT_GAIN_RIGHT,				AUDIO_MIXER_UNIT, 0x0014, WORD)	// left/right channels.
MKTAG (AUDMIX_INPUT_MIX_GAIN,					AUDIO_MIXER_UNIT, 0x0015, WORD)	// Analog output mix gain for the input.
MKTAG (AUDMIX_INPUT_MIX_GAIN_LEFT,			AUDIO_MIXER_UNIT, 0x0016, WORD)
MKTAG (AUDMIX_INPUT_MIX_GAIN_RIGHT,			AUDIO_MIXER_UNIT, 0x0017, WORD)
MKTAG (AUDMIX_INPUT_MIX_ATTENUATE,			AUDIO_MIXER_UNIT, 0x0018, WORD)	// Analog output mix attenuation.
MKTAG (AUDMIX_INPUT_MIX_ATTENUATE_LEFT,	AUDIO_MIXER_UNIT, 0x0019, WORD)
MKTAG (AUDMIX_INPUT_MIX_ATTENUATE_RIGHT,	AUDIO_MIXER_UNIT, 0x001a, WORD)
MKTAG (AUDMIX_INPUT_GAIN_ENABLE,				AUDIO_MIXER_UNIT, 0x001b, BOOL)	// Enables extra gain for input.
MKTAG (AUDMIX_INPUT_GAIN_ENABLE_LEFT,		AUDIO_MIXER_UNIT, 0x0001c, BOOL)
MKTAG (AUDMIX_INPUT_GAIN_ENABLE_RIGHT,		AUDIO_MIXER_UNIT, 0x001d, BOOL)
MKTAG (AUDMIX_INPUT_MUTE,						AUDIO_MIXER_UNIT, 0x001e, BOOL)	// Mutes input for the analog output mix.
MKTAG (AUDMIX_INPUT_MUTE_LEFT,				AUDIO_MIXER_UNIT, 0x001f, BOOL)
MKTAG (AUDMIX_INPUT_MUTE_RIGHT,				AUDIO_MIXER_UNIT, 0x0020, BOOL)

// Special tags for more advanced mixers.
//
MKTAG (AUDMIX_LOOPBACK,							AUDIO_MIXER_UNIT, 0x0021, BOOL)	// Enables digital loopback (ADC->DAC)
MKTAG (AUDMIX_LOOPBACK_ATTENUATION, 		AUDIO_MIXER_UNIT, 0x0022, WORD)	// Sets digital attenuation.

MKTAG (AUDMIX_MONOOUT_MUTE, 					AUDIO_MIXER_UNIT, 0x0023, BOOL)	// Mutes mono output.
MKTAG (AUDMIX_MONOIN_MUTE, 					AUDIO_MIXER_UNIT, 0x0024, BOOL)	// Mutes mono input.
MKTAG (AUDMIX_MONO_ATTENUATION, 				AUDIO_MIXER_UNIT, 0x0025, BOOL)	// Mono output attenuation.

// General tags for Audio Fader
//
MKTAG (AUDMIX_LOUDNESS,							AUDIO_MIXER_UNIT, 0x2001, BOOL)
MKTAG (AUDMIX_ZERO_CROSSING,					AUDIO_MIXER_UNIT, 0x2002, BOOL)

// Affect both front and rear fader in the right proportion as necessary for Buster
MKTAG (AUDMIX_FADER_LEFT,						AUDIO_MIXER_UNIT, 0x2003, WORD)
MKTAG (AUDMIX_FADER_RIGHT,						AUDIO_MIXER_UNIT, 0x2004, WORD)

MKTAG (AUDMIX_BASS,								AUDIO_MIXER_UNIT, 0x2007, int)
MKTAG (AUDMIX_TREBLE,							AUDIO_MIXER_UNIT, 0x2008, int)

//
// Special tags for Microsoft Sound System Audio Mixer Device
// Their execution will directly affect the physical unit.
//
//          -- DO NOT USE EXCEPT FOR THIS PURPOSE!! --
//
MKTAG (AUDMIX_D_GAIN,								AUDIO_MIXER_UNIT, 0x0026, WORD)
MKTAG (AUDMIX_D_GAIN_LEFT,							AUDIO_MIXER_UNIT, 0x0027, WORD)
MKTAG (AUDMIX_D_GAIN_RIGHT,						AUDIO_MIXER_UNIT, 0x0028, WORD)
MKTAG (AUDMIX_D_ATTENUATE,							AUDIO_MIXER_UNIT, 0x0029, WORD)
MKTAG (AUDMIX_D_ATTENUATE_LEFT,					AUDIO_MIXER_UNIT, 0x002a, WORD)
MKTAG (AUDMIX_D_ATTENUATE_RIGHT,					AUDIO_MIXER_UNIT, 0x002b, WORD)
MKTAG (AUDMIX_D_MUTE,								AUDIO_MIXER_UNIT, 0x002c, BOOL)
MKTAG (AUDMIX_D_MUTE_LEFT,							AUDIO_MIXER_UNIT, 0x002d, BOOL)
MKTAG (AUDMIX_D_MUTE_RIGHT,						AUDIO_MIXER_UNIT, 0x002e, BOOL)
MKTAG	(AUDMIX_D_INPUT_SELECT,						AUDIO_MIXER_UNIT, 0x002f, int)	// Selects the affected input (see above)
MKTAG (AUDMIX_D_INPUT_MUTE,						AUDIO_MIXER_UNIT, 0x0030, BOOL)
MKTAG (AUDMIX_D_INPUT_MUTE_LEFT,					AUDIO_MIXER_UNIT, 0x0031, BOOL)
MKTAG (AUDMIX_D_INPUT_MUTE_RIGHT,				AUDIO_MIXER_UNIT, 0x0032, BOOL)
MKTAG (AUDMIX_D_LOUDNESS,							AUDIO_MIXER_UNIT, 0x200b, BOOL)
MKTAG (AUDMIX_D_FADER_LEFT,						AUDIO_MIXER_UNIT, 0x200c, WORD)
MKTAG (AUDMIX_D_FADER_RIGHT,						AUDIO_MIXER_UNIT, 0x200d, WORD)
MKTAG (AUDMIX_D_BASS,								AUDIO_MIXER_UNIT, 0x200e, WORD)
MKTAG (AUDMIX_D_TREBLE,								AUDIO_MIXER_UNIT, 0x200f, WORD)
MKTAG (AUDMIX_D_INPUT,								AUDIO_MIXER_UNIT, 0x2010, WORD)
MKTAG (AUDMIX_D_INPUT_FADER_LEFT,				AUDIO_MIXER_UNIT, 0x2011, WORD)
MKTAG (AUDMIX_D_INPUT_FADER_RIGHT,				AUDIO_MIXER_UNIT, 0x2012, WORD)
MKTAG (AUDMIX_D_INPUT_FADER_FRONT_LEFT,		AUDIO_MIXER_UNIT, 0x2013, WORD)
MKTAG (AUDMIX_D_INPUT_FADER_FRONT_RIGHT,		AUDIO_MIXER_UNIT, 0x2014, WORD)
MKTAG (AUDMIX_D_INPUT_FADER_REAR_LEFT,			AUDIO_MIXER_UNIT, 0x2015, WORD)
MKTAG (AUDMIX_D_INPUT_FADER_REAR_RIGHT,		AUDIO_MIXER_UNIT, 0x2016, WORD)

// Additional tags for faders and/or mixers.
//

// New additional fader properties
MKTAG (AUDMIX_FADER_FRONT_LEFT,					AUDIO_MIXER_UNIT, 0x2030, WORD)
MKTAG (AUDMIX_FADER_FRONT_RIGHT,					AUDIO_MIXER_UNIT, 0x2031, WORD)
MKTAG (AUDMIX_FADER_REAR_LEFT,					AUDIO_MIXER_UNIT, 0x2032, WORD)
MKTAG (AUDMIX_FADER_REAR_RIGHT,					AUDIO_MIXER_UNIT, 0x2033, WORD)

MKTAG (AUDMIX_VOLUME,								AUDIO_MIXER_UNIT, 0x2050, WORD)
MKTAG (AUDMIX_VOLUME_LEFT,							AUDIO_MIXER_UNIT, 0x2003, WORD)	// Note: same as FADER_LEFT
MKTAG (AUDMIX_VOLUME_RIGHT,						AUDIO_MIXER_UNIT, 0x2004, WORD)

MKTAG (AUDMIX_FADER_FRONT,							AUDIO_MIXER_UNIT, 0x2053, WORD)
MKTAG (AUDMIX_FADER_REAR,							AUDIO_MIXER_UNIT, 0x2054, WORD)
MKTAG (AUDMIX_FADER_FRONT_MUTE,					AUDIO_MIXER_UNIT, 0x2055, WORD)
MKTAG (AUDMIX_FADER_REAR_MUTE,					AUDIO_MIXER_UNIT, 0x2056, WORD)

// Additional Direct Tags for faders and/or mixers
MKTAG (AUDMIX_D_INPUT_VOLUME,						AUDIO_MIXER_UNIT, 0x2057, WORD)
MKTAG (AUDMIX_D_INPUT_VOLUME_LEFT,				AUDIO_MIXER_UNIT, 0x2058, WORD)
MKTAG (AUDMIX_D_INPUT_VOLUME_RIGHT,				AUDIO_MIXER_UNIT, 0x2059, WORD)
MKTAG (AUDMIX_D_VOLUME,								AUDIO_MIXER_UNIT, 0x205a, WORD)
MKTAG (AUDMIX_D_VOLUME_LEFT,						AUDIO_MIXER_UNIT, 0x205b, WORD)
MKTAG (AUDMIX_D_VOLUME_RIGHT,						AUDIO_MIXER_UNIT, 0x205c, WORD)

// Tag for Installation of a Direct-Tag-Change-Hook
// Set to NULL to remove the hook.
MKTAG (AUDMIX_D_DTAG_CHANGE_HOOK,				AUDIO_MIXER_UNIT, 0x205d, DirectTagChangeHookPtr)

// Identified change hook
MKTAG (AUDMIX_D_ID_NOTIFICATION,					AUDIO_MIXER_UNIT, 0x205d, IdentifiedNotificationPtr)


#ifndef ONLY_EXTERNAL_VISIBLE

#if NT_KERNEL

class IDNotification : public Node
	{
	public:
		DWORD							id;
		NotificationHookHandle	hookHandle;

		IDNotification(DWORD id, NotificationHookHandle hookHandle) {this->id = id; this->hookHandle = hookHandle;}
	};

typedef IDNotification * IDNotificationPtr;

class IDNotificationList : public List
	{
	public:
		~IDNotificationList();
		IDNotificationPtr FindByID(DWORD id);
	};

#endif

class AudioMixer : public PhysicalUnit {
	friend class VirtualAudioMixer;
	protected:
		WORD							numInputs;
		MixerInputArrayPtr		inputs;
		int							currentInput;

		virtual Error SetCurrentInput(int currentInput);
		virtual Error ProcessChanges() = 0;

#if NT_KERNEL
		IDNotificationList	*notificationList;

		virtual Error SetIdentifiedNotification(IdentifiedNotificationPtr notification);
		virtual Error SendNotifications(DWORD senderID, DWORD type, DWORD msg, DWORD data);
#endif
	public:
		AudioMixer();
		~AudioMixer();

		virtual Error RetrieveINIValues(void) {GNRAISE_OK;}

		virtual VirtualAudioMixer * CreateVirtualAudioMixer(void) {return NULL;}
		VirtualUnit * CreateVirtual(void);
	};

class VirtualAudioMixer : public VirtualUnit {
	private:
		AudioMixer			*	mixer;
	protected:
		WORD	curInput;

		Error Preempt(VirtualUnit *previous);
	public:
		VirtualAudioMixer(AudioMixer *physical) : VirtualUnit(physical) {this->mixer = physical;}
		Error Configure(TAG __far * tags);

#if NT_KERNEL
		virtual Error SendNotifications(DWORD senderID, DWORD type, DWORD msg, DWORD data);
#endif
	};

inline VirtualUnit * AudioMixer::CreateVirtual(void) {return CreateVirtualAudioMixer();}

#endif // ONLY_EXTERNAL_VISIBLE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\general\Lists.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\general\lists.h
// AUTHOR:    U. Sigmund
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   21.03.95
//
// PURPOSE:   Generic linear list classes
//
// HISTORY:
//
//


#ifndef LISTS_H
#define LISTS_H

#include "library/common/prelude.h"
#include "Iterator.h"

class List;

class Node
	{
	friend class List;
	friend class ListIterator;

	private:
		Node	*	succ;
		Node	*	pred;
	protected:
		virtual BOOL HigherPriorityThan(Node * n) {return FALSE;}
	public:
		Node(void) {succ = NULL;pred = NULL;};
		virtual ~Node(void) {;};

		Node * Succ(void) {return succ;};
		Node * Pred(void) {return pred;};

		BOOL IsFirst(void) {return pred == NULL;};
		BOOL IsLast(void) {return succ == NULL;};
	};

class List : public IteratorHost
	{
	private:
		Node				*	first;
		Node				*	last;
		int					num;
	public:
		List(void) {first = NULL; last = NULL; num = 0;};
		virtual ~List(void) {;};

		Node * First(void) {return first;};
		Node * Last(void) {return last;};

		BOOL IsEmpty(void) {return first == NULL;};
		BOOL Contains(Node * n);
		int Num(void) {return num;};

		void InsertFirst(Node * n);
		void InsertLast(Node * n);
		void InsertBefore(Node * n, Node * before);
		void InsertAfter(Node * n, Node * after);

		void InsertByPriority(Node * n);
		void SortByPriority(Node * n);

		void RemoveFirst(void);
		void RemoveLast(void);
		void Remove(Node * n);

		void Enqueue(Node * n) {InsertLast(n);}
		Node * Dequeue(void) {Node * n = first; if (n) RemoveFirst(); return n;}

		void Push(Node * n) {InsertFirst(n);}
		Node * Pop(void) {return Dequeue();}

		Iterator * CreateIterator(void);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\hardware\audio\generic\stereodc.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// FILE:			library\hardware\audio\generic\stereodc.h
// AUTHOR:		Stefan Herr
// COPYRIGHT:	(c) 1996 Viona Development.  All Rights Reserved.
// CREATED:		22.08.95
//
// PURPOSE:		Base class for stereo decoders (FM/TV stereo decoders)
//
// HISTORY:

#ifndef STEREODC_H
#define STEREODC_H

enum SignalMode	{ST_MONO,					// Either TV or FM is received mono only
						 ST_STEREO,					//    "    "  "  "  "     "    stereo
						 ST_SAP,						// Second audio program (SAP) received for TV
						 ST_UNDEFINED,				// Mode could not be determined (i.e. no signal)
						 ST_AUTOMATIC,				// Only used when setting the mode.
						 ST_STEREO_SAP				// For NTSC TV: Stereo and SAP at the same time.
						 };


#ifndef ONLY_EXTERNAL_VISIBLE

#include "library/common/prelude.h"
#include "library/common/gnerrors.h"
#include "library/common/virtunit.h"
#include "library/common/tagunits.h"
//
// Stereo Decoder tags
//
MKTAG(STEREODEC_MODESELECT,	STEREO_DECODER_UNIT,	0x0001, SignalMode)
MKTAG(STEREODEC_MODEDETECT,	STEREO_DECODER_UNIT,	0x0002, SignalMode)

class StereoDecoder : public PhysicalUnit	{
	friend class VirtualStereoDecoder;
	protected:
		virtual Error GetSignalMode(SignalMode __far & mode) = 0;
		virtual Error SetSignalMode(SignalMode mode) = 0;

		virtual Error ProcessChanges() = 0;
	public:
	};

class VirtualStereoDecoder : public VirtualUnit {
	private:
		StereoDecoder	*	decoder;
	protected:
		SignalMode		mode;
	public:
		VirtualStereoDecoder(StereoDecoder * decoder);
		Error Configure(TAG __far * tags);
		Error Preempt(VirtualUnit * previous);
	};

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\hardware\drives\generic\DriveErrors.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  Error Declaration for Drive Classes
//
////////////////////////////////////////////////////////////////////


#ifndef DRIVEERRORS_H
#define DRIVEERRORS_H

#include "library\common\gnerrors.h"

#define GNR_DRIVE_FAILURE							MKERR(ERROR,	DISK,			HARDWARE,			0x00)
// General drive failure

#define GNR_DRIVE_FATAL_ERROR						MKERR(ERROR,	DISK,			HARDWARE,			0x01)
// Drive firmware is not responding any more

#define GNR_NO_VALID_DISK							MKERR(ERROR,	DISK,			OBJECT,				0x00)
// No valid/known disk was found

#define GNR_NO_DRIVE									MKERR(ERROR,	DISK,			OBJECT,				0x02)
// Drive does not exist/could not be found

#define GNR_DRIVE_DETACHED							MKERR(ERROR,	DISK,			OBJECT,				0x03)
// The drive has been detached -> is not available for playback

#define GNR_NO_DVD_DRIVE							MKERR(ERROR,	DISK,			OBJECT,				0x04)
// The drive is not a DVD drive (used on PCs)

#define GNR_BLOCK_ALREADY_LOCKED					MKERR(ERROR,	DISK,			OBJECT,				0x05)
// A block was already locked in a different mode (read/write)

#define GNR_BLOCK_NOT_LOCKED						MKERR(ERROR,	DISK,			OBJECT,				0x06)
// The block not be unlocked is not locked

#define GNR_DISK_IS_NOT_PRESENT					MKERR(ERROR,	DISK,			OBJECT,				0x07)
// The disk is not present in the drive

#define GNR_INVALID_DRIVE_LETTER					MKERR(ERROR,	DISK,			BOUNDS,				0x01)
// The drive letter specified was not correct/out of range

#define GNR_DISK_READ_ONLY							MKERR(ERROR,	DISK,			FILEIO,				0x00)
// The disk is read-only

#define GNR_DRIVE_LOCK_FAILED						MKERR(ERROR,	DISK,			OPERATION,			0x00)
// Unable to lock/unlock the drive

#define GNR_DRIVE_ALREADY_LOCKED					MKERR(WARNING,	DISK,			OPERATION,			0x01)
// The drive was already locked

#define GNR_DRIVE_LOAD_FAILED						MKERR(ERROR,	DISK,			OPERATION,			0x02)
// Could not load/unload the drive

#define GNR_DRIVE_NOT_LOADABLE					MKERR(ERROR,	DISK,			OPERATION,			0x03)
// Drive does not support loading/unloading the disk

#define GNR_READ_ERROR								MKERR(ERROR,	DISK,			OPERATION,			0x04)
// Some read error occurred

#define GNR_WRITE_ERROR								MKERR(ERROR,	DISK,			OPERATION,			0x05)
// Some write error occurred

#define GNR_HIGH_TEMPERATURE						MKERR(ERROR,	DISK,			OPERATION,			0x06)
// Drive reported that is is unable to work properly due to high temperature

#define GNR_COPY_PROTECTION_VIOLATION			MKERR(ERROR,	DISK,			COPYPROTECTION,	0x00)

#define GNR_COPY_PROTECTION_FAILED				MKERR(ERROR,	DISK,			COPYPROTECTION,	0x01)

#define GNR_READ_ERROR_SECTOR_ENCRYPTED		MKERR(ERROR,	DISK,			COPYPROTECTION,	0x02)
// A sector was requested which happened to be encrypted, but the authentication process was not completed

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\hardware\drives\generic\BlockBufferCDVDDrive.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  Block Buffer CDVD Drive
//
////////////////////////////////////////////////////////////////////

#ifndef BLOCKBUFFERCDVDDRIVE_H
#define BLOCKBUFFERCDVDDRIVE_H

#include "library/hardware/drives/generic/GenericDrive.h"
#include "library/hardware/drives/generic/DriveBlockBuffer.h"

////////////////////////////////////////////////////////////////////
//
//  Block Buffer CDVD Drive Class
//
////////////////////////////////////////////////////////////////////

class BlockBufferCDVDDrive : public CDVDDrive
	{
	protected:
		DriveBlockBuffer	*	blockBuffer;	// Data storage
		PhysicalDiskType		lastDiskType;	// The type of the last GetDiskType inquiry. Used to adjust DriveBlockSize

		virtual DriveBlockBuffer * CreateDriveBlockBuffer(void) = 0;

		//
		//  Data Access
		//

		virtual Error ReadDVDBlocks(DWORD block, DWORD num, BYTE * buffer, DWORD flags) = 0;
		virtual Error ReadCDBlocks(DWORD block, DWORD num, BYTE * buffer, DWORD flags) = 0;

	public:
		BlockBufferCDVDDrive(void);
		virtual ~BlockBufferCDVDDrive(void);

		virtual Error Init(DriveControlInfo * info, GenericProfile * profile);
		virtual Error Cleanup(void);

		//
		//  Inquiry & config functions
		//

		virtual Error GetDriveBlockSize(DWORD sectorType, DWORD & size, DWORD & minSize, DWORD & maxSize, DWORD & step);
		virtual Error SetDriveBlockSize(DWORD size);

		virtual Error GetNumberOfDriveBlocks(DWORD & num);
		virtual Error SetNumberOfDriveBlocks(DWORD num);

		//
		//  Basic Drive Functions
		//

		virtual Error TerminateRequest(RequestHandle * rh);				// Terminate the current request (read/write)
		virtual Error Flush(void);													// Make sure all commands are executed

		//
		//  Data Access Functions
		//

		virtual Error LockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh);
		virtual Error UnlockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\hardware\drives\generic\CDVDDefs.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
//
//  General definitions for CD and DVD
//
//////////////////////////////////////////////////////////////////////

#ifndef CDVDDEFS_H
#define CDVDDEFS_H

#include "Library/Common/Prelude.h"
#include "Library/Common/vddebug.h"

////////////////////////////////////////////////////////////////////
//
//  Definitions for DVD
//
////////////////////////////////////////////////////////////////////

#define DVD_BLOCK_SIZE	2048
#define CD_BLOCK_SIZE	2352

enum DVDAuthenticationCommand
	{
	DAC_START_AUTHENTICATION,
	DAC_READ_CHALLENGE_KEY,
	DAC_WRITE_BUS_KEY,
	DAC_WRITE_CHALLENGE_KEY,
	DAC_READ_BUS_KEY,
	DAC_READ_DISK_KEY,
	DAC_READ_TITLE_KEY,
	DAC_COMPLETE_AUTHENTICATION,
	DAC_CANCEL_AUTHENTICATION
	};

//////////////////////////////////////////////////////////////////////
//
//  CD Definitions
//
//////////////////////////////////////////////////////////////////////

//
//  CD in general
//

#define CD_FRAME_RATE				75
#define CD_FRAME_SIZE				2352
#define CD_MAX_TOC_ENTRY_NUM		100

//
//  Audio CD

#define CDDA_SUBCHANNEL_SIZE		98
#define CDDA_FRAME_SIZE				(CD_FRAME_SIZE + CDDA_SUBCHANNEL_SIZE)

//
//  CD ROM
//

#define CDROM_FORM1_HEADER			16
#define CDROM_FORM2_HEADER			16
#define CDROM_FORM1_DATA			2048
#define CDROM_FORM2_DATA			2336

//
//  CD ROM XA (also CDI)
//

#define CDROM_XAFORM1_HEADER		24
#define CDROM_XAFORM2_HEADER		24
#define CDROM_XAFORM1_DATA			2048
#define CDROM_XAFORM2_DATA			2324

//
//  Subchannel names
//

enum CDSubChannel
	{
	CSC_CHANNEL_P,
	CSC_CHANNEL_Q,
	CSC_CHANNEL_R,
	CSC_CHANNEL_S,
	CSC_CHANNEL_T,
	CSC_CHANNEL_U,
	CSC_CHANNEL_V,
	CSC_CHANNEL_W
	};

//
//  Q Subchannel information
//

enum CDSubChannelQ
	{
	CSQ_CONTROL	= 0,				// including ADR in LSN
	CSQ_ADR		= CSQ_CONTROL,	// including CONTROL in MSN
	CSQ_TNO		= 1,
	CSQ_X			= 2,				// Equivalent to POINT
	CSQ_POINT	= CSQ_X,			// Equivalent to X
	CSQ_MIN		= 3,
	CSQ_SEC		= 4,
	CSQ_FRAME	= 5,
	CSQ_ZERO		= 6,
	CSQ_AMIN		= 7,
	CSQ_ASEC		= 8,
	CSQ_AFRAME	= 9,
	CSQ_CRC1		= 10,
	CSQ_CRC2		= 11
	};

//
//  Type of the track
//

enum CDTrackType
	{
	CTT_NONE,
	CTT_AUDIO,
	CTT_DATA
	};

//
//  Multisession CD
//

enum CDSessionType
	{
	CST_NONE,
	CST_CDDA,		// Might also be CD ROM
	CST_CDI,
	CST_CDROM_XA
	};

//////////////////////////////////////////////////////////////////////
//
//  CD Directory Entry Class
//
//////////////////////////////////////////////////////////////////////

class CDTocEntry
	{
	protected:
		DWORD			startBlock;			// First block of track (absolute on disk)
		DWORD			numberOfBlocks;	// Number of blocks in the track
		CDTrackType trackType;			// Type of track (from TOC)

	public:
		CDTocEntry(void);
		CDTocEntry(DWORD startBlock, DWORD numberOfBlocks, CDTrackType type);
		CDTocEntry(BYTE startMin, BYTE startSec, BYTE startFrame,
					  BYTE playMin,  BYTE playSec,  BYTE playFrame,
					  CDTrackType type);
		CDTocEntry(const CDTocEntry & cdte);
		~CDTocEntry(void) {}

		CDTocEntry & operator=(const CDTocEntry & arg);

		void			SetStartBlock(DWORD startBlock)							{ this->startBlock = startBlock; }
		void			SetStartBlock(BYTE min, BYTE sec, BYTE frame)		{ startBlock = ((min * 60) + sec) * CD_FRAME_RATE + frame; }
		void			SetNumberOfBlocks(DWORD num)								{ this->numberOfBlocks = num; }
		void			SetNumberOfBlocks(BYTE min, BYTE sec, BYTE frame)	{ numberOfBlocks = ((min * 60) + sec) * CD_FRAME_RATE + frame; }
		void			SetTrackType(CDTrackType type)							{ this->trackType = type; }
		DWORD			GetStartBlock(void)											{ return startBlock; }
		DWORD			GetNumberOfBlocks(void)										{ return numberOfBlocks; }
		CDTrackType	GetTrackType(void)											{ return trackType; }
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\hardware\drives\generic\BlockBufferCDVDDrive.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  Block Buffer CDVD Drive Class
//
////////////////////////////////////////////////////////////////////

#include "library/hardware/drives/generic/BlockBufferCDVDDrive.h"

//
//  Constructor
//

BlockBufferCDVDDrive::BlockBufferCDVDDrive(void) : CDVDDrive()
	{
	lastDiskType = PHDT_NONE;
	}

//
//  Destructor
//

BlockBufferCDVDDrive::~BlockBufferCDVDDrive(void)
	{
	delete blockBuffer;
	}

//
//  Init
//

Error BlockBufferCDVDDrive::Init(DriveControlInfo * info, GenericProfile * profile)
	{
	GNREASSERT(CDVDDrive::Init(info, profile));
	blockBuffer = CreateDriveBlockBuffer();
	if (!blockBuffer)
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);

	GNRAISE_OK;
	}

//
//  Cleanup
//

Error BlockBufferCDVDDrive::Cleanup(void)
	{
	delete blockBuffer;
	return CDVDDrive::Cleanup();
	}

//
//  Get drive block size
//
//  Output:
//
//  size - current size of the block for sectore type passed in sectorType
//  minSize, maxSize - minimum and maximum size of block that can be found on currently loaded disk type
//  step - 0 (no meaning in CD/DVD case)
//

Error BlockBufferCDVDDrive::GetDriveBlockSize(DWORD sectorType, DWORD & size, DWORD & minSize, DWORD & maxSize, DWORD & step)
	{
	VDAutoMutex mutex(&monitorMutex);
	PhysicalDiskType type;

	GNREASSERT(GetDiskType(type));

	switch (type)
		{
		case PHDT_CDDA:
			maxSize = minSize = CD_FRAME_SIZE + CDDA_SUBCHANNEL_SIZE;
			break;
		case PHDT_CDROM:
		case PHDT_CDI:
		case PHDT_CDROM_XA:
			minSize = CD_FRAME_SIZE;
			maxSize = CD_FRAME_SIZE + CDDA_SUBCHANNEL_SIZE;
			break;
		case PHDT_DVD_ROM:
			maxSize = minSize = DVD_BLOCK_SIZE;
			break;
		case PHDT_NONE:
			GNREASSERT(blockBuffer->GetBlockSize(size));		// No disk, so return whatever we have now
			maxSize = minSize = size;
			break;
		default:
			BREAKPOINT;
		}

	switch (sectorType)
		{
		case DST_NONE:
			size = minSize; //If we don't know sector type, return minimum block size as current size
			break;
		case DST_DVD_ROM:
			size = DVD_BLOCK_SIZE;
			break;
		case DST_CDDA:
			size = CD_FRAME_SIZE + CDDA_SUBCHANNEL_SIZE;
			break;
		case DST_CDROM_MODE1:
		case DST_CDROM_MODE2:
		case DST_CDROM_MODE2_XA_FORM1:
		case DST_CDROM_MODE2_XA_FORM2:
			size = CD_FRAME_SIZE;
			break;
		case DST_HD:
		default:
			BREAKPOINT;
		}

	//
	//  Make sure the drive block size fits the media type
	//

	if (type != lastDiskType)
		GNREASSERT(blockBuffer->SetBlockSize(maxSize));
	lastDiskType = type;

	step = 0;
	GNRAISE_OK;
	}

//
//  Set drive block size
//

Error BlockBufferCDVDDrive::SetDriveBlockSize(DWORD size)
	{
	VDAutoMutex mutex(&monitorMutex);

	GNRAISE(GNR_UNIMPLEMENTED);
	}

//
//  Get number of drive blocks
//

Error BlockBufferCDVDDrive::GetNumberOfDriveBlocks(DWORD & num)
	{
	VDAutoMutex mutex(&monitorMutex);

	if (blockBuffer)
		return blockBuffer->GetBlockNum(num);
	else
		GNRAISE(GNR_OBJECT_NOT_ALLOCATED);
	}

//
//  Set number of drive blocks
//

Error BlockBufferCDVDDrive::SetNumberOfDriveBlocks(DWORD num)
	{
	VDAutoMutex mutex(&monitorMutex);

	if (blockBuffer)
		return blockBuffer->SetBlockNum(num);
	else
		GNRAISE(GNR_OBJECT_NOT_ALLOCATED);
	}

//
//  Terminate request
//

Error BlockBufferCDVDDrive::TerminateRequest(RequestHandle * rh)
	{
	GNRAISE_OK;
	}

//
//  Flush
//

Error BlockBufferCDVDDrive::Flush(void)
	{
	GNRAISE_OK;
	}

//
//  Lock blocks
//

Error BlockBufferCDVDDrive::LockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh)
	{
	VDAutoMutex mutex(&monitorMutex);
	Error err = GNR_UNIMPLEMENTED;
	Error helpErr;
	int i = 0;
	int j;

//	DP("Locking Block %d", block);
	rh->Activate();

	if (GD_COMMAND(flags) == DAT_LOCK_AND_READ)
		{
		if (!IS_ERROR(err = blockBuffer->LockBlocks(block, num, LM_READ, blocks)))
			{
			while (i<(int)num)
				{
				//
				//  Win32DriveBlockBuffer returns number of contiguous blocks in private0
				//

				switch (GD_SECTOR_TYPE(flags))
					{
					case DST_DVD_ROM:
						helpErr = ReadDVDBlocks(block + i, blocks[i].private0, blocks[i].data, flags);
						break;
					case DST_CDDA:
					case DST_CDROM_MODE1:
					case DST_CDROM_MODE2:
					case DST_CDROM_MODE2_XA_FORM1:
					case DST_CDROM_MODE2_XA_FORM2:
						helpErr = ReadCDBlocks(block + i, blocks[i].private0, blocks[i].data, flags);
						break;
					default:
						helpErr = GNR_OBJECT_INVALID;
						break;
					}

				//
				//  Mark invalid blocks in case of error
				//

				for (j=0; j<(int)blocks[i].private0; j++)
					{
					if (IS_ERROR(helpErr))
						blocks[i + j].data = NULL;
					blocks[i + j].err = helpErr;
					}

				if (IS_ERROR(helpErr))
					err = helpErr;

				//
				//  Continue until all blocks are read
				//

				if (blocks[i].private0)
					i += blocks[i].private0;
				else
					i++;
				}
			}
		}

	rh->Passivate();

	GNRAISE(err);
	}

//
//  Unlock blocks
//

Error BlockBufferCDVDDrive::UnlockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh)
	{
	VDAutoMutex mutex(&monitorMutex);
	Error err = GNR_UNIMPLEMENTED;

	rh->Activate();

	if (GD_COMMAND(flags) == DAT_UNLOCK_CLEAN)
		{
		err = blockBuffer->UnlockBlocks(block, num);
		}

	rh->Passivate();
//	DP("Unlock result was %lx", err);
	GNRAISE(err);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\hardware\drives\generic\CDVDDefs.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
//
//  General definitions for DVD and CD
//
//////////////////////////////////////////////////////////////////////

#include "Library/Hardware/Drives/Generic/CDVDDefs.h"

//////////////////////////////////////////////////////////////////////
//
//  CD TOC Entry Class
//
//////////////////////////////////////////////////////////////////////

//
//  Default constructor
//

CDTocEntry::CDTocEntry(void)
	{
	startBlock = 0;
	numberOfBlocks = 0;
	trackType = CTT_NONE;
	}

//
//  Constructor with block arguments
//

CDTocEntry::CDTocEntry(DWORD startBlock, DWORD numberOfBlocks, CDTrackType trackType)
	{
	this->startBlock = startBlock;
	this->numberOfBlocks = numberOfBlocks;
	this->trackType = trackType;
	}

//
//  Constructor with time arguments
//

CDTocEntry::CDTocEntry(BYTE startMin, BYTE startSec, BYTE startFrame, BYTE playMin,  BYTE playSec,  BYTE playFrame,
							  CDTrackType trackType)
	{
	SetStartBlock(startMin, startSec, startFrame);
	SetNumberOfBlocks(playMin, playSec, playFrame);
	this->trackType = trackType;
	}

//
//  Copy constructor
//

CDTocEntry::CDTocEntry(const CDTocEntry & cdte)
	{
	startBlock = cdte.startBlock;
	numberOfBlocks = cdte.numberOfBlocks;
	trackType = cdte.trackType;
	}

//
//  Assignment operator
//

CDTocEntry & CDTocEntry::operator=(const CDTocEntry & arg)
	{
	startBlock = arg.startBlock;
	numberOfBlocks = arg.numberOfBlocks;
	trackType = arg.trackType;
	return *this;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\hardware\drives\generic\Requests.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\hardware\drives\generic\DriveBlockBuffer.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  Drive Block Buffer Classes
//
////////////////////////////////////////////////////////////////////

#ifndef DRIVEBLOCKBUFFER_H
#define DRIVEBLOCKBUFFER_H

#define DBB_ENABLE_CHECK 1		// Enable consistency check

#include "library/common/prelude.h"
#include "library/common/gnerrors.h"
#include "library/hardware/drives/generic/driveerrors.h"
#include "library/hardware/drives/generic/GenericDrive.h"

////////////////////////////////////////////////////////////////////
//
//  Drive Block Buffer Class
//
////////////////////////////////////////////////////////////////////

class DriveBlockBuffer
	{
	public:
		DriveBlockBuffer(void) {};
		virtual ~DriveBlockBuffer(void) {};

		virtual Error SetBlockNum(DWORD blockNum) = 0;
		virtual Error GetBlockNum(DWORD & num) = 0;

		virtual Error SetBlockSize(DWORD blockSize) = 0;
		virtual Error GetBlockSize(DWORD & size) = 0;

		virtual Error LockBlocks(DWORD block, DWORD num, DriveBlockLockMode lockMode, DriveBlock * blocks) = 0;
		virtual Error UnlockBlocks(DWORD block, DWORD num) = 0;

		virtual Error BlocksLocked(DWORD block, DWORD num, DriveBlockLockMode lockMode, BOOL & locked) = 0;	// LM_NONE indicates "don't care"

		virtual Error GetFreeBlockNum(DWORD & num) = 0;

		virtual Error Flush(void) = 0;
	};

////////////////////////////////////////////////////////////////////
//
//  Scatter Drive Block Info Class
//
////////////////////////////////////////////////////////////////////

class ScatterDriveBlockInfo
	{
	public:
		WORD						lockCount;	// Number of times the block was locked
		DriveBlockLockMode	lockMode;	// Lock mode, read or write
		DWORD						succ;			// Number of successors with equal state (locked or free, including itself)
		DWORD						block;		// Index of the block contained in buffer
	};

////////////////////////////////////////////////////////////////////
//
//  Scatter Drive Block Buffer Class
//  NOTE: To create a working implementation of this class, the
//  following things must be implemented:
//  * Constructors which must call those of ScatterDriveBlockBuffer
//  * Destructor which must perform the same action as FreeData()
//  * AllocateData() and FreeData() methods
//
////////////////////////////////////////////////////////////////////

class ScatterDriveBlockBuffer : public DriveBlockBuffer
	{
	protected:
		BYTE * data;												// The buffer itself
		ScatterDriveBlockInfo * info;							// Management structure
		DWORD * indices;											// Indices for unlocking block

		DWORD blockNum;											// Number of blocks in buffer
		DWORD blockSize;											// Size of block in buffer
		DWORD freeBlocks;											// Number of free blocks
		DWORD nextSearchPosition;								// Search position for FindLockedBlock()

		//
		//  Internal management functions
		//

		virtual void AllocateData(DWORD size) = 0;			// This must be overloaded to create the implementation specific buffer
																			// If error occurs, data should be set to NULL
		virtual void FreeData(void) = 0;							// Delete buffer "data"
		Error Resize(DWORD blockNum, DWORD blockSize);		// Internal resize function for data buffer and control info
		void	InitInfo(void);										// Initialize control information

		DWORD FindLockedBlock(DWORD index);
		void	LockFreeBlocks(DWORD block, DWORD num, DriveBlockLockMode lockMode, DriveBlock * blocks);
		void	LockBlockSeq(DWORD start, DWORD block, DWORD num, DriveBlockLockMode lockMode, DriveBlock * blocks);
		void  RelockBlocks(DWORD start, DWORD num, DriveBlock * blocks);

#if DBB_ENABLE_CHECK
		void Check(void);
#endif

	public:
		ScatterDriveBlockBuffer(void);
		virtual ~ScatterDriveBlockBuffer(void);

		virtual Error SetBlockNum(DWORD blockNum);			// Set (minimum) track buffer size
		virtual Error GetBlockNum(DWORD & num);				// Get track buffer size (internal size can be higher)

		virtual Error SetBlockSize(DWORD blockSize);			// Set size of a drive block (in bytes)
		virtual Error GetBlockSize(DWORD & size);				// Get size of a drive block (in bytes)

		virtual Error LockBlocks(DWORD block, DWORD num,					// Lock specified amount of blocks
										 DriveBlockLockMode lockMode,				// This one returns the number of contiguously locked
										 DriveBlock * blocks);						// blocks in private0 of the first block of each segment
																							// Blocks that were already locked have private0 set to 0
		virtual Error UnlockBlocks(DWORD block, DWORD num);				// Unlock specified amount of blocks

		virtual Error BlocksLocked(DWORD block, DWORD num, DriveBlockLockMode lockMode, BOOL & locked);	// LM_NONE indicates "don't care"

		virtual Error GetFreeBlockNum(DWORD & num) { num = freeBlocks; GNRAISE_OK; }

		virtual Error Flush(void);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\hardware\drives\generic\DriveDefs.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  General Drive Definitions
//
////////////////////////////////////////////////////////////////////

#ifndef DRIVEDEFS_H
#define DRIVEDEFS_H

#include "Library/Common/Prelude.h"
#include "Library/Common/GNErrors.h"
//
//  From drvtypes.h
//

enum GenericTrayStatus
	{
	GTS_TRAY_UNKNOWN,
	GTS_TRAY_OPEN,
	GTS_TRAY_CLOSED,
	GTS_TRAY_MOVING
	};

#if BOARD_USE_NEW_NAVIGATION

enum GenericIRQTrigger
	{
	GITR_NO_TRIGGER,
	GITR_HIGH_LEVEL,
	GITR_LOW_LEVEL,
	GITR_RISING_EDGE,
	GITR_FALLING_EDGE,
	GITR_ANY_TRIGGER
	};
#endif

enum GenericCopyManagementInfo
	{
	GCMI_NO_RESTRICTION,
	GCMI_ONE_GENERATION,
	GCMI_COPY_FORBIDDEN
	};

//
//  The disk type
//

enum PhysicalDiskType
	{
	PHDT_NONE,
	PHDT_CDDA,
	PHDT_CDROM,
	PHDT_CDI,
	PHDT_CDROM_XA,
	PHDT_DVD_ROM,
	PHDT_DVD_RAM,
	PHDT_DVD_R,
	PHDT_DVD_RW,
	PHDT_HD,
	PHDT_ILLEGAL
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\hardware\drives\generic\DriveTable.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  Operating system dependent drive table classes
//
////////////////////////////////////////////////////////////////////

#include "DriveTable.h"


////////////////////////////////////////////////////////////////////
//
//  Drive table base class
//
////////////////////////////////////////////////////////////////////

//
//  Constructor
//

DriveTable::DriveTable(void)
	{
	}

//
//  Destructor
//

DriveTable::~DriveTable(void)
	{
	}

//
//  Cleanup
//

Error DriveTable::Cleanup(void)
	{
	DriveDesc * driveDesc;

	while (!drives.IsEmpty())
		{
		driveDesc = (DriveDesc*)drives.Pop();
		driveDesc->drive->Cleanup();
		delete driveDesc->drive;
		delete driveDesc;
		}

	GNRAISE_OK;
	}

//
//  Move iterator to first drive
//

Error DriveTable::GoFirstDrive(DriveIterator & it)
	{
	it.driveDesc = (DriveDesc*)(drives.First());
	if (it.driveDesc)
		GNRAISE_OK;
	else
		GNRAISE(GNR_OBJECT_NOT_FOUND);
	}

//
//  Move iterator to next drive
//

Error DriveTable::GoNextDrive(DriveIterator & it)
	{
	if (!it.driveDesc->IsLast())
		{
		it.driveDesc = (DriveDesc*)it.driveDesc->Succ();
		GNRAISE_OK;
		}
	else
		GNRAISE(GNR_OBJECT_NOT_FOUND);
	}

//
//  Test if iterator points to last drive
//

BOOL DriveTable::IsLast(const DriveIterator & it)
	{
	if (it.driveDesc)
		return it.driveDesc->IsLast();
	else
		return TRUE;
	}

//
//  Return pointer to drive
//

Error DriveTable::GetDrive(const DriveIterator & it, GenericDrive * & gd)
	{
	if (it.driveDesc)
		{
		gd = it.driveDesc->drive;
		GNRAISE_OK;
		}
	else
		GNRAISE(GNR_OBJECT_NOT_FOUND);
	}

//
//  Return drive name
//

Error DriveTable::GetDriveName(const DriveIterator & it, KernelString & driveName)
	{
	if (it.driveDesc)
		{
		driveName = it.driveDesc->driveName;
		GNRAISE_OK;
		}
	else
		GNRAISE(GNR_OBJECT_NOT_FOUND);
	}



Error WinDriveTable::CreatePotentialDrives()
	{
	DriveDesc * driveDesc;

	driveDesc = new DriveDesc(NULL, "D");
	drives.InsertLast(driveDesc);

	GNRAISE_OK;
	}


////////////////////////////////////////////////////////////////////
//
//  Win 9x Drive Table
//
////////////////////////////////////////////////////////////////////

//
//  Constructor
//


////////////////////////////////////////////////////////////////////
//
//  Win 2K Classes
//
////////////////////////////////////////////////////////////////////

//
//  Constructor
//

W2KDriveTable::W2KDriveTable(void)
	{
	}

//
//  Destructor
//

W2KDriveTable::~W2KDriveTable(void)
	{
	Cleanup();
	}

//
//  Initialize drive table
//

Error W2KDriveTable::Init(GenericProfile * profile)
	{
	DriveDesc * driveDesc, * dd;

	//
	//  Determine potential candidates
	//

	GNREASSERT(CreatePotentialDrives());
	driveDesc = (DriveDesc*)drives.First();

	//
	//  Now try all potential drives
	//

	while (driveDesc)
		{
		driveDesc->drive = new XBOXDVDDrive();
		DriveControlInfo * pControlInfo = new DriveControlInfo(driveDesc->driveName);
		driveDesc->StoreDriveControlInfo(pControlInfo);
		if (IS_ERROR(driveDesc->drive->Init(pControlInfo, profile)))
			{
			dd = (DriveDesc*) driveDesc->Succ();
			drives.Remove(driveDesc);
			delete driveDesc;
			driveDesc = dd;
			}
		else
			{
			driveDesc = (DriveDesc*) driveDesc->Succ();
			}
		}

	if (drives.Num() == 0)
		GNRAISE(GNR_READ_ERROR);

	GNRAISE_OK;
	}

//
//  Cleanup drive table
//

Error W2KDriveTable::Cleanup(void)
	{
	return DriveTable::Cleanup();
	}



////////////////////////////////////////////////////////////////////
//
//  ST20LITE Classes
//
////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\hardware\drives\generic\DriveTable.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  Operating system dependent drive table classes
//
////////////////////////////////////////////////////////////////////

#ifndef DRIVETABLE_H
#define DRIVETABLE_H

#include "Library/Common/Prelude.h"
#include "Library/Common/krnlstr.h"
#include "Library/general/lists.h"
#include "Library/hardware/drives/generic/GenericDrive.h"

#include "Library/hardware/drives/specific/XBOXDVDDrive.h"

////////////////////////////////////////////////////////////////////
//
//  Generic Drive Table
//
////////////////////////////////////////////////////////////////////

//
//  Description of a drive
//

class DriveDesc : public Node
	{
	public:
		GenericDrive	*	drive;		// The drive itself
		KernelString		driveName;
		//DriveDesc class holds pointer to the instance of DriveControlInfo-based objects.
		//DriveControlInfo-based object is created outside DriveDesc, but DriveDesc is responsible for deleting it.
		DriveControlInfo* driveControlInfo;

		//
		//  Methods
		//

		DriveDesc(GenericDrive * drive, const KernelString & driveName) : Node()
			{ this->drive = drive; this->driveName = driveName; this->driveControlInfo = NULL;}
		virtual ~DriveDesc(void) {if (driveControlInfo) delete driveControlInfo;}

		void StoreDriveControlInfo(DriveControlInfo* driveControlInfo){this->driveControlInfo = driveControlInfo;}
	};

//
//  Iterator over drive table
//

class DriveIterator
	{
	public:
		DriveDesc * driveDesc;

		DriveIterator(void) { driveDesc = NULL; }
		BOOL Valid(void) { return driveDesc != NULL; }
	};

//
//  Drive table base class
//

class DriveTable
	{
	protected:
		List drives;
		DWORD potentialDriveMask;

	public:
		DriveTable(void);
		virtual ~DriveTable(void);

		virtual Error Init(GenericProfile * profile) = 0;
		virtual Error Cleanup(void);

		virtual Error GoFirstDrive(DriveIterator & it);
		virtual Error GoNextDrive(DriveIterator & it);
		virtual BOOL  IsLast(const DriveIterator & it);
		virtual Error GetDrive(const DriveIterator & it, GenericDrive * & gd);
		virtual Error GetDriveName(const DriveIterator & it, KernelString & driveName);
	};


////////////////////////////////////////////////////////////////////
//
//  Windows drive table
//
////////////////////////////////////////////////////////////////////

class WinDriveTable : public DriveTable
	{
	protected:
		Error CreatePotentialDrives(void);
	};

////////////////////////////////////////////////////////////////////
//
//  Win 2K Drive Table
//
////////////////////////////////////////////////////////////////////

//
//  W2K drive table
//

class W2KDriveTable : public WinDriveTable
	{
	public:
		W2KDriveTable(void);
		virtual ~W2KDriveTable(void);

		virtual Error Init(GenericProfile * profile);
		virtual Error Cleanup(void);
	};


////////////////////////////////////////////////////////////////////
//
//  ST20LITE Drive Table
//
////////////////////////////////////////////////////////////////////


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\hardware\drives\generic\DriveBlockBuffer.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  Drive Block Buffer Classes
//
////////////////////////////////////////////////////////////////////

#include "DriveBlockBuffer.h"
#include "library/common/vddebug.h"

//
//  Return values for FindLockedBlock method
//

#define FB_BLOCK_NOT_FOUND					0xffffffff

////////////////////////////////////////////////////////////////////
//
//  Scatter Drive Block Buffer Class
//
////////////////////////////////////////////////////////////////////

//
//  Constructor
//

ScatterDriveBlockBuffer::ScatterDriveBlockBuffer(void)
	{
	blockNum = 64;
	blockSize = 2048;
	freeBlocks = blockNum;
	data = NULL;
	info = NULL;
	indices = NULL;
	Resize(blockNum, blockSize);
	}

//
//  Destructor
//

ScatterDriveBlockBuffer::~ScatterDriveBlockBuffer(void)
	{
	delete[] info;
	delete[] indices;
	}

//
//  Resize buffer
//  GNR_OBJECT_IN_USE: There are some locked blocks
//  GNR_NOT_ENOUGH_MEMORY: Not enough memory for so many blocks
//

Error ScatterDriveBlockBuffer::Resize(DWORD blockNum, DWORD blockSize)
	{
	if (freeBlocks != this->blockNum)
		GNRAISE(GNR_OBJECT_IN_USE);

	if (this->blockNum != blockNum || this->blockSize != blockSize)
		{
		this->blockNum = blockNum;
		this->blockSize = blockSize;
		freeBlocks = blockNum;

		//
		//  Resize data block
		//

		if (data)
			FreeData();
		AllocateData(blockNum * blockSize);
		if (data == NULL)
			{
			blockNum = blockSize = 0;
			GNRAISE(GNR_NOT_ENOUGH_MEMORY);
			}

		//
		//  Resize info block
		//

		delete[] info;
		info = new ScatterDriveBlockInfo[blockNum + 2];	// Two more for ease of programming
		if (info == NULL)
			{
			FreeData();
			data = NULL;
			blockNum = blockSize = NULL;
			GNRAISE(GNR_NOT_ENOUGH_MEMORY);
			}

		InitInfo();

		//
		//  Resize indices array
		//

		delete[] indices;
		indices = new DWORD[blockNum];
		}

	GNRAISE_OK;
	}

//
//  Initialize control data
//

void ScatterDriveBlockBuffer::InitInfo(void)
	{
	DWORD i;

	if (info != NULL)
		{
		for (i=0; i<blockNum; i++)
			{
			info[i].lockCount = 0;
			info[i].succ = blockNum - i;
			info[i].lockMode = LM_NONE;
			}

		info[blockNum].lockCount = 0;
		info[blockNum].succ = 0;
		info[blockNum].lockMode = LM_NONE;

		info[blockNum + 1].lockCount = 0;
		info[blockNum + 1].succ = 0;
		info[blockNum + 1].lockMode = LM_NONE;
		}

	freeBlocks = blockNum;

	nextSearchPosition = 0;
	}

//
//  Set number of drive blocks
//  GNR_INVALID_PARAMETERS: Illegal value specified
//

Error ScatterDriveBlockBuffer::SetBlockNum(DWORD blockNum)
	{
	if (blockNum == 0)
		GNRAISE(GNR_INVALID_PARAMETERS);

	GNRAISE(Resize(blockNum, this->blockSize));
	}

//
//  Get number of drive blocks
//

Error ScatterDriveBlockBuffer::GetBlockNum(DWORD & num)
	{
	num = blockNum;
	GNRAISE_OK;
	}

//
//  Set drive block size
//  GNR_INVALID_PARAMETERS: Illegal value specified
//

Error ScatterDriveBlockBuffer::SetBlockSize(DWORD blockSize)
	{
	if (blockSize == 0)
		GNRAISE(GNR_INVALID_PARAMETERS);

	GNRAISE(Resize(this->blockNum, blockSize));
	}

//
//  Get drive block size
//

Error ScatterDriveBlockBuffer::GetBlockSize(DWORD & size)
	{
	size = blockSize;
	GNRAISE_OK;
	}

//
//  Lock blocks
//  This one returns the number of contiguously locked
//  blocks in private0 of the first block of each segment.
//  For previously locked blocks this value is 0.
//  GNR_NOT_EOUGH_MEMORY: Not enough free blocks (only for those who need to be newly allocated)
//  GNR_BLOCK_ALREADY_LOCKED: Attempt to read-lock a write-locked block or to write lock an already locked block (read or write)
//

Error ScatterDriveBlockBuffer::LockBlocks(DWORD block, DWORD num, DriveBlockLockMode lockMode, DriveBlock * driveBlocks)
	{
	DWORD contNum;			// Number of contiguous blocks
	DWORD blocksLeft;		// Blocks left to lock
	DWORD lockedBlock;	// Index of already locked block
	DWORD i;


	//
	//  Lock blocks in maximal portions
	//

	blocksLeft = num;				// Number of blocks left to lock
	i = 0;

	while (blocksLeft)
		{
		//
		//  Find block which is already locked
		//

		contNum = 0;
		while (contNum < blocksLeft && (lockedBlock = FindLockedBlock(block + i + contNum)) == FB_BLOCK_NOT_FOUND)
			contNum++;

		//
		//  Mark blocks as lockable if there is enough free space
		//

		if (contNum > freeBlocks)
			GNRAISE(GNR_NOT_ENOUGH_MEMORY);

		if (contNum)
			{
			driveBlocks[i].lockMode = LM_NONE;
			driveBlocks[i].private0 = contNum;
			i += contNum;
			blocksLeft -= contNum;
			}

		//
		//  There may be multiple reads but only one write at a time
		//

		if (lockedBlock != FB_BLOCK_NOT_FOUND)
			{
			if (info[lockedBlock].lockMode == LM_WRITE || lockMode == LM_WRITE)
				GNRAISE(GNR_BLOCK_ALREADY_LOCKED);

			driveBlocks[i].lockMode = lockMode;
			driveBlocks[i].private0 = lockedBlock;
			i++;
			blocksLeft--;
			}
		}

	//
	//  We found space for all blocks, now let's really lock them
	//

	i = 0;
	while (i < num)
		{
		if (driveBlocks[i].lockMode == LM_NONE)
			{
			contNum = driveBlocks[i].private0;
			LockFreeBlocks(block + i, driveBlocks[i].private0, lockMode, &(driveBlocks[i]));
			i += contNum;
			}
		else
			{
			RelockBlocks(driveBlocks[i].private0, 1, &(driveBlocks[i]));
			driveBlocks[i].private0 = 1;
			i++;
			}
		}

#if DBB_ENABLE_CHECK
	Check();
#endif

	GNRAISE_OK;
	}

//
//  Lock free blocks
//  The availability of enough room must be asserted by caller.
//  This function assumes that none of the blocks (block <= b < block + num) is already locked.
//

void ScatterDriveBlockBuffer::LockFreeBlocks(DWORD block, DWORD num, DriveBlockLockMode lockMode, DriveBlock * driveBlocks)
	{
	DWORD smallestFit;	// Smallest block in which whole request fits (pointer to dummy element)
	DWORD largestSub;		// Largest subset of request (pointer to dummy element)
	DWORD searchIdx;
	DWORD succs;

	info[blockNum].succ = blockNum;		// Initialize dummy element
	info[blockNum + 1].succ = 0;			// Initialize dummy element

	//
	//  Repeat searching until all blocks are allocated
	//

	while (num)
		{
		searchIdx = 0;
		smallestFit = blockNum;
		largestSub = blockNum + 1;

		//
		//  Find either minimal contiguous set of blocks for whole request or maximal pieces
		//

		while (searchIdx < blockNum)
			{
			if (info[searchIdx].lockMode == LM_NONE)
				{
				if (info[searchIdx].succ >= num)
					{
					if (info[searchIdx].succ <= info[smallestFit].succ)	// == is important to skip dummy element
						{
						smallestFit = searchIdx;
						}
					}
				else
					{
					if (info[searchIdx].succ >= info[largestSub].succ)		// == is important to skip dummy element
						{
						largestSub = searchIdx;
						}
					}
				}

			searchIdx += info[searchIdx].succ;
			}

		//
		//  Now allocate blocks pointed to by either smallest fit or largest sub
		//

		if (smallestFit != blockNum)
			{
			LockBlockSeq(smallestFit, block, num, lockMode, driveBlocks);
			num = 0;
			}
		else	// No need to check largest sub here since existence of enough blocks is assured
			{
			succs = info[largestSub].succ;	// This really sucks. info[largestSub].succ might change inside LockBlockSeq()
			LockBlockSeq(largestSub, block, succs, lockMode, driveBlocks);
			num -= succs;
//			if (num > 0xffff)
//				BREAKPOINT;
			driveBlocks += succs;
			block += succs;
			}
		}
	}

//
//  Lock block sequence (for free blocks only)
//  start: index into info structure
//  block: index of the block on disk
//

void ScatterDriveBlockBuffer::LockBlockSeq(DWORD start, DWORD block, DWORD num, DriveBlockLockMode lockMode, DriveBlock * driveBlocks)
	{
	int i;
	DWORD numSucc;

	//
	//  Determine number of successors
	//

	numSucc = num;
	if (start + num < blockNum && info[start + num].lockMode != LM_NONE)
		numSucc += info[start + num].succ;

	//
	//  Lock the blocks
	//

	for (i=0; i<(int)num; i++)
		{
		info[start + i].lockCount = 1;
		info[start + i].succ = numSucc - i;
		info[start + i].block = block + i;
		info[start + i].lockMode = lockMode;
		driveBlocks[i].block = block + i;
		driveBlocks[i].data = data + (start + i) * blockSize;
		driveBlocks[i].lockMode = info[start + i].lockMode;
		driveBlocks[i].private0 = num - i;
		}

	//
	//  Update info of predecessor blocks
	//

	if (start > 0)
		{
		i = ((int)start) - 1;

		if (info[i].lockMode == LM_NONE)
			{
			//
			//  If blocks are free reduce successor count
			//  NOTE: This should never happen since we always allocate at the
			//  beginnig of a free block segment, but is here for completeness
			//

			while (i >= 0 && info[i].lockMode == LM_NONE)
				{
				info[i].succ -= num;
				i--;
				}
			}
		else
			{
			//
			//  If blocks were locked with same mode increase successor count
			//

			while (i >= 0 && info[i].lockMode != LM_NONE)
				{
				info[i].succ += numSucc;
				i--;
				}
			}
		}

	freeBlocks -= num;

#if DBB_ENABLE_CHECK
	Check();
#endif
	}

//
//  Relock already locked blocks
//  start: index into info structure
//

void ScatterDriveBlockBuffer::RelockBlocks(DWORD start, DWORD num, DriveBlock * driveBlocks)
	{
	DWORD i;

	//
	//  Allocate blocks
	//

	for (i=0; i<num; i++)
		{
		info[start + i].lockCount++;
		driveBlocks[i].block = info[start + i].block;
		driveBlocks[i].data = data + (start + i) * blockSize;
		driveBlocks[i].lockMode = info[start + i].lockMode;
		driveBlocks[i].private0 = info[start + i].succ;
		}
	}

//
//  Find locked block
//  Returns index in buffer or FB_BLOCK_NOT_FOUND
//

DWORD ScatterDriveBlockBuffer::FindLockedBlock(DWORD index)
	{
	DWORD i;

	for (i=0; i<blockNum; i++)
		{
		if (info[nextSearchPosition].block == index && info[nextSearchPosition].lockMode != LM_NONE)
			{
			return nextSearchPosition;
			}
//		nextSearchPosition = (nextSearchPosition + 1) % blockNum;
		nextSearchPosition++;
		if (nextSearchPosition == blockNum)
			nextSearchPosition = 0;
		}

	return FB_BLOCK_NOT_FOUND;
	}

//
//  Unlock blocks
//  GNR_NOT_ENOUGH_MEMORY: Attempt to unlock more blocks than there are
//  GNR_BLOCK_NOT_LOCKED: Attempt to unlock a block that is not locked
//

Error ScatterDriveBlockBuffer::UnlockBlocks(DWORD block, DWORD num)
	{
	int		i;
	int		j;
	DWORD		db;					// The block to unlock (index in info structure, not on drive)
	DWORD		prevSucc;			// Number of successors the block had before unlock
	BOOL		succFree;			// TRUE if successor of block was free


	//
	//  Check if there is an attempt to lock more blocks than there are
	//

	if (num > blockNum)
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);

	//
	//  Check existence of blocks to be unlocked
	//

	for (i=0; i<(int)num; i++)
		{
		if ((indices[i] = FindLockedBlock(block + i)) == FB_BLOCK_NOT_FOUND)
			GNRAISE(GNR_BLOCK_NOT_LOCKED);
		}

	//
	//  Now that we are sure that all blocks exist unlock blocks back
	//  to front to prevent iterated recomputation of succ values
	//

	for (i = ((int)num) - 1; i >= 0; i--)
		{
		//
		//  Unlock a single block
		//

		db = indices[i];
		info[db].lockCount--;
		if (!info[db].lockCount)
			{
			info[db].lockMode = LM_NONE;
			freeBlocks++;

			//
			//  Update successor info if block is free again
			//

			if (db != blockNum - 1)
				{
				if (info[db + 1].lockMode == LM_NONE)
					{
					succFree = TRUE;
					info[db].succ = info[db + 1].succ + 1;
					}
				else
					{
					prevSucc = info[db].succ;	// Save old successor number since we may have broken a sequence
					info[db].succ = 1;
					succFree = FALSE;
					}
				}
			else
				{
				succFree = FALSE;		// chain ends here
				prevSucc = 1;
				}

			//
			//  Update predecessors
			//

			if (db > 0)
				{
				j = ((int)db) - 1;

				if (info[j].lockMode == LM_NONE)
					{
					do
						{
						info[j].succ += info[db].succ;
						j--;
						}
					while (j >= 0 && info[j].lockMode == LM_NONE);
					}
				else
					{
					do
						{
						if (succFree)
							info[j].succ--;
						else
							info[j].succ -= prevSucc;
						j--;
						}
					while (j >= 0 && info[j].lockMode != LM_NONE);
					}
				}

			}
		}

#if DBB_ENABLE_CHECK
	Check();
#endif

	GNRAISE_OK;
	}

//
//  Test if blocks are locked (lockMode of LM_NONE indicates don't care)
//

Error ScatterDriveBlockBuffer::BlocksLocked(DWORD block, DWORD num, DriveBlockLockMode lockMode, BOOL & locked)
	{
	DWORD i;
	DWORD db;

	locked = FALSE;

	for (i=0; i<num; i++)
		{
		if ((db = FindLockedBlock(block + i)) == FB_BLOCK_NOT_FOUND)
			GNRAISE_OK;

		if (lockMode != LM_NONE && info[db].lockMode != lockMode)
			GNRAISE_OK;
		}

	locked = TRUE;
	GNRAISE_OK;
	}

//
//  Flush data
//  GNR_OK
//

Error ScatterDriveBlockBuffer::Flush(void)
	{
	InitInfo();
	GNRAISE_OK;
	}

#if DBB_ENABLE_CHECK

//
//  Check consistency of buffer
//

void ScatterDriveBlockBuffer::Check(void)
	{
	int i;

	for (i=0; i<(int)blockNum - 1; i++)
		{
		if ((info[i].succ > 1 && info[i+1].succ > info[i].succ) || info[i].succ == 0)
			BREAKPOINT;
		}

	if (info[blockNum-1].succ != 1)
		{
		BREAKPOINT;
		}
	}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\hardware\drives\generic\GenericDrive.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  Generic Drive Classes
//
////////////////////////////////////////////////////////////////////

#ifndef GENERICDRIVE_H
#define GENERICDRIVE_H

#include "library/common/prelude.h"
#include "library/common/krnlstr.h"
#include "library/common/krnlsync.h"
#include "library/common/Profiles.h"
#include "library/hardware/drives/generic/DriveDefs.h"
#include "library/hardware/drives/generic/Requests.h"
#include "library/hardware/drives/generic/DriveErrors.h"
#include "library/Common/KrnlInt.h"

//
//  Flag format for disk access is as follows:
//  ffffffff ffffffff cccccccc tttttttt
//  f: disk access flag
//  c: disk access command
//  t: disk sector type
//

#define GD_SECTOR_TYPE_MASK			0x000000ff
#define GD_COMMAND_MASK					0x0000ff00
#define GD_FLAGS_MASK					0xffff0000

#define GD_SECTOR_TYPE(flags)			(flags & GD_SECTOR_TYPE_MASK)
#define GD_COMMAND(flags)				(flags & GD_COMMAND_MASK)
#define GD_FLAGS(flags)					(flags & GD_FLAGS_MASK)

//
//  Disk Sector Types. Note that the macro DST_TYPE_IS_CDROM(x) depends on the order of the values.
//

#define DST_NONE							0x00000000
#define DST_DVD_ROM						0x00000001
#define DST_CDDA							0x00000002		// Including subchannel
#define DST_CDROM_MODE1					0x00000003		// order of CDROM sector types is important, see DST_TYPE_IS_CDROM macro
#define DST_CDROM_MODE2					0x00000004		// order of CDROM sector types is important, see DST_TYPE_IS_CDROM macro
#define DST_CDROM_MODE2_XA_FORM1		0x00000005		// order of CDROM sector types is important, see DST_TYPE_IS_CDROM macro
#define DST_CDROM_MODE2_XA_FORM2		0x00000006		// order of CDROM sector types is important, see DST_TYPE_IS_CDROM macro
#define DST_HD								0x00000007

#define DST_TYPE_IS_CDROM(x)			(DST_CDROM_MODE1 <= (x)  &&  (x) <= DST_CDROM_MODE2_XA_FORM2)

//
//  Disk Access Commands
//

#define DAT_NONE							0x00000000		// No action
#define DAT_LOCK_MODIFY					0x00000100		// Lock buffer to modify it (without reading data first)
#define DAT_LOCK_AND_READ				0x00000200		// Lock buffer, then read data into it
#define DAT_LOCK_READ_MODIFY			0x00000300		// Lock buffer, read data to it and allow modification
#define DAT_UNLOCK_CLEAN				0x00000400		// Unlock buffer, discard any changes
#define DAT_UNLOCK_DIRTY				0x00000500		// Unlock buffer and write contents to disk

//
//  Disk Access Flags
//

#define DAF_NONE							0x00000000		// Nothing at all
#define DAF_FORCED						0x00010000		// Force reading data (drive level)
#define DAF_STREAMING					0x00020000		// Streaming mode, prefetch might be used (drive level)
#define DAF_READ_SUBCHANNEL			0x00040000		// Read subchannel information (drive level)
#define DAF_CACHED						0x00080000		// Cache data (volume level)
#define DAF_SCANNING						0x00100000		// Scanning mode, suppress read ahead in drive

//
//  Drive Capabilities (for GetDriveCapabilities() call)
//

#define GDC_NONE							0x0000			// Nothing at all
#define GDC_REMOVABLE					0x0001			// The media can be removed
#define GDC_WRITEABLE					0x0002			// The drive supports writing on media
#define GDC_CHANGER						0x0004			// The drive has media change capabilities
#define GDC_DVD_AUTHENTICATION		0x0008			// Drive supports DVD authentication mechanisms
#define GDC_READ_RECORDABLE			0x0010			// Drive supports reading recordable media
#define GDC_SUPPORTS_SUBCHANNEL		0x0020			// Drive supports reading (CDDA) subchannel info
#if MSNDISC
#define GDC_CHANGER_ROTATES_CLOCKWISE					0x0040	// Drive can rotate changer mechanism clockwise
#define GDC_CHANGER_ROTATES_COUNTERCLOCKWISE			0x0080	// Drive can rotate changer mechanism counter-clockwise
#define GDC_SUPPORTS_PUSH_SENSE							0x0100	// Drive supports push sense detection
#endif

//
//  Flags for LoadMedia() call
//

#define LMF_NONE							0x0000			// Nothing special
#define LMF_WAIT							0x0001			// Wait till load process is complete
#define LMF_NO_SPIN_UP					0x0002			// Do not spin up drive after load

//
//  Flags for UnloadMedia() call
//

#define UMF_NONE							0x0000			// Nothing special
#define UMF_WAIT							0x0001			// Wait till unload process is complete

//
//  Flags for MoveChanger call
//

#if MSNDISC
#define MCO_OPEN									0x0001		// Open changer - provide access to 1 or more media
#define MCO_CLOSE									0x0002		// Close changer - prevent access to media
#define MCO_ROTATE_CLOCKWISE					0x0004		// Rotate changer clockwise
#define MCO_ROTATE_COUNTER_CLOCKWISE		0x0008		// Rotate changer counter clockwise
#define MCO_ROTATE_TO_POSITION				0x0010		// Rotate changer to a position. Position is defined by specific implementation.
#define MCO_CLAMP									0x0020		// Clamp media
#define MCO_UNCLAMP								0x0040		// Unclamp media
#define MCO_ACKNOWLEDGE_PUSH_SENSE			0x0080		// Acknowledge push sense detection

//
//  Flags for GetChangerStatus call
//

#define GCS_UNKNOWN								0x0001		// Changer mechanism is in an unknown state
#define GCS_ERROR									0x0002		// Changer mechanism is in an error state
#define GCS_BUSY									0x0004		// Changer mechanism is not ready

#define GCS_OPEN									0x0008		// Changer mechanism is open, user has access to 1 or more media
#define GCS_CLOSED								0x0010		// Changer mechanism is closed, user has no access to media
#define GCS_OPENING								0x0020		// Changer mechanism is in the process of going to the open state
#define GCS_CLOSING								0x0040		// Changer mechanism is in the process of going to the closed state
#define GCS_ROTATING_CLOCKWISE				0x0080		// Changer mechanism is rotating clockwise
#define GCS_ROTATING_COUNTER_CLOCKWISE		0x0100		// Changer mechanism is rotating counter clockwise
#define GCS_AT_SLOT								0x0200		// Changer mechanism current position is a slot

#define GCS_CLAMP_UNKNOWN						0x0400		// Changer mechanism clamp state is unknown
#define GCS_CLAMPED								0x0800		// Changer mechanism has clamped the media
#define GCS_UNCLAMPED							0x1000		// Changer mechanism has unclamped the media
#define GCS_CLAMPING								0x2000		// Changer mechanism is clamping the media
#define GCS_UNCLAMPING							0x4000		// Changer mechanism is unclamping the media


//
// Flags for GetSlotStatus call
//
#define GSS_UNKNOWN								0x0001		// Slot status unknown
#define GSS_ERROR									0x0002		// Disc present mechanism in error state
#define GSS_BUSY									0x0004		// Disc present mechanism is busy
#define GSS_DISC_PRESENT						0x0008		// Disc present in slot
#define GSS_DISC_NOT_PRESENT					0x0010		// Disc not preset in slot


#endif

//
//  The type of drive we are talking to
//

enum GenericDriveType
	{
	GDRT_NONE,
	GDRT_GENERIC,
	GDRT_CDVD,
	GDRT_HD
	};

//
//  Volume ID (unique identifier for a volume)
//

typedef KernelInt64 VolumeID;

////////////////////////////////////////////////////////////////////
//
//  Drive Block Class
//  NOTE: None of the data contained in this class shall be modified
//  outside the DriveBlockBuffer or derived classes.
//
////////////////////////////////////////////////////////////////////

enum DriveBlockLockMode { LM_NONE, LM_READ, LM_WRITE };

class DriveBlock
	{
	protected:
		BYTE					*	realData;	// Data of the block
	public:
		DWORD						block;		// Index of the block
		BYTE					*	data;			// Data of the block with offset skipping headers
		DriveBlockLockMode	lockMode;	// Locked for read or write
		Error						err;			// Error that occurred reading this block
		DWORD						private0;	// Driver may store info here

		void Copy(DriveBlock * db);		// Copy management data to another drive block (NO BLOCK DATA!)
	};

////////////////////////////////////////////////////////////////////
//
//  Drive Control Information
//
//  This class encapsulates the information necessary for a drive
//  to initialize itself and do accesses via the OS.
//  This is usually generated by a DriveTable object.
//
////////////////////////////////////////////////////////////////////

class DriveControlInfo
	{
	public:
		KernelString driveName;

		DriveControlInfo(void) { driveName = ""; }
		DriveControlInfo(const KernelString & driveName) { this->driveName = driveName; }
		virtual ~DriveControlInfo(void) {}
	};

////////////////////////////////////////////////////////////////////
//
//  Generic Drive Class Declaration
//
//  This class declares a generic drive with basic management
//  functions. Note that this class declares block oriented drives.
//
////////////////////////////////////////////////////////////////////

class GenericDrive
	{
	protected:
		VDLocalMutex monitorMutex;
		DriveControlInfo * controlInfo;
		GenericProfile *profile;
		BOOL requestsEnabled;   // when FALSE, all drive requests should be rejected and return GNR_OPERATION_ABORTED

	public:
		GenericDrive(void);
		virtual ~GenericDrive(void);

		virtual Error Init(DriveControlInfo * info, GenericProfile * profile);
		virtual Error Cleanup(void);

		//
		//  Inquiry & config functions
		//

		virtual Error GetDriveName(KernelString & name);
#if MSNDISC
		virtual Error GetDriveCaps(GenericDriveType & type, DWORD & caps, DWORD & slots, DWORD& positions, DWORD& changerOpenOffset);
#else
		virtual Error GetDriveCaps(GenericDriveType & type, DWORD & caps, DWORD & slots);
#endif
		virtual Error GetDriveBlockSize(DWORD sectorType, DWORD & currentSize, DWORD & minSize, DWORD & maxSize, DWORD & step) = 0;
		virtual Error GetCurrentDriveBlockSize(DWORD & size);
		virtual Error SetDriveBlockSize(DWORD size) = 0;

		virtual Error GetNumberOfDriveBlocks(DWORD & num) = 0;
		virtual Error SetNumberOfDriveBlocks(DWORD num) = 0;

		virtual Error GetBlockInfo(DWORD sectorType, DWORD & blockSize, DWORD & headerSize, DWORD & dataSize);

		//
		//  Basic Drive Functions
		//

		virtual Error SpinUp(void) = 0;													// Spin up drive
		virtual Error SpinDown(void) = 0;												// Spin down drive
		virtual Error TerminateRequest(RequestHandle * rh) = 0;					// Terminate the current request (read/write)
		virtual Error Flush(void) = 0;													// Make sure all commands are executed

		//
		//  Media handling
		//


#if MSNDISC
		virtual Error LoadMedia(int slotNumber = 0, DWORD flags = LMF_WAIT) = 0;	// load media in slot slotNumber
		virtual Error UnloadMedia(DWORD flags = UMF_WAIT) = 0;							// remove current media
		virtual Error MoveChanger( DWORD operation, DWORD flags, DWORD param )=0;	// Move Changer
		virtual Error GetChangerStatus( DWORD& status, DWORD& position)=0;									// Get Changer Status
		virtual Error GetSlotStatus( DWORD slot, DWORD& status )=0;
		virtual Error LockClamp( void )=0;														// Lock clamp
		virtual Error UnlockClamp( void )=0;													// Unlock clamp

#else
		virtual Error LoadMedia(int slotNumber = 0, DWORD flags = LMF_WAIT) = 0;	// Close Tray, load media in slot slotNumber
		virtual Error UnloadMedia(DWORD flags = UMF_WAIT) = 0;							// Open Tray, remove current media

		virtual Error GetTrayStatus(GenericTrayStatus & status) = 0;			// Get Tray Status, was: GetDriveStatus
		virtual Error LockTray(void) = 0;												// Lock Tray
		virtual Error UnlockTray(void) = 0;												// Unlock Tray
#endif

		virtual Error GetDiskType(PhysicalDiskType & type) = 0;					// DVD, CD Rom, Audio CD, ...
		virtual Error GetVolumeID(VolumeID & volumeID) = 0;
		virtual Error GetCopyManagementInfo(DWORD block, GenericCopyManagementInfo & gcmi) = 0;

		//
		//  Data Access Functions
		//

		virtual Error SeekBlock(DWORD block, DWORD flags, RequestHandle * rh) = 0;
		virtual Error LockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh) = 0;
		virtual Error UnlockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh) = 0;

		virtual void DisableRequests (void) {requestsEnabled = FALSE;}
		virtual void EnableRequests (void) {requestsEnabled = TRUE;}
	};

////////////////////////////////////////////////////////////////////
//
//  CDVD Drive
//
////////////////////////////////////////////////////////////////////

#ifndef CDVDDRIVE_H
#define CDVDDRIVE_H

#include "GenericDrive.h"
#include "CDVDDefs.h"

class CDVDDrive : public GenericDrive
	{
	protected:

		//
		//  DVD Authentication
		//
		virtual Error StartAuthentication (void) = 0;
		virtual Error CompleteAuthentication (void) = 0;
		virtual Error CancelAuthentication (void) = 0;
		virtual Error GetChallengeKey (BYTE * key) = 0;
		virtual Error SendChallengeKey (BYTE * key) = 0;
		virtual Error GetBusKey (BYTE * key) = 0;
		virtual Error SendBusKey (BYTE * key) = 0;
		virtual Error GetDiskKey (BYTE * key) = 0;
		virtual Error GetTitleKey (DWORD block, BYTE * key) = 0;

	public:
		CDVDDrive (void) {}
		virtual ~CDVDDrive (void);

		//
		//  DVD Authentication
		//

		virtual Error DVDIsEncrypted (BOOL & enc) = 0;
		virtual Error DoAuthenticationCommand (DVDAuthenticationCommand com, DWORD sector, BYTE * key);
		virtual Error GetRPCData (BOOL & isRPC2, BYTE & regionCode, BYTE & availSets) = 0;
		virtual Error SetRegionCode (BYTE region) = 0;

		//
		//  CD Access Methods
		//

		virtual Error GetNumberOfSessions (WORD & sessions) = 0;

		virtual Error ReadCDTOC (WORD session, CDSessionType & sessionType, CDTocEntry * & toc, WORD & tocEntryNum, RequestHandle * rh) = 0;
			// Drive creates TOC entries, to be deleted by caller
	};

////////////////////////////////////////////////////////////////////
//
//  Interrupt CE Drive
//
////////////////////////////////////////////////////////////////////


#endif // of CDVDDRIVE_H

#endif // of GENERICDRIVE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\hardware\mpeg2dec\generic\mp2dcryp.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef MP2DCRYP_H
#define MP2DCRYP_H

#include "library/common/prelude.h"
#include "library/common/gnerrors.h"

#define GNR_CSS_NOT_SUPPORTED			MKERR(ERROR, DECRYPTION, OPERATION, 0x00)
#define GNR_AUTHENTICATION_FAILED	MKERR(ERROR, DECRYPTION, OPERATION, 0x00)

enum MPEG2DVDAuthenticationCommand
	{
	M2D_CHECK_DISK_KEY,				// 0
	M2D_CHECK_TITLE_KEY,          // 1
	M2D_START_AUTHENTICATION,     // 2
	M2D_READ_CHALLENGE_KEY,       // 3
	M2D_WRITE_BUS_KEY,            // 4
	M2D_WRITE_CHALLENGE_KEY,      // 5
	M2D_READ_BUS_KEY,             // 6
	M2D_WRITE_DISK_KEY,           // 7
	M2D_WRITE_TITLE_KEY,          // 8
	M2D_COMPLETE_AUTHENTICATION,  // 9
	M2D_CANCEL_AUTHENTICATION     // 10
	};

#ifndef ONLY_EXTERNAL_VISIBLE

#include "library/lowlevel/hardwrio.h"

class MPEG2DVDDecryption
	{
	public:
		virtual Error DoAuthenticationCommand(MPEG2DVDAuthenticationCommand com, DWORD sector, BYTE __far * key) = 0;
		virtual Error Initialize(void) {GNRAISE_OK;}
		virtual Error PacketReset(void) {GNRAISE_OK;}
	};

class PioneerDecryption : public MPEG2DVDDecryption
	{
	protected:
		BitOutputPort	*	sck;
		BitInputPort	*	mo;
		BitOutputPort	*	mi;
		BitOutputPort	*	ss;
		int					delay;

		BOOL	diskKeyValid;
		BOOL	titleKeyValid;
		DWORD	titleKeySector;

		BYTE buffer[15];

		Error StartTransfer(void);
		Error EndTransfer(void);
		Error TransferByte(BYTE data, BYTE __far & response);

		Error WriteSeq(int reg, int data, ...);
		Error WriteBytes(int reg, int num, BYTE __far * data);
		Error ReadBytes(int reg, int num, BYTE __far * data);
		Error WriteByte(int reg, BYTE data);
		Error ReadByte(int reg, BYTE __far & data);

	public:
		PioneerDecryption(BitOutputPort * sck,
		                  BitInputPort  * mo,
		                  BitOutputPort * mi,
		                  BitOutputPort * ss,
		                  int delay = 3);

		Error DoAuthenticationCommand(MPEG2DVDAuthenticationCommand com, DWORD sector, BYTE __far * key);
		Error Initialize(void);
		Error PacketReset(void);
	};

class ToshibaDecryption : public MPEG2DVDDecryption
	{
	protected:
		ByteOutputPort	*	indexPort;
		ByteInOutPort	*	dataPort;
		ByteOutputPort	*	streamPort;

 		BYTE	reqoMode;
		BYTE	enboMode;
		BOOL	freqDiv16;

		BOOL	diskKeyValid;
		BOOL	titleKeyValid;
		DWORD	titleKeySector;

		Error WriteSeq(int reg, int data, ...);
		Error WriteBytes(int reg, int num, BYTE __far * data);
		Error ReadBytes(int reg, int num, BYTE __far * data);
		Error WriteByte(int reg, BYTE data);
		Error ReadByte(int reg, BYTE __far & data);
	public:
		ToshibaDecryption(ByteOutputPort *	indexPort,
		                  ByteInOutPort 	*	dataPort,
		                  ByteOutputPort	*	streamPort,
		                  BYTE					reqoMode,
		                  BYTE					enboMode,
		                  BOOL					freqDiv16);

		Error DoAuthenticationCommand(MPEG2DVDAuthenticationCommand com, DWORD sector, BYTE __far * key);
		Error Initialize(void);
		Error PacketReset(void);
	};

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\hardware\mpeg2dec\generic\MP2StreamReceiver.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef MP2STREAMRECEIVER_H
#define MP2STREAMRECEIVER_H

#include "library/common/prelude.h"
#include "library/common/gnerrors.h"

enum MPEG2PESType
	{
	MP2PES_ELEMENTARY,
	MP2PES_DVD,
	MP2PES_MPEG
	};

#define MP2SR_SCALE_BITS		0x80000L
#define MP2SR_SCALE_BYTES		0x10000L
#define MP2SR_SCALE_WORDS		0x08000L
#define MP2SR_SCALE_DWORDS		0x04000L
#define MP2SR_SCALE_DVDPES		0x00020L

struct MPEGDataSizePair
	{
	HBPTR		data;
	DWORD		size;
	int		timeStamp;
	DWORD		pad0;
	};

#ifndef ONLY_EXTERNAL_VISIBLE

class MPEG2StreamReceiver
	{
	public:
		virtual DWORD SendData(HPTR data, DWORD size) = 0;
		virtual DWORD SendDataMultiple (MPEGDataSizePair * data, DWORD size);
			//
			// Scale factor is fixed point number 16:16 bits
			//
			// e.g. Scale = 0x8000 is in WORDs
			//
		virtual DWORD LastTransferLocation(DWORD scale = MP2SR_SCALE_BYTES) = 0;
		virtual void CompleteData(void) = 0;
		virtual void FlushData(void) {};

		virtual void PutPTS(DWORD pts) {};

		virtual MPEG2PESType NeedsPES(void) {return MP2PES_ELEMENTARY;}
		virtual Error SendPESData(HPTR data, DWORD size, DWORD __far & done, DWORD __far & used) {GNRAISE(GNR_UNIMPLEMENTED);}
		virtual Error VOBUBorderReached(void) {GNRAISE_OK;}
	};

inline DWORD XScaleDWord(DWORD pos, DWORD from, DWORD to) {return pos == 0xffffffff ? pos : ScaleDWord(pos, from, to);}

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\hardware\mpeg2dec\generic\mpeg2dec.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef MPEG2DEC_H
#define MPEG2DEC_H

#include "library/common/prelude.h"
#include "library/common/gnerrors.h"
#include "mp2eldec.h"

#include "mp2dcryp.h"

#ifndef ONLY_EXTERNAL_VISIBLE

#include "mp2spudc.h"
#include "mp2demux.h"

class MPEG2AVDecoder : public MPEG2ElementaryDecoder
   {
   friend class VirtualMPEG2AVDecoder;
   protected:
   	MPEGStreamType		streamType;
   	BOOL					ac3;
   	BOOL					mpeg2Coding;
   	BOOL					lpcm;
		MPEG2AudioType		audioType;

		virtual Error SetAudioBitrate(DWORD rate) = 0;
		virtual Error SetSampleRate(WORD rate) = 0; // in samples per second;
		virtual Error SetLeftVolume(WORD volume) = 0;
		virtual Error SetRightVolume(WORD volume) = 0;
		virtual Error SetMute(BOOL mute) = 0;

		virtual Error SetBassConfig(AC3BassConfig config) = 0;
		virtual Error SetSpeakerConfig(AC3SpeakerConfig config) = 0;
		virtual Error SetCenterDelay(WORD delay) = 0;
		virtual Error SetSurroundDelay(WORD delay) = 0;

		virtual Error SetCenterVolume(WORD volume) = 0;
		virtual Error SetLeftSurroundVolume(WORD volume) = 0;
		virtual Error SetRightSurroundVolume(WORD volume) = 0;
		virtual Error SetSubwooferVolume(WORD volume) = 0;

		virtual Error SetAC3(BOOL ac3) {this->ac3 = ac3; GNRAISE_OK;}
		virtual Error SetLPCM(BOOL lpcm) {this->lpcm = lpcm; GNRAISE_OK;}
		virtual Error SetVideoBitrate(DWORD videoBitrate) = 0;
		virtual Error SetVideoWidth(WORD width) = 0;
		virtual Error SetVideoHeight(WORD height) = 0;
		virtual Error SetVideoFPS(WORD fps) = 0;
		virtual Error SetAspectRatio(WORD aspectRatio) = 0;
		virtual Error SetVideoStandard(VideoStandard	standard) = 0;
#if TEST_PAL_TO_NTSC
		virtual Error SetApplicationVideoStandard(VideoStandard	standard) = 0;
		virtual MovingImageStandard GetEncoderMovingImageStandard () = 0;
#endif
		virtual Error SetStreamType(MPEGStreamType streamType) = 0;
		virtual Error SetStreamMode(MPEGStreamMode streamMode) = 0;
		virtual Error SetMPEG2Coding(BOOL mpeg2Coding) {this->mpeg2Coding = mpeg2Coding; GNRAISE_OK;}
      virtual Error SetVideoStreamID(BYTE id) = 0;
      virtual Error SetAudioStreamID(BYTE id) = 0;
      virtual Error SetAC3StreamID(BYTE id) = 0;
   	virtual Error SetPresentationMode(MPEG2PresentationMode presentationMode) = 0;

      virtual Error SetLPCMStreamID(BYTE id) = 0;
		virtual Error SetDTSStreamID(BYTE id) = 0;
      virtual Error SetSPUStreamID(BYTE id) = 0;
		virtual Error SetMLPStreamID(BYTE id) = 0;
      virtual Error SetSPUEnable(BOOL enable) = 0;
      virtual Error SetSPUButtonState(SPUButtonState state) = 0;
      virtual Error SetSPUButtonPosition(int x, int y, int width, int height) = 0;
      virtual Error SetSPUButtonColors(DWORD selected, DWORD active) = 0;
      virtual Error SetSPUPaletteEntry(int p, int y, int u, int v) = 0;
      virtual Error SetSPUCommandHook(MPEG2SPUCommandHookHandle hook) = 0;
      virtual Error SetSPUButtonID(WORD id) {GNRAISE_OK;}
      virtual Error SetBitsPerSample(WORD bits) = 0;
      virtual Error SetChannels(WORD channels) = 0;
      virtual Error DoAuthenticationCommand(MPEG2DVDAuthenticationCommand com, DWORD sector, BYTE __far * key) = 0;

#if WDM_VERSION
		virtual Error SetCCPacketHook(MPEG2CCPacketHookHandle hook) = 0;
#endif
		virtual DWORD SendDataSplit(MPEGElementaryStreamType type, HPTR data, DWORD size, LONG time) = 0;
		virtual void CompleteDataSplit(MPEGElementaryStreamType type) = 0;
		virtual void RestartDataSplit(MPEGElementaryStreamType type) = 0;

		virtual Error SetAudioType(MPEG2AudioType audioType) {this->audioType = audioType; GNRAISE_OK;}
	public:
		VirtualUnit * CreateVirtual(void);

		virtual VirtualMPEG2AVDecoder * CreateVirtualMPEGDecoder(void) = 0;
   };

class VirtualMPEG2AVDecoder : public VirtualMPEG2ElementaryDecoder
	{
	private:
		MPEG2AVDecoder * decoder;
	protected:
   	MPEGStreamType		streamType;
		MPEGStreamMode		streamMode;
   	BOOL					mpeg2Coding;
   	BOOL					ac3;
   	BOOL					lpcm;
   	DWORD					audioBitrate;
		DWORD					videoBitrate;
		DWORD					streamBitrate;
		WORD					videoWidth;
		WORD					videoHeight;
		WORD					videoFPS;
		WORD					aspectRatio;
//		VideoStandard		videoStandard;		// why is this here????
		WORD					sampleRate;
		WORD					leftVolume;
		WORD					rightVolume;
		BOOL					audioMute;

		AC3BassConfig  	bassConfig;
		AC3SpeakerConfig  speakerConfig;
		WORD					centerDelay;
		WORD					surroundDelay;
		WORD					centerVolume;
		WORD					leftSurroundVolume;
		WORD					rightSurroundVolume;
		WORD					subwooferVolume;

		BYTE					videoStreamID;
		BYTE					audioStreamID;
		BYTE					ac3StreamID;
		BYTE					lpcmStreamID;
		BYTE					dtsStreamID;
		BYTE					mlpStreamID;
		BYTE					spuStreamID;
		WORD					channels;
		WORD					bitsPerSample;
		MPEG2PresentationMode	presentationMode;

		BOOL					spuEnable;
		SPUButtonState		buttonState;
		WORD					bx, by, bw, bh;
		DWORD					buttonSelectColor;
		DWORD					buttonActiveColor;
		DWORD					spuPalette[16];
		WORD					buttonID;
		MPEG2SPUCommandHookHandle	spuCommandHook;

#if WDM_VERSION
		MPEG2CCPacketHookHandle		ccPacketHook;
#endif
		MPEG2AudioType		audioType;

		Error PreemptChange(VirtualUnit * previous);
	public:
		VirtualMPEG2AVDecoder(MPEG2AVDecoder * decoder);

		Error Configure(TAG __far * tags);

      virtual Error DoAuthenticationCommand(MPEG2DVDAuthenticationCommand com, DWORD sector, BYTE __far * key);
		virtual Error GetDisplaySize(WORD __far &width, WORD __far &height) = 0;
		virtual DWORD SendDataSplit(MPEGElementaryStreamType type, HPTR data, DWORD size, LONG time);
		virtual void CompleteDataSplit(MPEGElementaryStreamType type);
		virtual void RestartDataSplit(MPEGElementaryStreamType type);

		virtual Error SetLine21Receiver(Line21Receiver * line21Receiver);
	};

#endif // ONLY_EXTERNAL_VISIBLE

#endif // MPEG2DEC_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\hardware\drives\generic\Requests.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  Request Handling Classes
//
////////////////////////////////////////////////////////////////////

#ifndef REQUESTS_H
#define REQUESTS_H

#include "library/general/lists.h"

////////////////////////////////////////////////////////////////////
//
//  Request Handle Class
//
////////////////////////////////////////////////////////////////////

class RequestHandle
	{
	protected:
		BOOL valid;
//		VDLocalMutex lock;

	public:
		RequestHandle(void) { valid = FALSE; }
		~RequestHandle(void) {}

		void Activate(void)
//			{ lock.Enter(); valid = TRUE; lock.Leave(); }
  			{ valid = TRUE; }

		void Passivate(void)
//			{ lock.Enter(); valid = FALSE; lock.Leave(); }
			{ valid = FALSE; }

		BOOL Valid(void) { return valid; }
	};

////////////////////////////////////////////////////////////////////
//
//  Request Store Class(es)
//
////////////////////////////////////////////////////////////////////

class RequestStore
	{
	//
	//  Request node class
	//  List node for storing requests
	//

	class RequestNode : public Node
		{
		public:
			RequestHandle	*	rh;
			DWORD					type;

			RequestNode(RequestHandle * rh, DWORD type) { this->rh = rh; this->type = type; }
		};

	protected:
		List requests;

	public:
		RequestStore(void);
		~RequestStore(void);

		Error AddRequest(RequestHandle * rh, DWORD type)
			{ RequestNode * rn = new RequestNode(rh, type); requests.Push(rn); GNRAISE_OK; }

		Error RemoveRequest(RequestHandle * rh);
		Error FindRequest(RequestHandle * rh, DWORD & type);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\hardware\drives\generic\GenericDrive.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  Generic Drive Classes
//
////////////////////////////////////////////////////////////////////

#include "GenericDrive.h"

////////////////////////////////////////////////////////////////////
//
//  Drive Block Class
//
////////////////////////////////////////////////////////////////////

//
//  Copy data to another drive block
//  WARNING: data is not copied, not the pointer to it
//

void DriveBlock::Copy(DriveBlock * db)
	{
	db->block = block;
	db->lockMode = lockMode;
	db->err = err;
	db->private0 = private0;
	}

////////////////////////////////////////////////////////////////////
//
//  Generic Drive Class
//
////////////////////////////////////////////////////////////////////

//
//  Constructor
//

GenericDrive::GenericDrive(void)
	{
	controlInfo = NULL;
	requestsEnabled = TRUE;
	}

//
//  Destructor
//

GenericDrive::~GenericDrive(void)
	{
	}

//
//  Initialize drive
//

Error GenericDrive::Init(DriveControlInfo * controlInfo, GenericProfile * profile)
	{
	this->controlInfo = controlInfo;
	this->profile = profile;
	GNRAISE_OK;
	}

//
//  Cleanup
//

Error GenericDrive::Cleanup(void)
	{
	controlInfo = NULL;
	GNRAISE_OK;
	}

//
//  Get drive name
//

Error GenericDrive::GetDriveName(KernelString & name)
	{
	VDAutoMutex mutex(&monitorMutex);

	if (controlInfo)
		{
		name = controlInfo->driveName;
		GNRAISE_OK;
		}
	else
		GNRAISE(GNR_OBJECT_NOT_FOUND);
	}

//
//  Get drive capabilities
//
#if MSNDISC
Error GenericDrive::GetDriveCaps(GenericDriveType & type, DWORD & caps, DWORD & slots, DWORD& positions, DWORD& changerOpenOffset)
	{
	type = GDRT_GENERIC;
	caps = GDC_NONE;
	slots = 1;
	positions = 1;
	changerOpenOffset = 0;
	GNRAISE_OK;
	}
#else
Error GenericDrive::GetDriveCaps(GenericDriveType & type, DWORD & caps, DWORD & slots)
	{
	type = GDRT_GENERIC;
	caps = GDC_NONE;
	slots = 1;
	GNRAISE_OK;
	}
#endif
//
//  Get drive block size
//

Error GenericDrive::GetCurrentDriveBlockSize(DWORD & size)
	{
	VDAutoMutex mutex(&monitorMutex);
	DWORD minSize, maxSize, step;

	return GetDriveBlockSize(DST_NONE, size, minSize, maxSize, step);
	}

//
//  Get misc info about a block
//

Error GenericDrive::GetBlockInfo(DWORD sectorType, DWORD & blockSize, DWORD & headerSize, DWORD & dataSize)
	{
	switch (sectorType)
		{
		case DST_DVD_ROM:
			blockSize = DVD_BLOCK_SIZE;
			headerSize = 0;
			dataSize = DVD_BLOCK_SIZE;
			break;
		case DST_CDDA:
			blockSize = CD_FRAME_SIZE + CDDA_SUBCHANNEL_SIZE;
			headerSize = 0;
			dataSize = CD_FRAME_SIZE + CDDA_SUBCHANNEL_SIZE;
			break;
		case DST_CDROM_MODE1:
			blockSize = CD_FRAME_SIZE;
			headerSize = CDROM_FORM1_HEADER;
			dataSize = CDROM_FORM1_DATA;
			break;
		case DST_CDROM_MODE2:
			blockSize = CD_FRAME_SIZE;
			headerSize = CDROM_FORM2_HEADER;
			dataSize = CDROM_FORM2_DATA;
			break;
		case DST_CDROM_MODE2_XA_FORM1:
			blockSize = CD_FRAME_SIZE;
			headerSize = CDROM_XAFORM1_HEADER;
			dataSize = CDROM_XAFORM1_DATA;
			break;
		case DST_CDROM_MODE2_XA_FORM2:
			blockSize = CD_FRAME_SIZE;
			headerSize = CDROM_XAFORM2_HEADER;
			dataSize = CDROM_XAFORM2_DATA;
			break;
		default:
			GNRAISE(GNR_OBJECT_INVALID);
		}

	GNRAISE_OK;
	}


////////////////////////////////////////////////////////////////////
//
//  CDVD Drive
//
////////////////////////////////////////////////////////////////////

//
//  Destructor
//

CDVDDrive::~CDVDDrive(void)
	{
	}


//
//  Do authentication command
//

Error CDVDDrive::DoAuthenticationCommand(DVDAuthenticationCommand com, DWORD sector, BYTE * key)
	{
	VDAutoMutex mutex(&monitorMutex);
	Error err;

//	DP(__TEXT("AP+ : %d %02x%02x%02x%02x%02x.%02x%02x%02x%02x%02x"), com, key[0], key[1], key[2], key[3], key[4], key[5], key[6], key[7], key[8], key[9]);

	switch (com)
		{
		case DAC_START_AUTHENTICATION:
			err = StartAuthentication();
			break;
		case DAC_READ_CHALLENGE_KEY:
			err = GetChallengeKey(key);
			break;
		case DAC_WRITE_BUS_KEY:
			err = SendBusKey(key);
			break;
		case DAC_WRITE_CHALLENGE_KEY:
			err = SendChallengeKey(key);
			break;
		case DAC_READ_BUS_KEY:
			err = GetBusKey(key);
			break;
		case DAC_READ_DISK_KEY:
			err = GetDiskKey(key);
			break;
		case DAC_READ_TITLE_KEY:
			err = GetTitleKey(sector, key);
			break;
		case DAC_COMPLETE_AUTHENTICATION:
			err = CompleteAuthentication();
			break;
		case DAC_CANCEL_AUTHENTICATION:
			err = CancelAuthentication();
			break;
		default:
			err = GNR_INVALID_PARAMETERS;
		}

//	DP(__TEXT("AP- : %d %02x%02x%02x%02x%02x.%02x%02x%02x%02x%02x"), com, key[0], key[1], key[2], key[3], key[4], key[5], key[6], key[7], key[8], key[9]);

	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\hardware\mpgcodec\generic\mpgcodec.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:       library\hardware\mpgcodec\generic\mpgcodec.h
// AUTHOR:		Martin Stephan
// COPYRIGHT:	(c) 1999 Viona Development GmbH.  All Rights Reserved.
// CREATED:		22.11.1999
//
// PURPOSE: 	shared definitions for MPEG2 encoder and decoder --- Header file
//					most of these definitions were previously defined in mpegdec.h
//					and were now moved to mpgcodec.h!
//
// HISTORY:
//

#ifndef MPGCODEC_H
#define MPGCODEC_H


enum MPEGCommand {mpc_none, 	  		// 0x0
                  mpc_start,    		// 0x1
                  mpc_play,     		// 0x2
                  mpc_seek,     		// 0x3
                  mpc_stop,     		// 0x4
                  mpc_step,     		// 0x5
                  mpc_freeze,   		// 0x6
                  mpc_resync,   		// 0x7
                  mpc_resyncue, 		// 0x8
                  mpc_cue,				// 0x9
                  mpc_end,				// 0xA
                  mpc_params,			// 0xB
                  mpc_stepkey,		// 0xC
                  mpc_scan,			// 0xD
						mpc_reverse,		// 0xE
						mpc_trickplay,		// 0xF
						mpc_seekaudio,		// 0x10
						mpc_resyncaudio,	// 0x11
						mpc_audio_test		// 0x12	Audio tests : pink noise, test tone
						};

enum MPEGState   {mps_reset, mps_preempted, mps_initial,
                  mps_frozen, mps_playing, mps_stepping,
                  mps_seeking, mps_resyncing, mps_stopped,
                  mps_scanning, mps_trickplaying, mps_testing,
						mps_capturing};

enum MPEGElementaryStreamType
	{
	MST_VIDEO,
	MST_AUDIO,
	MST_SUBPICTURE
	};


#endif // MPGCODEC_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\hardware\drives\specific\xboxdvddrive.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


#include "Library/Common/Prelude.h"
#include "Library/Common/vddebug.h"
#include "XBOXDVDDrive.h"
#include "Library/Hardware/Drives/Generic/CDVDDefs.h"
#include "ntddstor.h"
#include "ntddcdrm.h"
#include "winnt.h"

#ifndef _NTDDCDVD_
#define _NTDDCDVD_

#if _MSC_VER>1000
#pragma once
#endif

#define TEST_REDUCED_DRIVE_TIMEOUT 0

//
// NtDeviceIoControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//

#define FILE_DEVICE_CD_ROM              0x00000002
#define FILE_DEVICE_DVD                 0x00000033
#define FILE_DEVICE_MASS_STORAGE        0x0000002d
#define IOCTL_DVD_BASE                 FILE_DEVICE_DVD

#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)

//
// Define the method codes for how buffers are passed for I/O and FS controls
//

#define METHOD_BUFFERED                 0
#define METHOD_IN_DIRECT                1
#define METHOD_OUT_DIRECT               2
#define METHOD_NEITHER                  3

//
// Define the access check value for any access
//
//
// The FILE_READ_ACCESS and FILE_WRITE_ACCESS constants are also defined in
// ntioapi.h as FILE_READ_DATA and FILE_WRITE_DATA. The values for these
// constants *MUST* always be in sync.
//


#define FILE_ANY_ACCESS                 0
#define FILE_READ_ACCESS          ( 0x0001 )    // file & pipe
#define FILE_WRITE_ACCESS         ( 0x0002 )    // file & pipe

//
// CDVD Device Control Functions
//
// Warning: Ioctls from 200 through 300 are used for the old common class
// driver ioctls and should not be used for device specific functionality
//

//
// Copyright ioctls
//

#define IOCTL_DVD_START_SESSION     CTL_CODE(IOCTL_DVD_BASE, 0x0400, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DVD_READ_KEY          CTL_CODE(IOCTL_DVD_BASE, 0x0401, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DVD_SEND_KEY          CTL_CODE(IOCTL_DVD_BASE, 0x0402, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DVD_END_SESSION       CTL_CODE(IOCTL_DVD_BASE, 0x0403, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DVD_SET_READ_AHEAD    CTL_CODE(IOCTL_DVD_BASE, 0x0404, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DVD_GET_REGION        CTL_CODE(IOCTL_DVD_BASE, 0x0405, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DVD_SEND_KEY2         CTL_CODE(IOCTL_DVD_BASE, 0x0406, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

//
// DVD Structure queries
//

#define IOCTL_DVD_READ_STRUCTURE    CTL_CODE(IOCTL_DVD_BASE, 0x0450, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// The following file contains the IOCTL_STORAGE class ioctl definitions
//

#define IOCTL_STORAGE_SET_READ_AHEAD        CTL_CODE(IOCTL_STORAGE_BASE, 0x0100, METHOD_BUFFERED, FILE_READ_ACCESS)


#ifdef __cplusplus
extern "C" {
#endif

#pragma warning(disable : 4200)

typedef enum {
    DvdChallengeKey = 0x01,
    DvdBusKey1,
    DvdBusKey2,
    DvdTitleKey,
    DvdAsf,
    DvdSetRpcKey = 0x6,
    DvdGetRpcKey = 0x8,
    DvdDiskKey = 0x80,
    DvdInvalidateAGID = 0x3f
} DVD_KEY_TYPE;

typedef struct _DVD_COPY_PROTECT_KEY {
    ULONG KeyLength;
    DVD_SESSION_ID SessionId;
    DVD_KEY_TYPE KeyType;
    ULONG KeyFlags;
    union {
        HANDLE FileHandle;
        LARGE_INTEGER TitleOffset;
    } Parameters;
    UCHAR KeyData[0];
} DVD_COPY_PROTECT_KEY, *PDVD_COPY_PROTECT_KEY;

//
// Predefined (Mt. Fuji) key sizes
// Add sizeof(DVD_COPY_PROTECT_KEY) to get allocation size for
// the full key structure
//

#define DVD_CHALLENGE_KEY_LENGTH    (12 + sizeof(DVD_COPY_PROTECT_KEY))
#define DVD_BUS_KEY_LENGTH          (8 + sizeof(DVD_COPY_PROTECT_KEY))
#define DVD_TITLE_KEY_LENGTH        (8 + sizeof(DVD_COPY_PROTECT_KEY))
#define DVD_DISK_KEY_LENGTH         (2048 + sizeof(DVD_COPY_PROTECT_KEY))
#define DVD_RPC_KEY_LENGTH          (sizeof(DVD_RPC_KEY) + sizeof(DVD_COPY_PROTECT_KEY))
#define DVD_SET_RPC_KEY_LENGTH      (sizeof(DVD_SET_RPC_KEY) + sizeof(DVD_COPY_PROTECT_KEY))
#define DVD_ASF_LENGTH              (sizeof(DVD_ASF) + sizeof(DVD_COPY_PROTECT_KEY))

//
// Used with IOCTL_DVD_END_SESSION to end all DVD sessions at once
//

#define DVD_END_ALL_SESSIONS ((DVD_SESSION_ID) 0xffffffff)

//
// CGMS Copy Protection Flags
//

#define DVD_CGMS_RESERVED_MASK      0x00000078

#define DVD_CGMS_COPY_PROTECT_MASK  0x00000018
#define DVD_CGMS_COPY_PERMITTED     0x00000000
#define DVD_CGMS_COPY_ONCE          0x00000010
#define DVD_CGMS_NO_COPY            0x00000018

#define DVD_COPYRIGHT_MASK          0x00000040
#define DVD_NOT_COPYRIGHTED         0x00000000
#define DVD_COPYRIGHTED             0x00000040

#define DVD_SECTOR_PROTECT_MASK     0x00000020
#define DVD_SECTOR_NOT_PROTECTED    0x00000000
#define DVD_SECTOR_PROTECTED        0x00000020

/*++

IOCTL_STORAGE_SET_READ_AHEAD

Requests that the storage device skip to TargetAddress once it has run across
TriggerAddress during the course of it's read-ahead caching operations.

Input:

    a STORAGE_SET_READ_AHEAD structure which contains:
        * the trigger address
        * the target address

Output:

    none

--*/

typedef struct _STORAGE_SET_READ_AHEAD {
    LARGE_INTEGER TriggerAddress;
    LARGE_INTEGER TargetAddress;
} STORAGE_SET_READ_AHEAD, *PSTORAGE_SET_READ_AHEAD;

/*++

IOCTL_DVD_READ_STRUCTURE

Issues a READ_DVD_STRUCTURE command to the drive.

Input:

    a DVD_READ_STRUCTURE describing what information is requested

Output:

    a DVD Layer Descriptor as defined below

--*/

typedef enum DVD_STRUCTURE_FORMAT {
    DvdPhysicalDescriptor,
    DvdCopyrightDescriptor,
    DvdDiskKeyDescriptor,
    DvdBCADescriptor,
    DvdManufacturerDescriptor,
    DvdMaxDescriptor
} DVD_STRUCTURE_FORMAT, *PDVD_STRUCTURE_FORMAT;

typedef struct DVD_READ_STRUCTURE {
    LARGE_INTEGER BlockByteOffset;
    DVD_STRUCTURE_FORMAT Format;
    DVD_SESSION_ID SessionId;
    UCHAR LayerNumber;
} DVD_READ_STRUCTURE, *PDVD_READ_STRUCTURE;

typedef struct _DVD_DESCRIPTOR_HEADER {
    USHORT Length;
    UCHAR Reserved[2];
    UCHAR Data[0];
} DVD_DESCRIPTOR_HEADER, *PDVD_DESCRIPTOR_HEADER;

typedef struct _DVD_LAYER_DESCRIPTOR {
    USHORT Length;
    UCHAR BookVersion : 4;
    UCHAR BookType : 4;
    UCHAR MinimumRate : 4;
    UCHAR DiskSize : 4;
    UCHAR LayerType : 4;
    UCHAR TrackPath : 1;
    UCHAR NumberOfLayers : 2;
    UCHAR Reserved1 : 1;
    UCHAR TrackDensity : 4;
    UCHAR LinearDensity : 4;
    ULONG StartingDataSector;
    ULONG EndDataSector;
    ULONG EndLayerZeroSector;
    UCHAR Reserved5 : 7;
    UCHAR BCAFlag : 1;
    UCHAR Reserved6;
	 UCHAR bugbug[4];
} DVD_LAYER_DESCRIPTOR, *PDVD_LAYER_DESCRIPTOR;

typedef struct _DVD_COPYRIGHT_DESCRIPTOR {
    UCHAR CopyrightProtectionType;
    UCHAR RegionManagementInformation;
    USHORT Reserved;
} DVD_COPYRIGHT_DESCRIPTOR, *PDVD_COPYRIGHT_DESCRIPTOR;

typedef struct _DVD_DISK_KEY_DESCRIPTOR {
    UCHAR DiskKeyData[2048];
} DVD_DISK_KEY_DESCRIPTOR, *PDVD_DISK_KEY_DESCRIPTOR;

typedef struct _DVD_BCA_DESCRIPTOR {
    UCHAR BCAInformation[0];
} DVD_BCA_DESCRIPTOR, *PDVD_BCA_DESCRIPTOR;

typedef struct _DVD_MANUFACTURER_DESCRIPTOR {
    UCHAR ManufacturingInformation[2048];
} DVD_MANUFACTURER_DESCRIPTOR, *PDVD_MANUFACTURER_DESCRIPTOR;

typedef struct _DVD_RPC_KEY {
    UCHAR UserResetsAvailable:3;
    UCHAR ManufacturerResetsAvailable:3;
    UCHAR TypeCode:2;
    UCHAR RegionMask;
    UCHAR RpcScheme;
    UCHAR Reserved2[1];
} DVD_RPC_KEY, * PDVD_RPC_KEY;

typedef struct _DVD_SET_RPC_KEY {
    UCHAR PreferredDriveRegionCode;
    UCHAR Reserved[3];
} DVD_SET_RPC_KEY, * PDVD_SET_RPC_KEY;

typedef struct _DVD_ASF {
    UCHAR Reserved0[3];
    UCHAR SuccessFlag:1;
    UCHAR Reserved1:7;
} DVD_ASF, * PDVD_ASF;

typedef struct _DVD_REGION {
     UCHAR CopySystem;
     UCHAR RegionData;                      // current media region (not playable when set)
     UCHAR SystemRegion;                    // current drive region (playable when set)
     UCHAR ResetCount;                      // number of resets available
} DVD_REGION, *PDVD_REGION;

#ifdef __cplusplus
}
#endif
#pragma warning(default : 4200)


#endif  // _NTDDCDVD_

// session info, used to get information about the last session on a multisession disk
// used at GetNumberOfSessions(..).
// this session can be referred to from outside the drive object as session 2
// structure see ATAPI-Documentation, Read Toc Command, Format Field 01h
typedef struct _SessionInfo
	{
	WORD dataLength;
	BYTE firstSession;
	BYTE lastSession;
	BYTE reserved;
	BYTE addr:4;
	BYTE contr:4;
	BYTE firstTrackLastSession;
	BYTE reserved2;
	BYTE addresse[4];
	} SessionInfo;

#define FILE_DEVICE_CONTROLLER          0x00000004
#define IOCTL_SCSI_BASE                 FILE_DEVICE_CONTROLLER
#define IOCTL_SCSI_PASS_THROUGH_DIRECT  CTL_CODE(IOCTL_SCSI_BASE, 0x0405, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

#define SCSI_IOCTL_DATA_OUT          0
#define SCSI_IOCTL_DATA_IN           1
#define SCSI_IOCTL_DATA_UNSPECIFIED  2

typedef struct _SCSI_PASS_THROUGH_DIRECT {
    USHORT Length;
    UCHAR ScsiStatus;
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    UCHAR CdbLength;
    UCHAR SenseInfoLength;
    UCHAR DataIn;
    ULONG DataTransferLength;
    ULONG TimeOutValue;
    PVOID DataBuffer;
    ULONG SenseInfoOffset;
    UCHAR Cdb[16];
}SCSI_PASS_THROUGH_DIRECT, *PSCSI_PASS_THROUGH_DIRECT;

struct SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER : SCSI_PASS_THROUGH_DIRECT {
    ULONG             Filler;      // realign buffer to double word boundary
    UCHAR             ucSenseBuf[32];
    };

#define SFF_MODE_SENSE					0x5a
#define SFF_MODE_SELECT					0x55





////////////////////////////////////////////////////////////////////
//
//  W2K CDVD Drive Class
//
////////////////////////////////////////////////////////////////////


//
//  Constructor
//

XBOXDVDDrive::XBOXDVDDrive()
	{
	this->lockCount = 0;
	this->hDevice = NULL;
	this->blockDiff = 0;
	this->singleBlockCacheBlock = 0xffffffff;
	this->streamingMode = SMD_UNKNOWN;
	this->spindleSpeed = 2;
	this->successfulReadSectors = 0;
	}

//
//  Destructor
//

XBOXDVDDrive::~XBOXDVDDrive()
	{
	if (hDevice)
		{
		CloseDevice();
		}

	hDevice = NULL;
	}


//
//  Initialize drive
//

Error XBOXDVDDrive::Init(DriveControlInfo * pInfo, GenericProfile * pProfile)
	{
	Error err = GNR_OK;


	if (!IS_ERROR(err))
		{
		err = BlockBufferCDVDDrive::Init(pInfo, pProfile);
		}

	if (!IS_ERROR(err))
		{
		this->internalDriveName = pInfo->driveName+ (KernelString) ":";
		}

	// if device open, close it
	if (!IS_ERROR(err))
		{
		CloseDevice();
		}

	// set internal device name
	if (!IS_ERROR(err))
		{
		err = this->GetDevice(true);
		}

	return err;
	}


//
// CleanUp
//

Error XBOXDVDDrive::Cleanup()
	{
	Error err = GNR_OK;

/*	if (!IS_ERROR(err) && blockBuffer)
		{
		delete blockBuffer;
		blockBuffer = NULL;
		}

	if (!IS_ERROR(err) && tocBuffer)
		{
		delete[] tocBuffer;
		tocBufferSize = 0;
		} */

	if (!IS_ERROR(err))
		{
		err = CloseDevice();
		}

	return err;
	}

//
// Close Handle to Device
//
Error XBOXDVDDrive::CloseDevice()
	{
	Error err = GNR_OK;

	if (!IS_ERROR(err) && this->hDevice)
		{
		CloseHandle(this->hDevice);
		this->hDevice = NULL;
		}

	return err;
	}


//
// Get Handle to Device
//
Error XBOXDVDDrive::GetDevice(BOOL forced)
	{
	// if forced then close handle first to reopen...
	if (forced)
		CloseDevice();

	// get possible access rights
	if (!this->hDevice)
		{
		//
		// get access rights
		//
		HRESULT res = S_OK;

		encryptionInfoValid = false;

		DWORD desiredAccess = 0;

		desiredAccess = GENERIC_READ/* | GENERIC_WRITE*/;

		// Open file, FILE_FLAG_NO_BUFFERING must be set !
		//	GENERIC_WRITE must be set to provide SENDKEY2, used by SetRegion()...
		// if GENERIC_WRITE cannot be set cause there are insufficent rights,
		// SetRegion() will lead into an error
		hDevice = ::CreateFile("cdrom0:", GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING, NULL);

		if (hDevice == INVALID_HANDLE_VALUE)
			{
			DP(__TEXT("Could not get device, error %x"), GetLastError());
			this->hDevice = NULL;
			GNRAISE(GNR_NO_DVD_DRIVE);
			}
		}

	GNRAISE_OK;
	}


//
//	test if DVD is entrypted
//

Error XBOXDVDDrive::DVDIsEncrypted(BOOL & isEncrypted)
	{
	VDAutoMutex autoMutex(&monitorMutex);

	if (encryptionInfoValid)
		{
		isEncrypted = encryptionInfo;
		GNRAISE_OK;
		}

	Error err = GNR_OK;
	DWORD structSize = 0;

	DVD_READ_STRUCTURE readStruct = {0};
	BYTE * pCprStruct = NULL;

	if (!IS_ERROR(err))
		{
		err = this->GetDevice();
		}


	// get memory for copy protection descriptor
	if (!IS_ERROR(err))
		{
		structSize = sizeof(DVD_COPYRIGHT_DESCRIPTOR) + sizeof(DVD_DESCRIPTOR_HEADER);
		pCprStruct = new BYTE [structSize];
		if (!pCprStruct)
			err = GNR_NOT_ENOUGH_MEMORY;
		}

	// read copy protection descriptor
	if (!IS_ERROR(err))
		{
		readStruct.Format = DvdCopyrightDescriptor;

		DWORD returned = 0;
		BOOL fResult = DeviceIoControl( hDevice, IOCTL_DVD_READ_STRUCTURE, &readStruct, sizeof(readStruct),
											pCprStruct, structSize, &returned, NULL);
		if (fResult == 0x00)
			{
			DP(__TEXT("Error - IsEncrypted: %x"), GetLastError());
			err = GNR_READ_ERROR;
			}
		}


	// get information out of read struct
	if (!IS_ERROR(err))
		{
		DVD_COPYRIGHT_DESCRIPTOR * pCprDescr = (DVD_COPYRIGHT_DESCRIPTOR *) &(pCprStruct[sizeof(DVD_DESCRIPTOR_HEADER)]);

		encryptionInfo = isEncrypted = (pCprDescr->CopyrightProtectionType != 0);
		encryptionInfoValid = true;
		}

	// garbate collection
	if (pCprStruct)
		delete[] pCprStruct;

	// return result
	return err;
	}


//
//	Get copy management information
//

Error XBOXDVDDrive::GetCopyManagementInfo(DWORD block, GenericCopyManagementInfo & gcmi)
	{
	VDAutoMutex autoMutex(&monitorMutex);

	BOOL fResult;
	DWORD returned = 0;

	Error err = GNR_OK;

	if (!IS_ERROR(err))
		{
		err = this->GetDevice();
		}

	// try DVD Read Structure
	if (!IS_ERROR(err))
		{
		DVD_READ_STRUCTURE readStruct = {0};
		DVD_COPYRIGHT_DESCRIPTOR cprDescr = {0};

		readStruct.Format = DvdCopyrightDescriptor;

		fResult = DeviceIoControl( hDevice, IOCTL_DVD_READ_STRUCTURE, &readStruct, sizeof(readStruct),
											&cprDescr, sizeof(cprDescr), &returned, NULL);
		if (fResult == 0x00)
			{
			err = GNR_NO_DVD_DRIVE;
			DP(__TEXT("Error - IsDVDDrive : %x"), GetLastError());
			}
		else
			{
			switch (cprDescr.CopyrightProtectionType)
				{
				case 0x00 :
					gcmi = GCMI_NO_RESTRICTION;
					break;
				case 0x02 :
					gcmi = GCMI_ONE_GENERATION;
					break;
				case 0x03 :
					gcmi = GCMI_COPY_FORBIDDEN;
					break;
				default:
					gcmi = GCMI_COPY_FORBIDDEN;
					break;
				}
			}
		}

	return GNR_OK;
	}


//
//  Lock tray
//

Error XBOXDVDDrive::LockTray(void)
	{
	GNRAISE_OK;

	VDAutoMutex autoMutex(&monitorMutex);

	Error err = GNR_OK;

	if (!IS_ERROR(err))
		{
		err = this->GetDevice();
		}

	if (!IS_ERROR(err))
		{

		lockCount++;
		if (lockCount == 1)
			{
			BOOL lock = true;
			DWORD returned = 0;

			BOOL fResult = DeviceIoControl( hDevice, IOCTL_STORAGE_MEDIA_REMOVAL, &lock, sizeof(lock),
											NULL, 0, &returned, NULL);

			if (fResult == 0x00)
				{
				DP(__TEXT("Error - Lock: %x"), GetLastError());
				err = GNR_WRITE_ERROR;
				}
			}
		}

	return err;
	}

//
//  Unlock tray
//

Error XBOXDVDDrive::UnlockTray(void)
	{
	GNRAISE_OK;

	VDAutoMutex autoMutex(&monitorMutex);

	Error err = GNR_OK;

	// get device
	if (!IS_ERROR(err))
		{
		err = this->GetDevice();
		}

	// lock drive...
	if (!IS_ERROR(err))
		{
		lockCount--;
		if (lockCount == 0)
			{

			BOOL lock = false;
			DWORD returned = 0;

			BOOL fResult = DeviceIoControl( hDevice, IOCTL_STORAGE_MEDIA_REMOVAL, &lock, sizeof(lock),
											NULL, 0, &returned, NULL);

			if (fResult == 0x00)
				{
				DP(__TEXT("Error - Unlock: %x"), GetLastError());
				err = GNR_WRITE_ERROR;
				}
			}
		}

	return err;
	}


//
//  Get tray status
//

Error XBOXDVDDrive::GetTrayStatus(GenericTrayStatus & status)
	{
	status = GTS_TRAY_UNKNOWN;

	GNRAISE_OK;
	}


//
//  Get volume ID
//

Error XBOXDVDDrive::GetVolumeID(VolumeID & volumeID)
	{
	volumeID = 0;
	GNRAISE_OK;
	}

//
//  Load media
//

Error XBOXDVDDrive::LoadMedia(int slotNumber, DWORD flags)
	{
	VDAutoMutex autoMutex(&monitorMutex);

	Error err = GNR_OK;

	// get device handle to drive
	if (!IS_ERROR(err))
		{
		err = this->GetDevice();
		}

	// do ioctl to load media into drive
	if (!IS_ERROR(err))
		{
		DWORD returned = 0;
		BOOL fResult = DeviceIoControl( hDevice, IOCTL_STORAGE_LOAD_MEDIA, NULL, 0,
											NULL, 0, &returned, NULL);
		if (fResult == 0x00)
			{
			DP(__TEXT("Error - LoadMedia: %x"), GetLastError());
			err = GNR_WRITE_ERROR;
			}

		}

	return err;
	}


//
//  Unload media
//

Error XBOXDVDDrive::UnloadMedia(DWORD flags)
	{
	VDAutoMutex autoMutex(&monitorMutex);

	Error err =	GNR_OK;

	if (!IS_ERROR(err))
		{
		err = this->GetDevice();
		}


	if (!IS_ERROR(err))
		{
		if (lockCount != 0)
			DP(__TEXT("Media Removed but should be locked"));

		DWORD returned = 0;
		BOOL fResult = DeviceIoControl( hDevice, IOCTL_STORAGE_EJECT_MEDIA, NULL, 0,
										NULL, 0, &returned, NULL);

		if (fResult == 0x00)
			{
			DP(__TEXT("Error - UnloadMedia: %x"), GetLastError());
			err = GNR_WRITE_ERROR;
			}
		}


	return err;
	}

//
//  Start authentification
//

Error XBOXDVDDrive::StartAuthentication()
	{
	VDAutoMutex autoMutex(&monitorMutex);

	Error err = GNR_OK;

	if (!IS_ERROR(err))
		err = this->GetDevice();

	if (!IS_ERROR(err))
		{
		DWORD returned = 0;

		BOOL fResult = DeviceIoControl( hDevice, IOCTL_DVD_START_SESSION, NULL, 0,
													&this->sessionId, sizeof(this->sessionId), &returned, NULL);

		if (fResult == 0x00)
			{
			DP(__TEXT("Error - StartAuthentication: %x"), GetLastError());
			this->sessionId = 0;
			err = GNR_WRITE_ERROR;
			}
		}


	return err;
	}

//
//  Complete authentication
//

Error XBOXDVDDrive::CompleteAuthentication()
	{
	// for unmarked encrypted discs
	encryptionInfo = encryptionInfoValid = true;
	GNRAISE_OK;
	}

//
//  Cancel authentication
//

Error XBOXDVDDrive::CancelAuthentication()
	{
	VDAutoMutex autoMutex(&monitorMutex);

	Error err = GNR_OK;

	if (!IS_ERROR(err))
		{
		err = this->GetDevice();
		}

	if (!IS_ERROR(err))
		{
		DWORD returned = 0;
		BOOL fResult = DeviceIoControl( hDevice, IOCTL_DVD_END_SESSION, &this->sessionId, sizeof(this->sessionId),
										NULL, 0, &returned, NULL);

		if (fResult == 0x00)
			{
			DP(__TEXT("Error - CancelAutentication: %x"), GetLastError());
			err = GNR_WRITE_ERROR;
			}
		}

	return err;
	}


//
//  Get bus key
//

Error XBOXDVDDrive::GetBusKey(BYTE * key)
	{
	VDAutoMutex autoMutex(&monitorMutex);

	BYTE* pKeyData = NULL;
	PDVD_COPY_PROTECT_KEY pKey = NULL;

	Error err = GNR_OK;

	if (!IS_ERROR(err))
		{
		err = this->GetDevice();
		}

	if (!IS_ERROR(err))
		{
		pKeyData = new BYTE [DVD_BUS_KEY_LENGTH];
		if (!pKeyData)
			err = GNR_NOT_ENOUGH_MEMORY;
		}

	if (!IS_ERROR(err))
		{
		ZeroMemory(pKeyData, DVD_BUS_KEY_LENGTH);

		pKey = (PDVD_COPY_PROTECT_KEY) pKeyData;
		pKey->KeyLength = DVD_BUS_KEY_LENGTH;
		pKey->SessionId = this->sessionId;
		pKey->KeyType  = DvdBusKey1;

		DWORD returned = 0;

		BOOL fResult = DeviceIoControl( hDevice, IOCTL_DVD_READ_KEY, pKeyData, DVD_BUS_KEY_LENGTH,
											pKeyData, DVD_BUS_KEY_LENGTH, &returned, NULL);

		if (fResult == 0x00)
			{
			DP(__TEXT("Error - GetBusKey: %x"), GetLastError());
			err = GNR_READ_ERROR;
			}
		}

	if (!IS_ERROR(err))
		{
		for (int i=0; i<6; i++)
			key[i] = pKey->KeyData[i];
		}

	if (pKeyData)
		delete pKeyData;

	return err;
	}


//
//  Get challenge key
//

Error XBOXDVDDrive::GetChallengeKey(BYTE * key)
	{
	VDAutoMutex autoMutex(&monitorMutex);

	BYTE* pKeyData = NULL;
	PDVD_COPY_PROTECT_KEY pKey = NULL;

	Error err = GNR_OK;



	// get device parameter
	if (!IS_ERROR(err))
		{
		err = this->GetDevice();
		}

	// get memory for key
	if (!IS_ERROR(err))
		{
		pKeyData = new BYTE [DVD_CHALLENGE_KEY_LENGTH];
		if (!pKeyData)
			err = GNR_NOT_ENOUGH_MEMORY;
		}

	// read challenge key...
	if (!IS_ERROR(err))
		{
		ZeroMemory(pKeyData, DVD_CHALLENGE_KEY_LENGTH);

		pKey = (PDVD_COPY_PROTECT_KEY) pKeyData;
		pKey->KeyLength = DVD_CHALLENGE_KEY_LENGTH;
		pKey->SessionId = this->sessionId;
		pKey->KeyType  = DvdChallengeKey;

		DWORD returned = 0;
		BOOL fResult = DeviceIoControl( hDevice, IOCTL_DVD_READ_KEY, pKeyData, DVD_CHALLENGE_KEY_LENGTH,
											pKeyData, DVD_CHALLENGE_KEY_LENGTH, &returned, NULL);

		if (fResult == 0x00)
			{
			DP(__TEXT("Error - GetChallengeKey: %x"), GetLastError());
			err = GNR_READ_ERROR;
			}
		}

	// copy key content to result variable
	if (!IS_ERROR(err))
		{
		for (int i=0; i<10; i++)
			key[i] = pKey->KeyData[i];
		}

	// garbage collection
	if (pKeyData)
		delete pKeyData;


	return err;
	}

//
//  Get disk key
//

Error XBOXDVDDrive::GetDiskKey(BYTE * key)
	{
	VDAutoMutex autoMutex(&monitorMutex);

	DVD_READ_STRUCTURE	readStruct = {0};
	DVD_DISK_KEY_DESCRIPTOR		keyData = {0};

	Error err = GNR_OK;

	if (!IS_ERROR(err))
		{
		err = this->GetDevice();
		}

	if (!IS_ERROR(err))
		{
		readStruct.Format = DvdDiskKeyDescriptor;
		readStruct.SessionId = sessionId;

		for (int i=0; i<2048; i++)
			keyData.DiskKeyData[i] = 0xbd;

		DWORD returned = 0;
		BOOL fResult = DeviceIoControl( hDevice, IOCTL_DVD_READ_STRUCTURE, &readStruct, sizeof(readStruct),
											&keyData, sizeof(keyData), &returned, NULL);


		if (fResult == 0x00)
			{
			DP(__TEXT("Error - GetDiskKey: %x"), GetLastError());
			err = GNR_READ_ERROR;
			}
		}

	// copy key content to return variable
	if (!IS_ERROR(err))
		{
		for (int i=0; i<2048; i++)
			key[i] = keyData.DiskKeyData[i+4];
		}


	return err;

	}

//
//  Get title key
//

Error XBOXDVDDrive::GetTitleKey(DWORD block, BYTE * key)
	{
	VDAutoMutex autoMutex(&monitorMutex);

	Error err = GNR_OK;
	BYTE* pKeyData = NULL;
	PDVD_COPY_PROTECT_KEY pKey = NULL;

	if (!IS_ERROR(err))
		{
		err = this->GetDevice();
		}

	// get memory for key data
	if (!IS_ERROR(err))
		{
		pKeyData = new BYTE [DVD_TITLE_KEY_LENGTH];
		if (!pKeyData)
			err = GNR_NOT_ENOUGH_MEMORY;
		}


	// read title key from drive
	if (!IS_ERROR(err))
		{
		ZeroMemory(pKeyData, DVD_TITLE_KEY_LENGTH);

		pKey = (PDVD_COPY_PROTECT_KEY) pKeyData;
		pKey->KeyLength = DVD_TITLE_KEY_LENGTH;
		pKey->SessionId = this->sessionId;
		pKey->KeyType  = DvdTitleKey;
		pKey->Parameters.TitleOffset.QuadPart = (__int64)block * 2048;

		DWORD returned  = 0;
		BOOL fResult = DeviceIoControl( hDevice, IOCTL_DVD_READ_KEY, pKeyData, DVD_TITLE_KEY_LENGTH,
											pKeyData, DVD_TITLE_KEY_LENGTH, &returned, NULL);

		if (fResult == 0x00)
			{
			DP(__TEXT("Error - GetTitleKey: %x"), GetLastError());
			err = GNR_READ_ERROR;
			}
		}


	// copy key content
	if (!IS_ERROR(err))
		{
		key[0] = 0xF0;
		for (int i=0; i<5; i++)
			key[i+1] = pKey->KeyData[i];
		key[6] = 0;
		key[7] = 0;
		}

	// garbage collection
	if (pKeyData)
		delete pKeyData;

	return err;
	}



//
// Key Handling
// Send Keys
//


//
// Send Challenge Key
//
Error XBOXDVDDrive::SendChallengeKey(BYTE __far * key)
	{
	VDAutoMutex autoMutex(&monitorMutex);

	BYTE* pKeyData = NULL;

	Error err = GNR_OK;

	if (!IS_ERROR(err))
		{
		err = this->GetDevice();
		}

	if (!IS_ERROR(err))
		{
		pKeyData = new BYTE [DVD_CHALLENGE_KEY_LENGTH];
		if (!pKeyData)
			err = GNR_NOT_ENOUGH_MEMORY;
		}

	if (!IS_ERROR(err))
		{
		ZeroMemory(pKeyData, DVD_CHALLENGE_KEY_LENGTH);

		PDVD_COPY_PROTECT_KEY pKey = (PDVD_COPY_PROTECT_KEY) pKeyData;
		// pKey->Parameters.FileHandle = (ULONG) hDevice;
		pKey->KeyLength = DVD_CHALLENGE_KEY_LENGTH;
		pKey->SessionId = this->sessionId;
		pKey->KeyType = DvdChallengeKey;

		// copy key to write struct
		for (int i=0; i<10; i++)
			pKey->KeyData[i] = key[i];
		pKey->KeyData[10] = pKey->KeyData[11] = 0;

		DWORD returned = 0;
		BOOL fResult = DeviceIoControl( hDevice, IOCTL_DVD_SEND_KEY, pKeyData, DVD_CHALLENGE_KEY_LENGTH,
											NULL, 0 , &returned, NULL);

		if (fResult == 0x00)
			{
			DP(__TEXT("Error - SendChalllengeKey: %x"), GetLastError());
			err = GNR_WRITE_ERROR;
			}
		}

	if (pKeyData)
		delete[] pKeyData;

	return err;
	}


//
// Send bus key
//

Error XBOXDVDDrive::SendBusKey(BYTE __far * key)
	{
	VDAutoMutex autoMutex(&monitorMutex);

	BYTE* pKeyData = NULL;

	Error err = GNR_OK;

	if (!IS_ERROR(err))
		err = this->GetDevice();

	if (!IS_ERROR(err))
		{
		pKeyData = new BYTE [DVD_BUS_KEY_LENGTH];
		if (!pKeyData)
			err = GNR_NOT_ENOUGH_MEMORY;
		}

	if (!IS_ERROR(err))
		{

		ZeroMemory(pKeyData, DVD_BUS_KEY_LENGTH);

		PDVD_COPY_PROTECT_KEY pKey = (PDVD_COPY_PROTECT_KEY) pKeyData;
		pKey->KeyLength = DVD_BUS_KEY_LENGTH;
		pKey->SessionId = this->sessionId;
		pKey->KeyType  = DvdBusKey2;

		// copy key content
		for (int i=0; i<6; i++)
			pKey->KeyData[i] = key[i];
		pKey->KeyData[6] = pKey->KeyData[7] = 0;

		DWORD returned = 0;
		BOOL fResult = DeviceIoControl( hDevice, IOCTL_DVD_SEND_KEY, pKeyData, DVD_BUS_KEY_LENGTH,
											pKeyData, DVD_BUS_KEY_LENGTH, &returned, NULL);

		if (fResult == 0x00)
			{
			DP(__TEXT("Error - SendBusKey : %x"), GetLastError());
			err = GNR_WRITE_ERROR;
			}
		}

	if (pKeyData)
		delete[] pKeyData;

	return err;
	}






//
// RPC2 Support
//

Error XBOXDVDDrive::GetRPCData(BOOL __far &isRPC2, BYTE __far &regionCode, BYTE __far &availResets)
	{
	availResets = 10;
	isRPC2 = false;
	regionCode = 0;

	GNRAISE_OK;

	VDAutoMutex autoMutex(&monitorMutex);

	BYTE* pKeyData = NULL;
	PDVD_COPY_PROTECT_KEY pKey = NULL;

	Error err = GNR_OK;

	if (!IS_ERROR(err))
		{
		err = this->GetDevice();
		}

	if (!IS_ERROR(err))
		{
		pKeyData = new BYTE [DVD_RPC_KEY_LENGTH];
		if (!pKeyData)
			err = GNR_NOT_ENOUGH_MEMORY;
		}

	if (!IS_ERROR(err))
		{
		ZeroMemory(pKeyData, DVD_RPC_KEY_LENGTH);

		pKey = (PDVD_COPY_PROTECT_KEY) pKeyData;
		pKey->KeyLength = DVD_RPC_KEY_LENGTH;
		pKey->SessionId = this->sessionId;
		pKey->KeyType  = DvdGetRpcKey;

		DWORD returned = 0;
		BOOL fResult = DeviceIoControl( hDevice, IOCTL_DVD_READ_KEY, pKeyData, DVD_RPC_KEY_LENGTH,
											pKeyData, DVD_RPC_KEY_LENGTH, &returned, NULL);

		if (fResult == 0x00)
			{
			DP(__TEXT("Error - GetRpcData: %x"), GetLastError());
			err = GNR_READ_ERROR;
			}
		}

	if (!IS_ERROR(err))
		{
		availResets = pKey->KeyData[0] & 0x07;
		regionCode = pKey->KeyData[1];
  		isRPC2 = (pKey->KeyData[2] != 0x00);
		}

	if (pKeyData)
		delete[] pKeyData;

	return err;
	}


// Set Region will only work if drive is open with right access.
// If the calling thread had not the access rights to open the drive with write
// access, SetRegion will lead into an error code (GNR_WRITE_ERROR)

Error XBOXDVDDrive::SetRegionCode(BYTE regionCode)
	{
	VDAutoMutex autoMutex(&monitorMutex);

	BYTE* pKeyData = NULL;

	Error err = GNR_OK;

	// get drive
	if (!IS_ERROR(err))
		{
		err = this->GetDevice();
		}

	// get memory for key
	if (!IS_ERROR(err))
		{
		pKeyData = new BYTE [DVD_SET_RPC_KEY_LENGTH];
		if (!pKeyData)
			err = GNR_NOT_ENOUGH_MEMORY;
		}

	// Write key
	if (!IS_ERROR(err))
		{
		ZeroMemory(pKeyData, DVD_SET_RPC_KEY_LENGTH);

		PDVD_COPY_PROTECT_KEY pKey = (PDVD_COPY_PROTECT_KEY) pKeyData;
		pKey->KeyLength = DVD_SET_RPC_KEY_LENGTH;
		pKey->SessionId = this->sessionId;
		pKey->KeyType = DvdSetRpcKey;

		DVD_SET_RPC_KEY rpcKeyData = {0};
		rpcKeyData.PreferredDriveRegionCode = regionCode;
		rpcKeyData.Reserved[0] = 0;
		rpcKeyData.Reserved[1] = 0;
		rpcKeyData.Reserved[2] = 0;

		// copy key content
		for (int i=0; i<sizeof(DVD_SET_RPC_KEY); i++)
			pKey->KeyData[i] = ((BYTE*) (&rpcKeyData))[i];

		DWORD returned = 0;
		BOOL fResult = DeviceIoControl( hDevice, IOCTL_DVD_SEND_KEY2, pKeyData, DVD_SET_RPC_KEY_LENGTH,
											pKeyData, DVD_SET_RPC_KEY_LENGTH , &returned, NULL);

		if (fResult == 0x00)
			{
			DP(__TEXT("Error - Set RPC Key failed due to : %x"), GetLastError());
			err = GNR_WRITE_ERROR;
			}
		}

	// do some garbage collection
	if (pKeyData)
		delete[] pKeyData;

	GNRAISE_OK;
	}



//
// Audio CD handling...
//


// Read Audio CD Subchannel...

Error XBOXDVDDrive::ReadCDASubchannel(void __far * subchannel)
	{
	Error err = GNR_OK;

	if (subchannel == NULL)
		GNRAISE_OK;

	VDAutoMutex autoMutex(&monitorMutex);

	if (IS_ERROR(err = this->GetDevice()))
		GNRAISE(err);

	BOOL fResult = 0;
	DWORD returned = 0;

	CDROM_SUB_Q_DATA_FORMAT subQReqStruct = {0};
	subQReqStruct.Format = IOCTL_CDROM_CURRENT_POSITION;
	subQReqStruct.Track = 0;

	SUB_Q_CURRENT_POSITION subQCurrPos = {0};

	fResult = DeviceIoControl( hDevice, IOCTL_CDROM_READ_Q_CHANNEL, &subQReqStruct, sizeof(subQReqStruct),
										&subQCurrPos, sizeof(subQCurrPos), &returned, NULL);

	if (fResult == 0x00)
		{
		DP(__TEXT("Error - ReadCDABlock : %x"), GetLastError());
		GNRAISE(GetLastError());
		}
	else
		{
		// write subchannel.
		// since we only get Q-Channel, white out the other channels (12 Bytes P-Channel, 12 Bytes Q-Channel,...)
		BYTE* pSub = (BYTE*)subchannel;
		for (int i=0; i<12; i++)
			{
			*pSub = 0;
			pSub++;
			}


		*pSub = 0; pSub++;
		*pSub = 0; pSub++;
		*pSub = (subQCurrPos.Control << 4) | (subQCurrPos.ADR); pSub++;
		*pSub = (subQCurrPos.TrackNumber); pSub++;
		*pSub = (subQCurrPos.IndexNumber); pSub++;
		i += 5;
		BYTE * pQChan = (BYTE*)(&subQCurrPos);
		for (;i<24;i++)
			{
			*pSub = *pQChan;
			pSub++;
			pQChan++;
			}

		for (;i<CDDA_SUBCHANNEL_SIZE;i++)
			{
			*pSub = 0;
			pSub++;
			}

		}
	GNRAISE_OK;

	}


// Read blocks from Audio CD


Error XBOXDVDDrive::ReadCDBlocks(DWORD block, DWORD num, BYTE * buffer, DWORD flags)
	{
	VDAutoMutex autoMutex(&monitorMutex);

	Error err = GNR_OK;
	RAW_READ_INFO rrInfo;

	// get device
	if (!IS_ERROR(err))
		{
		err = this->GetDevice();
		}

	// blockDiff = 150;
	if (!IS_ERROR(err))
		{
		switch (GD_SECTOR_TYPE(flags))
			{
			case DST_CDDA :
			case DST_CDROM_MODE2_XA_FORM2 :
			case DST_CDROM_MODE2 :
				{
				ZeroMemory(&rrInfo, sizeof(rrInfo));
				rrInfo.DiskOffset.QuadPart = (block - blockDiff)*2048;
				rrInfo.SectorCount = num;


				switch (GD_SECTOR_TYPE(flags))
					{
					case DST_CDDA : rrInfo.TrackMode = CDDA; break;
					case DST_CDROM_MODE2 : rrInfo.TrackMode = YellowMode2; break;
					case DST_CDROM_MODE2_XA_FORM2 : rrInfo.TrackMode = XAForm2; break;
					default : err = GNR_INVALID_PARAMETERS;
					}

				// read blocks
				if (!IS_ERROR(err))
					{
					// data size. See remarks at rrInfo.Diskoffset...
					DWORD dataSize = num * CD_FRAME_SIZE;

					DWORD returned = 0;
					BOOL fResult = DeviceIoControl(	hDevice, IOCTL_CDROM_RAW_READ, &rrInfo, sizeof(rrInfo),
																buffer, dataSize , &returned, NULL);

					if (fResult == 0x00)
						{
						DP(__TEXT("Error - ReadCDABlock : %x"), GetLastError());
						err = GNR_READ_ERROR;
						}
					}
				break;
				}
			case DST_CDROM_MODE1:
			case DST_CDROM_MODE2_XA_FORM1:
				{
				DWORD dstBlock = block - blockDiff;
				long highPart = dstBlock >> 21;

				DWORD dwPointer = ::SetFilePointer (this->hDevice, dstBlock << 11, &highPart, FILE_BEGIN);

				if (dwPointer != 0xffffffff || (dwPointer == 0xffffffff && GetLastError() == NO_ERROR))
					{
					DWORD bytesRead = 0;
					BOOL fResult = ::ReadFile(hDevice, buffer, num << 11, &bytesRead, NULL);

					if (fResult == 0x00)
						DP(__TEXT("Error in ReadBlocks, cause %d"), GetLastError());
					}

				// format data in right format
				if (GD_SECTOR_TYPE(flags) == DST_CDROM_MODE2_XA_FORM1)
					{
					for (int i = num-1; i >= 0; i--)
						{
						for (int j = 2047; j >= 0; j--)
							buffer[i*CD_FRAME_SIZE+0x18 + j] = buffer[i*2048+j];
						}
					}
				break;
				}
			}
		}


	// read subchannel
	if (!IS_ERROR(err) && (flags & DAF_READ_SUBCHANNEL))
		{
		BYTE * buf = (BYTE*) buffer;
		buf += CD_FRAME_SIZE;
		err = ReadCDASubchannel(buf);
		}

	return err;
	}



//
// Read Audio CD Directory
// session number must be 1 or 2 (only for mutisession disk)
// if there are more than 2 real session, 2 sessions are faked the following way: sessions 1..n-1 is the first session,
// the last session is given as the secound session.
// See also GetNumberOfSessions(..)
// Toc array starts at index 0 (formally 1)
//

#define CDA_AUDIO_BLOCK_SIZE	2352
#define CDA_TOC_BUFFER_SIZE  CDA_AUDIO_BLOCK_SIZE+1000


Error XBOXDVDDrive::ReadCDTOC(WORD session, CDSessionType & sessionType, CDTocEntry * & toc, WORD & entryNum, RequestHandle * rh)
	{
	VDAutoMutex autoMutex(&monitorMutex);

	CDROM_TOC cdToc = {0};
	SessionInfo sessionInfo = {0};

	Error err = GNR_OK;

	// get number of sessions in drive
	if (!IS_ERROR(err))
		{
		DWORD returned = 0;
		BOOL fResult = ::DeviceIoControl(this->hDevice, IOCTL_CDROM_GET_LAST_SESSION, NULL, NULL, &sessionInfo, sizeof(sessionInfo), &returned, NULL);
		if (fResult == 0x00)
			{
			DP(__TEXT("Error in ReadCDToc, GetLastSession returned %x"), GetLastError());
			err = GNR_READ_ERROR;
			}
		}

	// compare to test parameters
	if (!IS_ERROR(err))
		{
		if (session > 2)
			err = GNR_INVALID_PARAMETERS;
		if ((sessionInfo.firstSession == sessionInfo.lastSession) && (session == 2))
			err = GNR_INVALID_PARAMETERS;
		}

	// get drive device
	if (!IS_ERROR(err))
		err = this->GetDevice();


	// read complete toc
	if (!IS_ERROR(err))
		{

		DWORD returned = 0;
		BOOL fResult = DeviceIoControl( hDevice, IOCTL_CDROM_READ_TOC, &cdToc, sizeof(cdToc),
											&cdToc, sizeof(cdToc) , &returned, NULL);

		if (fResult == 0x00)
			{
			DP(__TEXT("Error - ReadCDAToc : %x"), GetLastError());
			err = GNR_READ_ERROR;
			}
		}

	// convert toc
	if (!IS_ERROR(err))
		{
		// calculate number of toc entries
		DWORD tocLength = cdToc.LastTrack - cdToc.FirstTrack + 1;
		DWORD firstTrackOfSession = 0;
		DWORD lastTrackOfSession = 0;

		// set first toc entry for session.
		if (sessionInfo.firstSession == sessionInfo.lastSession)
			{
			// single session...
			firstTrackOfSession = 0;
			lastTrackOfSession = tocLength-1;
			}
		else
			{
			// Multisession
			if (session == 2)
				{
				// Multisession, secound session toc
				firstTrackOfSession = sessionInfo.firstTrackLastSession-1;
				lastTrackOfSession = tocLength-1;
				}
			else
				{
				// Multisession, first session toc
				firstTrackOfSession = 0;
				lastTrackOfSession = sessionInfo.firstTrackLastSession-2;
				}
			}

		entryNum = (WORD) (lastTrackOfSession - firstTrackOfSession +1);

		if (entryNum != 0)
			{
			toc = new CDTocEntry[entryNum];
			if  (!toc)
				err = GNR_NOT_ENOUGH_MEMORY;

			if (!IS_ERROR(err))
				{
				for (DWORD i = firstTrackOfSession; i<lastTrackOfSession+1; i++)
					{
					CDTocEntry dummyEntry;

					DWORD dstPos = i - firstTrackOfSession;

					// set track begginging and length...

					toc[dstPos].SetStartBlock(cdToc.TrackData[i].Address[1], cdToc.TrackData[i].Address[2], cdToc.TrackData[i].Address[3]);
					if (dstPos == 0)
						blockDiff = toc[dstPos].GetStartBlock();
					dummyEntry.SetStartBlock(cdToc.TrackData[i+1].Address[1], cdToc.TrackData[i+1].Address[2], cdToc.TrackData[i+1].Address[3]);
					toc[dstPos].SetNumberOfBlocks(dummyEntry.GetStartBlock() -  toc[i - firstTrackOfSession].GetStartBlock());

					// get track type
					CDTrackType trackType = CTT_NONE;
					if ((cdToc.TrackData[i].Control & 0x0c) != 0x04)
						trackType = CTT_AUDIO;
					else
						trackType = CTT_DATA;
					toc[dstPos].SetTrackType(trackType);

					DP("track added");
					}
				}
			}
		else
			{
			//  tocEntryNum == 0
			err = GNR_OBJECT_INVALID;
			}
		}

	// find out which type of sector
	PhysicalDiskType diskType = PHDT_NONE;
	if (!IS_ERROR(err))
		{
		err = this->GetCDType(diskType);
		}
	if (!IS_ERROR(err))
		{
		switch (diskType)
			{
			case PHDT_CDROM :
			case PHDT_CDDA : sessionType = CST_CDDA; break;

			case PHDT_CDI : sessionType = CST_CDI; break;
			case PHDT_CDROM_XA : sessionType = CST_CDROM_XA; break;

			case PHDT_NONE : sessionType = CST_NONE; break;
			}
		}


	// return result
	return err;
	}



//
// Read / Write commands
//


//
// Read Block(s) from DVD
//

#include "library\lowlevel\timer.h"

#define IOCTL_CDROM_SET_SPINDLE_SPEED CTL_CODE(IOCTL_CDROM_BASE, 0x0021, METHOD_BUFFERED, FILE_READ_ACCESS)


Error XBOXDVDDrive::ReadDVDBlocks(DWORD block, DWORD num, BYTE * buffer, DWORD flags)
	{
	// no lock while called from LockBlocks, although double blocking will make no problem...
	// VDAutoMutex autoMutex(&mutex);

	Error err = GNR_OK;
	DWORD res;
	bool retry;
	SCSI_PASS_THROUGH_DIRECT PassThrough;
	BOOL fSuccess;
	DWORD cbReturned;
	BYTE	senseBuffer[32];
	int	retryCount;

	if (!IS_ERROR(err))
		{
		err = this->GetDevice();
		}

	if (block == singleBlockCacheBlock)
		{
		memcpy(buffer, singleBlockCacheBuffer, 2048);
		block++;
		num--;
		buffer += 2048;
		}

	//
	// Retry navigation sectors
	//
	if (streamingMode == SMD_NAVIGATING)
		retryCount = 3;
	else
		retryCount = 1;

	if (num && !IS_ERROR(err))
		{
		ZeroMemory(&PassThrough, sizeof(PassThrough));
		PassThrough.Length = sizeof(SCSI_PASS_THROUGH_DIRECT);

		PassThrough.DataBuffer = buffer;
		PassThrough.DataTransferLength = num << 11;

		PassThrough.DataIn = SCSI_IOCTL_DATA_IN;
		PassThrough.Cdb[ 0] = 0x28;
		PassThrough.Cdb[ 1] = 0x00;
		PassThrough.Cdb[ 2] = (BYTE)(block >> 24) & 0xff;
		PassThrough.Cdb[ 3] = (BYTE)(block >> 16) & 0xff;
		PassThrough.Cdb[ 4] = (BYTE)(block >>  8) & 0xff;
		PassThrough.Cdb[ 5] = (BYTE)(block      ) & 0xff;
		PassThrough.Cdb[ 6] = 0x00;
		PassThrough.Cdb[ 7] = (BYTE)(num   >>  8) & 0xff;
		PassThrough.Cdb[ 8] = (BYTE)(num        ) & 0xff;
		PassThrough.Cdb[ 9] = 0x00;
		PassThrough.Cdb[10] = 0x00;
		PassThrough.Cdb[11] = 0x00;

		do {
			senseBuffer[0] = 0;
			retry = false;

			fSuccess = DeviceIoControl(hDevice, IOCTL_SCSI_PASS_THROUGH_DIRECT, &PassThrough, sizeof(SCSI_PASS_THROUGH_DIRECT), senseBuffer, 32, &cbReturned, NULL);
			if (!fSuccess)
				{
				DWORD res = GetLastError();

				if (res == 23 || res == 121)
					err = GNR_FILE_READ_ERROR;
				else
					err = GNR_END_OF_FILE;

				DP("Read error at %08lx of %d sectors %d", block, num, res);
				successfulReadSectors = 0;
				}
			else if (senseBuffer[0])
				{
				err = GNR_FILE_READ_ERROR;

				DP("Read error at %08lx of %d sectors %02x %02x %02x %02x - %02x %02x %02x %02x - %02x %02x %02x %02x %02x %02x",  block, num,
					senseBuffer[0], senseBuffer[1], senseBuffer[2], senseBuffer[3],
					senseBuffer[4], senseBuffer[5], senseBuffer[6], senseBuffer[7],
					senseBuffer[8], senseBuffer[9], senseBuffer[10], senseBuffer[11],
					senseBuffer[12], senseBuffer[13]);

				successfulReadSectors = 0;
				}
			else
				{
				successfulReadSectors += num;
				if (spindleSpeed < 2 && successfulReadSectors >= 10000)
					{
					spindleSpeed++;
					fSuccess = DeviceIoControl(hDevice, IOCTL_CDROM_SET_SPINDLE_SPEED, &spindleSpeed, sizeof(spindleSpeed), NULL, 0, &cbReturned, NULL);
					DP("Speed change to %d returned %d", spindleSpeed, fSuccess);
					successfulReadSectors = 0;
					}

				if (num == 1)
					{
					singleBlockCacheBlock = block;
					memcpy(singleBlockCacheBuffer, buffer, 2048);
					}

				err = GNR_OK;
				}

			//
			// Retry based on counter
			//
			if (err != GNR_OK && !retry && retryCount)
				{
				DP("Retrying due to retry counter %d", retryCount);

				if (spindleSpeed > 1)
					{
					spindleSpeed--;

					fSuccess = DeviceIoControl(hDevice, IOCTL_CDROM_SET_SPINDLE_SPEED, &spindleSpeed, sizeof(spindleSpeed), NULL, 0, &cbReturned, NULL);

					DP("Speed change to %d returned %d", spindleSpeed, fSuccess);
					}

				retry = true;
				retryCount--;
				}

			} while (retry);
		}

    if(err != GNR_OK)
        DP("Read error failed after all with err=%d\n", err);

	GNRAISE(err);
	}


// Spin dows drive - not implemented but returns ok
Error XBOXDVDDrive::SpinDown()
	{
	// drive in PC should spin down automatically
	GNRAISE_OK;
	}

// Spin up drive - not implelemted but returns ok, cause this is no error
Error XBOXDVDDrive::SpinUp()
	{
	// drive in PC should be spinned up...
	GNRAISE_OK;
	}

// Seek Blocks - no functionallity at the moment...
Error XBOXDVDDrive::SeekBlock(DWORD block, DWORD flags, RequestHandle *rh)
	{
	GNRAISE_OK;
	}


Error XBOXDVDDrive::SetStreamingMode(bool streaming)
	{
	SCSI_PASS_THROUGH_DIRECT PassThrough;
	UCHAR ReadErrorRecoveryPage[20];
	BOOL success;
	Error err;
	BOOL fSuccess;
	DWORD cbReturned;

	err = this->GetDevice();

	// try DVD Read Structure
	if (!IS_ERROR(err))
		{
		if (streaming && streamingMode != SMD_STREAMING)
			{
			ZeroMemory(&PassThrough, sizeof(PassThrough));
			PassThrough.Length = sizeof(PassThrough);
			PassThrough.DataBuffer = &ReadErrorRecoveryPage;
			PassThrough.DataTransferLength = sizeof(ReadErrorRecoveryPage);

			PassThrough.DataIn = SCSI_IOCTL_DATA_IN;
			PassThrough.Cdb[ 0] = SFF_MODE_SENSE;
			PassThrough.Cdb[ 1] = 0x08;
			PassThrough.Cdb[ 2] = 0x01;
			PassThrough.Cdb[ 3] = 0x00;
			PassThrough.Cdb[ 4] = 0x00;
			PassThrough.Cdb[ 5] = 0x00;
			PassThrough.Cdb[ 6] = 0x00;
			PassThrough.Cdb[ 7] = 0x00;
			PassThrough.Cdb[ 8] = 0x14;
			PassThrough.Cdb[ 9] = 0x00;
			PassThrough.Cdb[10] = 0x00;
			PassThrough.Cdb[11] = 0x00;
			fSuccess = DeviceIoControl(hDevice, IOCTL_SCSI_PASS_THROUGH_DIRECT, &PassThrough, sizeof(PassThrough), NULL, 0, &cbReturned, NULL);


			if (fSuccess)
				{
				ReadErrorRecoveryPage[8 + 2] = 0x00;
				ReadErrorRecoveryPage[8 + 3] = 0x01;

				PassThrough.DataIn = SCSI_IOCTL_DATA_OUT;
				PassThrough.Cdb[ 0] = SFF_MODE_SELECT;
				PassThrough.Cdb[ 1] = 0x10;
				PassThrough.Cdb[ 2] = 0x01;
				PassThrough.Cdb[ 3] = 0x00;
				PassThrough.Cdb[ 4] = 0x00;
				PassThrough.Cdb[ 5] = 0x00;
				PassThrough.Cdb[ 6] = 0x00;
				PassThrough.Cdb[ 7] = 0x00;
				PassThrough.Cdb[ 8] = 0x14;
				PassThrough.Cdb[ 9] = 0x00;
				PassThrough.Cdb[10] = 0x00;
				PassThrough.Cdb[11] = 0x00;
 				fSuccess = DeviceIoControl(hDevice, IOCTL_SCSI_PASS_THROUGH_DIRECT, &PassThrough, sizeof(PassThrough), NULL, 0, &cbReturned, NULL);

				if (fSuccess)
					{
					streamingMode = SMD_STREAMING;
					}
				}

			GNRAISE_OK;
			}
		else if (!streaming && streamingMode != SMD_NAVIGATING)
			{
			ZeroMemory(&PassThrough, sizeof(PassThrough));
			PassThrough.Length = sizeof(PassThrough);
			PassThrough.DataBuffer = &ReadErrorRecoveryPage;
			PassThrough.DataTransferLength = sizeof(ReadErrorRecoveryPage);

			PassThrough.DataIn = SCSI_IOCTL_DATA_IN;
			PassThrough.Cdb[ 0] = SFF_MODE_SENSE;
			PassThrough.Cdb[ 1] = 0x08;
			PassThrough.Cdb[ 2] = 0x01;
			PassThrough.Cdb[ 3] = 0x00;
			PassThrough.Cdb[ 4] = 0x00;
			PassThrough.Cdb[ 5] = 0x00;
			PassThrough.Cdb[ 6] = 0x00;
			PassThrough.Cdb[ 7] = 0x00;
			PassThrough.Cdb[ 8] = 0x14;
			PassThrough.Cdb[ 9] = 0x00;
			PassThrough.Cdb[10] = 0x00;
			PassThrough.Cdb[11] = 0x00;
			fSuccess = DeviceIoControl(hDevice, IOCTL_SCSI_PASS_THROUGH_DIRECT, &PassThrough, sizeof(PassThrough), NULL, 0, &cbReturned, NULL);

			if (fSuccess)
				{
				ReadErrorRecoveryPage[8 + 2] = 0x00;
				ReadErrorRecoveryPage[8 + 3] = 0x04;

				PassThrough.DataIn = SCSI_IOCTL_DATA_OUT;
				PassThrough.Cdb[ 0] = SFF_MODE_SELECT;
				PassThrough.Cdb[ 1] = 0x10;
				PassThrough.Cdb[ 2] = 0x01;
				PassThrough.Cdb[ 3] = 0x00;
				PassThrough.Cdb[ 4] = 0x00;
				PassThrough.Cdb[ 5] = 0x00;
				PassThrough.Cdb[ 6] = 0x00;
				PassThrough.Cdb[ 7] = 0x00;
				PassThrough.Cdb[ 8] = 0x14;
				PassThrough.Cdb[ 9] = 0x00;
				PassThrough.Cdb[10] = 0x00;
				PassThrough.Cdb[11] = 0x00;
 				fSuccess = DeviceIoControl(hDevice, IOCTL_SCSI_PASS_THROUGH_DIRECT, &PassThrough, sizeof(PassThrough), NULL, 0, &cbReturned, NULL);

				if (fSuccess)
					{
					streamingMode = SMD_NAVIGATING;
					}
				}

			GNRAISE_OK;
			}
		else
			GNRAISE_OK;
		}
	else
		GNRAISE(err);
	}

Error XBOXDVDDrive::LockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle *rh)
	{
#if TEST_REDUCED_DRIVE_TIMEOUT
#if _DEBUG
	int t1 = timeGetTime();
#endif

	SetStreamingMode((flags & DAF_STREAMING) != 0);

#if _DEBUG
	int t2 = timeGetTime();
	if (t2-t1 > 50)
		{
		DP("SetStreamingMode took long time %d", t2-t1);
		}
#endif
#endif //TEST_REDUCED_DRIVE_TIMEOUT

	return BlockBufferCDVDDrive::LockBlocks(block, num, blocks, flags, rh);
	}


DriveBlockBuffer * XBOXDVDDrive::CreateDriveBlockBuffer(void)
	{
	return new W2KDriveBlockBuffer;
	}


// Flush - not implemented at the moment
Error XBOXDVDDrive::Flush()
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}

// Flush - not implemented at the moment
Error XBOXDVDDrive::TerminateRequest(RequestHandle * rh)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}


// Get Disk Type
// Calls first GetDVDType(..), if fails calls GetCDType(..).
// returns the GenericDiskType, see definition there of possible return values

Error XBOXDVDDrive::GetDiskType(PhysicalDiskType & type)
	{
	VDAutoMutex mutex(&monitorMutex);
	Error err = GNR_OK;

	type = PHDT_NONE;

	if (!IS_ERROR(err))
		{
		err = GetDVDType(type);
		}

	if (IS_ERROR(err) || type == PHDT_NONE)
		err = GetCDType(type);

	if (IS_ERROR(err))
		type = PHDT_NONE;

	return err;

	}


// Get type of DVD disk in drive.
// If the drive is no DVD drive, this call will return with an error and type = PDT_NONE

Error XBOXDVDDrive::GetDVDType(PhysicalDiskType & type)
	{
	VDAutoMutex autoMutex(&monitorMutex);
	Error err = GNR_OK;

	DVD_READ_STRUCTURE readStruct = {0};
	DVD_LAYER_DESCRIPTOR layerDescr = {0};
	BYTE buffer[2048];
	for(int i=0; i<2048; i++) buffer[i] = 0xbd;

	if (!IS_ERROR(err))
		{
		err = this->GetDevice();
		}

	// try DVD Read Structure
	if (!IS_ERROR(err))
		{
		readStruct.Format = DvdPhysicalDescriptor;

		DWORD returned = 0;
		BOOL fResult = DeviceIoControl( hDevice, IOCTL_DVD_READ_STRUCTURE, &readStruct, sizeof(readStruct),
											&layerDescr, sizeof(layerDescr), &returned, NULL);
		if (fResult == 0x00)
			{
			err = GNR_READ_ERROR;
			type = PHDT_NONE;
			DP(__TEXT("Error - GetDVDType : %x"), GetLastError());
			}
		}

	// find out from result which type
	if (!IS_ERROR(err))
		{
		BYTE layerType = (layerDescr.BookType) | (layerDescr.BookVersion << 4);
		switch (layerType)
			{
			case 0x0000:
				type = PHDT_DVD_ROM;
				break;
			case 0x0001:
				type = PHDT_DVD_RAM;
				break;
			case 0x0010:
				type = PHDT_DVD_R;
				break;
			case 0x1001:
				type = PHDT_DVD_RW;
				break;
			}
		}

	return GNR_OK;
	}



//! Get type of CD
// Disks supported are
// - CD Audio (CDDA)
// - CDROM Mode 1
// - CDROM Mode 2 XA Form 1 & 2
// if there is a CDROM Mode 2 NOT XA, this detection fails (we never seen such a CD).
// if this leads into problems, you could find out with evaluating the subheader byte after the
// evaluaing the sector checksum (See "System Description CDROM XA, II.4, May 1991)
//

Error XBOXDVDDrive::GetCDType(PhysicalDiskType & type)
	{
	type = PHDT_CDROM_XA;

	GNRAISE_OK;

	VDAutoMutex autoMutex(&monitorMutex);

	Error err = GNR_OK;

	CDROM_DISK_DATA diskType = {0};
	CDROM_TOC cdToc = {0};

	// get device
	if (!IS_ERROR(err))
		{
		err = this->GetDevice();
		}

	// find out if cd contains data and / or audio tracks
	if (!IS_ERROR(err))
		{
		DWORD returned = 0;
		BOOL hResult = ::DeviceIoControl(this->hDevice, IOCTL_CDROM_DISK_TYPE, NULL, NULL, &diskType, sizeof(diskType), &returned, NULL);
		if (hResult == 0x00)
			{
			err = GNR_READ_ERROR;
			type = PHDT_NONE;
			}
		}

	// find out which type of disk.
	// if only audio tracks, it is simple.
	// else, try to read a data sector in the different forms.
	if (!IS_ERROR(err))
		{
		if (diskType.DiskData == CDROM_DISK_AUDIO_TRACK)
			{
			type = PHDT_CDDA;
			}
		else
			{
			type = PHDT_CDROM_XA;
			}
		}

	return err;
	}


//! get number of sessions.
// do not return real number of sessions, but maximum 2 Sessions if Multisession,
// cause you only need the last session.
// see also ReadCDToc
//
Error XBOXDVDDrive::GetNumberOfSessions(WORD & num)
	{
	VDAutoMutex autoMutex(&monitorMutex);
	Error err = GNR_OK;

	SessionInfo sessionInfo = {0};
	WORD numSessions = 0;

	// get device for DVD drive
	if (!IS_ERROR(err))
		{
		err = this->GetDevice();
		}

	// get last session information
	if (!IS_ERROR(err))
		{
		// the Microsoft Documentation on this IOCTL (documentation included in W2000DDK) is wrong.
		// it claims this call has no input and output parameters, but you will get the struct defined below (see ATAPI Docu)
		DWORD returned = 0;
		BOOL hResult = ::DeviceIoControl(this->hDevice, IOCTL_CDROM_GET_LAST_SESSION, NULL, NULL, &sessionInfo, sizeof(sessionInfo), &returned, NULL);
		if (hResult == 0x00)
			{
			err = GNR_READ_ERROR;
			}
		}

	// calculate number of sessions

	if (!IS_ERROR(err))
		{
		if (sessionInfo.firstSession != sessionInfo.lastSession)
			numSessions = 2;
		else
			numSessions = 1;
		}

	// return result.
	if (IS_ERROR(err))
		num = 0;
	else
		num = numSessions;

	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\hardware\mpeg2dec\generic\mp2eldec.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


// FILE:      library\hardware\mpeg2dec\generic\mp2eldec.h
// AUTHOR:    U. Sigmund, S. Herr
// COPYRIGHT: (c) 1998 VIONA Development GmbH.  All Rights Reserved.
// CREATED:
//
// PURPOSE:   MPEG2 elementary video/audio decoders and supporting classes.
//
// HISTORY:

#ifndef MP2ELDEC_H
#define MP2ELDEC_H

#include "library/common/prelude.h"
#include "library/common/gnerrors.h"
#include "library/hardware/mpegdec/generic/mpegdec.h"
#include "library/hardware/audio/generic/ac3setup.h"
#include "library/hardware/audio/generic/karaokesetup.h"
#include "library/hardware/video/generic/ccapvenc.h"
#include "library/hardware/mpeg2dec/generic/MP2StreamReceiver.h"

enum SPUButtonState
	{
	SBS_DISABLED,
	SBS_SELECTED,
	SBS_ACTIVATED
	};

struct MPEG2SPUCommandMsg {
	DWORD		pts;
	int		command;
	};

MKHOOK(MPEG2SPUCommand, MPEG2SPUCommandMsg)

typedef MPEG2SPUCommandHook	__far *	MPEG2SPUCommandHookPtr;

//
//  Error definitions
//

#define GNR_DISPLAY_MODE_NOT_SUPPORTED					MKERR(ERROR, MPEG, FORMAT, 0x00)
// The display mode could not be set

#define GNR_AUDIO_TYPE_NOT_SUPPORTED					MKERR(ERROR, MPEG, FORMAT, 0x01)
// The audio format is not supported

#define GNR_NO_SPDIF_HARDWARE								MKERR(ERROR, MPEG, HARDWARE, 0x02)
// We do not SPDIF hardware

#define GNR_FRAME_ADVANCE_BOUNDARY_REACHED			MKERR(WARNING, MPEG, BOUNDS, 0x03)

enum MPEG2PresentationMode
	{
	MPM_FULLSIZE,
	MPM_LETTERBOXED,
	MPM_PANSCAN,
	MPM_FULLSIZE16by9
	};

enum SPDIFHandling
	{
	SPDIFH_DEFAULT,			// On when playback is running, off in all other cases
	SPDIFH_ON,					// Always physically on
	SPDIFH_OFF					// Always physically off (line idle)
	};

// This can be specified for each audio type
enum SPDIFOutputMode
	{
	SPDIFOM_DEFAULT,			// AC3: compressed, LPCM: decompressed, idle: NULL output
	SPDIFOM_DECOMPRESSED,	// Force decompressed output, even for AC3
	SPDIFOM_MUTE_NULL,		// Force mute with NULL output, if SPDIF_ON
	SPDIFOM_OFF					// Physically off
	};

enum SPDIFCopyMode
	{
	SPDIFCM_DEFAULT,			// Use system's default (transfer rights from source material to output)
	SPDIFCM_NO_COPIES,		// do not allow any copies
	SPDIFCM_ONE_GENERATION,	// allow one generation of copies
	SPDIFCM_UNRESTRICTED		// no copy restrictions
	};

enum MPEG2SplitStreamType
	{
	MP2SST_DVD_ENCRYPTED,
	MP2SST_PROGRAM,
	MP2SST_PES,
	MP2SST_ELEMENTARY
	};

// Basic Audio Source Type
enum MPEG2AudioType
	{
	MP2AUDTYP_DEFAULT,		// means: use MPEG2_AUDIO_AC3 and MPEG2_AUDIO_LPCM tags to determine audio type
	MP2AUDTYP_MPEG,			// MPEG(-1) all layers
	MP2AUDTYP_MPEG2,
	MP2AUDTYP_AC3,
	MP2AUDTYP_LPCM,			// includes CDDA (set # of bits and sample rate accordingly)
	MP2AUDTYP_DTS,
	MP2AUDTYP_SDDS,
	MP2AUDTYP_DTS_CDDA,		// CDDA with DTS information
	MP2AUDTYP_MLP,

	MP2AUDTYP_NUMBER_OF_TYPES
	};

// Virtual Surround ("Spatializer") modes
enum MPEG2AudioSpatializer
	{
	MP2AUDSPAT_DEFAULT,
	MP2AUDSPAT_NONE = MP2AUDSPAT_DEFAULT,
	MP2AUDSPAT_SRS_TS_3D,			// SRS True Surround or 3D sound, depending on source material
	MP2AUDSPAT_VMAX_TS_3D		// VMAX True Surround or 3D sound, depending on source material
	};

// PCM Output Configurations (= Bass Redirection Schemes)
enum PCMOutputConfig
	{
	PCMOCFG_DEFAULT,	// ALL, scaled, is default
	PCMOCFG_ALL = PCMOCFG_DEFAULT,
	PCMOCFG_LSW,
	PCMOCFG_LLR,
	PCMOCFG_SLP,
	PCMOCFG_SUM,		// subwoofer = sum of all input channels
	PCMOCFG_BYP,		// Bypass
	PCMOCFG_LSW_WF    // same as config 1 without filters
	};

// Downsample mode for 96kHz LPCM
enum PCM96DownsampleMode
	{
	PCM96DWNS_DEFAULT,
	PCM96DWNS_DOWN_48KHZ = PCM96DWNS_DEFAULT,	// sample down to 48kHz by default
	PCM96DWNS_NONE										// no downsampling, play back using 96kHz
	};


// Program Format Flags for tag MPEG2_AUDIO_PROGRAM_FORMAT
#define AUDPF_PROLOGIC			MKFLAG(0)	// Indicates if Pro Logic Decoding is active or not
#define AUDPF_LEFT				MKFLAG(1)	// Shows if program contains
#define AUDPF_RIGHT				MKFLAG(2)
#define AUDPF_CENTER				MKFLAG(3)
#define AUDPF_LFE					MKFLAG(4)
#define AUDPF_LEFT_SURROUND	MKFLAG(5)
#define AUDPF_RIGHT_SURROUND	MKFLAG(6)
#define AUDPF_MONO_SURROUND	MKFLAG(7)


//
//  CDDA Data Format
//  Describes formats supported by decoder
//

#define CDDADF_AUDIO_ONLY			MKFLAG(0)			// Only audio data (corresponds to LPCM, 2 ch, 16 Bit, 44.1 kHz), default
#define CDDADF_AUDIO_SUBCHANNEL	MKFLAG(1)			// For each block first audio data (2352 bytes), then subchannel (98 bytes)
#define CDDADF_SUBCHANNEL_AUDIO	MKFLAG(2)			// For each block first subchannel (98 bytes), then audio data (2352 bytes)
#define CDDADF_DEFAULT				CDDADF_AUDIO_ONLY

//
//  LPCM Data Format (Endianess)
//

enum LPCMDataFormat
	{
	LDF_BIG_ENDIAN,
	LDF_LITTLE_ENDIAN
	};

//
//  Audio Type Config
//

struct AudioTypeConfig
	{
	union
		{
		struct
			{
			SPDIFOutputMode	spdifOutMode : 3;
			// ...can be expanded up to size of a DWORD...
			} config;

		DWORD	dummy;
		};

	friend BOOL operator==(const AudioTypeConfig a, const AudioTypeConfig b);
	friend BOOL operator!=(const AudioTypeConfig a, const AudioTypeConfig b);

	operator DWORD (void) {return dummy;}

	AudioTypeConfig(DWORD arg) {dummy = arg;}
	AudioTypeConfig(void) {dummy = 0;}
	AudioTypeConfig(SPDIFOutputMode initMode)
		{
		config.spdifOutMode = initMode;
		// ...
		}
	};

inline BOOL operator==(const AudioTypeConfig a, const AudioTypeConfig b)
	{
	return (a.dummy == b.dummy);
	}

//static inline BOOL operator!=(const AudioTypeConfig a, const AudioTypeConfig b)
inline BOOL operator!=(const AudioTypeConfig a, const AudioTypeConfig b)
	{
	return (a.dummy != b.dummy);
	}

#if WDM_VERSION

struct MPEG2CCPacketMsg
	{
	BOOL startField;
	BYTE * data;
	int num;
	};

MKHOOK(MPEG2CCPacket, MPEG2CCPacketMsg)

typedef MPEG2CCPacketHook * MPEG2CCPacketHookPtr;

#endif	// WDM_VERSION

enum ForcedAspectRatio
	{
	FORCED_AR_DEFAULT	= 0,
	// 1 left out. Do not change the following two assignments:
	FORCED_AR_4_BY_3	= 2,
	FORCED_AR_16_BY_9	= 3
	};

enum FrameRateValue
	{
	FRV_23976 = 1,
	FRV_24000 = 2,
	FRV_25000 = 3,
	FRV_29970 = 4,
	FRV_30000 = 5,
	FRV_50000 = 6,
	FRV_59940 = 7,
	FRV_60000 = 8
	};


// Bits for audio speaker test bitfield (MPEG2_AUDIO_TEST_SPEAKER_SELECT)
#define AUDIO_TEST_LEFT_SPEAKER				0x01
#define AUDIO_TEST_RIGHT_SPEAKER				0x02
#define AUDIO_TEST_CENTER_SPEAKER			0x04
#define AUDIO_TEST_SUBWOOFER_SPEAKER		0x08
#define AUDIO_TEST_LEFT_SURROUND_SPEAKER	0x10
#define AUDIO_TEST_RIGHT_SURROUND_SPEAKER	0x20



MKTAG(MPEG2_AUDIO_AC3,						MPEG_DECODER_UNIT,	0x1001, BOOL)
MKTAG(MPEG2_AUDIO_AC3_STREAMID,			MPEG_DECODER_UNIT,	0x1002, BYTE)
MKTAG(MPEG2_CODING_STANDARD,	  		   MPEG_DECODER_UNIT,	0x1003, BOOL)

MKTAG(MPEG2_AC3_BASS_CONFIG,				MPEG_DECODER_UNIT,	0x1004, AC3BassConfig)
MKTAG(MPEG2_AC3_SPEAKER_CONFIG,			MPEG_DECODER_UNIT,	0x1005, AC3SpeakerConfig)
MKTAG(MPEG2_AC3_CENTER_DELAY,				MPEG_DECODER_UNIT,	0x1006, WORD)
MKTAG(MPEG2_AC3_SURROUND_DELAY,			MPEG_DECODER_UNIT,	0x1007, WORD)

MKTAG(MPEG2_AC3_CENTER_VOLUME,			MPEG_DECODER_UNIT,	0x1008, WORD)
MKTAG(MPEG2_AC3_LEFT_SURROUND_VOLUME,  MPEG_DECODER_UNIT,	0x1009, WORD)
MKTAG(MPEG2_AC3_RIGHT_SURROUND_VOLUME,	MPEG_DECODER_UNIT,	0x100a, WORD)
MKTAG(MPEG2_AC3_SUBWOOFER_VOLUME,		MPEG_DECODER_UNIT,	0x100b, WORD)

MKTAG(MPEG2_AC3_DUAL_MODE_CONFIG,		MPEG_DECODER_UNIT,	0x100c, AC3DualModeConfig)
MKTAG(MPEG2_AC3_KARAOKE_CONFIG,			MPEG_DECODER_UNIT,	0x100d, AC3KaraokeConfig)

MKTAG(MPEG2_SPU_STREAMID,					MPEG_DECODER_UNIT,	0x1010, BYTE)
MKTAG(MPEG2_SPU_ENABLE,						MPEG_DECODER_UNIT,	0x1011, BOOL)

MKTAG(MPEG2_SPU_BUTTON_STATE,				MPEG_DECODER_UNIT,	0x1012, SPUButtonState)
MKTAG(MPEG2_SPU_BUTTON_LEFT,				MPEG_DECODER_UNIT,	0x1013, WORD)
MKTAG(MPEG2_SPU_BUTTON_TOP,				MPEG_DECODER_UNIT,	0x1014, WORD)
MKTAG(MPEG2_SPU_BUTTON_WIDTH,				MPEG_DECODER_UNIT,	0x1015, WORD)
MKTAG(MPEG2_SPU_BUTTON_HEIGHT,			MPEG_DECODER_UNIT,	0x1016, WORD)
MKTAG(MPEG2_SPU_BUTTON_SELECT_COLOR,	MPEG_DECODER_UNIT,	0x1017, DWORD)
MKTAG(MPEG2_SPU_BUTTON_ACTIVE_COLOR,	MPEG_DECODER_UNIT,	0x1018, DWORD)
MKTAG(MPEG2_SPU_PALETTE_ENTRY,			MPEG_DECODER_UNIT,	0x1019, DWORD)
	// Palette Bits 0..7 Pen, 8..15 V, 16..23 U, 24..31 Y
MKTAG(MPEG2_SPU_COMMAND_HOOK,				MPEG_DECODER_UNIT,	0x101a, MPEG2SPUCommandHookPtr)
MKTAG(MPEG2_SPU_BUTTON_ID,					MPEG_DECODER_UNIT,	0x101b, WORD)
MKTAG(MPEG2_SPU_BUTTON_STARTTIME,		MPEG_DECODER_UNIT,	0x101c, DWORD)
MKTAG(MPEG2_SPU_BUTTON_ENDTIME,			MPEG_DECODER_UNIT,	0x101d, DWORD)

MKTAG(MPEG2_AUDIO_LPCM,						MPEG_DECODER_UNIT,	0x1021, BOOL)
MKTAG(MPEG2_AUDIO_LPCM_STREAMID,			MPEG_DECODER_UNIT,	0x1022, BYTE)
MKTAG(MPEG2_LPCM_BITSPERSAMPLE,			MPEG_DECODER_UNIT,	0x1023, WORD)
MKTAG(MPEG2_LPCM_CHANNELS,					MPEG_DECODER_UNIT,	0x1024, WORD)

MKTAG(MPEG2_AUDIO_DTS_STREAMID,			MPEG_DECODER_UNIT,	0x1028, BYTE)
MKTAG(MPEG2_AUDIO_MLP_STREAMID,			MPEG_DECODER_UNIT,	0x1029, BYTE)

MKTAG(MPEG2_PRESENTATION_MODE,			MPEG_DECODER_UNIT,	0x1030, MPEG2PresentationMode)

MKTAG(MPEG2_DVD_STREAM_DEMUX,				MPEG_DECODER_UNIT,	0x1031, BOOL)
MKTAG(MPEG2_DVD_STREAM_ENCRYPTED,		MPEG_DECODER_UNIT,	0x1032, BOOL)

#if WDM_VERSION
// Do not use this tag from user mode!
MKTAG(MPEG2_CC_PACKET_HOOK,				MPEG_DECODER_UNIT,	0x1033, MPEG2CCPacketHookPtr)
#endif

// Use this for overriding the default handling of switching ON/OFF SPDIF output
// (on decoders that can control SPDIF out)
MKTAG(MPEG2_SPDIF_HANDLING,				MPEG_DECODER_UNIT,	0x1034, SPDIFHandling)
MKTAG(MPEG2_SPDIF_OUTPUT_MODE,			MPEG_DECODER_UNIT,	0x1035, SPDIFOutputMode)
MKTAG(MPEG2_SPDIF_COPY_MODE,				MPEG_DECODER_UNIT,	0x1036, SPDIFCopyMode)

// This supercedes tags MPEG2_AUDIO_AC3 and MPEG2_AUDIO_LPCM, if available
MKTAG(MPEG2_AUDIO_TYPE,						MPEG_DECODER_UNIT,	0x103a, MPEG2AudioType)

// Specifies audio spatializing algorithm (e.g. SRS True Surround)
MKTAG(MPEG2_AUDIO_SPATIALIZER,			MPEG_DECODER_UNIT,	0x103b, MPEG2AudioSpatializer)

MKTAG(MPEG2_POSITION_SCALE,				MPEG_DECODER_UNIT,	0x1040, DWORD)

// Tags for downscaling the MPEG image and positioning it at an offset.
MKTAG(MPEG2_DOWNSCALE_FACTOR,				MPEG_DECODER_UNIT,	0x1050, int)
MKTAG(MPEG2_DOWNSCALE_HOFFSET,			MPEG_DECODER_UNIT,	0x1051, int)
MKTAG(MPEG2_DOWNSCALE_VOFFSET,			MPEG_DECODER_UNIT,	0x1052, int)
MKTAG(MPEG2_DOWNSCALE_HOFFSET_LBOXED,	MPEG_DECODER_UNIT,	0x1053, int)
MKTAG(MPEG2_DOWNSCALE_VOFFSET_LBOXED,	MPEG_DECODER_UNIT,	0x1054, int)

// New smooth zoom interface:
MKTAG(MPEG2_ZOOM_FACTOR,					MPEG_DECODER_UNIT,	0x1060, int)
MKTAG(MPEG2_ZOOM_SPEED,						MPEG_DECODER_UNIT,	0x1061, int)
MKTAG(MPEG2_ZOOM_ACTION,					MPEG_DECODER_UNIT,	0x1062, int)
MKTAG(MPEG2_ZOOM_HOFFSET,					MPEG_DECODER_UNIT,	0x1063, int)
MKTAG(MPEG2_HOFFSET_SPEED,					MPEG_DECODER_UNIT,	0x1064, int)
MKTAG(MPEG2_HOFFSET_ACTION,				MPEG_DECODER_UNIT,	0x1065, int)
MKTAG(MPEG2_ZOOM_VOFFSET,					MPEG_DECODER_UNIT,	0x1066, int)
MKTAG(MPEG2_VOFFSET_SPEED,					MPEG_DECODER_UNIT,	0x1067, int)
MKTAG(MPEG2_VOFFSET_ACTION,				MPEG_DECODER_UNIT,	0x1068, int)
MKTAG(MPEG2_PIP_HOFFSET,					MPEG_DECODER_UNIT,	0x1069, int)
MKTAG(MPEG2_PIP_VOFFSET,					MPEG_DECODER_UNIT,	0x1070, int)


MKTAG(MPEG2_AC3_EQUALIZER_FRONT_ENABLE,MPEG_DECODER_UNIT,	0x1100, BOOL)
MKTAG(MPEG2_AC3_EQUALIZER_BACK_ENABLE,	MPEG_DECODER_UNIT,	0x1101, BOOL)
MKTAG(MPEG2_AC3_EQUALIZER_FRONT,			MPEG_DECODER_UNIT,	0x1104, DWORD)
MKTAG(MPEG2_AC3_EQUALIZER_BACK,			MPEG_DECODER_UNIT,	0x1105, DWORD)
MKTAG(MPEG2_STILL_FRAME_SEQUENCE,		MPEG_DECODER_UNIT,	0x1106, BOOL)
MKTAG(MPEG2_CURRENT_PLAYBACK_TIME,		MPEG_DECODER_UNIT,	0x1107, LONG)
MKTAG(MPEG2_AC3_VIRTUAL_3D_AUDIO,		MPEG_DECODER_UNIT,	0x1108, BOOL)

// Tags for split stream playback configuration
MKTAG(MPEG2_VIDEO_SPLIT_STREAM_TYPE,	MPEG_DECODER_UNIT,	0x1109, MPEG2SplitStreamType)
MKTAG(MPEG2_AUDIO_SPLIT_STREAM_TYPE,	MPEG_DECODER_UNIT,	0x1110, MPEG2SplitStreamType)
MKTAG(MPEG2_SPU_SPLIT_STREAM_TYPE,		MPEG_DECODER_UNIT,	0x1111, MPEG2SplitStreamType)

MKTAG(MPEG2_FORCED_SOURCE_ASPECT_RATIO, MPEG_DECODER_UNIT,	0x1120, ForcedAspectRatio)
// Switch to WDM playback (meaning: no navpacks in DVD data streams)
MKTAG(MPEG2_WDM_PLAYBACK,					MPEG_DECODER_UNIT,	0x1122, BOOL)
// Returns current value of the decoder's STC
MKTAG(MPEG2_CURRENT_STC,					MPEG_DECODER_UNIT,	0x1123, LONG)

MKTAG(MPEG2_REQUESTED_PLAYBACK_TIME,   MPEG_DECODER_UNIT,   0x1130, LONG)

// Closed Caption output on/off
MKTAG(MPEG2_CC_ENABLE,						MPEG_DECODER_UNIT,	0x1140, BOOL)

// Additional delay tags
MKTAG(MPEG2_AC3_LEFT_DELAY,				MPEG_DECODER_UNIT,	0x1200, WORD)
MKTAG(MPEG2_AC3_RIGHT_DELAY,				MPEG_DECODER_UNIT,	0x1201, WORD)
MKTAG(MPEG2_AC3_LEFT_SURROUND_DELAY,	MPEG_DECODER_UNIT,	0x1202, WORD)
MKTAG(MPEG2_AC3_RIGHT_SURROUND_DELAY,	MPEG_DECODER_UNIT,	0x1203, WORD)
MKTAG(MPEG2_AC3_SUBWOOFER_DELAY,			MPEG_DECODER_UNIT,	0x1204, WORD)

// Dolby Pro Logic Decoder config and mode
MKTAG(MPEG2_PRO_LOGIC_CONFIG,				MPEG_DECODER_UNIT,	0x1210, DolbyProLogicConfig)
MKTAG(MPEG2_PRO_LOGIC_MODE,				MPEG_DECODER_UNIT,	0x1211, DolbyProLogicMode)

// Low Frequency Enable (LFE). Applicable for AC3, MPEG2-MC and DTS stream playback
MKTAG(MPEG2_DECODE_LFE,						MPEG_DECODER_UNIT,	0x1220, BOOL)

// GET only tag that returns whether a LFE channel is present (and being decoded) or not
MKTAG(MPEG2_LFE_STATUS,						MPEG_DECODER_UNIT,	0x1221, BOOL)

// AC3 Audio Coding Mode (acmod property). GET only.
MKTAG(MPEG2_AC3_AUDIO_CODING_MODE,		MPEG_DECODER_UNIT,	0x1225, AC3AudioCodingMode)

// Returns TRUE if Pro Logic decoding is active
MKTAG(MPEG2_PROLOGIC_STATUS,				MPEG_DECODER_UNIT,	0x1226, BOOL)

// PCM output configuration
MKTAG(MPEG2_PCM_OUTPUT_CONFIG,			MPEG_DECODER_UNIT,	0x1230, PCMOutputConfig)

// Dynamic range
MKTAG(MPEG2_AC3_DYNAMIC_RANGE,			MPEG_DECODER_UNIT,	0x1236, AC3DynamicRange)
MKTAG(MPEG2_AC3_HIGH_DYNAMIC_RANGE,		MPEG_DECODER_UNIT,	0x1237, WORD)
MKTAG(MPEG2_AC3_LOW_DYNAMIC_RANGE,		MPEG_DECODER_UNIT,	0x1238, WORD)

MKTAG(MPEG2_AC3_DIALOG_NORM,			MPEG_DECODER_UNIT,	0x1239, AC3DialogNorm)
MKTAG(MPEG2_AC3_OPERATIONAL_MODE,		MPEG_DECODER_UNIT,	0x123a, AC3OperationalMode)

// Audio type specific configurations
MKTAG(MPEG2_AC3_AUDIO_TYPE_CONFIG,		MPEG_DECODER_UNIT,	0x1240, AudioTypeConfig)
MKTAG(MPEG2_LPCM_AUDIO_TYPE_CONFIG,		MPEG_DECODER_UNIT,	0x1241, AudioTypeConfig)
MKTAG(MPEG2_DTS_AUDIO_TYPE_CONFIG,		MPEG_DECODER_UNIT,	0x1242, AudioTypeConfig)
MKTAG(MPEG2_MPEG_AUDIO_TYPE_CONFIG,		MPEG_DECODER_UNIT,	0x1243, AudioTypeConfig)
MKTAG(MPEG2_MPEG2_AUDIO_TYPE_CONFIG,	MPEG_DECODER_UNIT,	0x1244, AudioTypeConfig)
MKTAG(MPEG2_SDDS_AUDIO_TYPE_CONFIG,		MPEG_DECODER_UNIT,	0x1245, AudioTypeConfig)
MKTAG(MPEG2_CDDA_DTS_AUDIO_TYPE_CONFIG,MPEG_DECODER_UNIT,	0x1246, AudioTypeConfig)
MKTAG(MPEG2_MLP_AUDIO_TYPE_CONFIG,		MPEG_DECODER_UNIT,	0x1247, AudioTypeConfig)

MKTAG(MPEG2_PCM96_DOWNSAMPLE_MODE_DAC,		MPEG_DECODER_UNIT,	0x1300, PCM96DownsampleMode)
MKTAG(MPEG2_PCM96_DOWNSAMPLE_MODE_SPDIF,	MPEG_DECODER_UNIT,	0x1301, PCM96DownsampleMode)

MKTAG(MPEG2_VIDEO_MIN_PLAYBACK_SPEED,	MPEG_DECODER_UNIT,	0x1330, WORD)
MKTAG(MPEG2_VIDEO_MAX_PLAYBACK_SPEED,	MPEG_DECODER_UNIT,	0x1331, WORD)

MKTAG(MPEG2_AUDIO_MIN_PLAYBACK_SPEED,	MPEG_DECODER_UNIT,	0x1334, WORD)
MKTAG(MPEG2_AUDIO_MAX_PLAYBACK_SPEED,	MPEG_DECODER_UNIT,	0x1335, WORD)

MKTAG(MPEG2_VIDEO_MIN_SCAN_SPEED,		MPEG_DECODER_UNIT,	0x1340, WORD)
MKTAG(MPEG2_VIDEO_MAX_SCAN_SPEED,		MPEG_DECODER_UNIT,	0x1341, WORD)

MKTAG(MPEG2_AUDIO_MIN_SCAN_SPEED,		MPEG_DECODER_UNIT,	0x1344, WORD)
MKTAG(MPEG2_AUDIO_MAX_SCAN_SPEED,		MPEG_DECODER_UNIT,	0x1345, WORD)

// Use this tag to damp volume during scan modes
MKTAG(MPEG2_AUDIO_VOLUME_DAMP,			MPEG_DECODER_UNIT,	0x1346, BOOL)

// Speaker selection for audio tests (e.g. pink noise test). Bitfield defined above.
MKTAG(MPEG2_AUDIO_TEST_SPEAKER_SELECT,	MPEG_DECODER_UNIT,	0x1350, WORD)

// Data format for CDDA decoder, should be Get/Set
MKTAG(CDDA_DATA_FORMAT,						MPEG_DECODER_UNIT,	0x1400, DWORD)

// Endianess of LPCM decoder (Qry/Get)
MKTAG(LPCM_DATA_FORMAT,						MPEG_DECODER_UNIT,	0x1401, LPCMDataFormat)

MKTAG(MPEG2_TIMEOUT_MSG,					MPEG_DECODER_UNIT,	0x1500, WORD)
MKTAG(MPEG2_REFILL_MSG,						MPEG_DECODER_UNIT,	0x1501, WORD)
MKTAG(MPEG2_DONE_MSG,						MPEG_DECODER_UNIT,	0x1502, WORD)
MKTAG(MPEG2_SIGNAL_MSG,						MPEG_DECODER_UNIT,	0x1503, WORD)
MKTAG(MPEG2_ERROR_MSG,						MPEG_DECODER_UNIT,	0x1504, WORD)

// Karaoke control tags
#define KARAOKE_TAGVALUE_BASE  0x2000

MKTAG(MPEG2_AUDIO_KARAOKE_ENABLE,								MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE +  0, BOOL)
MKTAG(MPEG2_AUDIO_KARAOKE_LEFT_CHANNEL_MUSIC_VOLUME,		MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE +  1, WORD)
MKTAG(MPEG2_AUDIO_KARAOKE_RIGHT_CHANNEL_MUSIC_VOLUME,		MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE +  2, WORD)
MKTAG(MPEG2_AUDIO_KARAOKE_ENABLE_MUSIC_CHANNEL_MUTE,		MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE +  3, BOOL)

MKTAG(MPEG2_AUDIO_KARAOKE_LEFT_CHANNEL_VOICE_VOLUME,		MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE +  4, WORD)
MKTAG(MPEG2_AUDIO_KARAOKE_RIGHT_CHANNEL_VOICE_VOLUME,		MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE +  5, WORD)
MKTAG(MPEG2_AUDIO_KARAOKE_ENABLE_VOICE_CHANNEL_MUTE,		MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE +  6, BOOL)


MKTAG(MPEG2_AUDIO_KARAOKE_PITCH_SHIFT,							MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE +  7, int)
MKTAG(MPEG2_AUDIO_KARAOKE_ENABLE_PITCH_SHIFT,				MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE +  8, BOOL)

MKTAG(MPEG2_AUDIO_KARAOKE_VOICE_CANCELLATION,				MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE +  9, WORD)
MKTAG(MPEG2_AUDIO_KARAOKE_ENABLE_VOICE_CANCELLATION,		MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE + 10, BOOL)

MKTAG(MPEG2_AUDIO_KARAOKE_DUET_THRESHOLD,						MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE + 11, WORD)
MKTAG(MPEG2_AUDIO_KARAOKE_ENABLE_DUET,							MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE + 12, BOOL)

MKTAG(MPEG2_AUDIO_KARAOKE_VOICE_EFFECT,						MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE + 13, KaraokeVoiceEffectType )
MKTAG(MPEG2_AUDIO_KARAOKE_VOICE_EFFECT_DELAY,				MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE + 14, WORD)
MKTAG(MPEG2_AUDIO_KARAOKE_VOICE_EFFECT_BALANCE,				MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE + 15, WORD)

MKTAG(MPEG2_AUDIO_KARAOKE_MUSIC_GAIN,							MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE + 16, WORD)
MKTAG(MPEG2_AUDIO_KARAOKE_VOICE_GAIN,							MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE + 17, WORD)
MKTAG(MPEG2_AUDIO_KARAOKE_MUSIC_IN_SHIFT, 					MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE + 18, WORD)
MKTAG(MPEG2_AUDIO_KARAOKE_MUSIC_OUT_SHIFT,					MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE + 19, WORD)
MKTAG(MPEG2_AUDIO_KARAOKE_VOICE_IN_SHIFT, 					MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE + 20, WORD)
MKTAG(MPEG2_AUDIO_KARAOKE_VOICE_OUT_SHIFT, 					MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE + 21, WORD)

MKTAG(MPEG2_AUDIO_KARAOKE_ECHO_FEEDBACK,						MPEG_DECODER_UNIT,  KARAOKE_TAGVALUE_BASE + 22, WORD)



#ifndef ONLY_EXTERNAL_VISIBLE

#include "library/common/virtunit.h"
#include "library/general/queues.h"
#include "library/common/krnlint.h"

#define INVALID_PTS	0xffffffff   // must be largest DWORD

class PTSAssoc {
	private:
		struct Assoc {DWORD pos, pts;} * assoc;
		int first;
		int last;
		int num;
	public:
		PTSAssoc(int num);
		~PTSAssoc(void);

		void PutPTS(DWORD pos, DWORD pts);
		DWORD GetPTS(DWORD pos);
		DWORD GetAvgPTS(DWORD pos);
		void Reset(void);
	};

class PTSCallback : Node
	{
	friend class PTSCaller;
	private:
		DWORD	callPTS;
		BOOL	needSequenceStartCallback;

		BOOL HigherPriorityThan(Node * n) {return callPTS < ((PTSCallback *)n)->callPTS;}
	public:
		PTSCallback(void) {callPTS = INVALID_PTS; needSequenceStartCallback = FALSE;}

		virtual Error PTSCallbackReached(DWORD currentPTS) = 0;
		virtual Error PTSCallbackCanceled(void);

		virtual Error SequenceStartReached (void);
	};

class PTSCaller
	{
	private:
		DWORD	lastPTS;

		List	callbacks;
	public:
		PTSCaller(void) {lastPTS = 0;}

		Error AddCallback(DWORD pts, PTSCallback * callback);
		Error RemCallback(PTSCallback * callback);

		Error CheckCallbacks(DWORD currentPTS);
		Error CancelCallbacks(void);

		Error AddSequenceStartCallback (PTSCallback *callback);
		Error RemSequenceStartCallback (PTSCallback *callback);
		Error CallSequenceStartCallbacks (void);
	};

class PTSCounter
	{
	private:
		BOOL running;

		long ptsDelay;

		DWORD basePTS;

		DWORD baseTimeOffset;
		DWORD stopTimeOffset;

		WORD playbackSpeed;

	public:
		PTSCounter(void);
		~PTSCounter(void);

		Error Reset(void);
		Error SetDecoderDelay(long delay); // in milliseconds

		Error Start (WORD playbackSpeed = 1000);
		Error Stop(void);

		Error SyncPTS(DWORD pts);
		Error SetPTS(DWORD pts);
		DWORD GetPTS(void);
	};


class MPEG2CommandQueue
	{
	private:
		struct {MPEGCommand com; DWORD param;} queue[16];
		DWORD	first, last, next;
	public:
		MPEG2CommandQueue(void) {last = 0; Reset();}

		void Reset(void) {first = next = last;}

		BOOL CommandPending(DWORD tag) {if (tag != 0xffffffff) return first <= tag; else return FALSE;}

		Error InsertCommand(MPEGCommand com, DWORD param, DWORD __far &tag);
		BOOL PeekCommand(MPEGCommand __far &com, DWORD __far &param);
		void SkipCommand(void) {first++; next++;}
		BOOL GetCommand(MPEGCommand __far &com, DWORD __far &param);
		Error CompleteCommand(void);
	};


class MPEG2ElementaryDecoder : public PhysicalUnit, public MPEG2StreamReceiver
   {
   friend class VirtualMPEG2ElementaryDecoder;
   protected:
   	DWORD		streamBitrate;
   	DWORD		positionScale, positionBaseScale;

      BOOL		dvdStreamDemux;
      BOOL		dvdStreamEncrypted;

		Error StreamHook(DWORD size);
   	Error SignalHook(DWORD position);
   	Error SignalHook(KernelInt64 position);
   	Error DoneHook(void);
		Error IdleHook(void);

		virtual DWORD RecoverStreamData(HPTR data, DWORD size) {return 0;}
		virtual DWORD StreamDataAvailable(void) {return 0;}
   public:
		MPEG2ElementaryDecoder	*	syncSlave;
      BOOL								slaveMode;

   	MPEG2ElementaryDecoder(void) {positionScale = positionBaseScale = MP2SR_SCALE_BYTES; syncSlave = NULL; slaveMode = FALSE;}

	   virtual Error SendCommand(MPEGCommand com, DWORD param, DWORD __far &tag) = 0;
		virtual BOOL CommandPending(DWORD tag) = 0;
      virtual Error DoCommand(MPEGCommand com, DWORD param);
		virtual Error CompleteCommand(DWORD tag);

		virtual DWORD CurrentLocation(void) = 0;
		virtual MPEGState CurrentState(void) = 0;

	   virtual DWORD GetPTS() = 0;
		virtual Error ConformToPTS(DWORD pts) {GNRAISE_OK;}
		virtual Error SetPlaybackTime(LONG time) {GNRAISE_OK;}

	   virtual Error SetSignalPosition(DWORD position) = 0;
	   virtual Error SetStreamBitRate(DWORD rate) {streamBitrate = rate; GNRAISE_OK;}
	   virtual Error SetPositionScale(DWORD scale) {positionScale = scale; GNRAISE_OK;}

   	virtual Error SetDVDStreamDemux(BOOL dvdDemux) {this->dvdStreamDemux = dvdDemux; GNRAISE_OK;}
   	virtual Error SetDVDStreamEncrypted(BOOL dvdEncrypted) {this->dvdStreamEncrypted = dvdEncrypted; GNRAISE_OK;}

		virtual Error SyncPlay(void) {GNRAISE_OK;}

		virtual Error NotifySiblingBufferFull(void) {GNRAISE_OK;}
		virtual Error NotifyTransferStopped(void) {GNRAISE_OK;}
		virtual Error VOBUBorderReached(void) {GNRAISE_OK;}
   };

class VirtualMPEG2ElementaryDecoder : public VirtualUnit, public MPEG2StreamReceiver
	{
	friend class MPEG2ElementaryDecoder;
	private:
		MPEG2ElementaryDecoder	*	decoder;
	protected:
#if !DRVDLL
		MPEGStreamHookHandle	streamHook;
		MPEGSignalHookHandle	signalHook;
		MPEGSignalHookHandle	doneHook;
	   MPEGIdleHookHandle	idleHook;
#else
		MPEGStreamHook	* streamHook;
		MPEGSignalHook	* signalHook;
		MPEGSignalHook	* doneHook;
	   MPEGIdleHook	* idleHook;
#endif

   	DWORD		streamBitrate;
		DWORD		signalPosition;
   	DWORD		positionScale;

		HBPTR		buffer;
		DWORD		buffStart, buffEnd, buffSize;
		DWORD		streamPosition;
		LONG		playbackTime;

		BOOL							dvdStreamDemux;
		BOOL							dvdStreamEncrypted;

		FixedDualIntQueue	ptsQueue;

      virtual Error RecoverStreamData(void);
      virtual Error ProvideStreamData(void);

      Error PreemptStopPrevious(VirtualUnit * previous);
      Error PreemptChange(VirtualUnit * previous);
      Error PreemptStartNew(VirtualUnit * previous);
	public:
		VirtualMPEG2ElementaryDecoder(MPEG2ElementaryDecoder * unit);
		~VirtualMPEG2ElementaryDecoder(void);

      virtual Error AllocateStreamBuffer(DWORD size);
		virtual Error FlushStreamBuffer(void);

		Error Configure (TAG __far *tags);

	   virtual Error SendCommand(MPEGCommand com, DWORD param, DWORD __far &tag);
		virtual BOOL CommandPending(DWORD tag);
      virtual Error DoCommand(MPEGCommand com, DWORD param);
		virtual Error CompleteCommand(DWORD tag);

		virtual DWORD CurrentLocation(void);
		virtual MPEGState CurrentState(void);

	   virtual DWORD SendData(HPTR data, DWORD size);
	   virtual void CompleteData(void);
		virtual DWORD LastTransferLocation(DWORD scale);

	   virtual Error SendPESData(HPTR data, DWORD size, DWORD __far & done, DWORD __far & used);

	   virtual DWORD GetPTS();
	   virtual void PutPTS(DWORD pts);
		virtual Error ConformToPTS(DWORD pts);

		virtual Error NotifySiblingBufferFull(void);
		virtual Error NotifyTransferStopped(void);
		virtual Error VOBUBorderReached(void);
	};


class MPEG2VideoDecoder : public MPEG2ElementaryDecoder
	{
	friend class VirtualMPEG2VideoDecoder;
	protected:
		virtual Error SetVideoBitrate(DWORD videoBitrate) = 0;
		virtual Error SetVideoWidth(WORD width) = 0;
		virtual Error SetVideoHeight(WORD height) = 0;
		virtual Error SetVideoStandard(VideoStandard	standard) = 0;
#if TEST_PAL_TO_NTSC
		virtual Error SetApplicationVideoStandard(VideoStandard	standard) = 0;	//aa3
		virtual MovingImageStandard GetEncoderMovingImageStandard () = 0;
#endif
		virtual Error SetVideoFPS(WORD fps) = 0;
		virtual Error SetMPEG2Coding(BOOL mpeg2Coding) = 0;
		virtual Error SetAspectRatio(WORD aspectRatio) = 0;
		virtual Error SetPresentationMode(MPEG2PresentationMode presentationMode) = 0;

	public:

	};

class VirtualMPEG2VideoDecoder : public VirtualMPEG2ElementaryDecoder
	{
	private:
		MPEG2VideoDecoder	*		decoder;
	protected:
		DWORD							videoBitrate;
		WORD							videoWidth;
		WORD							videoHeight;
		WORD							videoFPS;
		WORD							aspectRatio;
		VideoStandard				videoStandard;
#if TEST_PAL_TO_NTSC
		VideoStandard				diskVideoStandard;
		VideoStandard				applicationVideoStandard;
		MovingImageStandard		decoderMovingImageStandard;
#endif
		BOOL							mpeg2Coding;
		MPEG2PresentationMode	presentationMode;

		virtual Error GetDisplaySize(WORD __far& width, WORD __far& height);

		Error PreemptChange(VirtualUnit * previous);
	public:
		VirtualMPEG2VideoDecoder(MPEG2VideoDecoder * unit) : VirtualMPEG2ElementaryDecoder(unit)
			{decoder = unit; videoBitrate = 0; videoWidth = 0; videoHeight = 0;
			 videoFPS = 0; mpeg2Coding = FALSE;
			 presentationMode = MPM_FULLSIZE;
#if TEST_PAL_TO_NTSC

			applicationVideoStandard = VSTD_PAL;
#endif
			}

		Error Configure(TAG __far * tags);

		virtual Error SetLine21Receiver(Line21Receiver * line21Receiver);
	};

class MPEG2AudioDecoder : public MPEG2ElementaryDecoder
	{
	public:
		virtual Error SetAudioBitrate(DWORD rate) = 0;
		virtual Error SetSampleRate(WORD rate) = 0; // in samples per second;
		virtual Error SetLeftVolume(WORD volume) = 0;
		virtual Error SetRightVolume(WORD volume) = 0;
		virtual Error SetMute(BOOL mute) = 0;
		virtual Error SetAudioType(MPEG2AudioType audioType) {GNRAISE_OK;}
		virtual Error SetAudioLayer(MPEGAudioLayer audioLayer) {GNRAISE_OK;}
		virtual Error SetLPCM(BOOL lpcm) {GNRAISE_OK;}
		virtual Error SetBitsPerSample(WORD samples) {GNRAISE_OK;}
		virtual Error SetChannels(WORD channels) {GNRAISE_OK;}
	};

class VirtualMPEG2AudioDecoder : public VirtualMPEG2ElementaryDecoder
	{
	private:
		MPEG2AudioDecoder	* decoder;
	protected:
		DWORD	audioBitrate;
		WORD	sampleRate;
		WORD	leftVolume;
		WORD	rightVolume;
		BOOL	audioMute;
		WORD	bitsPerSample;
		WORD	channels;
		BOOL	lpcm;

		MPEGAudioLayer	audioLayer;
		MPEG2AudioType	audioType;

		Error PreemptChange(VirtualUnit * previous);
	public:
		VirtualMPEG2AudioDecoder(MPEG2AudioDecoder	* decoder) : VirtualMPEG2ElementaryDecoder(decoder)
			{this->decoder = decoder;audioBitrate = 0; sampleRate = 48000;
			 leftVolume = 10000; rightVolume = 10000; audioMute = TRUE;
			 audioType = MP2AUDTYP_DEFAULT; lpcm = FALSE; bitsPerSample = 16; channels = 2; audioLayer = MPAUDLAYER_2;
			 }

		Error Configure (TAG __far *tags);
	};

class MPEG2AC3Decoder : public MPEG2AudioDecoder
	{
	public:
		virtual Error SetAC3(BOOL ac3) = 0;

		virtual Error SetBassConfig(AC3BassConfig config) = 0;
		virtual Error SetSpeakerConfig(AC3SpeakerConfig config) = 0;
		virtual Error SetDualModeConfig(AC3DualModeConfig config) = 0;
		virtual Error SetKaraokeConfig(AC3KaraokeConfig config) = 0;
		virtual Error SetCenterDelay(WORD delay) = 0;
		virtual Error SetSurroundDelay(WORD delay) = 0;
		virtual Error SetCenterVolume(WORD volume) = 0;
		virtual Error SetLeftSurroundVolume(WORD volume) = 0;
		virtual Error SetRightSurroundVolume(WORD volume) = 0;
		virtual Error SetSubwooferVolume(WORD volume) = 0;
		virtual Error SetLeftDelay(WORD leftDelay) {GNRAISE_OK;}
		virtual Error SetRightDelay(WORD rightDelay) {GNRAISE_OK;}
		virtual Error SetLeftSurroundDelay(WORD leftSurroundDelay) {GNRAISE_OK;}
		virtual Error SetRightSurroundDelay(WORD rightSurroundDelay) {GNRAISE_OK;}
		virtual Error SetSubwooferDelay(WORD subwooferDelay) {GNRAISE_OK;}
		virtual Error SetPrologicConfig(DolbyProLogicConfig prologicConfig) {GNRAISE_OK;}
		virtual Error SetPrologicMode(DolbyProLogicMode prologicMode) {GNRAISE_OK;}
		virtual Error SetDecodeLFE(BOOL decodeLFE) {GNRAISE_OK;}
		virtual Error SetPCMOutputConfig(PCMOutputConfig pcmOCFG) {GNRAISE_OK;}
		virtual Error SetDynamicRange(AC3DynamicRange dynamicRange) {GNRAISE_OK;}
		virtual Error SetAudioTypeConfig(MPEG2AudioType type, AudioTypeConfig config) {GNRAISE_OK;}
	};

class VirtualMPEG2AC3Decoder : public VirtualMPEG2AudioDecoder
	{
	private:
		MPEG2AC3Decoder	*	decoder;
	protected:
		BOOL						ac3;
		AC3BassConfig  		bassConfig;
		AC3SpeakerConfig		speakerConfig;
		AC3DualModeConfig		dualModeConfig;
		AC3KaraokeConfig		karaokeConfig;
		WORD						centerDelay;
		WORD						surroundDelay;
		WORD						centerVolume;
		WORD						leftSurroundVolume;
		WORD						rightSurroundVolume;
		WORD						subwooferVolume;
		WORD						leftDelay;
		WORD						rightDelay;
		WORD						leftSurroundDelay;
		WORD						rightSurroundDelay;
		WORD						subwooferDelay;
		DolbyProLogicConfig	prologicConfig;
		DolbyProLogicMode		prologicMode;
		BOOL						decodeLFE;
		PCMOutputConfig		pcmOCFG;
		AC3DynamicRange		dynamicRange;
		AudioTypeConfig		ac3Config;
		AudioTypeConfig		dtsConfig;
		AudioTypeConfig		lpcmConfig;
		AudioTypeConfig		mpegConfig;
		AudioTypeConfig		mpeg2Config;
		AudioTypeConfig		cddaDtsConfig;

		Error PreemptChange(VirtualUnit * previous);
	public:
		VirtualMPEG2AC3Decoder(MPEG2AC3Decoder * decoder);
		Error Configure(TAG __far * tags);
	};

//
// Inlines
//

inline Error MPEG2CommandQueue::CompleteCommand(void)
	{
	first++;

	GNRAISE_OK;
	}

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\hardware\mpeg2enc\generic\mpeg2enc.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// FILE:       library\hardware\mpeg2enc\generic\mpeg2enc.h
// AUTHOR:		Martin Stephan
// COPYRIGHT:	(c) 1999 Viona Development GmbH.  All Rights Reserved.
// CREATED:		25.10.1999
//
// PURPOSE: 	MPEG2 video/audio encoders and supporting classes. --- Header file
//
// HISTORY:
//

#ifndef MPEG2ENC_H
#define MPEG2ENC_H

#include "mp2elenc.h"

#ifndef ONLY_EXTERNAL_VISIBLE

class MPEG2AVEncoder : public MPEG2ElementaryEncoder
   {
   friend class VirtualMPEG2AVEncoder;

   protected:
		MPEGEncoderStreamType	outputType;

		virtual Error SetOutputStreamType(MPEGEncoderStreamType outputStreamType) = 0;
		virtual Error SetVideoSource(VideoSource source) = 0;
		virtual Error SetVideoStandard(VideoStandard	standard) = 0;

   public:
		VirtualUnit * CreateVirtual(void);

		virtual VirtualMPEG2AVEncoder * CreateVirtualMPEGEncoder(void) = 0;
   };

class VirtualMPEG2AVEncoder : public VirtualMPEG2ElementaryEncoder
	{
	private:
		MPEG2AVEncoder * encoder;

	protected:
		//MPEGStreamType				streamType;
		MPEGEncoderStreamType	outputStreamType;
		VideoStandard				videoStandard;
		VideoSource					videoSource;

		Error PreemptChange(VirtualUnit * previous);

	public:
		VirtualMPEG2AVEncoder(MPEG2AVEncoder * encoder);

		Error Configure(TAG __far * tags);
	};
#endif

#endif // MPEG2ENC_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\hardware\video\generic\ccapvenc.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef CCAPVENC_H
#define CCAPVENC_H

#include "videnc.h"

#ifndef ONLY_EXTERNAL_VISIBLE

#define CCENCBUFFERSIZE	512

class CloseCaptionVideoEncoder : public VideoEncoder, public InterruptHandler
	{
	protected:
		virtual Error GetCCStatus(BOOL __far & first, BOOL __far & second) = 0;
		virtual Error PutCCData(BOOL field, BYTE d1, BYTE d2) = 0;
		virtual Error EnableCCTransfer(void) = 0;
		virtual Error DisableCCTransfer(void) = 0;

		char	ccbuffer[CCENCBUFFERSIZE];
		int	ccfirst, cclast;
		BOOL	cctransfer;
		BOOL	ccLastField;
		BOOL	ccflushed;
		BOOL	ccflushing;
		int	ccflushcnt;

	public:
		CloseCaptionVideoEncoder(GenericProfile * profile = NULL, int nIdleScreens = 0,
		                         VideoEncoderIdleEntry __far * idleEntries = NULL);

		// Dynamic type conversion routine to InterruptHandeler
		virtual InterruptHandler * ToInterruptHandler(void) {return this;}

		virtual void Interrupt(void);

		virtual Error AddCloseCaptionData(BOOL startField, BYTE __far * data, int num);
		virtual Error FlushCloseCaptionBuffer(void);
		virtual Error StartCloseCaptionTransfer(void);
		virtual Error StopCloseCaptionTransfer(void);
	};

class VirtualCloseCaptionVideoEncoder : public VirtualVideoEncoder, public Line21Receiver
	{
	private:
		CloseCaptionVideoEncoder	*	encoder;

	protected:
		BOOL	cctransfer;

		Error Preempt(VirtualUnit * previous);
	public:
		VirtualCloseCaptionVideoEncoder(CloseCaptionVideoEncoder * encoder);

		// Dynamic type conversion routine to Line21Receiver
		virtual Line21Receiver * ToLine21Receiver(void) {return this;}

		virtual Error AddCloseCaptionData(BOOL startField, BYTE __far * data, int num);
		virtual Error FlushCloseCaptionBuffer(void);
		virtual Error StartCloseCaptionTransfer(void);
		virtual Error StopCloseCaptionTransfer(void);
	};

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\hardware\mpegdec\generic\MPEGDEC.H ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


// FILE:      library\hardware\mpegdec\generic\mpegdec.h
// AUTHOR:    U. Sigmund
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   10.04.95
//
// PURPOSE:
//
// HISTORY:

#ifndef MPEGDEC_H
#define MPEGDEC_H

#include "library\common\prelude.h"
#include "library\common\gnerrors.h"
#include "library\common\tags.h"
#include "library\common\hooks.h"
#include "library\common\tagunits.h"
#include "library\hardware\video\generic\vidtypes.h"
#include "library\hardware\mpgcodec\generic\mpgcodec.h"

#ifndef ONLY_EXTERNAL_VISIBLE
#include "library\common\virtunit.h"
#endif

//
// Commands and parameters:
//
//		none                  : do nothing
//    start                 : start the operation
//    play([1..1000] speed) : play at specific speed (1000 = normal)
//    seek                  : stop playback, go standby
//    stop                  : stop playback
//    step(int frames)      : step some frames
//    freeze                : freeze current frame
//    resync                : resync after seek
//    end                   : end the operation
//
// State transition diagram
//
//	INITIAL:		reset
//
//	SRCSTATE		COMMAND/EVENT		DSTSTATE		ACTION
//
//	reset			start					initial		Init MPEG Decoder, start transfering data
// 				default				reset
//
//	initial		play					playing		Start playing the MPEG Stream
//					...					frozen		Freeze after first I-Frame
//
//	frozen		play					playing		Continue playing from current location
//					seek					seeking		Complete operation, and stop playback
//       		step					stepping		Go to step mode
//					end					reset
//					stop					stopped
//					default				frozen
//
//	playing		play					leaping		Adjust playback speed if required
//											playing
//					seek					seeking		Complete operation and stop playback
//					end					reset
//					stop					stopped
//					default				playing
//
// leaping     default           playing
//
//	stepping		play					playing
//					seek					seeking
//					end					reset
//					stop					stopped
//					default				stepping
//											frozen
//
//	seeking		resync				resyncing
//					resyncue				cued
//					end					reset
//
//	resyncing	play					playing
//					...					frozen
//
//	stopped		play					initial
//					end					reset
//					default				stopped
//

struct MPEGStreamMsg {
	DWORD		size;
	};

struct MPEGSignalMsg {
	DWORD		position;
	};

struct MPEGIdleMsg {
	};

struct MPEGErrorMsg {
	Error		error;
	};

MKHOOK(MPEGStream, MPEGStreamMsg)
MKHOOK(MPEGSignal, MPEGSignalMsg)
MKHOOK(MPEGIdle,   MPEGIdleMsg)
MKHOOK(MPEGError,  MPEGErrorMsg)

typedef MPEGStreamHook	__far *	MPEGStreamHookPtr;
typedef MPEGSignalHook	__far *	MPEGSignalHookPtr;
typedef MPEGIdleHook		__far *	MPEGIdleHookPtr;
typedef MPEGErrorHook	__far	*	MPEGErrorHookPtr;

enum MPEGStreamType {audioOnly, videoOnly, multiplexed};

enum MPEGStreamMode {singleStream, dualStream};

enum MPEGAudioLayer
	{
	MPAUDLAYER_1,
	MPAUDLAYER_2,
	MPAUDLAYER_3							// = MP3
	};

enum MPEGStereoMode
	{
	MPSS_NORMAL,							// Select output of first (normal) stereo program
	MPSS_DEFAULT = MPSS_NORMAL,
	MPSS_SECOND_STEREO					// Select output of second stereo program
	};

MKTAG(MPEG_AUDIO_BITRATE,					MPEG_DECODER_UNIT,	0x0001, DWORD)
MKTAG(MPEG_AUDIO_STREAMID,					MPEG_DECODER_UNIT,	0x0002, BYTE)
MKTAG(MPEG_VIDEO_STREAMID,					MPEG_DECODER_UNIT,	0x0003, BYTE)
MKTAG(MPEG_VIDEO_WIDTH,						MPEG_DECODER_UNIT,	0x0004, WORD)
MKTAG(MPEG_VIDEO_HEIGHT,   				MPEG_DECODER_UNIT,   0x0005, WORD)
MKTAG(MPEG_VIDEO_FPS,      				MPEG_DECODER_UNIT,   0x0006, WORD)
MKTAG(MPEG_STREAM_TYPE,						MPEG_DECODER_UNIT,	0x0007, MPEGStreamType)
MKTAG(MPEG_STREAM_HOOK,						MPEG_DECODER_UNIT,	0x0008, MPEGStreamHookPtr)
MKTAG(MPEG_LEFT_VOLUME,    				MPEG_DECODER_UNIT,   0x0009, WORD)
MKTAG(MPEG_RIGHT_VOLUME,   				MPEG_DECODER_UNIT,   0x000A, WORD)
MKTAG(MPEG_AUDIO_MUTE,     				MPEG_DECODER_UNIT,   0x000B, BOOL)
MKTAG(MPEG_SIGNAL_HOOK,						MPEG_DECODER_UNIT,	0x000C, MPEGSignalHookPtr)
MKTAG(MPEG_SIGNAL_POSITION,				MPEG_DECODER_UNIT,	0x000D, DWORD)
MKTAG(MPEG_DONE_HOOK,						MPEG_DECODER_UNIT,	0x000E, MPEGSignalHookPtr)
MKTAG(MPEG_VIDEO_BITRATE,					MPEG_DECODER_UNIT,   0x000F, DWORD)
MKTAG(MPEG_STREAM_BITRATE,					MPEG_DECODER_UNIT,   0x0010, DWORD)
MKTAG(MPEG_INTRA_QUANTIZER_MATRIX,		MPEG_DECODER_UNIT,	0x0011, BYTE __far *)
MKTAG(MPEG_NON_INTRA_QUANTIZER_MATRIX,	MPEG_DECODER_UNIT,	0x0012, BYTE __far *)
MKTAG(MPEG_VIDEOSTANDARD,					MPEG_DECODER_UNIT,	0x0013, VideoStandard)
#if TEST_PAL_TO_NTSC
MKTAG(MPEG_APP_VIDEOSTANDARD,				MPEG_DECODER_UNIT,	0x0014, VideoStandard)
MKTAG(MPEG_MOVING_IMG_STD,					MPEG_DECODER_UNIT,	0x0015, MovingImageStandard)
#endif
MKTAG(MPEG_STREAM_MODE,						MPEG_DECODER_UNIT,	0x0016, MPEGStreamMode)

MKTAG(MPEG_DISPLAY_WIDTH,					MPEG_DECODER_UNIT,	0x0020, WORD)
MKTAG(MPEG_DISPLAY_HEIGHT,					MPEG_DECODER_UNIT,	0x0021, WORD)

MKTAG(MPEG_VIDEO_BRIGHTNESS,				MPEG_DECODER_UNIT,	0x0022, WORD)
MKTAG(MPEG_VIDEO_CONTRAST,					MPEG_DECODER_UNIT,	0x0023, WORD)

MKTAG(MPEG_AUDIO_SAMPLERATE,				MPEG_DECODER_UNIT,	0x0024, WORD)
MKTAG(MPEG_IDLE_HOOK,						MPEG_DECODER_UNIT,	0x0025, MPEGIdleHookPtr)

MKTAG(MPEG_ASPECT_RATIO,					MPEG_DECODER_UNIT,	0x0026, WORD)
MKTAG(MPEG_SUPPORTS_HIRES_STILL,			MPEG_DECODER_UNIT,	0x0027, BOOL)

MKTAG(MPEG_CURRENT_STREAM_SEGMENT,		MPEG_DECODER_UNIT,	0x0028, DWORD)
MKTAG(MPEG_FIRST_STREAM_SEGMENT,			MPEG_DECODER_UNIT,	0x0029, DWORD)
MKTAG(MPEG_LAST_STREAM_SEGMENT,			MPEG_DECODER_UNIT,	0x002a, DWORD)

MKTAG(MPEG_DISPLAY_MODE,					MPEG_DECODER_UNIT,   0x0030, VideoMode)

// Determines the audio layer contained in the MPEG data/to be decoded
MKTAG(MPEG_AUDIO_LAYER,						MPEG_DECODER_UNIT,	0x0031, MPEGAudioLayer)

// CRC check enable/disable for MPEG (e.g. MP3) decoding (default: FALSE (off))
MKTAG(MPEG_CRC_CHECK,						MPEG_DECODER_UNIT,	0x0032, BOOL)

// Controls second stereo mode for MPEG audio material
MKTAG(MPEG_AUDIO_STEREO_MODE,				MPEG_DECODER_UNIT,	0x0033, MPEGStereoMode)

// Controls Deemphasis on DAC output
MKTAG(MPEG_AUDIO_DEEMPHASIS,				MPEG_DECODER_UNIT,	0x0034, BOOL)

MKTAG(MPEG_ERROR_HOOK,						MPEG_DECODER_UNIT,	0x0035, MPEGErrorHookPtr)


#ifndef ONLY_EXTERNAL_VISIBLE

#define MPEG_BUFF_SIZE	0x40000
#define MPEG_BUFF_ADD	0x01000

class MPEGParams {
	public:
		DWORD					audioBitRate;
		DWORD					videoBitRate;
		DWORD					streamBitRate;
		BYTE					audioStreamID;
		BYTE					videoStreamID;
		WORD					videoWidth;
		WORD					videoHeight;
		WORD					videoFPS;
		MPEGStreamType  	streamType;
		BYTE					intraQuantizerMatrix[64];
		BYTE					nonIntraQuantizerMatrix[64];
		VideoStandard		videoStandard;
		MPEGParams(void);
	};

class MPEGDecoder : public PhysicalUnit {
	friend class VirtualMPEGDecoder;
	protected:
		Error StreamHook(DWORD size);
		Error SignalHook(DWORD position);
		Error DoneHook(void);

		virtual DWORD RecoverData(HPTR data, DWORD size) = 0;
	public:
		virtual Error SendCommand(MPEGCommand com, DWORD param, DWORD __far &tag) = 0;
		Error DoCommand(MPEGCommand com, DWORD param);
		virtual Error CompleteCommand(DWORD tag) = 0;
		virtual DWORD SendData(HPTR data, DWORD size) = 0;
		virtual void CompleteData(void) = 0;
		virtual DWORD CurrentLocation(void) = 0;
		virtual MPEGState CurrentState(void) = 0;

		virtual Error SetSignal(DWORD position) = 0;

		virtual Error SetLeftVolume(WORD volume) = 0;
		virtual Error SetRightVolume(WORD volume) = 0;
		virtual Error MuteAudio(BOOL mute) = 0;

		virtual Error SetVideoStreamID(BYTE id) = 0;
		virtual Error SetAudioStreamID(BYTE id) = 0;
	};

class VirtualMPEGDecoder : public VirtualUnit {
	friend class MPEGDecoder;
	protected:
		HPTR					buffer;
		DWORD					buffPos;
		DWORD					buffStart;
		DWORD					buffFill;

		DWORD					signalPosition;

		MPEGParams			params;

#if !DRVDLL
		MPEGStreamHookHandle	streamHook;
		MPEGSignalHookHandle	signalHook;
		MPEGSignalHookHandle	doneHook;
#endif

		WORD					leftVolume;
		WORD					rightVolume;
		BOOL					audioMute;
		BOOL					completed;

		DWORD	FindNextValidHeader(void);

		virtual Error GetDisplaySize(WORD __far &width, WORD __far &height);
	private:
		MPEGDecoder		*	decoder;
	public:
		VirtualMPEGDecoder(MPEGDecoder * unit);
		~VirtualMPEGDecoder(void);

		Error Configure (TAG __far *tags);

		Error SendCommand(MPEGCommand com, DWORD param, DWORD __far &tag);
		Error DoCommand(MPEGCommand com, DWORD param);
		Error CompleteCommand(DWORD tag);

		MPEGState CurrentState(void);

		Error SendBuffer(void);
		Error RecoverBuffer(void);

		DWORD SendData(HPTR data, DWORD size);
		void CompleteData(void);

		DWORD CurrentLocation(void);
	};

inline Error MPEGDecoder::DoCommand(MPEGCommand com, DWORD param)
	{
	DWORD tag;

	GNREASSERT(SendCommand(com, param, tag));
	GNREASSERT(CompleteCommand(tag));

	GNRAISE_OK;
	}

inline Error VirtualMPEGDecoder::DoCommand(MPEGCommand com, DWORD param)
	{
	DWORD tag;

	GNREASSERT(SendCommand(com, param, tag));
	GNREASSERT(CompleteCommand(tag));

	GNRAISE_OK;
	}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\hardware\mpeg2enc\generic\mp2elenc.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// FILE:       library\hardware\mpeg2enc\generic\mp2elenc.h
// AUTHOR:		Martin Stephan
// COPYRIGHT:	(c) 1999 Viona Development GmbH.  All Rights Reserved.
// CREATED:		25.10.1999
//
// PURPOSE: 	MPEG2 elementary video/audio encoders and supporting classes. --- Header file
//
// HISTORY:
//

#ifndef MP2ELENC_H
#define MP2ELENC_H

#include "library/hardware/mpegenc/generic/mpegenc.h"

#ifndef ONLY_EXTERNAL_VISIBLE

class MPEG2ElementaryEncoder : public PhysicalUnit
   {
   friend class VirtualMPEG2ElementaryEncoder;

   protected:
		Error TransferDoneHook(void);
		Error BufferStarvingHook(void);

		virtual Error DoCommand(MPEGCommand com, DWORD param) = 0;
		virtual Error AddBuffer(HPTR data, DWORD size) = 0;
		virtual MPEGState CurrentState(void) = 0;

	public:
		MPEG2ElementaryEncoder(void) {;}

	};

class VirtualMPEG2ElementaryEncoder : public VirtualUnit
	{
	friend class MPEG2ElementaryEncoder;

	private:
		MPEG2ElementaryEncoder	*	encoder;

	protected:
#if !DRVDLL
		MPEGTransferDoneHookHandle				doneHook;
		MPEGEncoderBufferStarvingHookHandle bufferStarvingHook;
#endif
		Error PreemptStopPrevious(VirtualUnit * previous);
      Error PreemptChange(VirtualUnit * previous);
      Error PreemptStartNew(VirtualUnit * previous);

	public:
		VirtualMPEG2ElementaryEncoder(MPEG2ElementaryEncoder * unit);
		~VirtualMPEG2ElementaryEncoder(void);

		Error Configure (TAG __far *tags);
		virtual Error AddBuffer(HPTR data, DWORD size);
		virtual Error AllocateBuffer (DWORD size, FPTR __far &info, FPTR __far &data) { GNRAISE(GNR_UNIMPLEMENTED); }
		virtual Error FreeBuffer (FPTR info) { GNRAISE(GNR_UNIMPLEMENTED); }
		virtual Error DoCommand(MPEGCommand com, DWORD param);

	};

class MPEG2VideoEncoder : public MPEG2ElementaryEncoder
	{
	friend class VirtualMPEG2VideoEncoder;

	protected:
		virtual Error SetOutputStreamType(MPEGEncoderStreamType outputStreamType) = 0;
		virtual Error SetVideoSource(VideoSource source) = 0;
		virtual Error SetVideoStandard(VideoStandard	standard) = 0;
		virtual Error SetAspectRatio(WORD aspectRatio) = 0;
		virtual Error SetFrameRate(DWORD frameRate) = 0;
		virtual Error SetVideoBitrate(DWORD videoBitrate) = 0;
		virtual Error SetAudioBitrate(DWORD audioBitrate) = 0;
		virtual Error SetVideoWidth(WORD width) = 0;
		virtual Error SetVideoHeight(WORD height) = 0;

	public:

	};

class VirtualMPEG2VideoEncoder : public VirtualMPEG2ElementaryEncoder
	{
	private:
		MPEG2VideoEncoder	*		encoder;

	protected:
		MPEGEncoderStreamType	outputStreamType;
		VideoSource					videoSource;
		VideoStandard				videoStandard;

		Error PreemptChange(VirtualUnit * previous);

	public:
		VirtualMPEG2VideoEncoder(MPEG2VideoEncoder * unit) : VirtualMPEG2ElementaryEncoder(unit)
			{encoder = unit; outputStreamType = MST_UNKNOWN; videoSource = VIDEOSOURCE_MIN;
			 videoStandard = VIDEOSTANDARD_MIN;}

		Error Configure(TAG __far * tags);
	};

class MPEG2AudioEncoder : public MPEG2ElementaryEncoder
	{
	public:

	};

class VirtualMPEG2AudioEncoder : public VirtualMPEG2ElementaryEncoder
	{
	private:
		MPEG2AudioEncoder	* encoder;
	protected:
		Error PreemptChange(VirtualUnit * previous);
	public:
		VirtualMPEG2AudioEncoder(MPEG2AudioEncoder	* encoder) : VirtualMPEG2ElementaryEncoder(encoder)
			{this->encoder = encoder;}

		Error Configure (TAG __far *tags);
	};


#endif // ONLY_EXTERNAL_VISIBLE

#endif // MP2ELENC_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\hardware\video\generic\l21recvr.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// FILE:			library\hardware\video\generic\l21recvr.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 2000 VIONA Development.  All Rights Reserved.
// CREATED:		02.03.2000
//
// PURPOSE:		Line 21 Data Stream Receiver Base Class
//
// HISTORY:

#ifndef L21RECVR_H
#define L21RECVR_H

#include "library/common/prelude.h"

#ifndef ONLY_EXTERNAL_VISIBLE

class Line21Receiver
	{
	public:
		virtual Error AddCloseCaptionData(BOOL startField, BYTE __far * data, int num) = 0;
		virtual Error FlushCloseCaptionBuffer(void) = 0;
		virtual Error StartCloseCaptionTransfer(void) = 0;
		virtual Error StopCloseCaptionTransfer(void) = 0;
	};

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\hardware\video\generic\VIDCHIP.H ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


// FILE:      library\hardware\video\generic\vidchip.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   24.03.95
//
// PURPOSE: The abstract class for video decoder/encoder chip programming.
//
// HISTORY:

#ifndef VIDEOCHIP_H
#define VIDEOCHIP_H

#include "library\common\gnerrors.h"
#include "library\common\tags.h"
#include "library\common\tagunits.h"

#ifndef ONLY_EXTERNAL_VISIBLE
#include "library\common\virtunit.h"
#endif

#include "vidtypes.h"


MKTAG (VID_VIDEOSTANDARD,				VIDEO_CHIP_UNIT, 0x0001, VideoStandard)
MKTAG (VID_MODE,							VIDEO_CHIP_UNIT, 0x0002, VideoMode    )
MKTAG (VID_EXTSYNC,						VIDEO_CHIP_UNIT, 0x0003, BOOL         )
MKTAG (VID_PAL_VIDEOSUBSTANDARD,		VIDEO_CHIP_UNIT, 0x0004, PALVideoSubStandard)
MKTAG (VID_NTSC_VIDEOSUBSTANDARD,	VIDEO_CHIP_UNIT, 0x0005, NTSCVideoSubStandard)


#ifndef ONLY_EXTERNAL_VISIBLE

class VideoChip : public PhysicalUnit {
	public:
		virtual Error SetVideoStandard(VideoStandard std) = 0;
		virtual Error SetMode(VideoMode mode) = 0;
		virtual Error SetExtSync(BOOL extsync) = 0;
		virtual Error SetPALVideoSubStandard(PALVideoSubStandard palSubStandard) {GNRAISE_OK;}
		virtual Error SetNTSCVideoSubStandard(NTSCVideoSubStandard ntscSubStandard) {GNRAISE_OK;}
	};

class VirtualVideoChip : public VirtualUnit {
	protected:
		VideoStandard			standard;
#if TEST_PAL_TO_NTSC
		MovingImageStandard	movingImageStandard;		// current moving Image standard
#endif
		PALVideoSubStandard	palSubStandard;
		NTSCVideoSubStandard	ntscSubStandard;
		VideoMode		mode;
		BOOL				extSync;
		VideoChip	*	chip;

		Error Preempt(VirtualUnit *previous);
	public:
		VirtualVideoChip (VideoChip *physical);
		Error Configure(TAG __far * tags);
	};



#endif // ONLY_EXTERNAL_VISIBLE




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\hardware\video\generic\VIDDEC.H ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


// FILE:      library\hardware\video\generic\viddec.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   24.03.95
//
// PURPOSE: The abstract class for video decoder programming.
//
// HISTORY:

#ifndef VIDEODECODER_H
#define VIDEODECODER_H

#include "library\common\gnerrors.h"
#include "vidchip.h"


#ifndef ONLY_EXTERNAL_VISIBLE

#include "library\lowlevel\hardwrio.h"

#endif

#define MAX_Brightness  10000
#define MAX_Contrast    10000
#define MAX_Saturation  10000
#define MAX_Hue         10000


#define VIDDEC_InputNameMaxSize  40

struct VideoDecoderInputEntry
	{
	TCHAR name[VIDDEC_InputNameMaxSize];
	};


// Note that the tag enumeration must start after those of VideoChipClass !

MKTAG (DEC_INPUT_NUMBER, VIDEO_DECODER_UNIT, 0x0001001, WORD)
MKTAG (DEC_INPUT_NAMES,  VIDEO_DECODER_UNIT, 0x0001002, VideoDecoderInputEntry __far *)
MKTAG (DEC_INPUT,        VIDEO_DECODER_UNIT, 0x0001003, WORD)
// Each decoder has its own number of input lines. For flexibility, you ask
// for the number of input lines by GET_DEC_INPUT_NUMBER, then allocate enough
// space to hold DEC_INPUT_NUMBER times a struct VideoDecoderInputEntry,
// then call DEC_INPUT_NAMES to get an array of these structs filled
// with DEC_INPUT_NUMBER entries.

MKTAG (DEC_BRIGHTNESS, VIDEO_DECODER_UNIT, 0x0001004, WORD)
MKTAG (DEC_CONTRAST,   VIDEO_DECODER_UNIT, 0x0001005, WORD)
MKTAG (DEC_SATURATION, VIDEO_DECODER_UNIT, 0x0001006, WORD)
MKTAG (DEC_HUE,        VIDEO_DECODER_UNIT, 0x0001007, WORD)

MKTAG (DEC_DETECT_STD, VIDEO_DECODER_UNIT, 0x0001008, VideoStandard)
MKTAG (DEC_SAMPLEMODE, VIDEO_DECODER_UNIT, 0x0001009, VideoSampleMode)
MKTAG (DEC_TELETEXT,   VIDEO_DECODER_UNIT, 0x0002001, BOOL)


// Errors from the video decoder.

#define GNR_VDEC_PARAMS		MKERR(ERROR, VDECODER, PARAMS,   0x01)
	// illegal parameters

#define GNR_VDEC_NODETECT	MKERR(ERROR, VDECODER, PARAMS,   0x02)
	// video standard not detected



#ifndef ONLY_EXTERNAL_VISIBLE


class VideoDecoder : public VideoChip
	{
	friend class VirtualVideoDecoder;

	protected:
		VirtualUnit	*videoBus;
		WORD numInputs;
		VideoDecoderInputEntry __far *inputNames;

		Error Lock (VirtualUnit *unit);
		Error Unlock (VirtualUnit *unit);

	public:
		BitInputPort *signalPort;

		VideoDecoder (VirtualUnit *videoBus, WORD numInputs = 0, VideoDecoderInputEntry __far *inputNames = NULL)
			{
			this->videoBus   = videoBus;
			this->numInputs  = numInputs;
			this->inputNames = inputNames;
			this->signalPort = NULL;
			}

		virtual Error SetInput (WORD input) = 0;
		virtual Error SetBrightness (WORD brightness) = 0;
		virtual Error SetContrast (WORD contrast) = 0;
		virtual Error SetSaturation (WORD saturation) = 0;
		virtual Error SetHue (WORD hue) = 0;
		virtual Error SetSampleMode (VideoSampleMode mode) = 0;
		virtual Error SetTeletextMode (BOOL mode) {GNRAISE_OK;}

		virtual Error DetectVideoStandard (VideoStandard __far &std) = 0;
	};


class VirtualVideoDecoder : public VirtualVideoChip
	{
	protected:
		VideoDecoder	*	decoder;

		WORD 					input;
		WORD					brightness;
		WORD					contrast;
		WORD					saturation;
		WORD					hue;
		VideoSampleMode	sampleMode;
		BOOL					teletext;

		Error Preempt(VirtualUnit *previous);

	public:
		VirtualVideoDecoder(VideoDecoder *physical);
		Error Configure(TAG __far * tags);
	};



#endif // ONLY_EXTERNAL_VISIBLE



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\hardware\drives\specific\XBOXDVDDrive.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef XBOXDVDDRIVE_H
#define XBOXDVDDRIVE_H

#include "library\common\prelude.h"
#define DEVICE_TYPE DWORD
#include "library\common\krnlsync.h"
#include "library\hardware\drives\generic\BlockBufferCDVDDrive.h"


typedef ULONG DVD_SESSION_ID, *PDVD_SESSION_ID;



////////////////////////////////////////////////////////////////////
//
//  W2K Drive Block Buffer Class
//
////////////////////////////////////////////////////////////////////

class W2KDriveBlockBuffer : public ScatterDriveBlockBuffer
	{
	protected:
		void AllocateData(DWORD size)				{ data = (BYTE*)::VirtualAlloc(NULL, size, MEM_COMMIT, PAGE_READWRITE); }
		void FreeData(void)							{ ::VirtualFree(data, 0, MEM_RELEASE);	}

	public:
		W2KDriveBlockBuffer(void) : ScatterDriveBlockBuffer() {}
		// W2KDriveBlockBuffer(DWORD blockNum, DWORD blockSize) : ScatterDriveBlockBuffer(blockNum, blockSize) {}
		virtual ~W2KDriveBlockBuffer(void)	{ if (data) ::VirtualFree(data, 0, MEM_RELEASE); }
	};

////////////////////////////////////////////////////////////////////
//
//  NT5 CDVD Drive Class
//
////////////////////////////////////////////////////////////////////

class XBOXDVDDrive : public BlockBufferCDVDDrive
	{
	private:
		KernelString internalDriveName;
		DWORD blockDiff;
		BYTE	singleBlockCacheBuffer[2048];
		DWORD	singleBlockCacheBlock;
		enum	StreamingMode {SMD_UNKNOWN, SMD_STREAMING, SMD_NAVIGATING} streamingMode ;
	protected:
		DVD_SESSION_ID sessionId;
		TCHAR				deviceName[16];
		int				lockCount;
		HANDLE			hDevice;

		DWORD				spindleSpeed;
		DWORD				successfulReadSectors;

		bool				encryptionInfoValid;
		bool				encryptionInfo;

		//
		//  DVD authentication
		//

		virtual Error StartAuthentication(void);
		virtual Error SendChallengeKey(BYTE * key);
		virtual Error GetBusKey(BYTE * key);
		virtual Error GetChallengeKey(BYTE * key);
		virtual Error SendBusKey(BYTE * key);
		virtual Error GetDiskKey(BYTE * key);
		virtual Error CompleteAuthentication(void);
		virtual Error CancelAuthentication(void);
		virtual Error GetTitleKey(DWORD block, BYTE * key);

		Error				GetDevice(BOOL forced=false);
		Error				CloseDevice();

		virtual Error GetDVDType(PhysicalDiskType & type);
		virtual Error GetCDType(PhysicalDiskType & type);

		//
		//  Data Access
		//

		virtual Error ReadDVDBlocks(DWORD block, DWORD num, BYTE * buffer, DWORD flags);
		virtual Error ReadCDBlocks(DWORD block, DWORD num, BYTE * buffer, DWORD flags);
		Error			  ReadCDASubchannel(void __far * subchannel);


		virtual Error SetStreamingMode(bool streaming);

		//
		//	Memory Allocation
		//
		virtual DriveBlockBuffer * CreateDriveBlockBuffer(void);

	public:
		XBOXDVDDrive();
		~XBOXDVDDrive();

		virtual Error Init(DriveControlInfo * info, GenericProfile * profile);
		virtual Error Cleanup(void);


//
		//  Inquiry & config functions
		//
		/*
		virtual Error GetDriveCaps(GenericDriveType & type, DWORD & caps, DWORD & slots);
		*/

		//
		//  Basic Drive Functions
		//

		virtual Error SpinUp(void);												// Spin up drive
		virtual Error SpinDown(void);												// Spin down drive
		virtual Error TerminateRequest(RequestHandle * rh);				// Terminate the current request (read/write)
		virtual Error Flush(void);													// Make sure all commands are executed

		//
		//  Media handling
		//

		virtual Error LoadMedia (int slotNumber = 0, DWORD flags = LMF_WAIT);
		virtual Error UnloadMedia (DWORD flags = UMF_WAIT);

		virtual Error GetTrayStatus(GenericTrayStatus & status);			// Get Tray Status, was: GetDriveStatus
		virtual Error LockTray(void);												// Lock Tray
		virtual Error UnlockTray(void);											// Unlock Tray

		virtual Error GetDiskType(PhysicalDiskType & type);				// DVD, CD Rom, Audio CD, ...
		virtual Error GetVolumeID(VolumeID & volumeID);
		virtual Error GetCopyManagementInfo(DWORD block, GenericCopyManagementInfo & gcmi);

		//
		//  Data access functions
		//

		virtual Error SeekBlock(DWORD block, DWORD flags, RequestHandle * rh);
		virtual Error LockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh);

		//
		//  DVD authentication and region coding
		//

		virtual Error DVDIsEncrypted(BOOL & enc);
		virtual Error GetRPCData(BOOL & isRPC2, BYTE & regionCode, BYTE & availSets);
		virtual Error SetRegionCode(BYTE region);

		//
		//  CD Access Methods
		//

		virtual Error GetNumberOfSessions(WORD & num);
		virtual Error ReadCDTOC(WORD session, CDSessionType & sessionType, CDTocEntry * & toc, WORD & tocEntryNum, RequestHandle * rh);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\hardware\video\generic\VIDENC.H ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


// FILE:      library\hardware\video\generic\videnc.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   24.03.95
//
// PURPOSE: The abstract class for video encoder programming.
//
// HISTORY:

#ifndef VIDEOENCODER_H
#define VIDEOENCODER_H

#include "library\common\gnerrors.h"

#ifndef ONLY_EXTERNAL_VISIBLE
#include "library\common\profiles.h"
#include "library\lowlevel\intrctrl.h"
#endif

#include "vidchip.h"
#include "l21recvr.h"



MKTAG (ENC_SAMPLEMODE,						VIDEO_ENCODER_UNIT, 0x1001, VideoSampleMode)
MKTAG (ENC_HOFFSET,							VIDEO_ENCODER_UNIT, 0x1002, int)
MKTAG (ENC_VOFFSET,							VIDEO_ENCODER_UNIT, 0x1003, int)

// The idle screen mapping depends on the specific video encoder. First ask
// for the number of entries via GET_ENC_IDLE_NUMBER, then allocate enough
// space to hold ENC_IDLE_NUMBER times a struct VideoEncoderIdleEntry,
// then call GET_ENC_IDLE_ENTRY to get an array of these structs filled
// with ENC_IDLE_NUMBER entries.

#define VIDENC_IdleNameMaxSize  40

struct __far VideoEncoderIdleEntry
	{
	int number;   // in increasing order
	TCHAR name[VIDENC_IdleNameMaxSize];
	};

MKTAG (ENC_IDLESCREEN,						VIDEO_ENCODER_UNIT, 0x1004, int)   // global for all units
MKTAG (ENC_IDLE_NUMBER,						VIDEO_ENCODER_UNIT, 0x1005, int)   // global for all units
MKTAG (ENC_IDLE_ENTRY,						VIDEO_ENCODER_UNIT, 0x1006, VideoEncoderIdleEntry __far *)   // global for all units

MKTAG (ENC_COPY_PROTECTION,				VIDEO_ENCODER_UNIT, 0x1007, int)

MKTAG (ENC_CHROMA_FILTER,					VIDEO_ENCODER_UNIT, 0x1008, DWORD)

MKTAG (ENC_SVIDEO_ACTIVE,					VIDEO_ENCODER_UNIT, 0x1009, BOOL)

enum OutputSelect
	{
	ENC_TV,
	ENC_VCR,
	VCR_TV
	};

MKTAG (ENC_SET_OUTPUT,						VIDEO_ENCODER_UNIT, 0x1000a, OutputSelect)
MKTAG (ENC_SET_PRESENTATION_MODE,		VIDEO_ENCODER_UNIT, 0x1000b, VideoPresentationMode)

enum ComponentOutputMode
	{
	VCOMPOM_DEFAULT,	// let the Video Encoder implementation decide
	VCOMPOM_DISABLE,	// force to no output
	VCOMPOM_YUV,
	VCOMPOM_RGB
	};

// Selects which type of component output to use
MKTAG (ENC_COMPONENT_OUTPUT,				VIDEO_ENCODER_UNIT, 0x1020, ComponentOutputMode)

// Used for CGMS information
MKTAG (ENC_COPY_MODE,						VIDEO_ENCODER_UNIT, 0x1025, VideoCopyMode)

// Set the following from 0 to 10000. 5000 is neutral (default) setting
MKTAG (ENC_BRIGHTNESS,						VIDEO_ENCODER_UNIT, 0x1030, WORD)
MKTAG (ENC_CONTRAST,							VIDEO_ENCODER_UNIT, 0x1031, WORD)
MKTAG (ENC_SATURATION,						VIDEO_ENCODER_UNIT, 0x1032, WORD)
MKTAG (ENC_HUE,								VIDEO_ENCODER_UNIT, 0x1033, WORD)

MKTAG (ENC_ACTIVE_MUX_SRC,					VIDEO_ENCODER_UNIT, 0x3000, VideoMuxSource)
	// VIDEOMUXSRC_INTERNAL or VIDEOMUXSRC_EXTERNAL
MKTAG (ENC_LINE_MODE,						VIDEO_ENCODER_UNIT, 0x3001, VideoLineMode)
	// VLM_PROGRESSIVE or VLM_INTERLACED
MKTAG (ENC_PIXCLK_MODE,						VIDEO_ENCODER_UNIT, 0x3002, VideoPixClockMode)
	// VIDEOPIXCLK_INTERNAL or VIDEOPIXCLK_EXTERNAL
MKTAG (ENC_EMBEDDED_SYNC,					VIDEO_ENCODER_UNIT, 0x3003, BOOL)
MKTAG (ENC_HSYNC_POLARITY,					VIDEO_ENCODER_UNIT, 0x3005, BOOL)
MKTAG (ENC_VSYNC_POLARITY,					VIDEO_ENCODER_UNIT, 0x3006, BOOL)
MKTAG (ENC_STARTACTIVEPIXEL_DELAY,		VIDEO_ENCODER_UNIT, 0x3007, int)

// Errors from the video encoder.

#define GNR_VENC_PARAMS						MKERR(ERROR, VENCODER, PARAMS,  0x01)
	// illegal parameters
#define GNR_MACROVISION_NOT_SUPPORTED	MKERR(ERROR, VENCODER, GENERAL, 0x02)

#define GNR_CC_NOT_SUPPORTED				MKERR(ERROR, VENCODER, GENERAL, 0x03)

#ifndef ONLY_EXTERNAL_VISIBLE


class VideoEncoder : public VideoChip
	{
	friend class VirtualVideoEncoder;

	protected:
		GenericProfile *profile;
		int idleScreen;
		int nIdleScreens;
		VideoEncoderIdleEntry __far *idleEntries;
		BOOL svideoActive;

	public:
		VideoEncoder (GenericProfile *profile = NULL, int nIdleScreens = 0,
		              VideoEncoderIdleEntry __far *idleEntries = NULL);

		// Dynamic type conversion routine to InterruptHandeler
		virtual InterruptHandler * ToInterruptHandler(void)	{return NULL;}
#if TEST_PAL_TO_NTSC
		virtual Error SetVideoStandard (VideoStandard standard)			{GNRAISE_OK;}
		virtual Error SetMovingImageStandard (MovingImageStandard mis)	{GNRAISE_OK;}
#endif
		virtual Error SetSampleMode (VideoSampleMode mode) = 0;
		virtual Error SetHOffset (int offset) = 0;
		virtual Error SetVOffset (int offset) = 0;
		virtual Error SetIdleScreen (int idleScreen);
		virtual Error SetCopyProtection(int protection)					{GNRAISE_OK;}
		virtual Error SetChromaFilter(DWORD frequency)					{GNRAISE_OK;}
		virtual Error SetSVideoActive (BOOL active)						{GNRAISE_OK;}
		virtual Error SetComponentOut (ComponentOutputMode compOut)	{GNRAISE_OK;}
		virtual void DeactivateOutputs (void) = 0;
		virtual void ReactivateOutputs (void) = 0;
	};


class VirtualVideoEncoder : public VirtualVideoChip
	{
	protected:
		VideoEncoder			*encoder;
		VideoSampleMode		sampleMode;
		int						hOffset, vOffset;   // from 7110/7111 timing
		int						copyProtection;
		DWORD						chromaFilterFrequency;
		ComponentOutputMode	compOut;

		Error Preempt (VirtualUnit *previous);
	public:
		VirtualVideoEncoder (VideoEncoder *encoder);
		Error Configure (TAG __far * tags);

		// Dynamic type conversion routine to Line21Receiver
		virtual Line21Receiver * ToLine21Receiver(void) {return NULL;}
	};

#endif // ONLY_EXTERNAL_VISIBILE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\hardware\mpegenc\generic\mpegenc.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// FILE:       library\hardware\mpegenc\generic\mpegenc.h
// AUTHOR:		Martin Stephan
// COPYRIGHT:	(c) 1999 Viona Development GmbH.  All Rights Reserved.
// CREATED:		26.10.1999
//
// PURPOSE: 	MPEG encoder and supporting classes. --- Header file
//
// HISTORY:
//

#ifndef MPEGENC_H
#define MPEGENC_H

#include "library/common/vddebug.h"
#include "library/common/tags.h"
#include "library/common/hooks.h"
#include "library/common/tagunits.h"
#include "library/common/virtunit.h"
#include "library/hardware/video/generic/vidtypes.h"
#include "library/hardware/mpgcodec/generic/mpgcodec.h"


struct MPEGTransferDoneMsg {
	};

struct MPEGEncoderBufferStarvingMsg {
	};


MKHOOK(MPEGTransferDone, MPEGTransferDoneMsg)
MKHOOK(MPEGEncoderBufferStarving, MPEGEncoderBufferStarvingMsg)


typedef MPEGTransferDoneHook	__far *	MPEGTransferDoneHookPtr;
typedef MPEGEncoderBufferStarvingHook __far *  MPEGEncoderBufferStarvingHookPtr;


enum MPEGEncoderStreamType
	{
	MST_UNKNOWN					= 0x00,
	MST_AUDIO_ELEMENTARY		= 0x01,
	MST_VIDEO_ELEMENTARY		= 0x02,
	MST_PROGRAM					= 0x03,
	MST_TRANSPORT				= 0x04,
	MST_PACKET_ELEMENTARY	= 0x05,
	MST_PACKET_VIDEO_ES		= 0x06,
	MST_PACKET_AUDIO_ES		= 0x07,
	MST_MPEG1					= 0x08
	};


MKTAG(MPEG_TRANSFER_DONE_HOOK,		MPEG_ENCODER_UNIT,	0x0001, MPEGTransferDoneHookPtr)
MKTAG(MPEG_ENCODER_BUFFER_STARVING, MPEG_ENCODER_UNIT,   0x0002, MPEGEncoderBufferStarvingHookPtr)
MKTAG(MPEG_ENC_OUTPUT_TYPE,			MPEG_ENCODER_UNIT,   0x0003, MPEGEncoderStreamType)
MKTAG(MPEG_ENC_VIDEO_SOURCE,			MPEG_ENCODER_UNIT,	0x0004, VideoSource)
MKTAG(MPEG_ENC_VIDEOSTANDARD,			MPEG_ENCODER_UNIT,	0x0005, VideoStandard)
//MKTAG(MPEG_ENC_VIDEO_WIDTH,	MPEG_ENCODER_UNIT,	0x0002, WORD)
//MKTAG(MPEG_ENC_VIDEO_HEIGHT,  MPEG_ENCODER_UNIT,   0x0003, WORD)

//
// Previous definition conflicted with decoder definition.
// Should move shared defines to hardware\mpgcodec\generic\mpgcodec.h"
//
//#include "library\hardware\mpegdec\generic\mpegdec.h"

#endif // MPEGENC_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\hardware\videodma\generic\colctrlr.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// FILE:      library\hardware\videodma\generic\colctrlr.h
// AUTHOR:    S. Herr
// COPYRIGHT: (c) 1998 VIONA Development GmbH. All Rights Reserved.
// CREATED:   05.06.1998
//
// PURPOSE:   Abstract Color Controller class
//
// HISTORY:

#ifndef COLCTRLR_H
#define COLCTRLR_H

#include "library/common/prelude.h"

#define PCCF_BRIGHTNESS					0x00000001l
#define PCCF_CONTRAST					0x00000002l
#define PCCF_HUE							0x00000004l
#define PCCF_SATURATION					0x00000008l
#define PCCF_SHARPNESS					0x00000010l
#define PCCF_GAMMA						0x00000020l
#define PCCF_RED_BRIGHTNESS			0x00001000l
#define PCCF_BLUE_BRIGHTNESS			0x00002000l
#define PCCF_GREEN_BRIGHTNESS			0x00004000l

#ifndef ONLY_EXTERNAL_VISIBLE

struct ColorControlValues
	{
	WORD ccBrightness;
	WORD ccContrast;
	WORD ccSaturation;
	WORD ccHue;
	WORD ccGamma;
	WORD ccSharpness;
	BOOL ccColorEnable;
	WORD ccRedBrightness;
	WORD ccGreenBrightness;
	WORD ccBlueBrightness;
	};

class ColorController
	{
	public:
		virtual WORD  GetColorControl() = 0;
		virtual Error SetColorControlValues(ColorControlValues __far & clrCtrl) = 0;
	};

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\lowlevel\TIMER.H ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


// FILE:      library\lowlevel\timer.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   17.03.95
//
// PURPOSE: The timer class.
//
// HISTORY:

#ifndef TIMER_H
#define TIMER_H

#include "..\common\prelude.h"

class TimerClass {
	private:
		static int timerClassInited;
		static int nanoDelay;
	public:
		TimerClass (void);
		virtual void WaitMicroSecs (DWORD micros);
		virtual void WaitMilliSecs (DWORD millis);
		virtual DWORD GetMilliTicks (void);
		virtual DWORD GetMicroTicks (void);
	};


#if VXD_VERSION

class VxDTimerClass : public TimerClass
	{
	private:
		DWORD	vxdTimerHandle;

	public:
		VxDTimerClass(DWORD vxdTimerHandle) {this->vxdTimerHandle = vxdTimerHandle;}

		void WaitMilliSecs (DWORD millis);
	};

#define Timer (*globalTimer)
extern TimerClass * globalTimer;

#elif NT_KERNEL

#define Timer (*globalTimer)
extern TimerClass * globalTimer;

#else

extern TimerClass Timer;

#endif // VXD_VERSION



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\hardware\tuner\generic\TVTUNER.H ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// FILE:			library\hardware\tuner\generic\tvtuner.h
// AUTHOR:		Stefan Herr
// COPYRIGHT:	(c) 1995 Viona Development.  All Rights Reserved.
// CREATED:		17.07.95
//
// PURPOSE:		Definition of abstract base class for TV tuners
//
// HISTORY:

#ifndef TVTUNER_H
#define TVTUNER_H

#include "library\common\gnerrors.h"
#include "library\common\tags.h"
#include "library\common\tagunits.h"
#include "library\common\hooks.h"
#include "library\hardware\audio\generic\stereodc.h"

#ifndef ONLY_EXTERNAL_VISIBLE

#include "library\lowlevel\hardwrio.h"
#include "library\common\virtunit.h"

#endif


/////////////////////////////////////////////////////////////////////////////////////////////
// Definitions of helper data structures
/////////////////////////////////////////////////////////////////////////////////////////////

// number of available TV standards
#define STDS_NUM 10

// This struct defines the necessary properties of a TV standard for the purposes of
// this low-level driver
typedef struct
	{
	DWORD		minFreq;			// minimal allowed frequency
	DWORD		lowLimit,		// frequency limit for the LOW band [10^2 Hz]
				midLimit,		// frequency limit for the MID band [10^2 Hz]
				highLimit;		// frequency limit for the HIGH band [10^2 Hz]
	DWORD		visionIF;		// IF frequency [10^2 Hz]
	DWORD		stepSize;		// Scan step size.
	}  TVStdProperty;

// Define directions for automatic station search
enum Direction {SCAN_UP, SCAN_DOWN};	// SCAN_UP: search towards higher frequencies
													// SCAN_DOWN: search towards lower frequencies

// Defines which TV standards are available
enum TVTunerTVStandard { MIN_TV_STD = 0,
								 PAL_AIR=0, PAL_CABLE,
								 NTSC_AIR,  NTSC_CABLE,
				   			 SECAM_AIR, SECAM_CABLE,
				   			 JAPAN_AIR, JAPAN_CABLE,
				   			 PAL_I_AIR, PAL_I_CABLE,
				   			 MAX_TV_STD = PAL_I_CABLE };

// Define bands
enum TVTunerBands { MIN_BAND		=	0,
						  BAND_LOW		=	0,
						  BAND_MID,
						  BAND_HIGH,
						  MAX_TV_BAND	=	BAND_HIGH,
						  BAND_FM,							// Extension for tuners with FM reception capability
						  MAX_BAND		=	BAND_FM
						};


// Result of stepwise scan function (StepScan)
enum ScanResult {STATION_FOUND,				// A station was found during the last step
					  NO_STATION,					// No station was found.
					  UPPER_LIMIT,					// Upper limit of frequency range reached.
					  LOWER_LIMIT					// Lower limit reached.
					 };

// Step ratio for tuner
enum StepRatioSelect {STEP_AUTOMATIC,		// Step is chosen according to FM enable
							 STEP_SIZE_50,			// One step is 50		kHz, used for FM and PAL TV
							 STEP_SIZE_31_25,		//					31.25	kHz, currently NOT SUPPORTED!!
							 STEP_SIZE_62_5		//					62.5	kHz, used for NTSC TV
							};

/////////////////////////////////////////////////////////////////////////////////////////////
// Definition of callback hook for station scans
/////////////////////////////////////////////////////////////////////////////////////////////

struct TVScanMsg
	{
	DWORD				frequency;
	WORD				level;
	};

MKHOOK(TVScan, TVScanMsg)

typedef TVScanHook __far * TVScanHookPtr;

/////////////////////////////////////////////////////////////////////////////////////////////
// Tag definitions for TV tuners
/////////////////////////////////////////////////////////////////////////////////////////////

MKTAG (TVT_TVSTANDARD,		TV_TUNER_UNIT, 0x0001, TVTunerTVStandard)	// used to set TV standard
MKTAG (TVT_FREQUENCY ,		TV_TUNER_UNIT, 0x0002, DWORD)					// current frequency for channel (10^2 Hz units)
MKTAG (TVT_SIGNAL_LEVEL,	TV_TUNER_UNIT, 0x0004, WORD)					// Tag to get the signal level of the station
																							// on the current frequency. Not always supported.
																							// Value range 0 - 10000.
MKTAG (TVT_CHARGEPUMP,		TV_TUNER_UNIT, 0x1001, BOOL)					// 1: fast tuning, 0: slow but
																							// more precise tuning
MKTAG (TVT_PLLDISABLE,		TV_TUNER_UNIT, 0x1002, BOOL)					// 1: manual tuning, 0: normal op.
MKTAG (TVT_STEREO,	   	TV_TUNER_UNIT, 0x1003, BOOL)					// 1: Stereo,  0: Mono
MKTAG (TVT_MUTE,		   	TV_TUNER_UNIT, 0x1004, BOOL)					// 1: sound off,  0: sound on

MKTAG (TVT_STEPSIZE,			TV_TUNER_UNIT, 0x1008, StepRatioSelect)	// Default: automatic
MKTAG (TVT_FMENABLE,			TV_TUNER_UNIT, 0x1009, BOOL)					// Switch to FM band. Default: FALSE
MKTAG	(TVT_MODEDETECT,		TV_TUNER_UNIT, 0x100a, SignalMode)			// Used to inquire signal type
MKTAG (TVT_MODESELECT,		TV_TUNER_UNIT, 0x100b, SignalMode)			// Used to force certain reception mode

/////////////////////////////////////////////////////////////////////////////////////////////
// Error definitions for CTVTuner
/////////////////////////////////////////////////////////////////////////////////////////////

// An illegal TV standard was supported by the caller
#define GNR_TVT_ILLEGAL_TV_STD		MKERR(ERROR, TVTUNER, BOUNDS, 0x01)

// The provided frequency is not in the valid range for the given TV standard
#define GNR_TVT_ILLEGAL_FREQUENCY	MKERR(ERROR, TVTUNER, BOUNDS, 0x02)

// It was not possible to lock the PLL. Certainly this message will occur, if the PLL is
// disabled
#define GNR_TVT_PLL_NOT_LOCKED		MKERR(ERROR, TVTUNER, BUSY,   0x03)

// It is not possible to execute the action because this virtual unit is not the "current"
// one possessing the hardware
#define GNR_TVT_NOT_CURRENT			MKERR(ERROR, TVTUNER, INACTIVE, 0x04)

// Function not yet implemented.
#define GNR_TVT_NOT_IMPLEMENTED		MKERR(ERROR, TVTUNER, GENERAL, 0x05)

// ScanStation couldn't find a station.
#define GNR_TVT_NO_STATION_FOUND		MKERR(ERROR, TVTUNER, GENERAL, 0x06)

// ScanStaion with SCAN_DOWN reached the lower limit.
#define GNR_TVT_LOWER_LIMIT			MKERR(ERROR, TVTUNER, BOUNDS, 0x07)

// ScanStaion with SCAN_UP reached the upper limit.
#define GNR_TVT_UPPER_LIMIT			MKERR(ERROR, TVTUNER, BOUNDS, 0x08)

// Tells that the station scan was canceled by the user.
#define GNR_TVT_SCAN_CANCELED			MKERR(ERROR, TVTUNER, GENERAL, 0x09)

// Dialog box could not be opened
#define GNR_TVT_NO_DIALOG_BOX			MKERR(ERROR, TVTUNER, GENERAL, 0x0a)


#ifndef ONLY_EXTERNAL_VISIBLE

enum ScanState {SCAN_COARSE, SCAN_FINE, SCAN_SIGNAL_CHECK, SCAN_FINE_FORWARD};


/////////////////////////////////////////////////////////////////////////////////////////////
// Class TVTuner definition (realizes physical unit)
/////////////////////////////////////////////////////////////////////////////////////////////
class TVTuner : public PhysicalUnit {
	friend class VirtualTVTuner;

	protected:
		Direction		scanDir;
		ScanState		scanState;

		DWORD				changed;

		TVStdProperty	tvStdProperties[STDS_NUM];						// stores the properties of TV standards

		DWORD				freq;

		TVTunerTVStandard	tvStd;

		TVTuner();

		virtual 	Error SetTVStandard(TVTunerTVStandard tvStd);
		virtual 	Error SetFrequency(DWORD freq);

		virtual	Error SetScanDir(Direction dir);
		virtual	Error	SetScanState(ScanState state);

		virtual 	Error CheckInputLevel(WORD __far & level) = 0;
		virtual	Error	ScanStation(Direction dir, DWORD __far & freq) = 0;
		virtual	Error	StartStepScan(Direction dir) = 0;
		virtual	Error ScanStep(ScanResult __far & result,
										DWORD __far & curFreq,
										WORD	__far & curLevel,
									   ScanState __far & curState) = 0;

		virtual	Error Update(void) = 0;
	};


/////////////////////////////////////////////////////////////////////////////////////////////
// Class VirtualTVTuner definition (realizes virtual unit)
/////////////////////////////////////////////////////////////////////////////////////////////
class VirtualTVTuner : public VirtualUnit {
	private:
		TVTuner*					tuner;					// Pointer to the physical unit.
	protected:
		DWORD						freq;						// Current frequency of channel (10^2 Hz units)
		TVTunerTVStandard		tvStd;					// Stores the current TV standard of this virtual unit

		Direction				scanDir;
		ScanState				scanState;

	public:
		VirtualTVTuner(TVTuner* physical);

		virtual Error Configure(TAG __far * tags);
		virtual Error Preempt(VirtualUnit * previous);
																				// Standard configuration function
		virtual Error ScanStation(Direction dir);					// Search for the next available station and
																				// set the current frequency to its value if one was found.
		virtual Error StartStepScan(Direction dir);				// Initialize stepwise scan

		virtual Error ScanStep(ScanResult __far & 	result,	// Scan stepwise
									  DWORD	__far & 			curFreq,
									  WORD __far & 			curLevel);

		virtual Error CheckInputLevel(WORD __far & level);	// Check the signal strength of the station on the
																				// current frequency.
	};

#endif // of ONLY_EXTERNAL_VISIBLE


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\hardware\video\generic\VIDDEC.CPP ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


// FILE:      library\hardware\video\generic\viddec.cpp
// AUTHOR:    Ulrich Sigmund
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   16.08.95
//
// PURPOSE: The abstract class for video decoder programming.
//
// HISTORY:

#include "viddec.h"

Error VideoDecoder::Lock(VirtualUnit * unit)
	{
	Error err = GNR_OK;

	if (videoBus && IS_ERROR(err = videoBus->Lock()))
		{
		}
	else if (IS_ERROR(err = VideoChip::Lock(unit)))
		{
		if (videoBus)
			videoBus->Unlock();
		}

	return err;
	}

Error VideoDecoder::Unlock(VirtualUnit * unit)
	{
	if (videoBus)
		GNREASSERT(videoBus->Unlock());
	GNREASSERT(VideoChip::Unlock(unit));

	GNRAISE_OK;
	}

Error VirtualVideoDecoder::Configure(TAG __far * tags)
	{
	GNREASSERT(VirtualVideoChip::Configure(tags));

	PARSE_TAGS_START(tags)
		GETSETVC(DEC_INPUT,		input,		GNREASSERT(decoder->SetInput(input)));
		GETSETVC(DEC_BRIGHTNESS,brightness, GNREASSERT(decoder->SetBrightness(brightness)));
		GETSETVC(DEC_CONTRAST,	contrast,	GNREASSERT(decoder->SetContrast(contrast)));
		GETSETVC(DEC_SATURATION,saturation,	GNREASSERT(decoder->SetSaturation(saturation)));
		GETSETVC(DEC_HUE,			hue,			GNREASSERT(decoder->SetHue(hue)));
		GETSETVC(DEC_SAMPLEMODE,sampleMode,	GNREASSERT(decoder->SetSampleMode(sampleMode)));
		GETSETVC(DEC_TELETEXT,	teletext,	GNREASSERT(decoder->SetTeletextMode(teletext)));

		GETONLY(DEC_INPUT_NUMBER, decoder->numInputs);
#if NT_KERNEL || VXD_VERSION
		GETINQUIRE(DEC_INPUT_NAMES,
				memcpy (data, decoder->inputNames, sizeof(VideoDecoderInputEntry)*decoder->numInputs);
				);
#else
		GETINQUIRE(DEC_INPUT_NAMES,
				hmemcpy (data, decoder->inputNames, sizeof(VideoDecoderInputEntry)*decoder->numInputs);
				);
#endif

		GETINQUIRE(DEC_DETECT_STD, if (GetState() == current) return decoder->DetectVideoStandard(data); else GNRAISE(GNR_OBJECT_NOT_CURRENT););
	PARSE_TAGS_END;

	GNRAISE_OK;
	}

Error VirtualVideoDecoder::Preempt(VirtualUnit *previous)
	{
	GNREASSERT(VirtualVideoChip::Preempt(previous));

	PREEMPT_START(VirtualVideoDecoder)
		PREEMPT_UPDATE(input,		GNREASSERT(decoder->SetInput(input)));
		PREEMPT_UPDATE(brightness, GNREASSERT(decoder->SetBrightness(brightness)));
		PREEMPT_UPDATE(contrast,	GNREASSERT(decoder->SetContrast(contrast)));
		PREEMPT_UPDATE(saturation,	GNREASSERT(decoder->SetSaturation(saturation)));
		PREEMPT_UPDATE(hue,			GNREASSERT(decoder->SetHue(hue)));
		PREEMPT_UPDATE(sampleMode, GNREASSERT(decoder->SetSampleMode(sampleMode)));
		PREEMPT_UPDATE(teletext,	GNREASSERT(decoder->SetTeletextMode(teletext)));
	PREEMPT_END;

	GNRAISE_OK;
	}

VirtualVideoDecoder::VirtualVideoDecoder(VideoDecoder	*	physical)
		 : VirtualVideoChip(physical)
	{
	decoder = physical;
	input = 0;
	brightness = 5216;
	contrast = 5748;
	saturation = 5000;
	hue = 5000;
	sampleMode = VSAMOD_CCIR;
	teletext = FALSE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\hardware\tuner\generic\TVTUNER.CPP ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// FILE:			library\hardware\tuner\generic\tvtuner.cpp
// AUTHOR:		Stefan Herr
// COPYRIGHT:	(c) 1995 Viona Development.  All Rights Reserved.
// CREATED:		17.07.95
//
// PURPOSE:		Implementation of abstract base class for tv tuners
//
// HISTORY:

#include "tvtuner.h"
#include "library\support\gfxdebug\gfxdebug.h"


NAME_ERROR(TVT_ILLEGAL_TV_STD, "Illegal TV standard");
NAME_ERROR(TVT_ILLEGAL_FREQUENCY, "Illegal frequency");
NAME_ERROR(TVT_PLL_NOT_LOCKED, "PLL not locked");
NAME_ERROR(TVT_NOT_CURRENT, "TV tuner not current unit");
NAME_ERROR(TVT_NOT_IMPLEMENTED, "TV function not implemented");
NAME_ERROR(TVT_NO_STATION_FOUND, "No station found");
NAME_ERROR(TVT_LOWER_LIMIT, "Lower limit of frequency range reached");
NAME_ERROR(TVT_UPPER_LIMIT, "Upper limit of frequency range reached");
NAME_ERROR(TVT_SCAN_CANCELED, "Auto Scan canceled");
NAME_ERROR(TVT_NO_DIALOG_BOX, "Dialog box could not be opened");



#define CHANGED_FREQUENCY	MKFLAG(0)
#define CHANGED_STANDARD	MKFLAG(1)

//
// Flags that require a total reporgramming of the chip
//
#define CHANGED_VITAL			(CHANGED_FREQUENCY | CHANGED_STANDARD)
#define CHANGED_ALL				0xffff

// TV Tuner object for dialog box message function access.

//TVTuner *	tvTunerObj;

/////////////////////////////////////////////////////////////////////////////////////////////
// Class TVTuner implementation (physical unit)
/////////////////////////////////////////////////////////////////////////////////////////////

// The constructor defines the properties of the different TV tuner standards.
TVTuner::TVTuner()
	{
	//
	// The unit of the following values is [10^2 Hz] !
	//

	// Please pay attention: The band limits for PAL and NTSC are for Philips tuners only!!!!
	// The others were taken from ALPS documentation.

	tvStdProperties[PAL_AIR].minFreq			=  392500;
	tvStdProperties[PAL_AIR].stepSize		=     625;
	tvStdProperties[PAL_AIR].lowLimit		= 1572500 + 30000;
	tvStdProperties[PAL_AIR].midLimit		= 4512500 + 30000;
	tvStdProperties[PAL_AIR].highLimit		= 8952500 + 30000;
	tvStdProperties[PAL_AIR].visionIF		=  389000;

	tvStdProperties[PAL_CABLE].minFreq		=  392500;
	tvStdProperties[PAL_CABLE].stepSize		=     625;
	tvStdProperties[PAL_CABLE].lowLimit		= 1572500 + 30000;
	tvStdProperties[PAL_CABLE].midLimit		= 4512500 + 30000;
	tvStdProperties[PAL_CABLE].highLimit	= 8952500 + 30000;
	tvStdProperties[PAL_CABLE].visionIF		=  389000;

	tvStdProperties[NTSC_AIR].minFreq		=  462500;
	tvStdProperties[NTSC_AIR].stepSize		=     625;
	tvStdProperties[NTSC_AIR].lowLimit  	= 1572500 + 30000;
	tvStdProperties[NTSC_AIR].midLimit  	= 4512500 + 30000;
	tvStdProperties[NTSC_AIR].highLimit 	= 8012500 + 30000;
	tvStdProperties[NTSC_AIR].visionIF  	=  457500;

	tvStdProperties[NTSC_CABLE].minFreq		=  462500;
	tvStdProperties[NTSC_CABLE].stepSize	=     625;
	tvStdProperties[NTSC_CABLE].lowLimit	= 1572500 + 30000;
	tvStdProperties[NTSC_CABLE].midLimit	= 4512500 + 30000;
	tvStdProperties[NTSC_CABLE].highLimit	= 8012500 + 30000;
	tvStdProperties[NTSC_CABLE].visionIF	=  457500;

	tvStdProperties[SECAM_AIR].minFreq		=  392500;
	tvStdProperties[SECAM_AIR].stepSize		=     625;
	tvStdProperties[SECAM_AIR].lowLimit		= 1572500 + 30000;
	tvStdProperties[SECAM_AIR].midLimit		= 4512500 + 30000;
	tvStdProperties[SECAM_AIR].highLimit	= 8952500 + 30000;
	tvStdProperties[SECAM_AIR].visionIF		=  457500;

	tvStdProperties[SECAM_CABLE].minFreq 	=  392500;
	tvStdProperties[SECAM_CABLE].stepSize 	=     625;
	tvStdProperties[SECAM_CABLE].lowLimit  = 1572500 + 30000;
	tvStdProperties[SECAM_CABLE].midLimit  = 4512500 + 30000;
	tvStdProperties[SECAM_CABLE].highLimit = 8952500 + 30000;
	tvStdProperties[SECAM_CABLE].visionIF  =  457500;

	tvStdProperties[JAPAN_AIR].minFreq		=  822500;
	tvStdProperties[JAPAN_AIR].stepSize		=     625;
	tvStdProperties[JAPAN_AIR].lowLimit  	= 1652500 + 30000;
	tvStdProperties[JAPAN_AIR].midLimit  	= 3132500 + 30000;
	tvStdProperties[JAPAN_AIR].highLimit 	= 7652500 + 30000;
	tvStdProperties[JAPAN_AIR].visionIF  	=  587500;

	tvStdProperties[JAPAN_CABLE].minFreq	=  822500;
	tvStdProperties[JAPAN_CABLE].stepSize	=     625;
	tvStdProperties[JAPAN_CABLE].lowLimit 	= 1652500 + 30000;
	tvStdProperties[JAPAN_CABLE].midLimit 	= 3132500 + 30000;
	tvStdProperties[JAPAN_CABLE].highLimit	= 7652500 + 30000;
	tvStdProperties[JAPAN_CABLE].visionIF  =  587500;

	tvStdProperties[PAL_I_AIR].minFreq		=  392500;
	tvStdProperties[PAL_I_AIR].stepSize		=     500;
	tvStdProperties[PAL_I_AIR].lowLimit  	= 1262500 + 30000;
	tvStdProperties[PAL_I_AIR].midLimit  	= 3432500 + 30000;
	tvStdProperties[PAL_I_AIR].highLimit 	= 8952500 + 30000;
	tvStdProperties[PAL_I_AIR].visionIF  	=  395000;

	tvStdProperties[PAL_I_CABLE].minFreq	=  392500;
	tvStdProperties[PAL_I_CABLE].stepSize	=     500;
	tvStdProperties[PAL_I_CABLE].lowLimit 	= 1262500 + 30000;
	tvStdProperties[PAL_I_CABLE].midLimit 	= 3432500 + 30000;
	tvStdProperties[PAL_I_CABLE].highLimit	= 8952500 + 30000;
	tvStdProperties[PAL_I_CABLE].visionIF  =  395000;

	freq = 900000;
	tvStd = PAL_CABLE;

	changed = CHANGED_ALL;
	}



Error TVTuner::SetTVStandard(TVTunerTVStandard tvStd)
	{
	if ((tvStd >= MIN_TV_STD) && (tvStd <= MAX_TV_STD))			// Check validity of desired TV standard.
		{
		this->tvStd = tvStd;													// Set as new current TV standard.
		changed |= CHANGED_STANDARD;
		GNRAISE_OK;
		}
	else
		GNRAISE(GNR_TVT_ILLEGAL_TV_STD);
	}

Error TVTuner::SetFrequency(DWORD freq)
	{
//	if (freq > tvStdProperties[tvStd].minFreq && freq < tvStdProperties[tvStd].highLimit)
		{
		this->freq = freq;													// Set new frequency.
		changed |= CHANGED_FREQUENCY;
		GNRAISE_OK;
		}
//	else
//		GNRAISE(GNR_TVT_ILLEGAL_FREQUENCY);
	}

Error TVTuner::SetScanDir(Direction dir)
	{
	scanDir = dir;
	GNRAISE_OK;
	}

Error	TVTuner::SetScanState(ScanState state)
	{
	scanState = state;
	GNRAISE_OK;
	}

/////////////////////////////////////////////////////////////////////////////////////////////
// Class VirtualTVTuner implementation (virtual unit)
/////////////////////////////////////////////////////////////////////////////////////////////

VirtualTVTuner::VirtualTVTuner(TVTuner* physical) : VirtualUnit(physical)
	{
	tuner = physical;
	freq = 900000;
	tvStd = PAL_CABLE;
	}

Error VirtualTVTuner::Configure(TAG __far * tags)
	{
	PARSE_TAGS_START(tags)
		GETSETVC(TVT_TVSTANDARD,	tvStd,	GNREASSERT(tuner->SetTVStandard(tvStd)));
//		GETSETVC(TVT_FREQUENCY, 	freq, 	{GNREASSERT(tuner->SetFrequency(freq)); GDP("TVT_FREQUENCY: %ld", freq);});
		GETSETVC(TVT_FREQUENCY, 	freq, 	GNREASSERT(tuner->SetFrequency(freq)));
		GETINQUIRE(TVT_SIGNAL_LEVEL, {
												if (GetState() != current)
											 		GNRAISE(GNR_TVT_NOT_CURRENT);
												else
													GNREASSERT(tuner->CheckInputLevel(data));
											  });
	PARSE_TAGS_END

	if (GetState() == current)
		GNREASSERT(tuner->Update());

	GNRAISE_OK;
	}

Error VirtualTVTuner::Preempt(VirtualUnit * previous)
	{
	GNREASSERT(tuner->SetTVStandard(tvStd));
	GNREASSERT(tuner->SetFrequency(freq));
	GNREASSERT(tuner->SetScanDir(scanDir));
	GNREASSERT(tuner->SetScanState(scanState));

	GNREASSERT(tuner->Update());

	GNRAISE_OK;
	}

Error VirtualTVTuner::CheckInputLevel(WORD __far &level)
	{
	if (GetState() != current)
		GNRAISE(GNR_TVT_NOT_CURRENT);
	else
		return tuner->CheckInputLevel(level);
	}

Error VirtualTVTuner::ScanStation(Direction dir)
	{
	DWORD newFreq;

	if (GetState() != current)
		GNRAISE(GNR_TVT_NOT_CURRENT);
	else
		{
		GNREASSERT(tuner->ScanStation(dir, newFreq));
		freq = newFreq;
		}
	GNRAISE_OK;
	}

Error VirtualTVTuner::StartStepScan(Direction dir)
	{
	scanDir		= dir;
	scanState	= SCAN_COARSE;									// Initial state.

	if (dir == SCAN_UP)											// Add a little offset to the current frequency so
		freq += 30000;												// that the same station is not found twice.
	else
		freq -= 20000;

	if (GetState() == current)
		{
		GNREASSERT(tuner->SetFrequency(freq));
		GNREASSERT(tuner->SetScanDir(scanDir));
		GNREASSERT(tuner->SetScanState(scanState));
		}

	GNRAISE_OK;
	}

Error VirtualTVTuner::ScanStep(ScanResult __far & result, DWORD __far & curFreq, WORD __far & curLevel)
	{
	if (GetState() != current)
		GNRAISE(GNR_TVT_NOT_CURRENT);
	else
		{
		GNREASSERT(tuner->ScanStep(result, curFreq, curLevel, scanState));
		freq = curFreq;
		}

	GNRAISE_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\hardware\video\generic\VIDTYPES.H ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


// FILE:      library\hardware\video\generic\vidtypes.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   04.04.95
//
// PURPOSE: Video related types.
//
// HISTORY:

#ifndef VIDEOTYPES_H
#define VIDEOTYPES_H

enum VideoStandard
	{
	VSTD_NTSC	 = 0,
	VSTD_PAL		 = 1,
	VSTD_SECAM	 = 2,
	VSTD_HDTV	 = 3,
	VSTD_UNKNOWN = 4,
	VIDEOSTANDARD_MIN = VSTD_NTSC,
	VIDEOSTANDARD_MAX = VSTD_UNKNOWN
	};


enum MovingImageStandard
	{
	MIS_576_25		= 0,
	MIS_480_29_97	= 1
	};

enum PALVideoSubStandard
	{
	PALVIDEOSUBSTANDARD_MIN	= 0,
		PALVSSTD_DEFAULT		= 0,
		PALVSSTD_BDGHI			= 1,
		PALVSSTD_N				= 2,
		PALVSSTD_NC				= 3,
		PALVSSTD_INVALID		= 4,
	PALVIDEOSUBSTANDARD_MAX	= PALVSSTD_NC
	};

enum NTSCVideoSubStandard
	{
	NTSCVIDEOSUBSTANDARD_MIN	= 0,
		NTSCVSSTD_DEFAULT			= 0,
		NTSCVSSTD_NORMAL			= 1,
		NTSCVSSTD_PALM				= 2,
		NTSCVSSTD_443				= 3,
		NTSCVSSTD_JAPAN			= 4,
		NTSCVSSTD_PAL60			= 5,
		NTSCVSSTD_INVALID			= 6,
	NTSCVIDEOSUBSTANDARD_MAX	= NTSCVSSTD_PAL60
	};

enum VideoSource
	{
	VIDEOSOURCE_MIN			= 0,
		VSRC_COMPOSITE			= 0,
		VSRC_SVIDEO				= 1,
		VSRC_SERIAL_DIGITAL	= 2,
		VSRC_RGB					= 3,
	VIDEOSOURCE_MAX	= VSRC_RGB
	};

enum VideoPresentationMode
	{
	VPRM_4_BY_3_NORMAL,
	VPRM_4_BY_3_LETTERBOXED,
	VPRM_16_BY_9_ANAMORPHIC,
	VPRM_RESERVED
	};

enum VideoFormat
	{
	VIDEOFORMAT_MIN = 0,
		VFMT_YUV_422 = 0,
		VFMT_YUV_411 = 1,
		VFMT_YUV_420 = 2,
		VFMT_YUV_444 = 3,
		VFMT_RGB_444 = 4,
	VIDEOFORMAT_MAX = VFMT_RGB_444
	};

enum VideoBusFormat
	{
	VIDEOBUSFORMAT_MIN = 0,
		FBFM_YC16 = 0,
		FBFM_YC8  = 1,
	VIDEOBUSFORMAT_MAX = FBFM_YC8
	};

enum VideoLineMode
	{
	VIDEOLINEMODE_MIN		= 0,
		VLM_PROGRESSIVE	= 0,
		VLM_INTERLACED		= 1,
	VIDEOLINEMODE_MAX		= VLM_INTERLACED
	};

enum VideoMode
	{
	VIDEOMODE_MIN = 0,
		VMOD_RESET    = 0,
		VMOD_PATTERN  = 1,
		VMOD_CAPTURE  = 2,
		VMOD_PLAYBACK = 3,
		VMOD_PATTERNSYNC = 4,
	VIDEOMODE_MAX = VMOD_PATTERNSYNC
//	ModeForceReprogramming   // this one internal use only
	};

enum VideoSampleMode
	{
	VIDEOSAMPLEMODE_MIN = 0,
		VSAMOD_CCIR	= 0,
		VSAMOD_SQP	= 1,
	VIDEOSAMPLEMODE_MAX = VSAMOD_SQP
	};

enum VideoField
	{
	VIDEOFIELD_MIN = 0,
		VFLD_SINGLE = 0,
		VFLD_ODD    = 1,
		VFLD_EVEN   = 2,
	VIDEOFIELD_MAX = VFLD_EVEN
	};

enum VideoMuxSource
	{
	VIDEOMUXSRC_MIN = 0,
		VIDEOMUXSRC_INTERNAL = 0,
		VIDEOMUXSRC_NONE = 1,
		VIDEOMUXSRC_EXTERNAL = 2,
	VIDEOMUXSRC_MAX = VIDEOMUXSRC_EXTERNAL
	};

enum VideoPixClockMode
	{
	VIDEOPIXCLK_MIN = 0,
		VIDEOPIXCLK_INTERNAL = 0,
		VIDEOPIXCLK_EXTERNAL = 1,
	VIDEOPIXCLK_MAX = VIDEOPIXCLK_EXTERNAL
	};

enum VideoCopyMode
	{
	VCPMD_DEFAULT,	// depends on implementation (e.g. "do not indicate on video output"). Use for
						// content that does not contain copyright protection information.

	// Use the following three when the content contains copyright protection information
	VCPMD_COPYING_PERMITTED,		// indicate that copying is always allowed
	VCPMD_ONE_COPY_PERMITTED,		// one copy allowed
	VCPMD_NO_COPYING_PERMITTED		// no copy allowed
	};


// The values of the following two enums are hardware-independent.

enum GrabFormat
	{
	GRABFORMAT_MIN = 0,
		VGRB_MJPEG    = 0,
		VGRB_RGB_888x = 1,
		VGRB_RGB_888  = 2,
		VGRB_RGB_565  = 3,
		VGRB_RGB_555  = 4,
		VGRB_YUV_422  = 5,
	GRABFORMAT_MAX = VGRB_YUV_422
	};

enum PIPFormat
	{
	PIPFORMAT_MIN = 0,
		PFMT_RGB_888x	= 0,
		PFMT_RGB_888	= 1,
		PFMT_RGB_565	= 2,
		PFMT_RGB_555	= 3,
		PFMT_YUV_422	= 4,
		PFMT_UVY_422	= 5,
		PFMT_PALETTE_8	= 6,
		PFMT_OTHER		= 7,
	PIPFORMAT_MAX = PFMT_OTHER
	};


struct HardVideoParams
	{
	int totalWidth,
	    totalHeight,
	    activeWidth,
	    activeHeight;   // activeHeight must be even (interlace)
	BIT hsPol,          // can be 0 or 1
	    vsPol;          // can be 0 or 1
	int hStart,
	    hEnd,           // hEnd = hStart + activeWidth - 1
	    vStart,
	    vEnd;           // vEnd = vStart + activeHeight/2 - 1
	BIT oddFirst;
	};


// These are defines for TV standard (CCIR) dependent sizes.

const HardVideoParams NTSCParams =
	{
	858, 525,
	720, 480,
	0,   0,
	123, 123+720-1,
	20,  20+480-1,
	TRUE
	};

const HardVideoParams PALParams =
	{
	864, 625,
	720, 576,
	0,   0,
	133, 133+720-1,
	46,  46+576-1,
	FALSE
	};


// These are defines for TV standard (square pixel) dependent sizes.

const HardVideoParams NTSCSquareParams =
	{
	780, 525,
	640, 480,
	1,   1,
	75,  75+640-1,
	20,  20+480-1,
	TRUE
	};

const HardVideoParams PALSquareParams =
	{
	944, 625,
	768, 576,
	1,   1,
	83,  83+768-1,
	34,  34+576-1,
	FALSE
	};


// Video Port specific definitions

// Possible video formats on video port (format field in VideoPortCaps struct)
#define VP_FMT_RGB_555		MKFLAG(0)
#define VP_FMT_RGB_565		MKFLAG(1)
#define VP_FMT_CCIR_422		MKFLAG(2)
#define VP_FMT_YUV_411		MKFLAG(3)
#define VP_FMT_YUV_420		MKFLAG(4)
#define VP_FMT_YONLY_400	MKFLAG(5)
#define VP_FMT_RGB_888_24	MKFLAG(6)
#define VP_FMT_RGB_888_32	MKFLAG(7)
#define VP_FMT_RGB_332		MKFLAG(8)
#define VP_FMT_ACCUPAK		MKFLAG(9)
#define VP_FMT_DYUV			MKFLAG(10)

// Protocols
#define VP_PORT_DI_8A		MKFLAG(0)
#define VP_PORT_DIV_8A		MKFLAG(1)
#define VP_PORT_DE_8A		MKFLAG(2)
#define VP_PORT_SI_8A		MKFLAG(3)
#define VP_PORT_SIV_8A		MKFLAG(4)
#define VP_PORT_SE_8A		MKFLAG(5)
#define VP_PORT_16A			MKFLAG(6)
#define VP_PORT_V_16A		MKFLAG(7)
#define VP_PORT_FIREWIRE	MKFLAG(8)
// Use this when creating a dummy Kernel Video Port PIP:
#define VP_PORT_DUMMY		MKFLAG(9)

// generate from the ones above!
//#define VP_PROT_BROOKTREE
//#define VP_PROT_PHILIPS

// Special connection features
#define VP_FEAT_INVERTPOLARITY	MKFLAG(0)
#define VP_FEAT_INTERLACED			MKFLAG(1)
#define VP_FEAT_TELETEXT			MKFLAG(2)
#define VP_FEAT_CLOSEDCAPTION		MKFLAG(3)
#define VP_FEAT_E_HREFH_VREFH		MKFLAG(4)
#define VP_FEAT_E_HREFH_VREFL		MKFLAG(5)
#define VP_FEAT_E_HREFL_VREFH		MKFLAG(6)
#define VP_FEAT_E_HREFL_VREFL		MKFLAG(7)
#define VP_FEAT_COLORCONTROL		MKFLAG(8)
#define VP_FEAT_BOB					MKFLAG(9)
#define VP_FEAT_WEAVE				MKFLAG(10)
// Use this when creating a dummy Kernel Video Port PIP:
#define VP_FEAT_DUMMY					MKFLAG(11)

struct VideoPortCaps
	{
	DWORD	videoFormat;		// Video format on port connection

	DWORD	protocol;			// Communication protocol(s)
	DWORD	connFeatures;		// Special features for the connection

	DWORD	fieldWidth;			// Maximum total transfer width of one field
	DWORD	vbiWidth;			// Maximum transfer width for VBI information
	DWORD	fieldHeight;		// Maximum total transfer height of one field

	DWORD	usPerField;			// Shortest possible time between two VREFs in microseconds
	DWORD	pixelsPerSecond;	// Number of pixels per second

	DWORD	displayOnly;		// The VGA can only display, but not capture.

	DWORD	clrControls;		// Will contain possible color controls
	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\lowlevel\timer.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


// FILE:      library\lowlevel\timer.cpp
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   17.03.95
//
// PURPOSE: The timer class.
//
// HISTORY:

#include "timer.h"








// Global Timer Variable
#if VXD_VERSION
TimerClass * globalTimer;
#else
TimerClass Timer;
#endif

// Global variables for static data members of TimerClass
int TimerClass::timerClassInited;
int TimerClass::nanoDelay;

#if !NT_KERNEL

// Software delay loops have different speed on different processors. Accurate
// timing can be achieved by measuring the time delays in the following way:
// The loop in "nanoSleep" is very short and accurate. We time a lot of runs
// through it and look how long it took. Based on that information, we can
// calculate the parameter we need to provide "nanoSleep" to have it last for
// one microsecond.

static void nanoSleep (int delay)
	{
	_asm
		{
			mov		ecx, delay
		l1:	loop	l1
		}
	}

#endif




// Pause for a specified number of microseconds.

void TimerClass::WaitMicroSecs (DWORD micros)
	{
#if NT_KERNEL
	KeStallExecutionProcessor(micros);
#else
	int nanoDelay = this->nanoDelay;
	__asm
		{
				mov	edx, DWORD PTR [micros]
				mov	ebx, nanoDelay;
				sub	edx, 1
				jc		w0
		l0:	mov	ecx, ebx
		l1:   sub	ecx, 1
				jne	l1
				sub	edx, 1
				jnc	l0
		w0:
		}
#endif
	}

#if NT_KERNEL

static DWORD GetMillis(void)
	{
	LARGE_INTEGER val;
	DWORD freq;

	KeQueryTickCount(&val);
	freq = KeQueryTimeIncrement();

//	val = KeQueryPerformanceCounter(&freq);

	return (DWORD) (val.QuadPart * freq / 10000);
	}

static DWORD GetMicros(void)
	{
	LARGE_INTEGER val, freq;

	val = KeQueryPerformanceCounter(&freq);

	return (DWORD) (val.QuadPart * 1000000 / freq.QuadPart);
	}

void TimerClass::WaitMilliSecs (DWORD millis)
	{
	LARGE_INTEGER delay;

	DWORD startTime = GetMillis() + millis;

	delay.QuadPart = - (LONGLONG) millis * (LONGLONG) 10000; // unit is 100 ns

	if (STATUS_SUCCESS != KeDelayExecutionThread(KernelMode, FALSE, &delay))
		{
		// Do it the bad way if KeDelayExecutionThread was interrupted by APC.
		// We are mean.
		while (startTime > GetMillis()) WaitMicroSecs(500);
		}
	}

DWORD TimerClass::GetMilliTicks (void)
	{
	return GetMillis();
	}

DWORD TimerClass::GetMicroTicks (void)
	{
	return GetMicros();
	}


// The constructor. We measure how long loops on this processor take.
// Thus we can time short intervals in the microsecond range.

TimerClass::TimerClass (void)
	{
	}

#else

#if VXD_VERSION

DWORD	TimerClass::GetMilliTicks (void)
	{
	return Get_System_Time();
	}

// Sometimes milliseconds are enough resolution
void TimerClass::WaitMilliSecs (DWORD millis)
	{
	}

void VxDTimerClass::WaitMilliSecs(DWORD millis)
	{
	_VWIN32_WaitSingleObject(vxdTimerHandle, millis, FALSE);
	}

#else
// Get the number of microseconds elapsed since Windows started. Note that
// there's no DWORD wrap around since Windows can't run stable for 49 days.

DWORD TimerClass::GetMilliTicks (void)
	{
	return ::timeGetTime();
	}


// Sometimes milliseconds are enough resolution
void TimerClass::WaitMilliSecs (DWORD millis)
	{
	Sleep(millis);
	}

#endif

DWORD TimerClass::GetMicroTicks (void)
	{
	LARGE_INTEGER	count, freq;
	QueryPerformanceFrequency(&freq);
	QueryPerformanceCounter(&count);
	return (DWORD)(count.QuadPart * 1000 / (freq.QuadPart / 1000));
	}

// The constructor. We measure how long loops on this processor take.
// Thus we can time short intervals in the microsecond range.

TimerClass::TimerClass (void)
	{
	DWORD start, end, delta, delay;

	if (timerClassInited != TRUE)
		{
		timerClassInited = TRUE;
		nanoDelay = 1000;

		delay = 100;

		do {
			delay *= 10;

			start = GetMilliTicks();
			WaitMicroSecs(delay);
			end = GetMilliTicks();
			} while (end - start < 10);

		nanoDelay = (int)( delay / (end-start) );

		start = GetMilliTicks();
		WaitMicroSecs(40000);
		delta = GetMilliTicks() - start;

		if (nanoDelay && (delta < 20 || delta > 80))
			{
			nanoDelay = nanoDelay * 40 / (int)delta;
			}

		if (delta < 40)
			{
			do
				{
				nanoDelay++;
				start = GetMilliTicks();
				WaitMicroSecs(40000);
				delta = GetMilliTicks() - start;
				} while (delta < 40);
			}
		else if (delta > 40)
			{
			do
				{
				nanoDelay--;
				start = GetMilliTicks();
				WaitMicroSecs(40000);
				delta = GetMilliTicks() - start;
				} while (delta > 40);
			nanoDelay++;
			}
		}
	}

#endif // not NT_KERNEL branch
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\support\aspi32\WNASPI32.H ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

//***************************************************************************
//
// Name: 	      WNASPI32.H
//
// Description:	ASPI for Win32 definitions ('C' Language)
//
//***************************************************************************

#ifndef WNASPI32_H
#define WNASPI32_H

#if !WIN32
#pragma pack(4)
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef void *LPSRB;
typedef void (*PFNPOST)();

DWORD __cdecl SendASPI32Command    (LPSRB);
DWORD __cdecl GetASPI32SupportInfo (VOID);

#define SENSE_LEN					14			// Default sense buffer length
#define SRB_DIR_SCSI				0x00		// Direction determined by SCSI 															// command
#define SRB_DIR_IN					0x08		// Transfer from SCSI target to 															// host
#define SRB_DIR_OUT					0x10		// Transfer from host to SCSI 															// target
#define SRB_POSTING					0x01		// Enable ASPI posting
#define SRB_EVENT_NOTIFY            0x40        // Enable ASPI event notification
#define SRB_ENABLE_RESIDUAL_COUNT	0x04		// Enable residual byte count 															// reporting
#define SRB_DATA_SG_LIST			0x02		// Data buffer points to 																	// scatter-gather list
#define WM_ASPIPOST					0x4D42		// ASPI Post message
//***************************************************************************
//						 %%% ASPI Command Definitions %%%
//***************************************************************************
#define SC_HA_INQUIRY				0x00		// Host adapter inquiry
#define SC_GET_DEV_TYPE				0x01		// Get device type
#define SC_EXEC_SCSI_CMD			0x02		// Execute SCSI command
#define SC_ABORT_SRB				0x03		// Abort an SRB
#define SC_RESET_DEV				0x04		// SCSI bus device reset
#define SC_GET_DISK_INFO			0x06		// Get Disk information

//***************************************************************************
//								  %%% SRB Status %%%
//***************************************************************************
#define SS_PENDING			0x00		// SRB being processed
#define SS_COMP				0x01		// SRB completed without error
#define SS_ABORTED			0x02		// SRB aborted
#define SS_ABORT_FAIL		0x03		// Unable to abort SRB
#define SS_ERR 				0x04		// SRB completed with error

#define SS_INVALID_CMD		0x80		// Invalid ASPI command
#define SS_INVALID_HA		0x81		// Invalid host adapter number
#define SS_NO_DEVICE		0x82		// SCSI device not installed

#define SS_INVALID_SRB		0xE0		// Invalid parameter set in SRB
#define SS_FAILED_INIT		0xE4		// ASPI for windows failed init
#define SS_ASPI_IS_BUSY		0xE5		// No resources available to execute cmd
#define SS_BUFFER_TO_BIG	0xE6		// Buffer size to big to handle!

//***************************************************************************
//							%%% Host Adapter Status %%%
//***************************************************************************
#define HASTAT_OK					0x00	// Host adapter did not detect an 															// error
#define HASTAT_SEL_TO				0x11	// Selection Timeout
#define HASTAT_DO_DU				0x12	// Data overrun data underrun
#define HASTAT_BUS_FREE				0x13	// Unexpected bus free
#define HASTAT_PHASE_ERR			0x14	// Target bus phase sequence 																// failure
#define HASTAT_TIMEOUT				0x09	// Timed out while SRB was 																	waiting to beprocessed.
#define HASTAT_COMMAND_TIMEOUT 		0x0B	// While processing the SRB, the
															// adapter timed out.
#define HASTAT_MESSAGE_REJECT		0x0D	// While processing SRB, the 																// adapter received a MESSAGE 															// REJECT.
#define HASTAT_BUS_RESET			0x0E	// A bus reset was detected.
#define HASTAT_PARITY_ERROR			0x0F	// A parity error was detected.
#define HASTAT_REQUEST_SENSE_FAILED	0x10	// The adapter failed in issuing
														//   REQUEST SENSE.

//***************************************************************************
//			 %%% SRB - HOST ADAPTER INQUIRY - SC_HA_INQUIRY %%%
//***************************************************************************
typedef struct {
	BYTE	SRB_Cmd;				// ASPI command code = SC_HA_INQUIRY
	BYTE	SRB_Status;				// ASPI command status byte
	BYTE	SRB_HaId;				// ASPI host adapter number
	BYTE	SRB_Flags;				// ASPI request flags
	DWORD	SRB_Hdr_Rsvd;			// Reserved, MUST = 0
	BYTE	HA_Count;				// Number of host adapters present
	BYTE	HA_SCSI_ID;				// SCSI ID of host adapter
	BYTE	HA_ManagerId[16];		// String describing the manager
	BYTE	HA_Identifier[16];		// String describing the host adapter
	BYTE	HA_Unique[16];			// Host Adapter Unique parameters
	WORD	HA_Rsvd1;

} SRB_HAInquiry, *PSRB_HAInquiry;

//***************************************************************************
//			  %%% SRB - GET DEVICE TYPE - SC_GET_DEV_TYPE %%%
//***************************************************************************
typedef struct {

	BYTE	SRB_Cmd;				// ASPI command code = SC_GET_DEV_TYPE
	BYTE	SRB_Status;				// ASPI command status byte
	BYTE	SRB_HaId;				// ASPI host adapter number
	BYTE	SRB_Flags;				// Reserved
	DWORD	SRB_Hdr_Rsvd;			// Reserved
	BYTE	SRB_Target;				// Target's SCSI ID
	BYTE	SRB_Lun;				// Target's LUN number
	BYTE	SRB_DeviceType;			// Target's peripheral device type
	BYTE	SRB_Rsvd1;

} SRB_GDEVBlock, *PSRB_GDEVBlock;

//***************************************************************************
//		  %%% SRB - EXECUTE SCSI COMMAND - SC_EXEC_SCSI_CMD %%%
//***************************************************************************

#if WIN32
typedef struct {
	BYTE	SRB_Cmd;				// ASPI command code = SC_EXEC_SCSI_CMD
	BYTE	SRB_Status;				// ASPI command status byte
	BYTE	SRB_HaId;				// ASPI host adapter number
	BYTE	SRB_Flags;				// ASPI request flags
	DWORD	SRB_Hdr_Rsvd;			// Reserved
	BYTE	SRB_Target;				// Target's SCSI ID
	BYTE	SRB_Lun;				// Target's LUN number
	WORD 	SRB_Rsvd1;				// Reserved for Alignment
	DWORD	SRB_BufLen;				// Data Allocation Length
	BYTE	*SRB_BufPointer;		// Data Buffer Pointer
	BYTE	SRB_SenseLen;			// Sense Allocation Length
	BYTE	SRB_CDBLen;				// CDB Length
	BYTE	SRB_HaStat;				// Host Adapter Status
	BYTE	SRB_TargStat;			// Target Status
	void	*SRB_PostProc;			// Post routine
	void	*SRB_Rsvd2;				// Reserved
	BYTE	SRB_Rsvd3[16];			// Reserved for alignment
	BYTE	CDBByte[16];			// SCSI CDB
	BYTE	SenseArea[SENSE_LEN+2];	// Request Sense buffer

} SRB_ExecSCSICmd, *PSRB_ExecSCSICmd;
#else
typedef struct {
	BYTE	SRB_Cmd;				// ASPI command code = SC_EXEC_SCSI_CMD
	BYTE	SRB_Status;				// ASPI command status byte
	BYTE	SRB_HaId;				// ASPI host adapter number
	BYTE	SRB_Flags;				// ASPI request flags
	DWORD	SRB_Hdr_Rsvd;			// Reserved
	BYTE	SRB_Target;				// Target's SCSI ID
	BYTE	SRB_Lun;				// Target's LUN number
	WORD 	SRB_Rsvd1;				// Reserved for Alignment
	DWORD	SRB_BufLen;				// Data Allocation Length
	DWORD	SRB_BufPointer;		// Data Buffer Pointer
	BYTE	SRB_SenseLen;			// Sense Allocation Length
	BYTE	SRB_CDBLen;				// CDB Length
	BYTE	SRB_HaStat;				// Host Adapter Status
	BYTE	SRB_TargStat;			// Target Status
	DWORD	SRB_PostProc;			// Post routine
	DWORD	SRB_Rsvd2;				// Reserved
	BYTE	SRB_Rsvd3[16];			// Reserved for alignment
	BYTE	CDBByte[16];			// SCSI CDB
	BYTE	SenseArea[SENSE_LEN+2];	// Request Sense buffer

} SRB_ExecSCSICmd, *PSRB_ExecSCSICmd;
#endif

//***************************************************************************
//				  %%% SRB - ABORT AN SRB - SC_ABORT_SRB %%%
//***************************************************************************
typedef struct {

	BYTE	SRB_Cmd;				// ASPI command code = SC_EXEC_SCSI_CMD
	BYTE	SRB_Status;				// ASPI command status byte
	BYTE	SRB_HaId;				// ASPI host adapter number
	BYTE	SRB_Flags;				// Reserved
	DWORD	SRB_Hdr_Rsvd;			// Reserved
	void	*SRB_ToAbort;			// Pointer to SRB to abort

} SRB_Abort, *PSRB_Abort;

//***************************************************************************
//				%%% SRB - BUS DEVICE RESET - SC_RESET_DEV %%%
//***************************************************************************
typedef struct {

	BYTE	SRB_Cmd;				// ASPI command code = SC_EXEC_SCSI_CMD
	BYTE	SRB_Status;				// ASPI command status byte
	BYTE	SRB_HaId;				// ASPI host adapter number
	BYTE	SRB_Flags;				// Reserved
	DWORD	SRB_Hdr_Rsvd;			// Reserved
	BYTE	SRB_Target;				// Target's SCSI ID
	BYTE	SRB_Lun;				// Target's LUN number
	BYTE 	SRB_Rsvd1[12];			// Reserved for Alignment
	BYTE	SRB_HaStat;				// Host Adapter Status
	BYTE	SRB_TargStat;			// Target Status
	void 	*SRB_PostProc;			// Post routine
	void	*SRB_Rsvd2;				// Reserved
	BYTE	SRB_Rsvd3[16];			// Reserved
	BYTE	CDBByte[16];			// SCSI CDB

} SRB_BusDeviceReset, *PSRB_BusDeviceReset;

//***************************************************************************
//				%%% SRB - GET DISK INFORMATION - SC_GET_DISK_INFO %%%
//***************************************************************************
typedef struct {

	BYTE	SRB_Cmd;				// ASPI command code = SC_EXEC_SCSI_CMD
	BYTE	SRB_Status;				// ASPI command status byte
	BYTE	SRB_HaId;				// ASPI host adapter number
	BYTE	SRB_Flags;				// Reserved
	DWORD	SRB_Hdr_Rsvd;			// Reserved
	BYTE	SRB_Target;				// Target's SCSI ID
	BYTE	SRB_Lun;				// Target's LUN number
	BYTE 	SRB_DriveFlags;			// Driver flags
	BYTE	SRB_Int13HDriveInfo;	// Host Adapter Status
	BYTE	SRB_Heads;				// Preferred number of heads translation
	BYTE	SRB_Sectors;			// Preferred number of sectors translation
	BYTE	SRB_Rsvd1[20];			// Reserved
} SRB_GetDiskInfo, *PSRB_GetDiskInfo;


#ifdef __cplusplus
}
#endif

#if !WIN32
#pragma pack()
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\support\WinSock\SOCKCORE.CPP ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// Adapted for XBOX from.....

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\hardware\videodma\generic\PIP.H ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


// FILE:      library\hardware\videodma\generic\pip.h
// AUTHOR:    Ulrich Sigmund, S. Herr
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   08.04.95
//
// PURPOSE: The PIP-related classes.
//
// HISTORY:

#ifndef PIP_H
#define PIP_H

#include "library\common\prelude.h"
#include "library\common\gnerrors.h"
#include "library\common\tags.h"
#include "library\common\tagunits.h"
#include "library\common\hooks.h"
#include "library\hardware\video\generic\vidtypes.h"

#ifndef ONLY_EXTERNAL_VISIBLE
#include "library\common\virtunit.h"
#include "library\general\queues.h"
#include "library\lowlevel\kernlmem.h"
#endif

MKTAG(PIP_VIDEOSTANDARD,	PIP_UNIT,	0x00000001, VideoStandard)
#if !NT_KERNEL && !VXD_VERSION
MKTAG(PIP_WINDOW,				PIP_UNIT,	0x00000002, HWND)
#endif

	//
	// Source region, relative to active display
	//
MKTAG(PIP_SOURCE_LEFT,		PIP_UNIT,	0x00000003, int)
MKTAG(PIP_SOURCE_TOP,		PIP_UNIT,	0x00000004, int)
MKTAG(PIP_SOURCE_WIDTH,		PIP_UNIT,   0x00000005, int)
MKTAG(PIP_SOURCE_HEIGHT,	PIP_UNIT,   0x00000006, int)

	//
	// Destination region, relative to current window
	//
MKTAG(PIP_DEST_LEFT,			PIP_UNIT,	0x00000007, int)
MKTAG(PIP_DEST_TOP,			PIP_UNIT,	0x00000008, int)
MKTAG(PIP_DEST_WIDTH,		PIP_UNIT,   0x00000009, int)
MKTAG(PIP_DEST_HEIGHT,		PIP_UNIT,   0x0000000A, int)

MKTAG(PIP_ADAPT_CLIENT_SIZE, PIP_UNIT, 0x0000000B, BOOL)
MKTAG(PIP_ADAPT_SOURCE_SIZE, PIP_UNIT, 0x0000000C, BOOL)
MKTAG(PIP_SCREEN_DEST,     PIP_UNIT,   0x0000000D, BOOL)
MKTAG(PIP_SAMPLEMODE,		PIP_UNIT,	0x0000000E, VideoSampleMode)
MKTAG(PIP_HOFFSET,			PIP_UNIT,	0x0000000F, int)
MKTAG(PIP_VOFFSET,			PIP_UNIT,	0x00000010, int)
MKTAG(PIP_ALWAYS_OVERLAY,	PIP_UNIT,	0x00000011, BOOL)
MKTAG(PIP_COLORKEY_COLOR,	PIP_UNIT,	0x00000012, DWORD)
MKTAG(PIP_COLORKEYED,		PIP_UNIT,	0x00000013, BOOL)

	//
	// Display region, relative to the destination rectangle
	//
MKTAG(PIP_DISPLAY_LEFT,		PIP_UNIT,	0x00000014, short)
MKTAG(PIP_DISPLAY_TOP,		PIP_UNIT,	0x00000015, short)
MKTAG(PIP_DISPLAY_WIDTH,	PIP_UNIT,	0x00000016, short)
MKTAG(PIP_DISPLAY_HEIGHT,	PIP_UNIT,	0x00000017, short)

MKTAG(PIP_COLORKEY_INDEX,	PIP_UNIT,	0x00000018, DWORD)

// Make sure to set physical, bytesPerRow and pixelFormat at the same time when enabling this:
MKTAG (PIP_OFFSCREEN_OVERRIDE,		PIP_UNIT, 0x00000019, BOOL)
MKTAG (PIP_OFFSCREEN_BASE,				PIP_UNIT, 0x0000001a, void __far *)
MKTAG (PIP_OFFSCREEN_BASE_LINEAR,	PIP_UNIT, 0x0000001b, DWORD)		// Use a 32bit flat pointer
MKTAG (PIP_OFFSCREEN_BYTES_PER_ROW,	PIP_UNIT, 0x0000001c, WORD)
MKTAG (PIP_OFFSCREEN_PIXEL_FORMAT,	PIP_UNIT, 0x0000001d, PIPFormat)

struct FieldDisplayMsg
	{
	DWORD	fieldCnt;
	};

MKHOOK(FieldDisplay, FieldDisplayMsg);

MKTAG (PIP_FIELD_DISPLAY_HOOK,		PIP_UNIT, 0x0000001e, FieldDisplayHook *)

MKTAG (PIP_IS_POSSIBLE,					PIP_UNIT, 0x0000001f, BOOL)


#include "library\hardware\videodma\generic\colctrlr.h"

MKTAG (PIP_COLORCONTROL,				PIP_UNIT, 0x00000020, WORD)			// Get only tag to query color control support
MKTAG (PIP_BRIGHTNESS,					PIP_UNIT, 0x00000021, WORD)
MKTAG (PIP_CONTRAST,						PIP_UNIT, 0x00000022, WORD)
MKTAG (PIP_SATURATION,					PIP_UNIT, 0x00000023, WORD)
MKTAG (PIP_HUE,							PIP_UNIT, 0x00000024, WORD)
MKTAG (PIP_GAMMA,							PIP_UNIT, 0x00000025, WORD)			// Gamma correction
MKTAG (PIP_SHARPNESS,					PIP_UNIT, 0x00000026, WORD)
MKTAG (PIP_COLORENABLE,					PIP_UNIT, 0x00000027, BOOL)			// Used to toggle between B/W and color

// Use these to adjust brightness individually for R/G/B (only works with special VGAs)
MKTAG (PIP_RED_BRIGHTNESS,				PIP_UNIT, 0x00000028, WORD)
MKTAG (PIP_BLUE_BRIGHTNESS,			PIP_UNIT, 0x00000029, WORD)
MKTAG (PIP_GREEN_BRIGHTNESS,			PIP_UNIT, 0x0000002a, WORD)

// Used to crop the source rectangle when ADAPT_SOURCE_SIZE is TRUE
MKTAG (PIP_SOURCE_CROP_LEFT,			PIP_UNIT, 0x0000002b, WORD)
MKTAG (PIP_SOURCE_CROP_TOP,			PIP_UNIT, 0x0000002c, WORD)
MKTAG (PIP_SOURCE_CROP_RIGHT,			PIP_UNIT, 0x0000002d, WORD)
MKTAG (PIP_SOURCE_CROP_BOTTOM,		PIP_UNIT, 0x0000002e, WORD)



// Error definitions.
#define GNR_DMA_PIP_NOT_POSSIBLE			MKERR(ERROR, PIP, GENERAL, 0x01)		// Current screen mode does not allow DMA PIP
#define GNR_VIDEO_STD_NOT_SUPPORTED		MKERR(ERROR, PIP, GENERAL, 0x02)		// Desired video standard (e.g. SECAM) not supported.
#define GNR_PIP_NOT_RUNNING				MKERR(ERROR, PIP, GENERAL, 0x03)		// PIP is not running when trying to execute OptimizeBuffer()
#define GNR_NO_OPTIMAL_MINPIX				MKERR(ERROR, PIP, GENERAL, 0x04)		// No optimal minPix value could be found by OptimizeBuffer()
#define GNR_DEST_RECT_SIZE					MKERR(ERROR, PIP, GENERAL, 0x05)		// Destination rectangle too small or too big.
#define GNR_WRONG_GRAB_SIZE				MKERR(ERROR, PIP, GENERAL, 0x06)		// Dimensions of frame to grab are too big.
#define GNR_NO_VBLANK_IRQ					MKERR(ERROR, PIP, GENERAL, 0x07)		// An expected VBlank IRQ did not occur.
#define GNR_GRAB_TIMEOUT					MKERR(ERROR, PIP, GENERAL, 0x08)		// A timeout occurred during grabbing a frame.
#define GNR_WRONG_GRAB_FORMAT				MKERR(ERROR, PIP, GENERAL, 0x09)		// An unsupported capture format was requested
#define GNR_SAMPLEMODE_NOT_SUPPORTED	MKERR(ERROR, PIP, GENERAL, 0x0a)		// Desired video sample mode not supported
#define GNR_VP_ERROR							MKERR(ERROR, PIP, GENERAL, 0x0b)		// General error with Video Port
#define GNR_VP_NO_PORT_MATCH				MKERR(ERROR, PIP, GENERAL, 0x0c)		// Video source does not match Video Port
#define GNR_VP_HARDWARE_IN_USE			MKERR(ERROR, PIP, GENERAL, 0x0d)		// Video Port Hardware in use
#define GNR_VPM_ERROR						MKERR(ERROR, PIP, GENERAL, 0x0e)		// General error with VPM services
#define GNR_VPE_ERROR						MKERR(ERROR, PIP, GENERAL, 0x0f)		// General error with DirectX5/VPE services
#define GNR_NOT_ENOUGH_VIDEO_MEMORY		MKERR(ERROR, PIP, MEMORY,  0x10)
#define GNR_NO_OVERLAY_HARDWARE			MKERR(ERROR, PIP, GENERAL, 0x11)
#define GNR_OVERLAY_BUSY					MKERR(ERROR, PIP, BUSY,    0x12)
#define GNR_PRIMARY_NOT_AVAILABLE		MKERR(ERROR, PIP, BUSY,		0x13)



#if NT_KERNEL || VXD_VERSION || DRVDLL

struct WinDescRect
	{
	BOOL	include;
	RECT	pos;
	};

typedef struct WinDesc
	{
	RECT				frame;
	int				clips;
	WinDescRect	*	clip;
	} * WinDescPtr;

MKTAG(PIP_WINDOW_DESC,		PIP_UNIT,	0x00000102, WinDescPtr)

#endif



typedef struct StreamCaptureMsgStruct
	{
	FPTR bufferInfo;
	FPTR userData;
	DWORD captureTime;
	} StreamCaptureMsg;

MKHOOK(StreamCapture, StreamCaptureMsg);



typedef struct YStreamCaptureMsgStruct
	{
	FPTR bufferInfo;
	FPTR userData;
	WORD yCaptureCounter;
	} YStreamCaptureMsg;

MKHOOK(YStreamCapture, YStreamCaptureMsg);



#ifndef ONLY_EXTERNAL_VISIBLE



	class PrepInfoPIP : public LinkedQueueElement
		{
		// Extend this class to add more preparation info.
		public:
			KernelMemory kernelMem;
			FPTR bufferPtr;   // Kernel space
			FPTR userData;

			PrepInfoPIP (void) {}
			virtual ~PrepInfoPIP (void) {Unprepare ();}

			virtual Error Prepare (FPTR buffer, DWORD size);
			virtual Error Unprepare (void);

			FPTR KernelSpace (void) {return kernelMem.KernelSpace();}
		};



class PIP : public PhysicalUnit
	{
	friend class VirtualPIP;

	protected:
		BOOL pipIsPossible;

		virtual Error SetVideoStandard(VideoStandard std) = 0;
		virtual Error SetSampleMode(VideoSampleMode mode) = 0;
		virtual Error SetHOffset(int offset) = 0;
		virtual Error SetVOffset(int offset) = 0;
#if !NT_KERNEL && !VXD_VERSION
		virtual Error SetWindow(HWND win) = 0;
#endif
		virtual Error SetSourceRect(int left, int top, int width, int height) = 0;
		virtual Error SetDestRect(int left, int top, int width, int height) = 0;

		virtual int GetDisplayLeft(void) = 0;
		virtual int GetDisplayTop(void) = 0;
		virtual int GetDisplayWidth(void) = 0;
		virtual int GetDisplayHeight(void) = 0;

		virtual Error EnablePIP(BOOL enable) = 0;
#if WDM_VERSION
		virtual Error VirtuallyEnablePIP(BOOL enable) = 0;
		virtual Error VideoStreamOn() = 0;
		virtual Error VideoStreamOff() = 0;
#endif
		virtual Error GrabFrame(FPTR base, WORD width, WORD height,
		                        WORD stride, GrabFormat fmt) = 0;
		virtual Error SetAdaptClientSize(BOOL adaptClientSize) = 0;
		virtual Error SetAdaptSourceSize(BOOL adaptSourceSize) = 0;
		virtual Error SetScreenDest(BOOL screenDest) = 0;

#if NT_KERNEL || VXD_VERSION
		virtual Error SetWinDesc(WinDesc * wd) = 0;
#endif

#if !NT_KERNEL && !VXD_VERSION
		virtual Error SetColorkeyColor(DWORD color) {GNRAISE_OK;}
		virtual Error SetColorkeyIndex(DWORD index) {GNRAISE_OK;}
		virtual Error GetColorkeyed(BOOL __far & keyed) {keyed = FALSE; GNRAISE_OK;}
		virtual Error SetAlwaysOverlay(BOOL alwaysOverlay) {GNRAISE_OK;}
#endif
		virtual Error SetOffscreenOverride(BOOL offscreen) = 0;
		virtual Error SetOffscreenBase(FPTR base) = 0;
		virtual Error SetOffscreenBytesPerRow(WORD bpr) = 0;
		virtual Error SetOffscreenPixelFormat(PIPFormat format) = 0;
		virtual Error SetFieldDisplayHook(FieldDisplayHookHandle hook) {if (hook) GNRAISE(GNR_UNIMPLEMENTED); else GNRAISE_OK;}

		virtual Error SetSourceCrop(int left, int top, int right, int bottom) = 0;

		virtual Error Update(void);


		// Streaming capture mechanism.
		virtual Error InitGrabStream (StreamCaptureHookHandle hook, DWORD milliSecPerFrame,
		                              WORD width, WORD height, WORD stride, GrabFormat format);
		virtual Error FinishGrabStream (void);
		virtual Error PrepareGrabBuffer (FPTR buffer, DWORD size, FPTR __far &info);
		virtual Error UnprepareGrabBuffer (FPTR info);
		virtual Error AddStreamGrabBuffer (FPTR info, FPTR userData);
		virtual Error StartGrabStream (void);
		virtual Error StopGrabStream (void);
		virtual PrepInfoPIP *CreatePrepInfo (void);

		typedef struct CaptureParameters
			{
			StreamCaptureHookHandle hook;
			DWORD milliSecPerFrame;
			WORD width, height, stride;
			GrabFormat format;
			LinkedQueue capturePipe;
			int nBuffers;
			BOOL grabRunning;
			BOOL firstFrameIsHere;
			DWORD nextFrameNum;
			DWORD nextFrameTime;
			};
		CaptureParameters capture;


		// Y capture streaming.
		virtual Error StartGrabYStream (YStreamCaptureHookHandle hook, int left, int top, WORD width, WORD height) = 0;
		virtual Error StopGrabYStream (void) = 0;
		Error YDequeue (LinkedQueueElement __far * __far &element);


		virtual Error UpdateDisplay(void);
	public:
		PIP (void) {pipIsPossible = TRUE;}

		virtual Error Initialize(void);
		virtual Error ReInitialize(void) {GNRAISE_OK;}

		virtual Error SuspendDMA(void) {GNRAISE_OK;}
		virtual Error ResumeDMA(void) {GNRAISE_OK;}
	};



class VirtualPIP : public VirtualUnit
	{
	friend class PIP;

	protected:
		VideoStandard		standard;

#if NT_KERNEL || VXD_VERSION
		WinDesc			*	windesc;
#else
		HWND					window;
#endif

		int					sourceLeft, sourceTop, sourceWidth, sourceHeight;
		int					destLeft, destTop, destWidth, destHeight;
		WORD					sourceCropLeft, sourceCropTop, sourceCropRight, sourceCropBottom;
		BOOL					pipEnabled;
		BOOL					adaptClientSize;
		BOOL					adaptSourceSize;
		BOOL					screenDest;

#if !NT_KERNEL && !VXD_VERSION
		HANDLE				saveImage;
#else
		FPTR					saveImage;
#endif

		VideoSampleMode   sampleMode;
		int hOffset, vOffset;

		LinkedQueue yCapturePipe;
		YStreamCaptureHookHandle grabYHook;
		int 					grabYLeft;
		int 					grabYTop;
		WORD 					grabYWidth;
		WORD					grabYHeight;

		BOOL					alwaysOverlay;
		DWORD					keyColor;
		DWORD					keyIndex;

#if NT_KERNEL
		BOOL					virtualEnable;
#endif

		BOOL					offscreenOverride;
		FPTR					offscreenBase;
		WORD					offscreenBPR;
		PIPFormat			offscreenFormat;

		FieldDisplayHookHandle	fieldDisplayHook;

		virtual Error PreserveDisplay(void);
	private:
		PIP*				unit;
	public:
		VirtualPIP(PIP* physical);
		~VirtualPIP(void);

		Error Configure(TAG __far * tags);
		Error Preempt(VirtualUnit* previous);
		Error EnablePIP(BOOL enable);

#if NT_KERNEL
		Error VirtuallyEnablePIP(BOOL enable);
		Error VideoStreamOn();
		Error VideoStreamOff();
#endif

		Error GrabFrame(FPTR base, WORD width, WORD height,
		                WORD stride, GrabFormat fmt);

		Error AdaptClientSize(int destLeft, int destTop, int destWidth, int destHeight);
		Error AdaptSourceSize(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight);


		Error InitGrabStream (StreamCaptureHook *hook, DWORD milliSecPerFrame,
		                      WORD width, WORD height, WORD stride, GrabFormat format);
		Error FinishGrabStream (void);
		Error PrepareGrabBuffer (FPTR buffer, DWORD size, FPTR __far &info)
			{return unit->PrepareGrabBuffer (buffer, size, info);}
		Error UnprepareGrabBuffer (FPTR info)
			{return unit->UnprepareGrabBuffer (info);}
		Error AddStreamGrabBuffer (FPTR info, FPTR userData);
		Error StartGrabStream (void);
		Error StopGrabStream (void);


		virtual Error InitGrabYStream (void);
		virtual Error FinishGrabYStream (void);
		Error StartGrabYStream (YStreamCaptureHook *hook, int left, int top, WORD width, WORD height);
		Error StopGrabYStream(void);
		Error SupplyYStreamGrabBuffer (FPTR info, FPTR userData);


#if NT_KERNEL || VXD_VERSION
		virtual Error GetDMASizes (int &dmaLeft, int &dmaTop, int &dmaWidth, int &dmaHeight) = 0;
		virtual Error UpdateDisplay(FPTR & rDIB, BOOL & rAdaptClientSize, int & rDestLeft, int & rDestTop, int & rDestWidth, int & rDestHeight);
#if WDM_VERSION
		virtual Error PassivateDone() = 0;
#endif
#else
		virtual Error UpdateDisplay(void);
#endif
	};



inline Error VirtualPIP::AdaptClientSize(int destLeft, int destTop, int destWidth, int destHeight)
	{
	if (destLeft   != this->destLeft  ||
	    destTop    != this->destTop   ||
	    destWidth  != this->destWidth ||
	    destHeight != this->destHeight)
		{
		this->destLeft = destLeft;
		this->destTop = destTop;
		this->destWidth = destWidth;
		this->destHeight = destHeight;

		if (GetState() == current)
			GNREASSERT(unit->SetDestRect(destLeft, destTop, destWidth, destHeight));
		}

	GNRAISE_OK;
	}



inline Error VirtualPIP::AdaptSourceSize(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight)
	{
	if (sourceLeft   != this->sourceLeft  ||
	    sourceTop    != this->sourceTop   ||
	    sourceWidth  != this->sourceWidth ||
	    sourceHeight != this->sourceHeight)
		{
		this->sourceLeft = sourceLeft;
		this->sourceTop = sourceTop;
		this->sourceWidth = sourceWidth;
		this->sourceHeight = sourceHeight;

		if (GetState() == current)
			GNREASSERT(unit->SetSourceRect(sourceLeft, sourceTop, sourceWidth, sourceHeight));
		}

	GNRAISE_OK;
	}



#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\support\AVDataBase\AVDataBaseProfiles.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef AVDATABASEPROFILES_H
#define AVDATABASEPROFILES_H

#include "library\common\profiles.h"
#include "swcmcfg.h"

class AVDataBase
	{
	private:
		int			openCount;

		HCFGDB		dataBase;
		HINSTANCE	dataBaseInstance;

		int			displayDeviceID;
		int			soundDeviceID;

		HCFGDB (WINAPI* OpenDB)(LPCTSTR);
		int	 (WINAPI* DBInitialize)();
		int	 (WINAPI* CloseDB)(HCFGDB);
		int	 (WINAPI* GetDBInt)(HCFGDB, LPCTSTR, int, int, int, int&);

		Profile		legacyProfile;
	public:
		AVDataBase(KernelString swcmcfgdll, KernelString product, KernelString version, int displayDeviceID = 1, int soundDeviceID = 1);
		~AVDataBase(void);

		BOOL IsValid(void) {return dataBaseInstance != NULL;}

		void Obtain(void) {openCount++;}
		void Release(void) {openCount--; if (!openCount) delete this;}

		Error GetInt(KernelString name, int & value, int deflt);
		Error GetString(KernelString name, KernelString & value, KernelString deflt);
	};


class AVDataBaseProfile : public GenericProfile
	{
	private:
		KernelString	mainSection;
		AVDataBase	*	avDataBase;
	public:
		AVDataBaseProfile(KernelString swcmcfgdll, KernelString product, KernelString version, int displayDevice = 1, int soundDevice = 1);
		AVDataBaseProfile(AVDataBaseProfile * parent, KernelString section);
		~AVDataBaseProfile(void);

		BOOL IsValid(void) {return avDataBase->IsValid();}
		GenericProfile * CreateSection(KernelString section) {return new AVDataBaseProfile(this, section);}

		Error WriteDirect(KernelString entry, int value);
		Error ReadDirect(KernelString entry, int __far & value, int deflt);
		Error ReadDirect(KernelString entry, int __far & value) {return ReadDirect(entry, value, value);}

		Error WriteDirect(KernelString entry, bool value);
		Error ReadDirect(KernelString entry, bool __far & value, bool deflt);
		Error ReadDirect(KernelString entry, bool __far & value) {return ReadDirect(entry, value, value);}

		Error ReadDirect(KernelString entry, long __far & value, long deflt);
		Error ReadDirect(KernelString entry, long __far & value) {return ReadDirect(entry, value, value);}

		Error WriteDirect(KernelString entry, WORD value, int base);
		Error ReadDirect(KernelString entry, WORD __far & value, int base, WORD deflt);
		Error ReadDirect(KernelString entry, WORD __far & value, int base) {return ReadDirect(entry, value, base, value);}

		Error WriteDirect(KernelString entry, DWORD value, int base);
		Error ReadDirect(KernelString entry, DWORD __far & value, int base, DWORD deflt);
		Error ReadDirect(KernelString entry, DWORD __far & value, int base) {return ReadDirect(entry, value, base, value);}

		Error WriteDirect(KernelString entry, KernelString value);
		Error ReadDirect(KernelString entry, KernelString & value, KernelString deflt);
		Error ReadDirect(KernelString entry, KernelString & value) {return ReadDirect(entry, value, value);}
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\support\AVDataBase\AVDataBaseProfiles.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "AVDataBaseProfiles.h"

AVDataBase::AVDataBase(KernelString swcmcfgdll, KernelString product, KernelString version, int displayDeviceID, int soundDeviceID) :
	legacyProfile("RAVISENT", product, version)
	{
	this->displayDeviceID = displayDeviceID;
	this->soundDeviceID = soundDeviceID;
	openCount = 1;

	// First try to find the specified config library
	dataBaseInstance = ::LoadLibrary(swcmcfgdll);
	if (NULL == dataBaseInstance)
		{
		// Try previous dll name
		dataBaseInstance = ::LoadLibrary("SWCMCFG.dll");
		}
	if (dataBaseInstance)
		{
		(FARPROC &)DBInitialize = GetProcAddress(dataBaseInstance, "_SWCMCFG_Initialize@0");
		(FARPROC &)OpenDB       = GetProcAddress(dataBaseInstance, "_SWCMCFG_OpenDB@4");
		(FARPROC &)CloseDB      = GetProcAddress(dataBaseInstance, "_SWCMCFG_CloseDB@4");
		(FARPROC &)GetDBInt     = GetProcAddress(dataBaseInstance, "_SWCMCFG_GetInt@24");

		if (DBInitialize && OpenDB && CloseDB && GetDBInt)
			{
			if (DBInitialize() != 0)
				{
				dataBase = OpenDB(product + __TEXT("\\") + version);
				if (dataBase == 0)
					{
					::FreeLibrary(dataBaseInstance);
					dataBaseInstance = NULL;
					}
				}
			else
				{
				::FreeLibrary(dataBaseInstance);
				dataBaseInstance = NULL;
				}
			}
		else
			{
			::FreeLibrary(dataBaseInstance);
			dataBaseInstance = NULL;
			}
		}
	}

AVDataBase::~AVDataBase(void)
	{
	if (dataBaseInstance)
		::FreeLibrary(dataBaseInstance);
	}

Error AVDataBase::GetInt(KernelString name, int & value, int deflt)
	{
	if (dataBaseInstance)
		{
		if (GetDBInt(dataBase, name, deflt, displayDeviceID, soundDeviceID, value) != 0)
			GNRAISE_OK;
		else
			GNRAISE(GNR_PROFILE_READ);
		}
	else
		GNRAISE(GNR_PROFILE_READ);
	}

Error AVDataBase::GetString(KernelString name, KernelString & value, KernelString deflt)
	{
	GNREASSERT(legacyProfile.Read("DevDB", name, value, deflt));

	GNRAISE_OK;
	}


AVDataBaseProfile::AVDataBaseProfile(KernelString swcmcfgdll, KernelString product, KernelString version, int displayDevice, int soundDevice)
	{
	mainSection = "";
	avDataBase = new AVDataBase(swcmcfgdll, product, version, displayDevice, soundDevice);
	}

AVDataBaseProfile::AVDataBaseProfile(AVDataBaseProfile * parent, KernelString section)
	{
	mainSection = parent->mainSection + section + ".";
	avDataBase = parent->avDataBase;
	avDataBase->Obtain();
	}

AVDataBaseProfile::~AVDataBaseProfile(void)
	{
	avDataBase->Release();
	}


Error AVDataBaseProfile::WriteDirect(KernelString entry, int value)
	{
	GNRAISE_OK;
	}

Error AVDataBaseProfile::ReadDirect(KernelString entry, int __far & value, int deflt)
	{
	value = deflt;

	GNREASSERT(avDataBase->GetInt(mainSection + entry, value, deflt));

	GNRAISE_OK;
	}

Error AVDataBaseProfile::WriteDirect(KernelString entry, bool value)
	{
	GNRAISE_OK;
	}

Error AVDataBaseProfile::ReadDirect(KernelString entry, bool __far & value, bool deflt)
	{
	int iv;

	value = deflt;

	GNREASSERT(avDataBase->GetInt(mainSection + entry, iv, deflt));

	value = iv != 0;

	GNRAISE_OK;
	}

Error AVDataBaseProfile::ReadDirect(KernelString entry, long __far & value, long deflt)
	{
	int iv;

	value = deflt;

	GNREASSERT(avDataBase->GetInt(mainSection + entry, iv, deflt));

	value = (long)iv;

	GNRAISE_OK;
	}

Error AVDataBaseProfile::WriteDirect(KernelString entry, WORD value, int base)
	{
	GNRAISE_OK;
	}

Error AVDataBaseProfile::ReadDirect(KernelString entry, WORD __far & value, int base, WORD deflt)
	{
	int iv;

	value = deflt;

	GNREASSERT(avDataBase->GetInt(mainSection + entry, iv, deflt));

	value = (WORD)iv;

	GNRAISE_OK;
	}

Error AVDataBaseProfile::WriteDirect(KernelString entry, DWORD value, int base)
	{
	GNRAISE_OK;
	}

Error AVDataBaseProfile::ReadDirect(KernelString entry, DWORD __far & value, int base, DWORD deflt)
	{
	int iv;

	value = deflt;

	GNREASSERT(avDataBase->GetInt(mainSection + entry, iv, deflt));

	value = (DWORD)iv;

	GNRAISE_OK;
	}

Error AVDataBaseProfile::WriteDirect(KernelString entry, KernelString value)
	{
	GNRAISE_OK;
	}

Error AVDataBaseProfile::ReadDirect(KernelString entry, KernelString & value, KernelString deflt)
	{
	value = deflt;

	GNREASSERT(avDataBase->GetString(mainSection + entry, value, deflt));

	GNRAISE_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\support\Shell\ShellToolKit.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//---------------------------------------------------------------------------
// File: Library/Support/Shell/ShellToolKit.h
// Purpose: General Purpose Functions for Shell Utilities
// Author: Sam Frantz
// Date: 08-OKT-2000
//---------------------------------------------------------------------------

#ifndef SHELLTOOLKIT_H
#define SHELLTOOLKIT_H

#include <library/common/prelude.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>


#define MAXPATHLEN		(2048)
#define MAX_INSTR			(1024)
#define IDENTIFIERLEN	(256)
#define FAIL				(-1)
#define SUCCEED			(0)

#define MIN(x,y)        (((x) < (y)) ? (x) : (y))
#define EOS						((char) 0)
#define PATHDELIM               '\\'
#define PATH_SEPARATOR          ';'
#define simple_name(filename)   (strchr(filename, (int) PATHDELIM) == (char *) NULL)

#define MAX_OPTIONS	52
#define PRINT_BYTE(x)	((x >= ' ' && x <= '~') ? x : '.')	// used by PrintDump()

//---------------------------------------------------------------------------

class ShellToolKit
	{
	public:
		char	legalOptionChars[IDENTIFIERLEN];
		char	optionSet[MAX_OPTIONS];
		char	*optionArg[MAX_OPTIONS];
		int	optionCount;

		BOOL	verbose;
		BOOL	interactive;
		int	startArg;
		FILE	*outFp;
		FILE	*inFp;
		FILE	*screenFp;
		char	dirName[MAXPATHLEN];
		char	pgmName[MAXPATHLEN];
		char	pgmExt[IDENTIFIERLEN];
		char	inputFileName[MAXPATHLEN];
		char	outputFileName[MAXPATHLEN];
		char	logFileBaseName[MAXPATHLEN];
		int	logFileNumber;
		ShellToolKit(void)
			{
			startArg = 1;
			verbose = FALSE;
			outFp = (FILE *) NULL;
			screenFp = stdout;
			inFp = stdin;
			interactive = TRUE;
			outputFileName[0] = (char) NULL;
			inputFileName[0] = (char) NULL;
			logFileBaseName[0] = (char) NULL;
			logFileNumber = 0;
			}
		~ShellToolKit(void) { Shut(); }
		int Init(int argc, char *argv[], char *legalOptionChars = (char *) NULL);
		void Shut(void)
			{
			if (outFp != (FILE *) NULL)
				{
				printf("\nOutput is in \"%s\".\n", outputFileName);
				fclose(outFp);
				}
			if (inFp != stdin)
				fclose(inFp);
			}
		void OpenNextLogFile(void)
			{
			logFileNumber++;
			if (outFp != (FILE *) NULL)
				fclose(outFp);
			sprintf(outputFileName,"%s%d.log", logFileBaseName, logFileNumber);
			outFp = fopen(outputFileName,"w");
			}
		void CloseLogFile(void)
			{
			if (outFp != (FILE *) NULL)
				{
				fclose(outFp);
				outFp = (FILE *) NULL;
				}
			}
		void Print(char *format, ...);
		void VerbosePrint(char *format, ...);
		void PrintDump(unsigned char *bp, int len, int maxlen=0, BOOL dumpASCII=TRUE);
		void VerbosePrintDump(unsigned char *bp, int len, int maxlen=0, BOOL dumpASCII=TRUE);
		void PrintSetup(char *filename = (char *) NULL, FILE *screenFp = stdout);
		int StripTrailingWhitespace(char *instr);
		int SubstrIndex(char *instr, char *substr);
		int TranslateChars(char *instr, char *outstr, char from, char to);;
		int BaseName(char *instr, char *dir, char *bname, char *ext, char newSlash);
		int AnalyzeFileSpec(char *instr, char &driveLetter, char *dir, char *bname, char *ext);
		int GetYorNwithDefault(int defaultBool);
		int GetPositiveInt(void);

#ifdef WIN32
		int CheckPath( char *pBaseName,		// base name of file to find
						   char *pRelDir,			// relative directory path
						   char *pSearchPath,	// NULL terminated search paths
							int lSearchPath,		// length of search path string
							char *pReturn,			// return path buffer pointer
							int sReturn	);			// size of return path buffer
		int FindFileInPath( char *pBaseName,	// base name of file to find
						        char *pRelDir,		// relative directory path
							  	  char *pPathStr,	// NULL terminated search paths
								  char path_delim,	// path delimiter character
								  char *pReturn,		// return path buffer pointer
								  int sReturn );		// size of return path buffer
		int FindFileInEnvPath(char *defaultFname, char *envPathVar, char *resultFname);
#endif // WIN32

		int GetStandardProgramOptions(int argc, char *argv[],	char *legalOptionChars);
		BOOL CheckProgramFlag(int argc, char *argv[], char flagChar);
		BOOL CheckProgramWordFlag(int argc, char *argv[], char *flagStr);
		BOOL GetProgramOptionWithParameter(int argc, char *argv[],
													  char flagChar, char *paramStr);
		BOOL GetProgramWordOptionWithParameter(int argc, char *argv[],
															char *flagStr, char *&paramStr);
		void InitOptionChars(char *optionChars)
			{
			int	i;

			if (optionChars != (char *) NULL)
				strcpy(legalOptionChars,optionChars);
			for (i=0; i<MAX_OPTIONS; i++)
				{
				optionSet[i] = (char) NULL;
				optionArg[i] = (char *) NULL;
				}
			optionCount = 0;
			}
		void SetOptionFlag(char optChar)
			{
			BOOL	done = FALSE;
			for (int i=0; i < optionCount && done == FALSE; i++)
				{
				if (optionSet[i] == optChar)
					done = TRUE;
				}
			if (!done)
				{
				if (optionCount < MAX_OPTIONS)
					optionSet[optionCount++] = optChar;
				}
			}
		BOOL GetOptionFlag(char optChar)
			{
			BOOL	done = FALSE;
			for (int i=0; i < optionCount && done == FALSE; i++)
				{
				if (optionSet[i] == optChar)
					done = TRUE;
				}
			return done;
			}
		void SetOptionParameter(char optChar, char *optArg)
			{
			BOOL	done = FALSE;
			for (int i=0; i < optionCount && done == FALSE; i++)
				{
				if (optionSet[i] == optChar)
					{
					optionArg[i] = optArg;
					done = TRUE;
					}
				}
			if (!done)
				{
				if (optionCount < MAX_OPTIONS)
					{
					optionArg[optionCount] = optArg;
					optionSet[optionCount++] = optChar;
					}
				}
			}
		char * GetOptionParameter(char optChar)
			{
			char *done = (char *) NULL;
			for (int i=0; i < optionCount && done == (char *) NULL; i++)
				{
				if (optionSet[i] == optChar)
					done = optionArg[i];
				}
			return done;
			}
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\support\AVDataBase\SWCMCFG.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//
//  $Workfile: SWCMCFG.h $
//
//  Copyright (c) 1999  Quadrant International, Inc.
//  All Rights Reserved.
//
//////////////////////////////////////////////////////////////////////////////
//
// $Archive: /Tproj/library/support/AVDataBase/SWCMCFG.h $
// $Author: Fhermanson $
// $Modtime: 12/21/00 11:58a $
// $Date: 2/01/01 2:10p $
// $Revision: 2 $
//
////////////////////////////////////$NoKeywords: $////////////////////////////

#ifndef __SWCMCFG_H
#define __SWCMCFG_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef SWCMCFG_EXPORTS
#define SWCMCFG_API __declspec(dllexport)
#else
#define SWCMCFG_API __declspec(dllimport)
#endif

typedef int HCFGDB;

///////////////////////////////////////////////////////////////////////////////
//
// SWCMCFG_Initialize()
//
// Description:  This function sets the Software CineMaster configuration
//               data according to the following system information:
//
//                   Display Devices (VGA Card(s))
//                   Sound Devices
//                   CPU Type
//                   CPU Speed
//
//               This must be called before using any of the configuration
//               access functions.
//               It may be called more than once (e.g. on device change)
//
// Arguments:    void -
//
// Return:       SWCMCFG_API int  - Error value
//                          0 = Failed
//                          1 = Success
//
///////////////////////////////////////////////////////////////////////////////
SWCMCFG_API int WINAPI SWCMCFG_Initialize(void);

///////////////////////////////////////////////////////////////////////////////
//
// SWCMCFG_OpenDB()
//
// Description:  Returns a handle to a specific database for using GetInt
//
// Arguments:    LPCTSTR lpszDBName - Name of database
//                      (e.g. "Software Cinemaster\\2.0")
//
// Return:       SWCMCFG_API HCFGDB - >0 if successfull
//
///////////////////////////////////////////////////////////////////////////////
SWCMCFG_API HCFGDB WINAPI SWCMCFG_OpenDB(LPCTSTR lpszDBName);

///////////////////////////////////////////////////////////////////////////////
//
// int SWCMCFG_CloseDB()
//
// Arguments:    HCFGDB hDB - Handle to open DB
//
// Return:       SWCMCFG_API int - Error value
//                          0 = Failed
//                          1 = Success
//
///////////////////////////////////////////////////////////////////////////////
SWCMCFG_API int WINAPI SWCMCFG_CloseDB(HCFGDB hDB);

///////////////////////////////////////////////////////////////////////////////
//
// SWCMCFG_GetInt()
//
//
// Description:  Gets the value of the specified Software CineMaster
//               configuration item.
//
// Arguments:    HCFGDB  hDB - handle returned from SWCMCFG_OpenDB().
//               LPCTSTR lpszCfgItemName - Name of config item
//                                         (e.g. "VideoDecoder.PerformanceClass")
//               int nDefValue - this value is returned if no other value is found
//               int nDisplayDev - If this configuration item is
//                      related to the Display Device (VGA card), then this
//                      value is used to select either a default value or
//                      a value from the VGA card database for the specified
//                      VGA device.
//                         0 - This specifies to use the default value (as if
//                             the VGA card was NOT known.
//                         >= 1 - This specifies which VGA card (if multiple)
//                            to retrieve the value for (this is the DDRAW
//                            DevEnum + 1).
//                            If the vga card is not recognized, a default
//                            value will be returned.
//                      If the configuration item is NOT display (VGA)
//                      dependent, then this parameter has no effect.
//               int nSoundDev - If this configuration item is
//                      related to the Sound Card, then this
//                      value is used to select either a default value or
//                      a value from a Sound Card database for the specified
//                      Sound device.
//                         0 - This specifies to use the default value (as if
//                             the Sound card was NOT known.
//                         >= 1 - This specifies which Sound card (if multiple)
//                            to retrieve the value for (this is the DSOUND
//                            DevEnum + 1).
//                            If the sound card is not recognized, a default
//                            value will be returned.
//                      If the configuration item is NOT Sound card
//                      dependent, then this parameter has no effect.
//               int& nValue - This is the returned value if successful.
//
// Return:       SWCMCFG_API int  - Error value
//                          0 = Failed
//                          1 = Success
//
///////////////////////////////////////////////////////////////////////////////
SWCMCFG_API  int WINAPI SWCMCFG_GetInt(HCFGDB hDB, LPCTSTR lpszCfgItemName,
                                int nDefValue, int nDisplayDev, int nSoundDev,
                                int& nValue);

#ifdef __cplusplus
}   // extern "C" {
#endif

#endif // __SWCMCFG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\inc\dashst.h ===
#ifndef _DASHST_
#define _DASHST_

#ifdef __cplusplus
extern "C" {
#endif


BOOL
DashBeginUsingSoundtracks (
    VOID
    );

VOID
DashEndUsingSoundtracks (
    VOID
    );

BOOL
DashAddSoundtrack (
    PCWSTR SoundtrackName,
    PDWORD Stid
    );

BOOL
DashDeleteSoundtrack (
    DWORD Stid
    );


BOOL
DashDeleteSongFromSoundtrack (
    IN DWORD Stid,
    IN UINT Index
    );

BOOL
DashAddSongToSoundtrack (
    IN DWORD Stid,
    IN DWORD Songid,
    IN DWORD Length,
    IN PCWSTR Name
    );

BOOL
DashSwapSoundtracks (
    UINT Stid1,
    UINT Stid2
    );

BOOL
DashSwapSongs (
    DWORD Stid,
    DWORD Index1,
    DWORD Index2
    );

DashEditSoundtrackName (
    UINT Stid,
    PCWSTR NewName
    );

DashEditSongName (
    UINT Stid,
    UINT Index,
    PCWSTR NewName
    );

DWORD
DashGetSoundtrackCount (
    VOID
    );

DWORD
DashGetNewSongId (
    DWORD Stid
    );




#ifdef __cplusplus
}
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\support\vdsup32\win32\VDCommon.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef VDCOMMON_H
#define VDCOMMON_H

#ifdef _XBOX
#include <xtl.h>
#else
#include <windows.h>
#endif
#include "library\common\vddebug.h"
#include "library\support\aspi32\wnaspi32.h"

typedef struct VDASPIStruct
	{
	HANDLE		event;

	DWORD (__cdecl * xSendASPI32Command )   (LPSRB);
	DWORD (__cdecl * xGetASPI32SupportInfo) (VOID);

	}	*	VDASPIHandle;



#if !WINNT
#define DllEXPORT	__declspec( dllexport )
#else
#define DllEXPORT

#endif


extern "C"
	{
	DllEXPORT void		WINAPI VD32_VOID();
	DllEXPORT HANDLE	WINAPI VD32_OpenFile(const char * name, BOOL readWrite);
	DllEXPORT HANDLE	WINAPI VD32_CreateFile(const char * name);
	DllEXPORT void		WINAPI VD32_CloseFile(HANDLE file);
	DllEXPORT DWORD	WINAPI VD32_ReadFile(HANDLE file, void * data, DWORD size);
	DllEXPORT DWORD	WINAPI VD32_WriteFile(HANDLE file, void * data, DWORD size);
	DllEXPORT void		WINAPI VD32_SeekFile(HANDLE file, DWORD &low, DWORD &high);
	DllEXPORT void		WINAPI VD32_GetFileSize(HANDLE file, DWORD &low, DWORD &high);

	DllEXPORT BOOL		WINAPI VD32_GetPrivateProfileString(char * section, char * entry, char * initBuff, char * buff,
	                                      int size, char * fileName);
	DllEXPORT BOOL		WINAPI VD32_WritePrivateProfileString(char * section, char * entry, char * value, char * fileName);
	DllEXPORT BOOL		WINAPI VD32_GetPrivateProfileDWORD(char * section, char * entry, DWORD init, DWORD * buff,
	                                                 char * fileName);
	DllEXPORT BOOL		WINAPI VD32_WritePrivateProfileDWORD(char * section, char * entry, DWORD value, char * fileName);

#if !WINNT
	DllEXPORT void		WINAPI VD32_Sleep(DWORD millisecs);
	DllEXPORT VDASPIHandle		WINAPI VD32_OpenASPI(void);
	DllEXPORT void		WINAPI VD32_CloseASPI(VDASPIHandle handle);
	DllEXPORT DWORD		WINAPI VD32_GetASPISupportInfo(VDASPIHandle handle);
	DllEXPORT BOOL		WINAPI VD32_SendASPICommand(VDASPIHandle handle, SRB_ExecSCSICmd * cmd, void * buffer);
	DllEXPORT BOOL		WINAPI VD32_GetASPIDiskInfo(VDASPIHandle handle, SRB_GetDiskInfo * info);
#endif
	}


#endif // VDCOMMON_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\alerts.h ===
//-----------------------------------------------------------------------------
// -------------------
// File ....: alerts.h
// -------------------
// Author...: Gus J Grubba
// Date ....: April 1997
// O.S. ....: Windows NT 4.0
//
// History .: Apr, 02 1997 - Created
//
// 3D Studio Max Notification Alerts
//
//-----------------------------------------------------------------------------

#ifndef _ALERTS_H_
#define _ALERTS_H_

#define NOTIFY_FAILURE		(1<<0)
#define NOTIFY_PROGRESS		(1<<1)
#define NOTIFY_COMPLETION	(1<<2)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\support\WinSock\SOCKCORE.H ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __SOCKCORE_H_
#define __SOCKCORE_H_


#define XASSERT(x) if( !(x) ) _asm int 3

	#include <xtl.h>

#define FD_READ_BIT      0
#define FD_READ          (1 << FD_READ_BIT)

#define FD_WRITE_BIT     1
#define FD_WRITE         (1 << FD_WRITE_BIT)

#define FD_OOB_BIT       2
#define FD_OOB           (1 << FD_OOB_BIT)

#define FD_ACCEPT_BIT    3
#define FD_ACCEPT        (1 << FD_ACCEPT_BIT)

#define FD_CONNECT_BIT   4
#define FD_CONNECT       (1 << FD_CONNECT_BIT)

#define FD_CLOSE_BIT     5
#define FD_CLOSE         (1 << FD_CLOSE_BIT)

#define FD_QOS_BIT       6
#define FD_QOS           (1 << FD_QOS_BIT)

#define FD_GROUP_QOS_BIT 7
#define FD_GROUP_QOS     (1 << FD_GROUP_QOS_BIT)

#define FD_ROUTING_INTERFACE_CHANGE_BIT 8
#define FD_ROUTING_INTERFACE_CHANGE     (1 << FD_ROUTING_INTERFACE_CHANGE_BIT)

#define FD_ADDRESS_LIST_CHANGE_BIT 9
#define FD_ADDRESS_LIST_CHANGE     (1 << FD_ADDRESS_LIST_CHANGE_BIT)

#define FD_MAX_EVENTS    10
#define FD_ALL_EVENTS    ((1 << FD_MAX_EVENTS) - 1)



/////////////////////////////////////////////////////////////////////////////
// CAsyncSocket

class CAsyncSocket
{
protected:
	HANDLE	m_hInstSOCK;
	int		m_nSockTerm;
	HANDLE	m_hSocketWindow;
	SOCKET	m_hSocket;

	void SocketTerm(void);

// Construction
public:
	CAsyncSocket();
	~CAsyncSocket();
	BOOL SocketInit(WSADATA* lpwsaData = NULL);

	BOOL Create(UINT nSocketPort = 0, int nSocketType=SOCK_STREAM,
		long lEvent = FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE,
		LPCTSTR lpszSocketAddress = NULL);

	operator SOCKET() const
		{ return m_hSocket; }

	BOOL Attach(SOCKET hSocket, long lEvent =
		FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE);
	SOCKET Detach();

	BOOL GetPeerName(LPSTR& rPeerAddress, UINT& rPeerPort);
	BOOL GetPeerName(SOCKADDR* lpSockAddr, int* lpSockAddrLen)
		{ return (SOCKET_ERROR != getpeername(m_hSocket, lpSockAddr, lpSockAddrLen)); }

	BOOL GetSockName(LPSTR& rSocketAddress, UINT& rSocketPort);
	BOOL GetSockName(SOCKADDR* lpSockAddr, int* lpSockAddrLen)
		{ return (SOCKET_ERROR != getsockname(m_hSocket, lpSockAddr, lpSockAddrLen)); }

	BOOL SetSockOpt(int nOptionName, const void* lpOptionValue, int nOptionLen, int nLevel = SOL_SOCKET)
		{ return (SOCKET_ERROR != setsockopt(m_hSocket, nLevel, nOptionName, (LPCSTR)lpOptionValue, nOptionLen)); }
	BOOL GetSockOpt(int nOptionName, void* lpOptionValue, int* lpOptionLen, int nLevel = SOL_SOCKET)
		{ return (SOCKET_ERROR != getsockopt(m_hSocket, nLevel, nOptionName, (LPSTR)lpOptionValue, lpOptionLen)); }

//	static CAsyncSocket* PASCAL FromHandle(SOCKET hSocket)
//		{ return LookupHandle(hSocket, FALSE); }

//	static CAsyncSocket* PASCAL LookupHandle(SOCKET hSocket, BOOL f)
//		{ return FALSE; }

	static int PASCAL GetLastError()
		{ return WSAGetLastError(); }


// Operations
public:

	virtual BOOL Accept(CAsyncSocket& rConnectedSocket,
		SOCKADDR* lpSockAddr = NULL, int* lpSockAddrLen = NULL);

	BOOL Bind(UINT nSocketPort, LPCTSTR lpszSocketAddress = NULL);
	BOOL Bind (const SOCKADDR* lpSockAddr, int nSockAddrLen)
		{ return (SOCKET_ERROR != bind(m_hSocket, lpSockAddr, nSockAddrLen)); }

	virtual void Close();

	BOOL Connect(LPCTSTR lpszHostAddress, UINT nHostPort);
	BOOL Connect(const SOCKADDR* lpSockAddr, int nSockAddrLen)
		{ return ConnectHelper(lpSockAddr, nSockAddrLen); }

	BOOL IOCtl(long lCommand, DWORD* lpArgument)
		{ return (SOCKET_ERROR != ioctlsocket(m_hSocket, lCommand, lpArgument)); }

	BOOL Listen(int nConnectionBacklog=5)
		{ return (SOCKET_ERROR != listen(m_hSocket, nConnectionBacklog)); }

	virtual int Receive(void* lpBuf, int nBufLen, int nFlags = 0);

	int ReceiveFrom(void* lpBuf, int nBufLen, LPSTR& rSocketAddress, UINT& rSocketPort, int nFlags = 0);
	int ReceiveFrom(void* lpBuf, int nBufLen,	SOCKADDR* lpSockAddr, int* lpSockAddrLen, int nFlags = 0)
		{ return ReceiveFromHelper(lpBuf, nBufLen, lpSockAddr, lpSockAddrLen, nFlags); }

	enum { receives = 0, sends = 1, both = 2 };
	BOOL ShutDown(int nHow = sends)
		{ return (SOCKET_ERROR != shutdown(m_hSocket,nHow)); }

	virtual int Send(const void* lpBuf, int nBufLen, int nFlags = 0);

	int SendTo(const void* lpBuf, int nBufLen, UINT nHostPort, LPCTSTR lpszHostAddress = NULL, int nFlags = 0);
	int SendTo(const void* lpBuf, int nBufLen, const SOCKADDR* lpSockAddr, int nSockAddrLen, int nFlags = 0)
		{ return SendToHelper(lpBuf, nBufLen, lpSockAddr, nSockAddrLen, nFlags); }


	BOOL AsyncSelect(long lEvent =
		FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE);

// Overridable callbacks
protected:
	virtual void OnReceive(int nErrorCode);
	virtual void OnSend(int nErrorCode);
	virtual void OnOutOfBandData(int nErrorCode);
	virtual void OnAccept(int nErrorCode);
	virtual void OnConnect(int nErrorCode);
	virtual void OnClose(int nErrorCode);

// Implementation
public:
//	static CAsyncSocket* PASCAL LookupHandle(SOCKET hSocket, BOOL bDead = FALSE);
//	static void PASCAL AttachHandle(SOCKET hSocket, CAsyncSocket* pSocket, BOOL bDead = FALSE);
//	static void PASCAL DetachHandle(SOCKET hSocket, BOOL bDead = FALSE);
//	static void PASCAL KillSocket(SOCKET hSocket, CAsyncSocket* pSocket);
//	static void PASCAL DoCallBack(WPARAM wParam, LPARAM lParam);

	BOOL Socket(int nSocketType=SOCK_STREAM, long lEvent =
		FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE,
		int nProtocolType = 0, int nAddressFormat = PF_INET);

#ifdef _DEBUG
//	virtual void AssertValid() const;
#endif

protected:
	friend class CSocketWnd;

	virtual BOOL ConnectHelper(const SOCKADDR* lpSockAddr, int nSockAddrLen);
	virtual int ReceiveFromHelper(void* lpBuf, int nBufLen,
		SOCKADDR* lpSockAddr, int* lpSockAddrLen, int nFlags);
	virtual int SendToHelper(const void* lpBuf, int nBufLen,
		const SOCKADDR* lpSockAddr, int nSockAddrLen, int nFlags);
};

/////////////////////////////////////////////////////////////////////////////
// CSocket

class CSocket : public CAsyncSocket
{
//	DECLARE_DYNAMIC(CSocket);
private:
	CSocket(const CSocket& rSrc);         // no implementation
	void operator=(const CSocket& rSrc);  // no implementation

// Construction
public:
	CSocket();
	BOOL Create(UINT nSocketPort = 0, int nSocketType=SOCK_STREAM, LPCTSTR lpszSocketAddress = NULL)
		{ return CAsyncSocket::Create(nSocketPort, nSocketType, FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE, lpszSocketAddress); }

// Attributes
public:
	BOOL IsBlocking()
		{ return (m_pbBlocking != NULL); }

//	static CSocket* PASCAL FromHandle(SOCKET hSocket)
//		{ return (CSocket*)CAsyncSocket::LookupHandle(hSocket, FALSE); }

	BOOL Attach(SOCKET hSocket)
		{ return Attach(hSocket); }

// Operations
public:
	void CancelBlockingCall();

// Overridable callbacks
protected:
//	virtual BOOL OnMessagePending();

// Implementation
public:
	int m_nTimeOut;

	virtual ~CSocket();

	static int PASCAL ProcessAuxQueue();

	virtual BOOL Accept(CAsyncSocket& rConnectedSocket,
		SOCKADDR* lpSockAddr = NULL, int* lpSockAddrLen = NULL);
	virtual void Close();
	virtual int Receive(void* lpBuf, int nBufLen, int nFlags = 0);
	virtual int Send(const void* lpBuf, int nBufLen, int nFlags = 0);

	int SendChunk(const void* lpBuf, int nBufLen, int nFlags);

protected:
	BOOL* m_pbBlocking;
	int m_nConnectError;

	virtual BOOL ConnectHelper(const SOCKADDR* lpSockAddr, int nSockAddrLen);
	virtual int ReceiveFromHelper(void* lpBuf, int nBufLen,
		SOCKADDR* lpSockAddr, int* lpSockAddrLen, int nFlags);
	virtual int SendToHelper(const void* lpBuf, int nBufLen,
		const SOCKADDR* lpSockAddr, int nSockAddrLen, int nFlags);
//
//	static void PASCAL AuxQueueAdd(UINT message, WPARAM wParam, LPARAM lParam);
//
//	virtual BOOL PumpMessages(UINT uStopFlag);
//
//#ifdef _DEBUG
//	virtual void AssertValid() const;
//#endif
};


#endif // __SOCKCORE_H_

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\support\vdsup32\win32\vdcommon.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "vdcommon.h"



HINSTANCE		ASPIHandle;
bool				ASPIPossible		= TRUE;
VDASPIStruct *	ASPIStructHandle;
int				ASPICount			= 0;



void __stdcall VD32_VOID()
	{
	}

void  __stdcall VD32_Sleep(DWORD millisecs)
	{
	Sleep(millisecs);
	}

///////////////////////////////////////////////////////////////////////////////
// 32 Bit File Access
///////////////////////////////////////////////////////////////////////////////

HANDLE __stdcall VD32_OpenFile(const char * name, BOOL readWrite)
	{
	DP("Open File");
	if (readWrite)
		return CreateFile(name,
		                  GENERIC_READ | GENERIC_WRITE,
								0,
								NULL,
								OPEN_EXISTING,
								FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS,
								NULL);
	else
		return CreateFile(name,
		                  GENERIC_READ,
								FILE_SHARE_READ,
								NULL,
								OPEN_EXISTING,
								FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
								NULL);
	}

HANDLE __stdcall VD32_CreateFile(const char * name)
	{
	return CreateFile(name,
		               GENERIC_READ | GENERIC_WRITE,
							0,
							NULL,
							CREATE_ALWAYS,
							FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS,
							NULL);
	}

void  __stdcall VD32_CloseFile(HANDLE file)
	{
	CloseHandle(file);
	}

DWORD __stdcall VD32_ReadFile(HANDLE file, void * data, DWORD size)
	{
	ReadFile(file, data, size, &size, NULL);

	return size;
	}

DWORD __stdcall VD32_WriteFile(HANDLE file, void * data, DWORD size)
	{
	WriteFile(file, data, size, &size, NULL);

	return size;
	}

void __stdcall VD32_SeekFile(HANDLE file, DWORD &low, DWORD &high)
	{
	low = SetFilePointer(file, low, &(LONG &)high, FILE_BEGIN);
	}

void __stdcall VD32_GetFileSize(HANDLE file, DWORD &low, DWORD &high)
	{
	low = GetFileSize(file, &high);
	}


///////////////////////////////////////////////////////////////////////////////
// 32Bit ASPI Support
///////////////////////////////////////////////////////////////////////////////
#ifndef _XBOX

VDASPIHandle __stdcall VD32_OpenASPI(void)
	{

	DP("ASPI++");
	if (ASPIPossible)
		{
		if (ASPICount == 0)
			{
			ASPIPossible = false;
			ASPIStructHandle = new VDASPIStruct;

			ASPIHandle = LoadLibrary("WNASPI32.DLL");

			if (ASPIHandle)
				{
				(FARPROC &) (ASPIStructHandle->xSendASPI32Command) = GetProcAddress(ASPIHandle, "SendASPI32Command");
				(FARPROC &) (ASPIStructHandle->xGetASPI32SupportInfo) = GetProcAddress(ASPIHandle, "GetASPI32SupportInfo");
				if (ASPIStructHandle->xSendASPI32Command && ASPIStructHandle->xGetASPI32SupportInfo)
					{
					ASPIStructHandle->event = CreateEvent(NULL, FALSE, FALSE, NULL);

					ASPIPossible = true;
					ASPICount++;

					DP("Got ASPI");
					return ASPIStructHandle;
					}
				}
			}
		else
			{
			ASPICount++;
			return ASPIStructHandle;
			}
		}
	else
		return NULL;

	if (ASPIStructHandle)
		delete ASPIStructHandle;

	return NULL;
	}


void __stdcall VD32_CloseASPI(VDASPIHandle h)
	{
	if (ASPICount == 0)
		{
		DP("VDSUP32 : Release but no handle open");
		return;
		}

	if ((--ASPICount) == 0)
		{
		CloseHandle(ASPIStructHandle->event);

		delete ASPIStructHandle;
		}

	}

DWORD __stdcall VD32_GetASPISupportInfo(VDASPIHandle h)
	{
	if (ASPIStructHandle)
		{
		return ASPIStructHandle->xGetASPI32SupportInfo();
		}
	else
		return 0;
	}

BOOL __stdcall VD32_SendASPICommand(VDASPIHandle h, SRB_ExecSCSICmd * cmd, void * buffer)
	{
	if (ASPIStructHandle)
		{
		::ResetEvent(ASPIStructHandle->event);

		cmd->SRB_PostProc = ASPIStructHandle->event;
		cmd->SRB_BufPointer = (BYTE *)buffer;

		ASPIStructHandle->xSendASPI32Command((void*)cmd);

		if (cmd->SRB_Status == SS_PENDING) ::WaitForSingleObject(ASPIStructHandle->event, INFINITE);

		return cmd->SRB_Status == SS_COMP;
		}
	else
		return FALSE;
	}

BOOL __stdcall VD32_GetASPIDiskInfo(VDASPIHandle h, SRB_GetDiskInfo * info)
	{
	if (ASPIStructHandle)
		{
		ASPIStructHandle->xSendASPI32Command((void*)info);

		do {} while (info->SRB_Status == SS_PENDING);

		return info->SRB_Status == SS_COMP;
		}
	else
		return FALSE;
	}

///////////////////////////////////////////////////////////////////////////////
// 32Bit Registry Support
///////////////////////////////////////////////////////////////////////////////

BOOL __stdcall VD32_GetPrivateProfileString(char * section, char * entry,
	                                              char * initBuff, char * buff,
	                                              int size, char * fileName)
	{
	LONG	status;
	DWORD	dummy;
	HKEY key;
	char ebuffer[200];
	strcpy(buff, initBuff);
	BOOL res;
	DWORD	type;
	DWORD isize;

	strcpy(ebuffer, "Software\\Quadrant International, Inc.\\");
	strcat(ebuffer, fileName);
	strcat(ebuffer, "\\");
	strcat(ebuffer, section);

	status = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
									ebuffer,
									NULL,
									__TEXT(""),
									REG_OPTION_NON_VOLATILE,
									KEY_READ | KEY_WRITE,
									NULL,
									&key,
									&dummy);
	if (status == ERROR_SUCCESS)
		{
		res = TRUE;

		isize = size;

		if (RegQueryValueEx(key, entry, NULL, &type, (BYTE *)buff, &isize) == ERROR_SUCCESS)
			{
			if (type != REG_SZ) res = FALSE;
			}
		else
			res = FALSE;

		RegCloseKey(key);

		return res;
		}
	else
		return FALSE;
	}

BOOL __stdcall VD32_WritePrivateProfileString(char * section, char * entry, char * value, char * fileName)
	{
	LONG	status;
	DWORD	dummy;
	HKEY key;
	char ebuffer[200];
	BOOL res;

	strcpy(ebuffer, "Software\\Quadrant International, Inc.\\");
	strcat(ebuffer, fileName);
	strcat(ebuffer, "\\");
	strcat(ebuffer, section);

	status = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
									ebuffer,
									NULL,
									__TEXT(""),
									REG_OPTION_NON_VOLATILE,
									KEY_READ | KEY_WRITE,
									NULL,
									&key,
									&dummy);
	if (status == ERROR_SUCCESS)
		{
		res = TRUE;

		if (RegSetValueEx(key, entry, NULL, REG_SZ, (BYTE *)(TCHAR *)value, strlen(value)) == ERROR_SUCCESS)
			{
			}
		else
			res = FALSE;

		RegCloseKey(key);

		return res;
		}
	else
		return FALSE;
	}

BOOL __stdcall VD32_GetPrivateProfileDWORD(char * section, char * entry, DWORD init, DWORD * buff,
	                                              char * fileName)
	{
	LONG	status;
	DWORD	dummy;
	HKEY key;
	char ebuffer[200];
	BOOL res;
	DWORD	type;
	DWORD isize;

	*buff = init;
	strcpy(ebuffer, "Software\\Quadrant International, Inc.\\");
	strcat(ebuffer, fileName);
	strcat(ebuffer, "\\");
	strcat(ebuffer, section);

	status = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
									ebuffer,
									NULL,
									__TEXT(""),
									REG_OPTION_NON_VOLATILE,
									KEY_READ | KEY_WRITE,
									NULL,
									&key,
									&dummy);
	if (status == ERROR_SUCCESS)
		{
		res = TRUE;

		isize = 4;

		if (RegQueryValueEx(key, entry, NULL, &type, (BYTE *)buff, &isize) == ERROR_SUCCESS)
			{
			if (type != REG_DWORD && type != REG_BINARY) res = FALSE;
			}

		RegCloseKey(key);

		return res;
		}
	else
		return FALSE;
	}

BOOL __stdcall VD32_WritePrivateProfileDWORD(char * section, char * entry, DWORD value, char * fileName)
	{
	LONG	status;
	DWORD	dummy;
	HKEY key;
	char ebuffer[200];
	BOOL res;

	strcpy(ebuffer, "Software\\Quadrant International, Inc.\\");
	strcat(ebuffer, fileName);
	strcat(ebuffer, "\\");
	strcat(ebuffer, section);

	status = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
									ebuffer,
									NULL,
									__TEXT(""),
									REG_OPTION_NON_VOLATILE,
									KEY_READ | KEY_WRITE,
									NULL,
									&key,
									&dummy);
	if (status == ERROR_SUCCESS)
		{
		res = TRUE;

		if (RegSetValueEx(key, entry, NULL, REG_DWORD, (BYTE *)&value, 4) != ERROR_SUCCESS)
			res = FALSE;

		RegCloseKey(key);

		return res;
		}
	else
		return FALSE;
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\acolor.h ===
/**********************************************************************
 *<
	FILE: acolor.h

	DESCRIPTION:  floating point color + alpha

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef _ACOLOR_H 

#define _ACOLOR_H

#include "maxtypes.h"
#include "point3.h"
#include "color.h"

class AColor {
public:
	float r,g,b,a;

	// Constructors
	AColor()  {}
	AColor(float R, float G, float B, float A=1.0f)  { r = R; g = G; b = B; a = A; }
	AColor(double R, double G, double B, double A=1.0) {
		 r = (float)R; g = (float)G; b = (float)B; a = (float)A; }
	AColor(int R, int G, int B, int A=0) { 
		r = (float)R; g = (float)G; b = (float)B; a = (float)A; }
	AColor(const AColor& c) { r = c.r; g = c.g; b = c.b; a = c.a; } 
	AColor(const Color& c, float alph=1.0f) { r = c.r; g = c.g; b = c.b; a = alph; } 
	DllExport AColor(DWORD rgb, float alph=1.0f);  // from Windows RGB value
	AColor(float af[4]) { r = af[0]; g = af[1]; b = af[2];a = af[3]; }
	AColor(const BMM_Color_24& c) { 
		r = float(c.r)/255.0f; g = float(c.g)/255.0f; b = float(c.b)/255.0f; a = 1.0f; 
		}
	AColor(const BMM_Color_32& c) { 
		r = float(c.r)/255.0f; g = float(c.g)/255.0f; b = float(c.b)/255.0f; a = float(c.a)/255.0f; 
		}
	AColor(const BMM_Color_48& c) { 
		r = float(c.r)/65535.0f; g = float(c.g)/65535.0f; b = float(c.b)/65535.0f; a = 1.0f; 
		}
	AColor(const BMM_Color_64& c) { 
		r = float(c.r)/65535.0f; g = float(c.g)/65535.0f; b = float(c.b)/65535.0f; a = float(c.a)/65535.0f; 
		}
	
	void Black() { r = g = b = 0.0f; a = 1.0f; }
	void White() { r = g = b = 1.0f; a = 1.0f; }

	DllExport void ClampMax();  // makes components >= 0.0
	DllExport void ClampMin();  // makes components <= 1.0
    DllExport void ClampMinMax();  // makes components in [0,1]

	// Access operators
	float& operator[](int i) { return (&r)[i]; }     
	const float& operator[](int i) const { return (&r)[i]; }  

	// Conversion functions
	operator float*() { return(&r); }
	operator Color() { return Color(r,g,b); }

	// Convert to Bitmap Manager types
	operator BMM_Color_24() { 
		BMM_Color_24 c; 
		c.r = int(r*255.0f); c.g = int(g*255.0f); c.b = int(b*255.0f);
		return c;
		}
	operator BMM_Color_32() { 
		BMM_Color_32 c; 
		c.r = int(r*255.0f); c.g = int(g*255.0f); c.b = int(b*255.0f);	c.a = int(a*255.0f);
		return c;
		}
	operator BMM_Color_48() { 
		BMM_Color_48 c; 
		c.r = int(r*65535.0f); c.g = int(g*65535.0f); c.b = int(b*65535.0f); 
		return c;
		}
	operator BMM_Color_64() { 
		BMM_Color_64 c; 
		c.r = int(r*65535.0f);	c.g = int(g*65535.0f);	c.b = int(b*65535.0f);	c.a = int(a*65535.0f);
		return c;
		}

	// Convert to Windows RGB
	operator DWORD() { return RGB(FLto255(r),FLto255(g), FLto255(b)); }

	// Convert to Point3
	operator Point3() { return Point3(r,g,b); }

	// Unary operators
	AColor operator-() const { return (AColor(-r,-g,-b, -a)); } 
	AColor operator+() const { return *this; } 

	// Assignment operators
	inline AColor& operator-=(const AColor&);
    inline AColor& operator+=(const AColor&);
	inline AColor& operator*=(float); 
	inline AColor& operator/=(float);
	inline AColor& operator*=(const AColor&);	// element-by-element multiplg.

	// Test for equality
	int operator==(const AColor& p) const { return ((p.r==r)&&(p.g==g)&&(p.b==b)&&(p.a==a)); }
	int operator!=(const AColor& p) const { return ((p.r!=r)||(p.g!=g)||(p.b!=b)||(p.a!=a)); }

	// Binary operators
	inline AColor operator-(const AColor&) const;
	inline AColor operator+(const AColor&) const;
	inline AColor operator/(const AColor&) const;
    inline AColor operator*(const AColor&) const;   
	inline AColor operator^(const AColor&) const;   // CROSS PRODUCT
	};

int DllExport MaxComponent(const AColor&);  // the component with the maximum abs value
int DllExport MinComponent(const AColor&);  // the component with the minimum abs value

// Inlines:

inline AColor& AColor::operator-=(const AColor& c) {	
	r -= c.r;	g -= c.g;	b -= c.b;  a -= c.a;
	return *this;
	}

inline AColor& AColor::operator+=(const AColor& c) {
	r += c.r;	g += c.g;	b += c.b; a += c.a;
	return *this;
	}

inline AColor& AColor::operator*=(float f) {
	r *= f;   g *= f;	b *= f;  a *= f;
	return *this;
	}

inline AColor& AColor::operator/=(float f) { 
	r /= f;	g /= f;	b /= f;	a /= f;
	return *this; 
	}

inline AColor& AColor::operator*=(const AColor& c) { 
	r *= c.r;	g *= c.g;	b *= c.b;	a *= c.a;
	return *this; 
	}


inline AColor AColor::operator-(const AColor& c) const {
	return(AColor(r-c.r,g-c.g,b-c.b,a-c.a));
	}

inline AColor AColor::operator+(const AColor& c) const {
	return(AColor(r+c.r,g+c.g,b+c.b,a+c.a));
	}

inline AColor AColor::operator/(const AColor& c) const {
	return AColor(r/c.r,g/c.g,b/c.b,a/c.a);
	}

inline AColor AColor::operator*(const AColor& c) const {  
	return AColor(r*c.r, g*c.g, b*c.b, a*c.a);	
	}

inline AColor operator*(float f, const AColor& a) {
	return(AColor(a.r*f, a.g*f, a.b*f, a.a*f));
	}

inline AColor operator*(const AColor& a, float f) {
	return(AColor(a.r*f, a.g*f, a.b*f, a.a*f));
	}

// Composite  fg over bg, assuming associated alpha,
// i.e. pre-multiplied alpha for both fg and bg
inline AColor CompOver(const AColor &fg, const AColor& bg) {
	return  fg + (1.0f-fg.a)*bg;
	}

typedef AColor RGBA;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\animtbl.h ===
/**********************************************************************
 *<
	FILE:  animtbl.h

	DESCRIPTION:  Defines Animatable Classes

	CREATED BY: Rolf Berteig & Dan Silva

	HISTORY: created 9 September 1994

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef _ANIMTBL_H_
#define _ANIMTBL_H_


#define ANIMTYPE_NODE		1
#define ANIMTYPE_ROOTNODE	3
#define ANIMTYPE_CONTROL	2

/*---------------------------------------------------*/

class TreeListExp; 
class AnimEnum;
class ReferenceTarget;
class DWORDTab;
class IObjParam;
class INodeTab;
class AppDataChunk;
class IParamBlock2;

// The maximum number of track views that can be opened. Each
// animatable stores 3 bits for each track to identify it's open/close
// state and selection state.
#define MAX_TRACK_VIEWS	16

#define ALL_TRACK_VIEWS	0xffff

// The maximum number of track view selection sets
#define MAX_TRACKVIEW_SELSETS	16


// Values for flags in aflag
#define A_EVALUATING 		1
#define A_NOTIFYDEP  		(1<<1)
#define A_CHILD_TREE_OPEN 	(1<<2)
#define A_SUBANIM_TREE_OPEN	(1<<3)
#define A_OBJECT_REDUCED	(1<<4)

// BITS 5-11 are reserved for specific sub-class use.

// Atmospheric flags
#define A_ATMOS_DISABLED	(1<<5)

// OBJECT flags
#define A_OBJ_CREATING		(1<<5)		// The object is being created. It doesn't want to snap to itself.
#define A_OBJ_BEING_EDITED (1<<7)
#ifdef _OSNAP
#define A_OBJ_LONG_CREATE   (1<<6)		// Persists throughout the wholle creation process as 
										// opposed to the previous flag which gets cleared as 
										// as the object is added to the scene.
#endif

// MODIFIER flags . 
#define A_MOD_DISABLED			(1<<5)     // Modifier flag
#define A_MOD_BEING_EDITED		(1<<6)
#define A_MOD_USE_SEL			(1<<7)     // Modifier flag (use sub-ob selection)
#define A_MOD_DISABLED_INVIEWS	(1<<8)     // Modifier is disabled in viewports only

// MODAPP flags. 
#define A_MODAPP_DISABLED		(1<<5)  // ModApp flag
#define A_MODAPP_SELECTED		(1<<6)  // ModApp flag (parent node is selected)
#define A_MODAPP_DISPLAY_ACTIVE (1<<7)  // ModApp flag
#define A_MODAPP_DYNAMIC_BOX  	(1<<8)  // ModApp flag
#define A_MODAPP_RENDERING		(1<<9)  // Render begin turns this on and render end turns it off

// Derived Object Flags
#define A_DERIVEDOBJ_DONTDELETE	(1<<9)	// When the last modifier is deleted form this derived object, don't delete the derived object

// CONTROL flags
#define A_ORT_MASK				7
#define A_ORT_BEFORESHIFT		5	// Uses bit 5,6,7,8,9 and 10 to store ORT
#define A_ORT_AFTERSHIFT		8
#define A_CTRL_DISABLED			(1<<11)
#define A_ORT_DISABLED			A_SUPERCLASS1  // indicates that the ORT is disabled

// INODE flags
#define A_INODE_IK_TERMINATOR	(1<<5)	// Terminates the top of an IK chain
#define A_INODE_IK_POS_PINNED	(1<<6)
#define A_INODE_IK_ROT_PINNED	(1<<7)
#ifdef _OSNAP
#define A_INODE_CLONE_TARGET	(1<<8)
#endif
#define A_COMPONENT_LOCKED		(1<<19)	// needed for CompositeBase and its children

// Flags for Hold and Restore logic, for "lazy holding",
// to avoid multiple holding.
#define A_HELD				(1<<12)
#define A_SET				(1<<13)

// Deleted but kept around for UNDO
#define A_IS_DELETED		(1<<14)

// To prevent AutoDelete from being re-entered.
#define A_BEING_AUTO_DELETED  (1<<15)

// Reserved for superclass use
#define A_SUPERCLASS1		(1<<20)
#define A_SUPERCLASS2		(1<<21)

// These are reserved for use by the plug-in. No should will set these flags (except the plug-in class itself)
#define A_PLUGIN1			(1<<22)
#define A_PLUGIN2			(1<<23)
#define A_PLUGIN3			(1<<24)
#define A_PLUGIN4			(1<<25)

// Used to test for a dependency
#define A_DEPENDENCY_TEST	(1<<26)

// Ref target isn't deleted when dependents goes to 0 if this flag is set.
#define A_LOCK_TARGET		(1<<27)

#define A_WORK1				(1<<28)
#define A_WORK2				(1<<29)
#define A_WORK3				(1<<30)
#define A_WORK4				(1<<31)

#define A_OPENFLAG(t) ((t==0)?A_CHILD_TREE_OPEN:A_SUBANIM_TREE_OPEN)


class TimeMap {
	public:
		virtual TimeValue map(TimeValue t)=0;
		virtual TimeValue prevmap(TimeValue t)=0;
	};

class TrackHitRecord  {
	public:
		DWORD	hit;
		DWORD	flags;
		TrackHitRecord(DWORD h=0,DWORD f=0) {hit=h;flags=f;}
	};
typedef Tab<TrackHitRecord> TrackHitTab;


// Flags passed to MapKeys and DeleteKeys
#define TRACK_DOSEL			(1<<0)
#define TRACK_DOALL			(1<<1)  // ignore selection
#define TRACK_SLIDEUNSEL	(1<<2)  // Slide unselected keys to the right
#define TRACK_RIGHTTOLEFT	(1<<3)  // Enumerate right to left. If TRACK_SLIDEUNSEL is set, keys will slide to the left.
#define TRACK_DOSUBANIMS	(1<<4)  // This flag is only passed to MapKeys
#define TRACK_DOCHILDNODES	(1<<5)	// This flag is only passed to MapKeys
#define TRACK_MAPRANGE		(1<<6)	// The range, if not locked to first and last key, should be mapped as well.

// Flags passed to EditTimeRange
#define EDITRANGE_LINKTOKEYS	(1<<0)	// This means if one of the ends of the interval is at a key, link it to the key so that if the key moves, the interval moves.

// Flags passed to hit test tracks and fcurves.
#define HITTRACK_SELONLY		(1<<0)
#define HITTRACK_UNSELONLY		(1<<1)
#define HITTRACK_ABORTONHIT		(1<<2)
#define HITCURVE_TESTTANGENTS	(1<<3)
#define HITTRACK_SUBTREEMODE	(1<<4)  // Subtree mode is on so the anim is being asked to hittest itself in one of its ancestor's tracks

// Flags passed to SelectKeys
// Either SELECT, DESELECT, or a combination of CLEARKEYS and CLEARCURVE
// will be specified.
#define SELKEYS_SELECT			(1<<0)	
#define SELKEYS_DESELECT		(1<<1)
#define SELKEYS_CLEARKEYS		(1<<2)		 
#define SELKEYS_CLEARCURVE		(1<<3) 
#define SELKEYS_FCURVE			(1<<4) 	// indicates that were operating on keys of a function curve, not a track  


// Flags passed to GetTimeRange
#define TIMERANGE_SELONLY		(1<<0)	// The bounding interval of selected keys
#define TIMERANGE_ALL			(1<<1)  // Whatever the channel's time range is - usually the bunding interval of all keys.
#define TIMERANGE_CHILDNODES	(1<<2)  // A node's time range should include child nodes.
#define TIMERANGE_CHILDANIMS	(1<<3)  // A animatable's child anim ranges should be included

// Passed to the functions that modify a time range such as copy,paste,delete,reverse
#define TIME_INCLEFT		(1<<10)  // Include left endpoint
#define TIME_INCRIGHT		(1<<11)  // Include right endpoint
#define TIME_NOSLIDE		(1<<12)  // Delete any keys in the interval but don't actually remove the block of time.

// In addition to the TIME_ flags above, the following flag may be passed to PasteTrck()
#define PASTE_RELATIVE		(1<<20)	// Add the keys relative to existing keys

// Flags passed to AddKey
#define ADDKEY_SELECT		(1<<0)  // Select the new key and deselect any other selected keys
#define ADDKEY_INTERP		(1<<1)  // Init the new key to the interpolated value at that time. Otherwise, init the key to the value of the previous key.
#define ADDKEY_FLAGGED		(1<<2)  // Flag the newly created key as if FlagKey() was called for it

// Flags passed to CopyKeysFromTime()
#define COPYKEY_POS			(1<<0)	// These filter flags are passed to a tm controller. The tm
#define COPYKEY_ROT			(1<<1)	// can decide what to do with them... they have obvious meaning
#define COPYKEY_SCALE		(1<<2)	// For the PRS controller.

// Flags passed to GetNextKeyTime()
#define NEXTKEY_LEFT		(1<<0)	// Search to the left.
#define NEXTKEY_RIGHT		(1<<1)  // Search to the right.
#define NEXTKEY_POS			(1<<2)
#define NEXTKEY_ROT			(1<<3)
#define NEXTKEY_SCALE		(1<<4)

// Flags passed to IsKeyAtTime
#define KEYAT_POSITION		(1<<0)
#define KEYAT_ROTATION		(1<<1)
#define KEYAT_SCALE			(1<<2)

// Flags passed to PaintTrack and PaintFCurves
#define PAINTTRACK_SHOWSEL			(1<<0)
#define PAINTTRACK_SHOWSTATS		(1<<1)	// Show for selected keys
#define PAINTCURVE_SHOWTANGENTS		(1<<2)	// Show for selected keys
#define PAINTCURVE_FROZEN			(1<<3)  // Curve is in a frozen state
#define PAINTCURVE_GENCOLOR			(1<<4)	// Draw curve in generic color
#define PAINTCURVE_XCOLOR			(1<<5)	// Draw curve in red
#define PAINTCURVE_YCOLOR			(1<<6)	// Draw curve in green
#define PAINTCURVE_ZCOLOR			(1<<7)	// Draw curve in blue
#define PAINTTRACK_SUBTREEMODE		(1<<8)  // Subtree mode is on so the anim is being asked to paint itself in one of its ancestor's tracks
#define PAINTTRACK_HIDESTATICVALUES (1<<9)  // Indicates that static values shouldn't be displayed in tracks.

// Flags passed to GetFCurveExtents
#define EXTENTS_SHOWTANGENTS		(1<<0) // Tangents are visible for selected keys


// Values returned from PaintTrack, PaintFCurve and HitTestTrack
#define TRACK_DONE			1		// Track was successfully painted/hittested
#define TRACK_DORANGE		2		// This anim has no track. Draw/hittest the bounding range of it's subanims
#define TRACK_ASKCLIENT		3		// Ask client anim to paint the track

// Values returned from HitTestFCurve
#define HITCURVE_KEY		1	// Hit one or more keys
#define HITCURVE_WHOLE		2   // Hit the curve (anywhere)
#define HITCURVE_TANGENT	3	// Hit a tangent handle
#define HITCURVE_NONE		4	// Didn't hit squat
#define HITCURVE_ASKCLIENT	5	// Ask client to hit test fcurve.

// These flags are passed into PaintFCurves, HitTestFCurves, and GetFCurveExtnents
// They are filters for controllers with more than one curve
// NOTE: RGB controllers interpret X as red, Y as green and Z as blue.
#define DISPLAY_XCURVE		(1<<29)
#define DISPLAY_YCURVE		(1<<30)
#define DISPLAY_ZCURVE		(1<<31)

// Values returned from GetSelKeyCoords()
#define KEYS_NONESELECTED	(1<<0)
#define KEYS_MULTISELECTED	(1<<1)
#define KEYS_COMMONTIME		(1<<2)  // Both of these last two bits
#define KEYS_COMMONVALUE	(1<<3)  // could be set.

// Flags passed to GetSelKeyCoords()
#define KEYCOORDS_TIMEONLY		(1<<0)
#define KEYCOORDS_VALUEONLY		(1<<1)

// Variable definitions for SetSelKeyCoordsExpr()
#define KEYCOORDS_TIMEVAR	_T("n")
#define KEYCOORDS_VALVAR	_T("n")

// Return values from SetSelKeyCoordsExpr()
#define KEYCOORDS_EXPR_UNSUPPORTED	0	// Don't implement this method
#define	KEYCOORDS_EXPR_ERROR		1   // Error in expression
#define KEYCOORDS_EXPR_OK			2   // Expression evaluated

// Returned from NumKeys() if the animatable is not keyframeable
#define NOT_KEYFRAMEABLE	-1

// Flags passed to AdjustTangents
#define ADJTAN_LOCK		(1<<0)
#define ADJTAN_BREAK	(1<<1)

// Flags passed to EditTrackParams
#define EDITTRACK_FCURVE	(1<<0)	// The user is in the function curve editor.
#define EDITTRACK_TRACK		(1<<1) 	// The user is in one of the track views.
#define EDITTRACK_SCENE		(1<<2)	// The user is editing a path in the scene.
#define EDITTRACK_BUTTON	(1<<3)	// The user invoked by choosing the properties button. In this case the time parameter is NOT valid.
#define EDITTRACK_MOUSE		(1<<4)	// The user invoked by right clicking with the mouse. In this case the time parameter is valid.


// These are returned from TrackParamsType(). They define how the track parameters are invoked.
#define TRACKPARAMS_NONE	0	// Has no track parameters
#define TRACKPARAMS_KEY		1	// Entered by right clicking on a selected key
#define TRACKPARAMS_WHOLE	2	// Entered by right clicking anywhere in the track.

// Flags passed into RenderBegin
#define RENDERBEGIN_IN_MEDIT   1   // Indicates that the render is occuring in the material editor.


// Macros for converting track screen coords to time and back.
#define TimeToScreen(t,scale,scroll) (int(floor((t)*(scale)+0.5)) - (scroll))
#define ScreenToTime(s,scale,scroll) ((int)floor((s)/(scale) + (scroll)/(scale)+0.5))
#define ValueToScreen(v,h,scale,scroll) (h-int(floor((v)*(scale)+0.5)) - (scroll))
#define ScreenToValue(s,h,scale,scroll) ((float(h)-(float(s)+float(scroll)))/(scale))

// Scales a value about an origin
#define ScaleAboutOrigin(val,origin,scale) ((((val)-(origin))*(scale))+(origin))


class TrackClipObject {
	public:
		// Specifies the interval of time clipped.
		Interval clip;		

		// Identifies the creator of the clip object
		virtual SClass_ID 	SuperClassID()=0;
		virtual Class_ID	ClassID()=0;

		TrackClipObject(Interval iv) {clip = iv;}
		virtual void DeleteThis()=0;

		virtual int NumKeys() {return 0;}
		virtual BOOL GetKeyVal(int i, void *val) {return FALSE;}
		virtual BOOL SetKeyVal(int i, void *val) {return FALSE;}
	};


// This must be updated if a new entry is added to DimType!
#define NUM_BUILTIN_DIMS	10

enum DimType {
	DIM_WORLD,
	DIM_ANGLE,
	DIM_COLOR,	 	//0-1
	DIM_COLOR255,	//0-255
	DIM_PERCENT,  	//0-100
	DIM_NORMALIZED,	//0-1
	DIM_SEGMENTS,
	DIM_TIME,
	DIM_CUSTOM,
	DIM_NONE
	};

// These two classes describes the dimension of a parameter (sub-anim).
// The dimension type and possibly the dimension scale (if the type is
// custom) are used to determine a scale factor for the parameter.
// When a controller is drawing a function curve, it only needs to
// use the Convert() function - the scale factor is rolled into the single
// 'vzoom' parameter passed to PaintFCurves.
// So, for a controller to plot a value 'val' at time t it would do the
// following:
// int x = TimeToScreen(t,tzoom,tscroll);
// int y = ValueToScreen(dim->Convert(val),rect.h()-1,vzoom,vscroll);
//
class ParamDimensionBase {
	public:
		virtual DimType DimensionType()=0;
		virtual float Convert(float value)=0;
		virtual float UnConvert(float value)=0;
	}; 
class ParamDimension : public ParamDimensionBase {
	public:
		// If the DimType is custom than these must be implemented.
		virtual float GetDimScale() {return 1.0f;}
		virtual void SetDimScale() {}
		virtual TCHAR *DimensionName() {return _T("");}		
	};

// These point to default implementations for the standard DIM types.
CoreExport extern ParamDimension *defaultDim;
CoreExport extern ParamDimension *stdWorldDim;
CoreExport extern ParamDimension *stdAngleDim;
CoreExport extern ParamDimension *stdColorDim;
CoreExport extern ParamDimension *stdColor255Dim;
CoreExport extern ParamDimension *stdPercentDim;
CoreExport extern ParamDimension *stdNormalizedDim;
CoreExport extern ParamDimension *stdSegmentsDim;
CoreExport extern ParamDimension *stdTimeDim;

// Interface IDs for GetInterface() - NOTE: doesn't need to be released.
#define I_CONTROL			0x00001001		
#define I_MASTER			0x00001010
#define I_EASELIST			0x00001020
#define I_MULTLIST			0x00001030
#define I_BASEOBJECT		0x00001040
#define I_PARTICLEOBJ		0x00001050
#define I_KEYCONTROL		0x00001060
#define I_TEXTOBJECT		0x00001070
#define I_WAVESOUND			0x00001080
#ifdef _SUBMTLASSIGNMENT
	#define I_SUBMTLAPI			0x00001090
#endif
#define I_MESHSELECT		0x000010A0
#define I_MESHSELECTDATA	0x000010B0
#define I_MAXSCRIPTPLUGIN	0x000010C0
#define I_MESHDELTAUSER		0x000010D0
#define I_MESHDELTAUSERDATA	0x000010E0
#define I_SPLINESELECT		0x000010F0  // JBW: add interface to spline selection & ops (for SplineShape & EditSplineMod)
#define I_SPLINESELECTDATA	0x00001100
#define I_SPLINEOPS			0x00001110
#define I_PATCHSELECT		0x00001120  
#define I_PATCHSELECTDATA	0x00001130
#define I_PATCHOPS			0x00001140

#define I_COMPONENT			0x0000F010
#define I_REFARRAY			0x0000F030
#ifdef DESIGN_VER
//VIZ specific range begins here 0x0000F000
#define I_LINK_TARGET		0x0000F020
#define I_LAYER				0x0000F040
#define I_LAYER_MANAGER		0x0000F050
#endif
#define I_REAGENT			0x0000F060
#define I_GEOMIMP			0x0000F070 //JH 3/7/99 implementaion neutral interface to geometry caches
#define I_AGGREGATION		0x0000F080
#define I_VALENCE			0x0000F090
#define I_GUEST				0x0000F100
#define I_HOST				0x0000F110
#define I_SCENEOBJECT		0x0000F120
// Plug-in defined interfaces should be > this id
#define I_USERINTERFACE		0x0000ffff

#define GetControlInterface(anim)	((Control*)anim->GetInterface(I_CONTROL))
#define GetObjectInterface(anim)	((BaseObject*)anim->GetInterface(I_BASEOBJECT))
#define GetParticleInterface(anim) 	((ParticleObject*)anim->GetInterface(I_PARTICLEOBJ))
#define GetKeyControlInterface(anim) ((IKeyControl*)anim->GetInterface(I_KEYCONTROL))
#define GetMasterController(anim) ((ReferenceTarget*)anim->GetInterface(I_MASTER))
#define GetTextObjectInterface(anim) ((ITextObject*)anim->GetInterface(I_TEXTOBJECT))
#define GetWaveSoundInterface(anim) ((IWaveSound*)anim->GetInterface(I_WAVESOUND))
#define GetMeshSelectInterface(anim) ((IMeshSelect*)anim->GetInterface(I_MESHSELECT))
#define GetMeshSelectDataInterface(anim) ((IMeshSelectData*)anim->GetInterface(I_MESHSELECTDATA))
#define GetMeshDeltaUserInterface(anim) ((MeshDeltaUser*)anim->GetInterface(I_MESHDELTAUSER))
#define GetMeshDeltaUserDataInterface(anim) ((MeshDeltaUserData*)anim->GetInterface(I_MESHDELTAUSERDATA))

// This is the base class for classes that can be hung off an animatable's
// property list. When an animatable is deleted, it's properties will be
// deleted and their virtual destructor will be called.
class AnimProperty {
	public:
		virtual BOOL DontDelete() {return FALSE;}
		virtual ~AnimProperty() {}
		virtual DWORD ID()=0;
	};

class AnimPropertyList : public Tab<AnimProperty*> {
	public:
		CoreExport int FindProperty(DWORD id,int start=0);
	};


// Property IDs
#define PROPID_APPDATA		0x00000010
#define PROPID_EASELIST		0x00000020
#define PROPID_MULTLIST		0x00000030
#define PROPID_NOTETRACK	0x00000040
#define PROPID_CLEARCACHES	0x00000050
#define PROPID_HAS_WSM		0x00000060
#define PROPID_PSTAMP_SMALL 0x00000070
#define PROPID_PSTAMP_LARGE 0x00000071
#define PROPID_SVDATA			0x00000080
#define PROPID_FORCE_RENDER_MESH_COPY 0x000000100
#define PROPID_EVAL_STEPSIZE_BUG_FIXED 0x1000
#define PROPID_USER			0x0000FFFF	
// Values above PROPID_USER can be used by plug-ins. 
// Note: that a plug-in should only put user defined properties on it's
// own list. So IDs only have to be unique within a plug-in. If a plug-in
// needs to attach data to another object, it can do so via APP_DATA.

// BeginEditParams flags values
#define BEGIN_EDIT_CREATE  		(1<<0)
#define BEGIN_EDIT_MOTION		(1<<1)	// Controller is being edited in the motion branch
#define BEGIN_EDIT_HIERARCHY	(1<<2)	// Same as BEGIN_EDIT_IK
#define BEGIN_EDIT_IK			(1<<2)  // Controller is being edited in the IK subtask of the hierarchy branch
#define BEGIN_EDIT_LINKINFO		(1<<3)  // Controller is being edited in the Link Info  subtask of the hierarchy branch

// EndEditParams flags values
#define END_EDIT_REMOVEUI  (1<<0)

// Flags passed to EnumAuxFiles
#define FILE_ENUM_INACTIVE 		(1<<0) 			// enumerate inactive files
#define FILE_ENUM_VP			(1<<1)   	  	// enumerate video post files
#define FILE_ENUM_RENDER		(1<<2)   	  	// enumerate render files 
#define FILE_ENUM_ALL  (FILE_ENUM_INACTIVE|FILE_ENUM_VP|FILE_ENUM_RENDER)	// enumerate ALL files
#define FILE_ENUM_MISSING_ONLY	(1<<8)  	  	// enumerate missing files only
#define FILE_ENUM_1STSUB_MISSING (1<<9) 	    // just enumerate 1st file named by ifl if missing
#define FILE_ENUM_DONT_RECURSE   (1<<10) 	    // don't enumerate references
#define FILE_ENUM_CHECK_AWORK1   (1<<11) 	    // don't enumerate things with flag A_WORK1 set

// To enumerate all active but missing files
#define FILE_ENUM_MISSING_ACTIVE (FILE_ENUM_VP|FILE_ENUM_RENDER|FILE_ENUM_MISSING_ONLY)

// To enumerate all active but missing files, but only enumerate first subfile pointed
// to by an ifl (enumerating all of them can be very slow).
#define FILE_ENUM_MISSING_ACTIVE1 (FILE_ENUM_MISSING_ACTIVE|FILE_ENUM_1STSUB_MISSING )

// A callback object passed to EnumAuxFiles().
class NameEnumCallback {
	public:
		virtual void RecordName(TCHAR *name)=0;
	};

class NoteTrack;

class Animatable {
		friend class ISaveImp;
		friend class ILoadImp;

	protected:
		unsigned long aflag;
		AnimPropertyList aprops;
		DWORD tvflags1, tvflags2;

	public:	
		void SetAFlag(int mask) { aflag|=mask; }
		void ClearAFlag(int mask) { aflag &= ~mask; }
		int TestAFlag(int mask) { return(aflag&mask?1:0); }
		CoreExport Animatable();
		Animatable& operator=(const Animatable& an)  { aflag = an.aflag; return *this; }		
		virtual void GetClassName(TSTR& s) { s= TSTR(_T("Animatable")); }  
		CoreExport virtual Class_ID ClassID();
		CoreExport virtual SClass_ID SuperClassID();		
		CoreExport virtual ~Animatable();

		// This is how things are actually deleted. 
		// Since they are created with the ClassDesc::Create()  function, and 
		// deleted via this function, they can use a different memory allocator
		// than the core code. (theoretically)
		CoreExport virtual void DeleteThis();
		
		// Get rid of anything that can be rebuilt 
		// Objects have a default implementation.
		virtual void FreeCaches() {}

		// 'create' is TRUE if parameters are being edited in the create branch.
		// 'removeUI' is TRUE if the object's UI should be removed.
		virtual void BeginEditParams(IObjParam *ip,ULONG flags,Animatable *prev=NULL) {} 
		virtual void EndEditParams(IObjParam *ip,ULONG flags,Animatable *next=NULL) {} 

		// OLE-like method for adding new interfaces
		virtual void* GetInterface(ULONG id){ return NULL;}
		virtual void ReleaseInterface(ULONG id,void *i) {}

		// General method for adding properties, when
		// defining a new Interface would be too cumbersome
		virtual int SetProperty(ULONG id, void *data) { return 0; }
		virtual void *GetProperty(ULONG id) { return NULL; }

		virtual	int NumSubs()  { return 0; }     // How many sub-animatables are there?
		virtual	Animatable* SubAnim(int i) { return NULL; }  // access the ith sub-animatable
		CoreExport virtual TSTR SubAnimName(int i);  // get name of ith subanim
		virtual BOOL BypassTreeView() { return FALSE; } // return TRUE and you won't appear in the TreeView however your children will.
		virtual BOOL BypassTrackBar() { return BypassTreeView(); } // return TRUE and you won't appear in the TrackBar however your children will.
		virtual BOOL BypassPropertyLevel() { return FALSE; } // return TRUE and you won't appear as a property in the scripter however your children will.
		virtual BOOL InvisibleProperty() { return FALSE; } // return TRUE and you won't appear as a property in the scripter.
		virtual BOOL AssignController(Animatable *control,int subAnim) {return FALSE;}

		// Used to allow deletion of controllers from the track view
		virtual BOOL CanDeleteSubAnim(int i) {return FALSE;}
		virtual void DeleteSubAnim(int i) {}
		
		// Return the suggested color to draw a sub-anim's function curve
		// can be one of PAINTCURVE_GENCOLOR, PAINTCURVE_XCOLOR, PAINTCURVE_YCOLOR, PAINTCURVE_ZCOLOR
		virtual DWORD GetSubAnimCurveColor(int subNum) {return PAINTCURVE_GENCOLOR;}

		// Converts an anim index to a ref index or returns -1 if there is no
		// corrispondance. This is used for copying and pasting in the track
		// view. If a client does not wish an anim to be copy/pastable then
		// it can return -1 even if there is a corrisponding ref num.
		virtual int SubNumToRefNum(int subNum) {return -1;}

		// In addition to SubNumToRefNum(), if an anim doesn't want to be coppied it can return FALSE from this function
		virtual BOOL CanCopyAnim() {return TRUE;}

		// An anim can implement this to reutrn FALSE to prohibit make unique
		virtual BOOL CanMakeUnique() {return TRUE;}

		virtual	int NumChildren() {return 0; }   // Non-zero only for nodes.
		virtual Animatable* ChildAnim(int i) { return NULL; } // access the ith child
		CoreExport virtual TSTR NodeName(); 	   // For nodes only

		CoreExport int EnumAnimTree(AnimEnum *animEnum, Animatable *client, int subNum);
		CoreExport int HasSubElements(int type=0); 		

		// called once at the beginning of each render
		virtual int RenderBegin(TimeValue t, ULONG flags=0) { return 0; }
		// called once at the end of each render
		virtual int RenderEnd(TimeValue t) { return 0; }

		// edit the track or parameters
		virtual void EditTrack() { assert(0); } 
		
		// Get the number of keys and the time of the ith key.
		virtual int NumKeys() {return NOT_KEYFRAMEABLE;}
		virtual TimeValue GetKeyTime(int index) {return 0;}
		virtual int GetKeyIndex(TimeValue t) {return -1;}
		virtual BOOL GetNextKeyTime(TimeValue t,DWORD flags,TimeValue &nt) {return FALSE;}
		virtual void CopyKeysFromTime(TimeValue src,TimeValue dst,DWORD flags) {} 
		virtual void DeleteKeyAtTime(TimeValue t) {}
		virtual BOOL IsKeyAtTime(TimeValue t,DWORD flags) {return FALSE;}
		
		// The value returned from these two methods should be the number of keys skipped because their times were before
		// range.Start(). So sel[i] is the selection state for the offset+ith key.
		virtual int GetKeyTimes(Tab<TimeValue> &times,Interval range,DWORD flags) {return 0;}		
		virtual int GetKeySelState(BitArray &sel,Interval range,DWORD flags) {return 0;}

		// TreeView Methods
		/////////////////////////////////////////////////////////////
		// the 'tv' parameter specifies which track view.
		// each track view uses one bit, there can be up to MAX_TRACK_VIEWS
		CoreExport void OpenTreeEntry(int type, DWORD tv);
		CoreExport void CloseTreeEntry(int type, DWORD tv);
		CoreExport int IsTreeEntryOpen(int type, DWORD tv);
		
		// Track view selected state
		CoreExport BOOL GetSelInTrackView(DWORD tv);
		CoreExport void SetSelInTrackView(DWORD tv, BOOL sel);

		// Track view selection sets: 'which' should be >=0 and <MAX_TRACKVIEW_SELSETS
		CoreExport BOOL InTrackViewSelSet(int which);
		CoreExport void SetTrackViewSelSet(int which, BOOL inOut);

		// The tracks time range:
		CoreExport virtual Interval GetTimeRange(DWORD flags);
		virtual void EditTimeRange(Interval range,DWORD flags) {};
		
		// Operations to a selected block of time		
		virtual void DeleteTime(Interval iv, DWORD flags) {}
		virtual void ReverseTime(Interval iv, DWORD flags) {}
		virtual void ScaleTime(Interval iv, float s) {}
		virtual void InsertTime(TimeValue ins, TimeValue amount) {}
		
		// If an anim supports the above time operations it should return TRUE from this method.
		// Returning TRUE enables time selection on the track view for the track.
		virtual BOOL SupportTimeOperations() {return FALSE;}

		// Operations to keys
		CoreExport virtual void MapKeys(TimeMap *map, DWORD flags);
		virtual void DeleteKeys(DWORD flags) {}
		virtual void DeleteKeyByIndex(int index) {}
		virtual void SelectKeys(TrackHitTab& sel, DWORD flags) {}
		virtual void SelectSubKeys(int subNum,TrackHitTab& sel, DWORD flags) {} // this is called on the client when the client takes over control of an anims fcurve
		virtual void SelectSubCurve(int subNum,BOOL sel) {}
		virtual void SelectKeyByIndex(int i,BOOL sel) {}
		virtual BOOL IsKeySelected(int i) {return FALSE;}
		virtual void FlagKey(TrackHitRecord hit) {}
		virtual int GetFlagKeyIndex() {return -1;}
		virtual int NumSelKeys() {return 0;}
		virtual void CloneSelectedKeys(BOOL offset=FALSE) {}   // When offset is TRUE, set the new key time to be centered between the original key and the next key
		virtual void AddNewKey(TimeValue t,DWORD flags) {}
		virtual void MoveKeys(ParamDimensionBase *dim,float delta,DWORD flags) {}  // move selected keys vertically in the function curve editor
		virtual void ScaleKeyValues(ParamDimensionBase *dim,float origin,float scale,DWORD flags) {}
		virtual void SelectCurve(BOOL sel) {}
		virtual BOOL IsCurveSelected() {return FALSE;}		
		virtual BOOL IsSubCurveSelected(int subNum) {return FALSE;}
		virtual int GetSelKeyCoords(TimeValue &t, float &val,DWORD flags) {return KEYS_NONESELECTED;}
		virtual void SetSelKeyCoords(TimeValue t, float val,DWORD flags) {}
		virtual int SetSelKeyCoordsExpr(ParamDimension *dim,TCHAR *timeExpr, TCHAR *valExpr, DWORD flags) {return KEYCOORDS_EXPR_UNSUPPORTED;}
		virtual void AdjustTangents(
			TrackHitRecord hit,
			ParamDimensionBase *dim,
			Rect& rcGraph,
			float tzoom,
			int tscroll,
			float vzoom,
			int vscroll,
			int dx,int dy,
			DWORD flags) {};

		// Does this animatable actually have animation?
		// Default implementation returns TRUE if a child anim has animation.
		CoreExport virtual BOOL IsAnimated(); 

		// Clipboard methods:
		virtual BOOL CanCopyTrack(Interval iv, DWORD flags) {return FALSE;}
		virtual BOOL CanPasteTrack(TrackClipObject *cobj,Interval iv, DWORD flags) {return FALSE;}
		virtual TrackClipObject *CopyTrack(Interval iv, DWORD flags) {return NULL;}
		virtual void PasteTrack(TrackClipObject *cobj,Interval iv, DWORD flags) {}

		// Plug-ins can implement copying and pasting for cases where their subanims
		// don't implement it. These aren't called on the client unless the sub-anim
		// doesn't implement the above versions.
		virtual BOOL CanCopySubTrack(int subNum,Interval iv, DWORD flags) {return FALSE;}
		virtual BOOL CanPasteSubTrack(int subNum,TrackClipObject *cobj,Interval iv, DWORD flags) {return FALSE;}
		virtual TrackClipObject *CopySubTrack(int subNum,Interval iv, DWORD flags) {return NULL;}
		virtual void PasteSubTrack(int subNum,TrackClipObject *cobj,Interval iv, DWORD flags) {}


		// Drawing and hit testing tracks
		virtual int GetTrackVSpace( int lineHeight ) { return 1; }
		virtual int HitTestTrack(			
			TrackHitTab& hits,
			Rect& rcHit,
			Rect& rcTrack,			
			float zoom,
			int scroll,
			DWORD flags ) { return TRACK_DORANGE; }
		virtual int PaintTrack(			
			ParamDimensionBase *dim,
			HDC hdc,
			Rect& rcTrack,
			Rect& rcPaint,
			float zoom,
			int scroll,
			DWORD flags ) { return TRACK_DORANGE; }
		virtual int PaintSubTrack(			
			int subNum,
			ParamDimensionBase *dim,
			HDC hdc,
			Rect& rcTrack,
			Rect& rcPaint,
			float zoom,
			int scroll,
			DWORD flags) {return TRACK_DORANGE;}

		// Drawing and hit testing function curves
		virtual int PaintFCurves(			
			ParamDimensionBase *dim,
			HDC hdc,
			Rect& rcGraph,
			Rect& rcPaint,
			float tzoom,
			int tscroll,
			float vzoom,
			int vscroll,
			DWORD flags ) { return 0; }
		virtual int HitTestFCurves(			
			ParamDimensionBase *dim,
			TrackHitTab& hits,
			Rect& rcHit,
			Rect& rcGraph,			
			float tzoom,
			int tscroll,
			float vzoom,
			int vscroll,
			DWORD flags ) { return HITCURVE_NONE; }
		
		// Versions that allow clients to paint and hit test their subanims curves
		virtual int PaintSubFCurves(			
			int subNum,
			ParamDimensionBase *dim,
			HDC hdc,
			Rect& rcGraph,
			Rect& rcPaint,
			float tzoom,
			int tscroll,
			float vzoom,
			int vscroll,
			DWORD flags ) { return 0; }
		virtual int HitTestSubFCurves(
			int subNum,
			ParamDimensionBase *dim,
			TrackHitTab& hits,
			Rect& rcHit,
			Rect& rcGraph,			
			float tzoom,
			int tscroll,
			float vzoom,
			int vscroll,
			DWORD flags ) { return HITCURVE_NONE; }


		// Edit key info (or whatever) for selected keys.
		// hParent is the parent window that should be used to create any dialogs.
		// This function should not return until the user has completed editng at which
		// time any windows that were created should be destroyed. Unlike
		// BeginEditParams/EndEditParams this interface is modal.		
		virtual void EditTrackParams(
			TimeValue t,	// The horizontal position of where the user right clicked.
			ParamDimensionBase *dim,
			TCHAR *pname, // The name of the parameter as given by the client
			HWND hParent,
			IObjParam *ip,
			DWORD flags) {}

		// Returns a value indicating how track parameters are
		// are invoked. See description above by
		// TRACKPARAMS_NONE, TRACKPARAMS_KEY, TRACKPARAMS_WHOLE
		virtual int TrackParamsType() {return TRACKPARAMS_NONE;}

		// Calculate the largest and smallest values.
		// If this is processed, return non-zero.
		virtual int GetFCurveExtents(
			ParamDimensionBase *dim,
			float &min, float &max, DWORD flags) {return 0;}
		virtual int GetSubFCurveExtents(
			int subNum,
			ParamDimensionBase *dim,
			float &min, float &max, DWORD flags) {return 0;}

		// Describes the type of dimension of the ith sub-anim
		virtual ParamDimension* GetParamDimension(int i) {return defaultDim;}

		// This is not used anymore.
		virtual LRESULT CALLBACK TrackViewWinProc( HWND hwnd,  UINT message, 
		                                           WPARAM wParam, LPARAM lParam ) { return 0;}


		// Called when the user clicks on the icon of a subAnim in the track view.
		virtual BOOL SelectSubAnim(int subNum) {return FALSE;}

		// Add/delete note tracks
		CoreExport void AddNoteTrack(NoteTrack *note);
		CoreExport void DeleteNoteTrack(NoteTrack *note,BOOL delNote=TRUE); // If delNote is FALSE the note track will be removed from the anim but not deleted.
		CoreExport BOOL HasNoteTracks();
		CoreExport int NumNoteTracks();
		CoreExport NoteTrack *GetNoteTrack(int i);

		// Enumerate auxiliary files -- see ref.h for default implementation
		virtual void EnumAuxFiles(NameEnumCallback& nameEnum, DWORD flags = FILE_ENUM_ALL) {}

		// Free all bitmaps in the Animatable: don't recurse
		virtual void FreeAllBitmaps() {}

		// A master controller should implement this method to give the 
		// MAX a list of nodes that are part of the system. 
		virtual void GetSystemNodes(INodeTab &nodes) {}

		// If an object is a sub-class of a particular class, it will have a
		// different ClassID() because it is a different class. This method
		// allows an object to indicate that it is a sub-class of a particluar
		// class and therefore can be treated as one.
		// For example, a class could be derived from TriObject. This derived
		// class would have a different ClassID() then TriObject's class ID
		// however it still can be treated (cast) as a TriObject because it
		// is derived from TriObject.
		// Note the default implelementation: a class is considered to also
		// be a subclass of itself.
		virtual BOOL IsSubClassOf(Class_ID classID) {return classID==ClassID();}

		// Access app data chunks
		CoreExport void AddAppDataChunk(Class_ID cid, SClass_ID sid, DWORD sbid, DWORD len, void *d);
		CoreExport AppDataChunk *GetAppDataChunk(Class_ID cid, SClass_ID sid, DWORD sbid);
		CoreExport BOOL RemoveAppDataChunk(Class_ID cid, SClass_ID sid, DWORD sbid);		
		CoreExport void ClearAllAppData();
		
		CoreExport virtual void MouseCycleCompleted(TimeValue t);
		CoreExport virtual void MouseCycleStarted(TimeValue t);

		// JBW: direct ParamBlock2 access added
		virtual int	NumParamBlocks() { return 0; }			// return number of ParamBlocks in this instance
		virtual IParamBlock2* GetParamBlock(int i) { return NULL; } // return i'th ParamBlock
		virtual IParamBlock2* GetParamBlockByID(short id) { return NULL; } // return ParamBlock given ID


		// Save and load functions for schematic view data.
		// For classes derived from ReferenceMaker, there is
		// no need to call these.  However, IF you have stuff
		// derived from Animatable AND it appears in the
		// schematic view AND you want to save schematic view
		// properties for the object (node position, selection
		// state, etc.) THEN you have to call these guys in
		// your Save and Load functions... 
		CoreExport bool SvSaveData(ISave *isave, USHORT id);
		CoreExport bool SvLoadData(ILoad *iLoad);

		// Used internally by the schematic view.  There should
		// be no reason for plug-ins to ever call these...
		CoreExport DWORD SvGetRefIndex();
		CoreExport void SvSetRefIndex(DWORD i);
		CoreExport bool SvDeleteRefIndex();

		// Traverses the graph of objects in the MAX scene,
		// adding desired objects to the schematic view.
		// Developers can specialize this behaviour by overriding
		// this method and adding whatever objects are interesting
		// to the schematic view...
		// Objects are added to the schematic view by calling
		// IGraphObjectManager::AddAnimatable(...)
		// Reference lines are added to the schematic view by
		// calling IGraphObjectManager::AddReference(...)
		// Implementers of SvTraverseAnimGraph(...) should
		// call SvTraverseAnimGraph(...) recursively to
		// process other objects in the scene.
		CoreExport virtual SvGraphNodeReference SvTraverseAnimGraph(IGraphObjectManager *gom, Animatable *owner, int id, DWORD flags);

		// A default graph traversal function which can be
		// called from SvTraverseAnimGraph(...) to handle
		// graph traversal in simple cases.  Follows sub-anim
		// and child references...
		CoreExport SvGraphNodeReference SvStdTraverseAnimGraph(IGraphObjectManager *gom, Animatable *owner, int id, DWORD flags);

		// Animatable returns true if it can be the initiator of
		// a link operation in the schematic view...
		CoreExport virtual bool SvCanInitiateLink(IGraphObjectManager *gom, IGraphNode *gNode);

		// Animatable returns true if it can be the receiver
		// (parent) of a link operation in the schematic view...
		CoreExport virtual bool SvCanConcludeLink(IGraphObjectManager *gom, IGraphNode *gNode, IGraphNode *gNodeChild);

		// Returns the name of the object as it appears in the
		// schematic view...
		CoreExport virtual TSTR SvGetName(IGraphObjectManager *gom, IGraphNode *gNode, bool isBeingEdited);

		// Return true to permit the object's name to be
		// edited in the schematic view...
		CoreExport virtual bool SvCanSetName(IGraphObjectManager *gom, IGraphNode *gNode);

		// Called when the user changes the name of the object
		// in the schematic view...
		CoreExport virtual bool SvSetName(IGraphObjectManager *gom, IGraphNode *gNode, TSTR &name);

		// Return true if this object can be removed in the schematic view...
		CoreExport virtual bool SvCanRemoveThis(IGraphObjectManager *gom, IGraphNode *gNode);

		// Called when the user deletes this object in the schematic view...
		CoreExport virtual bool SvRemoveThis(IGraphObjectManager *gom, IGraphNode *gNode);

		// Returns true if the object is selected in its primary
		// editor...
		CoreExport virtual bool SvIsSelected(IGraphObjectManager *gom, IGraphNode *gNode);

		// Returns true if the object is to be highlighted in
		// the schematic view...
		CoreExport virtual bool SvIsHighlighted(IGraphObjectManager *gom, IGraphNode *gNode);

		// Returns the highlight color for this node.  The
		// highlight color is used to outline nodes in the
		// schematic view when SvIsHighlighted(...) returns
		// true...
		CoreExport virtual COLORREF SvHighlightColor(IGraphObjectManager *gom, IGraphNode *gNode);

		// Returns a color which is used to paint the triangular
		// color swatch that appears in the upper-right hand
		// corner of the node in the schematic view.  Can
		// return SV_NO_SWATCH to indicate that no swatch is
		// to be drawn...
		CoreExport virtual COLORREF SvGetSwatchColor(IGraphObjectManager *gom, IGraphNode *gNode);

		// Returns true if this object is inactive.  The schematic
		// view draws inactive nodes in a grayed-out state.
		CoreExport virtual bool SvIsInactive(IGraphObjectManager *gom, IGraphNode *gNode);

		// Links gNodeChild to this object...
		CoreExport virtual bool SvLinkChild(IGraphObjectManager *gom, IGraphNode *gNodeThis, IGraphNode *gNodeChild);

		// Called when this node is double-clicked in the
		// schematic view...
		CoreExport virtual bool SvHandleDoubleClick(IGraphObjectManager *gom, IGraphNode *gNode);

		// Called before a multiple select/deselect operation
		// in the schematic view.  Returns a callback used
		// to perform the (de)selection.  May return NULL if
		// this object cannot be selected in some principle
		// editor outside the schematic view...		
		CoreExport virtual MultiSelectCallback* SvGetMultiSelectCallback(IGraphObjectManager *gom, IGraphNode *gNode);		

		// Returns true if this object can be selected in
		// some editor (viewport, material editor, plug-in
		// specific editor, etc.).  Selection is actually
		// accomplished by via the SvGetMultiSelectCallback(...)
		// mechanism described above...
		CoreExport virtual bool SvCanSelect(IGraphObjectManager *gom, IGraphNode *gNode);

		// Called when the user edits the properties of a
		// node from the schematic view...
		CoreExport virtual bool SvEditProperties(IGraphObjectManager *gom, IGraphNode *gNode);

		// Returns a string to be displayed in the tip window
		// for this object in the schematic view...
		CoreExport virtual TSTR SvGetTip(IGraphObjectManager *gom, IGraphNode *gNode);

		// Returns a string to be displayed in the tip window
		// in the schematic view for a reference from "gNodeMaker"
		// to this...
		CoreExport virtual TSTR SvGetRefTip(IGraphObjectManager *gom, IGraphNode *gNode, IGraphNode *gNodeMaker);

		// Returns true is this object can respond to the SvDetach(...) method...
		CoreExport virtual bool SvCanDetach(IGraphObjectManager *gom, IGraphNode *gNode);

		// Detach this object from its owner...
		CoreExport virtual bool SvDetach(IGraphObjectManager *gom, IGraphNode *gNode);

	};





//
// Callback for EnumAnimTree:
//
// Scope values:

#define SCOPE_DOCLOSED 1   		// do "closed" animatables.
#define SCOPE_SUBANIM  2		// do the sub anims 
#define SCOPE_CHILDREN 4 		// do the node children
#define SCOPE_OPEN	(SCOPE_SUBANIM|SCOPE_CHILDREN) // do all open animatables
#define SCOPE_ALL	(SCOPE_OPEN|SCOPE_DOCLOSED)     // do all animatables

// Return values for AnimEnum procs
#define ANIM_ENUM_PROCEED 1
#define ANIM_ENUM_STOP 2
#define ANIM_ENUM_ABORT 3

class AnimEnum {
	protected:
		int depth;
		int scope;  
		DWORD tv;
	public:
	 	AnimEnum(int s = SCOPE_OPEN, int deep = 0, DWORD tv=0xffffffff) 
			{scope = s; depth = deep; this->tv = tv;}
		void SetScope(int s) { scope = s; }
		int Scope() { return scope; }
		void IncDepth() { depth++; }
		void DecDepth() { depth--; }
		int Depth() { return depth; }
		DWORD TVBits() {return tv;}
		virtual int proc(Animatable *anim, Animatable *client, int subNum)=0;
	};

// A usefule enumeration
class ClearAnimFlagEnumProc : public AnimEnum {
		DWORD flag;
	public:
		ClearAnimFlagEnumProc(DWORD f) {flag=f;}
		int proc(Animatable *anim, Animatable *client, int subNum) {
			anim->ClearAFlag(flag);
			return ANIM_ENUM_PROCEED;
			}
	};


//
// The is used by the two functions GetSubObjectCenters() and
// GetSubObjectTMs() found in the classes BaseObject and Control.
//
class SubObjAxisCallback {
	public:
		virtual void Center(Point3 c,int id)=0;
		virtual void TM(Matrix3 tm,int id)=0;
		virtual int Type()=0;
	};

// Values returned by Type();
#define SO_CENTER_SELECTION	1 
#define SO_CENTER_PIVOT		2


// --- AppData ---------------------------------------------

// An individual app data chunk
class AppDataChunk {
	public:
		// Note that data pointer should be allocated with standard malloc
		// since it will be freed in the destructor.
		AppDataChunk(Class_ID cid, SClass_ID sid, DWORD sbid, DWORD len, void *d)
			{classID=cid; superClassID=sid; subID=sbid; length=len; data=d;}
		AppDataChunk() {length=0;data=NULL;}

		~AppDataChunk() {
			if (data) free(data);
			}		

		// The super class and class IDs of the object that
		// is the owner of this chunk.
		Class_ID  classID;
		SClass_ID superClassID;

		// An extra ID that lets the owner identify its sub chunks.
		DWORD subID;
		
		// The chunk data itself
		DWORD length;
		void *data;

		// IO
		CoreExport IOResult Load(ILoad *iload);
		CoreExport IOResult Save(ISave *isave);
	};


// This list is maintained by the systems. Plug-ins need not concern themselves with it.
class AnimAppData : public AnimProperty {
	public:				
		Tab<AppDataChunk*> chunks;
		CRITICAL_SECTION csect;
		AppDataChunk *lastSearch;

		DWORD ID() {return PROPID_APPDATA;}		
		CoreExport ~AnimAppData();
		CoreExport AnimAppData();

		CoreExport AppDataChunk *FindChunk(Class_ID cid, SClass_ID sid, DWORD sbid);
		void AddChunk(AppDataChunk *newChunk) {chunks.Append(1,&newChunk);}
		CoreExport BOOL RemoveChunk(Class_ID cid, SClass_ID sid, DWORD sbid);

		CoreExport IOResult Load(ILoad *iload);
		CoreExport IOResult Save(ISave *isave);
	};

static const DWORD SV_NO_REF_INDEX = 0xFFFFFFFF;
class SchematicViewProperty : public AnimProperty
	{
	private:
	DWORD nodeRefIndex;

	public:				
	DWORD ID() { return PROPID_SVDATA; }
	CoreExport ~SchematicViewProperty() {}
	CoreExport SchematicViewProperty();

	DWORD GetRefIndex();
	void SetRefIndex(DWORD refIndex);
	bool GetRefSaveMark();

	CoreExport IOResult Load(ILoad *iload);
	CoreExport IOResult Save(ISave *isave);
	};
 
CoreExport void SetLockFailureLevel(int level);
CoreExport int GetLockFailureLevel();

class Interface;
CoreExport Interface *GetCOREInterface();
				
// JBW: macrorecorder.  For the macro-recorder to establish itself with CORE
class MacroRecorder;
CoreExport void SetMacroRecorderInterface(MacroRecorder* mri);
// JBW: to set the CIU macro scrit directory ref in CORE
class MacroDir;
CoreExport void SetMacroScriptInterface(MacroDir* msd);
						
// This API allows plug-in to query various system settings.
CoreExport int GetSystemSetting(int id);

// Values to pass to GetSystemSetting():

// Are editable meshes enabled?
#define SYSSET_ENABLE_EDITABLEMESH		1

// When GetSystemSetting is called with this the undo buffer is
// cleared. GetSystemSetting will return 0.
// Note that this will only work with version 1.1 of MAX or later.
#define SYSSET_CLEAR_UNDO				2


// Are keyboard accelerators enabled for the editable mesh.
#define SYSSET_EDITABLEMESH_ENABLE_KEYBOARD_ACCEL	3

// Is the edit meh modifier enabled?
#define SYSSET_ENABLE_EDITMESHMOD	4


// Returns the state of the VERSION_3DSMAX #define from PLUGAPI.H
// when the running version of MAX was compiled.
CoreExport DWORD Get3DSMAXVersion();


// Special access to the MAX INI file for motion capture
#define MCAP_INI_CHANNEL	1
#define MCAP_INI_PRESET		2
#define MCAP_INI_STOP		3
#define MCAP_INI_PLAY		4
#define MCAP_INI_RECORD		5
#define MCAP_INI_SSENABLE	6

CoreExport int GetMotionCaptureINISetting(int ID);
CoreExport void SetMotionCaptureINISetting(int ID, int val);

// CoreExecute: generic expansion capability
CoreExport int CoreExecute(int cmd, ULONG arg1=0, ULONG arg2=0, ULONG arg3=0);

#endif // _ANIMTBL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\arcdlg.h ===
/**********************************************************************
 *<
	FILE: arcdlg.h

	DESCRIPTION:

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __ARCDLG__H
#define __ARCDLG__H


class ArcballDialog {
	public:
	virtual void DeleteThis()=0;  
	};

class ArcballCallback {
	public:
	virtual void StartDrag()=0;   // called when drag begins (may want to save state at this point)
	virtual void EndDrag()=0;   // called when drag ends
	virtual void Drag(Quat q, BOOL buttonUp)=0;  // called during drag, with q=relative rotation from start
	virtual void CancelDrag()=0;  // called when right button clicked during drag
	virtual	void BeingDestroyed()=0;  // called if the window was closed
	};

CoreExport ArcballDialog *CreateArcballDialog(ArcballCallback *cb, HWND hwndOwner, TCHAR* title=NULL);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\appio.h ===
/**********************************************************************
 *<
	FILE: appio.h

	DESCRIPTION:  General chunk-ifying code: useful for writing 
	   hierarchical data structures to a linear stream, such as
	   an AppData block.

	CREATED BY: Dan Silva

	HISTORY: created 3/24/97

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __APPIO__H
#define __APPIO__H

//------------------------------------------------------------------------
// AppSave will write hierarchical chunks into a private buffer, enlarging 
//  it as needed.  When completed, use the methods BufferPtr() and 
// NBytesWritten() to get at this buffer. ( AppSave will delete the buffer in 
// its DeleteThis() method , so you need to copy the buffer to save the data.)

// The chunk hierarchy should always have a single highest level chunk.
// Chunks can be nested to any depth.
// A Chunk can contain either sub-chunks, or data, but not both.

//   For example:
//
//	AppSave *asave = NewAppSave(1000);
//	asave->BeginChunk(MAIN_CHUNK);
//	   asave->BeginChunk(CHUNK1);
//      .. write data 
//	   asave->EndChunk();
//
//	   asave->BeginChunk(CHUNK2);
//      .. write data 
//	   asave->EndChunk();
//
//	   asave->BeginChunk(CHUNK3);
//      .. write data 
//	   asave->EndChunk();
//	asave->EndChunk();  // end MAIN_CHUNK


class AppSave {
	protected:
		~AppSave() {}
	public:
		virtual void DeleteThis()=0;
		
		// After saving, use this to get pointer to the buffer created.
		virtual BYTE *BufferPtr()=0;

		// This tells how many bytes were written in the buffer.
		virtual int NBytesWritten()=0;
		
		// Begin a chunk.
		virtual void BeginChunk(USHORT id)=0;

		// End a chunk, and back-patch the length.
		virtual void EndChunk()=0;

		virtual int CurChunkDepth()=0;  // for checking balanced BeginChunk/EndChunk

		// write a block of bytes to the output stream.
		virtual IOResult Write(const void  *buf, ULONG nbytes, ULONG *nwrit)=0;

		// Write character strings
		virtual IOResult WriteWString(const char *str)=0;
		virtual IOResult WriteWString(const wchar_t *str)=0;
		virtual IOResult WriteCString(const char *str)=0;
		virtual IOResult WriteCString(const wchar_t *str)=0;

		};

//------------------------------------------------------------------------
// AppLoad takes a chunk-ified data stream, and provides routines for 
// decoding it. 

class AppLoad {
	protected:
		~AppLoad() {};
	public:
		virtual void DeleteThis()=0;
			
		// if OpenChunk returns IO_OK, use following 3 function to get the 
		// info about the chunk. IO_END indicates no more chunks at this level
		virtual IOResult OpenChunk()=0;

		// These give info about the most recently opened chunk
		virtual USHORT CurChunkID()=0;
		virtual ChunkType CurChunkType()=0;
		virtual	ULONG CurChunkLength()=0;  // chunk length NOT including header
		virtual	int CurChunkDepth()=0;  // for checking balanced OpenChunk/CloseChunk

		// close the currently opened chunk, and position at the next chunk
		//  return of IO_ERROR indicates there is no open chunk to close
		virtual IOResult CloseChunk()=0;

		// Look at the next chunk ID without opening it.
		// returns 0 if no more chunks
		virtual	USHORT PeekNextChunkID()=0;

		// Read a block of bytes from the output stream.
		virtual IOResult Read(void  *buf, ULONG nbytes, ULONG *nread )=0;

		// Read a string from a string chunk assumes chunk is already open, 
		// it will NOT close the chunk. Sets buf to point
		// to a char string.  Don't delete buf: ILoad will take care of it.

		//   Read a string that was stored as Wide chars. 
		virtual IOResult ReadWStringChunk(char** buf)=0;
		virtual IOResult ReadWStringChunk(wchar_t** buf)=0;

		//   Read a string that was stored as single byte chars
		virtual IOResult ReadCStringChunk(char** buf)=0;
		virtual IOResult ReadCStringChunk(wchar_t** buf)=0;


	};


// Create a new AppLoad for reading chunks out of buf:
// bufSize specifies the number of bytes that are valid in
// buf.. 
CoreExport AppLoad *NewAppLoad(BYTE *buf, int bufSize);

// Create a new AppSave for writing chunks
// InitbufSize is the initial size the internal buffer is allocated to.
// It will be enlarged if necessary.
CoreExport AppSave *NewAppSave(int initBufSize);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\assert1.h ===
/**********************************************************************
 *<
	FILE: assert1.h

	DESCRIPTION:

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifdef assert
#undef assert
#endif

#define assert( expr ) ( expr || assert1( /*#expr,*/ __LINE__, __FILE__ ) )

#define MaxAssert( expr ) ( (expr) || assert1( __LINE__, __FILE__ ) )

extern int UtilExport assert1( /*char *expr,*/ int line, char *file );

#ifdef _DEBUG
#define DbgAssert( expr ) ( (expr) || assert1( __LINE__, __FILE__ ) )
#define DbgVerify( expr ) ( (expr) || assert1( __LINE__, __FILE__ ) )
#else
#define DbgAssert( expr )
#define DbgVerify( expr ) ( expr )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\bmmlib.h ===
#ifndef _BMMLIB_H_
#define _BMMLIB_H_
#define  BMMExport __declspec( dllimport )
#include "bitmap.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\bitarray.h ===
/**********************************************************************
 *<
	FILE: bitarray.h

	DESCRIPTION:

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef BITARRAY__H
#define BITARRAY__H

#include <windef.h>
#include <ioapi.h>

class BitArrayCallback {
	public:
	virtual void proc(int n)=0;
	};

// Direction indicators for BitArray::Rotate and BitArray::Shift
#define LEFT_BITSHIFT 0
#define RIGHT_BITSHIFT 1

class BitArray {
	DWORD* bits;
	long numBits;
	public:
		DllExport void SetSize(int n, int save=0);  // save=1:preserve old bit values
		int	GetSize() const { return numBits; }
		DllExport void ClearAll();
		DllExport void SetAll();
	    DllExport void Set(int i);       	// set ith bit to 1
	    DllExport void Clear(int i);     	// set ith bit to 0 
		DllExport void Set(int i, int b);  // set ith bit to b
		DllExport int operator[](int i) const;  // get ith bit
		DllExport int NumberSet();      // how many bits are 1's.
		DllExport BOOL IsEmpty();      // are NO bits set?.  much faster than NumberSet
		DllExport void Compress();    
		DllExport void Expand();
		DllExport void Reverse(BOOL keepZero = FALSE);	// keepZero=TRUE keeps zero bit where it is
		DllExport void Rotate(int direction, int count);				// With wraparound
		DllExport void Shift(int direction, int count, int where=0);	// Without wraparound
		DllExport void EnumSet(BitArrayCallback &cb);  // enumerates elements that are 1's
		DllExport void DeleteSet (BitArray & dset, int mult=1);
		DllExport IOResult Save(ISave* isave);
		DllExport IOResult Load(ILoad* iload);

		BitArray() { bits = NULL; 	numBits = 0; }
		DllExport BitArray(int n);
		DllExport BitArray(const BitArray& b);
		DllExport ~BitArray();

		// Comparison operator
		DllExport BOOL operator==(const BitArray& b);
		
		// Assignment operators
		DllExport BitArray& operator=(const BitArray& b);

		// Assignment operators: These require arrays of the same size!
		DllExport BitArray& operator&=(const BitArray& b);  // AND=
		DllExport BitArray& operator|=(const BitArray& b);  // OR=
		DllExport BitArray& operator^=(const BitArray& b);  // XOR=

		// Binary operators: These require arrays of the same size!
		DllExport BitArray operator&(const BitArray&) const; // AND
		DllExport BitArray operator|(const BitArray&) const; // OR
		DllExport BitArray operator^(const BitArray&) const; // XOR

		// Unary operators
		DllExport BitArray operator~(); // unary NOT function

	};






#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\bitmap.h ===
//-----------------------------------------------------------------------------
// -------------------
// File ....: bitmap.h
// -------------------
// Author...: Tom Hudson
// Date ....: Sptember 1994
//
// History .: Sep, 01 1994 - Started serious coding
//            Oct, 18 1994 - First major revision for DLLs, restructuring
//            Jul, 10 1995 - Began working with it (Gus J Grubba)
//
//-----------------------------------------------------------------------------
      
#ifndef BITMAP_H_DEFINED
#define BITMAP_H_DEFINED

#define NOAVIFILE
#include <vfw.h>
#undef  NOAVIFILE

#include "palutil.h"
#include "linklist.h"
#include "gbuf.h"

//-- Defines that may change with compiler

#define INTBITS (sizeof(int) * 8)

//-- Class ID's for various DLL's

#define IMGCLASSID      1
#define CYCLECLASSID    2
#define FLICCLASSID     5
#define TARGACLASSID    6
#define YUVCLASSID      7
#define FBCLASSID       8
#define WSDCLASSID      9
#define IFLCLASSID      10
#define BMPCLASSID      11
#define JPEGCLASSID     12
#define TARGAPLSCLASSID 13
#define AVICLASSID      14
#define RLACLASSID      15

//-- local definitions

class BitmapManager;
class BitmapManagerImp;
class BitmapStorage;
class BitmapFilter;
class BitmapDither;
class BitmapInfo;
class BitmapPicker;
class BitmapIO;
class Bitmap;

//-- Temporary definitions to make the compiler happy

class GraphicsWindow;
class BMMInterface;
class DllDir;

//-- External data 

extern int  TheSystemFrame;         // TO DO: Move to App data structure?

//-----------------------------------------------------------------------------
//-- The Primary Bitmap Manager Object
//

extern BMMExport BitmapManager *TheManager; // TO DO: Move to App data structure?

//-- Common Macros ------------------------------------------------------------

//-- Just to make it shorter

#define bVirtual BMMExport virtual

//-- Set up a NULL macro

#ifndef NULL
#define NULL (0)
#endif

//-- Pixel storage classes ----------------------------------------------------
// These are in maxtypes.h now.
//typedef struct {
//   BYTE r,g,b;
//} BMM_Color_24;
//
//typedef struct {
//   BYTE r,g,b,a;
//} BMM_Color_32;
//
//typedef struct {
//   WORD r,g,b;
//} BMM_Color_48;
//
//typedef struct {
//   WORD r,g,b,a;
//} BMM_Color_64;

//-- Generic bitmap information structure -------------------------------------

typedef struct {
   int   width,height;
   float aspect,gamma;
   DWORD flags;
} BMMImageInfo;

//-- Basic bitmap types supported by Bitmap Manager

#define BMM_NO_TYPE              0       // Not allocated yet
#define BMM_LINE_ART             1
#define BMM_PALETTED             2
#define BMM_GRAY_8               3
#define BMM_GRAY_16              4       
#define BMM_TRUE_16              5
#define BMM_TRUE_32              6
#define BMM_TRUE_64              7

//-- Information Only

#define BMM_TRUE_24              8       
#define BMM_TRUE_48              9       
#define BMM_YUV_422              10
#define BMM_BMP_4                11      //-- Windows BMP 16 color bitmap
#define BMM_PAD_24               12      //-- Padded 24 bit (in a 32 bit register)

//-- Textual Limits

#define MAX_DESCRIPTION          256

//-- The number of bitmap formats supported internally

//#define BMM_FORMATS            6

//-- File types

//#define BMM_NOTYPE             0
//#define BMM_TARGA              1       // System Targa I/O driver
//#define BMM_GIF                2       // System GIF I.O driver

//-- Gamma limits

#define MINGAMMA                 0.2f
#define MAXGAMMA                 5.0f

//-- openMode values

#define BMM_NOT_OPEN             0       // Not opened yet
#define BMM_OPEN_R               1       // Read-only
#define BMM_OPEN_W               2       // Write

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//-- Error Codes for BMMRES type functions

typedef unsigned short BMMRES;              // Traps the use of int or BOOL

#define BMMRES_SUCCESS                0
#define BMMRES_ERRORTAKENCARE         1     // Error - Function has already taken action
#define BMMRES_FILENOTFOUND           2
#define BMMRES_MEMORYERROR            3
#define BMMRES_NODRIVER               4     // Device driver responsible for image not present
#define BMMRES_IOERROR                5
#define BMMRES_INVALIDFORMAT          6
#define BMMRES_CORRUPTFILE            7
#define BMMRES_SINGLEFRAME            8     // Goto request on a single frame image
#define BMMRES_INVALIDUSAGE           9     // Bad argument passed to function (Developer Mistake)
#define BMMRES_RETRY                  10    // User selected "Retry" from error dialogue
#define BMMRES_NUMBEREDFILENAMEERROR  11
#define BMMRES_INTERNALERROR          12
#define BMMRES_BADFILEHEADER          13
#define BMMRES_CANTSTORAGE            14
#define BMMRES_BADFRAME               15    // Invalid Frame Number Requested

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//-- BitmapIO usage types ( returned by BitmapIO::Capability() )

#define BMMIO_NONE                         0   // Not defined yet

#define BMMIO_READER                   (1<<0)  // Reads images
#define BMMIO_WRITER                   (1<<1)  // Writes images
#define BMMIO_EXTENSION                (1<<2)  // Uses file extension (File Filter Type)
#define BMMIO_MULTIFRAME               (1<<3)  // "File" contains multiple frames (i.e. FLC, AVI)

#define BMMIO_THREADED                 (1<<4)  // Thread aware plug-in
#define BMMIO_RANDOM_ACCESS            (1<<5)  // Can read and/or write frames in any order
#define BMMIO_NON_CONCURRENT_ACCESS    (1<<6)  // Cannot handle multiple, concurrent requests (FLC, AVI, VTR's, etc)

#define BMMIO_OWN_VIEWER               (1<<7)  // Driver has its own image viewer for its image type.

//-- Frame Buffers

#define BMMIO_FRAMEBUFFER              (1<<7)  // Frame Buffer Driver
#define BMMIO_GRABBER                  (1<<8)  // Device Grabs Video

//-- If the device is able to show its own image info dialogue this flag will be 
//   set. Otherwise, the host must use BitmapManager::GetImageInfo() and display
//   a generic info dialogue.

#define BMMIO_INFODLG            		(1<<9) // Has Info Dialog

//-- Uninterruptible Driver (AVI, FLIC, etc. cannot stop and go) (GG 02/26/97)

#define BMMIO_UNINTERRUPTIBLE			(1<<10)

//-- Drivers that may have a different image for a same given Max frame and same file/device
//   name should define this and implement the EvalMatch() method.

#define BMMIO_EVALMATCH				(1<<11)

//-- Special IFL device

#define BMMIO_IFL                		(1<<28)

//-- There is only a single call to the plug-in's control panel but the call specifies
//   the nature of the operation going on. It's up to the plug-in to provide different
//   interfaces if needed. If one control serves two or more services, all the pertinent
//   flags should be set.

#define BMMIO_CONTROLREAD        (1<<29) // Device Driver has Control Panel for Read Operations
#define BMMIO_CONTROLWRITE       (1<<30) // Device Driver has Control Panel for Write Operations
#define BMMIO_CONTROLGENERIC     (1<<31) // Device Driver has a generic Control Panel

//-----------------------------------------------------------------------------
//-- Bitmap close options

#define BMM_CLOSE_COMPLETE       0
#define BMM_CLOSE_ABANDON        1

//-- Filter Types

#define BMM_FILTER_NONE          0
#define BMM_FILTER_DUMMY         1
#define BMM_FILTER_SUM           2
#define BMM_FILTER_PYRAMID       3

//-- Filter Flag values

#define BMM_FILTER_NOFLAGS       ((DWORD)0)
#define BMM_FILTER_LERP_WRAP     ((DWORD)(1<<0))

//-- Dither Types

#define BMM_DITHER_NONE          0
#define BMM_DITHER_FLOYD         1

//-- Pyramidal filter information

#define MAX_PYRAMID_DEPTH        12
#define LAYER_DIM                MAX_PYRAMID_DEPTH+1

typedef struct {
   WORD  dmax;
   void  *map[LAYER_DIM];
   void  *alpha[LAYER_DIM]; 
} BMM_Pyramid;

//-- Summed-area table information

typedef struct {
   DWORD *sat_r,*sat_g,*sat_b,*sat_a;
} BMM_SAT;

//-- Bitmap::CopyImage options

#define COPY_IMAGE_CROP                 0                   // Copy image to current map size w/cropping if necessary
#define COPY_IMAGE_RESIZE_LO_QUALITY    1                   // Resize source image to destination map size (draft)
#define COPY_IMAGE_RESIZE_HI_QUALITY    2                   // Resize source image to destination map size (final)
#define COPY_IMAGE_USE_CUSTOM           3                   // Based on Image Input Options (BitmapInfo *)

// Class for storing a linked list of file extension strings
MakeLinkedList(TSTR);

//-- GRAINSTART
//-- Callback for Bitmap Effects
typedef BOOL (WINAPI *PBITMAP_FX_CALLBACK)(
    LPVOID lpparam, int done, int total, TCHAR *msg
    );
//-- GRAINEND

//-----------------------------------------------------------------------------
//-- I/O Handler
//
   
class BMM_IOHandler {

      //-- Name and Capabilities ------------------------
      
      TCHAR      ioShortDesc[MAX_DESCRIPTION]; 
      TCHAR      ioLongDesc[MAX_DESCRIPTION];
      DWORD      ioCapabilities;

      //-- Extension for file types
      
      TSTRList   ioExtension;
      
      //-- DLL Handler ----------------------------------
      
      ClassDesc *cd;
	  int		dllNumber;
      
   public:

      BMMExport BMM_IOHandler();
      
      BMMExport TCHAR           *ShortDescription ( const TCHAR  *d = NULL );
      BMMExport TCHAR           *LongDescription  ( const TCHAR  *d = NULL );
      BMMExport TCHAR           *Extension        ( int index, const TCHAR  *e = NULL );
      BMMExport int              NumExtensions    ( )                { return ioExtension.Count(); }

      BMMExport void             SetCD            ( ClassDesc *dll ) { cd = dll;};
      BMMExport ClassDesc       *GetCD            ( )                { return cd;};
      BMMExport void             SetDllNumber     ( int num )        { dllNumber = num; }
      BMMExport int              GetDllNum        ( )                { return dllNumber; }

      BMMExport void             SetCapabilities  ( DWORD cap )      { ioCapabilities |= cap;};
      BMMExport DWORD            GetCapabilities  ( )                { return (ioCapabilities);};
      BMMExport BOOL             TestCapabilities ( DWORD cap )      { return ((ioCapabilities & cap) != 0);};
      BMMExport BMM_IOHandler&   operator=(BMM_IOHandler &from);
};

//-----------------------------------------------------------------------------
//-- List of I/O Handlers
//

// Class for storing a linked list of Bitmap Manager BMM_IOHandler objects
MakeLinkedList(BMM_IOHandler);
   
class BMM_IOList: public BMM_IOHandlerList {

      BOOL     listed;
       
   public:

      BMM_IOList          ( )                { listed = FALSE; }

      BOOL     Listed     ( BOOL f)          { listed = f; return (listed);};
      BOOL     Listed     ( )                { return (listed);};

      BMMExport int   FindDevice             ( const TCHAR *name);
      BMMExport int   FindDeviceFromFilename ( const TCHAR *name);
      BMMExport int   ResolveDevice          ( BitmapInfo *bi   );
      BMMExport DWORD GetDeviceCapabilities  ( const TCHAR *name);

      //-- This Creates an Instance - Make sure to "delete" it after use.

      BMMExport BitmapIO *CreateDevInstance( const TCHAR *d );
      BMMExport BitmapIO *CreateDevInstance( int idx );

};



//-----------------------------------------------------------------------------
//-- RenderInfo Class
//

enum ProjectionType { ProjPerspective=0, ProjParallel=1 };

class RenderInfo {
   public:
   RenderInfo();
   ProjectionType projType;  
   float kx,ky;            // 3D to 2D projection scale factor 
   float xc,yc;           // screen origin
   BOOL fieldRender;    // field rendered?
   BOOL fieldOdd;         // if true, the first field is Odd lines
   // Render time and tranformations for the 2 fields, if field rendering. 
   // If not, use renderTime[0], etc.
   TimeValue renderTime[2]; 
   Matrix3 worldToCam[2];     
   Matrix3 camToWorld[2];
   BMMExport Point2 MapWorldToScreen(Point3 p, int field=0) { return MapCamToScreen(worldToCam[field]*p);}
   BMMExport Point2 MapCamToScreen(Point3 p);  // map point in camera space to screen
   BMMExport Ray MapScreenToCamRay(Point2 p);  // get viewing ray through screen point, in camera space
   BMMExport Ray MapScreenToWorldRay(Point2 p, int field=0); // get viewing ray through screen point, in world space
   };

//-----------------------------------------------------------------------------
//-- Bitmap Info Class
//

//-- Bitmap flags

#define MAP_NOFLAGS              ((DWORD)0)
#define MAP_READY                ((DWORD)(1<<0))
#define MAP_HAS_ALPHA            ((DWORD)(1<<1))
#define MAP_ALPHA_PREMULTIPLIED  ((DWORD)(1<<2))
#define MAP_PALETTED             ((DWORD)(1<<3))
#define MAP_FRAME_SYSTEM_LOCKED  ((DWORD)(1<<4))
#define MAP_DITHERED             ((DWORD)(1<<5))
#define MAP_FLIPPED              ((DWORD)(1<<6))     // Flipped horizontally
#define MAP_INVERTED             ((DWORD)(1<<7))     // Flipped vertically

//#define MAP_CUSTOMSIZE           ((DWORD)(1<<8))     // Custom size for input
//#define MAP_RESIZE               ((DWORD)(1<<9))     // Resize when input

#ifdef DESIGN_VER
#define MAP_HAS_BGIMAGE          ((DWORD)(1<<29))    // internal use only
#endif
#define MAP_LEGAL_DELETE	     ((DWORD)(1<<30))    // internal use only
#define MAP_VIEW_FILTERED        ((DWORD)(1<<31))    // Test stuff

#define MAP_ALL_FLAGS            0xFFFFFFFF

//-----------------------------------------------------------------------------
//-- Messages sent back by various (client) methods

//-- Sent by the plug-in to notify host of current progress. The host should
//   return TRUE if it's ok to continue or FALSE to abort process.

#define BMM_PROGRESS   WM_USER + 0x120   //-- wParam: Current lParam: Total

//-- Sent by the plug-in to check for process interruption. The host should
//   return FALSE (by setting lParam) if it's ok to continue or TRUE to abort 
//   process.

#define BMM_CHECKABORT WM_USER + 0x121   //-- wParam: 0       lParam: *BOOL

//-- Sent by the plug-in to display an optional textual message (for progress
//   report).

#define BMM_TEXTMSG    WM_USER + 0x122   //-- wParam: 0       lParam: LPCTSTR

class BitmapInfo {
   
		//-- Image name in case of named images such as files -------

		TCHAR                    name[MAX_PATH];

		//-- Device name gotten from BMM_IOHandler::LongDescription() 

		TCHAR                    device[MAX_DESCRIPTION];

		//-- Window Handle to send BMM_UPDATE messages --------------

		HWND                     hWnd;

		//-- Plug-In Parameter Block --------------------------------

		void                    *pidata;
		DWORD                    pisize;

		//-- Basic Image Data ---------------------------------------
		//
		//   When reading an image, or asking for image info, these
		//   fields will tell the user what the image is like.
		//
		//   When creating an image the user will set these fields to
		//   the desired parameters.
		//

		WORD                     width,height;
		float                    aspect,gamma;
		int                      fstart,fend;
		DWORD                    flags,type;

		//-- User data (what user wants) ----------------------------
		//
		//   Custom dimmensions, custom start and end point when
		//   reading sequence of imges, frame to fetch/save, etc.
		//

		WORD                     cwidth,cheight;   
		int                      custxpos,custypos;
		int                      start,end;        
		int                      step,preset_al;
		float                    custgamma;        

		#define BMM_UNDEF_FRAME   0x7FFF0000


		#define BMM_CUSTOM_GAMMA        ((DWORD)(1 << 0))
		#define BMM_CUSTOM_SIZE         ((DWORD)(1 << 1))
		#define BMM_CUSTOM_RESFIT       ((DWORD)(1 << 2))
		#define BMM_CUSTOM_POS          ((DWORD)(1 << 3))
		#define BMM_CUSTOM_FILEGAMMA    ((DWORD)(1 << 4))
		#define BMM_CUSTOM_IFLENUMFILES ((DWORD)(1 << 5))

		#define BMM_CUSTOM_POSNW  0
		#define BMM_CUSTOM_POSN   1
		#define BMM_CUSTOM_POSNE  2
		#define BMM_CUSTOM_POSW   3
		#define BMM_CUSTOM_POSCN  4
		#define BMM_CUSTOM_POSE   5
		#define BMM_CUSTOM_POSSW  6
		#define BMM_CUSTOM_POSS   7
		#define BMM_CUSTOM_POSSE  8

		DWORD                    customflags;

		int                      fnumber;           //-- Defines frame to
                                                  //   read or write.

		//-- When reading a sequence of frames, loopflag indicates what to
		//   do when reading beyond the end of available frames. It 
		//   defaults to BMM_SEQ_WRAP.

		#define  BMM_SEQ_WRAP     0                  //-- Wraps around back to start point
		#define  BMM_SEQ_ERROR    1                  //-- Generates an error
		#define  BMM_SEQ_HOLD     2                  //-- Holds last frame when done
		        
		WORD                     loopflag;         

		void                     doConstruct                 ( );
      
   public:

		BMMExport                BitmapInfo                  ( );
		BMMExport                BitmapInfo                  ( TCHAR *n );
		BMMExport                BitmapInfo                  ( BitmapInfo &bi );
		BMMExport               ~BitmapInfo                  ( );

		//-- Bitmap Flags

		BMMExport DWORD          Flags                       ( ) { return (flags); }
		BMMExport DWORD          SetFlags                    ( DWORD f ) { flags |=  f; return (flags); }
		BMMExport DWORD          ResetFlags                  ( DWORD f ) { flags &= ~f; return (flags); }
		BMMExport BOOL           TestFlags                   ( DWORD f ) { return (flags & f); }

		//-- Generic Read

		BMMExport WORD           Width                       ( ) { return (width); }
		BMMExport WORD           Height                      ( ) { return (height); }
		BMMExport float          Gamma                       ( ) { return (gamma); }
		BMMExport float          Aspect                      ( ) { return (aspect);}
		BMMExport int            Type                        ( ) { return (type); }
		BMMExport int            FirstFrame                  ( ) { return (fstart); }
		BMMExport int            LastFrame                   ( ) { return (fend); }
		BMMExport int            NumberFrames                ( ) { return (fend - fstart + 1); }
		BMMExport int            CurrentFrame                ( ) { return (fnumber); }
		BMMExport WORD           SequenceOutBound            ( ) { return (loopflag); }

		//-- "Name" returns full path of image file

		BMMExport const TCHAR   *Name                        ( ) { return (const TCHAR *)name;   }

		//-- "Filename" returns just the name of image file

		BMMExport const TCHAR   *Filename                    ( );

		//-- "Device" is the device reponsible for producing this image.
		//   For file types, this is just informative. For non file types
		//   this is the way this image is identified. Therefore, it is
		//   important to save both name and device in order to properly
		//   identify an image.

		BMMExport const TCHAR   *Device                      ( ) { return (const TCHAR *)device; }

		//-- Compare Two Bitmaps

		BMMExport BOOL           CompareName                 ( BitmapInfo *bi );

		//-- Copy Image info. Only name, device and image characteristics are
		//   copied. User info, such as Custom Width, etc. is not copied. 

		BMMExport void           CopyImageInfo               ( BitmapInfo *from );

		//-- Generic Write

		BMMExport int            SetFirstFrame               ( int m ) { int o = fstart;   fstart   = m; return (o);}
		BMMExport int            SetLastFrame                ( int s ) { int o = fend;     fend     = s; return (o);}
		BMMExport int            SetCurrentFrame             ( int v ) { int o = fnumber;  fnumber  = v; return (o);}
		BMMExport WORD           SetSequenceOutBound         ( WORD  c ) { WORD  o = loopflag; loopflag = c; return (o);}

		BMMExport WORD           SetWidth                    ( WORD  s ) { WORD  o = width;    width    = s; return (o);}
		BMMExport WORD           SetHeight                   ( WORD  u ) { WORD  o = height;   height   = u; return (o);}
		BMMExport float          SetGamma                    ( float c ) { float o = gamma;    gamma    = c; return (o);}
		BMMExport float          SetAspect                   ( float k ) { float o = aspect;   aspect   = k; return (o);}
		BMMExport int            SetType                     ( int   s ) { int   o = type;     type     = s; return (o);}

		BMMExport const TCHAR   *SetName                     ( const TCHAR *n );
		BMMExport const TCHAR   *SetDevice                   ( const TCHAR *d );

		//-- Custom Input Processing

		BMMExport WORD           CustWidth                   ( ) { return (cwidth);        }
		BMMExport WORD           CustHeight                  ( ) { return (cheight);       }
		BMMExport void           SetCustWidth                ( WORD w ) { cwidth  = w;     }
		BMMExport void           SetCustHeight               ( WORD h ) { cheight = h;     }
		BMMExport int            StartFrame                  ( ) { return (start);         }
		BMMExport int            EndFrame                    ( ) { return (end);           }
		BMMExport void           SetStartFrame               ( int s )  { start = s;      }
		BMMExport void           SetEndFrame                 ( int e )  { end   = e;      }
		BMMExport void           SetCustomX                  ( int x ) { custxpos = x;    }
		BMMExport void           SetCustomY                  ( int y ) { custypos = y;    }
		BMMExport int            GetCustomX                  ( ) { return custxpos;        }
		BMMExport int            GetCustomY                  ( ) { return custypos;        }
		BMMExport void           SetCustomGamma              ( float g ) { custgamma = g;  }
		BMMExport float          GetCustomGamma              ( ) { return custgamma;       }
		BMMExport void           SetCustomStep               ( int s ) { step = s;         }
		BMMExport int            GetCustomStep               ( ) { return step;            }
		BMMExport void           SetPresetAlignment          ( int p ) { preset_al = p;    }
		BMMExport int            GetPresetAlignment          ( ) { return preset_al;       }

		//-- Custom Input Flags

		BMMExport DWORD          GetCustomFlags              ( ) { return (customflags);             }
		BMMExport void           SetCustomFlag               ( DWORD f ) { customflags |=  f;        }
		BMMExport void           ResetCustomFlag             ( DWORD f ) { customflags &= ~f;        }
		BMMExport BOOL           TestCustomFlags             ( DWORD f ) { return (customflags & f); }

		//-- Plug-In Parameter Block

		BMMExport void*			GetPiData                   ( ) { return pidata;          }
		BMMExport void          SetPiData                   ( void *ptr ) { pidata = ptr; }
		BMMExport DWORD         GetPiDataSize               ( ) { return pisize;          }
		BMMExport void          SetPiDataSize               ( DWORD s ) { pisize = s;     }
		BMMExport void          ResetPiData                 ( );
		BMMExport BOOL          AllocPiData                 ( DWORD size );

		//-- Used to create Format Specific Parameter Block. Name and/or Device must be defined before using it.

		BMMExport void*			CreateFmtSpecBlock			( void );

		BMMExport void          Copy                        ( BitmapInfo *from ); //\\-- OBSOLETE --\\//
		BMMExport BitmapInfo    &operator=                  ( BitmapInfo &from );

		//-- Load/Save

		BMMExport IOResult       Save                        ( ISave *isave );
		BMMExport IOResult       Load                        ( ILoad *iload );
		BMMExport void           EnumAuxFiles                ( NameEnumCallback& nameEnum, DWORD flags);
		  
		//-- Miscelaneous

		BMMExport BOOL           Validate                    ( );
		BMMExport HWND           GetUpdateWindow             ( )           { return hWnd; }
		BMMExport void           SetUpdateWindow             ( HWND hwnd ) { hWnd = hwnd; }
		BMMExport DWORD          GetGChannels                ( );
		BMMExport DWORD          GetDeviceFlags              ( );

};

//-----------------------------------------------------------------------------
//-- Bitmap I/O Class
//
//   None of these methods are to be used directly. Use the BitmapManager for
//   any image I/O.
//


class BitmapIO {
    private:
      UWORD* outputGammaTab;   // this may be owned by gammaMgr
      UWORD* privGammaTab;     // private gamma table owned by the BitmapIO.
           
   protected:
      float                   gamma;     
      Bitmap                  *map;                        // The bitmap using this OUTPUT handler
      BitmapStorage           *storage;                    // The storage used by this INPUT handler

      int                      openMode;                   // See above
      
      //-- Linked list pointers for multiple output of a single bitmap

      BitmapIO                *prevIO;                     
      BitmapIO                *nextIO;

   public:

      // Used by the subclassed BitmapIO's to get pixels for output with
      // the appropriate output gamma correction.
      BMMExport  int           GetOutputPixels          ( int x,int y,int pixels,BMM_Color_64  *ptr, BOOL preMultAlpha=TRUE);
      
      // Used by the subclassed BitmapIO's to get 32 bit pixels for output with
      // the appropriate output gamma correction and dither. 
      BMMExport  int           GetDitheredOutputPixels  ( int x,int y,int pixels,BMM_Color_32  *ptr, BOOL preMultAlpha=TRUE);

      // Used by the subclassed BitmapIO's to get a DIB  for output with
      // the appropriate output gamma correction. 
      BMMExport  PBITMAPINFO   GetOutputDib             ( int depth = 24   );

      // Used by the subclassed BitmapIO's to get a DIB  for output with
      // the appropriate output gamma correction and dither
      BMMExport  PBITMAPINFO   GetDitheredOutputDib      ( int depth = 24   );

      BMMExport  float         OutputGamma();

      // If a BitmapIO wants to do its own dithering, it should call
      // these to find out if dithering is wanted.  If it is a 24 bit or
      // 32 bit format, it would usually just call GetDitheredOutputPixels instead.
      BMMExport  BOOL          DitherTrueColor();
      BMMExport  BOOL          DitherPaletted();

      // Calculate a color palette for output color packing: gamma corrects
      BMMExport  int           CalcOutputPalette(int palsize, BMM_Color_48 *pal);
   
      BMMExport                BitmapIO                    ( );
      bVirtual                ~BitmapIO                    ( );
      
      BitmapInfo               bi;
   
      inline    int            OpenMode                    ( ) { return (openMode); }
      inline    void           SetPrev                     ( BitmapIO *prev) { prevIO = prev; };
      inline    void           SetNext                     ( BitmapIO *next) { nextIO = next; };
      inline    BitmapIO      *Prev                        ( ) { return prevIO; };
      inline    BitmapIO      *Next                        ( ) { return nextIO; };
      
      BMMExport BitmapStorage *Storage                     ( );
      inline    Bitmap        *Map                         ( ) { return map; };

      bVirtual  int            ExtCount                    ( ) = 0;                                // Number of extemsions supported
      bVirtual  const TCHAR   *Ext                         ( int n ) = 0;                          // Extension #n (i.e. "3DS")
      bVirtual  const TCHAR   *LongDesc                    ( ) = 0;                                // Long ASCII description (i.e. "Targa 2.0 Image File")
      bVirtual  const TCHAR   *ShortDesc                   ( ) = 0;                                // Short ASCII description (i.e. "Targa")
      bVirtual  const TCHAR   *AuthorName                  ( ) = 0;                                // ASCII Author name
      bVirtual  const TCHAR   *CopyrightMessage            ( ) = 0;                                // ASCII Copyright message
      bVirtual  UINT           Version                     ( ) = 0;                                // Version number * 100 (i.e. v3.01 = 301)
      
      bVirtual  int            Capability                  ( ) = 0;                                // Returns IO module ability flags (see above)
      bVirtual  void           ShowAbout                   ( HWND hWnd ) = 0;                      // Show DLL's "About..." box

      //-- If the BMMIO_OWN_VIEWER flag is set, this method will be called
      //   whenever the user wants to view an image for this device. This
      //   is for devices which can "play" image sequences such as AVI's, FLIC's, etc.
      //-- TH 2/26/96 -- Added BOOL return to indicate if view worked.  If it didn't,
      //   it returns FALSE and the caller can view by the normal mechanism.

      bVirtual  BOOL           ShowImage                   ( HWND hWnd, BitmapInfo *bi ) { return FALSE; }

      //-- Show DLL's Control Panel
      //
      //   If the user exists through an Ok, this function will return TRUE.
      //   If the user cancels out, it will return FALSE. False indicates
      //   nothing has changed so the system won't bother asking the plug-in
      //   if it wants to save data.
      //
      //   This function is only called if the plug-in has defined it supports
      //   it (through the Capability  flag above).  The flag will indicate to
      //   the plug-in what operation is this control for (read, write, or
      //   generic).
      //
      
      bVirtual  BOOL           ShowControl                 ( HWND hWnd, DWORD flag ) { return FALSE; }
      
      //-- Parameter Block Load and Save ------------------------------------
      //
      //  The host will call EvaluateConfigure() to determine the buffer size
      //  required by the plug-in.
      //
      //  SaveConfigure() will be called so the plug-in can transfer its
      //  parameter block to the host ( ptr is a pre-allocated buffer).
      //
      //  LoadConfigure() will be called so the plug-in can load its 
      //  parameter block back.
      //  
      //  Memory management is performed by the host using standard
      //  LocalAlloc() and LocalFree().
      //  
      
      bVirtual  DWORD          EvaluateConfigure           ( ) = 0;
      bVirtual  BOOL           LoadConfigure               ( void *ptr ) = 0;
      bVirtual  BOOL           SaveConfigure               ( void *ptr ) = 0;

      //-- Used internaly to make sure current block belongs to Plug-In
      
      bVirtual  BOOL           ValidatePiData              ( BitmapInfo *bi );

      //-- System Interface
      
      BMMExport BOOL           SilentMode                  ( );


      //-- Calculate Desired Frame
      //
      //   This is for multiframe sequences. It processes the desired frame
      //   based on user options. It is used at the Load() function to find
      //   out which frame to load.
      //
      //   "fbi"    is the one passed to Load()
      //   "frame"  is a pointer to an integer to receive the frame number
      
      BMMExport BMMRES         GetFrame                    ( BitmapInfo *fbi, int *frame);
      
      //-- Critical Error Handling
      
      BMMExport BMMRES         ProcessImageIOError         ( BitmapInfo *bi, TCHAR *string = NULL);
      BMMExport BMMRES         ProcessImageIOError         ( BitmapInfo *bi, int errorcode);
      
      //---------------------------------------------------------------------
      //-- Channels Required (for Output)
      //
      //   By setting this flag, the plug-in can request the host to generate
      //   the given channels. Prior to Rendering, the host will scan the
      //   plug-ins in the chain of events and list all types of channels
      //   being requested. The plug-in, at the time of the Write() call, will
      //   have access to these channels through the channel interface
      //   described below in BitmapStorage().
      //
      //   The generation of these channels should not, normally, be a 
      //   default setting for a plug-in. These channels are memory hungry and
      //   if the plug-in won't use it, it should not ask for it. Normally
      //   the plug-in would ask the user which channels to save and set only
      //   the proper flags.
      //
      
      bVirtual  DWORD          ChannelsRequired            ( ) { return BMM_CHAN_NONE; }
      
      //-- Image Info
      
      bVirtual  BMMRES         GetImageInfoDlg             ( HWND hWnd, BitmapInfo *bi, const TCHAR *filename = NULL ) {return BMMRES_NODRIVER;}
      bVirtual  BMMRES         GetImageInfo                (            BitmapInfo *bi ) = 0;
      
      //-- Image File Loaders (IFL handlers)
      
      bVirtual  BMMRES         GetImageName                ( BitmapInfo *bi, TCHAR *filename) {filename[0]=0; return (BMMRES_SUCCESS);}

      //-- Image I/O (Not to use directly)
      
      bVirtual  BitmapStorage *Load                        ( BitmapInfo *bi, Bitmap *map, BMMRES *status ) = 0;      

      bVirtual  BMMRES         OpenOutput                  ( BitmapInfo *bi, Bitmap *map );
      bVirtual  BMMRES         Write                       ( int frame );
      bVirtual  int            Close                       ( int flag );
      bVirtual  PAVIFILE       GetPaviFile                 ( ) { return NULL; }

      // used internally to build output gamma table

      BMMExport void			InitOutputGammaTable(BitmapInfo*bi);

      //-- Evaluate Matching Frame (R2)

      bVirtual  void			EvalMatch		            ( TCHAR *matchString ) { matchString[0] = 0; }




};

//-----------------------------------------------------------------------------
//-- Bitmap Storage Class
//
//   None of these methods are to be used directly. Use the Bitmap class for
//   any image read/write.
//

//-- Channel Operations (for Get/Put16Channel)

#define BMM_CHANNEL_RED          0    //-- Get/Put only Red
#define BMM_CHANNEL_GREEN        1    //-- Get/Put only Green
#define BMM_CHANNEL_BLUE         3    //-- Get/Put only Blue
#define BMM_CHANNEL_ALPHA        4    //-- Get/Put only Alpha
#define BMM_CHANNEL_Z            5    //-- Get/Put only Z
#define BMM_CHANNEL_LUMINANCE    6    //-- Get (R+G+B)/3

class BitmapStorage {
#ifdef DESIGN_VER
   friend class GcsBitmap;
#endif
   protected:
   
      int                      openMode;                   // See above
      UINT                     usageCount;                 // Number of Bitmaps using this storage
      BitmapManager           *manager;

      int                      flags;
      int                      type;                       // See "Basic bitmap types", below

      BMM_Color_48             palette[256];               // 256 palette entries max
      int                      paletteSlots;
      UWORD                    *gammaTable;               // Gamma correction table
      
      RenderInfo               *rendInfo;
	  GBuffer                  *gbuffer;
   public:

      BMMExport                BitmapStorage               ( );
      bVirtual                ~BitmapStorage               ( );

      BitmapInfo               bi;
	   TCHAR*					evalString;

      // gamma 
      BMMExport   float        SetGamma(float gam);         
      inline      int          HasGamma                    ( ) { return (gammaTable!=NULL)          ? 1:0; };
      BMMExport   void         SetHasGamma(BOOL onOff);   
      void               UpdateGammaTable(); 
      BMMExport   UWORD       *GetInputGammaTable();

      inline  BitmapManager   *Manager                     ( ) { return manager;     }
      inline  int              OpenMode                    ( ) { return openMode;    }
      inline  int              Width                       ( ) { return bi.Width();  }
      inline  int              Height                      ( ) { return bi.Height(); }
      inline  float            Aspect                      ( ) { return bi.Aspect(); }
      inline  float            Gamma                       ( ) { return bi.Gamma();  }
      
      inline  int              Paletted                    ( ) { return (flags & MAP_PALETTED)            ? paletteSlots:0; }
      inline  int              IsDithered                  ( ) { return (flags & MAP_DITHERED)            ? 1:0; };
      inline  int              PreMultipliedAlpha          ( ) { return (flags & MAP_ALPHA_PREMULTIPLIED) ? 1:0; };
      inline  int              HasAlpha                    ( ) { return (flags & MAP_HAS_ALPHA)           ? 1:0; };
      
      inline  int              UsageCount                  ( ) { return usageCount; };
      inline  int              Type                        ( ) { return type; };
      inline  int              Flags                       ( ) { return flags; };
      inline  void             SetFlags                    ( DWORD f ) { flags |=  f; }

      bVirtual int             MaxRGBLevel                 ( ) = 0;
      bVirtual int             MaxAlphaLevel               ( ) = 0;
      
      //-- Scaling Tools

      bVirtual void           Scale       	               ( WORD *, int, WORD *, int );
      bVirtual BOOL           GetSRow     	               ( WORD *, int, WORD *, int );
      bVirtual BOOL           PutSRow     	               ( WORD *, int, WORD *, int );
      bVirtual BOOL           GetSCol     	               ( WORD *, WORD *, int, int );
      bVirtual BOOL           PutSCol     	               ( WORD *, WORD *, int, int );
      bVirtual BOOL           ScaleY      	               ( Bitmap *, BMM_Color_64 *, WORD *, WORD *, HWND, int cw = 0, int ch = 0 );
      bVirtual BOOL           ScaleX      	               ( Bitmap *, BMM_Color_64 *, WORD *, WORD *, HWND, int cw = 0, int ch = 0 );
      bVirtual int            StraightCopy                 ( Bitmap *from );

      bVirtual void           *GetStoragePtr               ( int *type ) { *type = BMM_NO_TYPE; return (NULL); }
      bVirtual void           *GetAlphaPtr                 ( int *type ) { *type = BMM_NO_TYPE; return (NULL); }

      //-- These are the standard methods for accessing image pixels
      
      bVirtual int             Get16Gray                   ( int x,int y,int pixels,WORD  *ptr) = 0;
      bVirtual int             Put16Gray                   ( int x,int y,int pixels,WORD  *ptr) = 0;
      bVirtual int             GetLinearPixels             ( int x,int y,int pixels,BMM_Color_64  *ptr) = 0;
      bVirtual int             GetPixels                   ( int x,int y,int pixels,BMM_Color_64  *ptr) = 0;
      bVirtual int             PutPixels                   ( int x,int y,int pixels,BMM_Color_64  *ptr) = 0;
      bVirtual int             GetIndexPixels              ( int x,int y,int pixels,unsigned char *ptr) = 0;
      bVirtual int             PutIndexPixels              ( int x,int y,int pixels,unsigned char *ptr) = 0;
      
      bVirtual int             CropImage                   ( int width,int height,BMM_Color_64 fillcolor) = 0;
      bVirtual int             CropImage                   ( int width,int height,int fillindex)  = 0;
      bVirtual int             ResizeImage                 ( int width,int height,int newpalette) = 0;

      bVirtual int             CopyCrop                    ( Bitmap *from, BMM_Color_64 fillcolor );
      bVirtual int             CopyScaleLow                ( Bitmap *from );
      bVirtual int             CopyScaleHigh               ( Bitmap *from, HWND hWnd, BMM_Color_64 **buf = NULL, int w=0, int h=0 );

      bVirtual int             CopyImage                   ( Bitmap *from,int operation,BMM_Color_64 fillcolor, BitmapInfo *bi = NULL);
      bVirtual int             CopyImage                   ( Bitmap *from,int operation,int fillindex);
      bVirtual int             GetPalette                  ( int start,int count,BMM_Color_48 *ptr) = 0;
      bVirtual int             SetPalette                  ( int start,int count,BMM_Color_48 *ptr) = 0;
      bVirtual int             GetFiltered                 ( float u,float v,float du,float dv,BMM_Color_64 *ptr) = 0;
      
      //-- User Interface
      
      bVirtual int             Allocate                    ( BitmapInfo *bi,BitmapManager *manager,int openMode)  = 0;
      bVirtual int             Connect                     ( ) = 0;
      bVirtual int             Disconnect                  ( ) = 0;
      bVirtual int             MapReady                    ( ) = 0;
      bVirtual int             ClosestColor                ( BMM_Color_48 color);
      bVirtual int             ClosestColor                ( int r,int g,int b);

      // GBuffer methods ----------------------
      // get a pointer to specified channel: also determine its type for check
      bVirtual void*    GetChannel(ULONG channelID, ULONG& chanType) { return gbuffer?gbuffer->GetChannel(channelID, chanType):NULL;}

      GBuffer *GetGBuffer()  { return gbuffer; } 

      // create the specified channels -- return channels present: (creates GBuffer if non-existent); 
      bVirtual ULONG    CreateChannels(ULONG channelIDs);
      
      // delete all the channels in channelIDs
      bVirtual void     DeleteChannels(ULONG channelIDs) { if (gbuffer) gbuffer->DeleteChannels(channelIDs); }  

      // query which channels are present
      bVirtual ULONG     ChannelsPresent() { return gbuffer?gbuffer->ChannelsPresent():0;  }


      // For output bitmaps, can get RenderInfo, which is written by the
      // renderer
      // AllocRenderInfo will alloc only if RenderInfo doesn't yet exist.
      BMMExport RenderInfo* AllocRenderInfo(); 
      // GetRenderInfo just hands back RenderInfo pointer
      BMMExport RenderInfo* GetRenderInfo();

};

//-----------------------------------------------------------------------------
//-- Bitmap Filter Class
//
//   Private class not to be documented
//

class BitmapFilter {
   
   protected:
   
      UINT                     usageCount;                 // Number of Bitmaps using this storage
      BitmapManager           *manager;                    // Pointer to bitmap manager
      BitmapStorage           *storage;                    // Pointer to storage itself
      DWORD                    flags;                      // Filter flags
      int                      dirty;                      // Needs updating flag
      UINT                     type;                       // Type index of filter
      
   public:
   
      BMMExport                BitmapFilter();
      bVirtual                ~BitmapFilter();
      
      inline    DWORD          Flags                       ( ) { return flags; };
      inline    void           SetFlag                     ( DWORD flag) { flags |= flag; dirty = 1; };
      inline    void           ToggleFlag                  ( DWORD flag) { flags ^= flag; dirty = 1; };
      inline    void           ClearFlag                   ( DWORD flag) { flags &= (~flag); dirty = 1; };
      inline    UINT           Type                        ( ) { return type; };
      inline    void           SetType                     ( UINT t) { type = t; };
      BMMExport int            Initialize                  ( BitmapManager *m,BitmapStorage *s);

      virtual   int            GetFiltered                 ( float u,float v,float du,float dv,BMM_Color_64 *ptr) = 0;
      virtual   void           Free                        ( ) {};

      BMMExport int            Connect                     ( );
      BMMExport int            Disconnect                  ( );
      BMMExport int            SetStorage                  ( BitmapStorage *storage);
      inline  BitmapStorage   *GetStorage                  ( ) { return storage; };
      inline    void           MakeDirty                   ( ) { dirty = 1; };

};

//-----------------------------------------------------------------------------
//-- Bitmap Dither Class
//
//   Private class not to be documented

class BitmapDither {
   
   protected:
   
      BitmapStorage           *storage;                    // Pointer to storage itself
      int                      type;                       // Type index of filter
      
   public:
    
      BMMExport                BitmapDither                ( );
      bVirtual                ~BitmapDither                ( );
      inline    UINT           Type                        ( ) { return type; };
      inline    void           SetType                     ( UINT t) { type = t; };
      BMMExport int            Initialize                  ( BitmapStorage *s);
      virtual   int            PutPixels                 ( int x,int y,int pixels,BMM_Color_64 *ptr) = 0;
      virtual   void           Free                        ( ) {};
      BMMExport int            SetStorage                  ( BitmapStorage *storage);
    
};


// Callback for notifying bitmaps that their Storage has changed, and 
// any on screen displays need to be refreshed.  Installed via
// Bitmap::SetNotify();
// VFBClosed is 
class BitmapNotify{
public:
	virtual int Changed(ULONG flags)=0;
	virtual void VFBClosed() {}  // called when VFB is closed
	};

// Callback for interactive adjustment of bitmap "Cropping rectangle", passed
// in as an argument to Bitmap::Display.
class CropCallback {
	public:
	virtual float GetInitU()=0;
	virtual float GetInitV()=0;
	virtual float GetInitW()=0;
	virtual float GetInitH()=0;
	virtual BOOL GetInitMode()=0;
	virtual void SetValues(float u, float v, float w, float h, BOOL md)=0;
	virtual void OnClose()=0;
	};
	
//-----------------------------------------------------------------------------
//-- Basic Bitmap Class
//
//
   
#define BMM_SINGLEFRAME -2000000L

class Bitmap {
   friend class BitmapManagerImp;
      
   private:
   
      DWORD                    flags;                      // See above

      BitmapManager            *manager;                   // Manager of this bitmap
      BitmapIO                 *output;                    // Head of output handler list
      BitmapFilter             *filter;                    // Filtered access methods
      BitmapDither             *dither;                    // Dither methods
      BitmapStorage            *storage;                   // Actual storage
      UINT                     filterType;                 // Filtered access type
      UINT                     ditherType;                 // Dither type
	  DWORD					   modifyID;                   // changes when bitmap changes: used in render effects
      int                      Free();

	  void 					   *vfbData;	

	  BitmapNotify *bmNotify;		// Called when storage is change so display can update

      friend LRESULT CALLBACK  InputWndProc                ( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam );

	  // To delete a Bitmap, call Bitmap::DeleteThis()
      BMMExport               ~Bitmap                      ( );

	  // To get a new Bitmap, call BitmapManager::NewBitmap()
      BMMExport                Bitmap                      ( BitmapManager *manager = TheManager );
     
   public:

      inline  BitmapManager   *Manager                     ( ) { return manager; };

      //-- Don't use these unless you know what you're doing ----------------
      
      BMMExport int            Create                      ( BitmapInfo *bi );
      BMMExport BOOL           FixDeviceName               ( BitmapInfo *bi );
      inline    int            MapReady                    ( ) { if (storage) return storage->MapReady(); return 0; };
      BMMExport void           AddOutput                   ( BitmapIO *out  );
      BMMExport void           RemoveOutput                ( BitmapIO *out  );
      BMMExport BitmapIO *     FindOutput                  ( BitmapInfo *bi );
      BMMExport PAVIFILE       GetPaviFile                 ( BitmapInfo *bi );
	  inline  void 			   *GetVFBData				   ( )	{ return vfbData; }
	  inline  void 			    SetVFBData				   (void *vfb )	{ vfbData = vfb; }

      
      //-- Public Interface -------------------------------------------------
      
      BMMExport void           DeleteThis                  ( ); // Call this , NOT delete, to free a Bitmap.		      
      inline  DWORD            Flags                       ( ) { return flags; };
      inline  void             SetFlag                     ( DWORD flag ) { flags |= flag; };
      inline  void             ToggleFlag                  ( DWORD flag ) { flags ^= flag; };
      inline  void             ClearFlag                   ( DWORD flag ) { flags &= (~flag); };
      
      inline  int              Width                       ( ) { if (storage) return storage->Width();              return 0; };
      inline  int              Height                      ( ) { if (storage) return storage->Height();             return 0; };
      inline  float            Aspect                      ( ) { if (storage) return storage->Aspect();             return (float)0.0; };
      inline  float            Gamma                       ( ) { if (storage) return storage->Gamma();              return (float)0.0; };
      inline  int              Paletted                    ( ) { if (storage) return storage->Paletted();           return 0; };
      inline  int              IsDithered                  ( ) { if (storage) return storage->IsDithered();         return 0; };
      inline  int              PreMultipliedAlpha          ( ) { if (storage) return storage->PreMultipliedAlpha(); return 0; };
      inline  int              HasAlpha                    ( ) { if (storage) return storage->HasAlpha();           return 0; };
      inline  int              MaxRGBLevel                 ( ) { if (storage) return storage->MaxRGBLevel();        return 0; };
      inline  int              MaxAlphaLevel               ( ) { if (storage) return storage->MaxAlphaLevel();      return 0; };
      
              int              Put16Gray                   ( int x,int y,int pixels,WORD *ptr )
                                                           { if (storage) return storage->Put16Gray(x,y,pixels,ptr); return 0; };
      inline  void            *GetStoragePtr               ( int *type ) 
                                                           { if (storage) return storage->GetStoragePtr(type);       return NULL; };
      inline  void            *GetAlphaPtr                 ( int *type ) 
                                                           { if (storage) return storage->GetAlphaPtr(type);         return NULL; };
      inline  int              Get16Gray                   ( int x,int y,int pixels,WORD *ptr )
                                                           { if (storage) return storage->Get16Gray(x,y,pixels,ptr);         return 0; };
      inline  int              GetPixels                   ( int x,int y,int pixels,BMM_Color_64 *ptr )
                                                           { if (storage) return storage->GetPixels(x,y,pixels,ptr);         return 0; };
      BMMExport int            PutPixels                   ( int x,int y,int pixels,BMM_Color_64 *ptr );
      inline  int              GetLinearPixels             ( int x,int y,int pixels,BMM_Color_64 *ptr )
                                                           { if (storage) return storage->GetLinearPixels(x,y,pixels,ptr);     return 0; };
      inline  int              GetIndexPixels              ( int x,int y,int pixels,BYTE *ptr )
                                                           { if (storage) return storage->GetIndexPixels(x,y,pixels,ptr);      return 0; };
      inline  int              PutIndexPixels              ( int x,int y,int pixels,BYTE *ptr )
                                                           { if (storage) return storage->PutIndexPixels(x,y,pixels,ptr);      return 0; };
      inline  int              CropImage                   ( int width,int height,BMM_Color_64 fillcolor)
                                                           { if (storage) return storage->CropImage(width,height,fillcolor);   return 0; };
      inline  int              CropImage                   ( int width,int height,int fillindex)
                                                           { if (storage) return storage->CropImage(width,height,fillindex);   return 0; };
      inline  int              ResizeImage                 ( int width,int height,int newpalette)
                                                           { if (storage) return storage->ResizeImage(width,height,newpalette);return 0; };
      inline  int              CopyImage                   ( Bitmap *from,int operation,BMM_Color_64 fillcolor, BitmapInfo *bi = NULL)
                                                           { if (storage) return storage->CopyImage(from,operation,fillcolor,bi); return 0; };
      inline  int              CopyImage                   ( Bitmap *from,int operation,int fillindex)
                                                           { if (storage) return storage->CopyImage(from,operation,fillindex); return 0; };
      inline  int              GetPalette                  ( int start,int count,BMM_Color_48 *ptr)
                                                           { if (storage) return storage->GetPalette(start,count,ptr);         return 0; };
      inline  int              SetPalette                  ( int start,int count,BMM_Color_48 *ptr)
                                                           { if (storage) return storage->SetPalette(start,count,ptr);         return 0; };

	  //-- GRAINSTART

      // Effects methods (GG 11/03/98) ----------

      BMMExport void			FilmGrain				( float grain, BOOL mask, PBITMAP_FX_CALLBACK callback = NULL, void *param = NULL );

	  //-- GRAINEND

      // GBuffer methods ---------------------

	  inline void             *GetChannel                ( ULONG channelID, ULONG& chanType ) 
                                       { if (storage) return storage->GetChannel(channelID, chanType); return NULL; }   
      
      inline GBuffer *GetGBuffer()  { return storage? storage->GetGBuffer(): NULL; } 

      inline ULONG            CreateChannels             ( ULONG channelIDs ) 
                                             { if (storage) return storage->CreateChannels(channelIDs); return 0; }   
      inline void             DeleteChannels             ( ULONG channelIDs ) 
                                             { if (storage) storage->DeleteChannels(channelIDs); }     
      inline ULONG            ChannelsPresent            ( )   
                                             { if (storage) return storage->ChannelsPresent();  return 0; }   
      inline RenderInfo*           GetRenderInfo()        { if (storage) return storage->GetRenderInfo(); return NULL; }

      inline RenderInfo*           AllocRenderInfo()     { if (storage) return storage->AllocRenderInfo(); return NULL; }


      //---------------------------------------------------------------------
      //
      //   This call will check with the plug-in (file or device) defined in 
      //   the given BitmapInfo and prepare (create) the proper channels. If 
      //   a given channel already exists, no new channel will be created. 
      //
      //   After creating a bitmap, use this function to define the optional 
      //   channels that may be required by the given handler. 
      //

      BMMExport BOOL          PrepareGChannels           ( BitmapInfo *bi ); 
      BMMExport BOOL          PrepareGChannels           ( DWORD channels ); 


      BMMExport int           GetFiltered                ( float u,float v,float du,float dv,BMM_Color_64 *ptr );
      BMMExport int           SetDither                  ( UINT ditherType );
      BMMExport int           SetFilter                  ( UINT filterType );
      inline    int           HasFilter                  ( ) { return (filter) ? 1:0; };
      inline    BitmapFilter  *Filter                    ( ) { return filter; }; 
      BMMExport int           SetStorage                 ( BitmapStorage *storage);
      inline    BitmapStorage *Storage                   ( ) { return storage; };
      inline    void          NullStorage                ( ) { storage = NULL; };
      
      //-- Windows DIB Conversion -------------------------------------------
      //
      //   Where depth is either 24 (BGR) or 32 (BGR0)
      //

      BMMExport PBITMAPINFO    ToDib                       ( int depth = 24, UWORD *gam=NULL, BOOL dither=FALSE);

      //-- Do not use this directly. Instead, use BitmapManager::Create(PBITMAPINFO)

      BMMExport BOOL           FromDib                     ( PBITMAPINFO pbmi );
      
      //-- Image output operations ------------------------------------------
      //
      //  To write a single image to a file/device:
      //
      //  *> Create BitmapInfo class: BitmapInfo bi;
      //
      //  *> Define output file/device:
      //
      //     Directly:       bi.SetName("file.tga");
      //   or
      //     User Interface: BitmapManager::SelectFileOutput( ... &bi ...)
      //
      //  *> Define bitmap: 
      //
      //                     bi.SetWidth(x)
      //                     bi.SetHeight(y)
      //                     etc...
      //
      //  *> Create bitmap:  Bitmap *map = BitmapManager::Create(&bi);
      //                     
      //
      //  *> Do something:   map->Fill({0,0,0});
      //
      //  *> OpenOutput:     map->OpenOutput(&bi);
      //
      //  *> Write:          map->Write(&bi)
      //
      //  *> Close:          map->Close(&bi)
      //
      //  To write a multiframe file, just keep doing something different to
      //  the bimap and keep writting. 
      //
      //  To write a sequence of images to a file/device:
      //
      //  *> Create BitmapInfo class: BitmapInfo bi;
      //
      //  *> Define output file/device:
      //
      //     Directly:       bi.SetName("file.tga");
      //   or
      //     User Interface: BitmapManager::SelectFileOutput( ... &bi ...)
      //
      //  *> Define bitmap: 
      //
      //                     bi.SetWidth(x)
      //                     bi.SetHeight(y)
      //
      //                     bi.SetFirstFrame(0)
      //                     bi.SetLastFrame(29)
      //
      //                     etc...
      //
      //  *> Create bitmap:  Bitmap *map = BitmapManager::Create(&bi);
      //                     
      //
      //  *> OpenOutput:     map->OpenOutput(&bi);
      //
      //     for (x = 0 to 29) {
      //        *> Do something to image...
      //        *> Write:    map->Write(&bi,x);
      //     }
      //
      //  *> Close:          map->Close(&bi)
      //
      //
      //  Note: You can add any number of  outputs to a bitmap. Just keep
      //  calling map->OpenInput() with different outputs (Targa file AND
      //  Frame Buffer for instance). To write or close a specific output,
      //  use Write()  and Close().  To write  and close them all at once,
      //  use WriteAll() and CloseAll().
      //
      //  It is ok to use WriteAll() and CloseAll() if you have just one
      //  output defined.
      //
      
      BMMExport BMMRES         OpenOutput                  ( BitmapInfo *bi );                                        // Open output
      BMMExport BMMRES         Write                       ( BitmapInfo *bi, int frame = BMM_SINGLEFRAME );         // Write frame to file
      BMMExport BMMRES         WriteAll                    ( int frame = BMM_SINGLEFRAME );                         // Write all open outputs
      BMMExport int            Close                       ( BitmapInfo *bi, int flag = BMM_CLOSE_COMPLETE );         // Close an open output
      BMMExport int            CloseAll                    ( int flag = BMM_CLOSE_COMPLETE);                          // Close all open outputs

      //-- Window gravity

      #define   BMM_UL  1      //-- Upper Left
      #define   BMM_LL  2      //-- Lower Left
      #define   BMM_UR  3      //-- Upper Right
      #define   BMM_LR  4      //-- Upper Left
      #define   BMM_CN  5      //-- Center

      #define   BMM_RND 10     //-- Renderer (Save/Restore)
      #define   BMM_VPP 11     //-- Video Post Primary (Save/Restore)
      #define   BMM_VPS 12     //-- Video Post Secondary (Save/Restore)

      BMMExport int            Display                     ( TCHAR *title = NULL, 	int position = BMM_CN, 
      		BOOL autonomous = FALSE, BOOL savebutton = TRUE, CropCallback *crop=NULL );
      BMMExport int            UnDisplay                   ( );
      BMMExport HWND           GetWindow                   ( );
      BMMExport void           RefreshWindow               ( RECT *rect = NULL );
      BMMExport void           SetWindowTitle              ( TCHAR *title );
	  BMMExport void           SetCroppingValues		   ( float u, float v, float w, float h, BOOL placeImage);

      //-- Get a Different Frame  -------------------------------------------
      //
      //   For  multifrane bitmaps (FLI's, AVI's, DDR devices, etc.),  if you
      //   simply want to load  another frame replacing a previously "Load"ed
      //   image.
      //
      //   If used with single frame drivers or if the driver doesn't support
      //   this function,  it returns BMMRES_SINGLEFRAME. If the return value
      //   is BMMRES_SUCCESS,  a new frame  has  been  loaded  into the given 
      //   bitmap.
      //
      //   To define desired frame, use bi->SetCurrentFrame( frame );
      //
      
      BMMExport BMMRES         GoTo                        ( BitmapInfo *bi );

      //-- Handy built-in functions

      BMMExport int            Fill                        ( int r,int g,int b,int alpha);

	  // Set a callback so can get notified if storage changed
      BMMExport void 		  SetNotify( BitmapNotify *bmnot=NULL);
      BitmapNotify *		  GetNotify() { return bmNotify; }
		
	  BMMExport BOOL IsAutonomousVFB();

 	  // Generic expansion function
	  BMMExport int Execute(int cmd, ULONG arg1=0, ULONG arg2=0, ULONG arg3=0); 

	  DWORD GetModifyID() { return modifyID; }
	  void SetModifyID(DWORD m) { modifyID = m; }
	  BMMExport void IncrModifyID();

      // Print the bitmap (if supported by the host app)
      BMMExport void Print(bool silent = false);

	  BMMExport void ShowProgressLine(int y); // y<0 to hide
};

//-- Various Bitmap In-Memory Lists -------------------------------------------

struct BMMStorageList {
	BitmapStorage *ptr;
	BMMStorageList *next;
	};

struct BMMFilterList {
	BitmapFilter *ptr;
	BMMFilterList *next;
	} ;

struct BMMBitmapList {
	Bitmap *ptr;
	BMMBitmapList *next;
	};

typedef struct tag_BMMGammaSettings {
	BitmapManager *mgr;
	BitmapInfo    *bi;
	BOOL           out;
	} BMMGammaSettings;     

typedef struct tag_BMMVfbPalette {
	BYTE  r,g,b;
	} BMMVfbPalette;     

class BitmapFileInputDialog {
	public:
	virtual BOOL BrowseBitmapFilesInput(BitmapInfo* info, HWND hWnd, TCHAR* title, BOOL view) = 0;
	};

class BitmapFileOutputDialog {
	public:
	virtual BOOL BrowseBitmapFilesOutput(BitmapInfo* info, HWND hWnd, TCHAR* title) = 0;
	};

//-----------------------------------------------------------------------------
//-- Main Bitmap Manager Class
//

class BitmapManager {
   
   public:
   
      BMMVfbPalette            *pal;

      //-- Construction/Destruction
      
      BitmapManager               ( BMMInterface *i) { pal = NULL; }
      BitmapManager               ( BMMInterface *i,const TCHAR *name) { pal = NULL; }
      virtual  BMMExport    ~BitmapManager               ( );
      friend void       DoConstruct      ( BitmapManager *m, BMMInterface *i, const TCHAR *name);

      //-- These are for internal use only
      
      virtual int            DeleteAllMaps               ( )=0;
      virtual int            AddStorage                  ( BitmapStorage *s)=0;
      virtual int            AddFilter                   ( BitmapFilter *a)=0;
      virtual int            AddBitmap                   ( Bitmap *b)=0;
      virtual int            DelStorage                  ( BitmapStorage *s)=0;
      virtual int            DelFilter                   ( BitmapFilter *a)=0;
      virtual int            DelBitmap                   ( Bitmap *b)=0;
      virtual BitmapFilter  *FindFilter                  ( BitmapStorage *s,UINT type)=0;
      virtual BitmapStorage *FindStorage                 ( BitmapInfo *bi, int openMode)=0;
      virtual int            FnametoBitMapInfo           ( BitmapInfo *bi )=0;       
      virtual void           FixFileExt                  ( OPENFILENAME &ofn, const TCHAR *extension)=0;
      virtual void           MakeVfbPalette              ( )=0;

      BMM_IOList               ioList;
      virtual void           ListIO                      ( )=0;
      
      //---------------------------------------------------------------------
      //-- Public Interface -------------------------------------------------
      
      //-- Host Interface

      virtual HINSTANCE      AppInst                     ( )=0;
      virtual HWND           AppWnd                      ( )=0;
      virtual DllDir        *AppDllDir                   ( )=0;
      virtual TCHAR         *GetDir                      (int i)=0;
      virtual BOOL           AddMapDir                   (TCHAR *dir,int update)=0;
      virtual int            GetMapDirCount              ( )=0;
      virtual TCHAR         *GetMapDir                   (int i)=0;
      virtual Interface     *Max                         ()=0;
	  virtual Bitmap        *NewBitmap                   ()=0; // returns a new Bitmap 

	  // Set a replacement for the bitmap file dialog. NULL will set the default.
	  virtual void			SetFileInputDialog(BitmapFileInputDialog* dlg = NULL)=0;
	  virtual void			SetFileOutputDialog(BitmapFileOutputDialog* dlg = NULL)=0;

      //-- These won't stay here. Error handling will be dealt in a couple of 
      //   different ways. There will be a "Silent" flag that will be set by
      //   the client and tested here in order to know if an error dialog should
      //   go up. Normally, if the user is sitting in front of the computer
      //   this flag will be FALSE. When rendering in the background, or network
      //   rendering, etc., this flag will be TRUE. There should be some kind of
      //   "preferences" configuration for this behavior.
      //
      //   There also will be a method for logging errors. This method will check
      //   for a "loggin on/off" flag and either add the entry or ignore it. The
      //   bitmap manager and its devices will log everything that goes wrong.
      //   When silent mode is on and logging is also on, this is the method to
      //   check what went bad. Having each device logging its own error will
      //   enable a more accurate description of the problem (as opposed to "I/O
      //   error").
      //
      //   Gus
      //
      
      virtual int            Status                      ( int *sCount, int *aCount, int *bCount)=0;
      virtual int            Error                       ( const TCHAR *string)=0;

      //-- Error handling ---------------------------------------------------
      //
      //

      //-- Max Interface (means no logging)
      
      #define LG_NOLOG         0
      
      //-- User Interface
      
      #define LG_FATAL         ((DWORD)(1 << 0))
      #define LG_INFO          ((DWORD)(1 << 1))
      #define LG_DEBUG         ((DWORD)(1 << 2))
      #define LG_WARN          ((DWORD)(1 << 3))

      //-- User Interface 
      
      virtual BOOL           SilentMode                  ( )=0;
      virtual void           SysLog                      ( int type, char *format, ... )=0;

      //-- Max Interface (used internally)
      
      virtual BOOL           SetSilentMode               ( BOOL s )=0;
      virtual void           SetLogLevel                 ( DWORD level )=0;
      virtual DWORD          GetLogLevel                 ( )=0;

      //-- Creating a new bitmap from scracth -------------------------------
      //
      //   Make  sure the given  BitmapInfo class has the proper data for the
      //   creation of the bitmap.  If you used the BitmapManager function to
      //   define the bitmap (SelectBitmapOutput()), both filename and device
      //   driver have been defined for you. 
      //
      //   Make sure to set the type of bimap using bi.SetType(). This will 
      //   define the storage type as in (so far):
      //
      //   BMM_LINE_ART 
      //   BMM_PALETTED 
      //   BMM_GRAY_8
      //   BMM_GRAY_16
      //   BMM_TRUE_16  
      //   BMM_TRUE_32  
      //   BMM_TRUE_64  
      //
      //   Do NOT use BMM_TRUE_24 nor BMM_TRUE_48. These are read only types.
      //
      //   Example code is in src/app/vpexecut.cpp
      //
      //
      //   Once a bitmap has been created, use its own methods for adding
      //   outputs and writing it (i.e. map->OpenOutput(), map->Write() and
      //   map->Close()).
      //
      //   Gus
      //
      
      virtual BMMExport Bitmap        *Create                      ( BitmapInfo *bi   )=0;

      //-- Creating a new bitmap from an existing Windows DIB ---------------
      //
      //   To Convert a Bitmap to a Windows DIB check Bitmap::ToDib()
      //

      virtual BMMExport Bitmap        *Create                      ( PBITMAPINFO pbmi )=0;

      //-- Loads Bitmap -----------------------------------------------------
      //
      //   Loads a bitmap.
      //
      //   Like most other  bitmap  functions, you should define the image to
      //   to load (either setting the name/device directly in BitmapInfo bi,
      //   or having  SelectFileInput() do it for you).  Once bi has the name
      //   of the image you want to  load, call Load() to create a new Bitmap
      //   which contains the image. Additional options may be set by calling
      //   ImageInputOptions()  before calling Load().  That will as the user 
      //   for special details such as  positioning of smaller/larger images,
      //   etc. All this does is to set the proper fields in BitmapInfo. It's
      //   up to you to use those.
      //
      //   BitmapInfo defaults to frame "zero". For multifrane files, such as
      //   *.avi, *.ifl, *.flc, etc. you should  specify the frame number you
      //   want. Do it by using bi.SetCurrentFrame(f)  before calling Load().
      //   
      //   
      //   Note: If loading images from a device, make sure bi.Name() is
      //         empty (bi.SetName(_T(""));). This is automatic if you use
      //         SelectDeviceInput(). If you just create a BitmapInfo
      //         instance and set the device name by hand (bi.SetDevice()),
      //         this is also automatic as both name and device names are
      //         by default empty. This should only be a concern if you
      //         reuse a BitmapInfo class previously used for image files.
      //   
      //   
      //   One of the methods in BitmapInfo returns a  window handle to  send
      //   progress report messages. If you  want to  receive these messages,
      //   set the window handle  (  bi->SetUpdateWindow(hWnd)  ) and process
      //   BMM_PROGRESS messages (see above).
      //   
      //   Gus
      //
      
      virtual BMMExport Bitmap        *Load                       ( BitmapInfo *bi, BMMRES *status = NULL)=0;

      //-- Load Image into an existing Bitmap  ----------------

      virtual BMMRES         LoadInto                    ( BitmapInfo *bi, Bitmap **map, BOOL forceReload=FALSE )=0;
      
      //-- General User Interface -------------------------------------------
      
      virtual BMMRES         GetImageInfoDlg             ( HWND hWnd, BitmapInfo *bi, const TCHAR *filename = NULL )=0;
      virtual BMMRES         GetImageInfo                (            BitmapInfo *bi, const TCHAR *filename = NULL )=0;
      virtual BOOL           ImageInputOptions           ( BitmapInfo *bi, HWND hWnd )=0;
      virtual BOOL           SelectDeviceInput           ( BitmapInfo *bi, HWND hWnd )=0;
      virtual BOOL           SelectDeviceOutput          ( BitmapInfo *bi, HWND hWnd )=0;

      virtual BOOL           SelectFileOutput            ( BitmapInfo *bi, 
                                                             HWND hWnd, 
                                                             TCHAR *title = NULL)=0;

      virtual BOOL           SelectFileInput             ( BitmapInfo *bi, 
                                                             HWND hWnd, 
                                                             TCHAR *title = NULL)=0;
      
      virtual BOOL           SelectFileInputEx           ( BitmapInfo *bi, 
                                                             HWND hWnd, 
                                                             TCHAR *title  = NULL,
                                                             BOOL viewonly = FALSE)=0;
      
	  virtual void RefreshAllVFBs()=0;

	  virtual void DeleteAllAutonomousVFBMaps()=0;

	  // Generic expansion function
	  virtual int Execute(int cmd, ULONG arg1=0, ULONG arg2=0, ULONG arg3=0)=0; 

	  virtual void BeginSavingLoadErrorFiles()=0;  // --Begin accumulating a list of files that didn't load,
	  											   // and don't put up load errors in the meantime.
	  virtual NameTab &GetLoadErrorFileList()=0;  // -- List of names of files not found
	  virtual void EndSavingLoadErrorFiles()=0;  // --End accumulating a list of files that didn't load, free the list.
      virtual BMMExport bool CanImport(const TCHAR* filename)=0;

};

//-----------------------------------------------------------------------------
//-- Forward References for Bitmap Functions
//
//   Internal Use
//

extern int                       ValidBitmapType             ( int type );
extern BMMExport BitmapStorage  *BMMCreateStorage            ( BitmapManager *manager,UINT type );
extern BMMExport BitmapFilter   *BMMCreateFilter             ( BitmapManager *manager,UINT type );
extern BMMExport BitmapDither   *BMMCreateDither             ( BitmapManager *manager,UINT type );
extern BMMExport int             BMMCalcPalette              ( Bitmap *map,int colors,BMM_Color_48 *palette );
extern BMMExport BYTE            BMMClosestColor             ( BMM_Color_64 *color,BMM_Color_48 *palette,int colors );

extern BMMExport void            OpenBMM                     ( BMMInterface *i );
extern BMMExport void            CloseBMM                    ( );
extern           BOOL CALLBACK   BMMGammaDlgProc             (HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam);
extern           void            ExtractExtension            ( TCHAR *string, TCHAR *ext );

//-----------------------------------------------------------------------------
//-- Handy-dandy pixel buffer class
//

class PixelBuf {

   private:

      BMM_Color_64 *buf;
      int           width;

   public:

      inline                   PixelBuf ( int width) { buf = (BMM_Color_64 *)calloc(width,sizeof(BMM_Color_64)); this->width=width; };
      inline                  ~PixelBuf ( ) { if(buf) free(buf); };
      inline BMM_Color_64     *Ptr      ( ) { return buf; };

      int                      Fill     ( int start, int count, BMM_Color_64 color ) {
                                  int ix,jx=start+count;
                                  if (jx > width)
                                     return 0;
                                  for(ix=start; ix<jx; buf[ix++]=color);
                                  return 1;
                               };
};

//-- Public Utilities ---------------------------------------------------------

BMMExport int    BMMCreateNumberedFilename  ( const TCHAR *namein,int frame,TCHAR *nameout );
BMMExport int    BMMGetFullFilename         ( BitmapInfo *bi );
BMMExport BOOL      BMMIsFile                  ( const TCHAR *filename );
BMMExport void      BMMSplitFilename           ( const TCHAR *name,TCHAR *p,TCHAR *f,TCHAR *e );
BMMExport void      BMMAppendSlash             ( TCHAR *path );
BMMExport BOOL      BMMGetUniversalName        ( TCHAR *szUniv, const TCHAR *szDrive );
BMMExport LPTSTR BMMGetLastErrorText        ( LPTSTR lpszBuf, DWORD dwSize );

// Get a color packer.  When done, be sure to call its DeleteThis();
BMMExport ColorPacker *BMMNewColorPacker(
   int w,            // width of bitmap to be packed
   BMM_Color_48 *pal,   // palette to use
   int npal,         // number of entries in the palette
   BYTE* remap=NULL  // optional remap done at last stage.
   );


BMMExport Quantizer *BMMNewQuantizer();

//  Rearrange palette "pal" ( which has colors 0..ncols-1 occupied, 
//  in descending order of frequency),  into "newpal" so that the colors 10-245 are 
//  populated first, then 0-9, then 246-255.  Sets optional array "remap" to map the
//  old palette index values to the new ones    
BMMExport void FixPaletteForWindows(BMM_Color_48 *pal, BMM_Color_48 *newpal,int ncols, BYTE *remap=NULL);

//-- Cleanup ------------------------------------------------------------------

#undef bVirtual


#endif BITMAP_H_DEFINED

//-- EOF: bitmap.h ------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\bezfont.h ===
/**********************************************************************
 *<
	FILE: bezfont.h

	DESCRIPTION: Bezier Font Support methods

	CREATED BY: Tom Hudson

	HISTORY: Created 1 November 1995

 *> Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#ifndef __BEZFONT_H__

#define __BEZFONT_H__

#include "plugin.h"

// Forward references
class BezFontManager;

class BezFontMetrics {
    public:
	   	LONG   Height;
	    LONG   Ascent;
	    LONG   Descent;
	    LONG   InternalLeading;
	    LONG   ExternalLeading;
	    LONG   AveCharWidth;
	    LONG   MaxCharWidth;
	    LONG   Weight;
	    LONG   Overhang;
	    LONG   DigitizedAspectX;
	    LONG   DigitizedAspectY;
	    BCHAR  FirstChar;
	    BCHAR  LastChar;
	    BCHAR  DefaultChar;
	    BCHAR  BreakChar;
	    BYTE   Italic;
	    BYTE   Underlined;
	    BYTE   StruckOut;
	    BYTE   PitchAndFamily;
	    BYTE   CharSet;
	    DWORD  Flags;
	    UINT   SizeEM;
	    UINT   CellHeight;
	    UINT   AvgWidth;
		CoreExport BezFontMetrics() {}	// To Do; Fill in fields with reasonable values
		CoreExport BezFontMetrics(NEWTEXTMETRIC *from);
	};

// BezFontInfo type
#define BEZFONT_TRUETYPE	0
#define BEZFONT_OTHER		1

// BezFontInfo flags
// None currently defined

class BezFontInfo {
	public:
		TSTR name;
		TSTR style;
		int type;		// See above
		DWORD flags;	// See above
		BezFontMetrics metrics;
		BezFontInfo() {}
		BezFontInfo(TSTR n, TSTR s, int t, DWORD f, BezFontMetrics &m) { name=n; style=s; type=t; flags=f; metrics=m; }
		CoreExport BezFontInfo &operator=(BezFontInfo &from);
	};

// A class for Dlls to use for info that will be sent back to them at load time
class DllData {
	public:
		DllData() {}
	};

// This is a callback class which is used to process font enumerations
class BezFontEnumProc {
	public:
		virtual BOOL CALLBACK Entry(BezFontInfo &info, LPARAM userInfo)=0;
	};

// A special enumerator for the font manager
class BezFontMgrEnumProc {
	public:
		BezFontManager *mgr;
		CoreExport BOOL CALLBACK Entry(BezFontInfo &info, LPARAM userInfo, DllData *dllData);
		void SetMgr(BezFontManager *m) { mgr = m; }
	};

// A class for listing font input dlls
class BezFontDll {
	public:
		ClassDesc *dll;
		BezFontDll() { dll=NULL; }
		BezFontDll(ClassDesc *d) { dll = d; }
	};

typedef Tab<BezFontDll *> BezFontDllTab;

// A class for providing access to required Max internals
class FontMgrInterface {
     public:
		virtual HINSTANCE	AppInst() = 0;
		virtual HWND		AppWnd() = 0;
		virtual DllDir		*AppDllDir() = 0;
    	virtual int			GetFontDirCount() = 0;
		virtual TCHAR		*GetFontDir (int i) = 0;
	};

typedef int BEZFONTHANDLE;

// A class used for listing the fonts we currently have available
class AvailableFont {
	public:
		BezFontInfo info;
		DllData *dllData;
		int dllIndex;	// The index of the DLL which provides this font (in BezFontDllTab)
		AvailableFont() { dllData = NULL; }
		AvailableFont(BezFontInfo &i, int di, DllData *dd=NULL) { info=i; dllIndex=di; dllData=dd; }
		~AvailableFont() { if(dllData) delete dllData; }
	};

typedef Tab<AvailableFont *> AvailableFontTab;

// The basic bezier font class
class BezFont {
	public:
		CoreExport BezFont() { }
		CoreExport virtual void EnumerateFonts(BezFontMgrEnumProc &proc, LPARAM userInfo)=0;
		CoreExport virtual int OpenFont(TSTR name, DWORD flags, DllData *dllData)=0;
		CoreExport virtual void CloseFont()=0;
		CoreExport virtual BOOL BuildCharacter(UINT index, float height, BezierShape &shape, float &width, int fontShapeVersion=1)=0;
	};

// A class used to list the fonts currently open
class OpenBezFont {
	public:
		int index;			 	// The index in AvailableFont
		DWORD flags;			// The style flags
		BEZFONTHANDLE handle;	// The handle we know it by
		int count;				// The number of users
		BezFont *loader;		// The loader for the font
		OpenBezFont() {}
		OpenBezFont(int i, DWORD f, BEZFONTHANDLE h, BezFont *l) { index=i; flags=f; handle=h; count=1; loader=l; }
		~OpenBezFont();
	};

typedef Tab<OpenBezFont *> OpenBezFontTab;

// This is the interface into Bezier fonts within the MAX system.
// This includes TrueType fonts and any other fonts supported via
// plugins.

// OpenFont flags
// None currently defined

class BezFontManager {
	friend class BezFontMgrEnumProc;

	private:
		FontMgrInterface *iface;
		BOOL initialized;
		BezFontDllTab dllTab;
		AvailableFontTab available;
		OpenBezFontTab open;
		BezFontMgrEnumProc enumProc;			// What we use to get the available fonts
	public:
		CoreExport BezFontManager();
		CoreExport ~BezFontManager();
		CoreExport void SetInterface(FontMgrInterface *i) { iface = i; }
		CoreExport void Init();
		CoreExport void Uninit();
		CoreExport void Reinit();
		CoreExport void EnumerateFonts(BezFontEnumProc &proc, LPARAM userInfo);
		CoreExport BOOL FontExists(TSTR name);			// Returns TRUE if the font is available
		CoreExport BEZFONTHANDLE OpenFont(TSTR name, DWORD flags);
		CoreExport BOOL CloseFont(BEZFONTHANDLE handle);	// Returns TRUE if the font is still in use
		CoreExport BOOL BuildCharacter(BEZFONTHANDLE handle, UINT index, float height, BezierShape &shape, float &width, int fontShapeVersion=1);
		CoreExport FontMgrInterface *GetInterface() { return iface; }
		CoreExport BOOL GetFontInfo(TSTR name, BezFontInfo &info);
	};

extern CoreExport BezFontManager theBezFontManager;

#endif //__BEZFONT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\box2.h ===
/**********************************************************************
 *<
	FILE: box2.h

	DESCRIPTION:

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef _BOX2_H 

#define _BOX2_H 

#include "ipoint2.h"
#include "point2.h"
#include <windef.h>


class Box2: public RECT {
	public:
	DllExport Box2();
	DllExport Box2(const IPoint2 a, const IPoint2 b);
	DllExport int IsEmpty();
	DllExport void SetEmpty();
	DllExport void Rectify();   // makes top<bottom, left<right
	DllExport void Scale(float f);
	DllExport void Translate(IPoint2 t);

	IPoint2 GetCenter() { return IPoint2((left+right)/2, (top+bottom)/2); }
	int x() { return min(left,right); }
	int y() { return min(top,bottom); }
	int w() { return abs(right-left)+1; }
	int h() { return abs(bottom-top)+1; }
	
	void SetW(int w) { right = left + w -1; } 
	void SetH(int h) { bottom = top + h -1; } 
	void SetX(int x) { left = x; }
	void SetY(int y) { top = y; }
	void SetWH(int w, int h) { SetW(w); SetH(h); }
	void SetXY(int x, int y) { SetX(x); SetY(y); }

	DllExport Box2& operator=(const RECT& r);
	DllExport Box2& operator=(RECT& r);
	DllExport Box2& operator+=(const Box2& b);
	DllExport Box2& operator+=(const IPoint2& p);
	int operator==( const Box2& b ) const { 	return (left==b.left && right==b.right && top==b.top && bottom==b.bottom); }
	DllExport int Contains(const IPoint2& p) const;  // is point in this box?
	};

typedef Box2 Rect;


struct FBox2 {
	Point2 pmin;
	Point2 pmax;
	int IsEmpty() { return pmin.x>pmax.x?1:0; }
	void SetEmpty() { pmin = Point2(1E30,1E30); pmax = -pmin; }
	FBox2& operator=(const FBox2& r) { pmin = r.pmin; pmax = r.pmax; return *this; }
	DllExport FBox2& operator+=(const Point2& p);
	DllExport FBox2& operator+=(const FBox2& b);
	DllExport int Contains(const Point2& p) const;  // is point in this box?
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\buildver.h ===
#ifndef _BUILD_VER_

#define _BUILD_VER_

// Don't use! Edu version of MAX now keyed off serial number
// Define EDU_VERSION to build the educational version of MAX
//#define EDU_VERSION

// Define BETA_VERSION to use Beta lock
//#define BETA_VERSION

// Define STUDENT_VER to build the student version of MAX
// #define STUDENT_VER
#ifdef STUDENT_VER
#define WIN95_ONLY
#endif

//TURN ON SNAPPING FOR INTEGRATION TO ATHENA
#define _OSNAP TRUE

//TURN ON PRIMITIVE CREATION WITH 3D SNAPPING
#define _3D_CREATE

// Turn on sub material assignment : 1/19/98 - CCJ
#define _SUBMTLASSIGNMENT

// Define DESIGN_VER to build the design version of MAX
// #define DESIGN_VER

// Define to build a version with no NURBS
// #define NO_NURBS

// Define APL_DBCS for double-byte character set versions (i.e. Japanese, Chinese)
//#define APL_DBCS

// no longer used by MAX
#if !defined(EDU_VERSION) && !defined(STUDENT_VER) && !defined(DESIGN_VER) && !defined(BETA_VERSION)
#define ORDINARY_VER
#endif

// errors that will no longer occur
#if defined(EDU_VERSION) && defined(STUDENT_VER)
#error "Both EDU_VERSION and STUDENT_VER defined in buildver.h!"
#endif

#if defined(EDU_VERSION) && defined(BETA_VERSION)
#error "Both EDU_VERSION and BETA_VERSION defined in buildver.h!"
#endif

#endif // _BUILD_VER_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\captypes.h ===
/**********************************************************************
 *<
	FILE: captypes.h

	DESCRIPTION: Capping type defintions

	CREATED BY: Tom Hudson

	HISTORY: Created 12 October 1995

 *> Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#ifndef __CAPTYPES_H_

#define __CAPTYPES_H_

// Just in case...
class PolyShape;
class BezierShape;

// Capping types supported
#define CAPTYPE_MORPH 0		// AKA 3D Studio DOS capping
#define CAPTYPE_GRID 1		// Max's very own capping

// Capping information classes:
// These classes provide information on how a cap is put together, based on the following:
//
// For Mesh caps, you get a list of created triangular faces, where the vertex indices are
// either original vertices on the PolyShape, newly created vertices inside the shape, or
// newly created vertices on the edge of a shape.  New vertices are only created for GRID
// type capping.  Cap info is always stored in unflipped form -- That is, faces are oriented
// in a counterclockwise order as viewed from the shape's "front", or positive Z.
//
// New free vertices are listed in the MeshCapInfo's "newVerts" table, a simple Point3 table.
// The "newVert" member of the MeshCapVert class points to the entry in the newVerts table.
//
// New edge vertices are stored with the polygon and segment number where they reside, along
// with a position on that segment (0-1) where they reside.  This information allows the cap
// user to divide adjacent faces as needed.
//
// For Patch caps, you can only cap using MORPH type capping.  GRID capping is meant for Mesh
// caps, where distorting a non-subdivided cap would result in serious surface discontinuities.
// Patches are automatically subdivided, so GRID capping is unnecessary there.
//

// CapFace flags 
#define CF_ABLINE (1<<0)
#define CF_BCLINE (1<<1)
#define CF_CALINE (1<<2)

class CapFace {
	public:
		int va;	// Index of vertex a
		int vb;	// Index of vertex b
		int vc;	// Index of vertex c
		DWORD flags;
		CapFace() {}
		CapFace(int a, int b, int c, DWORD f) { va=a; vb=b; vc=c; flags=f; }
	};

// Mesh cap vertices:
// These can be original vertices from the PolyShape or new free vertices
// in the center of the PolyShape.

#define MCV_ORIGINAL	0
#define MCV_FREE		1

class MeshCapVert {
	public:
		int type;		// See above
		int poly;		// The polygon number
		int index;		// The index of the vertex
		int newVert;	// The index of the new vertex
		MeshCapVert() {}
		MeshCapVert(int t, int p, int i, int nv=0) { type=t; poly=p; index=i; newVert=nv; }
	};

typedef Tab<CapFace> CapFaceTab;
typedef Tab<MeshCapVert> MeshCapVertTab;
typedef Tab<Point3> Point3Tab;

// The information class for mesh capping (MORPH or GRID)

class MeshCapInfo {
	public:
		CapFaceTab faces;
		MeshCapVertTab verts;
		Point3Tab newVerts;
		MeshCapInfo &operator=(MeshCapInfo &from) { faces=from.faces; verts=from.verts; newVerts=from.newVerts; return *this; }
		CoreExport void Init(PolyShape *shape);
		CoreExport void FreeAll();
	};

// Support classes for MeshCapper

class PolyLine;

class MeshCapPoly {
	public:
		int numVerts;
		int *verts;	// List of verts in mesh corresponding to verts in the PolyLine (1 per vert)
		MeshCapPoly() { verts = NULL; }
		CoreExport void Init(PolyLine &line);
		CoreExport ~MeshCapPoly();
		CoreExport void SetVert(int index, int vertex);
	};

// This class is used to apply the MeshCapInfo data to a mesh -- It will modify the mesh as required to
// add the cap.  Simply fill in the vertices and faces bordering the cap, then call the CapMesh method.

class MeshCapper {
	public:
		int numPolys;
		MeshCapPoly *polys;
		CoreExport MeshCapper(PolyShape &shape);
		CoreExport ~MeshCapper();
		CoreExport MeshCapPoly &operator[](int index);
		CoreExport int CapMesh(Mesh &mesh, MeshCapInfo &capInfo, BOOL flip, DWORD smooth, Matrix3 *tm=NULL, int mtlID=-1);
	};

// Patch capping

class CapPatch {
	public:
		int type;		// PATCH_TRI or PATCH_QUAD
		int verts[4];
		int vecs[8];
		int interior[4];
		CapPatch() {}
		CapPatch(int va, int vab, int vba, int vb, int vbc, int vcb, int vc, int vca, int vac, int i1, int i2, int i3) {
			type=PATCH_TRI; verts[0]=va; verts[1]=vb; verts[2]=vc; vecs[0]=vab; vecs[1]=vba; vecs[2]=vbc, vecs[3]=vcb;
			vecs[4]=vca; vecs[5]=vac; interior[0]=i1; interior[1]=i2; interior[2]=i3; }
		CapPatch(int va, int vab, int vba, int vb, int vbc, int vcb, int vc, int vcd, int vdc, int vd, int vda, int vad, int i1, int i2, int i3, int i4) {
			type=PATCH_QUAD; verts[0]=va; verts[1]=vb; verts[2]=vc; verts[3]=vd; vecs[0]=vab; vecs[1]=vba; vecs[2]=vbc, vecs[3]=vcb;
			vecs[4]=vcd; vecs[5]=vdc; vecs[6]=vda, vecs[7]=vad;  interior[0]=i1; interior[1]=i2; interior[2]=i3; interior[3]=i4; }
	};

// Patch cap vertices:
// These can be original vertices from the BezierShape or new free vertices
// in the center of the BezierShape.

#define PCVERT_ORIGINAL	0
#define PCVERT_FREE		1

class PatchCapVert {
	public:
		int type;
		int poly;		// The polygon number (ORIGINAL or EDGE)
		int index;		// The index of the vertex (ORIGINAL) or the segment for the EDGE vertex
		PatchCapVert() {}
		PatchCapVert(int t, int p, int i) { type=t; poly=p; index=i; }
	};

// Patch cap vectors:
// When a patch cap is generated, new interior vectors will be generated within the patch, and patch
// edges within the cap will have new vectors.  Patch edges along the edges of the originating bezier
// shape will use existing vectors.  This class provides information on which is which.

#define PCVEC_ORIGINAL	0
#define PCVEC_NEW		1

class PatchCapVec {
	public:
		int type;		// See above
		int poly;		// Polygon number for ORIGINAL
		int index;		// Index for ORIGINAL or into newVecs table (see below)
		PatchCapVec() {}
		PatchCapVec(int t, int p, int i) { type=t; poly=p; index=i; }
	};

typedef Tab<CapPatch> CapPatchTab;
typedef Tab<PatchCapVert> PatchCapVertTab;
typedef Tab<PatchCapVec> PatchCapVecTab;

// The information class for patch capping

class PatchCapInfo {
	public:
		CapPatchTab patches;
		PatchCapVertTab verts;
		PatchCapVecTab vecs;
		Point3Tab newVerts;
		Point3Tab newVecs;
		PatchCapInfo &operator=(PatchCapInfo &from) { patches=from.patches; verts=from.verts; vecs=from.vecs; newVerts=from.newVerts; newVecs=from.newVecs; return *this; }
		CoreExport void Init(BezierShape *shape);
		CoreExport void FreeAll();
	};

// Support classes for MeshCapper

class Spline3D;

class PatchCapPoly {
	public:
		int numVerts;
		int numVecs;
		int *verts;	// List of verts in patch mesh corresponding to verts in the spline (1 per vert)
		int *vecs;	// List of vecs in patch mesh corresponding to vecs in the spline (1 per vector)
		PatchCapPoly() { verts = vecs = NULL; }
		CoreExport void Init(Spline3D &spline);
		CoreExport ~PatchCapPoly();
		CoreExport void SetVert(int index, int vertex);
		CoreExport void SetVec(int index, int vector);
	};

// This class is used to apply the PatchCapInfo data to a PatchMesh -- It will modify the mesh as required to
// add the cap.  Simply fill in the vertices, vectors and patches bordering the cap, then call the CapPatch method.

class PatchCapper {
	public:
		int numPolys;
		PatchCapPoly *polys;
		CoreExport PatchCapper(BezierShape &shape);
		CoreExport ~PatchCapper();
		CoreExport PatchCapPoly &operator[](int index);
		CoreExport int CapPatchMesh(PatchMesh &mesh, PatchCapInfo &capInfo, BOOL flip, DWORD smooth, Matrix3 *tm=NULL, int mtlID=-1);
	};


#endif // __CAPTYPES_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\client.h ===
//-----------------------------------------------------------------------------
// -------------------
// File ....: Client.h
// -------------------
// Author...: Gus J Grubba
// Date ....: November 1995
// O.S. ....: Windows NT 3.51
//
// History .: Nov, 18 1995 - Created
//
// 3D Studio Max Network Rendering 
// 
// Client
//
//-----------------------------------------------------------------------------

#ifndef _CLIENTINCLUDE_
#define _CLIENTINCLUDE_

#ifndef  NETCEXPORT
#define  NETCEXPORT __declspec( dllimport )
#endif

//-----------------------------------------------------------------------------
//--  Interface Class ---------------------------------------------------------
//-----------------------------------------------------------------------------
     
class ClientInterface {

	public:

		virtual HINSTANCE	HostInst       		() = 0;
		virtual HWND		HostWnd          	() = 0;
		virtual TCHAR     	*GetDir           	(int i) = 0;
		virtual TCHAR     	*GetAppDir        	() = 0;
		virtual TSTR      	GetMaxFileName   	() = 0;
		virtual BOOL    	SaveMaxFile      	(TCHAR *name, TCHAR *archivename, bool archive = false) = 0;

};

//-----------------------------------------------------------------------------
//--  Base Class Definition ---------------------------------------------------
//-----------------------------------------------------------------------------
// #> Client
//
     
class Client {

	private:   
        
		TCPcomm          *tcp;
		ConnectionInfo   ci;

		#define          DEFNUMMANAGERS  4

		char             manager[DEFNUMMANAGERS][MAX_PATH];
		WORD             mgrport;

		Tab<ServerList>  Servers;
		ServerReg        sReg;
		ClientInterface  *iface;
		Interface		 *max;

        int                curServer;

        int                numSel;
        int               *selBuf;

        int                start,end,step;

		int				progressNFrames;
		BOOL			alertFailure,alertProgress,alertCompletion;
		BOOL			alertEnabled;
        
        //-- Flags defined in Common.h (NewJob flags)

        DWORD              flags;
        
        //-- Windows Specific -------------------------------------------------
        
        HWND               hWnd;
        HBITMAP            hBmpBulbOn,hBmpBulbBusy,hBmpBulbOff,hBmpBulbError;
        HBITMAP            hBmpBulbOnSel,hBmpBulbBusySel,hBmpBulbOffSel,hBmpBulbErrorSel;

        //-- Miscelaneous Functions -------------------------------------------

        void               UpdateManagerList         ( HWND hWnd );
        BOOL               GetMaxFile                ( HWND hWnd, TCHAR *name );

     public:

		//-- Job Info


		NewJob	*TheJob;


		//-- Constructors/Destructors -----------------------------------------

		NETCEXPORT         Client           ( ClientInterface *i, Interface *max );
		NETCEXPORT        ~Client           ( );
		void               Close            ( );
     
        //-- Public Interface -------------------------------------------------
        //

		NETCEXPORT BOOL	JobAssignment		( HWND hWnd, NewJob *job);
        NETCEXPORT BOOL	QueueManagement		( HWND hWnd );
        NETCEXPORT BOOL	JobMonitor			( HWND hWnd );

        //-- Dialog Functions -------------------------------------------------
        //

        BOOL			JobDlg           	( HWND,UINT,WPARAM,LPARAM );
        BOOL			PropDlg          	( HWND,UINT,WPARAM,LPARAM );
        BOOL			AlertDlg          	( HWND,UINT,WPARAM,LPARAM );
        BOOL			QueueDlg         	( HWND,UINT,WPARAM,LPARAM );
        BOOL			OutputExists		( HWND,UINT,WPARAM,LPARAM );
        
        BOOL			SubmitJob        	( HWND hWnd );
        void			LoadServerList   	( HWND hWnd );
        void			ResetServerList  	( HWND hWnd );
        void			HandleButtonState	( HWND hWnd );
        void			ShowServerProp   	( HWND hWnd );
        void			FixJobName       	( HWND hWnd );
        BOOL			CanConnect         	( HWND );
        void			ConnectManager     	( HWND );

        //-- Miscelaneous -----------------------------------------------------
        //

		Interface*		Max					( ) { return max; }
        void			ReadCfg				( );
        void			WriteCfg			( );
        
        BOOL			IsFile				( const TCHAR *filename );
        void			GetIniFile			( TCHAR *name );
        
};

//-----------------------------------------------------------------------------
//-- Interface

NETCEXPORT void *ClientCreate  ( ClientInterface *i, Interface *m );
NETCEXPORT void  ClientDestroy ( Client *v);

#endif

//-- EOF: Client.h ------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\box3.h ===
/**********************************************************************
 *<
	FILE: box3.h

	DESCRIPTION: 3D Box class

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#ifndef _BOX3_H 

#define _BOX3_H 

#include "point3.h"
#include "matrix3.h"

class Box3 {
	public:
		Point3 pmin,pmax;
		DllExport Box3();
		Box3(const Point3& p, const Point3& q) { pmin = p; pmax = q;}
		DllExport void Init();

		DllExport void MakeCube(const Point3& p, float side);

		// Access
		Point3 Min() const { return pmin; }
		Point3 Max() const { return pmax; }
		Point3 Center() const { return(pmin+pmax)/(float)2.0; }
		Point3 Width() const { return(pmax-pmin); }

		/* operator[] returns ith corner point: (i == (0..7) )
			Mapping:
			        X   Y   Z
			[0] : (min,min,min)
			[1] : (max,min,min)
			[2] : (min,max,min)
			[3] : (max,max,min)
			[4] : (min,min,max)
			[5] : (max,min,max)
			[6] : (min,max,max)
			[7] : (max,max,max)
			*/
		DllExport Point3 operator[](int i) const;	  

		// Modifiers
		DllExport Box3& operator+=(const Point3& p);	// expand this box to include Point3
		DllExport Box3& operator+=(const Box3& b);   // expand this box to include  Box3

		DllExport void Scale(float s); // scale box about center
		DllExport void Translate(const Point3 &p); // translate box
		DllExport void EnlargeBy(float s); // enlarge by this amount on all sides

		// include an array of points, optionally transformed by tm
		DllExport void IncludePoints(Point3 *pts, int numpoints, Matrix3 *tm=NULL); 

		// Returns a box that bounds the 8 transformed corners of the input box.
		DllExport Box3 operator*(const Matrix3& tm) const;

		// Tests
		DllExport int IsEmpty() const;   // is this box empty?
		DllExport int Contains(const Point3& p) const;  // is point in this box?
		DllExport int Contains(const Box3& b) const;  // is box b totally in this box?
		DllExport int Intersects(const Box3& b) const;  // does  box b intersect this box at all?
		
		

	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\cmdmode.h ===
/**********************************************************************
 *<
	FILE: cmdmode.h

	DESCRIPTION: Command mode class definition

	CREATED BY:	Rolf Berteig

	HISTORY: Created 13 January 1995

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __CMDMODE__
#define __CMDMODE__

// This file can be included in plug-in modules so
// it shouldn't reference/include private classes or functions.

class MouseCallBack;
class ChangeForegroundCallback;

class CommandMode {
	public:
		virtual int Class()=0;
		virtual int SuperClass() { return 0; }
		virtual int ID()=0;
		virtual MouseCallBack *MouseProc(int *numPoints)=0;
		virtual ChangeForegroundCallback *ChangeFGProc()=0;
		virtual BOOL ChangeFG( CommandMode *oldMode )=0;
		virtual void EnterMode()=0;
		virtual void ExitMode()=0;		
	};

// This is just a collection of modes that make up the xform modes.
// Plug-ins can specify these for thier sub-object types.
class XFormModes {
	public:
		CommandMode *move;
		CommandMode *rotate;
		CommandMode *scale;
		CommandMode *uscale;
		CommandMode *squash;
		CommandMode *select;
		XFormModes( 
			CommandMode *move,
			CommandMode *rotate,
			CommandMode *scale,
			CommandMode *uscale,
			CommandMode *squash,
			CommandMode *select )
			{
			this->move   = move;
			this->rotate = rotate;
			this->scale  = scale;
			this->uscale = uscale;
			this->squash = squash;
			this->select = select;
			}
		XFormModes() { move = rotate = scale = uscale = squash = select = NULL; } 
	};


// These can be returned from ChangeFGProc() instead of an actual FG proc
// to use predefined FG sets.
#define CHANGE_FG_SELECTED		((ChangeForegroundCallback *)1)
#define CHANGE_FG_ANIMATED		((ChangeForegroundCallback *)2)

// command super classes:
#define TRANSFORM_CMD_SUPER 	1

// command classes
#define VIEWPORT_COMMAND		1
#define MOVE_COMMAND			2
#define ROTATE_COMMAND			3
#define SCALE_COMMAND			4
#define USCALE_COMMAND			5
#define SQUASH_COMMAND			6
#define SELECT_COMMAND			7
#define HIERARCHY_COMMAND		8
#define CREATE_COMMAND			9
#define MODIFY_COMMAND			10
#define MOTION_COMMAND			11
#define ANIMATION_COMMAND		12
#define CAMERA_COMMAND			13
#define NULL_COMMAND			14
#define DISPLAY_COMMAND			15
#define SPOTLIGHT_COMMAND		16
#define PICK_COMMAND			17


// command IDs
#define CID_USER				0x0000ffff

// XFORM_COMMAND
#define CID_OBJMOVE				1
#define CID_OBJROTATE			2
#define CID_OBJSCALE			3
#define CID_OBJUSCALE			4
#define CID_OBJSQUASH			5
#define CID_OBJSELECT			6

#define CID_SUBOBJMOVE			7
#define CID_SUBOBJROTATE		8
#define CID_SUBOBJSCALE			9
#define CID_SUBOBJUSCALE		10
#define CID_SUBOBJSQUASH		11
#define CID_SUBOBJSELECT		12

// display branch command modes
#define CID_UNFREEZE			13
#define CID_UNHIDE				14


// HEIRARCHY_COMMAND
#define CID_LINK				100
#define CID_BINDWSM				110		// I guess this is a heirarchy command... sort of

// VIEWPORT_COMMAND
#define CID_ZOOMVIEW			200
#define CID_ZOOMREGION			201
#define CID_PANVIEW				202
#define CID_ROTATEVIEW			203
#define CID_ZOOMALL				204
#define CID_RNDREGION			205

// CAMERA COMMANDS
#define CID_CAMFOV				210
#define CID_CAMDOLLY			211
#define CID_CAMPERSP			212
#define CID_CAMTRUCK			213
#define CID_CAMROTATE			214
#define CID_CAMROLL				215

//ANIMATION_COMMAND
#define CID_PLAYANIMATION		300

//CREATE_COMMAND		
#define CID_SIMPLECREATE		400

//MODIFIY_COMMAND
#define CID_MODIFYPARAM			500

//MOTION_COMMAND	

#define CID_NULL				600

// Pick modes
#define CID_STDPICK				710
#define CID_PICKAXISOBJECT		700

// ATTACH To GROUP COMMAND
#define CID_GRP_ATTACH			800



#endif // __CMDMODE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\channels.h ===
/**********************************************************************
 *<
	FILE: channel.h

	DESCRIPTION:

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/



#ifndef __CHANNEL__H
#define __CHANNEL__H


// Channels within the object.
#define NUM_OBJ_CHANS 10

// Indices for object channels
#define TOPO_CHAN_NUM 0
#define GEOM_CHAN_NUM 1
#define TEXMAP_CHAN_NUM 2
#define MTL_CHAN_NUM 3
#define SELECT_CHAN_NUM 4
#define SUBSEL_TYPE_CHAN_NUM 5 
#define DISP_ATTRIB_CHAN_NUM 6 
#define VERT_COLOR_CHAN_NUM 7
#define GFX_DATA_CHAN_NUM 8
#define DISP_APPROX_CHAN_NUM 9

// Bit flags for object channels
#define TOPO_CHANNEL    	(1<<0) // topology (faces, polygons etc)
#define GEOM_CHANNEL    	(1<<1) // vertices
#define TEXMAP_CHANNEL  	(1<<2) // texture vertices and mapping
#define MTL_CHANNEL     	(1<<3) // material on per face basis
#define SELECT_CHANNEL  	(1<<4) // selection bits
#define SUBSEL_TYPE_CHANNEL (1<<5) // vertex/face/edge
#define DISP_ATTRIB_CHANNEL (1<<6) // display attributes
#define VERTCOLOR_CHANNEL   (1<<7) // color per vertex
#define GFX_DATA_CHANNEL	(1<<8) // stripping, edge list, etc.
#define DISP_APPROX_CHANNEL	(1<<9) // displacement approximation

#define TM_CHANNEL		(1<<10)  // Object transform (may be modified by modifiers)
#define GLOBMTL_CHANNEL (1<<31)  // material applied to object as whole

#define OBJ_CHANNELS  (TOPO_CHANNEL|GEOM_CHANNEL|SELECT_CHANNEL|TEXMAP_CHANNEL|MTL_CHANNEL|SUBSEL_TYPE_CHANNEL|DISP_ATTRIB_CHANNEL|VERTCOLOR_CHANNEL|GFX_DATA_CHANNEL|DISP_APPROX_CHANNEL)
#define ALL_CHANNELS  (OBJ_CHANNELS|TM_CHANNEL|GLOBMTL_CHANNEL)


#endif // __CHANNEL__H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\contextids.h ===
// 3DS MAX context-sensitive help items
// Help Contents (help menu IDs are in the menu section)

#ifndef _CONTEXTIDS_H_
#define _CONTEXTIDS_H_

#define F1Focus(cmd,data)	getHelpSys().setHelpFocus(cmd,data)
#define F1Help()			getHelpSys().doHelpFocus()
#define Help(cmd,data)		getHelpSys().help(cmd, data)
#define GetClickHelp()		getHelpSys().getClickHelp()

#define idh_contents				1000	// 3DS MAX Online Help (contents page)

// Titlebar items
#define idh_titlebar				2000	// Titlebar

//Menubar items
#define idh_menubar				3000	// Menubar

// File menu items
#define idh_file_menu				3100	// File menu
#define idh_file_new				3110	// New
#define idh_file_reset				3120	// Reset
#define idh_file_open				3130	// Open
#define idh_file_merge				3135	// Merge
#define idh_file_replace			3137	// Replace
#define idh_file_insert_tracks		3138	// Insert Tracks
#define idh_file_save				3140	// Save
#define idh_file_save_as			3150	// Save As
#define idh_file_save_selected			3160	// Save Selected
#define idh_file_import				3180	// Import
#define idh_file_export				3190	// Export
#define idh_file_archive			3200	// Archive
#define idh_file_summary_info			3210	// Summary Info
#define idh_file_view_file			3230	// View File
#define idh_file_configure_paths	3245	// Configure Paths
#define idh_file_preferences			3250	// Preferences
#define idh_file_properties			3255	// Properties
#define idh_file_exit				3260	// Exit
#define idh_file_history			3270	// History

// Edit menu items
#define idh_edit_menu				3300	// Edit menu
#define idh_edit_undo_redo			3310	// Undo/Redo
#define idh_edit_hold				3320	// Hold
#define idh_edit_fetch				3330	// Fetch
#define idh_edit_delete				3340	// Delete
#define idh_edit_clone				3350	// Clone
#define idh_edit_select_all			3360	// Select All
#define idh_edit_select_none		3370	// Select None
#define idh_edit_select_invert		3380	// Select Invert
#define idh_edit_select_by			3390	// Select By
#define idh_edit_select_by_color	3392
#define idh_edit_select_by_name		3394
#define idh_edit_region				3400	// Region
#define idh_edit_select_region_window	3402
#define idh_edit_select_region_crossing	3404
#define idh_edit_remove_named_selections	3410	// Remove Named Selections
#define idh_edit_edit_named_selections	3412
#define idh_edit_transform_type_in		3420	// Transform Type-in
#define idh_edit_mirror				3430	// Mirror
#define idh_edit_array				3435	// Mirror
#define idh_edit_snapshot			3437	// Mirror
#define idh_edit_align				3440	// Align
#define idh_edit_align_normals			3450	// Align Normals
#define idh_edit_place_highlight	3455
#define idh_edit_track_view			3459
#define idh_edit_schematic_view		3460
#define idh_edit_material_editor	3465
#define idh_edit_properties			3470	// Properties
#define idh_spacing_tool			3471

// Tools Menu
#define	idh_tools_menu				3475	// Tools menu
#define idh_tools_display_floater	3477	// display floater
#define idh_tools_selection_floater	3479	// selection floater
#define idh_tools_material_map_browser	3480	// mtl/map browser

// MAXScript menu (added JBW 11/11/98 & 12/15/98)
#define idh_maxscript_listener		3481	// open listener
#define idh_maxscript_open			3482	// open script editor
#define idh_maxscript_new			3483	// new script
#define idh_maxscript_run			3484	// run script file
#define idh_maxscript_macrorec		3485	// toggle macrorecorder enable

// Grouping menu items
#define idh_grouping_menu			3500	// Grouping menu
#define idh_grouping_group			3510	// Group
#define idh_grouping_open			3520	// Open
#define idh_grouping_close			3530	// Close
#define idh_grouping_ungroup			3540	// Ungroup
#define idh_grouping_explode			3550	// Explode
#define idh_grouping_detach			3560	// Detach
#define idh_grouping_attach			3570	// Attach

// Views menu items
#define idh_views_menu				3600	// Views menu
#define idh_views_undo_redo			3610	// Undo/Redo
#define idh_views_save_active		3620
#define idh_views_restore_active	3621
#define idh_views_units_setup		3625
#define idh_views_grid_and_snap_settings	3630	// Grid and Snap Settings
#define idh_views_grids				3640	// Grids
#define idh_views_background_image		3650	// Background Image
#define idh_views_update_background_image	3652
#define idh_views_reset_background_transform	3654
#define idh_views_show_axis_icon		3660	// Show Axis Icon
#define idh_views_show_ghosting			3662
#define idh_views_show_key_times		3664
#define idh_views_shade_selected		3670
#define idh_views_show_dependencies		3680
#define idh_views_match_camera_to_view	3682
#define idh_views_redraw_all_views		3690	// Redraw All Views
#define idh_views_deactivate_all_maps	3695	// Deactivate all maps in views
#define idh_views_update_during_spinner_drag	3697
#define idh_views_expert_mode			3698
#ifdef DESIGN_VER
#define idh_views_design_mode			3699
#define idh_views_standard_mode			3701
#endif
#define idh_views_viewport_configuration	3710	// Viewport Configuration

// Rendering menu items
#define idh_rendering_menu			3800	// Rendering menu
#define idh_rendering_render			3810	// Render
#define idh_rendering_video_post		3820	// Video Post
#define idh_rendering_environment		3840	// Environment
#define idh_rendering_make_preview		3870	// Make Preview
#define idh_rendering_view_preview		3880	// View Preview
#define idh_rendering_rename_preview 	3890	// Rename Preview
#define idh_rendering_show_last_render	3892

#define idh_track_view_menu						3900	// Trackview menu
#define idh_track_view_open_track_view			3902
#define idh_track_view_new_track_view			3904
#define idh_track_view_delete_track_view		3906
#define idh_track_view_stored_track_views_list	3908

// Schematic view menu items...
#define idh_schematic_view_open_schematic_view			3910
#define idh_schematic_view_new_schematic_view			3911
#define idh_schematic_view_delete_schematic_view		3912
#define idh_schematic_view_stored_schematic_views_list	3913

// Help menu items
#define idh_help_menu				4300	// Help menu
#define idh_help_contents			4310	// Help contents
#define idh_help_topics				4320	// topics
#define idh_help_plugin_help		4330	// plug-in help
#define idh_help_about				4340	// About 3D Studio MAX
#define idh_help_learning			4342
#define idh_help_connect_to_support_and_information	4344
#define idh_help_maxscript			4345

// Toolbar items
#define idh_toolbar				5000	// Toolbar
#define idh_tb_undo_redo			5010	// Undo/Redo
#define idh_tb_undo					5011
#define idh_tb_redo					5012
#define idh_tb_link_unlink			5020	// Link/Unlink
#define idh_tb_link					5021
#define idh_tb_unlink				5022
#define idh_tb_bind_to_space_warp		5030	// Bind to Space Warp
#define idh_tb_selection			5040	// Selection
#define idh_tb_selection_region		5041
#define idh_tb_sel_filter			5042
#define idh_tb_hit_by_name			5050	// Hit-by-name
#define idh_tb_transformations			5060	// Transformations
#define idh_tb_move					5061
#define idh_tb_rotate				5062
#define idh_tb_scale				5063
#define idh_tb_coord_sys			5064
#define idh_tb_pivot				5070	// Pivot button
#define idh_tb_x					5071
#define idh_tb_y					5072
#define idh_tb_z					5073
#define idh_tb_plane				5074
#define idh_tb_constraints			5075	// axis constaint buttons
#define idh_tb_inverse_kinematics_buttons	5080	// Inverse Kinematics Buttons
#define idh_tb_mirror				5085
#define idh_tb_array_button			5090	// Array Button
#define idh_tb_spacing_tool			5092    // Spacing tool
#define idh_tb_align_and_align_normals		5100	// Align and Align Normals
#define idh_tb_track_view_button		5110	// Track View Button
#define idh_tb_schematic_view_button	5111	// Schematic View Button
#define idh_tb_material_editor_button		5115	// Material Editor
#define idh_tb_rendering_controls		5120	// Rendering Controls
#define idh_tb_render					5121
#define idh_tb_render_quick				5122
#define idh_tb_render_last				5123
#define idh_tb_render_region			5124
#define idh_tb_named_selection_sets		5130	// Named Selection Sets

// the following item was added by Vera (we need this button in the toolbar so a  
// user can click on UI items that are not selectable or cannot receive focus)

#define idh_tb_help				5131	// Help button

// track view items
#define idh_track_view				5500	// Track View
#define idh_tv_layout				5510	// Track View Layout
#define idh_tv_hierarchy_list			5520	// Hierarchy list
#define idh_tv_edit_window			5530	// Track View Edit window
#define idh_tv_tool_bar				5540	// Track View Tool bar
#define idh_tv_navigation_icons			5550	// Track View Navigation icons (are there several?, if so, we need one ID per icon)

#define idh_view_ports				5600	// View ports
#define idh_vp_orthographic			5610	// Orthographic Views
#define idh_vp_camera				5620	// Camera Views
#define idh_vp_user				5630	// User Views
#define idh_vp_grid				5640	// Grid Views
#define idh_vp_spotlight			5650	// Spotlight Views

// Status line and prompt area items
#define idh_status_panel			5700
#define idh_sp_time_slider			5710	// Time slider
#define idh_sp_prompt_line			5720	// Prompt line
#define idh_sp_status_line			5730	// Status line
#define idh_sp_selection_lock		5735
#define idh_sp_window_crossing		5740
#define idh_sp_degrade_override		5745
#define idh_sp_snap_mode			5750
#define idh_sp_snap_toggle			5755
#define idh_sp_angle_snap			5760
#define idh_sp_percent_snap			5765
#define idh_sp_spinner_snap			5770
#define idh_sp_object_snap			5780	//object snapping

// time panel
#define idh_time_panel				5800
#define idh_tp_animate				5810
#define idh_tp_goto_start			5820
#define idh_tp_previous				5830
#define idh_tp_play					5840
#define idh_tp_next					5850
#define idh_tp_goto_end				5860
#define idh_tp_key_mode				5870
#define idh_tp_cur_time				5880
#define idh_tp_time_config			5890

// View control panel (lower right)
#define idh_view_control			8200
#define idh_vc_zoom					8201
#define idh_vc_zoom_all				8202
#define idh_vc_zoom_extents			8203
#define idh_vc_zoom_ext_sel			8204
#define idh_vc_zoom_ext_all			8205
#define idh_vc_zoom_ext_all_sel		8206
#define idh_vc_zoom_region			8207
#define idh_vc_field_of_view		8208
#define idh_vc_pan					8209
#define idh_vc_arc_rotate			8210
#define idh_vc_arc_rotate_sel		8211
#define idh_vc_min_max_toggle		8212
// camera specific
#define idh_vc_dolly				8213
#define idh_vc_perspective			8214
#define idh_vc_roll					8215
#define idh_vc_truck				8216
#define idh_vc_orbit				8217
#define idh_vc_pan_cam				8218
// spotlight specific
#define idh_vc_hotspot				8219
#define idh_vc_falloff				8220

// Command panel items
#define idh_command_panel			6000	// Command panel

// Create items
#define idh_cp_create				6100	// Create
#define idh_create_entity_names			6110	// Entity Names
#define idh_create_geometry			6120	// Geometry
#define idh_create_space_warps			6130	// Space Warps
#define idh_create_object_colors		6140	// Object Colors
#define idh_create_materials			6150	// Materials
#define idh_create_nonrendering_objects		6160	// Non-rendering Objects
#define idh_create_lights			6170	// Lights
#define idh_create_cameras			6180	// Cameras
#define idh_create_helper_objects		6190	// Helper Objects
#define idh_create_systems			6200	// Systems
#define idh_create_objects_instances_references	6210	// Objects, Instances, and References


// Modify items
#define idh_cp_modify				6300	// Modify
#define idh_modify_panel_layout			6310	// Layout of the Modify Command Panel
#define idh_modify_modifier_stack		6320	// Modifier Stack
#define idh_modify_miscellaneous		6330	// Miscellaneous Additions
#define idh_modify_subobject_selection		6340	// Sub-Object Selection
#define idh_modify_object_modifiers_editors	6350	// Object Modifiers (Editors)
#define idh_modify_object_modifiers_other	6360	// Object Modifiers (Other)
#define idh_modify_lights			6370	// Lights
#define idh_modify_cameras			6380	// Cameras
#define idh_modify_mapping			6390	// Mapping

// Surface items
#define idh_cp_surface				6400	// Surface
#define idh_surface_surfaces			6410	// Surfaces
#define idh_surface_materials			6420	// Materials

// Hierarchy items
#define idh_cp_hierarchy			6500	// Hierarchy
#define idh_hierarchy_adjust_pivot		6510	// Adjust Pivot
#define idh_hierarchy_transform			6520	// Transform
#define idh_hierarchy_link_info			6530	// Link Info
#define idh_hierarchy_ik			6540	// IK
#define idh_hierarchy_links			6550	// Links

// Motion items
#define idh_cp_motion				6600	// Motion
#define idh_motion_assign_transform_controller	6610	// Assign Transform Controller
#define idh_motion_path				6620	// Path
#define idh_motion_key_info			6630	// Key Info

// Display items
#define idh_cp_display				6700	// Display
#define idh_display_color			6710	// Display Color
#define idh_display_category			6720	// Category Displays
#define idh_display_individual			6730	// Individual Displays
#define idh_display_freeze			6740	// Freeze Displays
#define idh_display_optimizations		6750	// Display Optimizations
#define idh_display_links			6760	// Display Links



// Dialog Box: Viewport Configuration 
#define idh_dialog_viewport_configuration	7000	// main box
// render page
#define idh_vpconfig_render_page	7001	// render page
#define idh_vpconfig_rendering_level	7002	// rendering level (all)
#define idh_vpconfig_apply_to		7003	// apply to (for rendering level)
#define idh_vpconfig_rendering_options	7004	// rendering options
#define idh_vpconfig_fast_view		7005
#define idh_vpconfig_persp_user_view	7006
// layout page
#define idh_vpconfig_layout_page	7010
#define idh_vpconfig_layout_types	7011	// all layout buttons at top
#define idh_vpconfig_assign_view	7012	// view assignment region
#define idh_vpconfig_current_layout 7013
// safeframe page
#define idh_vpconfig_safeframe_page	7020
#define idh_vpconfig_safeframe_setup	7021	// setup portion
#define idh_vpconfig_safeframe_app	7022		// application portion
// degradation page
#define idh_vpconfig_degrade_page	7030	// degradation page
#define idh_vpconfig_general_degrade	7031	// general region
#define idh_vpconfig_active_degrade	7032		// active region
#define idh_vpconfig_parameters		7033		// degrade parameters
#define idh_vpconfig_interrupt		7034
// regions page
#define idh_vpconfig_regions_page	7040
#define idh_vpconfig_blowup_region	7041
#define idh_vpconfig_subregion		7042

// Dialog Box: Path Configuration
#define idh_dialog_configure_paths	7050	// main box
// general page
#define idh_paths_general_page		7051	// general page
#define idh_paths_plugin_page		7061	// plugin page
#define idh_paths_bitmaps_page		7062	// bitmaps page

// Dialog Box: Preference Setting 
#define idh_dialog_preference_settings	8000	// main box
// general page
#define idh_pref_general_page		8010
#define idh_pref_preview_options	8011
#define idh_pref_icon_size			8012
#define idh_pref_layout				8013
#define idh_pref_system_units		8014
#define idh_pref_interaction		8015
// rendering page
#define idh_pref_rendering_page		8018
#define idh_pref_video_color		8019
#define idh_pref_dithering			8020
#define idh_pref_field_order		8021
#define idh_pref_super_black		8022
#define idh_pref_hotspot_falloff	8023
#define idh_pref_def_preview		8024
#define idh_pref_renderer			8025
#define idh_pref_render_terminate	8026
// IK page
#define idh_pref_ik_page			8029
#define idh_pref_applied_ik			8030
#define idh_pref_interactive_ik		8031
// animation page
#define idh_pref_animation_page		8034
#define idh_pref_key_brackets		8035
#define idh_pref_animate			8036
#define idh_pref_sound				8037
#define idh_pref_controller_defs	8038
// keyboard page
#define idh_pref_keyboard_page		8042
#define idh_pref_command			8043
#define idh_pref_shortcut			8044
#define idh_pref_sets				8045
// files page
#define idh_pref_files_page			8048
#define idh_pref_file_handling		8049
#define idh_pref_file_menu			8050
#define idh_pref_archive_system		8051
// gamma page
#define idh_pref_gamma_page			8054
#define idh_pref_display			8055
#define idh_pref_device				8056
#define idh_pref_files				8057
// viewports page
#define idh_pref_viewports_page		8060
#define idh_pref_viewport_params	8061
#define idh_pref_viewport_bkgnd		8062
#define idh_pref_move_xfm			8063
// colors page
#define idh_pref_colors_page		8065
// maxscript page
#define idh_pref_maxscript_page		8066

// Dialog Box: Select by Name 
#define idh_dialog_select_by_name	8070
#define idh_sbn_list				8071
#define idh_sbn_list_control		8072	// bottom All/None/Inv and checkboxes
#define idh_sbn_sort				8073
#define idh_sbn_list_display		8074
#define idh_sbn_selection_sets		8075

// Scene Info dialog box
#define idh_dialog_scene_info		8080
#define idh_si_scene_totals			8081
#define idh_si_mesh_totals			8082
#define idh_si_memory				8083
#define idh_si_rendering			8084
#define idh_si_description			8085
#define idh_si_scene_info			8086
#define idh_si_save_to_file			8087
#define idh_si_plugin_info			8088

// Array dialog box
#define idh_dialog_array			8092
#define idh_ar_transformation		8093
#define idh_ar_type_of_entity		8094
#define idh_ar_total				8095
#define idh_ar_reset				8096

// Preview dialog box
#define idh_dialog_preview			8100
#define idh_pv_range				8101
#define idh_pv_frame_rate			8102
#define idh_pv_image_size			8103
#define idh_pv_display				8104
#define idh_pv_rnd_level			8105
#define idh_pv_output				8106


// dialogs with no "control level" granularity
#define idh_dialog_about			9000
#define idh_dialog_select_camera	9010
#define idh_dialog_collapse_warning	9020	// for both collapse all and collapse range
#define idh_dialog_edit_mod_stack	9030
#define idh_dialog_file_new			9040
#define idh_dialog_file_reset		9050
#define idh_dialog_object_prop		9060
#define idh_dialog_grid_snap_settings	9070
#define idh_dialog_group			9080
#define idh_dialog_import_name_conflict	9090
#define idh_dialog_missing_dlls		9100
#define idh_dialog_merge			9110
#define idh_dialog_merge_dup		9111
#define idh_dialog_merge_matlib		9112
#define idh_dialog_merge_matlib_dup	9113
#define idh_dialog_replace			9115
#define idh_dialog_mod_setup		9120
#define idh_dialog_choose_view		9130
#define idh_dialog_mtl_preview		9140
#define idh_dialog_object_color		9150
#define idh_dialog_clone_options	9160
#define idh_dialog_plugin_help		9170
#define idh_dialog_plugin_info		9180	// subdialog of scene info
#define idh_dialog_preview_cancel	9190
#define idh_dialog_rescale_time		9200
#define idh_dialog_time_config		9210
#define idh_dialog_topo_warning		9220	// topology warning
#define idh_dialog_units_setup		9230
#define idh_dialog_viewport_background	9240
#define idh_dialog_customize_ui		9245

#define idh_pref_draftrenderer		9250

//Dans id's
#define idh_dialog_mtl_edit			10001
#define idh_dialog_medit_opt		10002
#define idh_dialog_put_medit		10003
#define idh_dialog_mtlbrows			10004
#define idh_dialog_render			10005
#define idh_dialog_excl_list   		10006
#define idh_dialog_update_mtls 		10007

// Gus' IDs

#define idh_net_server_window			10500	//-- Network Render SERVER main UI Window
#define idh_net_manager_window			10501	//-- Network Render MANAGER main UI Window
#define idh_net_logging_prop			10502	//-- Network Render log properties (common to both Manager and Server)
#define idh_net_manager_prop			10503	//-- Network Render Manager Properties Dialogue
#define idh_net_server_prop				10504	//-- Network Render Server Properties Dialogue
#define idh_notify_main_ui				10505	//-- Notify.exe main UI
#define idh_bmm_vfb						10506	//-- BMM Virtual Frame Buffer Window
#define idh_net_joboutput				10507	//-- Network Rendering - Job Assignment Dialogue - Ouput Exists Dialogue
#define idh_net_job_assignment			10508	//-- Network Rendering - Job Assignment Dialogue
#define idh_net_job_assignment_srv_prop	10509	//-- Network Rendering - Job Assignment Dialogue - Server Properties
#define idh_net_job_assignment_alerts	10510	//-- Network Rendering - Job Assignment Dialogue - Alerts Dialogue

// Rolf's IDs
#define idh_dialog_trackview_ort			11000 
#define idh_dialog_trackview_timepaste		11010 
#define idh_dialog_trackview_trackpaste		11020 
#define idh_dialog_trackview_reducekeys		11030 
#define idh_dialog_trackview_filters		11040 
#define idh_dialog_trackview_pick			11050 
#define idh_dialog_trackview_choosecontrol	11060 

#define idh_dialog_timeslide_createkey		11070 

#define idh_dialog_pref_control_defaults	11080 
#define idh_dialog_pref_select_class		11090 

#define idh_dialog_snapshot					11100 
#define idh_dialog_align					11110 
#define idh_dialog_mirror					11120 
#define idh_dialog_normal_align				11130 
#define idh_dialog_view_align				11135

#define idh_dialog_render_params			11140 
#define idh_dialog_render_presetsize		11160 

#define idh_dialog_atmos					11170 
#define idh_dialog_atmos_create				11180 

#define idh_dialog_medit_browser			11190 
#define idh_dialog_medit_puttolib			11200 

#define idh_dialog_buttonsets				11210 

#define idh_dialog_xform_typein				11220
#define idh_dialog_display_floater			11225

#define idh_dialog_effect					11230 
#define idh_dialog_effect_create			11240 

#define idh_dialog_obj_xref					11250	// Object xref dialog
#define idh_dialog_scene_xref				11260   // Scene xref dialog


// layer ids
#define idh_tb_layer_current_button			11500
#define idh_tb_layer_prop_button			11510
#define idh_tb_layer_list					11520
#define idh_tb_geom_prop_button				11530

// Schematic view ids...
#define idh_dialog_schematicview_filters		11600

// CCJ Dialog ids
#define idh_dialog_file_properties			11700
#define idh_ramplayer_window				11710

// Prs dialog ids
#define idh_3dsexp_export					11800	// 3DS Export Dialog

#define idh_3dsimp_import					11820	// 3DS Import Dialog

#if 0		// rollups, not currently associated with help
#define idh_vrmlexp_anchor					11840	// VRML97 Helpers: Anchor
#define idh_vrmlexp_audioclip				11841	// VRML97 Helpers: AudioClip
#define idh_vrmlexp_backgroundsky			11842	// VRML97 Helpers: Background: sky colors rollout
#define idh_vrmlexp_backgroundground		11843	// VRML97 Helpers: Background: ground colors rollout
#define idh_vrmlexp_backgroundimages		11844	// VRML97 Helpers: Background: images rollout
#define idh_vrmlexp_bboard					11845	// VRML97 Helpers: Billboard
#define idh_vrmlexp_fog						11846	// VRML97 Helpers: Fog
#define idh_vrmlexp_inline					11847	// VRML97 Helpers: Inline
#define idh_vrmlexp_lod						11848	// VRML97 Helpers: LOD
#define idh_vrmlexp_navinfo					11849	// VRML97 Helpers: NavigationInfo
#define idh_vrmlexp_proxsensor				11850	// VRML97 Helpers: ProximitySensor
#define idh_vrmlexp_sound					11851	// VRML97 Helpers: Sound
#define idh_vrmlexp_timesensor				11852	// VRML97 Helpers: TimeSensor
#define idh_vrmlexp_touchsensor				11853	// VRML97 Helpers: TouchSensor
#endif
#define idh_vrmlexp_export					11854	// VRML97 Export Dialog

#if 0		// rollups, not currently associated with help
#define idh_vrblout_inline					11870	// VRML/VRBL Inline Rollout
#define idh_vrblout_lod						11871	// VRML/VRBL Level of Detail Rollout
#define idh_vrblout_actions					11872	// VRML/VRBL Actions Rollout
#define idh_vrblout_animate					11873	// VRML/VRBL Animate Rollout
#define idh_vrblout_hyperlink				11874	// VRML/VRBL Hyperlink Jump Rollout
#define idh_vrblout_viewpoint				11875	// VRML/VRBL Set Camera Rollout
#define idh_vrblout_triggers				11876	// VRML/VRBL Triggers Rollout
#endif
#define idh_vrblout_export					11877	// VRML/VRBL Export Dialog

#define idh_vrmlimp_import					11890	// VRML Import Dialog

#endif // _CONTEXTIDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\CompBase.h ===
/**********************************************************************
 *<
	FILE: compbase.h

	DESCRIPTION:  A base class for components implemented as RefArrays

	CREATED BY: John Hutchinson

	HISTORY: created 9/1/98

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#ifndef _COMPBASE
#define _COMPBASE

#include "RefArrayBase.h"
#include "Icomponent.h"

class CompositeBase : public RefArrayBase, public IComponent
{
protected:
	int iSelLevel;
	enum authority_context {eOpColor};

public:
	CompositeBase():iSelLevel(0){};
	// From Animatable
	CoreExport void DeleteThis();
	// CompositeBase now returns SHAPE_CLASS_ID for its SuperClassID when
	// it only contains shapes. This allows an instance to behave more
	// like a true shape if it only contains shapes. If you want to support
	// this behavior, you'll need two ClassDesc's, one returning GEOM and
	// one returning SHAPE for the super class id. They should both return
	// the same class id. If you want to disable this behavior, override
	// this method.
	CoreExport SClass_ID SuperClassID();

	// This is a flag that *should* be exported elsewhere in the SDK.
	#define DISP_NODEFAULTCOLOR (1<<12)
	// This is an additional flag that can be used by Display() and HitTest().
	#define EDITOBJ_THIS (1 << (HITFLAG_STARTUSERBIT+1))

	//This flag is used by hostcomposite when using special materilas in the viewport
	//It needs to indicate that the material has been usurped and that the mesh
	//should not be passed inode::NumMtls(), rather it should be passed 1.
	#define DISP_NUMMATS_INVALID (1 << (HITFLAG_STARTUSERBIT+2))

	// From BaseObject
	CoreExport int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
	CoreExport int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt);
	CoreExport void Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt);
	CoreExport void GetWorldBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );
	CoreExport void GetLocalBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );
	// For sub-object selection
	CoreExport void Move( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin=FALSE);
	CoreExport void Rotate( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Quat& val, BOOL localOrigin=FALSE);
	CoreExport void Scale( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin=FALSE);
	CoreExport int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc);
	CoreExport int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags, ModContext* mc);
	CoreExport int SubObjectIndex(HitRecord *hitRec);
	CoreExport void GetSubObjectCenters(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);
	CoreExport void GetSubObjectTMs(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);

	// From Object
	CoreExport void GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm = NULL, BOOL useSel = FALSE );
	CoreExport BOOL HasUVW();
	CoreExport void SetGenUVW(BOOL sw);
	CoreExport int CanConvertToType(Class_ID obtype);
	CoreExport Object* ConvertToType(TimeValue t, Class_ID obtype);
	CoreExport void GetCollapseTypes(Tab<Class_ID> &clist,Tab<TSTR*> &nlist);
	CoreExport Class_ID PreferredCollapseType();
	CoreExport int IntersectRay(TimeValue t, Ray& ray, float& at, Point3& norm);
	CoreExport ObjectState Eval(TimeValue t);

	// From GeomObject
	CoreExport Mesh* GetRenderMesh(TimeValue t, INode *inode, View& view, BOOL& needDelete);

	// From ShapeObject
	CoreExport void SetRenderable(BOOL sw);
	CoreExport void SetThickness(float t);
	CoreExport void SetGenUVs(BOOL sw);
	CoreExport int NumberOfVertices(TimeValue t, int curve = -1);
	CoreExport int NumberOfCurves();
	CoreExport BOOL CurveClosed(TimeValue t, int curve);
	CoreExport Point3 InterpCurve3D(TimeValue t, int curve, float param, int ptype=PARAM_SIMPLE);
	CoreExport Point3 TangentCurve3D(TimeValue t, int curve, float param, int ptype=PARAM_SIMPLE);
	CoreExport float LengthOfCurve(TimeValue t, int curve);
	CoreExport int NumberOfPieces(TimeValue t, int curve);
	CoreExport Point3 InterpPiece3D(TimeValue t, int curve, int piece, float param, int ptype=PARAM_SIMPLE);
	CoreExport Point3 TangentPiece3D(TimeValue t, int curve, int piece, float param, int ptype=PARAM_SIMPLE);
	CoreExport MtlID GetMatID(TimeValue t, int curve, int piece);
	CoreExport BOOL CanMakeBezier();
	CoreExport void MakeBezier(TimeValue t, BezierShape &shape);
	CoreExport void MakePolyShape(TimeValue t, PolyShape &shape, int steps = PSHAPE_BUILTIN_STEPS, BOOL optimize = FALSE);
	CoreExport ShapeHierarchy &OrganizeCurves(TimeValue t, ShapeHierarchy *hier=NULL);
	CoreExport int MakeCap(TimeValue t, MeshCapInfo &capInfo, int capType);
	CoreExport int MakeCap(TimeValue t, PatchCapInfo &capInfo);
	CoreExport BOOL AttachShape(TimeValue t, INode *thisNode, INode *attachNode, BOOL weldEnds=FALSE, float weldThreshold=0.0f);

	// From RefArrayBase
	CoreExport class IRefArray *Containee(void){return NULL;}

	// Local methods
	CoreExport virtual ObjectState EvalPipeObj(TimeValue t, Object* obj) = 0;
	CoreExport virtual void CombineComponentMeshes(TimeValue t, Mesh& m) = 0;
	CoreExport virtual void CombineComponentShapes(TimeValue t, BezierShape& Dest) = 0;
	CoreExport virtual void CombineRenderMeshes(TimeValue t, INode *inode, View& view, Mesh& m) = 0;
	CoreExport virtual bool HasOnlyShapeOperands(TimeValue t) = 0;
	CoreExport virtual bool isCompositeAuthority(authority_context context, int contextflags);

	CoreExport virtual bool IsAShape(Object *obj);
	CoreExport void LockComponent();
	CoreExport void UnlockComponent();

protected:
	// Used by most ShapeObject methods.
	CoreExport bool GetNextShape(ComponentIterator* iter, ShapeObject*& shape);
	CoreExport bool CurveFound(int& curve, ComponentIterator* iter, ShapeObject*& shape);
};

//If you implement a component using the compbase class, then you can implement 
//the iterator for it by deriving from the following class. The assumptions include:
// 1) The composite isa IRefArray

class CompositeIteratorBase: public ComponentIterator
{
protected:
	long m_current;
public:
	CoreExport CompositeIteratorBase() : m_current(0) {}
	CoreExport virtual ~CompositeIteratorBase();
	CoreExport virtual void First();
	CoreExport virtual void Next();
	CoreExport virtual bool IsDone() /*const*/;
	CoreExport virtual int SubObjIndex() { return m_current; }
	CoreExport virtual IComponent* GetComponent(void** ipp = NULL, ULONG iid = I_BASEOBJECT) const;
	//Note: this object may be dynamically allocated. Calls must 
	//be matched with calls to DisposeTemporary()

	CoreExport virtual void DeleteThis();

	CoreExport virtual bool WantsDisplay(DWORD flags){return !Hidden();}
	CoreExport virtual Point3 DisplayColor(DWORD flags, INode* n = NULL, GraphicsWindow* gw = NULL);
protected:
	CoreExport virtual Object* GetCompositeObject() = 0;
	CoreExport virtual const Object* GetCompositeObject() const = 0;
};


#endif //_COMPBASE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\color.h ===
/**********************************************************************
 *<
	FILE: color.h

	DESCRIPTION:

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef _COLOR_H 

#define _COLOR_H

#include "point3.h"

#define FLto255(x) ((int)((x)*255.0f+.5))	

class Color;

struct RealPixel {
	unsigned char r,g,b;   // mantissas
	unsigned char e;	   // exponent
	DllExport operator Color();
	};

DllExport RealPixel MakeRealPixel(float r, float g, float b);
DllExport void ExpandRealPixel(const RealPixel &rp, float &r, float &g, float &b);


class Color {
public:
	float r,g,b;

	// Constructors
	Color()  {}
	Color(float R, float G, float B)  { r = R; g = G; b = B;  }
	Color(double R, double G, double B) { r = (float)R; g = (float)G; b = (float)B; }
	Color(int R, int G, int B) { r = (float)R; g = (float)G; b = (float)B; }
	Color(const Color& a) { r = a.r; g = a.g; b = a.b; } 
	DllExport Color(DWORD rgb);  // from Windows RGB value
	Color(Point3 p) { r = p.x; g = p.y; b = p.z; }
	Color(float af[3]) { r = af[0]; g = af[1]; b = af[2]; }
	Color(RealPixel rp) { ExpandRealPixel(rp,r,g,b); } 
	Color(const BMM_Color_24& c) { 
		r = float(c.r)/255.0f; g = float(c.g)/255.0f; b = float(c.b)/255.0f;  
		}
	Color(const BMM_Color_32& c) { 
		r = float(c.r)/255.0f; g = float(c.g)/255.0f; b = float(c.b)/255.0f;  
		}
	Color(const BMM_Color_48& c) { 
		r = float(c.r)/65535.0f; g = float(c.g)/65535.0f; b = float(c.b)/65535.0f;  
		}
	Color(const BMM_Color_64& c) { 
		r = float(c.r)/65535.0f; g = float(c.g)/65535.0f; b = float(c.b)/65535.0f;  
		}
	
		
	void Black() { r = g = b = 0.0f; }
	void White() { r = g = b = 1.0f; }

	DllExport void ClampMax();  // makes components >= 0.0
	DllExport void ClampMin();  // makes components <= 1.0
    DllExport void ClampMinMax();  // makes components in [0,1]

	// Access operators
	float& operator[](int i) { return (&r)[i]; }     
	const float& operator[](int i) const { return (&r)[i]; }  

	// Conversion function
	operator float*() { return(&r); }

	// Convert to Windows RGB
	operator DWORD() { return RGB(FLto255(r),FLto255(g), FLto255(b)); }

	// Convert to Point3
	operator Point3() { return Point3(r,g,b); }

	// Convert to RealPixel
	DllExport operator RealPixel() { return MakeRealPixel(r,g,b); }

	// Convert to Bitmap Manager types
	operator BMM_Color_24() { 
		BMM_Color_24 c; 
		c.r = int(r*255.0f); c.g = int(g*255.0f); c.b = int(b*255.0f);
		return c;
		}
	operator BMM_Color_32() { 
		BMM_Color_32 c; 
		c.r = int(r*255.0f); c.g = int(g*255.0f); c.b = int(b*255.0f);
		return c;
		}
	operator BMM_Color_48() { 
		BMM_Color_48 c; 
		c.r = int(r*65535.0f); c.g = int(g*65535.0f); c.b = int(b*65535.0f);
		return c;
		}
	operator BMM_Color_64() { 
		BMM_Color_64 c; 
		c.r = int(r*65535.0f); c.g = int(g*65535.0f); c.b = int(b*65535.0f);
		return c;
		}

	// Unary operators
	Color operator-() const { return(Color(-r,-g,-b)); } 
	Color operator+() const { return *this; } 

	// Assignment operators
	inline Color& operator-=(const Color&);
    inline Color& operator+=(const Color&);
	inline Color& operator*=(float); 
	inline Color& operator/=(float);
	inline Color& operator*=(const Color&);	// element-by-element multiplg.

	// Test for equality
	int operator==(const Color& p) const { return ((p.r==r)&&(p.g==g)&&(p.b==b)); }
	int operator!=(const Color& p) const { return ((p.r!=r)||(p.g!=g)||(p.b!=b)); }

	// Binary operators
	inline Color operator-(const Color&) const;
	inline Color operator+(const Color&) const;
	inline Color operator/(const Color&) const;
    inline Color operator*(const Color&) const;   
	inline Color operator^(const Color&) const;   // CROSS PRODUCT
	};

int DllExport MaxComponent(const Color&);  // index of the component with the maximum abs value
int DllExport MinComponent(const Color&);  // index of the component with the minimum abs value

float DllExport MaxVal(const Color&);  // value of the component with the maximum abs value
float DllExport MinVal(const Color&);  // value of the component with the minimum abs value

// Inlines:

inline float Length(const Color& v) {	
	return (float)sqrt(v.r*v.r+v.g*v.g+v.b*v.b);
	}

inline Color& Color::operator-=(const Color& a) {	
	r -= a.r;	g -= a.g;	b -= a.b;
	return *this;
	}

inline Color& Color::operator+=(const Color& a) {
	r += a.r;	g += a.g;	b += a.b;
	return *this;
	}

inline Color& Color::operator*=(float f) {
	r *= f;   g *= f;	b *= f;
	return *this;
	}

inline Color& Color::operator/=(float f) { 
	r /= f;	g /= f;	b /= f;	
	return *this; 
	}

inline Color& Color::operator*=(const Color& a) { 
	r *= a.r;	g *= a.g;	b *= a.b;	
	return *this; 
	}

inline Color Color::operator-(const Color& c) const {
	return(Color(r-c.r,g-c.g,b-c.b));
	}

inline Color Color::operator+(const Color& c) const {
	return(Color(r+c.r,g+c.g,b+c.b));
	}

inline Color Color::operator/(const Color& c) const {
	return Color(r/c.r,g/c.g,b/c.b);
	}

inline Color Color::operator*(const Color& c) const {  
	return Color(r*c.r, g*c.g, b*c.b);	
	}

inline Color operator*(float f, const Color& a) {
	return(Color(a.r*f, a.g*f, a.b*f));
	}

inline Color operator*(const Color& a, float f) {
	return(Color(a.r*f, a.g*f, a.b*f));
	}

inline Color operator/(const Color& a, float f) {
	return(Color(a.r/f, a.g/f, a.b/f));
	}

inline Color operator+(const Color& a, float f) {
	return(Color(a.r+f, a.g+f, a.b+f));
	}

inline Color operator+(float f, const Color& a) {
	return(Color(a.r+f, a.g+f, a.b+f));
	}

inline Color operator-(const Color& a, float f) {
	return(Color(a.r-f, a.g-f, a.b-f));
	}

inline Color operator-(float f, const Color& a) {
	return(Color(f-a.r, f-a.g, f-a.b));
	}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\control.h ===
/**********************************************************************
 *<
	FILE:  control.h

	DESCRIPTION:  Control definitions

	CREATED BY:  Dan Silva and Rolf Berteig

	HISTORY: created 9 September 1994

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __CONTROL__

#define __CONTROL__

#include "plugapi.h"

extern CoreExport void ApplyScaling(Matrix3 &m, const ScaleValue &v);
extern CoreExport void InitControlLists();


class ScaleValue;
class ViewExp;
class INode;
class XFormModes;
class INodeTab;
class View;

CoreExport ScaleValue operator+(const ScaleValue& s0, const ScaleValue& s1);
CoreExport ScaleValue operator-(const ScaleValue& s0, const ScaleValue& s1);
CoreExport ScaleValue operator*(const ScaleValue& s, float f);
CoreExport ScaleValue operator*(float f, const ScaleValue& s);
CoreExport ScaleValue operator+(const ScaleValue& s, float f);
CoreExport ScaleValue operator+(float f, const ScaleValue& s);

class ScaleValue {
	public:
	Point3 s;
	Quat q;
	ScaleValue() {}
	ScaleValue(const Point3& as) { s = as; q = IdentQuat(); }
	ScaleValue(const Point3& as, const Quat& aq) {s = as; q = aq;}
	ScaleValue& operator+=(const ScaleValue& s) {(*this)=(*this)+s;return (*this);}
	ScaleValue& operator*=(const float s) {(*this)=(*this)*s;return (*this);}
	ScaleValue& operator=(const ScaleValue &v) {s=v.s;q=v.q;return (*this);}
	float& operator[](int el) {return s[el];}
	};

// Types of ORTs
#define ORT_BEFORE	1
#define ORT_AFTER	2

// ORTs
#define ORT_CONSTANT			1
#define ORT_CYCLE				2
#define ORT_LOOP				3	// This is cycle with continuity.
#define ORT_OSCILLATE			4
#define ORT_LINEAR				5
#define ORT_IDENTITY			6
#define ORT_RELATIVE_REPEAT		7

/*---------------------------------------------------------------------*/

// A list of ease curves.
class EaseCurveList : public ReferenceTarget {
		friend class AddEaseRestore;
		friend class DeleteEaseRestore;

	private:
		Tab<Control*> eases;
		
	public:
	 	EaseCurveList() {OpenTreeEntry(1,ALL_TRACK_VIEWS);}
	  	CoreExport ~EaseCurveList();

		CoreExport TimeValue ApplyEase(TimeValue t,Interval &valid);
		CoreExport void AppendEaseCurve(Control *cont);
		CoreExport void DeleteEaseCurve(int i);
		CoreExport void DisableEaseCurve(int i);
		CoreExport void EnableEaseCurve(int i);
		CoreExport BOOL IsEaseEnabled(int i);
		int NumEaseCurves() {return eases.Count();}

		// Animatable
		void GetClassName(TSTR& s) { s= TSTR(_T("EaseCurve")); }  
		Class_ID ClassID() { return Class_ID(EASE_LIST_CLASS_ID,0); }
		SClass_ID SuperClassID() { return EASE_LIST_CLASS_ID; }		
		CoreExport int NumSubs();
		CoreExport Animatable* SubAnim(int i);
		CoreExport TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum) {return subNum;}
		BOOL BypassTreeView() { return TRUE; }
		void DeleteThis() { delete this; }
		ParamDimension* GetParamDimension(int i) {return stdTimeDim;}
		CoreExport BOOL AssignController(Animatable *control,int subAnim);
		CoreExport void* GetInterface(ULONG id);

		CoreExport IOResult Save(ISave *isave);
		CoreExport IOResult Load(ILoad *iload);
		
		// Reference
		CoreExport int NumRefs();
		CoreExport RefTargetHandle GetReference(int i);
		CoreExport void SetReference(int i, RefTargetHandle rtarg);
		CoreExport RefTargetHandle Clone(RemapDir &remap = NoRemap());
		CoreExport RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	         PartID& partID,  RefMessage message);		
	};

class EaseCurveAnimProp : public AnimProperty {
	public:
		EaseCurveList *el;
		EaseCurveAnimProp() { el=NULL; }
		DWORD ID() {return PROPID_EASELIST;}
	};

#define GetEaseListInterface(anim)	((EaseCurveList*)anim->GetInterface(I_EASELIST))

/*---------------------------------------------------------------------*/
// A list of multiplier curves.
class MultCurveList : public ReferenceTarget {
		friend class AddMultRestore;
		friend class DeleteMultRestore;
	private:
		Tab<Control*> mults;
		
	public:
	 	MultCurveList() {OpenTreeEntry(1,ALL_TRACK_VIEWS);}
	  	CoreExport ~MultCurveList();

		CoreExport float GetMultVal(TimeValue t,Interval &valid);
		CoreExport void AppendMultCurve(Control *cont);
		CoreExport void DeleteMultCurve(int i);
		CoreExport void DisableMultCurve(int i);
		CoreExport void EnableMultCurve(int i);
		CoreExport BOOL IsMultEnabled(int i);
		int NumMultCurves() {return mults.Count();}

		// Animatable
		void GetClassName(TSTR& s) { s= TSTR(_T("MultCurve")); }  
		Class_ID ClassID() { return Class_ID(MULT_LIST_CLASS_ID,0); }
		SClass_ID SuperClassID() { return MULT_LIST_CLASS_ID; }		
		CoreExport int NumSubs();
		CoreExport Animatable* SubAnim(int i);
		CoreExport TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum) {return subNum;}
		BOOL BypassTreeView() { return TRUE; }
		void DeleteThis() { delete this; }
		ParamDimension* GetParamDimension(int i) {return stdNormalizedDim;}
		CoreExport BOOL AssignController(Animatable *control,int subAnim);
		CoreExport void* GetInterface(ULONG id);

		CoreExport IOResult Save(ISave *isave);
		CoreExport IOResult Load(ILoad *iload);
		
		// Reference
		CoreExport int NumRefs();
		CoreExport RefTargetHandle GetReference(int i);
		CoreExport void SetReference(int i, RefTargetHandle rtarg);
		CoreExport RefTargetHandle Clone(RemapDir &remap = NoRemap());
		CoreExport RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	         PartID& partID,  RefMessage message);		
	};

class MultCurveAnimProp : public AnimProperty {
	public:
		MultCurveList *ml;
		MultCurveAnimProp() { ml=NULL; }
		DWORD ID() {return PROPID_MULTLIST;}
	};

#define GetMultListInterface(anim)	((MultCurveList*)anim->GetInterface(I_MULTLIST))

/*---------------------------------------------------------------------*/


//
// For hit testing controller apparatus 
//

class CtrlHitRecord {
	friend class CtrlHitLog;
	CtrlHitRecord *next;
	public:
		INode *nodeRef;
		DWORD distance;
		ulong hitInfo;
		DWORD infoExtra;		
		CtrlHitRecord() {next=NULL; distance=0; hitInfo=0; nodeRef=NULL;}
		CtrlHitRecord(CtrlHitRecord *nxt,INode *nr, DWORD d, ulong inf, DWORD extra) {
			next=nxt;nodeRef=nr;distance=d;hitInfo=inf;infoExtra=extra;}
		CtrlHitRecord *Next() {return next;}		
	};				   	

class CtrlHitLog {
	CtrlHitRecord *first;
	int hitIndex;
	public:
		CtrlHitLog()  { first = NULL; }
		~CtrlHitLog() { Clear(); }
		CoreExport void Clear();
		CoreExport void ClearHitIndex()		{ hitIndex = 0; }
		CoreExport void IncrHitIndex()		{ hitIndex++; }
		CtrlHitRecord* First() { return first; }
		CoreExport CtrlHitRecord* ClosestHit();
		void LogHit(INode *nr,DWORD dist,ulong info,DWORD infoExtra)
			{first = new CtrlHitRecord(first,nr,dist,info,infoExtra);}
	};


// For enumerating IK paramaters
class IKEnumCallback {
	public:
		virtual void proc(Control *c, int index)=0;
	};

class IKDeriv {
	public:
		virtual int NumEndEffectors()=0;
		virtual Point3 EndEffectorPos(int index)=0;
		virtual void DP(Point3 dp,int index)=0;
		virtual void DR(Point3 dr,int index)=0;
		virtual void NextDOF()=0;
	};

// Flags passed to CompDerivs
#define POSITION_DERIV	(1<<0)
#define ROTATION_DERIV	(1<<1)


// This class is used to store IK parameters that have been
// copied to a clipboard.
class IKClipObject {
	public:
		// Identifies the creator of the clip object
		virtual SClass_ID 	SuperClassID()=0;
		virtual Class_ID	ClassID()=0;
		
		virtual void DeleteThis()=0;
	};

// Values for 'which' pasted to Copy/PasteIKParams
#define COPYPASTE_IKPOS		1
#define COPYPASTE_IKROT		2

// Passed to InitIKJoints() which is called when importing
// R4 3DS files that have IK joint data.
class InitJointData {
	public:
		BOOL active[3];
		BOOL limit[3];
		BOOL ease[3];
		Point3 min, max, damping;
	};

// This structure is passed to GetDOFParams().
// Controllers that support IK can provide info about their DOFs
// so that bones can display this information.
// The first 3 DOFs are assumed to be position
// and the next 3 are assumed to be rotation
class DOFParams {
	public:
		BOOL display[6];		// Should this DOF be displayed?
		Point3 axis[6];			// DOF axis
		Point3 pos[6];			// Base of axis
		BOOL limit[6];          // is joint limited?
		float min[6];			// min limit
		float max[6];           // max limit
		float curval[6];		// Current value of the parameter
		BOOL sel[6];			// should DOF be highlighted
		BOOL endEffector;		// is there an end effector for this controller
		Matrix3 eeTM;			// world TM of the end effector if present
	};


// These two ways values can be retreived or set.
// For get:
//		RELATIVE = Apply
//		ABSOLUTE = Just get the value
// For set:
//		RELATIVE = Add the value to the existing value (i.e Move/Rotate/Scale)
//		ABSOLUTE = Just set the value
enum GetSetMethod {CTRL_RELATIVE,CTRL_ABSOLUTE};


// Control class provides default implementations for load and save which save the ORT type in these chunks:
#define CONTROLBASE_CHUNK 		0x8499
#define INORT_CHUNK				0x3000
#define OUTORT_CHUNK			0x3001
#define CONT_DISABLED_CHUNK		0x3002

// Inheritance flags.
#define INHERIT_POS_X	(1<<0)
#define INHERIT_POS_Y	(1<<1)
#define INHERIT_POS_Z	(1<<2)
#define INHERIT_ROT_X	(1<<3)
#define INHERIT_ROT_Y	(1<<4)
#define INHERIT_ROT_Z	(1<<5)
#define INHERIT_SCL_X	(1<<6)
#define INHERIT_SCL_Y	(1<<7)
#define INHERIT_SCL_Z	(1<<8)
#define INHERIT_ALL		511

class Control : public ReferenceTarget {
	public:
		Control() {SetORT(ORT_CONSTANT,ORT_BEFORE);SetORT(ORT_CONSTANT,ORT_AFTER);};
		virtual ~Control() {};

		virtual void Copy(Control *from)=0;
		virtual void CommitValue(TimeValue t) {}
		virtual void RestoreValue(TimeValue t) {}
		virtual INode* GetTarget() { return NULL; } 
		virtual RefResult SetTarget(INode *targ) {return REF_SUCCEED;}

		// Implemented by transform controllers that have position controller
		// that can be edited in the trajectory branch
		virtual Control *GetPositionController() {return NULL;}
		virtual Control *GetRotationController() {return NULL;}
		virtual Control *GetScaleController() {return NULL;}
		virtual BOOL SetPositionController(Control *c) {return FALSE;}
		virtual BOOL SetRotationController(Control *c) {return FALSE;}
		virtual BOOL SetScaleController(Control *c) {return FALSE;}

		// If a controller has an 'X', 'Y', or 'Z' controller, it can implement
		// these methods so that its sub controllers can respect track view filters
		virtual Control *GetXController() {return NULL;}
		virtual Control *GetYController() {return NULL;}
		virtual Control *GetZController() {return NULL;}

		// Implemented by look at controllers that have a float valued roll
		// controller so that the roll can be edited via the transform type-in
		virtual Control *GetRollController() {return NULL;}
		virtual BOOL SetRollController(Control *c) {return FALSE;}

		// Implemented by any Point3 controller that wishes to indicate that it is intended
		// to control floating point RGB color values
		virtual BOOL IsColorController() {return FALSE;}

		// Implemented by TM controllers that support 
		// filtering out inheritance
		virtual DWORD GetInheritanceFlags() {return INHERIT_ALL;}
		virtual BOOL SetInheritanceFlags(DWORD f,BOOL keepPos) {return FALSE;} // return TRUE if TM controller supports inheritance

		virtual BOOL IsLeaf() {return TRUE;}
		virtual int IsKeyable() {return 1;}

		// If a controller does not want to allow another controller
		// to be assigned on top of it, it can return FALSE to this method.
		virtual BOOL IsReplaceable() {return TRUE;}		

		// This is called on TM, pos, rot, and scale controllers when their
		// input matrix is about to change. If they return FALSE, the node will
		// call SetValue() to make the necessary adjustments.
		virtual BOOL ChangeParents(TimeValue t,const Matrix3& oldP,const Matrix3& newP,const Matrix3& tm) {return FALSE;}

		// val points to an instance of a data type that corresponds with the controller
		// type. float for float controllers, etc.
		// Note that for SetValue on Rotation controllers, if the SetValue is
		// relative, val points to an AngAxis while if it is absolute it points
		// to a Quat.
		virtual void GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method=CTRL_ABSOLUTE)=0;	
		virtual	void SetValue(TimeValue t, void *val, int commit=1, GetSetMethod method=CTRL_ABSOLUTE)=0;

		// Transform controllers that do not inherit their parent's  transform 
		// should override this method. Returning FALSE will cause SetValue 
		// to be called even in the case when the parent is also being transformed.
		virtual BOOL InheritsParentTransform() { return TRUE; }

		virtual int GetORT(int type) {return (aflag>>(type==ORT_BEFORE?A_ORT_BEFORESHIFT:A_ORT_AFTERSHIFT))&A_ORT_MASK;}
		CoreExport virtual void SetORT(int ort,int type);
		
		// Sets the enabled/disabled state for ORTs
		CoreExport virtual void EnableORTs(BOOL enable);

		// Default implementations of load and save handle loading and saving of out of range type.
		// Call these from derived class load and save.
		// NOTE: Must call these before any of the derived class chunks are loaded or saved.
		CoreExport IOResult Save(ISave *isave);
		CoreExport IOResult Load(ILoad *iload);

		// For IK
		// Note: IK params must be given in the order they are applied to
		// the parent matrix. When derivatives are computed for a parameter
		// that parameter will apply itself to the parent matrix so the next
		// parameter has the appropriate reference frame. If a controller isn't
		// participating in IK then it should return FALSE and the client (usually PRS)
		// will apply the controller's value to the parent TM.
		virtual void EnumIKParams(IKEnumCallback &callback) {}
		virtual BOOL CompDeriv(TimeValue t,Matrix3& ptm,IKDeriv& derivs,DWORD flags) {return FALSE;}
		virtual float IncIKParam(TimeValue t,int index,float delta) {return 0.0f;}
		virtual void ClearIKParam(Interval iv,int index) {return;}
		virtual BOOL CanCopyIKParams(int which) {return FALSE;}
		virtual IKClipObject *CopyIKParams(int which) {return NULL;}
		virtual BOOL CanPasteIKParams(IKClipObject *co,int which) {return FALSE;}
		virtual void PasteIKParams(IKClipObject *co,int which) {}
		virtual void InitIKJoints(InitJointData *posData,InitJointData *rotData) {}
		virtual BOOL GetIKJoints(InitJointData *posData,InitJointData *rotData) {return FALSE;}
		virtual BOOL GetDOFParams(TimeValue t,Matrix3 &ptm,DOFParams &dofs,BOOL nodeSel) {return FALSE;}
		virtual BOOL CreateLockKey(TimeValue t, int which) {return FALSE;}
		virtual void MirrorIKConstraints(int axis,int which,BOOL pasteMirror=FALSE) {}
		virtual BOOL TerminateIK() {return FALSE;} // controllers can act as terminators.

		// Called on a transform controller when the a message is received from a pin node
		virtual RefResult PinNodeChanged(RefMessage message,Interval changeInt, PartID &partID) {return REF_SUCCEED;}

		// Called on a transform controller when one of the node level IK parameters has been changed
		virtual void NodeIKParamsChanged() {}

		// Called in a transform controller when a node invalidates its TM cache
		virtual void TMInvalidated() {}

		// Let's the TM controller determine if it's OK to bind (IK bind) to a particular node.
		virtual BOOL OKToBindToNode(INode *node) {return TRUE;}

		// Ease curves
		virtual BOOL CanApplyEaseMultCurves() {return TRUE;}
		CoreExport TimeValue ApplyEase(TimeValue t,Interval &valid);
		CoreExport void AppendEaseCurve(Control *cont);
		CoreExport void DeleteEaseCurve(int i);
		CoreExport int NumEaseCurves();

		// Multiplier curves		
		CoreExport float GetMultVal(TimeValue t,Interval &valid);
		CoreExport void AppendMultCurve(Control *cont);
		CoreExport void DeleteMultCurve(int i);
		CoreExport int NumMultCurves();

		// These are implemented to handle ease curves. If a controller
		// is a leaf controller, then it MUST NOT BY DEFINITION have any
		// sub controllers or references. If it is a leaf controller, then
		// these are implemented to handle the ease curve list.
		// If it is NOT a leaf controller, then these can be overridden.
		CoreExport int NumRefs();
		CoreExport RefTargetHandle GetReference(int i);
		CoreExport void SetReference(int i, RefTargetHandle rtarg);
		CoreExport int NumSubs();
		CoreExport Animatable* SubAnim(int i);
		CoreExport TSTR SubAnimName(int i);

		// Default implementations of some Animatable methods
		CoreExport void* GetInterface(ULONG id);
		CoreExport int PaintFCurves(			
			ParamDimensionBase *dim,
			HDC hdc,
			Rect& rcGraph,
			Rect& rcPaint,
			float tzoom,
			int tscroll,
			float vzoom,
			int vscroll,
			DWORD flags );
		CoreExport int GetFCurveExtents(
			ParamDimensionBase *dim,
			float &min, float &max, DWORD flags);


		// This is called on transform controller after a node is
		// cloned and the clone process has finished
		virtual void PostCloneNode() {}

		// Slave TM controllers can implement this to prevent plug-ins
		// deleting their node via the DeleteNode API.
		virtual BOOL PreventNodeDeletion() {return FALSE;}

		// New interface for visibility float controllers to allow view dependent visibility
		// The default implementation will call GetValue()
		CoreExport virtual float EvalVisibility(TimeValue t,View &view,Box3 pbox,Interval &valid);
		
		// Called on visibility controllers. Gives them the option to completely hide an object in the viewports
		virtual BOOL VisibleInViewports() {return TRUE;}

		// Called on transform controllers or visibility controllers when a node is cloned and the user has chosen to instance
		virtual BOOL CanInstanceController() {return TRUE;}

		// Should be called by any leaf controller's clone method so
		// that ease and multipier curves are cloned.
		CoreExport void CloneControl(Control *ctrl,RemapDir &remap);

		//-------------------------------------------------------
		// Controllers that wish to have an apparatus available in
		// the scene will implement these methods:
		// NOTE: Most of these methods are duplicated in BaseObject or Object
		// (see object.h for descriptions).
		virtual int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags) { return 0; };
		virtual int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt) { return 0; }
		virtual	void GetWorldBoundBox(TimeValue t,INode* inode, ViewExp *vpt, Box3& box) {}

		virtual void ActivateSubobjSel(int level, XFormModes& modes ) {}

		virtual void SelectSubComponent(CtrlHitRecord *hitRec, BOOL selected, BOOL all, BOOL invert=FALSE) {}
		virtual void ClearSelection(int selLevel) {}
		virtual int SubObjectIndex(CtrlHitRecord *hitRec) {return 0;}		
		virtual void SelectAll(int selLevel) {}
		virtual void InvertSelection(int selLevel) {}

		virtual void GetSubObjectCenters(SubObjAxisCallback *cb,TimeValue t,INode *node) {}
		virtual void GetSubObjectTMs(SubObjAxisCallback *cb,TimeValue t,INode *node) {}

		// Modify sub object apparatuses
		virtual void SubMove( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin=FALSE ){}
		virtual void SubRotate( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Quat& val, BOOL localOrigin=FALSE ){}
		virtual void SubScale( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin=FALSE ){}		
		
		// Schematic View Animatable Overides...
		CoreExport SvGraphNodeReference SvTraverseAnimGraph(IGraphObjectManager *gom, Animatable *object, int id, DWORD flags);

		// Called when the user rescales time in the time configuration dialog. If FALSE
		// is returned from this method then MapKeys() will be used to perform the scaling. 
		// Controllers can override this method to handle things like rescaling tagents that 
		// MapKeys() won't affect and return TRUE if they don't want map keys to be called.
		virtual BOOL RescaleTime(Interval oseg, Interval nseg) {return FALSE;}
	};


// Any controller that does not evaluate itself as a function of it's
// input can subclass off this class.
// GetValueLocalTime() will never ask the controller to apply the value,
// it will always ask for it absolute.
class StdControl : public Control {
	public:		
		virtual void GetValueLocalTime(TimeValue t, void *val, Interval &valid, GetSetMethod method=CTRL_ABSOLUTE)=0;
		virtual	void SetValueLocalTime(TimeValue t, void *val, int commit=1, GetSetMethod method=CTRL_ABSOLUTE)=0;
		CoreExport void GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method=CTRL_ABSOLUTE);
		CoreExport void SetValue(TimeValue t, void *val, int commit=1, GetSetMethod method=CTRL_ABSOLUTE);

		virtual void Extrapolate(Interval range,TimeValue t,void *val,Interval &valid,int type)=0;
		
		virtual void *CreateTempValue()=0;
		virtual void DeleteTempValue(void *val)=0;
		virtual void ApplyValue(void *val, void *delta)=0;
		virtual void MultiplyValue(void *val, float m)=0;
	};


// Each super class of controller may have a specific packet defined that
// the 'val' pointer will point to instead of a literal value.
// In reality, probably only the Transform controller will do this.
enum SetXFormCommand { XFORM_MOVE, XFORM_ROTATE, XFORM_SCALE, XFORM_SET };
class SetXFormPacket {
	public:
		SetXFormCommand command;
		Matrix3 tmParent;
		Matrix3 tmAxis;		// if command is XFORM_SET, this will contain the new value for the XFORM.		
		Point3 p;
		Quat q;
		AngAxis aa;
		BOOL localOrigin;		
		
		// XFORM_SET
		SetXFormPacket(const Matrix3& mat,const Matrix3& par=Matrix3(1))
			{command=XFORM_SET,tmParent=par,tmAxis=mat;}

		// XFORM_MOVE
		SetXFormPacket(Point3 pt, const Matrix3& par=Matrix3(1), 
						const Matrix3& a=Matrix3(1))
			{command=XFORM_MOVE;tmParent=par;tmAxis=a;p=pt;localOrigin=FALSE;}

		// XFORM_ROTATE
		SetXFormPacket(Quat qt, BOOL l, const Matrix3& par=Matrix3(1),
						const Matrix3& a=Matrix3(1))
			{command=XFORM_ROTATE;tmParent=par;tmAxis=a;q=qt;aa=AngAxis(q);localOrigin=l;}
		SetXFormPacket(AngAxis aA, BOOL l, const Matrix3& par=Matrix3(1),
						const Matrix3& a=Matrix3(1))
			{command=XFORM_ROTATE;tmParent=par;tmAxis=a;q=Quat(aA);aa=aA;localOrigin=l;}

		// XFORM_SCALE
		SetXFormPacket(Point3 pt, BOOL l, const Matrix3& par=Matrix3(1),
						const Matrix3& a=Matrix3(1))
			{command=XFORM_SCALE;tmParent=par;tmAxis=a;p=pt;localOrigin=l;}

		// Just in case you want to do it by hand...
		SetXFormPacket() {};
	};



// This is a special control base class for controllers that control
// morphing of geomoetry.
//
// The 'val' pointer used with GetValue will point to an object state.
// This would be the result of evaluating a combination of targets and
// producing a new object that is some combination of the targets.
//
// The 'val' pointer used with SetValue will point to a 
// SetMorphTargetPacket data structure. This has a pointer to
// an object (entire pipeline) and the name of the target.

// A pointer to one of these is passed to SetValue
class SetMorphTargetPacket {
	public:
		Matrix3 tm;
		Object *obj;
		TSTR name;
		BOOL forceCreate; // Make sure the key is created even if it is at frame 0
		SetMorphTargetPacket(Object *o,TSTR n,Matrix3 &m,BOOL fc=FALSE) {obj = o;name = n;tm = m;forceCreate=fc;}
		SetMorphTargetPacket(Object *o,TSTR n,BOOL fc=FALSE) {obj = o;name = n;tm = Matrix3(1);forceCreate=fc;}
	};

class MorphControl : public Control {
	public:
		
		// Access the object pipelines of the controller's targets. Note
		// that these are pointers to the pipelines, not the result of
		// evaluating the pipelines.
		virtual int NumMorphTargs() {return 0;}
		virtual Object *GetMorphTarg(int i) {return NULL;}
		virtual void DeleteMorphTarg(int i) {}
		virtual void GetMorphTargName(int i,TSTR &name) {name.printf(_T("Target #%d"),i);}
		virtual void SetMorphTargName(int i,TSTR name) {}
		virtual Matrix3 GetMorphTargTM(int i) {return Matrix3(1);}

		// Checks an object to see if it is an acceptable target.
		virtual BOOL ValidTarget(TimeValue t,Object *obj) {return FALSE;}

		// When a REFMSG_SELECT_BRANCH message is received the morph controller should
		// mark the target indicated and be prepared to return its ID from this method.
		virtual int GetFlaggedTarget() {return -1;}

		// Should call these methods on targets
		virtual BOOL HasUVW() { return 1; }
		virtual void SetGenUVW(BOOL sw) {  }
	};

//-------------------------------------------------------------
// Control base class for Master Controllers
//

class MasterPointControl : public Control {
	public:
		// Set the number of sub-controllers
		virtual	void SetNumSubControllers(int num, BOOL keep=FALSE) {}
		// Return the number of sub-controllers
		virtual	int	 GetNumSubControllers() { return 0; }
		// Delete all the sub-controllers that are set to TRUE in the BitArray
		virtual void DeleteControlSet (BitArray set) {}
		// Add a new sub-controller
		virtual int	 AddSubController(Control* ctrl) { return 0; }
		// Return i'th of sub-controller
		virtual Control* GetSubController(int i) { return NULL; }
		// Set the i'th sub-controller
		virtual	void SetSubController(int i, Control* ctrl) {}
};


//----------------------------------------------------------------//
//
// Some stuff to help with ORTs - these could actually be Interval methods

inline TimeValue CycleTime(Interval i,TimeValue t)
	{
	int res, dur = i.Duration()-1;
	if (dur<=0) return t;		
	res	= (t-i.Start())%dur;
	if (t<i.Start()) {
		return i.End()+res;
	} else {
		return i.Start()+res;
		}
	}

inline int NumCycles(Interval i,TimeValue t)
	{
	int dur = i.Duration()-1;
	if (dur<=0) return 1;
	if (t<i.Start()) {
		return (abs(t-i.Start())/dur)+1;
	} else 
	if (t>i.End()) {
		return (abs(t-i.End())/dur)+1;
	} else {
		return 0;
		}
	}



// Types that use this template must support:
//  T + T, T - T, T * float, T + float 

template <class T> T 
LinearExtrapolate(TimeValue t0, TimeValue t1, T &val0, T &val1, T &endVal)
	{
	return (T)(endVal + (val1-val0) * float(t1-t0));
	}

template <class T> T 
RepeatExtrapolate(Interval range, TimeValue t, 
		T &startVal, T &endVal, T &cycleVal)
	{
	int cycles = NumCycles(range,t);
	T delta;
	if (t<range.Start()) {
		delta = startVal - endVal;
	} else {
		delta = endVal - startVal;
		}
	return (T)(cycleVal + delta * float(cycles));
	}

template <class T> T 
IdentityExtrapolate(TimeValue endPoint, TimeValue t, T &endVal )
	{
	return (T)(endVal + float(t-endPoint));
	}

CoreExport Quat LinearExtrapolate(TimeValue t0, TimeValue t1, Quat &val0, Quat &val1, Quat &endVal);
CoreExport Quat RepeatExtrapolate(Interval range, TimeValue t, 
					Quat &startVal, Quat &endVal, Quat &cycleVal);
CoreExport Quat IdentityExtrapolate(TimeValue endPoint, TimeValue t, Quat &endVal );

CoreExport ScaleValue LinearExtrapolate(TimeValue t0, TimeValue t1, ScaleValue &val0, ScaleValue &val1, ScaleValue &endVal);
CoreExport ScaleValue RepeatExtrapolate(Interval range, TimeValue t, ScaleValue &startVal, ScaleValue &endVal, ScaleValue &cycleVal);
CoreExport ScaleValue IdentityExtrapolate(TimeValue endPoint, TimeValue t, ScaleValue &endVal);


template <class T> T
LinearInterpolate(const T &v0,const T &v1,float u)
	{
	return (T)((1.0f-u)*v0 + u*v1);
	}

inline Quat 
LinearInterpolate(const Quat &v0,const Quat &v1,float u)
	{
	return Slerp(v0,v1,u);
	}

inline ScaleValue 
LinearInterpolate(const ScaleValue &v0,const ScaleValue &v1,float u)
	{
	ScaleValue res;
	res.s = ((float)1.0-u)*v0.s + u*v1.s;
	res.q = Slerp(v0.q,v1.q,u);
	return res;
	}


inline Interval TestInterval(Interval iv, DWORD flags)
	{
	TimeValue start = iv.Start();
	TimeValue end = iv.End();
	if (!(flags&TIME_INCLEFT)) {
		start++;
		}	
	if (!(flags&TIME_INCRIGHT)) {
		end--;
		}
	if (end<start) {
		iv.SetEmpty();
	} else {
		iv.Set(start,end);
		}
	return iv;	
	}

inline Quat ScaleQuat(Quat q, float s)
	{
	float angle;
	Point3 axis;
	AngAxisFromQ(q,&angle,axis);
	return QFromAngAxis(angle*s,axis);
	}

//-------------------------------------------------------------------
// A place to store values during Hold/Restore periods
//
//********************************************************
// TempStore:  This is a temporary implementation:
//  It uses a linear search-
//  A hash-coded dictionary would be faster.
//  (if there are ever a lot of entries)
//********************************************************

struct Slot {
	void *key;
	void *pdata;
	int nbytes;	
	Slot *next;
	public:
		Slot() { pdata = NULL; }
		~Slot() {
			 if (pdata) free(pdata); 
			 pdata = NULL;
			 }

	};

class TempStore {
	Slot *slotList;				
	Slot* Find(int n, void *data, void *ptr);
	public:
		TempStore() { 	slotList = NULL;	}
		~TempStore() {	ClearAll();	}
		CoreExport void ClearAll();   // empty out the store 
		CoreExport void PutBytes(int n, void *data, void *ptr);
		CoreExport void GetBytes(int n, void *data, void *ptr);
		CoreExport void Clear(void *ptr);  // Remove single entry
		void PutFloat(float  f, void *ptr) {
			 PutBytes(sizeof(float),(void *)&f,ptr);
			 }
		CoreExport void PutInt(int i, void *ptr) {
			 PutBytes(sizeof(int),(void *)&i,ptr);
			 }
		CoreExport void GetFloat(float *f, void *ptr) { 
			GetBytes(sizeof(float),(void *)f,ptr);
			}
		CoreExport void GetInt(int *i, void *ptr) { 
			GetBytes(sizeof(int),(void *)i,ptr);
			}
		CoreExport void PutPoint3(Point3  f, void *ptr) {
			 PutBytes(sizeof(Point3),(void *)&f,ptr);
			 }
		CoreExport void GetPoint3(Point3 *f, void *ptr) { 
			GetBytes(sizeof(Point3),(void *)f,ptr);
			}
		CoreExport void PutQuat( Quat  f, void *ptr) {
			 PutBytes(sizeof(Quat),(void *)&f,ptr);
			 }
		CoreExport void GetQuat( Quat *f, void *ptr) { 
			GetBytes(sizeof(Quat),(void *)f,ptr);
			}
		CoreExport void PutScaleValue( ScaleValue  f, void *ptr) {
			 PutBytes(sizeof(ScaleValue),(void *)&f,ptr);
			 }
		CoreExport void GetScaleValue( ScaleValue *f, void *ptr) { 
			GetBytes(sizeof(ScaleValue),(void *)f,ptr);
			}
	};


extern CoreExport TempStore tmpStore;   // this should be in the scene data struct.


CoreExport int Animating();	 // is the animate switch on??
CoreExport void AnimateOn();  // turn animate on
CoreExport void AnimateOff();  // turn animate off
CoreExport void SuspendAnimate(); // suspend animation (uses stack)
CoreExport void ResumeAnimate();   // resume animation ( " )

CoreExport TimeValue GetAnimStart();
CoreExport TimeValue GetAnimEnd();
CoreExport void SetAnimStart(TimeValue s);
CoreExport void SetAnimEnd(TimeValue e);

CoreExport Control *NewDefaultFloatController();
CoreExport Control *NewDefaultPoint3Controller();
CoreExport Control *NewDefaultMatrix3Controller();
CoreExport Control *NewDefaultPositionController();
CoreExport Control *NewDefaultRotationController();
CoreExport Control *NewDefaultScaleController();
CoreExport Control *NewDefaultBoolController();
CoreExport Control *NewDefaultColorController();
CoreExport Control *NewDefaultMasterPointController();

CoreExport Control* CreateInterpFloat();
CoreExport Control* CreateInterpPosition();
CoreExport Control* CreateInterpPoint3();
CoreExport Control* CreateInterpRotation();
CoreExport Control* CreateInterpScale();
CoreExport Control* CreatePRSControl();
CoreExport Control* CreateLookatControl();
CoreExport Control* CreateMasterPointControl();

CoreExport void SetDefaultController(SClass_ID sid, ClassDesc *desc);
CoreExport ClassDesc *GetDefaultController(SClass_ID sid);

CoreExport void SetDefaultColorController(ClassDesc *desc);
CoreExport void SetDefaultBoolController(ClassDesc *desc);



#endif //__CONTROL__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\coreexp.h ===
/**********************************************************************
 *<
	FILE: coreexp.h

	DESCRIPTION:

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __COREEXPORT__H
#define __COREEXPORT__H

#ifdef BLD_CORE
#define CoreExport __declspec( dllexport )
#else
#define CoreExport __declspec( dllimport )
#endif

#endif // __COREEXPORT__H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\coregen.h ===
/**********************************************************************
 *<
	FILE: coregen.h

	DESCRIPTION:  General includes for core (must include corebas.h
	              before this file).

	CREATED BY: Rolf Berteig

	HISTORY: created 19 November 1994

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __COREGEN__
#define __COREGEN__

#include "..\core\control.h"
#include "..\core\object.h"

#endif // __COREGEN__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\dbgprint.h ===
/**********************************************************************
 *<
	FILE: dbgprint.cpp

	DESCRIPTION: Simple Debug Print Function

	CREATED BY: Tom Hudson

	HISTORY: Created 3 July 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#ifndef __DBGPRINT__H
#define __DBGPRINT__H

void UtilExport DebugPrint(const TCHAR *format, ...);

#endif //__DBGPRINT__H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\decomp.h ===
/**********************************************************************
 *<
	FILE: decomp.h

	DESCRIPTION:

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef _H_Decompose
#define _H_Decompose

typedef struct {
	Point3 t;	/* Translation components */
	Quat q;	/* Essential rotation	  */
	Quat u;	/* Stretch rotation	  */
	Point3 k;	/* Stretch factors	  */
	float f;	/* Sign of determinant	  */
	} AffineParts;

CoreExport void SpectralDecomp(Matrix3 m, Point3 &s, Quat& q);
CoreExport void decomp_affine(Matrix3 A, AffineParts *parts);
CoreExport void invert_affine(AffineParts *parts, AffineParts *inverse);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\dynamic.h ===
#ifndef _DYNAMIC_H_

#define _DYNAMIC_H_
#include "iparamm.h"
#include "Simpobj.h"

class DynamHelperObject : public SimpleObject, IParamArray {
public:
virtual	INode *GetEndNode1(){return NULL;}
virtual	INode *GetEndNode2(){return NULL;}
virtual	Point3 ApplyAtEnd1(TimeValue t){return Point3(0.0f,0.0f,0.0f);}
virtual	Point3 ApplyAtEnd2(TimeValue t){return Point3(0.0f,0.0f,0.0f);}
virtual	Point3 Force(TimeValue t,TimeValue dt){return Point3(0.0f,0.0f,0.0f);}
};

typedef struct{
  TimeValue t1,t2;
  Point3 FlectForce,ApplyAt;
  int Num;
} FlectForces;

class DynamModObject : public SimpleWSMObject
{ public:
	virtual FlectForces ForceData(TimeValue t)
	{FlectForces f1;f1.t1=0;f1.t2=0;
	 f1.FlectForce=Point3(0.0f,0.0f,0.0f);
	 f1.ApplyAt=Point3(0.0f,0.0f,0.0f);return f1;}
};

#endif // _DYNAMIC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\dummy.h ===
/**********************************************************************
 *<
	FILE: dummy.h

	DESCRIPTION:

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __DUMMY__H
#define __DUMMY__H


extern CoreExport Class_ID dummyClassID;

class DummyObject: public HelperObject {			   
	friend class DummyObjectCreateCallBack;
	friend BOOL CALLBACK DummyParamDialogProc( HWND hDlg, UINT message, 
		WPARAM wParam, LPARAM lParam );
	
		// Mesh cache
		Mesh mesh;	
		long dumFlags;	
		Point3 color;
		Box3 box;
		Interval valid;
		void BuildMesh();
		void UpdateMesh();

	//  inherited virtual methods for Reference-management
		RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message );

	public:
		CoreExport DummyObject();

		CoreExport Box3 GetBox() const;
		CoreExport void SetBox(Box3& b);
		CoreExport void SetColor(Point3 color);
		CoreExport void EnableDisplay();
		CoreExport void DisableDisplay();
		CoreExport void SetValidity(Interval v);

		//  inherited virtual methods:
		// From BaseObject
		CoreExport int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt);
		CoreExport void Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt);
		CoreExport int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
		CoreExport CreateMouseCallBack* GetCreateMouseCallBack();
		CoreExport RefTargetHandle Clone(RemapDir& remap = NoRemap());
		Interval ObjectValidity(TimeValue t) { return valid; }

		// From Object
		CoreExport ObjectState Eval(TimeValue time);
		void InitNodeName(TSTR& s);
		int DoOwnSelectHilite() {return 1; }		
		int IsRenderable(){ return 0; }
		TCHAR *GetObjectName();

		//  From Object
		CoreExport void GetWorldBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );
		CoreExport void GetLocalBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );
		CoreExport void GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm, BOOL useSel=FALSE );


		// IO
		CoreExport IOResult Save(ISave *isave);
		CoreExport IOResult Load(ILoad *iload);

		// From ReferenceMaker
		CoreExport void RescaleWorldUnits(float f);

		// Animatable methods
		void DeleteThis() { delete this; }
		Class_ID ClassID() { return dummyClassID; }  
		void GetClassName(TSTR& s);
		int IsKeyable(){ return 1;}
		LRESULT CALLBACK TrackViewWinProc( HWND hwnd,  UINT message, 
	            WPARAM wParam,   LPARAM lParam ){return(0);}
	};

CoreExport ClassDesc* GetDummyObjDescriptor();
#endif // __DUMMY__H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\euler.h ===
/*******************************************************************
 *
 *    DESCRIPTION: euler.h
 *
 *    AUTHOR: Converted from Ken Shoemake's Graphics Gems IV code by Dan Silva
 *
 *    HISTORY:  converted 11/21/96
 *
 *              RB: This file provides only a subset of those
 *                  found in the original Graphics Gems paper.
 *                  All orderings are 'static axis'.
 *
 *******************************************************************/

#ifndef __EULER__
#define __EULER__

#include "matrix3.h"
#include "quat.h"

#define EULERTYPE_XYZ	0
#define EULERTYPE_XZY	1
#define EULERTYPE_YZX	2
#define EULERTYPE_YXZ	3
#define EULERTYPE_ZXY	4
#define EULERTYPE_ZYX	5
#define EULERTYPE_XYX	6
#define EULERTYPE_YZY	7
#define EULERTYPE_ZXZ	8

#define EULERTYPE_RF    16  // rotating frame (axes)  --prs.

void DllExport QuatToEuler(const Quat &q, float *ang,int type);
void DllExport EulerToQuat(float *ang, Quat &q,int type);
void DllExport MatrixToEuler(const Matrix3 &mat, float *ang,int type);
void DllExport EulerToMatrix(float *ang, Matrix3 &mat,int type);
float DllExport GetEulerQuatAngleRatio(Quat &quat1,Quat &quat2, float *euler1, float *euler2, int type = EULERTYPE_XYZ);
float DllExport GetEulerMatAngleRatio(Matrix3 &mat1,Matrix3 &mat2, float *euler1, float *euler2, int type = EULERTYPE_XYZ);

#endif // __EULER__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\dpoint3.h ===
/**********************************************************************
 *<
	FILE: dpoint3.h

	DESCRIPTION:

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __DPOINT3__ 

#define __DPOINT3__

#include "point3.h"

class ostream;

class DPoint3 {
public:
	double x,y,z;

	// Constructors
	DPoint3(){}
	DPoint3(double X, double Y, double Z)  { x = X; y = Y; z = Z;  }
	DPoint3(const DPoint3& a) { x = a.x; y = a.y; z = a.z; } 
	DPoint3(const Point3& a) { x = a.x; y = a.y; z = a.z; } 
	DPoint3(double af[3]) { x = af[0]; y = af[1]; z = af[2]; }

	// Access operators
	double& operator[](int i) { return (&x)[i]; }     
	const double& operator[](int i) const { return (&x)[i]; }  

 	// Conversion function
	operator double*() { return(&x); }

 	// Unary operators
	DPoint3 operator-() const { return(DPoint3(-x,-y,-z)); } 
	DPoint3 operator+() const { return *this; } 

	// Assignment operators
	DllExport DPoint3& operator=(const Point3& a) {	x = a.x; y = a.y; z = a.z;	return *this; }
	DllExport DPoint3& operator-=(const DPoint3&);
	DllExport DPoint3& operator+=(const DPoint3&);
	DllExport DPoint3& operator*=(double);
	DllExport DPoint3& operator/=(double);

	// Binary operators
	DllExport DPoint3 operator-(const DPoint3&) const;
	DllExport DPoint3 operator+(const DPoint3&) const;
	DllExport double operator*(const DPoint3&) const;		// DOT PRODUCT
	DllExport DPoint3 operator^(const DPoint3&) const;	// CROSS PRODUCT

	};

double DllExport Length(const DPoint3&); 
int DllExport MaxComponent(const DPoint3&);  // the component with the maximum abs value
int DllExport MinComponent(const DPoint3&);  // the component with the minimum abs value
DPoint3 DllExport Normalize(const DPoint3&); // Return a unit vector.

DPoint3 DllExport operator*(double, const DPoint3&);	// multiply by scalar
DPoint3 DllExport operator*(const DPoint3&, double);	// multiply by scalar
DPoint3 DllExport operator/(const DPoint3&, double);	// divide by scalar

ostream DllExport &operator<<(ostream&, const DPoint3&); 
	 
// Inlines:

inline double Length(const DPoint3& v) {	
	return (double)sqrt(v.x*v.x+v.y*v.y+v.z*v.z);
	}

inline DPoint3& DPoint3::operator-=(const DPoint3& a) {	
	x -= a.x;	y -= a.y;	z -= a.z;
	return *this;
	}

inline DPoint3& DPoint3::operator+=(const DPoint3& a) {
	x += a.x;	y += a.y;	z += a.z;
	return *this;
	}

inline DPoint3& DPoint3::operator*=(double f) {
	x *= f;   y *= f;	z *= f;
	return *this;
	}

inline DPoint3& DPoint3::operator/=(double f) { 
	x /= f;	y /= f;	z /= f;	
	return *this; 
	}

inline DPoint3 DPoint3::operator-(const DPoint3& b) const {
	return(DPoint3(x-b.x,y-b.y,z-b.z));
	}

inline DPoint3 DPoint3::operator+(const DPoint3& b) const {
	return(DPoint3(x+b.x,y+b.y,z+b.z));
	}

inline double DPoint3::operator*(const DPoint3& b) const {  
	return(x*b.x+y*b.y+z*b.z);	
	}

inline DPoint3 operator*(double f, const DPoint3& a) {
	return(DPoint3(a.x*f, a.y*f, a.z*f));
	}

inline DPoint3 operator*(const DPoint3& a, double f) {
	return(DPoint3(a.x*f, a.y*f, a.z*f));
	}

inline DPoint3 operator/(const DPoint3& a, double f) {
	return(DPoint3(a.x/f, a.y/f, a.z/f));
	}

DPoint3 DllExport CrossProd(const DPoint3& a, const DPoint3& b);	// CROSS PRODUCT
	
double DllExport DotProd(const DPoint3& a, const DPoint3& b) ;		// DOT PRODUCT

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\custcont.h ===
/**********************************************************************
 *<
	FILE: custcont.h

	DESCRIPTION: Custom Controls for Jaguar

	CREATED BY: Rolf Berteig

	HISTORY: created 17 November, 1994

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __CUSTCONT__
#define __CUSTCONT__

#include "winutil.h"
#include "buildver.h"

void CoreExport InitCustomControls( HINSTANCE hInst );

#ifdef DESIGN_VER
// VIZ window tinting APIs
void     CoreExport EnableWindowTinting(bool flag = true);
void     CoreExport SetWindowTint(const HWND hwnd, const COLORREF color);
void     CoreExport ChangeWindowTint(const HWND hwnd, const COLORREF color);
COLORREF CoreExport GetWindowTint(const HWND hwnd);
COLORREF CoreExport GetAncestorTint(const HWND hwnd);
#endif

// Values returned by DADMgr::SlotOwner()
#define OWNER_MEDIT_SAMPLE 		0
#define OWNER_NODE 				1
#define OWNER_MTL_TEX			2  //  button in mtl or texture
#define OWNER_SCENE				3  //  button in light, modifier, atmospheric, etc
#define OWNER_BROWSE_NEW		4
#define OWNER_BROWSE_LIB		5
#define OWNER_BROWSE_MEDIT		6
#define OWNER_BROWSE_SCENE		7

class ReferenceTarget;

class DADMgr {
	public:
		// Called on the source to see what if anything can be dragged from this x,y
		// returns 0 if can't drag anything from this point
		virtual SClass_ID GetDragType(HWND hwnd, POINT p)=0;


		// Return TRUE if creating instance witb "new", rather than returning
		// a pointer to an existing entity.
		// If GetInstance creates a new instance every time it is called, then IsNew should
		// return TRUE. This prevents GetInstance from being called repeatedly as the
		// drag progresses.
		virtual BOOL IsNew(HWND hwnd, POINT p, SClass_ID type) { return FALSE; } 

		// called on potential target to see if can drop type at this x,y
		virtual BOOL OkToDrop(ReferenceTarget *dropThis, HWND hfrom, HWND hto, POINT p, SClass_ID type, BOOL isNew = FALSE)=0;

		// called on potential target to allow it to substitute custom cursors. (optional)
		virtual HCURSOR DropCursor(ReferenceTarget *dropThis, HWND hfrom, HWND hto, POINT p, SClass_ID type, BOOL isNew = FALSE){ return NULL;}

		// Return one of the OWNER_ values above
		virtual int SlotOwner() { return OWNER_MTL_TEX; } 
		 
		// This should return a pointer to the drag source.  HWND is the window the mouse
		// down occured in, and p is the position in that window.  Type tells the expected
		// type of object.
		virtual ReferenceTarget *GetInstance(HWND hwnd, POINT p, SClass_ID type)=0;

		// This routine is called on the target with the pointer returned by the source's GetInstance,
		// or possibly a clone of it as the dropThis.   hwnd is where the mouse was released
		// for the drop, p is the position within hwnd, and type is the type of object
		// being dropped.
		virtual void  Drop(ReferenceTarget *dropThis, HWND hwnd, POINT p, SClass_ID type)=0;

		// This is called when the source and target WINDOW are the same
		virtual void  SameWinDragAndDrop(HWND h1, POINT p1, POINT p2) {}

		// This lets the manager know whether to call LocalDragAndDrop when the
		// same DADMgr handles both source and target windows.
		virtual BOOL  LetMeHandleLocalDAD() { return 0; }

		// This is called if the same DADMgr is handling both the source and target windows,
		// if LetMeHandleLocalDAD() returned true.
		virtual void  LocalDragAndDrop(HWND h1, HWND h2, POINT p1, POINT p2){}

		// If this returns true, the CustButtons that have this DADManager
		// will automatically make their text a tooltip
		virtual BOOL AutoTooltip(){ return FALSE; }

		// If a drag source doesn't want any references being made to the instance returned,
		// then this method should return true: it will force a copy to be made.
		virtual BOOL CopyOnly(HWND hwnd, POINT p, SClass_ID type) { return FALSE; } 

		// Normally the mouse down and mouse up messages are not sent to the 
		// source window when doing DAD, but if you need them, return TRUE
		virtual BOOL AlwaysSendButtonMsgsOnDrop(){ return FALSE; }

		// Generic expansion function
		virtual int Execute(int cmd, ULONG arg1=0, ULONG arg2=0, ULONG arg3=0) { return 0; } 
	};


class ICustomControl {
	public:
		virtual HWND GetHwnd()=0;
		virtual void Enable(BOOL onOff=TRUE)=0;
		virtual void Disable()=0;
		virtual BOOL IsEnabled()=0;
		// this second enable function is used to disable and enable custom controls
		// when the associated parameter has a non-keyframable parameter.
		// The effective enable state is the AND of these two enable bits.
		virtual void Enable2(BOOL onOff=TRUE)=0;
		// Generic expansion function
		virtual int Execute(int cmd, ULONG arg1=0, ULONG arg2=0, ULONG arg3=0) { return 0; } 
	};

// This is a bitmap brush where the bitmap is a gray and white checker board.
HBRUSH CoreExport GetLTGrayBrush();
HBRUSH CoreExport GetDKGrayBrush();

// Makes the grid pattern brushes solid for screen shots
void CoreExport MakeBrushesSolid(BOOL onOff);

// The standard font...
HFONT CoreExport GetFixedFont();

// The hand cursor used for panning.
HCURSOR CoreExport GetPanCursor();

// Used to update the new mouse-tracking outlined buttons
void CoreExport UpdateButtonOutlines();

//----------------------------------------------------------------------------//
// Customizable UI Frame 

#define CUIFRAMECLASS _T("CUIFrame")

// CUI Frame content types
#define CUI_TOOLBAR			(1<<0)		// set if frame holds toolbars and/or tool palettes
#define CUI_MENU			(1<<1)		// set if frame holds a menu
#define CUI_HWND			(1<<2)		// set if frame hold a generic hWnd

// CUI Frame position types
#define CUI_TOP_DOCK		(1<<0)
#define CUI_BOTTOM_DOCK		(1<<1)
#define CUI_LEFT_DOCK		(1<<2)
#define CUI_RIGHT_DOCK		(1<<3)
#define CUI_ALL_DOCK		(CUI_TOP_DOCK|CUI_BOTTOM_DOCK|CUI_LEFT_DOCK|CUI_RIGHT_DOCK)
#define CUI_HORIZ_DOCK		(CUI_TOP_DOCK|CUI_BOTTOM_DOCK)
#define CUI_VERT_DOCK		(CUI_LEFT_DOCK|CUI_RIGHT_DOCK)
#define CUI_FLOATABLE		(1<<4)
#define CUI_FLOATING		(1<<4)	// synonym
#define CUI_CONNECTABLE		(1<<5)
#define CUI_SM_HANDLES		(1<<6)		// set if frame should display size/move handles

// CUI Docking Panel locations
#define CUI_NO_PANEL		0
#define CUI_TOP_PANEL		CUI_TOP_DOCK
#define CUI_BOTTOM_PANEL	CUI_BOTTOM_DOCK
#define CUI_LEFT_PANEL		CUI_LEFT_DOCK
#define CUI_RIGHT_PANEL		CUI_RIGHT_DOCK
#define CUI_FIXED_PANELS	(CUI_TOP_PANEL|CUI_BOTTOM_PANEL|CUI_LEFT_PANEL|CUI_RIGHT_PANEL)
#define CUI_FLOATING_PANELS (1<<4)
#define CUI_ALL_PANELS		(CUI_FIXED_PANELS|CUI_FLOATING_PANELS)

#define CUI_POSDATA_MSG		(WM_APP + 0x3412)	// used for retrieving CUIFrame position data

// orientation parameters
#define CUI_NONE			0
#define CUI_HORIZ			CUI_HORIZ_DOCK
#define CUI_VERT			CUI_VERT_DOCK
#define CUI_FLOAT			CUI_FLOATING

#define CUI_MIN_TB_WIDTH	25		// minimum width of a CUIFrame-based toolbar

#define CUI_MENU_HIDE			0
#define CUI_MENU_SHOW_ENABLED	1
#define CUI_MENU_SHOW_DISABLED	2

// CUI size parameters
#define CUI_MIN_SIZE			0
#define CUI_MAX_SIZE			1
#define CUI_PREF_SIZE			2

// CUI bitmap button image size (in pixels: 16x15 or 24x24)
#define CUI_SIZE_16				16
#define CUI_SIZE_24				24

// CUI bitmap button image mask options
#define CUI_MASK_NONE			0	// no mask -- MAX should generate one
#define CUI_MASK_MONO			1	// normal Windows convention
#define CUI_MASK_ALPHA			2	// 8-bit alpha channel present
#define CUI_MASK_ALPHA_PREMULT	3	// 8-bit pre-multiplied alpha channel present

// CUI edit types -- not all implemented (yet?)
#define CUI_EDIT_NONE			0
#define CUI_EDIT_KBD			(1<<0)
#define CUI_EDIT_SCRIPT			(1<<1)
#define CUI_EDIT_MACRO			(CUI_EDIT_KBD | CUI_EDIT_SCRIPT)
#define CUI_EDIT_ORDER			(1<<2)

class CUIPosData 
{
public:
	virtual ~CUIPosData()									{}
	virtual int GetWidth(int sizeType, int orient)			{ return 50; }
	virtual int GetHeight(int sizeType, int orient)			{ return 50; }
};

// Provides a way for messages received by the CUIFrame to be processed
// in a context-specific fashion.  ProcessMessage should return TRUE 
// if the message is handled and FALSE if not.  If FALSE is returned (or
// no handler is defined), then the CUIFrame simply passes WM_COMMAND
// messages on to its parent.  Window position messages are passed from
// the CUIFrame to the HWND of the 'content' (either toolbar or menu)
// Other messages are passed on to DefaultWndProc.

class CUIFrameMsgHandler
{
public:
	virtual int ProcessMessage(UINT message, WPARAM wParam, LPARAM lParam) { return FALSE; }
};

class ICustButton;
class ICustStatus;

class ICUIFrame : public ICustomControl {
public:
	// CUIFrame attributes
	virtual	void SetPosType(DWORD t)=0;
	virtual	DWORD GetPosType()=0;
	virtual void SetPosRank(int rank, int subrank=0)=0;
	virtual int GetPosRank()=0;
	virtual int GetPosSubrank()=0;
	virtual BOOL IsFloating()=0;
	virtual void Hide(BOOL b)=0;
	virtual BOOL IsHidden()=0;
	virtual void SetCurPosition(DWORD pos)=0;
	virtual DWORD GetCurPosition()=0;
	virtual void SetContentType(DWORD t)=0;
	virtual DWORD GetContentType()=0;
	virtual void SetContentHandle(HWND hContent)=0;
	virtual HWND GetContentHandle()=0;
	virtual void SetTabbedToolbar(BOOL b)=0;
	virtual BOOL GetTabbedToolbar()=0;
	virtual void AddToolbarTab(HWND hTBar, CUIFrameMsgHandler *msgHandler, TCHAR *name, int pos = -1)=0;
	virtual void DeleteToolbarTab(int pos)=0;
	virtual int GetToolbarCount()=0;
	virtual HWND GetToolbarHWnd(int pos)=0;
	virtual TCHAR *GetTabName(int pos)=0;
	virtual void SetCurrentTab(int pos)=0;
	virtual int GetCurrentTab()=0;
	virtual int GetSize(int sizeType, int dir /* width or height */, int orient)=0;
	virtual BOOL InstallMsgHandler(CUIFrameMsgHandler *msgHandler)=0;
	virtual void SetName(TCHAR *name)=0;	// name is used to store position info
	virtual TCHAR *GetName()=0;
	virtual BOOL SetMenuDisplay(int md)=0;
	virtual int GetMenuDisplay()=0;
	virtual void SetSystemWindow(BOOL b)=0;	// set to TRUE for main UI, only works if parent is the main MAX hWnd
	virtual BOOL GetSystemWindow()=0;
	virtual BOOL ReadConfig(TCHAR *cfg, int startup=FALSE)=0;	// returns FALSE if no position has been saved
	virtual void WriteConfig(TCHAR *cfg)=0;
};

ICUIFrame CoreExport *GetICUIFrame( HWND hCtrl );
void CoreExport ReleaseICUIFrame( ICUIFrame *icf );


HWND CoreExport CreateCUIFrameWindow(HWND hParent, TCHAR *title, int x, int y, int cx, int cy);

#define CUI_MODE_NORMAL		0
#define CUI_MODE_EDIT		1

class CUIFrameMgr {
private:
	HWND	hApp;
	TSTR	cfgFile;
	void	RecalcPanel(int panel);
	int		GetMaxRank(int panel);
	int		GetMaxSubrank(int panel, int rank);
	void	GetDockRect(int panel, int rank, RECT *rp);
	int		GetDockingRank(int panel, RECT *rp = NULL);
	int		GetDockingSubrank(int panel, int rank, RECT *rp = NULL);
	void	AdjustRanks(int panel, int start, int incr);
	void	AdjustSubranks(int panel, int rank, int start, int incr);
	int		resSize[4];
	int		mode;
	int		horizTextBtns;
	int		fixedWidthTextBtns;
	int		btnWidth;
	int		imageSize;
	int		lockLayout;
	CUIFrameMsgHandler *defMsgHandler;
	HIMAGELIST defImage16;
	HIMAGELIST defImage24;

public:
	CoreExport CUIFrameMgr();
	CoreExport ~CUIFrameMgr();
	CoreExport void SetAppHWnd(HWND hApp);
	CoreExport TCHAR *GetCUIDirectory();
	CoreExport void ProcessCUIMenu(HWND hWnd, int x, int y);
	CoreExport void DockCUIWindow(HWND hWnd, int panel, RECT *rp = NULL, int init = FALSE);
	CoreExport void FloatCUIWindow(HWND hWnd, RECT *rp = NULL, int init = FALSE);
	CoreExport void SetReservedSize(int panel, int size);
	CoreExport int GetReservedSize(int panel);
	CoreExport int GetPanelSize(int panel, int incReserved = FALSE);
	CoreExport void RecalcLayout(int entireApp=FALSE);
	CoreExport void DrawCUIWindows(int panels=CUI_ALL_PANELS);
	CoreExport int OverDockRegion(LPPOINT pt, DWORD posType, int override = FALSE);
	CoreExport void SetMode(int md);
	CoreExport int GetMode();
	CoreExport void ExpertMode(int onOff);
	CoreExport void HideFloaters(int onOff);
	CoreExport HWND GetItemHwnd(int id);
	CoreExport ICustButton *GetICustButton( int id );
	CoreExport ICustStatus *GetICustStatus( int id );
	CoreExport void HorizTextButtons(BOOL b);
	CoreExport int GetHorizTextButtons();
	CoreExport void FixedWidthTextButtons(BOOL b);
	CoreExport int GetFixedWidthTextButtons();
	CoreExport void SetTextButtonWidth(int w);
	CoreExport int GetTextButtonWidth();
	CoreExport int GetCount();
	CoreExport ICUIFrame *GetICUIFrame(int i);
	CoreExport ICUIFrame *GetICUIFrame(TCHAR *name);
	CoreExport ICUIFrame *GetICUIFrame(int panel, int rank, int subrank);
	CoreExport int SetConfigFile(TCHAR *cfg);
	CoreExport TCHAR *GetConfigFile();
	CoreExport int DeleteSystemWindows(int toolbarsOnly = TRUE);
	CoreExport int CreateSystemWindows(int reset = FALSE);
	CoreExport void SetImageSize(int size)	{ imageSize = size; }
	CoreExport int GetImageSize()			{ return imageSize; }
	CoreExport int GetButtonHeight(int sz=0) { if(!sz) sz=imageSize; return sz==CUI_SIZE_16 ? 22 : 31; }
	CoreExport int GetButtonWidth(int sz=0)  { if(!sz) sz=imageSize; return sz==CUI_SIZE_16 ? 23 : 32; }
	CoreExport void SetDefaultData(CUIFrameMsgHandler *msg, HIMAGELIST img16, HIMAGELIST img24=NULL) 
				{ defMsgHandler = msg; defImage16 = img16; defImage24 = img24; }
	CoreExport HIMAGELIST GetDefaultImageList(int sz=0)	
				{ if(!sz) sz=imageSize; return ((sz==CUI_SIZE_16) || !defImage24) ? defImage16 : defImage24; }
	CoreExport int AddToImageList(TCHAR *groupName, HBITMAP i16, HBITMAP m16, HBITMAP i24, HBITMAP m24);
	CoreExport int LoadBitmapFile(TCHAR *filename);
	CoreExport int LoadBitmapImages();
	CoreExport int GetImageGroupCount();
	CoreExport TCHAR *GetImageGroupName(int i);
	CoreExport int GetGroupImageCount(int i);	
	CoreExport int GetTotalImageCount();
	CoreExport int GetGroupStartIndex(int i);
	CoreExport int GetGroupStartIndex(TCHAR *groupName);
	CoreExport CUIFrameMsgHandler *GetDefaultMsgHandler()	{ return defMsgHandler; }
	CoreExport int ReadConfig();
	CoreExport int WriteConfig();
	CoreExport void SetLockLayout(BOOL lock)	{ lockLayout = lock; }
	CoreExport BOOL GetLockLayout()				{ return lockLayout; }
	CoreExport void EnableAllCUIWindows(int enabled);
};

CUIFrameMgr CoreExport *GetCUIFrameMgr();
CoreExport void DoCUICustomizeDialog();
CoreExport BOOL AllFloatersAreHidden();


#define MB_TYPE_KBD			1
#define MB_TYPE_SCRIPT		2

class MacroButtonData {
	public:
		CoreExport	MacroButtonData()	{ label = tip = imageName = NULL; imageID = -1; }
		// constructor for kbd-based macro buttons
		CoreExport	MacroButtonData(long tID, void *cb, int cID, TCHAR *lbl, TCHAR *tp=NULL, int imID=-1, TCHAR *imName=NULL)
				{
				macroType=MB_TYPE_KBD; tblID=tID; this->cb=cb; cmdID=cID; imageID=imID;
				label=NULL; SetLabel(lbl); tip=NULL; SetTip(tp); imageName=NULL; SetImageName(imName); 
				}
		CoreExport	MacroButtonData(int msID, TCHAR *lbl, TCHAR *tp=NULL, int imID=-1, TCHAR *imName=NULL)
				{
				macroType=MB_TYPE_SCRIPT; macroScriptID=msID; imageID=imID; 
				label=NULL; SetLabel(lbl); tip=NULL; SetTip(tp); imageName=NULL; SetImageName(imName);
				}
		CoreExport	~MacroButtonData()	{ if(label) delete [] label;  if(tip) delete [] tip; if(imageName) delete[] imageName; }

		CoreExport	MacroButtonData & operator=(const MacroButtonData& mbd);

		CoreExport	void SetLabel(TCHAR *lbl);
					TCHAR *GetLabel()		{ return label; }
		CoreExport	void SetTip(TCHAR *tp);
					TCHAR *GetTip()			{ return tip; }
					void SetCmdID(int id)	{ cmdID = id; }
					int GetCmdID()			{ return cmdID; }
					void SetScriptID(int id){ macroScriptID = id; }
					int GetScriptID()		{ return macroScriptID; }
		CoreExport	void SetImageName(TCHAR *imName);
					TCHAR *GetImageName()	{ return imageName; }
					void SetImageID(int id)	{ imageID = id; }
					int GetImageID()		{ return imageID; }

		int			macroType;
		long		tblID;	// ShortcutTableID, but type not defined yet!
		void		*cb;	// ShortcutCallback, but not defined yet!
		int			cmdID;
		int			macroScriptID;
		TCHAR *		label;
		TCHAR *		tip;

		TCHAR *		imageName;
		int			imageID;
		// need bitmap references, script name or id, etc...
	};

//---------------------------------------------------------------------------//
// Spinner control


#define SPINNERWINDOWCLASS	_T("SpinnerControl")


// LOWORD(wParam) = ctrlID, 
// HIWORD(wParam) = TRUE if user is dragging the spinner interactively.
// lParam = pointer to ISpinnerControl
#define CC_SPINNER_CHANGE  		WM_USER + 600	

// LOWORD(wParam) = ctrlID, 
// lParam = pointer to ISpinnerControl
#define CC_SPINNER_BUTTONDOWN	WM_USER + 601

// LOWORD(wParam) = ctrlID, 
// HIWORD(wParam) = FALSE if user cancelled - TRUE otherwise
// lParam = pointer to ISpinnerControl
#define CC_SPINNER_BUTTONUP		WM_USER + 602


enum EditSpinnerType {
	EDITTYPE_INT, 
	EDITTYPE_FLOAT, 
	EDITTYPE_UNIVERSE, 
	EDITTYPE_POS_INT, 
	EDITTYPE_POS_FLOAT, 
	EDITTYPE_POS_UNIVERSE,
	EDITTYPE_TIME
	};

class ISpinnerControl : public ICustomControl {
	public:
		virtual float GetFVal()=0;
		virtual int GetIVal()=0;
		virtual void SetAutoScale(BOOL on=TRUE)=0;
		virtual void SetScale( float s )=0;
		virtual void SetValue( float v, int notify )=0;
		virtual void SetValue( int v, int notify )=0;
		virtual void SetLimits( int min, int max, int limitCurValue = TRUE )=0;
		virtual void SetLimits( float min, float max, int limitCurValue = TRUE )=0;
		virtual void LinkToEdit( HWND hEdit, EditSpinnerType type )=0;
		virtual void SetIndeterminate(BOOL i=TRUE)=0;
		virtual BOOL IsIndeterminate()=0;
		virtual void SetResetValue(float v)=0;
		virtual void SetResetValue(int v)=0;
		virtual void SetKeyBrackets(BOOL onOff)=0;
	};

ISpinnerControl CoreExport *GetISpinner( HWND hCtrl );
void CoreExport ReleaseISpinner( ISpinnerControl *isc );

CoreExport void SetSnapSpinner(BOOL b);
CoreExport BOOL GetSnapSpinner();
CoreExport void SetSnapSpinValue(float f);
CoreExport float GetSnapSpinValue();

CoreExport void SetSpinnerPrecision(int p);
CoreExport int GetSpinnerPrecision();

CoreExport void SetSpinnerWrap(int w);
CoreExport int GetSpinnerWrap();


// begin - mjm 12.18.98
//---------------------------------------------------------------------------
// Slider control

#define SLIDERWINDOWCLASS	_T("SliderControl")

// LOWORD(wParam) = ctrlID, 
// HIWORD(wParam) = TRUE if user is dragging the slider interactively.
// lParam = pointer to ISliderControl
#define CC_SLIDER_CHANGE  		WM_USER + 611

// LOWORD(wParam) = ctrlID, 
// lParam = pointer to ISliderControl
#define CC_SLIDER_BUTTONDOWN	WM_USER + 612

// LOWORD(wParam) = ctrlID, 
// HIWORD(wParam) = FALSE if user cancelled - TRUE otherwise
// lParam = pointer to ISliderControl
#define CC_SLIDER_BUTTONUP		WM_USER + 613

class ISliderControl : public ICustomControl
{
public:
	virtual float GetFVal()=0;
	virtual int GetIVal()=0;
	virtual void SetNumSegs( int num )=0;
	virtual void SetValue( float v, int notify )=0;
	virtual void SetValue( int v, int notify )=0;
	virtual void SetLimits( int min, int max, int limitCurValue = TRUE )=0;
	virtual void SetLimits( float min, float max, int limitCurValue = TRUE )=0;
	virtual void LinkToEdit( HWND hEdit, EditSpinnerType type )=0;
	virtual void SetIndeterminate(BOOL i=TRUE)=0;
	virtual BOOL IsIndeterminate()=0;
	virtual void SetResetValue(float v)=0;
	virtual void SetResetValue(int v)=0;
	virtual void SetKeyBrackets(BOOL onOff)=0;
};

ISliderControl CoreExport *GetISlider( HWND hCtrl );
void CoreExport ReleaseISlider( ISliderControl *isc );

// mjm - 3.1.99 - use spinner precision for edit boxes linked to slider controls
/*
CoreExport void SetSliderPrecision(int p);
CoreExport int  GetSliderPrecision();
*/

// routines for setting up sliders.
CoreExport ISliderControl *SetupIntSlider(HWND hwnd, int idSlider, int idEdit,  int min, int max, int val, int numSegs);
CoreExport ISliderControl *SetupFloatSlider(HWND hwnd, int idSlider, int idEdit,  float min, float max, float val, int numSegs);
CoreExport ISliderControl *SetupUniverseSlider(HWND hwnd, int idSlider, int idEdit,  float min, float max, float val, int numSegs);

// controls whether or not sliders send notifications while the user adjusts them with the mouse
CoreExport void SetSliderDragNotify(BOOL onOff);
CoreExport BOOL GetSliderDragNotify();
// end - mjm 12.18.98


//---------------------------------------------------------------------------//
// Rollup window control

#define ROLLUPWINDOWCLASS _T("RollupWindow")

typedef void *RollupState;

// Flags passed to AppendRollup
#define APPENDROLL_CLOSED	(1<<0)	// Starts the page out rolled up.
#define DONTAUTOCLOSE    	(1<<1)	// Dont close this rollup when doing Close All

class IRollupWindow : public ICustomControl {
	public:
		// Shows or hides all
		virtual void Show()=0;
		virtual void Hide()=0;

		// Shows or hides by index
		virtual void Show(int index)=0;
		virtual void Hide(int index)=0;

		virtual HWND GetPanelDlg(int index)=0;
		virtual int GetPanelIndex(HWND hWnd)=0;
		virtual void SetPanelTitle(int index,TCHAR *title)=0;

		// returns index of new panel
		virtual int AppendRollup( HINSTANCE hInst, TCHAR *dlgTemplate, 
				DLGPROC dlgProc, TCHAR *title, LPARAM param=0,DWORD flags=0 )=0;
		virtual int ReplaceRollup( int index, HINSTANCE hInst, TCHAR *dlgTemplate, 
				DLGPROC dlgProc, TCHAR *title, LPARAM param=0,DWORD flags=0 )=0;
		virtual void DeleteRollup( int index, int count )=0;
		virtual void SetPageDlgHeight(int index,int height)=0;

		virtual void SaveState( RollupState *hState )=0;
		virtual void RestoreState( RollupState *hState )=0;

		// Passing WM_LBUTTONDOWN, WM_MOUSEMOVE, and WM_LBUTTONUP to
		// this function allows scrolling with unused areas in the dialog.
		virtual void DlgMouseMessage( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam )=0;

		virtual int GetNumPanels()=0;
		virtual BOOL IsPanelOpen(int index) = 0;
		virtual void SetPanelOpen(int index, BOOL isOpen) =0;
		virtual int GetScrollPos()=0;
		virtual void SetScrollPos(int spos)=0;

	};

// This function returns TRUE if a particular rollup panel is open given
// a handle to the dialog window in the panel.
CoreExport BOOL IsRollupPanelOpen(HWND hDlg);

IRollupWindow CoreExport *GetIRollup( HWND hCtrl );
void CoreExport ReleaseIRollup( IRollupWindow *irw );

//----------------------------------------------------------------------------//
// CustEdit control

#define CUSTEDITWINDOWCLASS _T("CustEdit")

// Sent when the user hits the enter key in an edit control.
// wParam = cust edit ID
// lParam = HWND of cust edit control.
#define WM_CUSTEDIT_ENTER	(WM_USER+685)

class ICustEdit : public ICustomControl {
	public:
		virtual void GetText( TCHAR *text, int ct )=0;
		virtual void SetText( TCHAR *text )=0;	
		virtual void SetText( int i )=0;
		virtual void SetText( float f, int precision=3 )=0;
		virtual int GetInt(BOOL *valid=NULL)=0;
		virtual float GetFloat(BOOL *valid=NULL)=0;
		virtual void SetLeading(int lead)=0;
		virtual void WantReturn(BOOL yesNo)=0;
		virtual BOOL GotReturn()=0;		// call this on receipt of EN_CHANGE
		virtual void GiveFocus()=0;
		virtual BOOL HasFocus()=0;
		virtual void WantDlgNextCtl(BOOL yesNo)=0;
		virtual void SetNotifyOnKillFocus(BOOL onOff)=0;
		virtual void SetBold(BOOL onOff)=0;
	};

ICustEdit CoreExport *GetICustEdit( HWND hCtrl );
void CoreExport ReleaseICustEdit( ICustEdit *ice );

#define CUSTSTATUSEDITWINDOWCLASS _T("CustStatusEdit")

class ICustStatusEdit : public ICustomControl {
	public:
		virtual void GetText( TCHAR *text, int ct )=0;
		virtual void SetText( TCHAR *text )=0;	
		virtual void SetText( int i )=0;
		virtual void SetText( float f, int precision=3 )=0;
		virtual int GetInt(BOOL *valid=NULL)=0;
		virtual float GetFloat(BOOL *valid=NULL)=0;
		virtual void SetLeading(int lead)=0;
		virtual void WantReturn(BOOL yesNo)=0;
		virtual BOOL GotReturn()=0;		// call this on receipt of EN_CHANGE
		virtual void GiveFocus()=0;
		virtual BOOL HasFocus()=0;
		virtual void WantDlgNextCtl(BOOL yesNo)=0;
		virtual void SetNotifyOnKillFocus(BOOL onOff)=0;
		virtual void SetBold(BOOL onOff)=0;
		virtual void SetReadOnly(BOOL onOff)=0;
	};

ICustStatusEdit CoreExport *GetICustStatusEdit( HWND hCtrl );
void CoreExport ReleaseICustStatusEdit( ICustStatusEdit *ice );

//----------------------------------------------------------------------------//
// CustButton control

#define CUSTBUTTONWINDOWCLASS _T("CustButton")

#define CC_COMMAND  		WM_USER + 700
// send these with CC_COMMAND: wParam = CC_???
#define CC_CMD_SET_TYPE  		23		// lParam = CBT_PUSH, CBT_CHECK
#define CC_CMD_SET_STATE		24		// lParam = 0/1 for popped/pushed
#define CC_CMD_HILITE_COLOR		25		// lParam = RGB packed int

#define RED_WASH	RGB(255,192,192)
#define GREEN_WASH	RGB(192,255,192)
#define BLUE_WASH	RGB(192,192,255)

enum CustButType { CBT_PUSH, CBT_CHECK };

// If the button is set to notify on button down, it will send a WM_COMMAND
// with this notify code when the user touches the button.
#define BN_BUTTONDOWN 	8173
// It will also send this message when the mouse is released regardless
// if the mouse is released inside the toolbutton rectangle
#define BN_BUTTONUP		8174

// If a button is set to notify on right clicks,  it will send a WM_COMMAND
// with this notify code when the user right clicks on the button.
#define BN_RIGHTCLICK 	8183

// When the user chooses a new fly-off item, this notify code will be sent.
#define BN_FLYOFF		8187


// When the user presses a button a WM_MENUSELECT message is sent so that
// the client can display a status prompt describing the function of
// the tool. The fuFlags parameter is set to this value:
#define CMF_TOOLBUTTON	9274

class FlyOffData {
	public:
		int iOutEn;
		int iInEn;
		int iOutDis;
		int iInDis;		
	};

// Directions the fly off will go.
#define FLY_VARIABLE	1
#define FLY_UP			2
#define FLY_DOWN		3
#define FLY_HVARIABLE	4 // horizontal variable
#define FLY_LEFT		5
#define FLY_RIGHT		6

typedef LRESULT CALLBACK PaintProc(HDC hdc, Rect rect, BOOL in, BOOL checked, BOOL enabled);

class ICustButton : public ICustomControl {
	public:
		virtual void GetText( TCHAR *text, int ct )=0;
		virtual void SetText( TCHAR *text )=0;			
		virtual void SetImage( HIMAGELIST hImage, 
			int iOutEn, int iInEn, int iOutDis, int iInDis, int w, int h )=0;
		virtual void SetType( CustButType type )=0;
		virtual void SetFlyOff(int count,FlyOffData *data,int timeOut,int init,int dir=FLY_VARIABLE, int columns=1)=0;
		virtual void SetCurFlyOff(int f,BOOL notify=FALSE)=0;
		virtual int GetCurFlyOff()=0;
		virtual BOOL IsChecked()=0;
		virtual void SetCheck( BOOL checked )=0;
		virtual void SetCheckHighlight( BOOL highlight )=0;
		virtual void SetButtonDownNotify(BOOL notify)=0;
		virtual void SetRightClickNotify(BOOL notify)=0;
		virtual void SetHighlightColor(COLORREF clr)=0;
		virtual void SetTooltip(BOOL onOff, LPSTR text)=0;
		virtual void SetDADMgr(DADMgr *dad)=0;
		virtual DADMgr *GetDADMgr()=0;
		virtual void SetMacroButtonData(MacroButtonData *md)=0;
		virtual MacroButtonData *GetMacroButtonData()=0;
		virtual void SetDisplayProc(PaintProc *proc)=0;
		virtual TCHAR* GetCaptionText(void)=0;
		virtual bool SetCaptionText(const TCHAR* text)=0;
	};

ICustButton CoreExport *GetICustButton( HWND hCtrl );
void CoreExport ReleaseICustButton( ICustButton *icb );


//---------------------------------------------------------------------------//
// CustStatus

#define CUSTSTATUSWINDOWCLASS _T("CustStatus")

enum StatusTextFormat {
	STATUSTEXT_LEFT,
	STATUSTEXT_CENTERED,
	STATUSTEXT_RIGHT };


class ICustStatus : public ICustomControl {
	public:
		virtual void SetText(TCHAR *text)=0;
		virtual void SetTextFormat(StatusTextFormat f)=0;
		virtual void GetText(TCHAR *text, int ct)=0;
		virtual void SetTooltip(BOOL onOff, LPSTR text)=0;
	};

ICustStatus CoreExport *GetICustStatus( HWND hCtrl );
void CoreExport ReleaseICustStatus( ICustStatus *ics );

//---------------------------------------------------------------------------//
// CustSeparator -- for use on toolbars

#define CUSTSEPARATORWINDOWCLASS _T("CustSeparator")

class ICustSeparator : public ICustomControl {
	public:
		virtual void SetVisibility(BOOL onOff)=0;
		virtual BOOL GetVisibility()=0;
	};

ICustSeparator CoreExport *GetICustSeparator( HWND hCtrl );
void CoreExport ReleaseICustSeparator( ICustSeparator *ics );


//----------------------------------------------------------------------------//
// CustToolbar control

#define CUSTTOOLBARWINDOWCLASS _T("CustToolbar")

#ifdef _OSNAP 
	#define VERTTOOLBARWINDOWCLASS _T("VertToolbar")

#endif

// Sent in a WM_COMMAND when the user right clicks in open space
// on a toolbar.
#define TB_RIGHTCLICK 	0x2861

enum ToolItemType { 
	CTB_PUSHBUTTON, 
	CTB_CHECKBUTTON, 
	CTB_MACROBUTTON,	// DB 10/27/98
	CTB_SEPARATOR,
	CTB_STATUS,
	CTB_OTHER
#ifdef _OSNAP
	, CTB_IMAGE
#endif
	};

// toolbar orientation
#define CTB_NONE		CUI_NONE
#define CTB_HORIZ		CUI_HORIZ
#define CTB_VERT		CUI_VERT
#define CTB_FLOAT		CUI_FLOAT

class ToolItem {
	public: 
		ToolItemType type;
		int id;
		DWORD helpID;
		int w, h;
		int orient;	// which orientations does this item apply to?
		virtual ~ToolItem() {}
	};

class ToolButtonItem : public ToolItem {
	public:		
		int iOutEn, iInEn;
		int iOutDis, iInDis;
		int iw;
		int ih;		
		TCHAR *label;
		ToolButtonItem(ToolItemType t,
			int iOE, int iIE, int iOD, int iID,
			int iW, int iH, int wd,int ht, int ID, DWORD hID=0, TCHAR *lbl = NULL,
			int or = CTB_HORIZ|CTB_VERT|CTB_FLOAT)
			{ 
			type = t; 
			orient = or;
			iOutEn = iOE; iInEn = iIE; iOutDis = iOD; iInDis = iID;
			iw = iW; ih = iH; w = wd; h = ht; id = ID; helpID = hID;
			label = lbl;
			}		
	};

class ToolMacroItem : public ToolItem {
	public:		
		MacroButtonData md;
		ToolMacroItem(int wd, int ht, MacroButtonData *data, int or = CTB_HORIZ|CTB_VERT|CTB_FLOAT)
			{ 
			type = CTB_MACROBUTTON;
			md = *data; 
			orient = or;
			w = wd; h = ht; id = 0; helpID = 0;
			}
	};

class ToolSeparatorItem : public ToolItem {
	public:
		int vis;
		ToolSeparatorItem(int w, int h=16 /* for backwards compat! */, BOOL vis=TRUE, int or=CTB_HORIZ|CTB_VERT|CTB_FLOAT) {
			type = CTB_SEPARATOR;
			id = 0;
			helpID = 0;
			this->w = w;
			this->h = h;
			h = 0;
			this->vis = vis;
			orient = or;
			} 
	};

class ToolStatusItem : public ToolItem {
	public:
		BOOL fixed;
		ToolStatusItem(int w, int h,BOOL f,int id, DWORD hID=0, int or = CTB_HORIZ|CTB_FLOAT) {
			type = CTB_STATUS;
			this->w = w;
			this->h = h;
			this->id = id;
			this->helpID = hID;
			fixed = f;
			orient = or;
			}
	};

#define CENTER_TOOL_VERTICALLY	0xffffffff

class ToolOtherItem : public ToolItem {
	public:
		int	  y;
		DWORD style;
		TCHAR *className;
		TCHAR *windowText;
		ToolOtherItem(TCHAR *cls,int w,int h,int id,DWORD style=WS_CHILD|WS_VISIBLE,
					int y=CENTER_TOOL_VERTICALLY,TCHAR *wt=NULL,DWORD hID=0, int or=CTB_HORIZ|CTB_FLOAT) {
			type = CTB_OTHER;
			this->y = y;
			this->w = w;
			this->h = h;
			this->id = id;
			this->helpID = hID;
			this->style = style;
			orient = or;
			className = cls;
			windowText = wt;
			}		
	};


#ifdef _OSNAP  //allow image controls on toolbars
class ToolImageItem : public ToolItem {
	public:
		int	  y;
		int	il_index;
		ToolImageItem(int w,int h,int k,int id, int y=CENTER_TOOL_VERTICALLY,DWORD hID=0, int or=CTB_HORIZ|CTB_FLOAT) {
			type = CTB_IMAGE;
			this->y = y;
			this->w = w;
			this->h = h;
			this->il_index  = k;
			this->id = id;
			this->helpID = hID;
			orient = or;
			}		
	};
#endif

class ICustToolbar : public ICustomControl {
	public:
		virtual void SetImage( HIMAGELIST hImage )=0;
		virtual void AddTool( ToolItem& entry, int pos=-1)=0;
        virtual void AddTool2(ToolItem& entry, int pos=-1)=0; // Adds caption buttons to toolbars
		virtual void DeleteTools( int start, int num=-1 )=0;  // num = -1 deletes 'start' through count-1 tools
		virtual void SetBottomBorder(BOOL on)=0;
		virtual void SetTopBorder(BOOL on)=0;
		virtual int	 GetNeededWidth(int rows)=0;	// return width needed for specified # of rows
		virtual void SetNumRows(int rows)=0;
		virtual ICustButton *GetICustButton( int id )=0;
		virtual ICustStatus *GetICustStatus( int id )=0;
		virtual HWND GetItemHwnd(int id)=0;
		virtual int GetNumItems()=0;
		virtual int GetItemID(int index)=0;
		virtual int FindItem(int id)=0;
		virtual void DeleteItemByID(int id)=0;
		virtual void LinkToCUIFrame( HWND hCUIFrame, CUIFrameMsgHandler *msgHandler)=0;
		virtual void GetFloatingCUIFrameSize(SIZE *sz, int rows=1)=0;
		virtual ICustStatusEdit *GetICustStatusEdit(int id)=0;
	};

ICustToolbar CoreExport *GetICustToolbar( HWND hCtrl );
void CoreExport ReleaseICustToolbar( ICustToolbar *ict );

#ifdef _OSNAP
class IVertToolbar : public ICustomControl {
	public:
		virtual void SetImage( HIMAGELIST hImage )=0;
		virtual void AddTool( const ToolItem& entry, int pos=-1 )=0;
		virtual void DeleteTools( int start, int num=-1 )=0;  // num = -1 deletes 'start' through count-1 tools
		virtual void SetBottomBorder(BOOL on)=0;
		virtual void SetTopBorder(BOOL on)=0;
		virtual ICustButton *GetICustButton( int id )=0;
		virtual ICustStatus *GetICustStatus( int id )=0;		
		virtual HWND GetItemHwnd(int id)=0;
		virtual void Enable(BOOL onOff=TRUE){};
	};

IVertToolbar CoreExport *GetIVertToolbar( HWND hCtrl );
void CoreExport ReleaseIVertToolbar( IVertToolbar *ict );

#endif


//---------------------------------------------------------------------------//
// CustImage


#define CUSTIMAGEWINDOWCLASS _T("CustImage")

class ICustImage : public ICustomControl {
	public:
		virtual void SetImage( HIMAGELIST hImage,int index, int w, int h )=0;		
	};

ICustImage CoreExport *GetICustImage( HWND hCtrl );
void CoreExport ReleaseICustImage( ICustImage *ici );

#ifdef _OSNAP
//---------------------------------------------------------------------------//
// CustImage 2D Version for displaying osnap icons


#define CUSTIMAGEWINDOWCLASS2D  _T("CustImage2D")

class ICustImage2D : public ICustomControl {
	public:
		virtual void SetImage( HIMAGELIST hImage,int index, int w, int h )=0;		
	};

//ICustImage CoreExport *GetICustImage2D( HWND hCtrl );
//void CoreExport ReleaseICustImage2D( ICustImage2D *ici );
#endif


//------------------------------------------------------------------------
// Off Screen Buffer

class IOffScreenBuf {
	public:
		virtual HDC GetDC()=0;
		virtual void Erase(Rect *rct=NULL)=0;
		virtual void Blit(Rect *rct=NULL)=0;
		virtual void Resize()=0;
		virtual void SetBkColor(COLORREF color)=0;
		virtual COLORREF GetBkColor()=0;
	};

CoreExport IOffScreenBuf *CreateIOffScreenBuf(HWND hWnd);
CoreExport void DestroyIOffScreenBuf(IOffScreenBuf *iBuf);


//------------------------------------------------------------------------
// Color swatch control
// Puts up the ColorPicker when user right clicks on it.
//

// This message is sent as the color is being adjusted in the 
// ColorPicker.
// LOWORD(wParam) = ctrlID, 
// HIWORD(wParam) = 1 if button UP 
//                = 0 if mouse drag.
// lParam = pointer to ColorSwatchControl
#define CC_COLOR_CHANGE			WM_USER + 603

// LOWORD(wParam) = ctrlID, 
// lParam = pointer to ColorSwatchControl
#define CC_COLOR_BUTTONDOWN		WM_USER + 606

// LOWORD(wParam) = ctrlID, 
// HIWORD(wParam) = FALSE if user cancelled - TRUE otherwise
// lParam = pointer to ColorSwatchControl
#define CC_COLOR_BUTTONUP		WM_USER + 607

// This message is sent if the color has been clicked on, before 
// bringing up the color picker.
// LOWORD(wParam) = ctrlID, 
// HIWORD(wParam) = 0 
// lParam = pointer to ColorSwatchControl
#define CC_COLOR_SEL			WM_USER + 604


// This message is sent if another color swatch has been dragged and dropped
// on this swatch. 
// LOWORD(wParam) = toCtrlID, 
// HIWORD(wParam) = 0
// lParam = pointer to ColorSwatchControl
#define CC_COLOR_DROP			WM_USER + 605



#define COLORSWATCHWINDOWCLASS _T("ColorSwatch")

class IColorSwatch: public ICustomControl {
	public:
		// sets only the varying color of the color picker if showing
		virtual COLORREF SetColor(COLORREF c, int notify=FALSE)=0;  // returns old color

		// sets both the varying color and the "reset"color of the color picker
		virtual COLORREF InitColor(COLORREF c, int notify=FALSE)=0;  // returns old color

		virtual COLORREF GetColor()=0;
		virtual void ForceDitherMode(BOOL onOff)=0;
		virtual void SetModal()=0;
		virtual void Activate(int onOff)=0;
		virtual void EditThis(BOOL startNew=TRUE)=0;
		virtual void SetKeyBrackets(BOOL onOff)=0;
	};

IColorSwatch CoreExport *GetIColorSwatch( HWND hCtrl, COLORREF col, TCHAR *name);
IColorSwatch CoreExport *GetIColorSwatch(HWND hCtrl);
void CoreExport ReleaseIColorSwatch( IColorSwatch *ics );



//---------------------------------------------------------------------------//
// DragAndDrop Window


#define DADWINDOWCLASS	_T("DragDropWindow")

typedef LRESULT CALLBACK WindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

class IDADWindow : public ICustomControl {
	public:
		// Installing this makes it do drag and drop.
		virtual void SetDADMgr( DADMgr *dadMgr)=0;
		virtual DADMgr *GetDADMgr()=0;
		
		// Install Window proc called to do all the normal things after 
		// drag/and/drop processing is done.
		virtual void SetWindowProc( WindowProc *proc)=0;

	};

IDADWindow CoreExport *GetIDADWindow( HWND hWnd);
void CoreExport ReleaseIDADWindow( IDADWindow *idw );



//------------------------------------------------------------------------
// Window thumb tack

// This function installs a thumb tack in the title bar of a window
// which allows the user to make it an always on top window.
// NOTE: The window class for the window should have 4 extra bytes in 
// the window structure for SetWindowLong().
CoreExport void InstallThumbTack(HWND hwnd);
CoreExport void RemoveThumbTack(HWND hwnd);

// Handy routines for setting up Spinners.
CoreExport ISpinnerControl *SetupIntSpinner(HWND hwnd, int idSpin, int idEdit,  int min, int max, int val);
CoreExport ISpinnerControl *SetupFloatSpinner(HWND hwnd, int idSpin, int idEdit,  float min, float max, float val, float scale = 0.1f);
CoreExport ISpinnerControl *SetupUniverseSpinner(HWND hwnd, int idSpin, int idEdit,  float min, float max, float val, float scale = 0.1f);

// Controls whether or not spinners send notifications while the user adjusts them with the mouse
CoreExport void SetSpinDragNotify(BOOL onOff);
CoreExport BOOL GetSpinDragNotify();

//---------------------------------------------------------------------------
//

CoreExport void DisableAccelerators();
CoreExport void EnableAccelerators();
CoreExport BOOL AcceleratorsEnabled();

CoreExport void SetSaveRequiredFlag(BOOL b=TRUE);
CoreExport BOOL GetSaveRequiredFlag();
CoreExport BOOL IsSaveRequired();


#endif // __CUSTCONT__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\evuser.h ===
/*********************************************************************
 *<
	FILE: evuser.h

	DESCRIPTION: Event user functionality

	CREATED BY:	Tom Hudson

	HISTORY: Created 16 June 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

/**********************************************************************
How to use:

This is a set of classes which form a generic notification system.  To
use:

* Create an EventUser object.

* Register the EventUser object with the appropriate router.

* The EventRouter will call your EventUser's Notify() method when
the event occurs.

* When you're done with the EventUser object, call the EventRouter's
UnRegister() method.  This will delete the EventUser from the router's
notification system.

* If your code is part of a window proc, call the router's Register
and UnRegister methods when the window receives WM_ACTIVATE messages.
This will properly uncouple the notification system when the window is
deactivated.

**********************************************************************/

#ifndef __EVUSER__
#define __EVUSER__

class EventUser {
	public:
		virtual void Notify()=0;
	};

#endif // __EVUSER__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\export.h ===
#ifdef DllExport
#undef DllExport
#endif

#ifdef IMPORTING
#define DllExport	__declspec( dllimport )
#else
#define DllExport	__declspec( dllexport )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\evrouter.h ===
/*********************************************************************
 *<
	FILE: evrouter.h

	DESCRIPTION: Event router functionality

	CREATED BY:	Tom Hudson

	HISTORY: Created 16 June 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#ifndef __EVROUTER__
#define __EVROUTER__

#include "evuser.h"

typedef EventUser* PEventUser;
typedef Tab<PEventUser> PEventUserTab;

class EventRouter {
	private:
		PEventUserTab	userTab;
		BOOL			notifyMultiple;
	public:
		EventRouter(BOOL multiple = FALSE)	{ notifyMultiple = multiple; }
		CoreExport void Register(EventUser *user);
		CoreExport void UnRegister(EventUser *user);
		// Process the event.  Returns TRUE if the event was handed off to a user.
		CoreExport BOOL Process();
	};

extern CoreExport EventRouter deleteRouter;
extern CoreExport EventRouter backspaceRouter;
#ifdef _OSNAP
	extern CoreExport EventRouter tabkeyRouter;
#endif

#endif // __EVROUTER__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\exprlib.h ===
#ifndef _EXPRLIB_H_

#define _EXPRLIB_H_

#define IMPORTING
#include "expr.h"
#undef IMPORTING

#endif // _EXPRLIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\expr.h ===
/**********************************************************************
 *<
	FILE: expr.h

	DESCRIPTION: expression object include file.

	CREATED BY: Don Brittain

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef _EXPR_H_

#define _EXPR_H_

#include "export.h"

#define SCALAR_EXPR		1
#define VECTOR_EXPR		3

#define SCALAR_VAR		SCALAR_EXPR
#define VECTOR_VAR		VECTOR_EXPR

class Expr;

typedef int (*ExprFunc)(Expr *e, float f);

class DllExport Inst {
public:
    ExprFunc	func;
    float  		sVal;
};

class ExprVar {
public:
	TSTR		name;
	int			type;
	int			regNum;
};

MakeTab(float);
MakeTab(Point3);
MakeTab(Inst);
MakeTab(ExprVar);

class Expr {
public:
	Expr()	{ sValStk = vValStk = instStk = nextScalar = nextVector = 0; }
	~Expr()	{ deleteAllVars(); }

	DllExport int		load(char *s);
	DllExport int		eval(float *ans, int sRegCt, float *sRegs, int vRegCt=0, Point3 *vRegs=NULL);
	int					getExprType(void)	{ return exprType; }
	TCHAR *				getExprStr(void)	{ return origStr; }
	TCHAR *				getProgressStr(void){ return progressStr; }
	DllExport int		defVar(int type, TCHAR *name);
	DllExport int		getVarCount(int type);
	DllExport TCHAR *	getVarName(int type, int i);
	DllExport int		getVarRegNum(int type, int i);
	DllExport BOOL		deleteAllVars();
	DllExport BOOL		deleteVar(TCHAR *name);

// pseudo-private: (only to be used by the "instruction" functions
	void		setExprType(int type)	{ exprType = type; }
	void		pushInst(ExprFunc fn, float f) 
					{ if(instStk >= inst.Count()) inst.SetCount(instStk+30); 
					inst[instStk].func = fn; inst[instStk++].sVal = f; }
	void		pushSVal(float f)	{ if(sValStk>=sVal.Count())sVal.SetCount(sValStk+10);sVal[sValStk++]=f; }
	float		popSVal()			{ return sVal[--sValStk]; }
	void		pushVVal(Point3 &v)	{ if(vValStk>=vVal.Count())vVal.SetCount(vValStk+10);vVal[vValStk++]=v; }
	Point3 &	popVVal()			{ return vVal[--vValStk]; }
	int			getSRegCt(void)		{ return sRegCt; }
	float		getSReg(int index)	{ return sRegPtr[index]; }
	int			getVRegCt(void)		{ return vRegCt; }
	Point3 &	getVReg(int index)	{ return vRegPtr[index]; }

	ExprVarTab	vars;			// named variables
private:
	TCHAR *		exprPtr;		// pointer to current str pos during parsing
	TCHAR *		exprStr;		// ptr to original expression string to parse
	TSTR		origStr;		// original expression string that was loaded
	TSTR		progressStr;	// string to hold part of expr successfully parsed
	int			sRegCt;			// actual number of scalar registers passed to "eval"
	float		*sRegPtr;		// pointer to the scalar register array
	int			vRegCt;			// actual number of vector registers passed to "eval"
	Point3		*vRegPtr;		// pointer to the vector register array
	int			exprType;		// expression type: SCALAR_EXPR or VECTOR_EXPR (set by load)

	int			sValStk;		// scalar value stack
	floatTab	sVal;
	int			vValStk;		// vector value stack
	Point3Tab	vVal;
	int			instStk;		// instruction stack
	InstTab		inst;

	int			nextScalar;		// next scalar slot
	int			nextVector;		// next vector slot

	friend		yylex();
	friend		yyerror(char *);
};

#define EXPR_NORMAL			 0
#define EXPR_INST_OVERFLOW	-1	// instruction stack overflow during parsing
#define EXPR_UNKNOWN_TOKEN	-2  // unknown function, const, or reg during parsing
#define EXPR_TOO_MANY_VARS	-3	// value stack overflow
#define EXPR_TOO_MANY_REGS	-4	// register array overflow, or reg number too big
#define EXPR_CANT_EVAL		-5	// function can't be evaluated with given arg
#define EXPR_CANT_PARSE		-6	// expression can't be parsed (syntactically)

#endif // _EXPR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\filters.h ===
//-----------------------------------------------------------------------------
// --------------------
// File ....: Filters.h
// --------------------
// Author...: Gus Grubba
// Date ....: September 1995
//
// History .: Sep, 07 1995 - Started
//
//-----------------------------------------------------------------------------
		
#ifndef    FILTERS_H_DEFINED
#define    FILTERS_H_DEFINED

#include <fltapi.h>
#include <tvnode.h>

//-- Just to make it shorter

#define dVirtual FLTExport virtual

//-- How long can a filter name be

#define MAXFILTERNAME  MAX_PATH
#define MAXRESOURCE    MAX_PATH

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//-- Frame Range
//
	
class FrameRange {

		int start;
		int end;
		int current;
		
	 public:
	 
		FLTExport       FrameRange  ( ) {start = end = current  = 0;}
		FLTExport       ~FrameRange ( ) {};

		FLTExport int   First       ( ) {   return (start); }
		FLTExport int   Last        ( ) {   return (end); }
		FLTExport int   Count       ( ) {   return (end - start + 1); }
		FLTExport int   Current     ( ) {   return (current);   }
		FLTExport int   Elapsed     ( ) {   return (current -   start); }

		FLTExport void  SetFirst    ( int u ) { start = u; }
		FLTExport void  SetLast     ( int u ) { end = u; }
		FLTExport void  SetCurrent  ( int u ) { current = u; }


};

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//--   Forward Reference

class ImageFilter;
class FilterManager;

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//-- Time Change Notification (R2)

class TimeChange : public TimeChangeCallback {
	public:
		BOOL set;
		TimeChange () { set = FALSE; }
		ImageFilter *filter;
		void TimeChanged(TimeValue t);
};

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//--   Filter Info
//
	
enum MaskType {
	MASK_R = 0,  
	MASK_G, 
	MASK_B, 
	MASK_A, 
	MASK_L, 
	MASK_Z, 
	MASK_MTL_ID,
	MASK_NODE_ID

};

#define NUMMASKFLAGS (MASK_NODE_ID - MASK_R) + 1

class ImageFilterInfo {

		//-- Name of the filter used internally for identitification.

		TCHAR            name[MAXFILTERNAME];

		//-- Filters may want to identify themselves by something more  
		//   specific than their names. Specially filters that give names
		//   to parameter sets. If "resource" below is not empty, it
		//   will be used to identify the filter in the Video Post Queue.
		//   This is saved along with everything else by the host (Max).
		//   If all the filter needs is a resource to identify a set of
		//   parameters, this will sufice.

		TCHAR            resource[MAXRESOURCE];

		//-- Plug-In Parameter Block ------------------------------------------
		//
		//    No direct access to clients. Use the  methods in the  filter class.
		//

		void             *pidata;
		DWORD            pisize;

		//-- New R2 Stuff

		TCHAR			*userlabel;		//-- Optional label given by user
		ITrackViewNode	*node;			//-- TV Node (if any)
		Class_ID		nodeid;			//-- TV Node ID (if any);

		int				flttype;

	public:

		FLTExport        ImageFilterInfo                  ( );
		FLTExport       ~ImageFilterInfo                  ( );

		//-- Mask Information -------------------------------------------------

		BOOL                         maskenabled,evCopy;
		BOOL                         invertedmask;
		BitmapInfo                   mask;
		WORD                         maskflag;
		
		//-- This is a BitmapInfo that holds information about the current 
		//   Video Post main queue Image buffer. This can be used to get
		//   VP's (or target image) resolution, etc. To make an analogy, if
		//   this was a BitmapIO plug-in, this is the BitmapInfo given as
		//   the argument. This used primarilly at the time the filter
		//   receives the "Setup()" call as at render time, all this can be
		//   found in srcmap.

		BitmapInfo                   imgQueue;

		//-- Internal Helpers -------------------------------------------------

		FLTExport void              SetName         ( const TCHAR *n )    { _tcscpy(name,n);}
		FLTExport void              SetResource     ( const TCHAR *n )    { _tcscpy(resource,n);}
		FLTExport const TCHAR		*Name           ( )   { return    (const TCHAR *)name;}
		FLTExport const TCHAR		*Resource       ( )   { return    (const TCHAR *)resource;}
		
		//-- Plug-In Parameter Block ------------------------------------------
		
		FLTExport void              *GetPiData      ( ) { return pidata; }
		FLTExport void              SetPiData       ( void    *ptr ) { pidata = ptr; }
		FLTExport DWORD          	GetPiDataSize   ( )   { return    pisize; }
		FLTExport void              SetPiDataSize   ( DWORD s ) { pisize = s; }
		FLTExport void              ResetPiData     ( );
		FLTExport BOOL              AllocPiData     ( DWORD size  );

		FLTExport ImageFilterInfo &operator= (  ImageFilterInfo &from );
		
		//-- Load/Save
		
		FLTExport IOResult       	Save            ( ISave *isave );
		FLTExport IOResult       	Load            ( ILoad *iload, Interface *max );
		
		//-- Execution  Info ---------------------------------------------------
		//
		//    12/06/95 - GG
		//
		//    QueueRange defines    the entire Video Post Queue range. Execution
		//    is only the portion being rendered. This is, unless   the user    selects
		//    a "range", the same as QueueRange. FilterRange is where this  filter
		//    starts    and ends.
		//
		//    Video Post Queue
		//
		//              1         2         3         4         5
		//    0----|----|----|----|----|----|----|----|----|----|----|----|----|---- ...
		//
		//    Video Post spans from 0 to 49 (QueueRange) Start: 0  End: 49
		//
		//    qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq
		//
		//    User executes a "range" from 10 to 30 (Execution Range) Start: 10 End: 30
		//
		//                  uuuuuuuuuuuuuuuuuuuuu
		//
		//    This filter appears in the queue from 5 to 35 (Filter Range) Start: 5 End: 35
		//
		//           fffffffffffffffffffffffffffffff        

		FrameRange                   QueueRange;              //-- Entire Video Post Queue
		FrameRange                   ExecutionRange;          //-- Segement being rendered
		FrameRange                   FilterRange;             //-- Filter Segment
		
		//----------------------------------------------------------------------
		//-- R2 Stuff Below ----------------------------------------------------
		//----------------------------------------------------------------------
	
		//-- Trackview Node Functions ------------------------------------------

		FLTExport ITrackViewNode	*Node	( ) 				{ return node;	}
		FLTExport void				SetNode (ITrackViewNode	*n) { node = n;		}

		FLTExport Class_ID			NodeID		( )		 		{ return nodeid;}
		FLTExport void				SetNodeID	( Class_ID id )	{ nodeid = id;  }

		//-- Optional Label given by user while adding or editing a filter. This label
		//   replaces the filter's name in Video Post's tracks for easier identification.

		FLTExport TCHAR				*UserLabel		( )			{ return userlabel; }

		//-- Used by VP to update the label. Not to be used by filters.

		FLTExport void				SetUserLabel	( TCHAR *l)	{ userlabel = l; }

		//-- Used to determine what type of filter this is at "Setup" time.

		#define	FLT_FILTER	0
		#define	FLT_LAYER	1

		FLTExport int				FilterType		( )	{ return flttype; }
		FLTExport void				SetFilterType	( int type ) { flttype = type; }

};

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//--   Filter Plug-Ins Handler
//
	
class FLT_FilterHandler {

		//-- Name and Capabilities  ------------------------
		
		TCHAR         fltDescription[MAXFILTERNAME];    
		DWORD         fltCapability;

		//-- DLL    Handler ----------------------------------
		
		ClassDesc *cd;
		
	public:

		FLT_FilterHandler();
		
		FLTExport TCHAR           *Description        ( const TCHAR  *d = NULL  );

		FLTExport void             SetCD              ( ClassDesc *dll )    { cd = dll;}
		FLTExport ClassDesc       *GetCD              ( )                   { return    cd;}

		FLTExport void             SetCapabilities  ( DWORD cap )      { fltCapability |= cap;}
		FLTExport DWORD            GetCapabilities  ( )                { return    (fltCapability);}
		FLTExport BOOL             TestCapabilities ( DWORD cap )      { return    (fltCapability  & cap);}

};

//-----------------------------------------------------------------------------
//--   Messages    sent back by various    (client)    methods

//--   Sent by the plug-in to notify   host of current progress. The   host should
// return TRUE if  it's ok to continue or FALSE to abort process.

#define    FLT_PROGRESS    WM_USER + 0x20    //-- wParam:  Current lParam: Total

//--   Sent by the plug-in to check for    process interruption. The host should
// return FALSE (by setting *lParam) if it's   ok  to  continue    or  TRUE to abort 
// process.

#define	FLT_CHECKABORT	WM_USER + 0x21    //-- wParam:  0         lParam: BOOL*

//--   Sent by the plug-in to display an optional textual  message (for progress
// report).

#define	FLT_TEXTMSG		WM_USER + 0x22    //-- wParam:  0         lParam: LPCTSTR

//--   Sent by the host TO the plug-in to notify the time has changed (the user
// moved the time slider in Max).

#define    FLT_TIMECHANGED	WM_USER + 0x23    //-- wParam:  0         lParam: TimeValue t

//--   Sent by the host TO the plug-in to notify that an Undo operation has been done.
// The plugin will set some boolean internally and wait for the next WM_PAINT message
// in order to update any spinners or other values that may have been undone.

#define    FLT_UNDO		WM_USER + 0x24    //-- wParam:  0         lParam: 0

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//--   List of Filter  Plug-Ins
//
	
class FLT_FilterList: public   Tab<FLT_FilterHandler> {

		BOOL        listed;
		 
	public:

		FLT_FilterList        ( )           { listed    = FALSE;    }

		BOOL        Listed    ( BOOL    f)  { listed    = f; return (listed);};
		BOOL        Listed    ( )           { return    (listed);};

		FLTExport int    FindFilter              ( const TCHAR *name );
		FLTExport DWORD  GetFilterCapabilities   ( const TCHAR *name );

		//-- This Creates   an  Instance    - Make sure to  "delete"    it  after   use.

		FLTExport ImageFilter *CreateFilterInstance(const TCHAR *d);

};

//-----------------------------------------------------------------------------
//-- Undo Notification

class UndoNotify : public TVNodeNotify {
	HWND hWnd;
public:
	UndoNotify (HWND hwnd) {hWnd = hwnd;}
	RefResult NotifyRefChanged	(Interval changeInt, RefTargetHandle hTarget, 
			PartID& partID,  RefMessage message) {
			SendMessage(hWnd,FLT_UNDO,0,0);
			InvalidateRect(hWnd,NULL,FALSE);
			return(REF_SUCCEED);
	}
};

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//--   ImageFilter Capability Flags
//
// It  is  valid   for a   plug-in to both Filter and  Compositor. If  both flags are
// set, the    user will be able   to  select it from  both the    Filter list and from
// the Compositor  list.   The plug-in will know it is running as  a filter    when
// the foreground  map pointer is  NULL.
//

#define IMGFLT_NONE              0      //  None

#define IMGFLT_MASK              (1<<0) //  Supports Masking
#define IMGFLT_CONTROL           (1<<1) //  Plug-In has a Control Panel
#define IMGFLT_FILTER            (1<<2) //  Plug-In is a Filter
#define IMGFLT_COMPOSITOR        (1<<3) //  Plug-In is a Compositor
#define IMGFLT_THREADED          (1<<4) //  Thread aware plug-in

//-- Class ID's for various DLL's

#define NEGATIVECLASSID 0x4655434A
#define ALPHACLASSID    0x655434A4
#define ADDCLASSID      0x55434A46
#define BLURCLASSID     0x5434A465
#define CROSFADECLASSID 0x434A4655
#define GLOWCLASSID     0x35A46554
#define COOKIECLASSID   0x4A465543
#define WIPECLASSID     0xA4655434
#define FADECLASSID     0x4655434B
#define PDALPHACLASSID  0x655434B4

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//--   Image   Filter Class
//

class ImageFilter {
	
	protected:

		BOOL	interactive;
		HWND	vpSetuphWnd,vphWnd,dlghWnd;

		//-- Bitmap Pointers --------------------------------------------------
		//
		// All filters will have at least a pointer to "srcmap". This is VP's
		// (or any other process') main image pipeline.
		//
		// Composition filters will also receive a second [frgmap] bitmap
		// which should be composited above the main [srcmap] bitmap.
		//
		// If "mskmap" is not NULL, it will contain a pointer to a grayscale
		// image to be used as a mask for the process.
		//
		// 12/06/95 - GG
		//
		// The srcmap (Background) is the Video Post queue bitmap. Use its
		// methods to find out dimmensions (width, height, aspect ratio, etc.)
		// If the queue is using Alpha channel, it will be noted in the bitmap
		// flags (srcmap). The same is true for Z and G buffers. Again, simply
		// use the bitmap methods to access these.
		//
		
		Bitmap                      *srcmap;         //--   Source (Background)
		Bitmap                      *mskmap;         //--   Mask (Grayscale Masking)
		Bitmap                      *frgmap;         //--   Foreground (for layering/transitions)
		
		//-- Set    by  Host ----------------------------------
		
		ImageFilterInfo         *ifi;
		
	public:
	
		FLTExport	ImageFilter     ( );
		dVirtual	~ImageFilter	( );
		
		//-- Filter Info    ---------------------------------
		
		dVirtual     const TCHAR    *Description      ( ) = 0; // ASCII description (i.e. "Convolution Filter")
		dVirtual     const TCHAR    *AuthorName       ( ) = 0; // ASCII Author name
		dVirtual     const TCHAR    *CopyrightMessage ( ) = 0; // ASCII Copyright message
		dVirtual     UINT            Version          ( ) = 0; // Version number * 100 (i.e. v3.01 = 301)
		dVirtual     DWORD           Capability       ( ) = 0; // Returns capability flags (see above)

		//-- Dialogs ----------------------------------------------------------
		//
		//    An About Box  is  mandatory. The  Control panel is optional and   its 
		//    existence should be flagged   by  the Capability  flag above.
		//

		dVirtual     void            ShowAbout         ( HWND    hWnd ) =    0;
		dVirtual     BOOL            ShowControl       ( HWND    hWnd ) {    return FALSE; }

		//-- Parameter  Setting (Host's Responsability) ----

		dVirtual     void            SetSource         ( Bitmap *map )     {srcmap = map;}
		dVirtual     void            SetForeground     ( Bitmap *map )     {frgmap = map;}
		dVirtual     void            SetMask           ( Bitmap *map )     {mskmap = map;}
		dVirtual     void            SetFilterInfo     ( ImageFilterInfo *i ) {ifi   = i;}

		//-- Execution  ------------------------------------
		//
		//    The   "hWnd" argument is a    window handler  to  which
		//    the   plug-in will be sending messages.

		dVirtual     BOOL            Render            ( HWND    hWnd ) =    0;

		//-- Max    Interface ----------------------------------------------------
		//
		//    Some of Max's core functions exported through the Interface class.
		//

		dVirtual  Interface *Max  ( );

		//-- Helpers --------------------------------------

		dVirtual  int     Lerp    (int a, int b, int l);
		dVirtual  int     Lerp    (int a, int b, float f);
		
		//-- Parameter  Block   Load and    Save ------------------------------------
		//
		//   The host will  call EvaluateConfigure() to determine the   buffer size
		//   required by the plug-in.
		//
		//   SaveConfigure() will be called so the  plug-in can transfer    its
		//   parameter block to the host ( ptr is a pre-allocated   buffer).
		//
		//   LoadConfigure() will be called so the  plug-in can load its    
		//   parameter block back.
		//   
		//   Memory management is performed by the  host using standard
		//   LocalAlloc() and   LocalFree().
		//   
		
		dVirtual  DWORD   EvaluateConfigure  ( )           { return 0; }
		dVirtual  BOOL    LoadConfigure      ( void *ptr ) { return (FALSE); }
		dVirtual  BOOL    SaveConfigure      ( void *ptr ) { return (FALSE); }

		//-- Preview Facility -------------------------------------------------
		//
		//    This is used  by  plug-ins    that want to have   a preview bitmap while
		//    displaying its control dialogue.
		//
		//    The   flag controls how   much of the queue   to  run:
		//
		//    PREVIEW_BEFORE - The queue is run up  to  the event before the    filter
		//    calling it.
		//
		//    PREVIEW_UP ----- The queue is run up  to  the event (filter) calling
		//    this function.
		//
		//    PREVIEW_WHOLE -- The whole queue is run   including events after
		//    this filter.
		//
		//    The   given   frame   is  the Video Post  Queue   frame   number and not  Max's
		//    frame number.
		//
		//
		//    Parameters:
		//
		//    hWnd -    WIndow handle to send messages to. These are    the progress,
		//    check for abort, text messages    etc. If the plug in wants to support
		//    a cancel button   and progress bars   etc, it must handle these messages.
		//    It is Ok to send a    NULL window handle in which case    nothing is checked.
		//
		//    back -    Pointer to a Bitmap pointer. If the Bitmap pointer  is  NULL,   a
		//    new   bitmap is created   using   the given dimmensions. This pointer must be
		//    NULL the first time this  function    is  called as the bitmap    must be
		//    created by Video Post. Once   this function is called and a   bitmap is
		//    returned, it  is  ok  to  call it again using this map.   In  this case, Video
		//    Post will simply use it instead of creating a new one.    You must    delete
		//    the   bitmap when done.
		//
		//    fore -    For layer plug-ins, this points to the  foreground image.   This is
		//    only valid if flag    is  set to PREVIEW_BEFORE. In this case back will hold  
		//    Video Post main   queue   and fore    will have the foreground image to be 
		//    composited. This is usefull   if  you, a layer plug-in, want  to  collect the 
		//    images    and run a real  time preview. If flag is not PREVIEW_BEFORE,    fore
		//    will be a NULL pointer indicating there   is  no  bitmap.
		//
		//    frame - The desired frame. Make sure  you request a frame within  the
		//    range your plug-in    is  active.
		//
		//    width & height - Self explanatory.
		//
		//    flag -    Explained above.
		//

		#ifndef PREVIEW_BEFORE
		#define PREVIEW_BEFORE  1
		#define PREVIEW_UP      2
		#define PREVIEW_WHOLE   3
		#endif

		dVirtual    BOOL CreatePreview  ( 
				HWND hWnd,                      //-- Window handle to send  messages    to
				Bitmap **back,                  //-- Pointer to Bitmap Pointer (Background)
				int frame,                      //-- Desired Frame
				int width,                      //-- Desired Width
				int height,                     //-- Desired Height
				float   aspect,                 //-- Desired Aspect Ratio
				Bitmap **fore   = NULL,         //-- Pointer to Bitmap Pointer (Foreground)
				DWORD   flag    = PREVIEW_UP );

		//----------------------------------------------------------------------
		//-- Channels Required
		//
		//    By setting this   flag,   the plug-in can request the host    to  generate
		//    the   given   channels. Prior to Rendering,   the host    will scan the
		//    plug-ins in the   chain   of  events and list all types of channels
		//    being requested. The plug-in, at the  time of the Render()    call,   
		//    will have access to these channels through    the channel interface
		//    described in  Bitmap.h    - BitmapStorage.
		//
		//    The   generation of these channels should not, normally,  be  a 
		//    default setting   for a   plug-in.    These   channels    are memory hungry   and
		//    if the    plug-in won't use   it, it should not   ask for it. Normally
		//    the   plug-in would ask   the user    which   channels    to  use and set only
		//    the   proper flags.
		//
		
		dVirtual     DWORD   ChannelsRequired       ( ) {   return BMM_CHAN_NONE; }
		

		//----------------------------------------------------------------------
		//-- R2 Stuff Below ----------------------------------------------------
		//----------------------------------------------------------------------
	
		TimeChange	timeChange;
		UndoNotify*	undonotify;

		dVirtual HWND	DlgHandle			( void ) { return dlghWnd; }

		//-- Filter Control Dialogue Interactivity -----------------------------

		dVirtual void	MakeDlgInteractive	( HWND hWnd );
		dVirtual BOOL	IsInteractive		( void ) { return interactive; }

		//-- Trackview Node Functions ------------------------------------------

		dVirtual ITrackViewNode *CreateNode ( );
		dVirtual ITrackViewNode *Node ( ) { return ifi->Node(); }

		//-- FilterUpdate() ----------------------------------------------------
		//
		// Whenever a filter instance is created or updated (i.e. the user went,
		// through the Filter Edit Control dialogue) this is call is issued to 
		// the filter. The filter may use it to create/update its node controls.
		//
		// See example in negative.cpp.

		dVirtual void	FilterUpdate	( ) { }

};

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//--   Main Filter Manager Class
//
//

class FilterManager    {
	
		TCHAR                   name[MAXFILTERNAME];
		FLTInterface            *iface;
		ImageFilterInfo         *ifi;
		Interface               *max;

		//-- General Private    Methods
		
		BOOL                    SetupPlugIn                 ( HWND hWnd, WORD   item );
		void                    HandleMaskFile              ( HWND hWnd, WORD   item );
		
		//-- Image Filter   Private Methods
		
		int                     GetCurrentFilter            ( HWND hWnd, TCHAR *plugin  );
		void                    HandleFilterDialogState     ( HWND hWnd );

	public:
	
		FLTExport                   FilterManager           ( FLTInterface  *i);
		FLTExport                   FilterManager           ( FLTInterface  *i,const    TCHAR   *name);
		FLTExport                   ~FilterManager          ( );
		
		FLTExport FLTInterface  *iFace                      ( ) {   return iface;}
		
		void                        DoConstruct             ( FLTInterface  *i,const    TCHAR   *name);
		
		FLT_FilterList              fltList;
		FLTExport void              ListFilters             ( );
		
		FLTExport HINSTANCE         AppInst                 ( );
		FLTExport HWND              AppWnd                  ( );
		FLTExport DllDir            *AppDllDir              ( );
		FLTExport Interface         *Max                    ( ) {   return max; }
		
		//-- User Interface -------------------------------

		BOOL						ImageFilterControl		( HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam );
		
		//-- This function will create a    mask bitmap based
		//    on the    given   ImageFilterInfo class.
		
		Bitmap                      *ProcessMask                    ( HWND hWnd, ImageFilterInfo    *ii );
		
		//-- This function will list all    available filter 
		//    plug-ins. The "item" argument defines an id 
		//    for   a combo box to  receive the list whithin 
		//    the   hWnd context. It returns the number of  
		//    filters found.
		
		FLTExport int               GetFilterList                   ( HWND hWnd, int item );
		FLTExport int               GetLayerList                    ( HWND hWnd, int item );
		
		//-- This runs  the show. Thew  window handle is used
		//    to send progress messages back. See above the
		//    discussion about messages. The    host should
		//    check keyboard and    cancel buttons  and return
		//    FALSE to a FLT_PROGRESS or FLT_CHECKABORT
		//    message telling   the Plug-In to  cancel.
		
		FLTExport BOOL              RenderFilter     ( HWND hWnd, 
													   ImageFilterInfo *ii, 
													   Bitmap *map,
													   Bitmap *foreMap = NULL);
		
		//-- This will  bring   a full blown dialog giving  the
		//    user an interface to select   and define a plug-
		//    in filter. Returns    FALSE   if  the user    cancels.
		
		FLTExport BOOL              SelectImageFilter( HWND hWnd, ImageFilterInfo *ii    );
		
		//-- This will  fill out    the given combo box with a
		//    list of available mask options
		
		FLTExport void              ListMaskOptions  ( HWND hWnd, int item);

		//----------------------------------------------------------------------
		//-- R2 Stuff Below ----------------------------------------------------
		//----------------------------------------------------------------------
	
		//-- Internal Use

		FLTExport void              UpdateFilter		( ImageFilterInfo *ii );

		
};

//-----------------------------------------------------------------------------
//--   Forward References
//

extern FLTExport   void             OpenFLT         (  FLTInterface *i );
extern FLTExport   void             CloseFLT        (  );

//-----------------------------------------------------------------------------
//--   The Primary Filter Manager  Object
//
// TO  DO: Move    to  App data    structure?

extern FLTExport FilterManager *TheFilterManager; 

#endif

//-- EOF: filters.h -----------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\fbwin.h ===
/**********************************************************************
 *<
	FILE: fbwin.h

	DESCRIPTION: framebuffer window include file.

	CREATED BY: Don Brittain

	HISTORY:

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#if !defined(_FBWIN_H_)

#define _FBWIN_H_

#ifdef WIN95STUFF
#include <vfw.h>
#endif

#define FBW_MSG_OFFSET (WM_USER + 1000)

#define FBW_LBUTTONDOWN		(WM_LBUTTONDOWN + FBW_MSG_OFFSET)
#define FBW_LBUTTONUP		(WM_LBUTTONUP + FBW_MSG_OFFSET)
#define FBW_LBUTTONDBLCLK	(WM_LBUTTONDBLCLK + FBW_MSG_OFFSET)
#define FBW_RBUTTONDOWN		(WM_RBUTTONDOWN + FBW_MSG_OFFSET)
#define FBW_RBUTTONUP		(WM_RBUTTONUP + FBW_MSG_OFFSET)
#define FBW_RBUTTONDBLCLK	(WM_RBUTTONDBLCLK + FBW_MSG_OFFSET)
#define FBW_MOUSEMOVE		(WM_MOUSEMOVE + FBW_MSG_OFFSET)


class FB_RGBA_Pixel {
	union {
		struct {
			BYTE red;
			BYTE green;
			BYTE blue;
			BYTE alpha;
		} rgba;
		DWORD pix;
	};
};

// framebuffer window setup structure
class FBWinSetup {
public:
    DllExport FBWinSetup();
	DWORD			winStyle;
	POINT			winSize;
	POINT			winPlace;
	POINT			fbSize;
};

class FrameBufferWindow {
public:
	DllExport	FrameBufferWindow(HWND hParent, FBWinSetup &fbw);
	DllExport	~FrameBufferWindow();

				HWND	getHWnd()			{ return hWnd; }
				int		getBitsPerPixel()	{ return bpp; }

				void	setNotify(int n)	{ notify = n; }
				int		getNotify()			{ return notify; }

				int		getOriginX()	{ return origin.x; }
				int		getOriginY()	{ return origin.y; }
				void	setOrigin(int x, int y)	{ origin.x = x; origin.y = y; }

				int		getFbSizeX()	{ return fbSize.x; }
				int		getFbSizeY()	{ return fbSize.y; }
#if 0
	DllExport	void	setFbSize(int x, int y);

	DllExport	void	loadDIB(LPBITMAPINFOHEADER dib);
#endif
	
	DllExport	void	startScanlineLoad();
	DllExport	void	scanline(int line, int start, int count, FB_RGBA_Pixel *pixels);
	DllExport	void	scanline(int line, int start, int count, BYTE *red, BYTE *green, BYTE *blue);
	DllExport	void	endScanlineLoad();

	friend LRESULT CALLBACK FBWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);

private:
	void 				onPaint(HWND hWnd, WPARAM wParam, LPARAM lParam);
	void				onSize(HWND hWnd, WPARAM wParam, LPARAM lParam);
	void				setupPalette();
	void				setupDIB();

	static int			refCount;
	HWND				hWnd;
	HWND				hParent;

	int					notify;

#ifdef WIN95STUFF
	HDRAWDIB			hDrawDC;
#endif
	int					bpp;
	int					paletted;

	POINT				winSize;
	POINT				fbSize;
	POINT				origin;

	int					dibLoaded;
	LOGPALETTE *		logPal;
	LPBITMAPINFOHEADER	pbih;
	BYTE *				pixBuf;
	int					pixBufSize;
};


#endif // _FBWIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\FileLinkApi.h ===
/*********************************************************************
 *<
	FILE: FileLinkApi.h

	DESCRIPTION: File Link interface class

	CREATED BY:	Nikolai Sander

	HISTORY: Created 29 January 1998

 *>	Copyright (c) 1997-1999, All Rights Reserved.
 **********************************************************************/

#ifndef FILELINKAPI_H
#define FILELINKAPI_H

#include <maxtypes.h>


/******
	Accessing the Link Table:
	If you want your plugin to be able to access the IVizLinkTable interface
	without incurring a load-time dependency, add the following function to
	your plugin. With this, your plugin will load whether or not the
	VizLink plugin is available.

// Returns NULL if the LinkTable plugin is not present on this system.
IVizLinkTable* GetLinkTable()
{
	// Look for the LinkTable node in track view.
	ITrackViewNode* tvRoot = GetCOREInterface()->GetTrackViewRootNode();
	int i = tvRoot->FindItem(VIZLINKTABLE_CLASS_ID);
	if (i < 0)
		return NULL;

	// Get the node's controller.
	ITrackViewNode* tvNode = tvRoot->GetNode(i);
	Control* pc = tvNode->GetController(VIZLINKTABLE_CLASS_ID);
	if (pc == NULL)
		return NULL;

	// Call GetInterface to confirm that this is the proper instance.
	return GetVizLinkTable(pc);
}
******/

#define VIZLINKTABLE_CLASS_ID Class_ID(0xa20bbe82, 0x70c763d)

#define I_VIZLINKCONTROLLER (I_USERINTERFACE+0x1739)
#define GetVizLinkTable(anim) ((IVizLinkTable*)anim->GetInterface(I_VIZLINKCONTROLLER))

#define kFILES_FORMAT -1


class VizLinkList;
class FormatRegistry;
class FormatFactory;
class LinkTableRecord;
class LinkedObjectsEnum;
class IFileLinkManager;


// Interface to the underlying implementation. Also designed as 
// a Facade to the more complicated linking process.
//
class IVizLinkTable : public StdControl
{
public :
	typedef int Iterator;

	// Access to the UI driver.
	virtual IFileLinkManager* GetFileLinkManager() = 0;

	// If you pass in kFILES_FORMAT for the format argument, the format type will be
	// determined from the filename.
	virtual BOOL DoAttach(const TCHAR* filename,
						int format = 0,
						BOOL suppressPrompts = FALSE,
						BOOL readOnly = TRUE) = 0;
	virtual int NumLinkedFiles() const = 0;
	virtual bool GetLinkID(int i, Iterator& iter) const = 0;
	virtual bool DoReload(Iterator iter, BOOL suppressPrompts = FALSE) = 0;
	virtual bool DoDetach(Iterator iter) = 0;
	virtual bool DoBind(Iterator iter) = 0;
	virtual LinkTableRecord* RecordAt(IVizLinkTable::Iterator id) = 0;
	virtual bool ChangeLinkFile(Iterator iter, const TSTR& str) = 0;

// Auto-reload event handling.
protected:
	friend class DBManUI;
	// Only DBManUI can turn this on and off.
	virtual void EnableAutoReload(bool enable) = 0;
public:
	virtual void WaitForReloadThread() const = 0;

public:
	// List updating notification.
	virtual void RegisterForListUpdates(VizLinkList*) = 0;
	virtual void UnregisterForListUpdates(VizLinkList*) = 0;
	virtual void UpdateList() = 0;

	// For iterating over all linked nodes.
	virtual void EnumerateLinkedObjects(LinkedObjectsEnum* EnumProc) = 0;

	// Linked splines can be rendered.
	virtual void SetRenderSplines(BOOL b) = 0;
	virtual BOOL GetRenderSplines() const = 0;
	virtual BOOL SetSplineRenderThickness(float f) = 0;
	virtual float GetSplineRenderThickness() const = 0;
	virtual void SetGenUVs(BOOL b) = 0;
	virtual BOOL GetGenUVs() const = 0;
	virtual void SetShapeRenderFlags(Object *pObj) const = 0;

	// If you are supporting a new format, register your factory class
	// here.
	virtual BOOL RegisterFactory(Class_ID& cid) = 0;
	virtual FormatRegistry* Registry() = 0;

};


// This interface provides access to some of the link manager's functions.
class IFileLinkManager
{
public:
	// Select a file, prompt for settings, and link the file.
	virtual BOOL DoAttach(BOOL suppressPrompts = FALSE) = 0;

	// Display the manager.
	virtual void OpenFileLinkManager(Interface* ip) = 0;
	// Enable/Disable the manager
	virtual void EnableFileLinkManager(BOOL enable) = 0;
};


// If you have a list that you want dynamically updated whenever a 
// linked file's status changes, derive your class from this, and
// implement the inherited method(s). For example, a utility plugin
// would derive from both UtilityObj and from VizLinkList.
class VizLinkList
{
public:
	virtual void RefreshLinkedFileList() = 0;
};


#endif //FILELINKAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\fltlib.h ===
#ifndef  __INFILTERS__
#ifndef _FLTLIB_H_
#define _FLTLIB_H_
#define FLTExport __declspec( dllimport )
#include "Filters.h"
#undef  FLTExport
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\fltapi.h ===
//-----------------------------------------------------------------------------
// -------------------
// File	....:	fltapi.h
// -------------------
// Author...:	Gus Grubba
// Date	....:	September 1995
//
// History	.:	Sep, 07 1995 -	Started
//
//-----------------------------------------------------------------------------

//--	FLT Interface class

class FLTInterface {

	public:

		virtual HINSTANCE	 AppInst				()	= 0;
		virtual HWND		 AppWnd				()	= 0;
		virtual DllDir		*AppDllDir			()	= 0;
		virtual TCHAR		*GetDir				(int i) = 0;
		virtual int			 GetMapDirCount	()	= 0;
		virtual TCHAR		*GetMapDir			(int i) = 0;
		virtual BOOL		 CreatePreview    (HWND,Bitmap**,int,int,int,float,Bitmap**,DWORD) = 0;
		virtual Interface *GetMaxInterface	( ) = 0;

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\gamma.h ===
/**********************************************************************
 *<
	FILE:  gamma.h

	DESCRIPTION:  Gamma utilities

	CREATED BY: Dan Silva

	HISTORY: created 26 December 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/


#ifndef __GAMMA__H
#define __GAMMA__H

#define WRDMAX 65535
#define FWRDMAX 65535.0f

#define RCBITS 13   // number of bits used to represent colors before gamma correction.
					// this keeps the lookup table a reasonable size
#define RCOLN (1<<RCBITS)    
#define RCMAX (RCOLN-1)	
#define FRCMAX ((float)RCMAX) 
#define RCHALF (RCOLN>>1)
#define RCSH (RCBITS-8)		  /* shift amount from 8 bit to RCBITS */
#define RCSH16 (16-RCBITS)	  /* shift amount from 16 bit to RCBITS */
#define RCFRACMASK ((ulong)((1<<RCSH)-1))	  
#define RC_SCL (1<<RCSH)
#define RC_SCLHALF (1<<(RCSH-1))
#define FRC_SCL ((float)RC_SCL)
#define RCSHMASK (0xffffffffL<<RCSH)
#define RCSHMAX (0xffL<<RCSH)


#define GAMMA_NTSC		2.2f
#define	GAMMA_PAL		2.8f

class GammaMgr {
	public:
		BOOL enable;
		BOOL dithTrue;
		BOOL dithPaletted;
		float dispGamma;
		float fileInGamma;
		float fileOutGamma;
		UBYTE disp_gamtab[256];    	  // (8->8) display gamma for drawing color swatches (8->8) 
		UBYTE disp_gamtabw[RCOLN];    // (RCBITS->8) display gamma 
		UBYTE file_in_gamtab[256];    // (8->8) 
		UWORD file_in_degamtab[256];  // (8->16)  for de-gamifying bitmaps on input
		UWORD file_out_gamtab[RCOLN]; // (RCBITS->16) gamma correct for file output, before dither 

		inline COLORREF DisplayGammaCorrect(COLORREF col) {
			return RGB(disp_gamtab[GetRValue(col)],	disp_gamtab[GetGValue(col)], disp_gamtab[GetBValue(col)]);		
			}

		CoreExport Color DisplayGammaCorrect(Color c);
			
		CoreExport void Enable(BOOL onOff);
		BOOL IsEnabled() { return enable;}

		CoreExport void  SetDisplayGamma(float gam);
		float GetDisplayGamma() { return dispGamma; }

		CoreExport void SetFileInGamma(float gam);
		float GetFileInGamma() { return fileInGamma; }

		CoreExport void SetFileOutGamma(float gam);
		float GetFileOutGamma() { return fileOutGamma; }

		GammaMgr();


	};

CoreExport extern GammaMgr gammaMgr;


inline COLORREF gammaCorrect(DWORD c) { return gammaMgr.DisplayGammaCorrect(c); }
inline UBYTE gammaCorrect(UBYTE b) { return gammaMgr.disp_gamtab[b]; }


#define GAMMA16to8(b)  gammaMgr.disp_gamtabw[b>>RCSH16]

// Build Gamma table that maps 8->8  
CoreExport void BuildGammaTab8(UBYTE gamtab[256], float gamma, int onoff=TRUE);

// Build a Gamma table that maps 8->16
CoreExport void BuildGammaTab8(UWORD gamtab[256], float gamma, int onoff=TRUE);

// Build Gamma table that maps RCBITS->8
CoreExport void BuildGammaTab(UBYTE gamtab[RCOLN], float gamma, int onoff=TRUE);

// Build Gamma table that  maps RCBITS->16
CoreExport void BuildGammaTab(UWORD gamtab[RCOLN], float gamma, int onoff=TRUE);

CoreExport float gammaCorrect(float v, float gamma);
CoreExport float deGammaCorrect(float v, float gamma);
CoreExport UBYTE gammaCorrect(UBYTE v, float gamma);
CoreExport UBYTE deGammaCorrect(UBYTE v, float gamma);
CoreExport UWORD gammaCorrect(UWORD c, float gamma);
CoreExport UWORD deGammaCorrect(UWORD c, float gamma);


// Temporary table for converting 16->16.
class GamConvert16 {
	float gamma;
	UWORD* gtab;
	public:	
		GamConvert16(float gam=1.0f);  
		~ GamConvert16();  
		void SetGamma(float gam);
		UWORD Convert(UWORD v) { return gtab[v>>RCSH16]; }

	};

// Temporary table for converting 8->16.
class GamConvert8 {
	float gamma;
	UWORD gtab[256];
	public:	
		GamConvert8(float gam=1.0f);  
		void SetGamma(float gam);
		UWORD Convert(UBYTE v) { return gtab[v]; }

	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\gcommlib.h ===
#ifndef _GCOMMLIB_
#define _GCOMMLIB_
#define  GCOMMEXPORT __declspec( dllimport )
#include "gcomm.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\frontend.h ===
/*********************************************************************
 *<
	FILE: frontend.h

	DESCRIPTION: A new plug-in type that controls the main UI for MAX

	CREATED BY:	Rolf Berteig

	HISTORY: 4/01/97

 *>	Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/

#ifndef __FRONTEND_H__
#define __FRONTEND_H__

// layout bits
#define FE_LAYOUT_NO_TIMESLIDER			(1<<0)
#define FE_LAYOUT_NO_TOOLBAR			(1<<1)
#define FE_LAYOUT_NO_COMMAND_PANEL		(1<<2)
#define FE_LAYOUT_CONTROL_COMMAND_PANEL	(1<<3)
#define FE_LAYOUT_DEFAULT				0


// Tool bar buttons
#define TOOLBUT_HELP				0
#define TOOLBUT_UNDO				1
#define TOOLBUT_REDO				2
#define TOOLBUT_LINK				3
#define TOOLBUT_UNLINK				4
#define TOOLBUT_SPACEWARP_BIND		5
#define TOOLBUT_SELECT				6
#define TOOLBUT_REGION_TYPE			7
#define TOOLBUT_SELECT_FILTER		8
#define TOOLBUT_SELECT_BYNAME		9
#define TOOLBUT_MOVE				10
#define TOOLBUT_ROTATE				11
#define TOOLBUT_SCALE				12
#define TOOLBUT_REF_COORDSYS		13
#define TOOLBUT_REF_CENTER			14
#define TOOLBUT_CONST_X				15
#define TOOLBUT_CONST_Y				16
#define TOOLBUT_CONST_Z				17
#define TOOLBUT_CONST_PLANE			18
#define TOOLBUT_IK					19
#define TOOLBUT_MIRROR				20
#define TOOLBUT_ARRAY				21
#define TOOLBUT_ALIGN				22
#define TOOLBUT_NAMED_SELSETS		23
#define TOOLBUT_TRACKVIEW			24
#define TOOLBUT_MEDIT				25
#define TOOLBUT_RENDER				26
#define TOOLBUT_QUICK_RENDER		27
#define TOOLBUT_RENDER_TYPE			28
#define TOOLBUT_RENDER_LAST			29
#define TOOLBUT_SEPERATOR			30
#define TOOLBUT_LAYER_CURRENT		31
#define TOOLBUT_LAYER_PROP			32
#define TOOLBUT_LAYER_CONTROL		33
#define TOOLBUT_LAYER_OBJ_PROP		34
#define TOOLBUT_MEASURE				35
#define TOOLBUT_SCHEMATIC_VIEW		36

// Standard MAX tool buttons use IDs greater then this value.
// FE plug-in tool buttons should use IDs less then this max value
// and greater then this min value.
// Note that the actual resource IDs for standard MAX buttons will
// be converted to the above #defines when passed to ProcessToolButton().
#define MIN_FE_CUSTOM_TOOLID		1000
#define MAX_FE_CUSTOM_TOOLID		30000


// Menu items
#define MENUITEM_FILE_NEW						0
#define MENUITEM_FILE_RESET						1
#define MENUITEM_FILE_OPEN						2
#define MENUITEM_FILE_MERGE						3
#define MENUITEM_FILE_REPLACE					4
#define MENUITEM_FILE_INSERTTRACKS				5
#define MENUITEM_FILE_SAVE						6
#define MENUITEM_FILE_SAVEAS					7
#define MENUITEM_FILE_SAVESELECTED				8
#define MENUITEM_FILE_IMPORT					9
#define MENUITEM_FILE_EXPORT					10
#define MENUITEM_FILE_ARCHIVE					11
#define MENUITEM_FILE_SUMMARYINFO				12
#define MENUITEM_FILE_VIEWFILE					13
#define MENUITEM_FILE_CONFIGUREPATHS			14
#define MENUITEM_FILE_PREFERENCES				15
#define MENUITEM_FILE_EXIT						16

#define MENUITEM_EDIT_UNDO						17
#define MENUITEM_EDIT_REDO						18
#define MENUITEM_EDIT_HOLD						19
#define MENUITEM_EDIT_FETCH						20
#define MENUITEM_EDIT_DELETE					21
#define MENUITEM_EDIT_CLONE						22
#define MENUITEM_EDIT_SELECTALL					23
#define MENUITEM_EDIT_SELECTNONE				24
#define MENUITEM_EDIT_SELECTINVERT				25
#define MENUITEM_EDIT_SELECTBY_COLOR			26
#define MENUITEM_EDIT_SELECTBY_MATERIAL			27
#define MENUITEM_EDIT_SELECTBY_SMOOTHING		28
#define MENUITEM_EDIT_SELECTBY_NAME				29
#define MENUITEM_EDIT_REGION_WINDOW				30
#define MENUITEM_EDIT_REGION_CROSSING			31
#define MENUITEM_EDIT_REMOVENAMEDSELECTIONS		32
#define MENUITEM_EDIT_PROPERTIES				33

#define MENUITEM_TOOLS_TRANSFORMTYPEIN			34
#define MENUITEM_TOOLS_DISPLAYFLOATER			35
#define MENUITEM_TOOLS_SELECTIONFLOATER			36
#define MENUITEM_TOOLS_MIRROR					37
#define MENUITEM_TOOLS_ARRAY					38
#define MENUITEM_TOOLS_SNAPSHOT					39
#define MENUITEM_TOOLS_ALIGN					40
#define MENUITEM_TOOLS_ALIGNNORMALS				41
#define MENUITEM_TOOLS_PLACEHIGHLIGHT			42
#define MENUITEM_TOOLS_MTLEDIT					43
#define MENUITEM_TOOLS_MTLBROWSE				44

#define MENUITEM_GROUP_GROUP					45
#define MENUITEM_GROUP_OPEN						46
#define MENUITEM_GROUP_CLOSE					47
#define MENUITEM_GROUP_UNGROUP					48
#define MENUITEM_GROUP_EXPLODE					49
#define MENUITEM_GROUP_ATTACH					50
#define MENUITEM_GROUP_DETACH					51

#define MENUITEM_VIEWS_UNDO							52
#define MENUITEM_VIEWS_REDO							53
#define MENUITEM_VIEWS_SAVEACTIVEVIEW				54
#define MENUITEM_VIEWS_RESTOREACTIVEVIEW			55
#define MENUITEM_VIEWS_UNITSETUP					56
#define MENUITEM_VIEWS_DRAWINGAIDS					57
#define MENUITEM_VIEWS_GRIDS_SHOWHOMEGRID			58
#define MENUITEM_VIEWS_GRIDS_ACTIVATEHOMEGRID		59
#define MENUITEM_VIEWS_GRIDS_ACTIVATEGRIDOBJECT		60
#define MENUITEM_VIEWS_GRIDS_ALIGN					61
#define MENUITEM_VIEWS_IMAGEBACKGROUND				62
#define MENUITEM_VIEWS_UPDATEBKGIMAGE				63
#define MENUITEM_VIEWS_RESETBKGXFORM				64
#define MENUITEM_VIEWS_SHOWAXISICON					65
#define MENUITEM_VIEWS_SHOWGHOSTING					66
#define MENUITEM_VIEWS_SHOWKEYTIMES					67
#define MENUITEM_VIEWS_SHADESELECTED				68
#define MENUITEM_VIEWS_SHOWDEP						69
#define MENUITEM_VIEWS_MATCHCAMERATOVIEW			70
#define MENUITEM_VIEWS_REDRAW						71
#define MENUITEM_VIEWS_DEACT_MAPS					72
#define MENUITEM_VIEWS_UPDATEDURINGSPINNERDRAG		73
#define MENUITEM_VIEWS_EXPERTMODE					74
#define MENUITEM_VIEWS_VIEWPORTCONFIG				75

#define MENUITEM_RENDER_RENDER						76
#define MENUITEM_RENDER_VIDEOPOST					77
#define MENUITEM_RENDER_SHOW_LAST_IMG				78
#define MENUITEM_RENDER_ATMOSPHERE					79
#define MENUITEM_RENDER_PREVIEW						80
#define MENUITEM_RENDER_VIEWPREVIEW					81
#define MENUITEM_RENDER_RENAMEPREVIEW				82

#define MENUITEM_HELP_CONTENTS						83
#define MENUITEM_HELP_INDEX							84
#define MENUITEM_HELP_PLUGINHELP					85
#define MENUITEM_HELP_ABOUT							86

// VIZ specific
#define MENUITEM_TOOLS_SPACETOOL					87
#define MENUITEM_TOOLS_LAYERPROP					88

// JBW added MAXScript menu (11/11/98 & 12/15/98)
#define MENUITEM_MAXSCRIPT_LISTENER					89
#define MENUITEM_MAXSCRIPT_OPEN						90
#define MENUITEM_MAXSCRIPT_NEW						91
#define MENUITEM_MAXSCRIPT_RUN						92
#define MENUITEM_MAXSCRIPT_MACROREC					93


// Standard MAX menu items use IDs greater then this value.
// FE plug-in menu items should use IDs less then this max value
// and greater then this min value.
// Note that the actual resource IDs for standard MAX menu items will
// be converted to the above #defines when passed to ProcessMenuItem().
#define MIN_FE_CUSTOM_MENUEITEM		1000
#define MAX_FE_CUSTOM_MENUEITEM		30000




// Special interface given only to front end controllers
class IFrontEnd {
	public:
		virtual HWND GetCommandPanelHWND()=0;
		
		virtual void *GetInterface(DWORD id)=0;

		virtual void ClearToolBar()=0;
		virtual void RemoveStandardToolButton(int id)=0;
		virtual void AddStandardToolButton(int id,int sepSize=-1)=0;
		virtual void CheckStandardTool(int id, BOOL onOff)=0;
		virtual BOOL IsStandardToolChecked(int id, BOOL onOdd)=0;
		virtual void EnableStandardTool(int id, BOOL enabled)=0;
		virtual void SetStandardToolFlyoff(int id, int fly)=0;
		virtual int GetStandardToolFlyoff(int id)=0;
		virtual ICustToolbar *GetMainToolbar()=0;

		virtual HMENU GetMainMenu()=0;
		virtual void SetMainMenu(HMENU hMenu)=0;
		virtual int MenuIDtoResID(int id)=0; // given one of the above defines, what is the corrisponding resource ID
		virtual int ResIDtoMenuID(int id)=0; // oppisite of above
	};


class FrontEndController {
	public:
		virtual void DeleteThis()=0;

		virtual void *GetInterface(DWORD id) {return NULL;}
		
		// Called once on startup. Note that MAX windows have been created
		// but not necessarily sized.
		virtual void Initialize(IFrontEnd *ife,Interface *ip) {}

		virtual DWORD GetLayout() {return FE_LAYOUT_DEFAULT;}		
		
		// Notifications
		virtual DWORD GeneralNotify(DWORD id, DWORD param1, DWORD param2) {return 0;}		
		virtual void SelectionChanged() {}
		virtual void TimeChanged(TimeValue t) {}
		virtual DWORD ProcessToolButton(int id, int notify) {return 0;}
		virtual DWORD ProcessMenuItem(int id, int notify) {return 0;}
		virtual DWORD ProcessInitMenu(HMENU hMenu) {return 0;}
		virtual DWORD ProcessViewportRightClick(HWND hWnd, IPoint2 m) {return 0;}
		virtual DWORD ProcessViewportLabelClick(HWND hWnd, IPoint2 m) {return 0;}
		virtual DWORD ProcessViewportMenuItem(int id, int notify) {return 0;}
		virtual DWORD ProcessViewportInitMenu(HMENU hMenu) {return 0;}
		virtual void Resize() {}
	};






#endif //__FRONTEND_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\gbuf.h ===
/**********************************************************************
 *<
	FILE: gbuf.h : GBuffer manager.

	DESCRIPTION:

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1998, All Rights Reserved.
 **********************************************************************/

#ifndef __GBUF__H
#define __GBUF__H

#define NUMGBCHAN 13

// GBuffer channels (number of bytes in parenthesis)
#define GB_Z       			0  	// (4)  Z-Buffer depth, float
#define GB_MTL_ID  			1  	// (1)  ID assigned to mtl via mtl editor
#define GB_NODE_ID 			2  	// (2)  ID assigned to node via properties
#define GB_UV       		3 	// (8)  UV coordinates - Point2 
#define GB_NORMAL   		4 	// (4)  Normal vector in view space, compressed 
#define GB_REALPIX  		5 	// (4)  Non clamped colors in "RealPixel" format 
#define GB_COVERAGE 		6 	// (1)  Pixel coverage  
#define GB_BG 	     		7 	// (3)  RGB color of what's behind layer 
#define GB_NODE_RENDER_ID 	8 	// (2)  Node render index, word
#define GB_COLOR		 	9 	// (3)  Color (RGB)
#define GB_TRANSP		 	10 	// (3)  Transparency (RGB)
#define GB_VELOC		 	11 	// (8)  Velocity (Point2)
#define GB_WEIGHT		 	12 	// (3)  Weight of layers contribution to pixel color

CoreExport int GBDataSize(int i);

CoreExport TCHAR *GBChannelName(int i);

// Recognized channel bits 

#define BMM_CHAN_NONE     0
#define BMM_CHAN_Z        (1<<GB_Z) 		//  Z-buffer depth, float 
#define BMM_CHAN_MTL_ID   (1<<GB_MTL_ID) 	//  ID assigned to mtl via mtl editor 
#define BMM_CHAN_NODE_ID  (1<<GB_NODE_ID) 	//  ID assigned to node via properties 
#define BMM_CHAN_UV       (1<<GB_UV) 		//  UV coordinates - Point2 
#define BMM_CHAN_NORMAL   (1<<GB_NORMAL) 	//  Normal vector in view space, compressed 
#define BMM_CHAN_REALPIX  (1<<GB_REALPIX) 	//  Non clamped colors in "RealPixel" format 
#define BMM_CHAN_COVERAGE (1<<GB_COVERAGE) 	//  Pixel coverage of front surface 
#define BMM_CHAN_BG 	  (1<<GB_BG) 		//  RGB color of what's behind front object 
#define BMM_CHAN_NODE_RENDER_ID (1<<GB_NODE_RENDER_ID) //  node render index 
#define BMM_CHAN_COLOR    (1<<GB_COLOR) 	//  Color (Color24) 
#define BMM_CHAN_TRANSP   (1<<GB_TRANSP) 	//  Transparency (Color24) 
#define BMM_CHAN_VELOC    (1<<GB_VELOC) 	//  Velocity ( Point2 ) 
#define BMM_CHAN_WEIGHT   (1<<GB_WEIGHT) 	//  Weight ( Color24 ) 

// Recognized types of channels
#define BMM_CHAN_TYPE_UNKNOWN 0 
#define BMM_CHAN_TYPE_8   2 // 1 byte per pixel
#define BMM_CHAN_TYPE_16  3 // 1 word per pixel
#define BMM_CHAN_TYPE_24  8 // 3 bytes per pixel
#define BMM_CHAN_TYPE_32  4 // 2 words per pixel
#define BMM_CHAN_TYPE_48  5 // 3 words per pixel
#define BMM_CHAN_TYPE_64  6 // 4 words per pixel
#define BMM_CHAN_TYPE_96  7 // 6 words per pixel

struct GBufData {
	float z;
	UBYTE mtl_id;
	UWORD node_id;
	Point2 uv;
	DWORD normal;
	RealPixel realpix;
	UBYTE coverage;
	UWORD rend_id;
	Color24 color;
	Color24 transp;
	Color24 weight;
	Point2 veloc;
	};
	

//------------------------------------gbuf.h ----------------------------------------------

class GBufReader {
	public:
	virtual int  StartLine(int y)=0;      	// -1 = no data for line, or x of first non-empty pixel
	virtual BOOL StartPixel(int x)=0;     	// -1 = eol,; 0 = empty; 1= has data  ( Automatically starts first layer)
	virtual BOOL StartPixel(int x,int y)=0; // -1 = eol,; 0 = empty; 1= has data ( includes StartLine)
	virtual BOOL StartNextLayer()=0;		// 0 = no more layers ( Do not call before first layer )
	virtual	int NextPixel()=0;       		// -1 = eol,; 0 = empty; 1 = has data
	// Read a data element: chan is one of { GB_Z, GB_MTL_ID, GB_NODE_ID, ... etc }
	virtual BOOL ReadChannelData(int chan, void *data)=0; // 1= has data;  0= didnt have data
	virtual BOOL ReadAllData(GBufData *data)=0; // 1= has data;  0= didnt have data
	virtual void DeleteThis()=0;
	// Generic expansion function
	virtual int Execute(int cmd, ULONG arg1=0, ULONG arg2=0, ULONG arg3=0) { return 0; } 
	};	


// This assumes pixels are created in increasing order of x.
class GBufWriter {
	public:
	virtual void StartLine(int y)=0;		 // 1 = success  0 = fail ( Must call before every line)
	virtual void StartPixel(int x)=0;        // 1 = success  0 = fail  ( Must call to start each pixel )
	virtual void StartNextLayer()=0;		 // 1 = success  0 = fail  ( Must call before first layer)
	// Write a data element: chan is one of { GB_Z, GB_MTL_ID, GB_NODE_ID, ... etc }
	virtual BOOL WriteChannelData(int chan, void *data)=0;  // 1=success   0=fail
	virtual BOOL WriteAllData(GBufData *data)=0; // 1= success;  0= fail
	virtual BOOL EndLine()=0;                 // 1=success   0=fail ( Just call after every line)
	virtual void DeleteThis()=0;
	// Generic expansion function
	virtual int Execute(int cmd, ULONG arg1=0, ULONG arg2=0, ULONG arg3=0) { return 0; } 
	};	

class GBuffer {
	public:
	virtual void SetRasterSize(int ww, int hh)=0;  	  // when create bitmap or size changes.
	virtual int Width()=0;
	virtual int Height()=0;
	virtual int InitBuffer()=0;    					   // call before writing buffer.
	virtual ULONG CreateChannels(ULONG channelMask)=0; // create specified channels
	virtual void  DeleteChannels(ULONG channelMask)=0; // delete specified channels 
	virtual ULONG ChannelsPresent()=0;
	virtual void  *GetChannel( ULONG channelID, ULONG& chanType)=0; 
	virtual GBufReader *CreateReader()=0;
	virtual void DestroyReader(GBufReader *pRdr)=0;
	virtual GBufWriter *CreateWriter()=0;
	virtual void DestroyWriter(GBufWriter *pRdr)=0;
	virtual BOOL IsDefaultGBuffer() { return FALSE; }
	virtual void DeleteThis()=0;
	virtual void Copy(GBuffer *gbfrom)=0;
	virtual	void CopyScale(GBuffer *gbfrom, int cw=-1, int ch=-1)=0;
	virtual void Position(int srcy, int trgy, int srcx, int trgx, int trgw, int trgh )=0;

	// for file writing
	virtual int  NumberLayerRecords(int y)=0;  
	virtual int  GetLayerChannel(int y, int ichan, char *data)=0; // ichan = -1 creates array of x values

	// for file reading
	virtual int CreateLayerRecords(int y, int num)=0;  
	virtual int SetLayerChannel(int y, int ichan, char *data)=0; // ichan = -1 gets array of x values
	
	// This scans the entire image and updates the minimum and maximum values
	virtual void UpdateChannelMinMax()=0;

	// Get Channel limits  ( currently only valid for z,uv,veloc)
	virtual BOOL GetChannelMin(int chan, void *data)=0;
	virtual BOOL GetChannelMax(int chan, void *data)=0;
	
	// names indexed by NodeRenderId
	virtual NameTab &NodeRenderIDNameTab()=0;

	// Generic expansion function
	virtual int Execute(int cmd, ULONG arg1=0, ULONG arg2=0, ULONG arg3=0) { return 0; } 

	};

CoreExport void SetMaximumGBufferLayerDepth(int m);
CoreExport int GetMaximumGBufferLayerDepth();

CoreExport GBuffer *NewDefaultGBuffer();

#endif// __GBUF__H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\genhier.h ===
/**********************************************************************
 *<
	FILE: hierclas.h

	DESCRIPTION: Simple utility class for describing hierarchies

	CREATED BY: Tom Hudson

	HISTORY: Created 3 July 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#ifndef __HIERCLAS__H
#define __HIERCLAS__H

#define INVALID_HIERARCHY -1

class HierarchyEntry {
	public:
		int data;
		int children;
		HierarchyEntry *parent;
		HierarchyEntry *sibling;
		HierarchyEntry *child;
		TSTR sortKey;
		UtilExport HierarchyEntry();
		UtilExport HierarchyEntry(int d, HierarchyEntry *p, HierarchyEntry *s);
		UtilExport int HierarchyLevel();
		UtilExport void AddChild(int d);
		UtilExport int GetChild(int index);
		int Children() { return children; }
		UtilExport void Sort();
	};

class GenericHierarchy {
	private:
		HierarchyEntry root;
		void FreeTree(HierarchyEntry* start = NULL);
		BOOL isSorted;
		void CopyTree(int parent, HierarchyEntry* ptr);
	public:
		GenericHierarchy() { root = HierarchyEntry(-1,NULL,NULL); isSorted = FALSE; }
		UtilExport ~GenericHierarchy();
		UtilExport void AddEntry(int data, int parent = -1);		// Add one entry, given its parent
		UtilExport int Entries();									// Total number of members in the hierarchy
		UtilExport HierarchyEntry* GetStart() { return root.child; } // Get the first item under the root
		UtilExport HierarchyEntry* FindEntry(int data, HierarchyEntry* start = NULL);
		UtilExport int NumberOfChildren(int data);					// The number of children for this item
		UtilExport int GetChild(int data, int index);				// Get the nth child of this item
		UtilExport void New();										// Clear out the hierarchy tree
		UtilExport void Sort();										// Sort tree by children/siblings
		UtilExport BOOL IsCompatible(GenericHierarchy& hier);		// Are they compatible?
		UtilExport void Dump(HierarchyEntry* start = NULL);			// DebugPrint the tree
		UtilExport GenericHierarchy& operator=(GenericHierarchy& from);	// Copy operator
		UtilExport TSTR& SortKey();									// Get the sort key for the hierarchy
	};

#endif __HIERCLAS__H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\gencam.h ===
/**********************************************************************
 *<
	FILE: gencamera.h

	DESCRIPTION:  Defines General-Purpose cameras

	CREATED BY: Tom Hudson

	HISTORY: created 5 December 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#ifndef __GENCAM__H__ 

#define __GENCAM__H__

// Camera types
#define FREE_CAMERA 0
#define TARGETED_CAMERA 1
#define PARALLEL_CAMERA 2

#define NUM_CAM_TYPES 2

class GenCamera: public CameraObject {			   
	public:
		virtual GenCamera *NewCamera(int type)=0;
		virtual void SetConeState(int s)=0;
		virtual int GetConeState()=0;
		virtual void SetHorzLineState(int s)=0;
		virtual int GetHorzLineState()=0;
		virtual void Enable(int enab)=0;
		virtual BOOL SetFOVControl(Control *c)=0;
		virtual void  SetFOVType(int ft)=0;
		virtual int GetFOVType()=0;
		virtual Control *GetFOVControl()=0;
		virtual	int  Type()=0;
		virtual void SetType(int tp)=0;

		virtual void SetDOFEnable(TimeValue t, BOOL onOff) {}
		virtual BOOL GetDOFEnable(TimeValue t, Interval& valid = Interval(0,0)) { return 0; }
		virtual void SetDOFFStop(TimeValue t, float fs) {}
		virtual float GetDOFFStop(TimeValue t, Interval& valid = Interval(0,0)) { return 1.0f; }
	};



#endif // __GENCAM__H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\genshape.h ===
/**********************************************************************
 *<
	FILE: genshape.h
				  
	DESCRIPTION:  Defines Generic Shape Class

	CREATED BY: Tom Hudson

	HISTORY: created 13 November 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#ifndef __GENSHAPE__

#define __GENSHAPE__

extern CoreExport Class_ID  genericShapeClassID; 

#endif // __GENSHAPE__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\genlight.h ===
/**********************************************************************
 *<
	FILE: genlight.h

	DESCRIPTION:  Defines General-Purpose lights

	CREATED BY: Tom Hudson

	HISTORY: created 5 December 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#ifndef __GENLIGHT__H__ 

#define __GENLIGHT__H__


#define OMNI_LIGHT		0	// Omnidirectional
#define TSPOT_LIGHT		1	// Targeted
#define DIR_LIGHT		2	// Directional
#define FSPOT_LIGHT		3	// Free
#define TDIR_LIGHT		4   // Targeted directional

#define NUM_LIGHT_TYPES	5

#define DECAY_NONE  0
#define DECAY_INV   1
#define DECAY_INVSQ 2

// SetAtten types
#define ATTEN1_START   	0  // near
#define ATTEN1_END		1  // near
#define ATTEN_START		2  // far
#define ATTEN_END		3  // far

// Shapes
#define RECT_LIGHT		0
#define CIRCLE_LIGHT	1

class ShadowType;

class GenLight: public LightObject {			   
public:
	virtual GenLight *NewLight(int type)=0;
	virtual RefResult EvalLightState(TimeValue t, Interval& valid, LightState* cs)=0;
	virtual int Type()=0;  // OMNI_LIGHT, TSPOT_LIGHT, DIR_LIGHT, FSPOT_LIGHT, TDIR_LIGHT
	virtual void SetType(int tp) {} // OMNI_LIGHT, TSPOT_LIGHT, DIR_LIGHT, FSPOT_LIGHT, TDIR_LIGHT      
	virtual BOOL IsSpot()=0;
	virtual BOOL IsDir()=0;
	virtual void SetUseLight(int onOff)=0;
	virtual BOOL GetUseLight(void)=0;
	virtual void SetSpotShape(int s)=0;
	virtual int GetSpotShape(void)=0;
	virtual void SetHotspot(TimeValue time, float f)=0;
	virtual float GetHotspot(TimeValue t, Interval& valid = Interval(0,0))=0;
	virtual void SetFallsize(TimeValue time, float f)=0;
	virtual float GetFallsize(TimeValue t, Interval& valid = Interval(0,0))=0;
	virtual void SetAtten(TimeValue time, int which, float f)=0;
	virtual float GetAtten(TimeValue t, int which, Interval& valid = Interval(0,0))=0;
	virtual void SetTDist(TimeValue time, float f)=0;
	virtual float GetTDist(TimeValue t, Interval& valid = Interval(0,0))=0;
	virtual ObjLightDesc *CreateLightDesc(INode *n)=0;
	virtual void SetRGBColor(TimeValue t, Point3& rgb)=0;
	virtual Point3 GetRGBColor(TimeValue t, Interval &valid = Interval(0,0))=0;
	virtual void SetHSVColor(TimeValue t, Point3& hsv)=0;
	virtual Point3 GetHSVColor(TimeValue t, Interval &valid = Interval(0,0))=0;
	virtual void SetIntensity(TimeValue time, float f)=0;
	virtual float GetIntensity(TimeValue t, Interval& valid = Interval(0,0))=0;
	virtual void SetContrast(TimeValue time, float f)=0;
	virtual float GetContrast(TimeValue t, Interval& valid = Interval(0,0))=0;
	virtual void SetAspect(TimeValue t, float f)=0;
	virtual float GetAspect(TimeValue t, Interval& valid = Interval(0,0))=0;
	virtual void SetConeDisplay(int s, int notify=TRUE)=0;
	virtual BOOL GetConeDisplay(void)=0;
	virtual void SetUseAtten(int s)=0;
	virtual BOOL GetUseAtten(void)=0;
	virtual void SetAttenDisplay(int s)=0;
	virtual BOOL GetAttenDisplay(void)=0;
	virtual void SetUseAttenNear(int s)=0;
	virtual BOOL GetUseAttenNear(void)=0;
	virtual void SetAttenNearDisplay(int s)=0;
	virtual BOOL GetAttenNearDisplay(void)=0;
	virtual void Enable(int enab)=0;
	virtual void SetMapBias(TimeValue t, float f)=0;
	virtual float GetMapBias(TimeValue t, Interval& valid = Interval(0,0))=0;
	virtual void SetMapRange(TimeValue t, float f)=0;
	virtual float GetMapRange(TimeValue t, Interval& valid = Interval(0,0))=0;
	virtual void SetMapSize(TimeValue t, int f)=0;
	virtual int GetMapSize(TimeValue t, Interval& valid = Interval(0,0))=0;
	virtual void SetRayBias(TimeValue t, float f)=0;
	virtual float GetRayBias(TimeValue t, Interval& valid = Interval(0,0))=0;

	virtual int GetUseGlobal()=0;
	virtual void SetUseGlobal(int a)=0;
	virtual int GetShadow()=0;
	virtual void SetShadow(int a)=0;

	virtual int GetShadowType()=0;
	virtual void SetShadowType(int a)=0;

	// Pluggable Shadow generator (11/2/98): 
	virtual	void SetShadowGenerator(ShadowType *s) {};
	virtual ShadowType *GetShadowGenerator() { return NULL; } 

	virtual int GetAbsMapBias()=0;
	virtual void SetAbsMapBias(int a)=0;

	virtual void SetAtmosShadows(TimeValue t, int onOff) {}
	virtual int GetAtmosShadows(TimeValue t) { return 0; }
	virtual void SetAtmosOpacity(TimeValue t, float f) {}
	virtual float GetAtmosOpacity(TimeValue t, Interval& valid=FOREVER) { return 0.0f; }
	virtual void SetAtmosColAmt(TimeValue t, float f) {}
	virtual float GetAtmosColAmt(TimeValue t, Interval& valid=FOREVER) { return 0.0f; }
	virtual void SetUseShadowColorMap(TimeValue t, int onOff) { }
	virtual int GetUseShadowColorMap(TimeValue t) { return FALSE; }
	
	virtual int GetOvershoot()=0;
	virtual void SetOvershoot(int a)=0;

	virtual NameTab& GetExclusionList()=0;
	virtual void SetExclusionList(NameTab &list)=0;

	virtual BOOL SetHotSpotControl(Control *c)=0;
	virtual BOOL SetFalloffControl(Control *c)=0;
	virtual BOOL SetColorControl(Control *c)=0;
	virtual Control* GetHotSpotControl()=0;
	virtual Control* GetFalloffControl()=0;
	virtual Control* GetColorControl()=0;
	
	virtual void SetAffectDiffuse(BOOL onOff) {}
	virtual BOOL GetAffectDiffuse() {return 0;}
	virtual void SetAffectSpecular(BOOL onOff) {}
	virtual BOOL GetAffectSpecular() {return 0;}

	virtual void SetDecayType(BOOL onOff) {}
	virtual BOOL GetDecayType() {return 0;}
	virtual void SetDecayRadius(TimeValue time, float f) {}
	virtual float GetDecayRadius(TimeValue t, Interval& valid = Interval(0,0)) { return 0.0f;}
	virtual void SetDiffuseSoft(TimeValue time, float f) {}
	virtual float GetDiffuseSoft(TimeValue t, Interval& valid = Interval(0,0)) { return 0.0f; }

	virtual void SetShadColor(TimeValue t, Point3& rgb) {}
	virtual Point3 GetShadColor(TimeValue t, Interval &valid = Interval(0,0)) { return Point3(0,0,0); }
	virtual BOOL GetLightAffectsShadow() { return 0; }
	virtual void SetLightAffectsShadow(BOOL b) {  }
	virtual void SetShadMult(TimeValue t, float m) {}
	virtual float GetShadMult(TimeValue t, Interval &valid = Interval(0,0)) { return 1.0f; }

	virtual Texmap* GetProjMap() { return NULL;  }
	virtual void SetProjMap(Texmap* pmap) {}
	virtual Texmap* GetShadowProjMap() { return NULL;  }
	virtual void SetShadowProjMap(Texmap* pmap) {}

	virtual void SetAmbientOnly(BOOL onOff) {  }
	virtual BOOL GetAmbientOnly() { return FALSE; }

	virtual void SetEmitterEnable(TimeValue t, BOOL onOff) {}
	virtual BOOL GetEmitterEnable(TimeValue t, Interval& valid = Interval(0,0)) { return 0; }
	virtual void SetEmitterEnergy(TimeValue t, float energy) {}
	virtual float GetEmitterEnergy(TimeValue t, Interval& valid = Interval(0,0)) { return 0.0f; }
	virtual void SetEmitterDecayType(TimeValue t, int decay) {}
	virtual int  GetEmitterDecayType(TimeValue t, Interval& valid = Interval(0,0)) { return 0; }
	virtual void SetEmitterCausticPhotons(TimeValue t, int photons) {}
	virtual int  GetEmitterCausticPhotons(TimeValue t, Interval& valid = Interval(0,0)) { return 0; }
	virtual void SetEmitterGlobalIllumPhotons(TimeValue t, int photons) {}
	virtual int  GetEmitterGlobalIllumPhotons(TimeValue t, Interval& valid = Interval(0,0)) { return 0; }
};


#endif // __GENLIGHT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\gcomm.h ===
//-----------------------------------------------------------------------------
// ------------------
// File ....: gcomm.h
// ------------------
// Author...: Gus J Grubba
// Date ....: September 1995
// O.S. ....: Windows NT 3.51
//
// Note ....: Copyright 1991, 1995 Gus J Grubba
//
// History .: Sep, 03 1995 - Ported to C++ / WinNT
//
//-----------------------------------------------------------------------------

#ifndef _GCOMMINCLUDE_
#define _GCOMMINCLUDE_

//-----------------------------------------------------------------------------
//-- Common Error Codes

typedef unsigned int GCRES;

#define GCRES_SUCCESS           0x0000

//-----------------------------------------------------------------------------
//-- Error Handler

typedef void (WINAPI *PERROR_HANDLER)(
     int          ErrorCode,
     const TCHAR *ErrorMessage
    );

//-----------------------------------------------------------------------------
//-- Client Types

#define gcTCP         1    //-- 0x1000 ... 0x1FFF
#define gcUART        2    //-- 0x2000 ... 0x2FFF
#define gcSCSI        3    //-- 0x3000 ... 0x3FFF
#define gcCENTRONICS  4    //-- 0x4000 ... 0x4FFF
#define gcIPX         5    //-- 0x5000 ... 0x5FFF
#define gcNETBIOS     6    //-- 0x6000 ... 0x6FFF

//-----------------------------------------------------------------------------
//-- Error Types (for logging)

#define ERR_FATAL  0 // Fatal Error, won't procede
#define ERR_WARN   1 // Warning Error, will procede with defaults (No Error Dialogue)
#define ERR_INFO   2 // Not an error, just a logging message (No Error Dialogue)
#define ERR_DEBUG  3 // Not an error, just debugging information (No Error Dialogue)

//-----------------------------------------------
//-- NetBios

#ifndef ADAPTER_STATUS_BLOCK

#include <nb30.h>

typedef struct tag_ADAPTER_STATUS_BLOCK {
	ADAPTER_STATUS	asb_header;
	NAME_BUFFER		asb_Names[32];
} ADAPTER_STATUS_BLOCK;

typedef struct tag_MAC_ADDRESS {
	unsigned char addr[6];
} MAC_ADDRESS;

#endif

//-----------------------------------------------------------------------------
//--  FileName Class Definition -----------------------------------------------
//-----------------------------------------------------------------------------
// #> CFileName
//
     
class CFileName {
		TCHAR	filename[MAX_PATH];
	public:
		GCOMMEXPORT 		CFileName	( ) { filename[0] = 0; }
		GCOMMEXPORT 		CFileName	( TCHAR *name ) { SetName(name); }
		GCOMMEXPORT void	SetName		( TCHAR *name ) { _tcscpy(filename,name); }
		GCOMMEXPORT void	SetExtension( TCHAR *ext );
		GCOMMEXPORT TCHAR*	Extension	( );
		GCOMMEXPORT TCHAR*	FileName	( );
		GCOMMEXPORT DWORD	FileSize	( );
		GCOMMEXPORT TCHAR*	FullName	( ) { return filename; }
};

//-----------------------------------------------------------------------------
//--  Timer Class Definition --------------------------------------------------
//-----------------------------------------------------------------------------
// #> Timer
//
     
class Timer {

        float timer,count;

     public:

        //-- Timer methods ----------------------------------------------------
        //
        //   Timers are kept in fractional units of seconds with a resolution 
        //   no less than 10ms.

        GCOMMEXPORT             Timer            ( float t = 2.0f ) { timer = t; Start(); }
        GCOMMEXPORT void        Set              ( float t = 2.0f ) { timer = t; }
        GCOMMEXPORT void        Start            ( );
        GCOMMEXPORT BOOL        IsTimeout        ( );
        GCOMMEXPORT float       Elapsed          ( );

};

//-----------------------------------------------------------------------------
//--  Base Class Definition ---------------------------------------------------
//-----------------------------------------------------------------------------
// #> tcCOMM
//
     
class tcCOMM {

     private:   
        
        //-- Windows Specific -------------------------------------------------
        
        HINSTANCE           tcphInst;
        HWND                hWnd;

        //-- System -----------------------------------------------------------
        
        BOOL                silentmode;
        PERROR_HANDLER      errorhandler;
        TCHAR               error_title[64];

     public:

        //-- Constructors/Destructors -----------------------------------------

        GCOMMEXPORT         tcCOMM           ( );
        GCOMMEXPORT        ~tcCOMM           ( );
     
        //-- Initialization process -------------------------------------------
        //
        
        virtual BOOL        Init             ( HWND hWnd         )=0;
        virtual BOOL        Setup            ( void *setupdata   )=0;
        virtual void        Close            ( )=0;

        //-- Application provided hooks for saving/restoring session ----------
        //
        //   If the application wants to save and restore session data, such
        //   as numbers, names, addresses, etc., it should use these methods.
        //   Each subclassed object should implement a method for saving and
        //   restoring its own session data.
        //
        //   The host will issue a LoadSession() with  previously saved data
        //   before issuing an Init() call. At the end of a session, it will
        //   issue the SaveSession() before calling Close();
        //
        //   The host will use EvaluateDataSize() to find out the size of the
        //   buffer needed (called prior to SaveSession()).
        //   

        virtual BOOL        SaveSession      ( void *ptr )=0;
        virtual BOOL        LoadSession      ( void *ptr )=0;
        virtual DWORD       EvaluateDataSize ( )=0;
        
        //-- Services ---------------------------------------------------------
        //
        //   If you want your own error handler, use this function to register
        //   one. Whenever an error occurs, it will be called with an error 
        //   code and with an optional error string message. The function
        //   prototype is:
        //
        //   void WINAPI ErrorHandler (int ErrorCode, TCHAR *ErrorMessage);
        //
        //   ErrorCode is one of the defined error codes above.
        //   ErrorMessage, if not NULL, contains a textual description of the
        //   error and can be used directly.
        //
        //   Note that only ERR_FATAL warrants a mandatory action. All other
        //   error types are handled as you please. The idea is to provide
        //   ongoing messages for logging purposes and debugging. Internally,
        //   only ERR_FATAL will generate a dialogue message (provided the
        //   silence flag is set to FALSE);
        //
        
        GCOMMEXPORT void    RegisterErrorHandler  (PERROR_HANDLER handler);
        
        //-- If you do not provide an error handler, the driver will produce
        //   its own error messages. If you don't pass a Window handler, the
        //   driver will use the system window (root) as the parent window.
        //   
        //   You can set the driver not to produce any error message at all 
        //   by setting the Silent flag to TRUE. Simply use SetSilentMode().


        HWND                GethWnd          ( )          { return  hWnd; }
        void                SethWnd          ( HWND hwnd ) { hWnd = hwnd; }
        BOOL                SilentMode       ( )     { return silentmode; }
        void                SetSilentMode    ( BOOL v ) { silentmode = v; }

        //-- Error Dialogue Title ---------------------------------------------
        //
        //   If you let the driver produce its own error dialogue boxes, you
        //   still can set the Window title if you want something other than
        //   the default "Transport Error".
        
        void                SetErrorTitle    ( TCHAR *t ) {_tcscpy(error_title,t);}

        //-- Internal Services ------------------------------------------------
        //
    
        void                SetInstance      ( HINSTANCE hi ) { tcphInst = hi; }
        HINSTANCE           GetInstance      (  )             { return (tcphInst); }
        TCHAR              *GetLastErrorText ( TCHAR *buf, DWORD size );
        void                Error            ( int type, const TCHAR *message );

};

//-----------------------------------------------------------------------------
//-- Interface

GCOMMEXPORT void*	gcommCreate		( int   type		);
GCOMMEXPORT void	gcommDestroy	( void* ptr			);
GCOMMEXPORT bool	gcInitNetRender	( char* target=NULL	);

//-----------------------------------------------------------------------------
//-- Utilities

GCOMMEXPORT	bool	gcGetMacAddress			(MAC_ADDRESS *addr);
GCOMMEXPORT	bool	gcMatchMacAddress		(MAC_ADDRESS *addr1, MAC_ADDRESS *addr2);
GCOMMEXPORT	void	gcMac2String			(MAC_ADDRESS *addr, TCHAR *string);
GCOMMEXPORT	void	gcMac2StringCondensed	(MAC_ADDRESS *addr, TCHAR *string);

#include "tcp.h"

#endif

//-- EOF: gcomm.h -------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\geom.h ===
#ifndef _GEOM_H_

#define _GEOM_H_

#include <export.h>
#include "gfloat.h"
#include "point2.h"
#include "point3.h"
#include "point4.h"
#include "ipoint2.h"
#include "ipoint3.h"
#include "dpoint3.h"
#include "matrix2.h"
#include "matrix3.h"
#include "quat.h"
#include "stack3.h"
#include "box3.h"
#include "box2.h"
#include "bitarray.h"
#include "color.h"
#include "acolor.h"
#include "euler.h"
#include "gutil.h"
#endif // _GEOM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\geomlib.h ===
#ifndef _GEOMLIB_H_

#define _GEOMLIB_H_

#define IMPORTING
#include "geom.h"
#undef IMPORTING

#endif // _GEOMLIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\gfloat.h ===
/**********************************************************************
 *<
	FILE: gfloat

	DESCRIPTION: Single Precision Floating Point Routines

	CREATED BY: Don Brittain & Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef _GFLOAT_H 

#define _GFLOAT_H


//-------------------------------------------------------------------------------
// Single precision floating point stuff...
//
inline void SinCos (float angle, float *sine, float *cosine) 
{
#ifdef _M_IX86	// if on Intel, use assembly language
	__asm {
		push		ecx
        fld         dword ptr angle
        fsincos
		mov 		ecx, dword ptr[cosine]
        fstp        dword ptr [ecx]
		mov 		ecx, dword ptr[sine]
        fstp        dword ptr [ecx]
		pop			ecx
    }
#else
    *sine   = (float)sin (angle);
    *cosine = (float)cos (angle);
#endif
}

inline float Sin(float angle)
{
#ifdef _M_IX86
	float s, c;
	SinCos(angle, &s, &c);
	return s;
#else
	return (float)sin((double)angle);
#endif
}

inline float Cos(float angle)
{
#ifdef _M_IX86
	float s, c;
	SinCos(angle, &s, &c);
	return c;
#else
	return (float)cos((double)angle);
#endif
}

inline float Sqrt(float arg)
{
#ifdef _M_IX86
	float ans;
    __asm {
        fld         dword ptr arg
        fsqrt
        fstp        dword ptr [ans]
    	}
	return ans;
#else
	return (float)sqrt((double)arg);
#endif
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\gfxlib.h ===
#ifndef _GFXLIB_H_

#define _GFXLIB_H_

#define IMPORTING
#include "gfx.h"
#undef IMPORTING

#endif // _GFXLIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\gizmo.h ===
/**********************************************************************
 *<
	FILE: gizmo.h

	DESCRIPTION: An apparatus object

	CREATED BY: Rolf Berteig

	HISTORY: 4-15-96

 *>	Copyright (c) 1996 Rolf Berteig, All Rights Reserved.
 **********************************************************************/

#ifndef __GIZMO_H__
#define __GIZMO_H__

class IParamMap;

class GizmoObject : public HelperObject {
	public:
		IParamBlock *pblock;		
		static IParamMap *pmapParam;
		static IObjParam *ip;

		CoreExport GizmoObject();
		CoreExport ~GizmoObject();

		CoreExport static GizmoObject *editOb;

		// From BaseObject
		CoreExport void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
		CoreExport void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		CoreExport int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt);		
		CoreExport int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);		

		// From Object
		ObjectState Eval(TimeValue time) {return ObjectState(this);}
		void InitNodeName(TSTR& s) {s = GetObjectName();}		
		CoreExport int CanConvertToType(Class_ID obtype);
		CoreExport Object* ConvertToType(TimeValue t, Class_ID obtype);		
		CoreExport void GetWorldBoundBox(TimeValue t, INode* inode, ViewExp* vpt, Box3& box );
		CoreExport void GetLocalBoundBox(TimeValue t, INode* inode, ViewExp* vpt, Box3& box );
		CoreExport void GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm, BOOL useSel );		

		// Animatable methods		
		//void GetClassName(TSTR& s) {s = GetObjectName();}		
		int NumSubs() { return 1; }  
		Animatable* SubAnim(int i) { return pblock; }
		TSTR SubAnimName(int i) {return _T("Parameters");}

		// From ref
		int NumRefs() {return 1;}
		RefTargetHandle GetReference(int i) {return pblock;}
		void SetReference(int i, RefTargetHandle rtarg) {pblock=(IParamBlock*)rtarg;}		
		CoreExport RefResult NotifyRefChanged(Interval changeInt,RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message);
		
		// Must implement...
		Interval ObjectValidity(TimeValue t) {return FOREVER;}		
		virtual void InvalidateUI() {}
		virtual	ParamDimension *GetParameterDim(int pbIndex) {return defaultDim;}
		virtual TSTR GetParameterName(int pbIndex) {return TSTR(_T("Parameter"));}
		virtual void DrawGizmo(TimeValue t,GraphicsWindow *gw) {}
		virtual Point3 WireColor() { return GetUIColor(COLOR_ATMOS_APPARATUS); } // mjm - 4.20.99
		virtual void GetBoundBox(Matrix3 &mat,TimeValue t,Box3 &box) {}
	};

#endif //__GIZMO_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\gfx.h ===
/**********************************************************************
 *<
	FILE: gfx.h

	DESCRIPTION: main graphics system include file.

	CREATED BY: Don Brittain

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#if !defined(_GFX_H_)

#define _GFX_H_

#include "geomlib.h"
#include "export.h"
#include "mtl.h"

#ifndef UtilExport
#define UtilExport __declspec( dllimport )
#endif
#include "assert1.h"
#include "tab.h"

typedef Tab<DWORD> DWTab;
typedef unsigned short MtlID;

// strip-related stuff

#define PUT_NORMALS_IN_STRIPS

class Strip {
public:
	MtlID	mID;
	DWORD	smGrp;
	DWTab	v;
	DWTab	tv;
	void AddVert(DWORD vtx)	{ v.Append(1, &vtx); }
	void AddVert(DWORD vtx, DWORD tvtx) { v.Append(1, &vtx); tv.Append(1, &tvtx); }
#ifdef PUT_NORMALS_IN_STRIPS
	DWTab	n;
	void AddVertN(DWORD vtx, DWORD nor) { v.Append(1, &vtx); n.Append(1, &nor); }
	void AddVertN(DWORD vtx, DWORD tvtx, DWORD nor) { v.Append(1, &vtx); tv.Append(1, &tvtx); n.Append(1, &nor); }
#endif
};

typedef Strip *StripPtr;
typedef Tab<StripPtr> StripTab;


// General definitions

#define WM_SHUTDOWN			(WM_USER+2001)
#define WM_INIT_COMPLETE	(WM_USER+2002)

#define GW_MAX_FILE_LEN		128
#define GW_MAX_CAPTION_LEN	128

#define GW_MAX_VERTS		32
#define GFX_MAX_STRIP		100

typedef BOOL	(*HitFunc)(int, int, void *);

// Rendering modes
#define GW_NO_ATTS			0x00000
#define GW_WIREFRAME		0x00001
#define GW_ILLUM			0x00002
#define GW_FLAT				0x00004
#define GW_SPECULAR			0x00008
#define GW_TEXTURE			0x00010
#define GW_Z_BUFFER			0x00020
#define GW_PERSP_CORRECT	0x00040
#define GW_POLY_EDGES		0x00080
#define GW_BACKCULL			0x00100
#define GW_TWO_SIDED		0x00200
#define GW_COLOR_VERTS		0x00400
#define GW_SHADE_CVERTS		0x00800
#define GW_PICK				0x01000
#define GW_BOX_MODE			0x02000
#define GW_ALL_EDGES		0x04000
#define GW_VERT_TICKS		0x08000
#define GW_SHADE_SEL_FACES	0x10000

#define GW_LIGHTING			(GW_ILLUM | GW_SPECULAR)


// spotlight shapes
#define GW_SHAPE_RECT		0
#define GW_SHAPE_CIRCULAR	1

// texture tiling
#define GW_TEX_NO_TILING	0
#define GW_TEX_REPEAT		1
#define GW_TEX_MIRROR		2

// View volume clip flags
#define GW_LEFT_PLANE		0x0100
#define GW_RIGHT_PLANE		0x0200
#define GW_BOTTOM_PLANE		0x0400
#define GW_TOP_PLANE		0x0800
#define GW_FRONT_PLANE		0x1000
#define GW_BACK_PLANE		0x2000
#define GW_PLANE_MASK		0x3f00

// edge styles
#define GW_EDGE_SKIP		0
#define GW_EDGE_VIS			1
#define GW_EDGE_INVIS		2

// buffer types (for dual-plane stuff)
#define BUF_F_BUFFER		0
#define BUF_Z_BUFFER		1

// support method return values
#define GW_DOES_SUPPORT			TRUE
#define GW_DOES_NOT_SUPPORT		FALSE

// support queries
#define GW_SPT_TXT_CORRECT		0	// allow persp correction to be toggled?
#define GW_SPT_GEOM_ACCEL		1	// do 3D xforms, clipping, lighting thru driver?
#define GW_SPT_TRI_STRIPS		2	// send down strips instead of individual triangles?
#define GW_SPT_DUAL_PLANES		3	// allow dual planes to be used?
#define GW_SPT_SWAP_MODEL		4	// update viewports with complete redraw on WM_PAINT?
#define GW_SPT_INCR_UPDATE		5	// redraw only damaged areas on object move?
#define GW_SPT_1_PASS_DECAL		6	// do decaling with only one pass?
#define GW_SPT_DRIVER_CONFIG	7	// allow driver config dialog box?
#define GW_SPT_TEXTURED_BKG		8	// is viewport background a texture?
#define GW_SPT_VIRTUAL_VPTS		9	// are viewports bigger than the window allowed?
#define GW_SPT_PAINT_DOES_BLIT	10	// does WM_PAINT cause a backbuffer blit?
#define GW_SPT_WIREFRAME_STRIPS	11	// if true, wireframe objects are sent as tristrips
#define GW_SPT_ORG_UPPER_LEFT	12	// true if device origin is at upper left, false o/w
#define GW_SPT_ARRAY_PROCESSING	13	// true if the driver can handle vertex array data
#define GW_SPT_TOTAL			14	// always the max number of spt queries

// display state of the graphics window
#define GW_DISPLAY_MAXIMIZED	1
#define GW_DISPLAY_WINDOWED		2
#define GW_DISPLAY_INVISIBLE	3

// multi-pass rendering
#define GW_PASS_ONE				0
#define GW_PASS_TWO				1

// light types
enum LightType { OMNI_LGT, SPOT_LGT, DIRECT_LGT, AMBIENT_LGT };

// Light attenuation types -- not fully implemented
#define GW_ATTEN_NONE		0x0000
#define GW_ATTEN_START		0x0001
#define GW_ATTEN_END		0x0002
#define GW_ATTEN_LINEAR		0x0010
#define GW_ATTEN_QUAD		0x0020

// General 3D light structure
class Light {
public:
    DllExport Light();
    LightType		type;
    Point3			color;
    int				attenType;
    float			attenStart;
	float			attenEnd;
    float			intensity;
    float			hotSpotAngle;
	float			fallOffAngle;
	int				shape;
	float			aspect;
	int				overshoot;
	BOOL 			affectDiffuse;
	BOOL 			affectSpecular;
};

enum CameraType { PERSP_CAM, ORTHO_CAM };

// General camera structure
class Camera {
public:
	DllExport Camera();
	void			setPersp(float f, float asp)
						{ type = PERSP_CAM; persp.fov = f; 
						  persp.aspect = asp; makeMatrix(); }
	void			setOrtho(float l, float t, float r, float b)
						{ type = ORTHO_CAM; ortho.left = l; ortho.top = t; 
						  ortho.right = r; ortho.bottom = b; makeMatrix(); }
	void			setClip(float h, float y) 
						{ hither = h; yon = y; makeMatrix(); }
	CameraType		getType(void)	{ return type; }
	float			getHither(void) { return hither; }
	float			getYon(void)	{ return yon; }
	DllExport void	reset();
	void			getProj(float mat[4][4])	
						{ memcpy(mat, proj, 16 * sizeof(float)); }
private:
	DllExport void	makeMatrix();
	float			proj[4][4];
	CameraType		type;
	union {
	    struct {
            float	fov;
            float	aspect;
		} persp;
		struct {
		    float	left;
		    float	right;
		    float	bottom;
		    float	top;
		} ortho;
	};
	float			hither;
	float			yon;
};

const double pi        = 3.141592653589793;
const double piOver180 = 3.141592653589793 / 180.0;

// Color types (used by setColor)
enum ColorType { LINE_COLOR, FILL_COLOR, TEXT_COLOR, CLEAR_COLOR };

// Marker types
enum MarkerType  { POINT_MRKR, HOLLOW_BOX_MRKR, PLUS_SIGN_MRKR, 
						   ASTERISK_MRKR, X_MRKR, BIG_BOX_MRKR, 
						   CIRCLE_MRKR, TRIANGLE_MRKR, DIAMOND_MRKR,
						   SM_HOLLOW_BOX_MRKR, SM_CIRCLE_MRKR, 
						   SM_TRIANGLE_MRKR, SM_DIAMOND_MRKR,
						   DOT_MRKR, SM_DOT_MRKR
};

// Region types (for built-in hit-testing)
#define POINT_RGN	0x0001
#define	RECT_RGN	0x0002
#define CIRCLE_RGN	0x0004
#define FENCE_RGN	0x0008

typedef struct tagCIRCLE
{
    LONG  x;
    LONG  y;
	LONG  r;
} CIRCLE;

class HitRegion {
public:
	int				type;
	int				crossing;// not used for point
	int				epsilon; // not used for rect or circle
	union {
		POINT		pt;
		RECT		rect;
		CIRCLE		circle;
		POINT *		pts;
	};
};

inline int ABS(const int x) { return (x > 0) ? x : -x; }

typedef void (*GFX_ESCAPE_FN)(void *);


// driver types for getDriver() method
#define GW_DRV_RENDERER		0
#define GW_DRV_DEVICE		1

// for possible future implementation
#define GW_HEIDI			0
#define GW_OPENGL			1
#define GW_DIRECT3D			2
#define GW_HEIDI3D			3
#define GW_NULL				4
#define GW_CUSTOM			5

// graphics window setup structure
class GWinSetup {
public:
    DllExport GWinSetup();
    TCHAR		caption[GW_MAX_CAPTION_LEN];
	TCHAR		renderer[GW_MAX_FILE_LEN];
	TCHAR		device[GW_MAX_FILE_LEN];
	DWORD		winStyle;
	POINT		size;
	POINT		place;
	int			id;
	int			type;
};

// abstract graphics window class
class GraphicsWindow {
public:
	virtual	~GraphicsWindow() {}
	virtual void	postCreate(int ct, GraphicsWindow **gw) = 0;
	virtual void	shutdown() = 0;
	virtual int		getVersion() = 0;
	virtual TCHAR * getDriverString(void) = 0;
	virtual void	config(HWND hWnd) = 0;
	virtual int		querySupport(int what) = 0;

	virtual HWND	getHWnd(void) = 0;
	virtual void	setPos(int x, int y, int w, int h) = 0;
	virtual void	setDisplayState(int s) = 0;
	virtual int		getDisplayState() = 0;
	virtual int		getWinSizeX() = 0;
	virtual int		getWinSizeY() = 0;
	virtual DWORD	getWinDepth(void) = 0;
	virtual DWORD	getHitherCoord(void) = 0;
	virtual DWORD	getYonCoord(void) = 0;
	virtual void	getTextExtents(TCHAR *text, SIZE *sp) = 0;
	virtual int		getMaxStripLength() { return GFX_MAX_STRIP; }
	virtual void	setFlags(DWORD f) = 0;
	virtual DWORD	getFlags() = 0;

	virtual void	resetUpdateRect() = 0;
	virtual void	enlargeUpdateRect(RECT *rp) = 0;
	virtual int		getUpdateRect(RECT *rp) = 0;
    virtual void	updateScreen() = 0;

	virtual BOOL	setBufAccess(int which, int b) = 0;
	virtual BOOL	getBufAccess(int which) = 0;
	virtual BOOL	getBufSize(int which, int *size) = 0;
	virtual BOOL	getBuf(int which, int size, void *buf) = 0;
	virtual BOOL	setBuf(int which, int size, void *buf, RECT *rp) = 0;
	virtual BOOL	getDIB(BITMAPINFO *bmi, int *size) = 0;
	virtual BOOL	setBackgroundDIB(int width, int height, BITMAPINFO *bmi) = 0;
	virtual void	setBackgroundOffset(int x, int y) = 0;
	virtual int		getTextureSize(int bkg=FALSE) = 0;
	virtual DWORD	getTextureHandle(BITMAPINFO *bmi) = 0;
	virtual void	freeTextureHandle(DWORD handle) = 0;
	virtual BOOL	setTextureByHandle(DWORD handle) = 0;
	virtual BOOL	setTextureTiling(int u, int v, int w=GW_TEX_NO_TILING) = 0;
	virtual int		getTextureTiling(int which) = 0;

	virtual void	beginFrame() = 0;
	virtual void	endFrame() = 0;
	virtual void	setViewport(int x, int y, int w, int h) = 0;
	virtual void	setVirtualViewportParams(float zoom, float xOffset, float yOffset) = 0;
	virtual void	setUseVirtualViewport(int onOff) = 0;
    virtual void	clearScreen(RECT *rp, int useBkg = FALSE) = 0;
    virtual void	setTransform(const Matrix3 &m) = 0;
	virtual Matrix3	getTransform(void) = 0;
	virtual void	multiplePass(int pass, BOOL onOff, float scaleFact = 1.005f) = 0;
    virtual void	setTexTransform(const Matrix3 &m) = 0;
	virtual BOOL	getFlipped(void)=0;
	virtual void	setSkipCount(int c) = 0;
	virtual int		getSkipCount(void) = 0;
	virtual void	setViewportLimits(DWORD l) = 0;
	virtual DWORD	getViewportLimits(void) = 0;
    virtual void	setRndLimits(DWORD l) = 0;
	virtual DWORD 	getRndLimits(void) = 0;
	virtual DWORD 	getRndMode(void) = 0;
	virtual int		getMaxLights(void) = 0;
    virtual void	setLight(int num, const Light *l) = 0;
	virtual void	setLightExclusion(DWORD exclVec) = 0;
    virtual void	setCamera(const Camera &c) = 0;
	virtual void	setCameraMatrix(float mat[4][4], Matrix3 *invTM, int persp, float hither, float yon) = 0;
	virtual void	getCameraMatrix(float mat[4][4], Matrix3 *invTM, int *persp, float *hither, float *yon) = 0;
    virtual void	setColor(ColorType t, float r, float g, float b) = 0;
			void	setColor(ColorType t, Point3 clr) { setColor(t,clr.x,clr.y,clr.z); }
    virtual void	setMaterial(const Material &m) = 0;
	virtual Material *getMaterial(void) = 0;

	virtual DWORD	hTransPoint(const Point3 *in, IPoint3 *out) = 0;
	virtual DWORD	wTransPoint(const Point3 *in, IPoint3 *out) = 0;
	virtual DWORD	transPoint(const Point3 *in, Point3 *out) = 0;
	virtual void	lightVertex(const Point3 &pos, const Point3 &nor, Point3 &rgb) = 0;

	virtual void	hText(IPoint3 *xyz, TCHAR *s) = 0;
	virtual void	hMarker(IPoint3 *xyz, MarkerType type) = 0;
	virtual void	hPolyline(int ct, IPoint3 *xyz, Point3 *rgb, int closed, int *es) = 0;
			void	hPolyline(int ct, IPoint3 *xyz, Point3 *rgb, Point3 *uvw, int closed, int *es)
					{ hPolyline(ct, xyz, rgb, closed, es); }
	virtual void	hPolygon(int ct, IPoint3 *xyz, Point3 *rgb, Point3 *uvw) = 0;
	virtual void	hTriStrip(int ct, IPoint3 *xyz, Point3 *rgb, Point3 *uvw) = 0;

	virtual void	wText(IPoint3 *xyz, TCHAR *s) = 0;
	virtual void	wMarker(IPoint3 *xyz, MarkerType type) = 0;
	virtual void	wPolyline(int ct, IPoint3 *xyz, Point3 *rgb, int closed, int *es) = 0;
			void	wPolyline(int ct, IPoint3 *xyz, Point3 *rgb, Point3 *uvw, int closed, int *es)
					{ wPolyline(ct, xyz, rgb, closed, es); }
	virtual void	wPolygon(int ct, IPoint3 *xyz, Point3 *rgb, Point3 *uvw) = 0;
	virtual void	wTriStrip(int ct, IPoint3 *xyz, Point3 *rgb, Point3 *uvw) = 0;

    virtual void 	text(Point3 *xyz, TCHAR *s) = 0;
    virtual void	marker(Point3 *xyz, MarkerType type) = 0;
	virtual void	polyline(int ct, Point3 *xyz, Point3 *rgb, int closed, int *es) = 0;
			void	polyline(int ct, Point3 *xyz, Point3 *rgb, Point3 *uvw, int closed, int *es)
					{ polyline(ct, xyz, rgb, closed, es); }
	virtual void	polylineN(int ct, Point3 *xyz, Point3 *nor, int closed, int *es) = 0;
	virtual void	startSegments() = 0;
	virtual void	segment(Point3 *xyz, int vis) = 0;
	virtual void	endSegments() = 0;
	virtual void 	polygon(int ct, Point3 *xyz, Point3 *rgb, Point3 *uvw) = 0;
	virtual void 	polygonN(int ct, Point3 *xyz, Point3 *nor, Point3 *uvw) = 0;
	virtual void	triStrip(int ct, Point3 *xyz, Point3 *rgb, Point3 *uvw) = 0;
	virtual void	triStripN(int ct, Point3 *xyz, Point3 *nor, Point3 *uvw) = 0;
	virtual void	startTriangles() = 0;
	virtual void	triangle(Point3 *xyz, Point3 *rgb) = 0;
	virtual void	triangleN(Point3 *xyz, Point3 *nor, Point3 *uvw) = 0;
	virtual void	triangleNC(Point3 *xyz, Point3 *nor, Point3 *rgb) = 0;
	virtual void	triangleNCT(Point3 *xyz, Point3 *nor, Point3 *rgb, Point3 *uvw) = 0;
	virtual void	triangleW(Point3 *xyz, int *es) = 0;
	virtual void	triangleNW(Point3 *xyz, Point3 *nor, int *es) = 0;
	virtual void	endTriangles() = 0;
	virtual void	loadMeshData(DWORD id, int xyzCt, Point3 *xyz, int norCt, Point3 *nor, int uvwCt, Point3 *uvw, int mtlCt, Material *mtl) = 0;
	virtual void	processStrips(DWORD id, int stripCt, StripTab *s, GFX_ESCAPE_FN fn) = 0;

	virtual void	setHitRegion(HitRegion *rgn) = 0;
	virtual void	clearHitCode(void) = 0;
	virtual BOOL	checkHitCode(void) = 0;
	virtual DWORD	getHitDistance(void) = 0;

	virtual int		isPerspectiveView(void) = 0;
	virtual float	interpWorld(Point3 *world1, Point3 *world2, float sParam, Point3 *interpPt) = 0;

	virtual void	escape(GFX_ESCAPE_FN fn, void *data) = 0;
};

// for Windows int coords with origin at upper-left
inline int wIsFacingBack(const IPoint3 &v0, const IPoint3 &v1, const IPoint3 &v2, int flip=0 )
{
	int s = ( (v0[0]-v1[0])*(v2[1]-v1[1]) - (v2[0]-v1[0])*(v0[1]-v1[1]) ) < 0;
	return flip ? !s : s;
}

// for HEIDI int coords with origin at lower-left
inline int hIsFacingBack(const IPoint3 &v0, const IPoint3 &v1, const IPoint3 &v2, int flip=0 )
{
	int s = ( (v0[0]-v1[0])*(v2[1]-v1[1]) - (v2[0]-v1[0])*(v0[1]-v1[1]) );
	return flip ? s < 0 : s > 0;
}

DllExport HINSTANCE GetGraphicsLibHandle(TCHAR *driverLibName);
DllExport BOOL GraphicsSystemIsAvailable(HINSTANCE drv);
DllExport BOOL GraphicsSystemCanConfigure(HINSTANCE drv);
DllExport BOOL GraphicsSystemConfigure(HWND hWnd, HINSTANCE drv);
DllExport void FreeGraphicsLibHandle(HINSTANCE drv);

DllExport GraphicsWindow *createGW(HWND hWnd, GWinSetup &gws);

DllExport void getRegionRect(HitRegion *hr, RECT *rect);
DllExport BOOL pointInRegion(int x, int y, HitRegion *hr);

DllExport int distToLine(int x, int y, int *p1, int *p2);
DllExport int lineCrossesRect(RECT *rc, int *p1, int *p2);
DllExport int segCrossesRect(RECT *rc, int *p1, int *p2);
DllExport int segCrossesCircle(int cx, int cy, int r, int *p1, int *p2);
DllExport BOOL insideTriangle(IPoint3 &p0, IPoint3 &p1, IPoint3 &p2, IPoint3 &q);
DllExport int getZfromTriangle(IPoint3 &p0, IPoint3 &p1, IPoint3 &p2, IPoint3 &q);


// colors for drawing in viewports
#define COLOR_SELECTION				0
#define COLOR_SUBSELECTION			1
#define COLOR_FREEZE				2
#define COLOR_GRID					3
#define COLOR_GRID_INTENS			4
#define COLOR_SF_LIVE				5
#define COLOR_SF_ACTION				6
#define COLOR_SF_TITLE				7
#define COLOR_VP_LABELS				8
#define COLOR_VP_INACTIVE			9
#define COLOR_ARCBALL				10
#define COLOR_ARCBALL_HILITE		11
#define COLOR_ANIM_BUTTON			12
#define COLOR_SEL_BOXES				13
#define COLOR_LINK_LINES			14
#define COLOR_TRAJECTORY			15
#define COLOR_ACTIVE_AXIS			16
#define COLOR_INACTIVE_AXIS			17
#define COLOR_SPACE_WARPS			18
#define COLOR_DUMMY_OBJ				19
#define COLOR_POINT_OBJ				20
#define COLOR_POINT_AXES			21
#define COLOR_TAPE_OBJ				22
#define COLOR_BONES					23
#define COLOR_GIZMOS				24
#define COLOR_SEL_GIZMOS			25
#define COLOR_SPLINE_VECS			26
#define COLOR_SPLINE_HANDLES		27
#define COLOR_PATCH_LATTICE			28	// No longer used -- TH 2/20/99
#define COLOR_PARTICLE_EM			29
#define COLOR_CAMERA_OBJ			30
#define COLOR_CAMERA_CONE			31
#define COLOR_CAMERA_HORIZ			32
#define COLOR_NEAR_RANGE			33
#define COLOR_FAR_RANGE				34
#define COLOR_LIGHT_OBJ				35
#define COLOR_TARGET_LINE			36
#define COLOR_HOTSPOT				37
#define COLOR_FALLOFF				38
#define COLOR_START_RANGE			39
#define COLOR_END_RANGE				40
#define COLOR_VIEWPORT_BKG			41
#define COLOR_TRAJ_TICS_1			42
#define COLOR_TRAJ_TICS_2			43
#define COLOR_TRAJ_TICS_3			44
#define COLOR_GHOST_BEFORE			45
#define COLOR_GHOST_AFTER			46
#define COLOR_12FIELD_GRID			47
#define COLOR_START_RANGE1			48
#define COLOR_END_RANGE1			49
#define COLOR_CAMERA_CLIP  			50
#define COLOR_NURBS_CV				51
#define COLOR_NURBS_LATTICE			52
#define COLOR_NURBS_CP				53
#define COLOR_NURBS_FP				54
#define COLOR_NURBS_DEP				55
#define COLOR_NURBS_ERROR			56
#define COLOR_NURBS_HILITE			57
#define COLOR_NURBS_FUSE			58
#define COLOR_END_EFFECTOR			59
#define COLOR_END_EFFECTOR_STRING	60
#define COLOR_JOINT_LIMIT_SEL		61
#define COLOR_JOINT_LIMIT_UNSEL		62
#define COLOR_IK_TERMINATOR			63
#define COLOR_SF_USER				64
#define COLOR_VERT_TICKS			65
#define COLOR_XRAY					66
#define COLOR_GROUP_OBJ				67
#define COLOR_MANIPULATOR_X			68
#define COLOR_MANIPULATOR_Y			69
#define COLOR_MANIPULATOR_Z			70
#define COLOR_MANIPULATOR_ACTIVE	71
#define COLOR_VPT_CLIPPING			72
#define COLOR_DECAY_RADIUS			73
#define COLOR_VERT_NUMBERS			74
#define COLOR_CROSSHAIR_CURSOR		75

#define COLOR_SV_WINBK              76 // SV Window Background
#define COLOR_SV_NODEBK             77 // SV Default Node Background
#define COLOR_SV_SELNODEBK          78 // SV Selected Node Background
#define COLOR_SV_NODE_HIGHLIGHT     79 // SV Viewport Selected Node Highlight
#define COLOR_SV_MATERIAL_HIGHLIGHT 80 // SV MEDIT Selected Node Highlight
#define COLOR_SV_MODIFIER_HIGHLIGHT 81 // SV Selected Modifier Highlight
#define COLOR_SV_PLUGIN_HIGHLIGHT   82 // SV Plug-in Highlight
#define COLOR_SV_SUBANIM_LINE       83 // SV Subanim line color
#define COLOR_SV_CHILD_LINE         84 // SV Child node line color
#define COLOR_SV_FRAME              85 // SV Frame color
#define COLOR_SV_SELTEXT            86 // SV Selected Label Color
#define COLOR_SV_TEXT               87 // SV Label Color

#define COLOR_UNSEL_TAB				88
#define COLOR_ATMOS_APPARATUS		89	// mjm - 1.21.99
#define COLOR_SUBSELECTION_HARD		90  //2-3-99 watje
#define COLOR_SUBSELECTION_MEDIUM	91  //2-3-99 watje
#define COLOR_SUBSELECTION_SOFT		92  //2-3-99 watje

#define COLOR_SV_UNFOLD_BUTTON      93 // SV Unfold Button
#define COLOR_SV_GEOMOBJECT_BK      94 // Geometry Object Node Background
#define COLOR_SV_LIGHT_BK           95 // Light Node Background
#define COLOR_SV_CAMERA_BK          96 // Camera Node Background
#define COLOR_SV_SHAPE_BK           97 // Shape Node Background
#define COLOR_SV_HELPER_BK          98 // Helper Node Background
#define COLOR_SV_SYSTEM_BK          99 // System Node Background
#define COLOR_SV_CONTROLLER_BK     100 // Controller Node Background
#define COLOR_SV_MODIFIER_BK       101 // Modifier Node Background
#define COLOR_SV_MATERIAL_BK       102 // Material Node Background
#define COLOR_SV_MAP_BK            103 // Map Node Background

#define COLOR_TOTAL					104	// always the max number of colors

// Returns/sets color values for drawing in the viewport (selection, subsel, etc)
DllExport Point3 GetUIColor(int which);
DllExport void SetUIColor(int which, Point3 *clr);
DllExport Point3 GetDefaultUIColor(int which);

#define GetSelColor()		GetUIColor(COLOR_SELECTION)
#define GetSubSelColor()	GetUIColor(COLOR_SUBSELECTION)
#define GetFreezeColor()	GetUIColor(COLOR_FREEZE)


	
#endif // _GFX_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\gizmoimp.h ===
/**********************************************************************
 *<
	FILE: gizmoimp.h

	DESCRIPTION: General atmoshperic gizmo objects

	CREATED BY: Rolf Berteig

	HISTORY: 4-15-96
	         11-13-96 Moved into core

 *>	Copyright (c) 1996 Rolf Berteig, All Rights Reserved.
 **********************************************************************/

#ifndef __GIZMOIMP_H__
#define __GIZMOIMP_H__

#define SPHEREGIZMO_CLASSID	Class_ID(0x3bc31904, 0x67d74ec7)
#define CYLGIZMO_CLASSID	Class_ID(0x3bc31904, 0x67d74ec8)
#define BOXGIZMO_CLASSID	Class_ID(0x3bc31904, 0x67d74ec9)

class SphereGizmoObject : public GizmoObject {
	public:		
		CoreExport SphereGizmoObject();
		CoreExport ~SphereGizmoObject();

		// From BaseObject
		CoreExport CreateMouseCallBack* GetCreateMouseCallBack();
		CoreExport void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);
		CoreExport void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		CoreExport TCHAR *GetObjectName();
		CoreExport void InitNodeName(TSTR& s);

		// Animatable methods
		CoreExport void GetClassName(TSTR& s);
		void DeleteThis() {delete this;}
		Class_ID ClassID() {return SPHEREGIZMO_CLASSID;}
		
		// From ref
		CoreExport RefTargetHandle Clone(RemapDir& remap = NoRemap());		

		// From GizmoObject		
		Interval ObjectValidity(TimeValue t); // mjm - 1.27.99	
		CoreExport void InvalidateUI();
		CoreExport ParamDimension *GetParameterDim(int pbIndex);
		CoreExport TSTR GetParameterName(int pbIndex);
		CoreExport void DrawGizmo(TimeValue t,GraphicsWindow *gw);		
		CoreExport void GetBoundBox(Matrix3 &mat,TimeValue t,Box3 &box);
	};

#define PB_GIZMO_RADIUS	0
#define PB_GIZMO_HEMI	1
#define PB_GIZMO_SEED	2


class CylGizmoObject : public GizmoObject {
	public:		
		CoreExport CylGizmoObject();
		CoreExport ~CylGizmoObject();

		// From BaseObject
		CoreExport CreateMouseCallBack* GetCreateMouseCallBack();
		CoreExport void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);
		CoreExport void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		CoreExport TCHAR *GetObjectName();
		CoreExport void InitNodeName(TSTR& s);

		// Animatable methods
		CoreExport void GetClassName(TSTR& s);
		void DeleteThis() {delete this;}
		Class_ID ClassID() {return CYLGIZMO_CLASSID;}
		
		// From ref
		CoreExport RefTargetHandle Clone(RemapDir& remap = NoRemap());		

		// From GizmoObject		
		Interval ObjectValidity(TimeValue t); // mjm - 1.27.99	
		CoreExport void InvalidateUI();
		CoreExport ParamDimension *GetParameterDim(int pbIndex);
		CoreExport TSTR GetParameterName(int pbIndex);
		CoreExport void DrawGizmo(TimeValue t,GraphicsWindow *gw);		
		CoreExport void GetBoundBox(Matrix3 &mat,TimeValue t,Box3 &box);
	};

#define PB_CYLGIZMO_RADIUS	0
#define PB_CYLGIZMO_HEIGHT	1
#define PB_CYLGIZMO_SEED	2

class BoxGizmoObject : public GizmoObject {
	public:
		CoreExport BoxGizmoObject();
		CoreExport ~BoxGizmoObject();

		// From BaseObject
		CoreExport CreateMouseCallBack* GetCreateMouseCallBack();
		CoreExport void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);
		CoreExport void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		CoreExport TCHAR *GetObjectName();
		CoreExport void InitNodeName(TSTR& s);

		// Animatable methods
		CoreExport void GetClassName(TSTR& s);
		void DeleteThis() {delete this;}
		Class_ID ClassID() {return BOXGIZMO_CLASSID;}
		
		// From ref
		CoreExport RefTargetHandle Clone(RemapDir& remap = NoRemap());		

		// From GizmoObject		
		Interval ObjectValidity(TimeValue t); // mjm - 1.27.99	
		CoreExport void InvalidateUI();
		CoreExport ParamDimension *GetParameterDim(int pbIndex);
		CoreExport TSTR GetParameterName(int pbIndex);
		CoreExport void DrawGizmo(TimeValue t,GraphicsWindow *gw);		
		CoreExport void GetBoundBox(Matrix3 &mat,TimeValue t,Box3 &box);
	};

#define PB_BOXGIZMO_LENGTH	0
#define PB_BOXGIZMO_WIDTH	1
#define PB_BOXGIZMO_HEIGHT	2
#define PB_BOXGIZMO_SEED	3


#endif //__GIZMOIMP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\gport.h ===
/**********************************************************************
 *<
	FILE: gport.h

	DESCRIPTION: Palette management.

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __GPORT__H
#define __GPORT__H


class GPort {
	public:
		// get the palette index associated with the ith slot
		virtual int AnimPalIndex(int i)=0;
	
		// returns a slot number if available, -1 if not:
		// typically called in WM_INITDIALOG processing for as
		// may slots as you need (total availible is 8)
		virtual int GetAnimPalSlot()=0;

		// Release an animated palete slot slot 
		// Typically called in WM_DESTROY for each slot
		// obtained with GetAnimPalSlot
		virtual void ReleaseAnimPalSlot(int i)=0;

		// set the color associated with the ith animated slot
		virtual void SetAnimPalEntry(int i, COLORREF cr)=0;

		// Stuff the standard MAX palette the palette for the HDC,
		// handing back a handle to the old palette.
		virtual HPALETTE PlugPalette(HDC hdc)=0;

		// Create a brush for drawing with the ith animated palette slot color
		virtual HBRUSH MakeAnimBrush(int slotNum, COLORREF col )=0;

		// Update colors calls the Windows UpdateColors on the hdc.
		// Returns 1 iff it changed screen pixel values .
	 	// Call this when get WM_PALETTECHANGED Msg
		virtual int UpdateColors(HDC hdc)=0;

		// After several SetAnimPalEntry calls, call this to affect the
		// HDC's palette
		virtual void AnimPalette(HDC hdc)=0;

		// The companion function to PlugPalette.
		virtual void RestorePalette(HDC hDC,HPALETTE hOldPal)=0;

		// Map an single row of pixels 24 bit color to indices into 
		// the current GPort palette, applying a dither pattern.
		// This routine does NOT do gamma correction.
		// inp points to an array of width RGB triples.
		// outp is an array of width bytes.  x and y are necessary to 
		// establish dither pattern alignment.
		virtual void MapPixels(UBYTE* inp, UBYTE *outp, int x, int y, int width)=0;

		 
		// Display an array of 24bit colors in the HDC: if the current display is 8 bit
		//  it will display it (with dither) using in the GPort palette, otherwise it 
		//  will just blit to the screen. Does NOT do gamma correction.
		//   "drect" is the destination rectangle in the hdc.
		//   "map" points to an array of RGB triples, with bytesPerRow bytes on each scanline.
		//   "xsrc" and "ysrc" are the position within this source raster of the upper left
		//    corner of the rectangle to be copied..
		virtual void DisplayMap(HDC hdc, Rect& drect,int xsrc, int ysrc, UBYTE *map, int bytesPerRow)=0;
		
		// This version stretches the image (if src!=dest).
		//  "dest" is the destination rectangle in the hdc;
		//  "src" is the source rectangle in map.
		virtual void DisplayMap(HDC hdc, Rect& dest, Rect& src, UBYTE *map, int bytesPerRow)=0; 

		// DitherColorSwatch first gamma corrects Color c using the current
		// display gamma. In paletted modes, it will fill rectangle "r" with 
		// a dithered pattern  approximating Color c.  In 24 bit modes it just 
		// fills the rectange with c.
		virtual void DitherColorSwatch(HDC hdc, Rect& r, Color c)=0;

		// This attempts to use the animated color slot indicated by "slot"
		// to paint a rectangular color swatch. 
		// If slot is -1, it will uses DitherColorSwatch.  It does gamma correction.
		virtual void PaintAnimPalSwatch(HDC hdc, DWORD col, int slot, int left, int top, int right, int bottom)=0;

		// get the current GPort palette.
		virtual HPALETTE GetPalette()=0;
	};

// Normally this is the only one of these, and this gets you a pointer to it.
extern CoreExport GPort* GetGPort();


#endif // __GPORT__H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\guplib.h ===
#ifndef __INGUP__
#ifndef __GUPLIB_H_
#define __GUPLIB_H_
#define GUPExport __declspec( dllimport )
#include <gup.h>
#undef  GUPExport
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\gup.h ===
//-----------------------------------------------------------------------------
// ----------------
// File ....: gup.h
// ----------------
// Author...: Gus Grubba
// Date ....: September 1998
//
// History .: Sep, 30 1998 - Started
//
//-----------------------------------------------------------------------------
		
#ifndef	GUP_H_DEFINED
#define	GUP_H_DEFINED

#include <gupapi.h>

//-- Just to make it shorter

#define	dVirtual GUPExport virtual

//-- Forward References

class GUP;

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//-- Plug-Ins Handler
//
	
class GUPHandler {

		//-- DLL Handler ----------------------------------
		
		ClassDesc*	cd;
		Class_ID	id;
		GUP*		instance;
		
	public:

								GUPHandler		( );

		GUPExport	void		SetCD			( ClassDesc *dll )	{ cd = dll;	}
		GUPExport	ClassDesc*	GetCD			( )					{ return cd;}
		GUPExport	void		SetID			( Class_ID cid )	{ id = cid;	}
		GUPExport	Class_ID	GetID			( )					{ return id;}
		GUPExport	void		SetInstance		( GUP *ins )		{ instance = ins;  }
		GUPExport	GUP*		GetInstance		( )					{ return instance; }

		GUPExport	GUP*		Gup				( )					{ return instance; }

};

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//-- List of Loaded Plug-Ins
//
	
class GUPList: public Tab<GUPHandler> {

	public:

		GUPExport			GUPList				( )	{ ; }
		GUPExport	int		FindGup				( const Class_ID id );
		GUPExport	GUP*	CreateInstance		( const Class_ID id );

};

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//-- Global Utility Plug-In Class
//

class GUP {
	
	public:
	
		GUPExport	GUP								( );
		dVirtual	~GUP							( );

		//-----------------------------------------------------------
		//-- Plug-In Service Methods
		
		dVirtual	HINSTANCE		MaxInst			( );
		dVirtual	HWND			MaxWnd			( );
		dVirtual	DllDir*			MaxDllDir		( );
		dVirtual	Interface*		Max				( );
		dVirtual	BitmapManager*	Bmi				( );
		dVirtual	int				EnumTree		( ITreeEnumProc *proc );

		//-----------------------------------------------------------
		//-- Plug-In Service Methods (Scripting)
		
		dVirtual	bool			ExecuteStringScript	( TCHAR *string );
		dVirtual	bool			ExecuteFileScript	( TCHAR *file );

		//-----------------------------------------------------------
		//-----------------------------------------------------------
		//-- Plug-In Implementation Methods
		
		//-----------------------------------------------------------
		// Start() is called at boot time. If the plug-in
		// desires to remain loaded, it returns GUPRESULT_KEEP. If
		// it returns GUPRESULT_NOKEEP, it will be discarded. If it
		// returns GUPRESULT_ABORT MAX will be shut down.

		#define GUPRESULT_KEEP		0x00
		#define GUPRESULT_NOKEEP	0x01
		#define GUPRESULT_ABORT		0x03

		dVirtual	DWORD			Start		( ) = 0;
		
		//-------------------------------------------------
		// Stop is called prior to discarding the plug-in
		// for persistent plug-ins (i.e. only those that 
		// returned GUPRESULT_KEEP for Start() above).
		
		dVirtual	void			Stop		( ) = 0;

		//-------------------------------------------------
		// Control is an entry point for external access to
		// GUP plug-ins. For instance, Utility plugins can
		// invoke their GUP plugin counterpart and have 
		// direct access to them.
		//
		
		dVirtual	DWORD			Control		( DWORD parameter ) { return 0;}

		//-------------------------------------------------
		// Optional Methods for saving the plug-in state
		// within a scene file.

		dVirtual	IOResult		Save		( ISave *isave );
		dVirtual	IOResult		Load		( ILoad *iload );

};

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//-- Main GUP Manager Class
//
//

class GUPManager    {
	
		GUPInterface*	iface;

		int				InitList		( );
		bool			listed;
		
	public:
	
		GUPExport					GUPManager		( GUPInterface *i );
		GUPExport					~GUPManager		( );
		
		GUPList		gupList;
		
		GUPExport	bool			Ready			( );
		GUPExport	bool			Init			( );
		GUPExport	GUPInterface*	Interface		( ) { return iface; }
		GUPExport	IOResult		Save			( ISave *isave );
		GUPExport	IOResult		Load			( ILoad *iload );

};

//-----------------------------------------------------------------------------
//-- Exported
//

extern GUPExport	void			OpenGUP			(  GUPInterface *i );
extern GUPExport	void			CloseGUP		(  );
extern GUPExport	GUPManager*		gupManager; 
extern GUPExport	GUP*			OpenGupPlugIn	( const Class_ID id); 

//-----------------------------------------------------------------------------
//-- Cleanup

#undef	dVirtual
#endif	GUP_H_DEFINED

//-- EOF: gup.h ---------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\gupapi.h ===
//-----------------------------------------------------------------------------
// -------------------
// File ....: gupapi.h
// -------------------
// Author...: Gus Grubba
// Date ....: September 1998
//
// History .: Sep, 30 1998 - Started
//
//-----------------------------------------------------------------------------

//-- GUP Interface class

class GUPInterface {

	public:

		virtual HINSTANCE	AppInst			() = 0;
		virtual HWND		AppWnd			() = 0;
		virtual DllDir*		AppDllDir		() = 0;
		virtual Interface*	Max				() = 0;
		virtual int			EnumTree		( ITreeEnumProc *proc ) = 0;

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\hitdata.h ===
/**********************************************************************
 *<
	FILE: hitdata.h
				  
	DESCRIPTION:  Defines the basic Hit Data class

	CREATED BY: Dan Silva

	HISTORY: created 9 September 1994

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __HITDATA__

#define __HITDATA__

class HitData {
	public:
		virtual ~HitData() {}
	}; 

#endif __HITDATA__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\gutil.h ===
/**********************************************************************
 *<
	FILE: gutil.h

	DESCRIPTION: Geometric utility functions

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef _GUTIL_H 

#define _GUTIL_H


//- BaryCoords-----------------------------------------------------
// Given three points in space forming a triangle (p0,p1,p2), 
// and a fourth point in the plane of that triangle, returns the
// barycentric coords of that point relative to the triangle.

DllExport Point3 BaryCoords(Point3 p0, Point3 p1, Point3 p2, Point3 p);

// Same thing in 2D
DllExport Point3 BaryCoords(Point2 p0, Point2 p1, Point2 p2, Point2 p);



//--RayHitsBox--------------------------------------------------------
// Returns true of the ray pierces the box

DllExport BOOL RayHitsBox(Ray &ray, Box3 &b);


// DistPtToLine ---------------------------------------------------------
// find distance of q from line p0->p1 

DllExport float  DistPtToLine(Point2 *p0, Point2 *p1, Point2 *q );


// Dist3DPtToLine ---------------------------------------------------------
// find distance of q from line p0->p1 

DllExport float  Dist3DPtToLine(Point3* p0, Point3* p1, Point3*  q );


//----------------------------------------------------------------------
// Computing the 3 Bump basis vectors from the UVW's at the triangle.
//
//  input:
//    tv: texture coordinates at 3 triangle vertices
//    v: coordinates of triangle vertices (usually in camera space)
//
// output:
//    bvec: the 3 bump basis vectors (normalized) corresponding to the U,V,and W axes.
//
DllExport void ComputeBumpVectors(const Point3 tv[3], const Point3 v[3], Point3 bvec[3]);



//-------------------------------------------------------------------------------
// Quick and dirty unit vector compression. Only accurate to 1 part in 512
//
ULONG DllExport CompressNormal(Point3 p);

Point3 DllExport DeCompressNormal(ULONG n);

//-------------------------------------------------------------------------------
// JH 10/05/98
// Method to come up with an arbitray axis system given an "up" direction
// Conforms to the AutoCAD algorithm
void DllExport ArbAxis(const Point3& zAxis, Matrix3& matrix);




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\helpsys.h ===
/**********************************************************************
 *<
	FILE: helpsys.h

	DESCRIPTION: Help Class include file.

	CREATED BY: greg finch

	HISTORY:

 *>	Copyright (c) 1998, All Rights Reserved.
 **********************************************************************/

#ifndef _HELPSYS_H_
#define _HELPSYS_H_

#include "contextids.h"
#include "export.h"

#define F1Focus(cmd,data)	getHelpSys().setHelpFocus(cmd,data)
#define F1Help()			getHelpSys().doHelpFocus()
#define Help(cmd,data)		getHelpSys().help(cmd, data)
#define GetClickHelp()		getHelpSys().getClickHelp()

class DllExport HelpSys {
public:
	HelpSys();
	~HelpSys();

    void		setAppHInst(HINSTANCE h);

	void		setClickHelp(int onOff);
	int			getClickHelp()		{ return clickHelp; }
	void		setHelpHWnd(HWND h)	{ helpHWnd = h; }
	HWND		getHelpHWnd()		{ return helpHWnd; }
	void		setHelpFocus(UINT uCommand, DWORD dwData);
	int			doHelpFocus();
	int			help(UINT uCommand, DWORD dwData);
	//int         getKeyID(int which);
	void		setExportedFunctionPointers(void (*enableAcc)(), void (*disableAcc)(), BOOL (*accEnabled)());

private:
	int			clickHelp;
	HWND		helpHWnd;
	HCURSOR		helpCursor;
	HCURSOR		savedCursor;
	UINT		focusCmd;
	DWORD		focusData;
};

struct IDPair {
	DWORD CID;
	DWORD HID;
};

DllExport DWORD     CIDtoHID(int CID, IDPair *array);
DllExport void      SetDialogHelpIDs(HWND hDlg, IDPair *array);
DllExport HelpSys & getHelpSys(void);
DllExport HWND		GetHTMLHelpHWnd();

#endif // _HELPSYS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\hotcheck.h ===
/**********************************************************************
 *<
	FILE:  hotcheck.h

	DESCRIPTION:  Video Color check utilities

	CREATED BY: Dan Silva

	HISTORY: created 26 December 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/


#ifndef __HOTCHECK__H
#define __HOTCHECK__H

#define VID_NTSC 0
#define VID_PAL 1

// Methods
#define HOT_FLAG 0
#define HOT_SCALE_LUM 1
#define HOT_SCALE_SAT 2


CoreExport void  BuildHotTable( int video_type = VID_NTSC );
CoreExport int HotLimit(Color48 *thepix, int method = HOT_SCALE_LUM);  // do video color check


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\hold.h ===
/**********************************************************************
 *<
	FILE: hold.h

	DESCRIPTION:

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __HOLD__H__
#define __HOLD__H__

#define RESTOBJ_DOES_REFERENCE_POINTER		1
#define RESTOBJ_GOING_TO_DELETE_POINTER		2

class HoldStore;
class RestoreObj {
	friend class HoldStore;
	friend class GenUndoObject;
	friend class CheckForFlush;
		RestoreObj *next,*prev;
	public:
		RestoreObj() { next = prev = NULL; }
   		virtual ~RestoreObj() {};
		virtual void Restore(int isUndo)=0;
		virtual void Redo()=0;
		virtual int Size() { return 1; }
		virtual void EndHold() { }
		virtual TSTR Description() { return TSTR(_T("---")); }
		virtual int Execute(int cmd, ULONG arg1=0, ULONG arg2=0, ULONG arg3=0) {return -1;}
	};

class Hold {
  	HoldStore *holdStore, *holdList;
	int undoEnabled;
	int superLevel;
	int putCount;
	HoldStore *ResetStore();
	void Init();
	void AddOpToUndoMgr(TCHAR *name,int id);
	public:
		CoreExport Hold();
		CoreExport ~Hold();
		CoreExport void Put(RestoreObj *rob);
		CoreExport void Begin();
		CoreExport void Suspend();	  // temporarly suspend holding
		CoreExport int IsSuspended();
		CoreExport void Resume();    // resume holding
		CoreExport int	Holding();  // are we holding?
		CoreExport void DisableUndo();  // prevents Undo when Accept is called.
		CoreExport void EnableUndo();
		CoreExport void Restore();  // Restore changes from holdStore. 
		CoreExport void Release();  // Tosses out holdStore. 

		// 3 ways to terminate the Begin()...
		CoreExport void End();  // toss holdStore.
		CoreExport void Accept(int nameID); // record Undo (if enabled), End();
		CoreExport void Accept(TCHAR *name);
		CoreExport void Cancel();   // Restore changes, End() 

		//		
		// Group several Begin-End lists into a single Super-group.
		CoreExport void SuperBegin();
		CoreExport void SuperAccept(int nameID);
		CoreExport void SuperAccept(TCHAR *name);
		CoreExport void SuperCancel();

		// Get the number of times Put() has been called in the current session of MAX
		CoreExport int GetGlobalPutCount();
	};



extern CoreExport Hold theHold;

void CoreExport EnableUndoDebugPrintout(BOOL onoff);


#endif //__HOLD__H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\hsv.h ===
/**********************************************************************
 *<
	FILE: hsv.h

	DESCRIPTION:

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __HSV__H
#define __HSV__H


#define MAXCOLORS 16


// This callback proc gets called after every mouse button up to tell you the
// new color, if you want to do interactive update.

class HSVCallback {
	public:
		virtual	void ButtonDown() {}
		virtual	void ButtonUp(BOOL accept) {}
		virtual	void ColorChanged(DWORD col, BOOL buttonUp)=0;	   										
		virtual	void BeingDestroyed(IPoint2 pos)=0;	// gets called when picker is closed: 
	};

// Put up the Modal dialog.
extern CoreExport int HSVDlg_Do(
	HWND hwndOwner, 		// owning window
	DWORD *lpc,				// pointer to color to be edited
    IPoint2 *spos, 			// starting position, set to ending position
    HSVCallback *callBack,	// called when color changes
	TCHAR *name				// name of color being edited
    );

CoreExport void RGBtoHSV (DWORD rgb, int *ho, int *so, int *vo);
CoreExport DWORD HSVtoRGB (int H, int S, int V);
CoreExport void HSVtoHWBt (int h, int s, int v, int *ho, int *w, int *bt);
CoreExport void HWBttoHSV (int h, int w, int bt, int *ho, int *s, int *v);

// RB: Added floating point versions
class Color;
CoreExport Color RGBtoHSV(Color rgb);
CoreExport Color HSVtoRGB(Color hsv);


// MODELESS Version

class ColorPicker {
	protected:
	~ColorPicker() {}
	public:
		ColorPicker() {}
		virtual void ModifyColor (DWORD color)=0;
		virtual void SetNewColor (DWORD color, TCHAR *name)=0;  
		virtual DWORD GetColor()=0;
		virtual IPoint2 GetPosition()=0;
		virtual void Destroy()=0;  // remove window and delete ColorPicker.
		virtual void InstallNewCB(DWORD col, HSVCallback *pcb, TCHAR *name)=0;
	};

// Create A Modeless Color Picker
CoreExport ColorPicker *CreateColorPicker(HWND hwndOwner, DWORD initColor,
	 IPoint2* spos, HSVCallback *pcallback, TCHAR *name, int objClr=0);
	 
CoreExport void SetCPInitPos(IPoint2 &pos);
CoreExport IPoint2 GetCPInitPos(void);	

#define WM_ADD_COLOR	(WM_USER+2321)	// wParam = color

//--------------------------------------------------------------------------
// Pluggable color picker class ( COLPICK_CLASS_ID )
//--------------------------------------------------------------------------


class ColPick {
	public:
	// Do Modal dialog
	virtual int ModalColorPicker(
		HWND hwndOwner, 		// owning window
		DWORD *lpc,				// pointer to color to be edited
	    IPoint2 *spos, 			// starting position, set to ending position
	    HSVCallback *callBack,	// called when color changes
		TCHAR *name				// name of color being edited
	    )=0;

	// Create Modeless dialog.
	virtual	ColorPicker *CreateColorPicker(
		HWND hwndOwner,   // owning window
		DWORD initColor,  // inital value of color
		IPoint2* spos,    // starting position of dialog
		HSVCallback *pcallback, // call back when color changes
		TCHAR *name, 	  // name of color being edited
		BOOL isObjectColor=FALSE)=0;

	virtual const TCHAR *ClassName()=0;
	virtual Class_ID ClassID()=0;
	virtual void DeleteThis()=0;
	virtual int Execute(int cmd, ULONG arg1=0, ULONG arg2=0, ULONG arg3=0)=0; 
	};

//--------------------------------------------------------------------------
// the class id for the default color picker is Class_ID(DEFAULT_COLPICK_CLASS_ID,0)

#define DEFAULT_COLPICK_CLASS_ID 1

//--------------------------------------------------------------------------
// These are used by the MAX to plug in the current color picker.  
// Developers should not need to access these.
CoreExport ColPick *SetCurColPick(ColPick *colpick);
CoreExport ColPick *GetCurColPick();
//--------------------------------------------------------------------------
   
//--------------------------------------------------------------------------


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\icmdline.h ===
/**********************************************************************
 *<
	FILE:			icmdline.h

	DESCRIPTION:	Class definitions for command line panel interface

	CREATED BY:		Christer Janson

	HISTORY:		Created 26 September 1997

 *>	Copyright (c) Autodesk, 1997, All Rights Reserved.
 **********************************************************************/

#if !defined(_ICMDLINE_H_)
#define _ICMDLINE_H_

class CommandLineCallback {
public:
	virtual BOOL	ExecuteCommand(TCHAR* szCmdLine) { return FALSE; };
	virtual void	GotKeyEvent(UINT message, WPARAM wParam, LPARAM lParam) {};
};

class ICommandLine {
public:
	virtual BOOL	RegisterCallback(CommandLineCallback* cb) = 0;
	virtual BOOL	UnRegisterCallback(CommandLineCallback* cb) = 0;
	virtual void	SetVisibility(BOOL bShow) = 0;
	virtual BOOL	GetVisibility() = 0;
	virtual	BOOL	Prompt(TCHAR* szCmdLine) = 0;

	// Set the actual string in the command line editor
	virtual	BOOL	SetCommandLineText(TCHAR* szCmdLine) = 0;
};

#endif // _ICMDLINE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\IGuest.h ===
/**********************************************************************
 *<
	FILE: IGuest.h

	DESCRIPTION: Declares Host/Guest protocol

	CREATED BY:	John Hutchinson

	HISTORY: Created April 24, 1999

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#pragma once

class IGeomImp;
class IHost;

class IGuest 
{
public:
	virtual void rsvp(IHost* host, IGeomImp* return_envelope, Matrix3& tm) = 0; 
};


class IHost
{
public:
	virtual void accomodate(IGeomImp* guestrep, Matrix3 &tm, HitRecord *rec = NULL) = 0;
	virtual bool locate(INode *host, Control *c, Matrix3 &oldP, Matrix3 &newP) = 0;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\IAggregation.h ===
/**********************************************************************
 *<
	FILE: IAggregation.h

	DESCRIPTION: Interface to object aggregation manager

	CREATED BY:	John Hutchinson

	HISTORY: Created January 9, 1999

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#pragma once

// DESCRIPTION:
// The IAggregation class is the interface class for representing
// the process of object aggregation

//some constants passed to association class descriptors when editing parameters
#define BEGIN_EDIT	1
#define END_EDIT	2
#define IMAGE_LOAD	3

typedef enum {eUncommitted,
				ePending,
					ePartial,
					eFully,
					eRejecting,
					eAborting}
commitlevels;

typedef enum {eNoAffinity,
				eSuperClassAffinity,
					ePseudoSuperClassAffinity,
					eClassAffinity,
					eInterfaceAffinity,
					eInstanceAffinity}
aggregationaffinity;

class IAggregation 
{
public:
	virtual void SetActiveComplex(INode* node) = 0;
	virtual INode* GetActiveComplex() = 0;
	virtual void Reset() = 0;
	virtual bool SetProductFactory(SClass_ID superID, Class_ID classID) = 0;
	virtual bool RegisterIntermediateFactory(ClassDesc* cd, int affinity) = 0;
	virtual void ResetFactories() = 0;
	virtual IRollupWindow* GetParamRollup() = 0;
	virtual ClassDesc* GetSelClassDesc() const  = 0;
	virtual Animatable* GetSelClassTemplate() = 0;
	virtual int ToolbarIndex(ClassDesc* cd) = 0;
	virtual HIMAGELIST ToolbarImagelist(int which) = 0;
	virtual bool RegisterAssocClass(ClassDesc* cd, int whichbar, int ioe_idx, int iod_idx, int iie_idx, int iid_idx) = 0; 
	virtual int CommitAggregation(int action, int flag) = 0;
	virtual void Suspend() = 0;
	virtual void Resume() = 0;
	virtual bool isSuspended() = 0;
	virtual INode* ReactToNode(INode* newnode) = 0;
	virtual commitlevels Status() = 0;
};

class ValenceData
{
public:
	ValenceData():m_type(0){};
	int m_type;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\IGeomImp.h ===
/**********************************************************************
 *<
	FILE: IGeomImp.h

	DESCRIPTION: Declaration of the interface which a puppet must implement.
				A puppet is essentially a geometry machine with a series of 
				set poses and operations. 
	CREATED BY: John Hutchinson

	HISTORY: Dec 9, 1997

 *>	Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/
#ifndef __IGEOMPUPPET_H
#define __IGEOMPUPPET_H
#include "export.h"
#include <windows.h>
#include "maxtypes.h"

//FIX ME
//THis should not depend on GE
//but for now we use some of its classes
class AcGePoint3d;
class AcGeVector3d;
class AcGePlane;
class AcGePoint2d;
class AcGeVector2d;


#define OP_TIMING

//FIX ME
//This shouldn't depend on amodeler
//but for now we use some of its classes
//JH 3/9/99 Removing references to vertexdata
//#include "../msdkamodeler/inc/vertdata.h"

//need the mesh class for TriangulateMesh
#include "max.h"
class INode;
class ViewExp;

extern inline AcGePoint3d* MaxArToGeAr(const Point3* maxPt, int numverts);

#define MAX_MESH_ID			0x00000001
#define AMODELER_BODY_ID	0x00000002
class OpTimer;
class IGeomImp {
	protected:

	public:
	static DllExport OpTimer opstatistics; //exported from core, initialized in hostcomp.cpp
	//access to the actual internal geometry representation
//	virtual void SetInternalRepresentation(LONG RepID, void *rep);
	virtual void Init(void *prep = NULL, LONG RepID = -1) = 0;
	virtual void *GetInternalRepresentation(LONG RepID, bool* needsdelete)= 0;// access to the wrapped cache
	virtual LONG NativeRepresentationID() = 0;
	///////////////////////////////////////////////////////////////////////////
    // 
    // pseudoconstructors
    // 
	//JH In the process of overloading these for ease of use in MAX 03/26/99

    virtual bool createBox(const Point3& p) = 0;
    virtual bool createBox(const AcGePoint3d& p, const AcGeVector3d& vec) = 0;

    virtual bool createSphere(float radius, int sides, BOOL smooth = TRUE) = 0;
    virtual bool createSphere(const AcGePoint3d& p, double radius, int approx) = 0;

    virtual bool createCylinder(float height, float radius, int sides , BOOL smooth = TRUE) = 0;
    virtual bool createCylinder(const AcGePoint3d& axisStart, const AcGePoint3d& axisEnd, 
         double radius, int approx) = 0;

    virtual bool createCone(float height, float radius1, float radius2, int sides , BOOL smooth = TRUE) = 0;
    virtual bool createCone(const AcGePoint3d& axisStart, const AcGePoint3d& axisEnd, 
        const AcGeVector3d& baseNormal, double radius1, double radius2, int approx) = 0;

    virtual bool createPipe(float height, float radius1, float radius2, int sides , BOOL smooth = TRUE) = 0;
    virtual bool createPipe(const AcGePoint3d& axisStart, const AcGePoint3d& axisEnd, 
        const AcGeVector3d& baseNormal,
        double dblOuterRadius, double dblInnerRadius, 
        int approx) = 0;

	virtual void createPipeConic(const AcGePoint3d& axisStart, const AcGePoint3d& axisEnd,
        const AcGeVector3d& baseNormal,
		double outterRadius1, double innerRadius1,
		double outterRadius2, double innerRadius2, 
        int approx) = 0;

	virtual void createTetrahedron(const AcGePoint3d& p1, const AcGePoint3d& p2,
		const AcGePoint3d& p3, const AcGePoint3d& p4) = 0;

	virtual bool createTorus(float majorRadius, float minorRadius, int sidesa, int segs, BOOL smooth = TRUE) = 0;
	virtual bool createTorus(const AcGePoint3d& axisStart, const AcGePoint3d& axisEnd,
		double majorRadius, double minorRadius, int majorApprox, int minorApprox) = 0;
/*
	virtual void createReducingElbow(const AcGePoint3d& elbowCenter, const AcGePoint3d& endCenter1,
        const AcGePoint3d& endCenter2, double endRadius1, double endRadius2,
        int majorApprox, int minorApprox) = 0;
	virtual void createRectToCircleReducer(
        const AcGePoint3d& baseCorner,
        const AcGeVector2d& baseSizes, 
        const AcGePoint3d& circleCenter,
        const AcGeVector3d& circleNormal, 
        double circleRadius, 
        int approx) = 0;
*/
	virtual bool createConvexHull(const AcGePoint3d vertices[], int numVertices) = 0;
	virtual bool createConvexHull(const Point3 vertices[], int numVertices) = 0;

    // Create a body consisting of one face
    //
/*
    virtual void createFace(const AcGePoint3d vertices[], AModeler::PolygonVertexData* vertexData[], 
        int numVertices, const AcGeVector3d &normal) = 0;
*/
    virtual void createFace(const AcGePoint3d vertices[], int numVertices, BOOL smooth = TRUE) = 0;

	//The boolean operators
	virtual void prepBoolean() = 0;
	virtual void operator +=(IGeomImp& b) = 0; 
    virtual void operator -=(IGeomImp& b) = 0; 
    virtual void operator *=(IGeomImp& b) = 0; 
    virtual int interfere  (IGeomImp& b) = 0;

	//combination
	virtual bool Combine(IGeomImp& b) = 0; 

	//assignment
	virtual IGeomImp& operator =(IGeomImp& b) = 0;

    
	// The section method removes part of the body in the positive halfplane
    //
	virtual void  section(const Matrix3& tm) = 0;
    virtual void  section(const AcGePlane& p) = 0; 

    // Sweeps
    //
	virtual bool createPyramid(float width, float depth, float height)=0;
	virtual bool createPyramid(
        const AcGePoint3d vertices[], 
//        AModeler::PolygonVertexData* vertexData[],
	    int numVertices, 
        const AcGeVector3d &plgNormal, 
        const AcGePoint3d &apex) = 0;

//	virtual bool createExtrusion(const Point3 vertices[], int numVertices, const float height )=0;
	virtual bool createExtrusion(		
		PolyPt vertices[], 
		int numVertices, 
		const float height,
		const BOOL smooth,
		const BOOL genMatIDs,
		const BOOL useShapeIDs)=0;

	virtual bool createExtrusion(
        const AcGePoint3d vertices[], 
//        AModeler::PolygonVertexData* vertexData[],
		int numVertices, 
        const AcGeVector3d &plgNormal, 
        const AcGeVector3d &extusionVector, 
        const AcGePoint3d &fixedPt, 
        double scaleFactor, 
        double twistAngle) = 0;

    virtual void createAxisRevolution(
        const AcGePoint3d vertices[],
//        AModeler::PolygonVertexData* vertexData[],
        int numVertices,
        const AcGeVector3d &normal,
        const AcGePoint3d &axisStart,
        const AcGePoint3d &axisEnd,
        double revolutionAngle,
        int approx,
        const AcGePoint3d &fixedPt,
        double scaleFactor,
        double twistAngle) = 0;

    virtual void createEndpointRevolution(
        const AcGePoint3d vertices[],
//        AModeler::PolygonVertexData* vertexData[],
		int numVertices,
        const AcGeVector3d &normal,
        double revolutionAngle,
        int approx)=0;
/*
    void createSkin(
        AsdkBody* profiles[],
        int numProfiles,
        bool isClosed,
        MorphingMap* morphingMaps[]);
*/

	virtual void createExtrusionAlongPath(
		const AcGePoint3d vertices[], 
//        AModeler::PolygonVertexData* vertexData[], 
		int numVerticesm, 
        bool pathIsClosed, 
        bool bCheckValidity,
        const AcGePoint3d &scaleTwistFixedPt, 
        double scaleFactor, 
        double twistAngle,
		const AcGeVector3d &extusionVector) = 0;

	virtual void createWallCorner(
                    const AcGePoint2d& pt1,     // Start of wall 1
                    const AcGePoint2d& pt2,     // End of wall 1, start of wall 2
                    const AcGePoint2d& pt3,     // End of wall 2
                    bool           materialToTheLeft,
                    double         width1,  // Wall 1 width
                    double         width2,  // Wall 2 width
                    double         height,  // Wall height
					AcGePlane&         matingPlane1,
					AcGePlane&         matingPlane2,
                    bool&          wall1NeedsToBeSectioned,
                    bool&          wall2NeedsToBeSectioned) = 0;

	///////////////////////////////////////////////////////////////////////////
	//
	// transforms
	//

	virtual void transform(Matrix3 & mat, bool override_locks = true) = 0;


    ///////////////////////////////////////////////////////////////////////////
    // 
    // triangulation
    // 

	
	// Saves the triangles directly to a Mesh //
	virtual void triangulateMesh(TimeValue t, Mesh& m, 
	TesselationType type = kTriangles, bool cacheTriangles    = true)  = 0;

/* TO DO
	// saves the triangle back to the callback object 
	virtual void triangulate   (TimeValue t, OutputTriangleCallback*, 
	TriangulationType type = kGenerateTriangles, bool cacheTriangles    = true) = 0;
*/
    ///////////////////////////////////////////////////////////////////////////
    // 
    // display
    // 
	virtual void Display(TimeValue t, INode* inode, ViewExp *vpt, int flags) = 0;
	virtual void Invalidate() = 0;

	//Validity
	virtual bool isNull() = 0;

	//////////////////////////////////////////////////////////////////////////
	//
	// Copy
	//
	virtual IGeomImp * Copy(void) = 0;

	//////////////////////////////////////////////////////////////////////////
	//
	// BondingBox methods
	//
	virtual void GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm=NULL, BOOL useSel=FALSE ) = 0;


	//////////////////////////////////////////////////////////////////////////
	//
	// Constraining transform
	//
	virtual bool GetTransformLock(int type, int axis) = 0;
	virtual void SetTransformLock(int type, int axis, BOOL onOff) = 0;
};

//#ifdef IMPORTING
//#error
//#endif

#define HIRES

class OpTimer: public MeshOpProgress
{
private:
#ifdef HIRES
	LARGE_INTEGER  opstart;
	LARGE_INTEGER  optime;
	LARGE_INTEGER  cumtime;
	LARGE_INTEGER  res;
#else
	int opstart, optime, cumtime;
#endif
	int m_errorcode;
	int m_errcount;
	int m_opcount;
	TSTR curopname;
public:
	//From MeshOpProgress
	OpTimer():m_errorcode(0), m_opcount(0){curopname = "??";}
	void Init(int total)
	{
		++m_opcount;
		m_errorcode = 0;
		
#ifdef HIRES
		QueryPerformanceFrequency(&res);
		optime.QuadPart = 0;
		QueryPerformanceCounter(&opstart);
#else
		opstart = GetTickCount();
#endif
	}
	BOOL Progress(int p)
	{
#ifdef HIRES
		LARGE_INTEGER opnow;
		QueryPerformanceCounter(&opnow);
		cumtime.QuadPart += (opnow.QuadPart - (opstart.QuadPart + optime.QuadPart));
		optime.QuadPart = opnow.QuadPart - opstart.QuadPart;
#else
		integer opnow = GetTickCount();
		cumtime += (opnow - (opstart + optime));
		optime = opnow - opstart; 
#endif
		return true;
	}
	void OutputMetrics(HWND hDlg);
	void InitName(char *opname){curopname = opname;}
	void ExtendName(char *opname){curopname += opname;}
	void FlagError(int errcode = 999){m_errorcode = errcode;++m_errcount;}
	void Reset(){
		m_errcount = 0; m_opcount=0;
#ifdef HIRES
		cumtime.QuadPart = 0;
#else
		optime = 0; 
#endif

	}
};

extern "C" __declspec(dllexport) IGeomImp* CreateAmodelerBody();
extern "C" __declspec(dllexport) IGeomImp* CreateMeshAdapter();
#endif //__IGEOMPUPPET_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\ikctrl.h ===
/**********************************************************************
 *<
	FILE:  ikctrl.h

	DESCRIPTION:  Inverse Kinematics Controllers

	CREATED BY:  Rolf Berteig

	HISTORY: 3-1-97

 *>	Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/

#ifndef __IKCTRL_H__
#define __IKCTRL_H__


#define IKMASTER_CLASSID		Class_ID(0xa91004be,0x9901fe83)
#define IKSLAVE_CLASSID			Class_ID(0xbe380a31,0x310dc9e4)

class IKMasterControl : public ReferenceTarget {
	public:
		Class_ID			ClassID() {return IKMASTER_CLASSID;}
		SClass_ID			SuperClassID() {return REF_TARGET_CLASS_ID;}

		virtual void		AddSlaveNode(INode *node)=0;
		virtual void		*GetMasterBase()=0;

		virtual void		SetPosThresh(float t)=0;
		virtual void		SetRotThresh(float t)=0;
		virtual void		SetIterations(int i)=0;
		virtual void		SetStartTime(TimeValue s)=0;
		virtual void		SetEndTime(TimeValue e)=0;

		virtual float		GetPosThresh()=0;
		virtual float		GetRotThresh()=0;
		virtual int			GetIterations()=0;
		virtual TimeValue	GetStartTime()=0;
		virtual TimeValue	GetEndTime()=0;
	};

class IKSlaveControl : public Control {
	public:
		Class_ID ClassID() {return IKSLAVE_CLASSID;}
		SClass_ID SuperClassID() {return CTRL_MATRIX3_CLASS_ID;}

		virtual IKMasterControl *GetMaster()=0;
		virtual void SetDOF(int which,BOOL onOff)=0;
		virtual void SetInitPos(Point3 pos)=0;
		virtual void SetInitRot(Point3 rot)=0;
		virtual void MakeEE(BOOL onOff,DWORD which,Point3 pos,Quat rot)=0;
	};

CoreExport IKMasterControl *CreateIKMasterControl();
CoreExport IKSlaveControl *CreateIKSlaveControl(IKMasterControl *master,INode *slaveNode);


#endif //__IKCTRL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\icurvctl.h ===
/**********************************************************************
 *<
	FILE: iurvctl.h

	DESCRIPTION:	CurveControl Interface

	CREATED BY:		Nikolai Sander, Kinetix

	HISTORY:		Created 10/15/98

 *>	Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/


#ifndef __ICURVECOTL__H
#define __ICURVECOTL__H

#define CURVE_CONTROL_CLASS_ID Class_ID(0x14585773, 0x483a7dcf)

#define I_RESMAKER_INTERFACE 0x2474334a

#define WM_CC_SEL_CURVEPT         WM_USER+0x2b70 // lParam = ICurve * , LOWORD(wParam) = number of points selected
#define WM_CC_CHANGE_CURVEPT      WM_USER+0x2b71 // lParam = ICurve * , LOWORD(wParam) = point index
#define WM_CC_CHANGE_CURVETANGENT WM_USER+0x2b72 // lParam = ICurve * , LOWORD(wParam) = point index, HIWORD(wParam) TRUE->InTangent, FALSE->OutTangent
#define WM_CC_DEL_CURVEPT         WM_USER+0x2b73 // lParam = ICurve * , LOWORD(wParam) = point index

#define CC_DRAWBG				(1<<0)
#define CC_DRAWGRID				(1<<1)
#define CC_DRAWUTOOLBAR			(1<<2)
#define CC_SHOWRESET			(1<<3)
#define CC_DRAWLTOOLBAR			(1<<4)
#define CC_DRAWSCROLLBARS		(1<<5)
#define CC_AUTOSCROLL			(1<<6)
#define CC_DRAWRULER			(1<<7)
#define CC_ASPOPUP				(1<<8)
#define CC_CONSTRAIN_Y			(1<<9)
#define CC_HIDE_DISABLED_CURVES (1<<10)

// Rightclick menu
#define CC_RCMENU_MOVE_XY	    (1<<11)
#define CC_RCMENU_MOVE_X	    (1<<12)
#define CC_RCMENU_MOVE_Y	    (1<<13)
#define CC_RCMENU_SCALE			(1<<14)
#define CC_RCMENU_INSERT_CORNER	(1<<15)
#define CC_RCMENU_INSERT_BEZIER	(1<<16)
#define CC_RCMENU_DELETE		(1<<17)

#define CC_ALL_RCMENU (CC_RCMENU_MOVE_XY|CC_RCMENU_MOVE_X|CC_RCMENU_MOVE_Y|CC_RCMENU_SCALE|CC_RCMENU_INSERT_CORNER|CC_RCMENU_INSERT_BEZIER|CC_RCMENU_DELETE)

#define CC_ALL (CC_DRAWBG|CC_DRAWGRID|CC_DRAWUTOOLBAR|CC_SHOWRESET|CC_DRAWLTOOLBAR|CC_DRAWSCROLLBARS|CC_AUTOSCROLL| \
		CC_DRAWRULER|CC_ASPOPUP|CC_CONSTRAIN_Y|CC_HIDE_DISABLED_CURVES| CC_ALL_RCMENU )

#define CC_NONE 0

#define CID_CC_MOVE_XY				0
#define CID_CC_MOVE_X				1
#define CID_CC_MOVE_Y				2
#define CID_CC_SCALE				3
#define CID_CC_INSERT_CORNER		4
#define CID_CC_INSERT_BEZIER		5

// IPoint flags
#define CURVEP_BEZIER		(1<<0)
#define CURVEP_CORNER		(1<<1)
#define CURVEP_LOCKED_Y		(1<<2)
#define CURVEP_LOCKED_X		(1<<3)
#define CURVEP_SELECTED		(1<<4)
#define CURVEP_ENDPOINT		(1<<8)	// It's a constrained endpoint on the curve

// Flags passed to SelectPts
#define SELPTS_SELECT			(1<<0)	
#define SELPTS_DESELECT			(1<<1)
#define SELPTS_CLEARPTS			(1<<2)		 

#define IS_CORNER(flags)        ( ( (flags) & CURVEP_CORNER) && !((flags) & CURVEP_BEZIER) )
#define IS_BEZIERSMOOTH(flags)  ( ( (flags) & CURVEP_BEZIER) && !((flags) & CURVEP_CORNER) )
#define IS_BEZIERCORNER(flags)  ( (flags) & (CURVEP_BEZIER | CURVEP_CORNER) )



class ICurve;

class ICurveCtl : public ReferenceTarget {
public:
	
	virtual BOOL  IsActive()=0;										// This reflects if the dialog box is up or not
	virtual void  SetActive(BOOL sw)=0;								// This brings up or closes the dialog box
	virtual HWND  GetHWND()=0;
	virtual void  SetNumCurves(int iNum)=0;							// Sets the number of curves for this CurveControl.
																	// Note, that this method actually create the curves, which means,
																	// that the NewCurveCreatedCallback method will be called. However, this happens only 
																	// if a ResourceMakerCallback is registered already.
																	// Thus it is important,that the ResourceMakerCallback is registered BEFORE this method
																	// is called.

	virtual int   GetNumCurves()=0;									// Returns the numbers of curves
	virtual void  SetXRange(float min, float max)=0;				// Determines the first and last key for all curves
	virtual void  SetYRange(float min, float max)=0;				// Determines the upper and lower limits, if the Flag CC_CONSTRAIN_Y is set
	virtual void  RegisterResourceMaker(ReferenceMaker *rmak)=0;	// This registers a rmaker, which has to implement GetInterface 
																	// for I_RESMAKER_INTERFACE by returning an object derived from 
																	// ResourceMakerCallback
	
	virtual BOOL  GetZoomValues(float *h, float *v)=0;				// Returns the current zoom values
	virtual void  SetZoomValues(float h, float v)=0;				// Sets the zoom values
	virtual BOOL  GetScrollValues(int *h, int *v)=0;				// Returns the current Scroll Values
	virtual void  SetScrollValues(int h, int v)=0;					// Sets the scroll values
	virtual void  ZoomExtents()=0;
	virtual void  SetTitle(TCHAR *str)=0;							// Sets the title of the dialog box
	virtual ICurve *GetControlCurve(int numCurve)=0;				// Returns and interface to the numCurve'th curve
	virtual void  SetDisplayMode(BitArray &mode)=0;					// Determines which curves are toggled on
	virtual BitArray GetDisplayMode()=0;							// Returns which curves are toggled on
	virtual void  SetCCFlags(DWORD flags)=0;
	virtual DWORD GetCCFlags()=0;
	virtual void  SetCustomParentWnd(HWND hParent)=0;				// Parent Window, if CurveControl is no popup window
	virtual void  SetMessageSink(HWND hWnd)=0;						// WM_CC_CHANGE_CURVEPT, WM_CC_CHANGE_CURVETANGENT and WM_CC_DEL_CURVEPT will be sent to this window
	virtual void  SetCommandMode(int ID)=0;
	virtual int   GetCommandMode()=0;
	virtual void  Redraw()=0;
	virtual Interval	GetValidity(TimeValue t)=0;
	virtual void Update(TimeValue t, Interval& valid)=0;

};

class CurvePoint
{
public:
	Point2 p;
	Point2 in;
	Point2 out;
	int flags;
};


class ICurve : public ReferenceTarget 
{
public:
	virtual void  SetPenProperty(COLORREF color, int width = 0, int style = PS_SOLID)=0; // Sets the pen properties of a curve 
	virtual void  GetPenProperty(COLORREF &color, int &width, int &style)=0;				 // Gets the color of a curve
	virtual void  SetDisabledPenProperty(COLORREF color, int width = 0, int style = PS_SOLID)=0; // Sets the pen properties of a curve if it is disabled
	virtual void  GetDisabledPenProperty(COLORREF &color, int &width, int &style)=0;				 // Gets the color of a curve if it is disabled
	virtual float GetValue(TimeValue t, float fX, Interval &ivalid = FOREVER, BOOL UseLookupTable = FALSE)=0;			 // Returns the Y-value for a given X-Value
	virtual void  SetCanBeAnimated(BOOL Animated)=0;
	virtual BOOL  GetCanBeAnimated()=0;

	virtual int   IsAnimated(int index)=0;
	
	virtual int   GetNumPts()=0;
	virtual void  SetNumPts(int count)=0;
	virtual	BitArray GetSelectedPts()=0;
	virtual	void  SetSelectedPts(BitArray &sel, int flags)=0;

	virtual	void  SetPoint(TimeValue t, int index, CurvePoint *point, BOOL CheckConstraints = TRUE)=0;
	virtual CurvePoint	GetPoint(TimeValue t, int index, Interval &valid = FOREVER)=0;

	
	virtual int	  Insert(int where, CurvePoint & p)=0;
	virtual void  Delete(int index)=0;

	virtual void  SetLookupTableSize(int size)=0;
	virtual int   GetLookupTableSize()=0;
};

class ResourceMakerCallback
{
public:
	
	// this callback has to set the HIMAGELIST to implement custom bitmaps on the display buttons
	// The imagelist has to have NumCurves bitmaps in the format 16x15 set of images are 
	// for Out&In Enabled.
	// If the Imagelist was assigned the callback has to return TRUE. If it returns FALSE, the default bitmaps will 
	// be used. The pCCtl pointer can be used to determine which ICurveCtl calls the callback, in
	// case the plugin uses many CurveControls and want to set different bitmaps for different CurveControls

	virtual BOOL SetCustomImageList(HIMAGELIST &hCTools,ICurveCtl *pCCtl){return FALSE;} 
	
	// This callback allows the developer to assign custom ToolTips to the display buttons. He simply has to assing a 
	// TSTR to the ToolTip parameter in regards to the button number. The pCCtl pointer can be used to determine 
	// which ICurveCtl calls the callback, in case the plugin uses many CurveControls and want to set different 
	// Tooltips for different CurveControls

	virtual BOOL GetToolTip(int iButton, TSTR &ToolTip,ICurveCtl *pCCtl){return FALSE;}

	virtual void ResetCallback(int curvenum, ICurveCtl *pCCtl){}
	virtual void NewCurveCreatedCallback(int curvenum, ICurveCtl *pCCtl){}
	
	virtual void* GetInterface(ULONG id) {return NULL;}
};

#endif __ICURVECOTL__H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\IComponent.h ===
/**********************************************************************
 *<
	FILE: IComponent.h

	DESCRIPTION:  An interface representing the composite pattern.

	CREATED BY: John Hutchinson

	HISTORY: created 9/1/98

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#ifndef _ICOMP
#define _ICOMP

/* 
The composite pattern relies on a common interface for leaves and composites.
This class embodies that commonality. Classes which realize this interface 
will generally be of two forms: composites and leaves. A composite will 
implement its methods by iterating over its components and making a recursive
call. A leaf will actually do something. 

*/
class ComponentIterator;
class INode;
class Object;

class IComponent {
public:
	virtual void DisposeTemporary() = 0;
	virtual void Remove(ComponentIterator& c) = 0;
	virtual void Add(TimeValue t, Object* obj, TSTR objname, Matrix3& oppTm, Matrix3& boolTm, Matrix3& parTM, Control* opCont = NULL) = 0;
	virtual void Add(TimeValue t, INode *node, Matrix3& boolTm, bool delnode = true) = 0;

	virtual ComponentIterator * MakeIterator() /*const*/ = 0;
	virtual ComponentIterator * MakeReverseIterator() /*const*/ = 0;

	virtual Object* MakeLeaf(Object* o) = 0;
	virtual bool IsLeaf() const = 0;

	virtual void SelectOp(int which, BOOL selected) = 0;
	virtual void ClearSelection() = 0;
	virtual int GetSubSelectionCount() = 0;
};


class ComponentIterator {
public:
	virtual void First() = 0;
	virtual void Next() = 0;
	virtual bool IsDone() /*const*/ = 0; //Should be const but we want to call nonconst methods from within
	virtual int SubObjIndex() = 0;
	virtual IComponent* GetComponent(void** ipp = NULL, ULONG iid = I_BASEOBJECT) const = 0;
	//Note: this object may be dynamically allocated. Calls must 
	//be matched with calls to DisposeTemporary()

	virtual Object* GetComponentObject() const = 0;
	virtual INode* GetComponentINode(INode *node) const = 0;
	virtual void DisposeComponentINode(INode *node) const = 0;
	virtual Control* GetComponentControl() const = 0;//This need not be released
	virtual bool Selected() const = 0;//is the corresponding component selected?
	virtual bool Hidden() const = 0;//is the corresponding component hidden?
	virtual void DeleteThis() = 0;
	
	//JH 4/12/99 Adding some methods for better display control
	virtual bool WantsDisplay(DWORD flags) = 0;
	virtual Point3 DisplayColor(DWORD flags, INode* n = NULL, GraphicsWindow* gw = NULL) = 0;
protected:
	virtual bool ValidIndex(int which) const = 0;
};

class CompositeClassDesc: public ClassDesc
{
public:
	virtual int				NumValenceTypes(){return 0;}
	virtual Class_ID		GetValenceClassID(int which) {return Class_ID(0,0);}
};

#endif //_ICOMP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\impapi.h ===
/**********************************************************************
 *<
	FILE: impapi.h

	DESCRIPTION: Geometry import/export API header

	CREATED BY:	Tom Hudson

	HISTORY: Created 26 December 1994

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef _IMPAPI_H_
#define _IMPAPI_H_

// These includes get us the general camera and light interfaces
#include "gencam.h"
#include "genlight.h"

#include "render.h"

// Import Node class

class ImpNode {
public:
	virtual RefResult	Reference(ObjectHandle obj)	= 0;
	virtual void		SetTransform( TimeValue t, Matrix3 tm ) = 0;
	virtual void 		SetName(const TCHAR *newname) = 0;
	virtual void		SetPivot(Point3 p) = 0;
	virtual INode *		GetINode()=0;			// Use with care -- Always use above methods instead
	// I'm stuffing these in here so that I can perhaps add API functions without recompiling
	virtual int			TempFunc1(void *p1=NULL, void *p2=NULL, void *p3=NULL, void *p4=NULL, void *p5=NULL, void *p6=NULL, void *p7=NULL, void *p8=NULL)=0;
	virtual int			TempFunc2(void *p1=NULL, void *p2=NULL, void *p3=NULL, void *p4=NULL, void *p5=NULL, void *p6=NULL, void *p7=NULL, void *p8=NULL)=0;
	virtual int			TempFunc3(void *p1=NULL, void *p2=NULL, void *p3=NULL, void *p4=NULL, void *p5=NULL, void *p6=NULL, void *p7=NULL, void *p8=NULL)=0;
	virtual int			TempFunc4(void *p1=NULL, void *p2=NULL, void *p3=NULL, void *p4=NULL, void *p5=NULL, void *p6=NULL, void *p7=NULL, void *p8=NULL)=0;
	virtual int			TempFunc5(void *p1=NULL, void *p2=NULL, void *p3=NULL, void *p4=NULL, void *p5=NULL, void *p6=NULL, void *p7=NULL, void *p8=NULL)=0;
	virtual int			TempFunc6(void *p1=NULL, void *p2=NULL, void *p3=NULL, void *p4=NULL, void *p5=NULL, void *p6=NULL, void *p7=NULL, void *p8=NULL)=0;
	virtual int			TempFunc7(void *p1=NULL, void *p2=NULL, void *p3=NULL, void *p4=NULL, void *p5=NULL, void *p6=NULL, void *p7=NULL, void *p8=NULL)=0;
	virtual int			TempFunc8(void *p1=NULL, void *p2=NULL, void *p3=NULL, void *p4=NULL, void *p5=NULL, void *p6=NULL, void *p7=NULL, void *p8=NULL)=0;
	virtual int			TempFunc9(void *p1=NULL, void *p2=NULL, void *p3=NULL, void *p4=NULL, void *p5=NULL, void *p6=NULL, void *p7=NULL, void *p8=NULL)=0;
	virtual int			TempFunc10(void *p1=NULL, void *p2=NULL, void *p3=NULL, void *p4=NULL, void *p5=NULL, void *p6=NULL, void *p7=NULL, void *p8=NULL)=0;
	};

// Import Interface class

class ImpInterface {
public:
	virtual ImpNode *		CreateNode() = 0;
	virtual void 			RedrawViews() = 0;
	virtual GenCamera*	 	CreateCameraObject(int type) = 0;
	virtual Object *   		CreateTargetObject() = 0;
	virtual GenLight*	 	CreateLightObject(int type) = 0;
	virtual void *			Create(SClass_ID sclass, Class_ID classid)=0;
	virtual int 			BindToTarget(ImpNode *laNode, ImpNode *targNode)=0;
	virtual void			AddNodeToScene(ImpNode *node)=0;
	virtual void			SetAnimRange(Interval& range)=0;
	virtual Interval		GetAnimRange()=0;
	// Environment settings
	virtual void 			SetEnvironmentMap(Texmap *txm)=0;
	virtual void 			SetAmbient(TimeValue t, Point3 col)=0;
	virtual void 			SetBackGround(TimeValue t,Point3 col)=0;
	virtual void 			SetUseMap(BOOL onoff)=0;
	virtual void 			AddAtmosphere(Atmospheric *atmos)=0;

	virtual int				NewScene()=0;  // delete all existing geometry
	// I'm stuffing these in here so that I can perhaps add API functions without recompiling
	virtual int				TempFunc1(void *p1=NULL, void *p2=NULL, void *p3=NULL, void *p4=NULL, void *p5=NULL, void *p6=NULL, void *p7=NULL, void *p8=NULL)=0;
	virtual int				TempFunc2(void *p1=NULL, void *p2=NULL, void *p3=NULL, void *p4=NULL, void *p5=NULL, void *p6=NULL, void *p7=NULL, void *p8=NULL)=0;
	virtual int				TempFunc3(void *p1=NULL, void *p2=NULL, void *p3=NULL, void *p4=NULL, void *p5=NULL, void *p6=NULL, void *p7=NULL, void *p8=NULL)=0;
	virtual int				TempFunc4(void *p1=NULL, void *p2=NULL, void *p3=NULL, void *p4=NULL, void *p5=NULL, void *p6=NULL, void *p7=NULL, void *p8=NULL)=0;
	virtual int				TempFunc5(void *p1=NULL, void *p2=NULL, void *p3=NULL, void *p4=NULL, void *p5=NULL, void *p6=NULL, void *p7=NULL, void *p8=NULL)=0;
	virtual int				TempFunc6(void *p1=NULL, void *p2=NULL, void *p3=NULL, void *p4=NULL, void *p5=NULL, void *p6=NULL, void *p7=NULL, void *p8=NULL)=0;
	virtual int				TempFunc7(void *p1=NULL, void *p2=NULL, void *p3=NULL, void *p4=NULL, void *p5=NULL, void *p6=NULL, void *p7=NULL, void *p8=NULL)=0;
	virtual int				TempFunc8(void *p1=NULL, void *p2=NULL, void *p3=NULL, void *p4=NULL, void *p5=NULL, void *p6=NULL, void *p7=NULL, void *p8=NULL)=0;
	virtual int				TempFunc9(void *p1=NULL, void *p2=NULL, void *p3=NULL, void *p4=NULL, void *p5=NULL, void *p6=NULL, void *p7=NULL, void *p8=NULL)=0;
	virtual int				TempFunc10(void *p1=NULL, void *p2=NULL, void *p3=NULL, void *p4=NULL, void *p5=NULL, void *p6=NULL, void *p7=NULL, void *p8=NULL)=0;
	virtual FILE *			DumpFile() = 0;			// For debugging -- Stream for dumping debug messages
	};

// Export Interface class

class ExpInterface {
public:
	IScene *		theScene;		// Pointer to the scene
	};

#endif // _IMPAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\ILayerManager.h ===
/**********************************************************************
 *<
	FILE: ILayerManager.h

	DESCRIPTION: Declaration of the ILayerManager interface

	CREATED BY:	Peter Sauerbrei

	HISTORY: Created 19 October 1998

 *>	Copyright (c) 1998-99, All Rights Reserved.
 **********************************************************************/

#pragma once
#ifndef __ILAYERMANAGER_H__
#define __ILAYERMANAGER_H__
#include <ILayer.h>

class LayerIterator;
class ConstLayerIterator;

class ILayerManager : public ReferenceTarget
{
public:
	static const SClass_ID kLayerManagerSuperClassID;

	// from Animatable
	SClass_ID SuperClassID() { return kLayerManagerSuperClassID; }

	// local methods
	virtual bool AddLayer(ILayer * layer) = 0;
	virtual void CreateLayer(void) = 0;							// creates a new layer
	virtual void DeleteLayer(const TSTR & name) = 0;					// deletes a layer
	virtual void SetCurrentLayer(const TSTR & name) = 0;				// sets the current layer
	virtual void SetCurrentLayer(void) = 0;
	virtual ILayer * GetCurrentLayer(void) const = 0;	// gets the current layer
	virtual void EditLayer(const TSTR & name) = 0;
	virtual void DoLayerPropDialog(HWND hWnd) = 0;
	virtual LayerIterator * MakeIterator(void) = 0;
	virtual ConstLayerIterator * MakeConstIterator(void) const = 0;
	virtual int GetLayerCount(void) = 0;
	virtual ILayer * GetLayer(const TSTR & name) const = 0;
	virtual void DoLayerSelDialog(HWND hWnd) = 0;
	virtual void SetupToolList(HWND hWnd) = 0;
	virtual void ExtendMenu(HMENU hMenu, bool geometry = true, bool grid = false) = 0;
	virtual TSTR GetSavedLayer(int i) const = 0;
	virtual ILayer * GetRootLayer() const = 0;
	virtual void Reset(BOOL fileReset = FALSE) = 0;
#ifdef DESIGN_VER
	virtual ILayer * CreateLayer2(void) = 0;
	virtual void SelectObjectsByLayer(HWND hWnd) = 0;
#endif
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\imacroscript.h ===
/*	
 *		imacroscript.h - Public interface to Macro script manager for the MAX CUI
 *
 *	Macro scripts (or macros) are scripts that live in buttons and menus in the new 
 *  customizable UI.  The macro script manager keeps a directory of all known macros 
 *  and provides an API for running and editing macros and for accessing and 
 *  updating the directory.
 *
 *  The directory is used by the CUI to provide a list of available macros in the 
 *  toolbar/menu/shelf editor.  The API also provides a way for the CUI
 *  to open a macro editor to allow on-the-fly creation of macro scripts. 
 *
 *  Macros are normally entered into the directory by the MAXScript compiler as a
 *  side-effect of compiling a macro () definition.  Anyone using MAXScript can at
 *  any time eval a macro definition and thereby add CUI macro scripts.
 *  Consequently, macros can be stored in any script file and be loaded just by
 *  executing the file.  The macro definition syntax permits any number of macros per
 *  file.  
 *
 *  Most macros will be stored in files in a special CUI macro or config
 *  directory so that a user can take all his custom UI stuff with him by copying
 *  directories.  (this directory supports recursive scanning of sub-dirs,
 *  so users can organize their macros)
 *  On-the-fly macro creation in the CUI editor or by text drag-and-
 *  drop onto the shelf or by evaling a definition in the listener will generate 
 *  a file in this directory to provide permanent storage.
 *
 *			Copyright  Autodesk, Inc, 1998.  John Wainwright.
 *
 */

#ifndef _H_IMACROSCRIPT
#define _H_IMACROSCRIPT

#ifndef ScripterExport
#	ifdef BLD_MAXSCRIPT
#		define ScripterExport __declspec( dllexport )
#	else
#		define ScripterExport __declspec( dllimport )
#	endif
#endif

typedef short MacroID;

class Value;

/* ----------------  macro directory -------------------------- */

class MacroEntry
{
public:
	// access
	virtual MacroID		GetID() = 0;
	virtual TSTR&		GetName() = 0;
	virtual TSTR&		GetCategory() = 0;
	virtual TSTR&		GetFileName() = 0;
	virtual void		SetFileName(TCHAR* fn) = 0;
	virtual long		GetOffset() = 0;
	virtual void		SetOffset(int o) = 0;
	virtual Value*		GetCode() = 0;
	virtual TSTR&		GetToolTip() = 0;
	virtual void		SetToolTip(TCHAR* tt) = 0;
	virtual TSTR&		GetButtonText() = 0;
	virtual void		SetButtonText(TCHAR* bt) = 0;
	virtual void		SetButtonIcon(TCHAR* icnf, int indx) = 0;
	virtual TSTR&		GetButtonIconFile() = 0;
	virtual int			GetButtonIconIndex() = 0;
	virtual void		SetFlags(short mask) = 0;
	virtual void		ClearFlags(short mask) = 0;
	virtual short		GetFlags(short mask) = 0;

	// execution
	virtual Value*		Execute() = 0;

	// cleanup
	virtual void		DeleteThis() = 0;
};

#define ME_DROPPED_SCRIPT	0x0001		// macro made from some drag-and-dropped text
#define ME_SILENT_ERRORS	0x0002		// macro won't report any runtime errors

class MacroDir
{
public:

	// access by ID or category & name strings
	virtual MacroEntry*	GetMacro(MacroID mid) = 0;
	virtual MacroEntry*	FindMacro(TCHAR* category, TCHAR* name) = 0;
	virtual BOOL		ValidID(MacroID mid) = 0;

	// iteration 
	virtual int			Count() = 0;
	virtual MacroEntry*	GetMacro(int index) = 0;

	// macro entry management
	virtual MacroEntry*	AddMacro(TCHAR* category, TCHAR* name, TCHAR* tooltip, TCHAR* buttonText,
									TCHAR* sourceFile, int sourceOffset) = 0;
	virtual MacroEntry*	AddMacro(TCHAR* category, TCHAR* name, TCHAR* tooltip, TCHAR* buttonText,
									TCHAR* sourceText) = 0;
    virtual BOOL		SetMacro(MacroID mid, TCHAR* tooltip, TCHAR* btnText, TCHAR* sourceFile, int sourceOffset) = 0;
	virtual TCHAR*		MakeNameValid(TCHAR* s) = 0;
	virtual TCHAR*		MakeCategoryValid(TCHAR* s) = 0;
	
	// editing
	virtual BOOL		EditMacro(MacroID mid) = 0;
	
	// execution
	virtual Value*		Execute(MacroID mid) = 0;

	// macro-script file directory scanning & loading
	virtual void		LoadMacroScripts(TCHAR* path_name = NULL, BOOL recurse = TRUE) = 0;
	
	// set & get default path for storing/searching macro script files
	virtual void		SetMacroScriptPath(TCHAR* path_name) = 0;
	virtual TCHAR*		GetMacroScriptPath() = 0;
};

#if defined(BLD_CORE)
	extern MacroDir& GetMacroScriptDir();
#else
	extern ScripterExport MacroDir& GetMacroScriptDir();
	extern ScripterExport void InitMacroScriptDir();
#endif

#endif    // _H_IMACROSCRIPT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\impexp.h ===
/**********************************************************************
 *<
	FILE: impexp.h

	DESCRIPTION: Includes for importing and exporting geometry files

	CREATED BY:	Tom Hudson

	HISTORY: Created 26 December 1994

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/


#ifndef _IMPEXP_H_
#define _IMPEXP_H_

// The following work on the specified file or bring up the browser if null
BOOL ImportFile(const TCHAR *buf = NULL, BOOL suppressPrompts=FALSE, Class_ID *importerID=NULL);
BOOL ExportFile(const TCHAR *buf = NULL, BOOL suppressPrompts=FALSE, DWORD options=0, Class_ID *exporterID=NULL);

class ImpInterface;
class ExpInterface;
class Interface;

// Returned by DoImport, DoExport
#define IMPEXP_FAIL 0
#define IMPEXP_SUCCESS 1
#define IMPEXP_CANCEL 2

// SceneImport::ZoomExtents return values
#define ZOOMEXT_NOT_IMPLEMENTED	-1		// The default (uses Preferences value)
#define ZOOMEXT_YES				TRUE	// Zoom extents after import
#define ZOOMEXT_NO				FALSE	// No zoom extents

// The scene import/export classes.  Right now, these are very similar, but this may change as things develop

class SceneImport {
public:
							SceneImport() {};
	virtual					~SceneImport() {};
	virtual int				ExtCount() = 0;					// Number of extemsions supported
	virtual const TCHAR *	Ext(int n) = 0;					// Extension #n (i.e. "3DS")
	virtual const TCHAR *	LongDesc() = 0;					// Long ASCII description (i.e. "Autodesk 3D Studio File")
	virtual const TCHAR *	ShortDesc() = 0;				// Short ASCII description (i.e. "3D Studio")
	virtual const TCHAR *	AuthorName() = 0;				// ASCII Author name
	virtual const TCHAR *	CopyrightMessage() = 0;			// ASCII Copyright message
	virtual const TCHAR *	OtherMessage1() = 0;			// Other message #1
	virtual const TCHAR *	OtherMessage2() = 0;			// Other message #2
	virtual unsigned int	Version() = 0;					// Version number * 100 (i.e. v3.01 = 301)
	virtual void			ShowAbout(HWND hWnd) = 0;		// Show DLL's "About..." box
	virtual int				DoImport(const TCHAR *name,ImpInterface *ii,Interface *i, BOOL suppressPrompts=FALSE) = 0;	// Import file
	virtual int				ZoomExtents() { return ZOOMEXT_NOT_IMPLEMENTED; }	// Override this for zoom extents control
	};

// SceneExport::DoExport options flags:
#define SCENE_EXPORT_SELECTED (1<<0)

class SceneExport {
public:
							SceneExport() {};
	virtual					~SceneExport() {};
	virtual int				ExtCount() = 0;					// Number of extemsions supported
	virtual const TCHAR *	Ext(int n) = 0;					// Extension #n (i.e. "3DS")
	virtual const TCHAR *	LongDesc() = 0;					// Long ASCII description (i.e. "Autodesk 3D Studio File")
	virtual const TCHAR *	ShortDesc() = 0;				// Short ASCII description (i.e. "3D Studio")
	virtual const TCHAR *	AuthorName() = 0;				// ASCII Author name
	virtual const TCHAR *	CopyrightMessage() = 0;			// ASCII Copyright message
	virtual const TCHAR *	OtherMessage1() = 0;			// Other message #1
	virtual const TCHAR *	OtherMessage2() = 0;			// Other message #2
	virtual unsigned int	Version() = 0;					// Version number * 100 (i.e. v3.01 = 301)
	virtual void			ShowAbout(HWND hWnd) = 0;		// Show DLL's "About..." box
	virtual int				DoExport(const TCHAR *name,ExpInterface *ei,Interface *i, BOOL suppressPrompts=FALSE, DWORD options=0) = 0;	// Export file
	virtual BOOL			SupportsOptions(int ext, DWORD options) {return FALSE;} // Returns TRUE if all option bits set are supported for this extension
	};


#endif // _IMPEXP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\imtl.h ===
/**********************************************************************
 *<
	FILE: imtl.h

	DESCRIPTION: Renderer materials

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __IMTL__H
#define __IMTL__H


#include <plugapi.h>

//#include "gport.h"	
#include "custcont.h" 
#include "shape.h"

#define PROJ_PERSPECTIVE 0   // perspective projection
#define PROJ_PARALLEL 1      // parallel projection

#define AXIS_UV 0
#define AXIS_VW 1
#define AXIS_WU 2

// Values for SymFlags:
#define U_WRAP   (1<<0)
#define V_WRAP   (1<<1)  
#define U_MIRROR (1<<2)
#define V_MIRROR (1<<3)

#define	X_AXIS 0
#define	Y_AXIS 1
#define	Z_AXIS 2

static inline float Intens(const AColor& c) {	return (c.r+c.g+c.b)/3.0f;	}
static inline float Intens(const Color& c) {	return (c.r+c.g+c.b)/3.0f;	}

// Meta-materials post this message to the MtlEditor when user
// clicks on a sub-material button.
#define WM_SUB_MTL_BUTTON	WM_USER + 0x04001

// Materials or Texture maps post this message to the MtlEditor when user
// clicks on a texture map button.
#define WM_TEXMAP_BUTTON	WM_USER + 0x04002

class ShadeContext;
class Bitmap;
class RenderMapsContext; 
class Object;
class UVGen;
class XYZGen;
class Sampler;

// Postage Stamp images ----------
// GetImage fills an array RGB triples.
// Width() and Height() return the dimensions of the image in pixels. 
// The width in bytes of the array is given by the following macro, where w is pixel width. 

#define ByteWidth(w) (((w*3+3)/4)*4)

class PStamp: public AnimProperty {
	public:
	virtual int Width()=0;
	virtual int Height()=0;
	virtual void SetImage(UBYTE *img)=0;
	virtual void GetImage(UBYTE *img)=0;
	virtual void DeleteThis()=0;
	virtual IOResult Load(ILoad *iload)=0;
	virtual IOResult Save(ISave *isave)=0;
	};

class TexHandle {
	public:
		virtual DWORD GetHandle() = 0;
		virtual void DeleteThis() = 0;
	};		

// Values for extraFlags:
#define EX_MULT_ALPHA     1    // if alpha is NOT premultiplied in the Bitmap, set this 
#define EX_RGB_FROM_ALPHA 2    // make map using alpha to define gray level 
#define EX_OPAQUE_ALPHA   4    // make map using opaque alpha 
#define EX_ALPHA_FROM_RGB 8    // make alpha from intensity 

class TexHandleMaker{
	public: 
		// choice of two ways to create a texture handle.
		// From a 3DSMax Bitmap
		virtual TexHandle* CreateHandle(Bitmap *bm, int symflags=0, int extraFlags=0)=0;
		// From a 32 bit DIB
		virtual TexHandle* CreateHandle(BITMAPINFO *bminf, int symflags=0, int extraFlags=0)=0;

		// This tells you the size desired of the bitmap. It ultimately
		// needs a square bitmap that is a power of 2 in width and height.
		// If you already have a bitmap around, just pass it in to CreateHandle
		// and it will be converted.  If you are making a bitmap from scratch
		// (i.e.) a procedural texture, then you should make it Size() in 
		// width in height, and save us an extra step.  In either case
		// You own your bitmap, and are responsible for ultimately freeing it.

		virtual int Size()=0;
	};


// passed to SetPickMode. This is a callback that gets called as
// the user tries to pick objects in the scene.
class PickObjectProc {
	public:
		// Called when the user picks something.
		// return TRUE to end the pick mode.
		virtual BOOL Pick(INode *node)=0;

		// Return TRUE if this is an acceptable hit, FALSE otherwise.
		virtual BOOL Filter(INode *node)=0;

		// These are called as the mode is entered and exited
		virtual void EnterMode() {}
		virtual void ExitMode() {}

		// Provides two cursor, 1 when over a pickable object and 1 when not.
		virtual HCURSOR GetDefCursor() {return NULL;}
		virtual HCURSOR GetHitCursor() {return NULL;}

		// Return TRUE to allow the user to pick more than one thing.
		// In this case the Pick method may be called more than once.
		virtual BOOL AllowMultiSelect() {return FALSE;}
	};


// Interface that is passed in to the Mtl or Texture Map when it is in the mtl
// editor.
class IMtlParams {
	public:
	// call after mouse up's in mtls params
	// It causes the viewports to be redrawn.
	virtual void MtlChanged()=0;  

	// Adds rollup pages to the Material Params. Returns the window
	// handle of the dialog that makes up the page.
	virtual HWND AddRollupPage( HINSTANCE hInst, TCHAR *dlgTemplate, 
		DLGPROC dlgProc, TCHAR *title, LPARAM param=0,DWORD flags=0 )=0;


	// Adds rollup pages to the Material Params. Returns the window
	// handle of the dialog that makes up the page.
	virtual HWND ReplaceRollupPage( HWND hOldRollup, HINSTANCE hInst, TCHAR *dlgTemplate, 
		DLGPROC dlgProc, TCHAR *title, LPARAM param=0,DWORD flags=0 )=0;

	// Removes a rollup page and destroys it.  When a dialog is destroyed
	// it need not delete all its rollup pages: the Mtl Editor will do
	// this for it, and it is more efficient.
	virtual void DeleteRollupPage( HWND hRollup )=0;

	// When the user mouses down in dead area, the plug-in should pass
	// mouse messages to this function which will pass them on to the rollup.
	virtual void RollupMouseMessage( HWND hDlg, UINT message, 
				WPARAM wParam, LPARAM lParam )=0;

	virtual int IsRollupPanelOpen(HWND hwnd)=0;
	virtual int GetRollupScrollPos()=0;
	virtual void SetRollupScrollPos(int spos)=0;

	virtual void RegisterTimeChangeCallback(TimeChangeCallback *tc)=0;
	virtual void UnRegisterTimeChangeCallback(TimeChangeCallback *tc)=0;

	// Registers a dialog window so IsDlgMesage() gets called for it.
	// This is done automatically for Rollup Pages.
	virtual void RegisterDlgWnd( HWND hDlg )=0;
	virtual int UnRegisterDlgWnd( HWND hDlg )=0;

	// get the current time.
	virtual TimeValue GetTime()=0;	

	// Pick an object from the scene
	virtual void SetPickMode(PickObjectProc *proc)=0;
	virtual void EndPickMode()=0;

	// JBW 10/19/98: get interface to mtl editor rollup
	virtual IRollupWindow *GetMtlEditorRollup()=0;

	// Generic expansion function
	virtual int Execute(int cmd, ULONG arg1=0, ULONG arg2=0, ULONG arg3=0) { return 0; } 
	};

class ParamDlg;
class Texmap;

class RenderData {
	public:
		virtual void DeleteThis() {delete this;/*should be pure virtual*/}
		virtual int Execute(int cmd, ULONG arg1=0, ULONG arg2=0, ULONG arg3=0) { return 0;} 
	};

class LightDesc : public RenderData {
	public:
		BOOL affectDiffuse;
		BOOL affectSpecular;
		BOOL  ambientOnly;
		DWORD  extra;
		LightDesc() { affectDiffuse = affectSpecular = TRUE; }
		// determine color and direction of illumination: return FALSE if light behind surface.
		// also computes dot product with normal dot_nl, and diffCoef which is to be used in
		// place of dot_n for diffuse light computations.
	    virtual BOOL Illuminate(ShadeContext& sc, Point3& normal, Color& color, Point3 &dir, float &dot_nl, float &diffuseCoef){ return 0;}
		
		virtual Point3 LightPosition() { return Point3(0,0,0); } 

	};

#define SHADELIM_FLAT 1
#define SHADELIM_GOURAUD 2
#define SHADELIM_PHONG 3

// Transform Reference frames: 
enum RefFrame { REF_CAMERA=0, REF_WORLD, REF_OBJECT };

class ShadeOutput {
	public:
		ULONG flags;
		Color c;  // shaded color
		Color t;  // transparency
		float ior;  // index of refraction
		int gbufId;
		CoreExport void MixIn(ShadeOutput& a, float f);  // (*this) =  (1-f)*(*this) + f*a;
		void Reset() { 
			flags = 0;
			gbufId = 0;
			c.Black(); t.Black(); ior = 1.0f; 
			}
	};


class RenderInstance;

struct ISect {
	float t;   // ray parameter
	BOOL exit;
	BOOL backFace;
	RenderInstance *inst;
	int fnum;  // face number
	Point3 bc; // barycentric coords
	Point3 p;  // intersection point, object coords
	Point3 pc;  // intersection point, camera coords
	ULONG matreq;
	int mtlNum;
	ISect *next;
	};

class ISectList {
	public:
	ISect *first;
	ISectList() { first = NULL; }
	~ISectList() { Init(); }
	BOOL IsEmpty() { return first?0:1; }
	CoreExport void Add(ISect *is); 
	CoreExport void Prune(float a); 
	CoreExport void Init();
	};
	
CoreExport ISect *GetNewISect();
CoreExport void DiscardISect(ISect *is);

// Value given to blurFrame for non blurred objects  ( Object motion blur)
#define NO_MOTBLUR 0xffff 

class FilterKernel;

class RenderGlobalContext {
	public:
	Renderer *renderer;
	int projType; 	// PROJ_PERSPECTIVE or PROJ_PARALLEL
	int devWidth, devHeight;
	float xscale, yscale;
	float xc,yc;
	BOOL antialias;
	Matrix3 camToWorld, worldToCam;
	float nearRange, farRange;
	float devAspect;          // PIXEL aspect ratio of device pixel H/W
	float frameDur;
	Texmap *envMap;
	Color globalLightLevel;
	Atmospheric *atmos;
	TimeValue time;
	BOOL wireMode; // wire frame render mode?
	float wire_thick;  // global wire thickness
	BOOL force2Side;   // is force two-sided rendering enabled
	BOOL inMtlEdit;  // rendering in mtl editor?
	BOOL fieldRender;  // are we rendering fields
	BOOL first_field;  // is this the first field or the second?
	BOOL field_order;  // which field is first: 0->even first,  1->odd first

	BOOL objMotBlur;  // is object motion blur enabled
	int nBlurFrames;  // number of object motion blur time slices

	Point2 MapToScreen(Point3 p){ 	
		if (projType==1) { return Point2(  xc + xscale*p.x , yc + yscale*p.y); }
		else  {	if (p.z==0.0f) p.z = .000001f;
			return Point2( xc + xscale*p.x/p.z,  yc + yscale*p.y/p.z);
			}
		}

	virtual FilterKernel* GetAAFilterKernel(){ return NULL; }
	virtual float GetAAFilterSize(){ return 0.0f; }

	// Access RenderInstances
	virtual int NumRenderInstances() { return 0; }
	virtual RenderInstance* GetRenderInstance( int i ) { return NULL; }

	// Evaluate the global environment map using ray as point of view,
	// optionally with atmospheric effect.
	virtual AColor EvalGlobalEnvironMap(ShadeContext &sc, Ray &r, BOOL applyAtmos) { 
		return AColor(0.0f,0.0f,0.0f,1.0f); 
		}

	virtual void IntersectRay(RenderInstance *inst, Ray& ray, ISect &isct, ISectList &xpList, BOOL findExit) {}
	virtual BOOL IntersectWorld(Ray &ray, int skipID, ISect &hit, ISectList &xplist, int blurFrame = NO_MOTBLUR) { return FALSE; }

	virtual ViewParams *GetViewParams() { return NULL; } 

	virtual FILE* DebugFile() { return NULL; }

	// Generic expansion function
	virtual int Execute(int cmd, ULONG arg1=0, ULONG arg2=0, ULONG arg3=0) { return 0; } 
	};

#define SCMODE_NORMAL  0
#define SCMODE_SHADOW  1
//
// Shade Context: passed into Mtls and Texmaps
//
class ShadeContext {
	public:
	ULONG mode;							// normal, shadow ...
	BOOL doMaps;						// apply texture maps?
	BOOL filterMaps;					// should texture be filtered		            
	BOOL shadow;						// apply shadows?
	BOOL backFace;						// are we on the back side of a 2-Sided face?
	int mtlNum;							// sub-mtl number for multi-materials
	Color ambientLight;					// ambient light 
	int nLights;						// number of lights;
	int rayLevel;
	int xshadeID;  						// different for every shade call in a render.
	LightDesc *atmosSkipLight;
	RenderGlobalContext *globContext;
	ShadeOutput out;                    // where the material leaves its results
	virtual Class_ID ClassID() { return Class_ID(0,0); }  // to distinguish different ShadeContexts.
	void ResetOutput() { out.Reset(); }
	virtual BOOL 	  InMtlEditor()=0;	// is this rendering the mtl editor sample sphere?
	virtual int Antialias() {return 0;}
	virtual int ProjType() { return 0;} // returns: 0: perspective, 1: parallel
	virtual LightDesc* Light(int n)=0;	// get the nth light. 
	virtual TimeValue CurTime()=0;     	// current time value
	virtual int NodeID() { return -1; }
	virtual INode *Node() { return NULL; }
	virtual Object *GetEvalObject() { return NULL; } // Returns the evaluated object for this node. 
												   // Will be NULL if object is motion blurred	
	virtual Point3 BarycentricCoords() { return Point3(0,0,0);}  // coords relative to triangular face 
	virtual int FaceNumber()=0;			// 
	virtual Point3 Normal()=0;  		// interpolated surface normal, in cameara coords: affected by SetNormal()
	virtual void SetNormal(Point3 p) {}	// used for perturbing normal
	virtual Point3 OrigNormal() { return Normal(); } // original surface normal: not affected by SetNormal();
	virtual Point3 GNormal()=0; 		// geometric (face) normal
	virtual float  Curve() { return 0.0f; }   	    // estimate of dN/dsx, dN/dsy
	virtual Point3 V()=0;       		// Unit view vector: from camera towards P 
	virtual void SetView(Point3 p)=0;	// Set the view vector
	virtual Point3 OrigView() { return V(); } // Original view vector: not affected by SetView();
	virtual	Point3 ReflectVector()=0;	// reflection vector
	virtual	Point3 RefractVector(float ior)=0;	// refraction vector
	virtual void SetIOR(float ior) {} // Set index of refraction
	virtual float GetIOR() { return 1.0f; } // Get index of refraction
	virtual Point3 CamPos()=0;			// camera position
	virtual Point3 P()=0;				// point to be shaded;
	virtual Point3 DP()=0;    		  	// deriv of P, relative to pixel, for AA
	virtual void DP(Point3& dpdx, Point3& dpdy){};  // deriv of P, relative to pixel
	virtual Point3 PObj()=0;   		  	// point in obj coords
	virtual Point3 DPObj()=0;   	   	// deriv of PObj, rel to pixel, for AA
	virtual Box3 ObjectBox()=0; 	  	// Object extents box in obj coords
	virtual Point3 PObjRelBox()=0;	  	// Point rel to obj box [-1 .. +1 ] 
	virtual Point3 DPObjRelBox()=0;	  	// deriv of Point rel to obj box [-1 .. +1 ] 
	virtual void ScreenUV(Point2& uv, Point2 &duv)=0; // screen relative uv (from lower left)
	virtual IPoint2 ScreenCoord()=0; // integer screen coordinate (from upper left)
	virtual Point2 SurfacePtScreen(){ return Point2(0.0,0.0); } // return the surface point in screen coords

	virtual Point3 UVW(int channel=0)=0;  			// return UVW coords for point
	virtual Point3 DUVW(int channel=0)=0; 			// return UVW derivs for point
	virtual void DPdUVW(Point3 dP[3],int channel=0)=0; // Bump vectors for UVW (camera space)

	virtual BOOL IsSuperSampleOn(){ return FALSE; }
	virtual BOOL IsTextureSuperSampleOn(){ return FALSE; }
	virtual int GetNSuperSample(){ return 0; }
	virtual float GetSampleSizeScale(){ return 1.0f; }

	// UVWNormal: returns a vector in UVW space normal to the face in UVW space. This can 
	// be CrossProd(U[1]-U[0],U[2]-U[1]), where U[i] is the texture coordinate
	// at the ith vertex of the current face.  Used for hiding textures on
	// back side of objects.
	virtual Point3 UVWNormal(int channel=0) { return Point3(0,0,1); }  

	// diameter of view ray at this point
	virtual float RayDiam() { return Length(DP()); } 

	// angle of ray cone hitting this point: gets increased/decreased by curvature 
	// on reflection
	virtual float RayConeAngle() { return 0.0f; } 

	CoreExport virtual AColor EvalEnvironMap(Texmap *map, Point3 view); //evaluate map with given viewDir
	virtual void GetBGColor(Color &bgcol, Color& transp, BOOL fogBG=TRUE)=0;   // returns Background color, bg transparency

	// Camera ranges set by user in camera's UI.
	virtual float CamNearRange() {return 0.0f;}
	virtual float CamFarRange() {return 0.0f;}

	// Transform to and from internal space
	virtual Point3 PointTo(const Point3& p, RefFrame ito)=0; 
	virtual Point3 PointFrom(const Point3& p, RefFrame ifrom)=0; 
	virtual Point3 VectorTo(const Point3& p, RefFrame ito)=0; 
	virtual Point3 VectorFrom(const Point3& p, RefFrame ifrom)=0; 
	CoreExport virtual Point3 VectorToNoScale(const Point3& p, RefFrame ito); 
	CoreExport virtual Point3 VectorFromNoScale(const Point3& p, RefFrame ifrom); 

	// After being evaluated, if a map or material has a non-zero GBufID, it should
	// call this routine to store it into the shade context.
	void SetGBufferID(int gbid) { out.gbufId = gbid; }

	virtual FILE* DebugFile() { return NULL; }

	virtual AColor EvalGlobalEnvironMap(Point3 dir) { return AColor(0,0,0,0); }

	virtual BOOL GetCache(Texmap *map, AColor &c){ return FALSE; }
	virtual BOOL GetCache(Texmap *map, float &f) { return FALSE; }
	virtual BOOL GetCache(Texmap *map, Point3 &p){ return FALSE; }
	virtual void PutCache(Texmap *map, const AColor &c){}
	virtual void PutCache(Texmap *map, const float f) {}
	virtual void PutCache(Texmap *map, const Point3 &p){}
	virtual void TossCache(Texmap *map) {}
	// Generic expansion function
	virtual int Execute(int cmd, ULONG arg1=0, ULONG arg2=0, ULONG arg3=0) { return 0; } 

	// These are used to prevent self shadowing by volumetric lights
	LightDesc *GetAtmosSkipLight() { return atmosSkipLight; }
	void SetAtmosSkipLight(LightDesc *lt) { atmosSkipLight = lt; }

	ShadeContext() {mode = SCMODE_NORMAL; nLights = 0; shadow = TRUE;  rayLevel = 0; globContext = NULL; atmosSkipLight = NULL; }
	};

		
// Material and Texmap flags values
#define MTL_IN_SCENE          	(1<<0)
#define MTL_BEING_EDITED     	(1<<1)  // mtl params being displayed in medit
#define MTL_SUB_BEING_EDITED 	(1<<2)  // mtl OR sub mtl/tex being displayed in medit
#define MTL_TEX_DISPLAY_ENABLED (1<<3)  // Interactive texture display enabled
#define MTL_MEDIT_BACKGROUND    (1<<8)  // Show background in Mtl Editor
#define MTL_MEDIT_BACKLIGHT		(1<<9)  // Backlight in Mtl Editor

#define MTL_OBJTYPE_SHIFT		10
#define MTL_MEDIT_OBJTYPE		(1<<MTL_OBJTYPE_SHIFT) // Object type displayed in Mtl Editor
#define MTL_MEDIT_OBJTYPE_MASK	((1<<MTL_OBJTYPE_SHIFT)|(1<<MTL_OBJTYPE_SHIFT+1)|(1<<MTL_OBJTYPE_SHIFT+2))

#define MTL_TILING_SHIFT		13
#define MTL_MEDIT_TILING		(1<<MTL_TILING_SHIFT) // Object type displayed in Mtl Editor
#define MTL_MEDIT_TILING_MASK	((1<<MTL_TILING_SHIFT)|(1<<MTL_TILING_SHIFT+1)|(1<<MTL_TILING_SHIFT+2))
#define MTL_MEDIT_VIDCHECK		(1<<16)
#define MTL_BROWSE_OPEN1		(1<<18)
#define MTL_BROWSE_OPEN2		(1<<19)
#define MTL_WORK_FLAG			(1<<31)

// Material Requirements flags: returned by Requirements() function
#define MTLREQ_2SIDE    		(1<<0)  // 2-sided material
#define MTLREQ_WIRE     		(1<<1)  // Wire frame
#define MTLREQ_WIRE_ABS 		(1<<2)  // Wire frame, absolute size
#define MTLREQ_TRANSP   		(1<<3) 	// transparency
#define MTLREQ_UV				(1<<4)  // requires UVW coords
#define MTLREQ_FACEMAP			(1<<5)  // use "face map" UV coords
#define MTLREQ_XYZ				(1<<6)  // requires object XYZ coords
#define MTLREQ_OXYZ 			(1<<7)  // requires object ORIGINAL XYZ coords
#define MTLREQ_BUMPUV			(1<<8)  // requires UV bump vectors
#define MTLREQ_BGCOL			(1<<9)  // requires background color (e.g. Matte mtl)
#define MTLREQ_PHONG			(1<<10) // requires interpolated normal
#define MTLREQ_AUTOREFLECT 		(1<<11) // needs to build auto-reflect map
#define MTLREQ_AUTOMIRROR 		(1<<12) // needs to build auto-mirror map
#define MTLREQ_NOATMOS 			(1<<13) // suppress atmospheric shader (used by Matte mtl)
#define MTLREQ_ADDITIVE_TRANSP	(1<<14) // composite additively 
#define MTLREQ_VIEW_DEP			(1<<15) // mtl/map is view dependent 
#define MTLREQ_UV2				(1<<16)  // requires second uv channel values (vertex colors)
#define MTLREQ_BUMPUV2			(1<<17)  // requires second uv channel bump vectors
#define MTLREQ_PREPRO	    	(1<<18)  // Pre-processing. BuildMaps will be called on every frame
#define MTLREQ_DONTMERGE_FRAGMENTS 	(1<<19) // inhibit sub-pixel fragment merging, when mtl creates
										    // discontinuities across edges that would normally be smooth.
#define MTLREQ_DISPLACEMAP 		(1<<20) //Material has Displacement map channel
#define MTLREQ_SUPERSAMPLE 		(1<<21) //Material requires supersampling
#define MTLREQ_WORLDCOORDS 		(1<<22) //World coordinates are used in mtl/map evaluation

#define MAPSLOT_TEXTURE      0 	// texture maps: 
#define MAPSLOT_ENVIRON      1 	// environment maps: generate UVW on-the-fly using view vector, default to spherical
#define MAPSLOT_DISPLACEMENT 2 	// displacement maps: a type of texture map.
#define MAPSLOT_BACKGROUND   3 	// background maps: generate UVW on-the-fly using view vector, default to screen

// Where to get texture vertices: returned by GetUVWSource();
#define UVWSRC_EXPLICIT   0		// use explicit mesh texture vertices (whichever map channel)
#define UVWSRC_OBJXYZ	  1 	// generate planar uvw mapping from object xyz on-the-fly
#define UVWSRC_EXPLICIT2  2  	// use explicit mesh map color vertices as a tex map
#define UVWSRC_WORLDXYZ   3  	// generate planar uvw mapping from world xyz on-the-fly
#ifdef DESIGN_VER
#define UVWSRC_GEOXYZ	  4		// generate planar uvw mapping from geo referenced world xyz on-the-fly
#endif


// Base class from which materials and textures are subclassed.
class MtlBase: public ReferenceTarget {
	friend class Texmap;
	TSTR name;
	ULONG mtlFlags;
	int defaultSlotType;
	public:
		Quat meditRotate;
		ULONG gbufID;
		CoreExport MtlBase();
		TSTR& GetName() { return name; }
		CoreExport void SetName(TSTR s);
		void SetMtlFlag(int mask, BOOL val=TRUE) { 
			if (val) mtlFlags |= mask; else mtlFlags &= ~mask;
			}
		void ClearMtlFlag(int mask) { mtlFlags &= ~mask; }
		int TestMtlFlag(int mask) { return(mtlFlags&mask?1:0); }

		// Used internally by materials editor.
		int GetMeditObjType() { return (mtlFlags&MTL_MEDIT_OBJTYPE_MASK)>>MTL_OBJTYPE_SHIFT; }	
		void SetMeditObjType(int t) { mtlFlags &= ~MTL_MEDIT_OBJTYPE_MASK; mtlFlags |= t<<MTL_OBJTYPE_SHIFT; }
		int GetMeditTiling() { return (mtlFlags&MTL_MEDIT_TILING_MASK)>>MTL_TILING_SHIFT; }	
		void SetMeditTiling(int t) { mtlFlags &= ~MTL_MEDIT_TILING_MASK; mtlFlags |= t<<MTL_TILING_SHIFT; }

		// recursively determine if there are any multi-materials or texmaps 
		// in tree
		CoreExport BOOL AnyMulti();

		BOOL TextureDisplayEnabled() { return TestMtlFlag(MTL_TEX_DISPLAY_ENABLED); }

		// Return the "className(instance Name)". 
		// The default implementation should be used in most cases.
	    CoreExport virtual TSTR GetFullName();

		// Mtls and Texmaps must use this to copy the common portion of 
		// themselves when cloning
		CoreExport MtlBase& operator=(const MtlBase& m);

		virtual int BuildMaps(TimeValue t, RenderMapsContext &rmc) { return 1; }

		// This gives the cumulative requirements of the mtl and its
		// tree. The default just OR's together the local requirements
		// of the Mtl with the requirements of all its children.
		// For most mtls, all they need to implement is LocalRequirements,
		// if any.
		CoreExport virtual ULONG Requirements(int subMtlNum); 

		// Specifies various requirements for the material: Should NOT
		// include requirements of its sub-mtls and sub-maps.
		virtual ULONG LocalRequirements(int subMtlNum) { return 0; } 

		// This gives the UVW channel requirements of the mtl and its
		// tree. The default implementation just OR's together the local mapping requirements
		// of the Mtl with the requirements of all its children.
		// For most mtls, all they need to implement is LocalMappingsRequired, if any.
		// mapreq and bumpreq will be initialized to empty sets with MAX_MESHMAPS elements
		// set 1's in mapreq for uvw channels required
		// set 1's in bumpreq for bump mapping channels required
		CoreExport virtual void MappingsRequired(int subMtlNum, BitArray & mapreq, BitArray &bumpreq);

		// Specifies UVW channel requirements for the material: Should NOT
		// include UVW channel requirements of its sub-mtls and sub-maps.
		virtual void LocalMappingsRequired(int subMtlNum, BitArray & mapreq, BitArray &bumpreq) {  }

		// This returns true for materials or texmaps that select sub-
		// materials based on mesh faceMtlIndex. Used in 
		// interactive render.
		virtual	BOOL IsMultiMtl() { return FALSE; }

		// Methods to access sub texture maps of material or texmap
		virtual int NumSubTexmaps() { return 0; }
		virtual Texmap* GetSubTexmap(int i) { return NULL; }
		virtual int MapSlotType(int i) { return defaultSlotType; }
		virtual void SetSubTexmap(int i, Texmap *m) { }

		// query MtlBase about the On/Off state of each sub map.
		virtual int SubTexmapOn(int i) { return 1; } 

		// This must be called on a sub-Mtl or sub-Map when it is removed,
		// in case it or any of its submaps are active in the viewport.
		CoreExport void DeactivateMapsInTree();

		CoreExport virtual TSTR GetSubTexmapSlotName(int i);
		CoreExport TSTR GetSubTexmapTVName(int i);
		// use this for drag-and-drop of texmaps
		CoreExport void CopySubTexmap(HWND hwnd, int ifrom, int ito);

		// To make texture & material evaluation more efficient, this function is
		// called whenever time has changed.  It will be called at the
		// beginning of every frame during rendering.
		virtual	void Update(TimeValue t, Interval& valid)=0;

		// set back to default values
		virtual void Reset()=0;

		// call this to determine the validity interval of the mtl or texture
		virtual Interval Validity(TimeValue t)=0;
		
		// this gets called when the mtl or texture is to be displayed in the
		// mtl editor params area.
		virtual ParamDlg* CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp)=0;
		// called by the ParamMap2 AUTO_UI system if the material/map is letting
		// the system build an AutoMParamDlg for it.  SetDlgThing() is called on
		// a material/map coming into an exsting set of ParamDlgs, once for each 
		// secondary ParamDlg and it should set the appropriate 'thing' into the
		// given dlg (for example, Texout* or UVGen*).  Return FALSE if dlg is unrecognized.
		// See Gradient::SetDlgThing() for an example.
		virtual BOOL SetDlgThing(ParamDlg* dlg) { return FALSE; }

		// save the common mtlbase stuff.
		// these must be called in a chunk at the beginning of every mtl and
		// texmap.
		CoreExport IOResult Save(ISave *isave);
        CoreExport IOResult Load(ILoad *iload);
		
		// GBuffer functions
		ULONG GetGBufID() { return gbufID; }
		void SetGBufID(ULONG id) { gbufID = id; }
		
		// Default File enumerator.
		CoreExport void EnumAuxFiles(NameEnumCallback& nameEnum, DWORD flags);

		// Postage Stamp
		CoreExport PStamp* GetPStamp(int sz); // sz = 0: small, 1: large   		
		CoreExport PStamp* CreatePStamp(int sz);    		
		CoreExport void DiscardPStamp(int sz);   		

		// Schematic View Animatable Overides...
		CoreExport SvGraphNodeReference SvTraverseAnimGraph(IGraphObjectManager *gom, Animatable *owner, int id, DWORD flags);
		CoreExport bool SvHandleDoubleClick(IGraphObjectManager *gom, IGraphNode *gNode);
		CoreExport TSTR SvGetName(IGraphObjectManager *gom, IGraphNode *gNode, bool isBeingEdited);
		CoreExport bool SvCanSetName(IGraphObjectManager *gom, IGraphNode *gNode);
		CoreExport bool SvSetName(IGraphObjectManager *gom, IGraphNode *gNode, TSTR &name);
		CoreExport COLORREF SvHighlightColor(IGraphObjectManager *gom, IGraphNode *gNode);
		CoreExport bool SvIsSelected(IGraphObjectManager *gom, IGraphNode *gNode);
		CoreExport MultiSelectCallback* SvGetMultiSelectCallback(IGraphObjectManager *gom, IGraphNode *gNode);
		CoreExport bool SvCanSelect(IGraphObjectManager *gom, IGraphNode *gNode);
	};


// Every MtlBase sub-class defines a ParamDlg to manage its part of
// the material editor.
class ParamDlg {
	public:
		virtual Class_ID ClassID()=0;
		virtual void SetThing(ReferenceTarget *m)=0;
		virtual ReferenceTarget* GetThing()=0;
		virtual void SetTime(TimeValue t)=0;
		virtual	void ReloadDialog()=0;
		virtual void DeleteThis()=0;
		virtual void ActivateDlg(BOOL onOff)=0;
		// These need to be implemented if using a TexDADMgr or a MtlDADMgr
		virtual int FindSubTexFromHWND(HWND hwnd){ return -1;} 
		virtual int FindSubMtlFromHWND(HWND hwnd){ return -1;} 
		// Generic expansion function
		virtual int Execute(int cmd, ULONG arg1=0, ULONG arg2=0, ULONG arg3=0) { return 0; } 

	};

// Pre-defined categories of texture maps
CoreExport TCHAR TEXMAP_CAT_2D[];  // 2D maps
CoreExport TCHAR TEXMAP_CAT_3D[];  // 3D maps
CoreExport TCHAR TEXMAP_CAT_COMP[]; // Composite
CoreExport TCHAR TEXMAP_CAT_COLMOD[]; // Color modifier
CoreExport TCHAR TEXMAP_CAT_ENV[];  // Environment

class NameAccum {
	public:
		virtual	void AddMapName(TCHAR *name)=0;
	};


// virual texture map interface
class Texmap: public MtlBase {
	int activeCount;
	public:
		int cacheID;    // used by renderer for caching returned values
				
		CoreExport Texmap();

		SClass_ID SuperClassID() { return TEXMAP_CLASS_ID; }
		virtual void GetClassName(TSTR& s) { s= TSTR(_T("Texture")); }  

		// Evaluate the color of map for the context.
		virtual	AColor EvalColor(ShadeContext& sc)=0;
	
		// Evaluate the map for a "mono" channel.
		// this just permits a bit of optimization 
		virtual	float  EvalMono(ShadeContext& sc) {
			return Intens(EvalColor(sc));
			}
		
		// For Bump mapping, need a perturbation to apply to a normal.
		// Leave it up to the Texmap to determine how to do this.
		virtual	Point3 EvalNormalPerturb(ShadeContext& sc)=0;

		// This query is made of maps plugged into the Reflection or 
		// Refraction slots:  Normally the view vector is replaced with
		// a reflected or refracted one before calling the map: if the 
		// plugged in map doesn't need this , it should return TRUE.
		virtual BOOL HandleOwnViewPerturb() { return FALSE; }

		// Methods for doing interactive texture display
		CoreExport void IncrActive();
		CoreExport void DecrActive(); 

		int Active() { return activeCount; }
		virtual BOOL SupportTexDisplay() { return FALSE; }
		virtual void ActivateTexDisplay(BOOL onoff) {}
		virtual DWORD GetActiveTexHandle(TimeValue t, TexHandleMaker& thmaker) {return 0;}

		virtual	void GetUVTransform(Matrix3 &uvtrans) {}
		virtual int GetTextureTiling() { return  U_WRAP|V_WRAP; }
		virtual void InitSlotType(int sType) { defaultSlotType = sType; }			   
		virtual int MapSlotType(int i) { return defaultSlotType; }
		virtual int GetUVWSource() { return UVWSRC_EXPLICIT; }
		virtual int GetMapChannel () { return 1; }	// only relevant if above returns UVWSRC_EXPLICIT

		virtual UVGen *GetTheUVGen() { return NULL; }  // maps with a UVGen should implement this
		virtual XYZGen *GetTheXYZGen() { return NULL; } // maps with a XYZGen should implement this

		// System function to set slot type for all subtexmaps in a tree.
		CoreExport void RecursInitSlotType(int sType);			   
		virtual void SetOutputLevel(TimeValue t, float v) {}

		// called prior to render: missing map names should be added to NameAccum.
		// return 1: success,   0:failure. 
		virtual int LoadMapFiles(TimeValue t) { return 1; } 

		// render a 2-d bitmap version of map.
		CoreExport virtual void RenderBitmap(TimeValue t, Bitmap *bm, float scale3D=1.0f, BOOL filter = FALSE);

		CoreExport void RefAdded(RefMakerHandle rm);

		// Schematic View Animatable Overides...
		CoreExport SvGraphNodeReference SvTraverseAnimGraph(IGraphObjectManager *gom, Animatable *owner, int id, DWORD flags);

	};


class TexmapContainer: public ReferenceTarget {
	SClass_ID SuperClassID() { return TEXMAP_CONTAINER_CLASS_ID; }
	CoreExport SvGraphNodeReference SvTraverseAnimGraph(IGraphObjectManager *gom, Animatable *owner, int id, DWORD flags);
	};

// ID's for different DynamicProperties: passed into
// GetDynamicProperty()

#define DYN_BOUNCE 1
#define DYN_STATIC_FRICTION 2
#define DYN_SLIDING_FRICTION 3


// virtual material interface
class Mtl: public MtlBase {
	Texmap *activeTexmap; 
	public:
		CoreExport Mtl();
		SClass_ID SuperClassID() { return MATERIAL_CLASS_ID; }
		virtual void GetClassName(TSTR& s) { s= TSTR(_T("Mtl")); }  

		Texmap* GetActiveTexmap() { return activeTexmap; }
		void SetActiveTexmap( Texmap *txm) { activeTexmap = txm; }

		CoreExport void RefDeleted();
		CoreExport void RefAdded(RefMakerHandle rm);  

		// Must call Update(t) before calling these functions!
		// Their purpose is for setting up the material for the
		// GraphicsWindow renderer.
		virtual Color GetAmbient(int mtlNum=0, BOOL backFace=FALSE)=0;
		virtual Color GetDiffuse(int mtlNum=0, BOOL backFace=FALSE)=0;	    
		virtual Color GetSpecular(int mtlNum=0, BOOL backFace=FALSE)=0;
		virtual float GetShininess(int mtlNum=0, BOOL backFace=FALSE)=0;
		virtual	float GetShinStr(int mtlNum=0, BOOL backFace=FALSE)=0;		
		virtual float GetXParency(int mtlNum=0, BOOL backFace=FALSE)=0;

		// >>>>> Self-Illum
		virtual BOOL GetSelfIllumColorOn(int mtlNum=0, BOOL backFace=FALSE) { return TRUE; }
		virtual float GetSelfIllum(int mtlNum=0, BOOL backFace=FALSE) { return 0.0f; }
		virtual Color GetSelfIllumColor(int mtlNum=0, BOOL backFace=FALSE){ Color c( .0f,.0f,.0f); return c; }

		// sampler
		virtual Sampler * GetPixelSampler(int mtlNum=0, BOOL backFace=FALSE){ return NULL; }

		// used by the scanline renderer
		virtual float WireSize(int mtlNum=0, BOOL backFace=FALSE) { return 1.0f; }

		// why incomplete sets?? 
		// used onlt for default material creation....add no more
		virtual void SetAmbient(Color c, TimeValue t)=0;		
		virtual void SetDiffuse(Color c, TimeValue t)=0;		
		virtual void SetSpecular(Color c, TimeValue t)=0;
		virtual void SetShininess(float v, TimeValue t)=0;		

		// The main method: called by the renderer to compute color and transparency
		// output returned in sc.out
		virtual void Shade(ShadeContext& sc)=0;

		// Methods to access sub-materials of meta-materials 
		virtual int NumSubMtls() { return 0; }
		virtual Mtl* GetSubMtl(int i) { return NULL; }
		virtual void SetSubMtl(int i, Mtl *m) { }
		virtual int SubMtlOn(int i) { return 1; } 
		CoreExport virtual TSTR GetSubMtlSlotName(int i);
		CoreExport TSTR GetSubMtlTVName(int i);					  
		CoreExport void CopySubMtl(HWND hwnd, int ifrom, int ito);

		// Dynamics properties
		virtual CoreExport float GetDynamicsProperty(TimeValue t, int mtlNum, int propID);
		virtual CoreExport void SetDynamicsProperty(TimeValue t, int mtlNum, int propID, float value);
		
		// Displacement mapping
		virtual float EvalDisplacement(ShadeContext& sc) { return 0.0f; }
		virtual Interval DisplacementValidity(TimeValue t) { return FOREVER; }

		// Schematic View Animatable Overides...
		CoreExport bool SvCanInitiateLink(IGraphObjectManager *gom, IGraphNode *gNode);

		// allows plugins to control the display of the Discard/Keep Old Material dialog when being
		// created in a MtlEditor slot.  Added by JBW for scripted material plugins.
		// return TRUE to prevent the Keep Old Material dialog from poping.
		virtual BOOL DontKeepOldMtl() { return FALSE; }
	};

//  A texture map implements this class and passes it into  EvalUVMap,
//  EvalUVMapMono, and EvalDeriv to evaluate itself with tiling & mirroring
class MapSampler {
	public:
		// required:
		virtual	AColor Sample(ShadeContext& sc, float u,float v)=0;
		virtual	AColor SampleFilter(ShadeContext& sc, float u,float v, float du, float dv)=0;
		// optional:
		virtual void SetTileNumbers(int iu, int iv) {} // called before SampleFunctions to tell what tile your in
		virtual	float SampleMono(ShadeContext& sc, float u,float v) { return Intens(Sample(sc,u,v)); }
		virtual	float SampleMonoFilter(ShadeContext& sc, float u,float v, float du, float dv){
			return Intens(SampleFilter(sc,u,v,du,dv)); 
			}
	};


// This class generates UV coordinates based on the results of a UV 
// Source and user specified transformation.
// A reference to one of these is referenced by all 2D texture maps.
class UVGen: public MtlBase {
	public:
		// Get texture coords and derivatives for antialiasing
		virtual void GetUV( ShadeContext& sc, Point2& UV, Point2& dUV)=0;
		
		// This is how a Texmap evaluates itself
		virtual AColor EvalUVMap(ShadeContext &sc, MapSampler* samp,  BOOL filter=TRUE)=0;
		virtual float EvalUVMapMono(ShadeContext &sc, MapSampler* samp, BOOL filter=TRUE)=0;
		virtual	Point2 EvalDeriv( ShadeContext& sc, MapSampler* samp, BOOL filter=TRUE)=0;

		// Get dPdu and dPdv for bump mapping
		virtual	void GetBumpDP( ShadeContext& sc, Point3& dPdu, Point3& dPdv)=0;

		virtual void GetUVTransform(Matrix3 &uvtrans)=0;

		virtual int GetTextureTiling()=0;
		virtual void SetTextureTiling(int t)=0;

		virtual int GetUVWSource()=0;
		virtual int GetMapChannel () { return 1; }	// only relevant if above returns UVWSRC_EXPLICIT
		virtual void SetUVWSource(int s)=0;
		virtual void SetMapChannel (int s) { }

		virtual int SymFlags()=0;
		virtual void SetSymFlags(int f)=0;

		virtual int GetSlotType()=0; 
		virtual void InitSlotType(int sType)=0; 

		virtual int GetAxis()=0;  // returns AXIS_UV, AXIS_VW, AXIS_WU
		virtual void SetAxis(int ax)=0;  //  AXIS_UV, AXIS_VW, AXIS_WU

		// The clip flag controls whether the U,V values passed to MapSampler by 
		//  EvalUVMap and EvalUVMapMono are clipped to the [0..1] interval or not. 
		// It defaults to ON (i.e., clipped).
		virtual void SetClipFlag(BOOL b)=0;	
		virtual BOOL GetClipFlag()=0;

		virtual BOOL IsStdUVGen() { return FALSE; } // class StdUVGen implements this to return TRUE

		SClass_ID SuperClassID() { return UVGEN_CLASS_ID; }

		virtual void SetRollupOpen(BOOL open)=0;
		virtual BOOL GetRollupOpen()=0;
		CoreExport SvGraphNodeReference SvTraverseAnimGraph(IGraphObjectManager *gom, Animatable *owner, int id, DWORD flags);
		CoreExport TSTR SvGetName(IGraphObjectManager *gom, IGraphNode *gNode, bool isBeingEdited)
			{
			return Animatable::SvGetName(gom, gNode, isBeingEdited);
			}
	};

// This class generates Point3 coordinates based on the ShadeContext.
// A reference to one of these is referenced by all 3D texture maps.
class XYZGen: public MtlBase {
	public:
		// Get texture coords and derivatives for antialiasing
		virtual void GetXYZ( ShadeContext& sc, Point3& p, Point3& dp)=0;
		SClass_ID SuperClassID() { return XYZGEN_CLASS_ID; }
		virtual void SetRollupOpen(BOOL open)=0;
		virtual BOOL GetRollupOpen()=0;
		virtual BOOL IsStdXYZGen() { return FALSE; } // class StdXYZGen implements this to return TRUE
		virtual	void GetBumpDP( ShadeContext& sc, Point3* dP) {}; // returns 3 unit vectors for computing differentials
		CoreExport SvGraphNodeReference SvTraverseAnimGraph(IGraphObjectManager *gom, Animatable *owner, int id, DWORD flags);
		CoreExport TSTR SvGetName(IGraphObjectManager *gom, IGraphNode *gNode, bool isBeingEdited)
			{
			return Animatable::SvGetName(gom, gNode, isBeingEdited);
			}
	};

// This class is used by texture maps to put up the output filter 
// rollup, and perform the output filtering.
class TextureOutput: public MtlBase {
	public:
		virtual AColor Filter(AColor c) = 0;
		virtual float Filter(float f) = 0;
		virtual Point3 Filter(Point3 p) = 0;
		virtual float GetOutputLevel(TimeValue t) = 0;
		virtual void SetOutputLevel(TimeValue t, float v) = 0;
		virtual void SetInvert(BOOL onoff)=0;
		virtual BOOL GetInvert()=0;
		virtual void SetRollupOpen(BOOL open)=0;
		virtual BOOL GetRollupOpen()=0;
		SClass_ID SuperClassID() { return TEXOUTPUT_CLASS_ID; }
		CoreExport SvGraphNodeReference SvTraverseAnimGraph(IGraphObjectManager *gom, Animatable *owner, int id, DWORD flags);
		CoreExport TSTR SvGetName(IGraphObjectManager *gom, IGraphNode *gNode, bool isBeingEdited)
			{
			return Animatable::SvGetName(gom, gNode, isBeingEdited);
			}
	};

typedef MtlBase* MtlBaseHandle;
typedef Mtl* MtlHandle;
typedef Texmap* TexmapHandle;


// Simple list of materials
class MtlList: public Tab<MtlHandle> {
	public:
		CoreExport int AddMtl(Mtl *m, BOOL checkUnique=TRUE);
		CoreExport int FindMtl(Mtl *m);
		CoreExport int FindMtlByName(TSTR& name);
		void RemoveEntry(int n) { Delete(n,1); }
		void Empty() { Resize(0); }
	};

// Materials library
class MtlLib: public ReferenceTarget, public MtlList {
	public:
		SClass_ID SuperClassID() { return REF_MAKER_CLASS_ID; }
		CoreExport Class_ID ClassID();
		CoreExport void DeleteAll();
		void GetClassName(TSTR& s) { s= TSTR(_T("MtlLib")); }  
		CoreExport ~MtlLib();

		int NumSubs() { 
			return Count(); 
			}  
		Animatable* SubAnim(int i) { 
			return (*this)[i]; 
			}
		CoreExport TSTR SubAnimName(int i);
		CoreExport virtual void Remove(Mtl *m);
		CoreExport virtual void Add(Mtl *m);

		// From ref
		RefResult AutoDelete() { return REF_SUCCEED; }
		CoreExport void DeleteThis();
		int NumRefs() { return Count();}
		RefTargetHandle GetReference(int i) { return (RefTargetHandle)(*this)[i];}
		CoreExport void SetReference(int i, RefTargetHandle rtarg);
		CoreExport RefTargetHandle Clone(RemapDir &remap = NoRemap());
		CoreExport RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message );

		// IO
		CoreExport IOResult Save(ISave *isave);
        CoreExport IOResult Load(ILoad *iload);

	};


// A MtlBase Version of the above
class MtlBaseList: public Tab<MtlBaseHandle> {
	public:
		CoreExport int AddMtl(MtlBase *m, BOOL checkUnique=TRUE);
		CoreExport int FindMtl(MtlBase *m);
		CoreExport int FindMtlByName(TSTR& name);
		void RemoveEntry(int n) { Delete(n,1); }
		void Empty() { Resize(0); }
	};

class MtlBaseLib : public ReferenceTarget, public MtlBaseList {
	public:
		SClass_ID SuperClassID() { return REF_MAKER_CLASS_ID; }
		CoreExport Class_ID ClassID();
		CoreExport void DeleteAll();
		void GetClassName(TSTR& s) { s= TSTR(_T("MtlBaseLib")); }  
		CoreExport ~MtlBaseLib();

		int NumSubs() {return Count();}		
		Animatable* SubAnim(int i) {return (*this)[i];}
		CoreExport TSTR SubAnimName(int i);
		
		CoreExport virtual void Remove(MtlBase *m);
		CoreExport virtual void Add(MtlBase *m);
		CoreExport virtual void RemoveDuplicates();

		// From ref
		RefResult AutoDelete() {return REF_SUCCEED;}
		CoreExport void DeleteThis();
		int NumRefs() { return Count();}
		RefTargetHandle GetReference(int i) { return (RefTargetHandle)(*this)[i];}
		CoreExport void SetReference(int i, RefTargetHandle rtarg);
		CoreExport RefTargetHandle Clone(RemapDir &remap = NoRemap());
		CoreExport RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message );

		// IO
		CoreExport IOResult Save(ISave *isave);
        CoreExport IOResult Load(ILoad *iload);
	};


// Simple list of numbers
class NumList: public Tab<int> {
	public:
		CoreExport int Add(int j, BOOL checkUnique=TRUE);
		CoreExport int Find(int j);
	};

class MtlRemap {
	public:
		virtual Mtl* Map(Mtl *oldAddr)=0;
	};

//--------------------------------------------------------------------------------
// Use this class to implement Drag-and-Drop for materials sub-Texmaps.
// If this class is used the ParamDlg method FindSubTexFromHWND() must be implemented.
//--------------------------------------------------------------------------------
class TexDADMgr: public DADMgr {
	ParamDlg *dlg;
	public:
		TexDADMgr(ParamDlg *d=NULL) { dlg = d;}
		void Init(ParamDlg *d) { dlg = d; }
		// called on the draggee to see what if anything can be dragged from this x,y
		SClass_ID GetDragType(HWND hwnd, POINT p) { return TEXMAP_CLASS_ID; }
		// called on potential dropee to see if can drop type at this x,y
		CoreExport BOOL OkToDrop(ReferenceTarget *dropThis, HWND hfrom, HWND hto, POINT p, SClass_ID type, BOOL isNew);
		int SlotOwner() { return OWNER_MTL_TEX;	}
	    CoreExport ReferenceTarget *GetInstance(HWND hwnd, POINT p, SClass_ID type);
		CoreExport void Drop(ReferenceTarget *dropThis, HWND hwnd, POINT p, SClass_ID type);
		CoreExport BOOL  LetMeHandleLocalDAD(); 
		CoreExport void  LocalDragAndDrop(HWND h1, HWND h2, POINT p1, POINT p2);
		BOOL  AutoTooltip(){ return TRUE; }
	};


//--------------------------------------------------------------------------------
// Use this class to implement Drag-and-Drop for materials sub-materials.
// If this class is used the ParamDlg method FindSubMtlFromHWND() must be implemented.
//--------------------------------------------------------------------------------
class MtlDADMgr: public DADMgr {
	ParamDlg *dlg;
	public:
		MtlDADMgr(ParamDlg *d=NULL) { dlg = d;}
		void Init(ParamDlg *d) { dlg = d; }
		// called on the draggee to see what if anything can be dragged from this x,y
		SClass_ID GetDragType(HWND hwnd, POINT p) { return MATERIAL_CLASS_ID; }
		// called on potential dropee to see if can drop type at this x,y
		BOOL OkToDrop(ReferenceTarget *dropThis, HWND hfrom, HWND hto, POINT p, SClass_ID type, BOOL isNew) {
			if (hfrom==hto) return FALSE;
			return (type==MATERIAL_CLASS_ID)?1:0;
			}
		int SlotOwner() { return OWNER_MTL_TEX;	}
	    CoreExport ReferenceTarget *GetInstance(HWND hwnd, POINT p, SClass_ID type);
		CoreExport void Drop(ReferenceTarget *dropThis, HWND hwnd, POINT p, SClass_ID type);
		CoreExport BOOL  LetMeHandleLocalDAD(); 
		CoreExport void  LocalDragAndDrop(HWND h1, HWND h2, POINT p1, POINT p2);
		BOOL  AutoTooltip(){ return TRUE; }
	};


// this class used for Drag/and/dropping Bitmaps
class DADBitmapCarrier: public ReferenceTarget {
	TSTR name;
	public:
	void SetName(TSTR &nm) { name = nm; }
	TSTR& GetName() { return name; }		

	Class_ID ClassID() { return Class_ID(0,1); }
	SClass_ID SuperClassID() { return BITMAPDAD_CLASS_ID; }		
	void DeleteThis() { }
	RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	         PartID& partID,  RefMessage message) { return REF_DONTCARE; }		
	RefTargetHandle Clone(RemapDir &remap = NoRemap()) { assert(0); return NULL; }

	};

// Get a pointer to the BitmapCarrier (their's only two of these: one for the
// source, and one for the destination:  don't try to delete these; 
CoreExport DADBitmapCarrier *GetDADBitmapCarrier();


CoreExport void SetLoadingMtlLib(MtlLib *ml);
CoreExport void SetLoadingMtlBaseLib(MtlBaseLib *ml);

CoreExport ClassDesc* GetMtlLibCD();
CoreExport ClassDesc* GetMtlBaseLibCD();

CoreExport UVGen* GetNewDefaultUVGen();
CoreExport XYZGen* GetNewDefaultXYZGen();
CoreExport TextureOutput* GetNewDefaultTextureOutput();
inline int IsMtl(Animatable *m) { return m->SuperClassID()==MATERIAL_CLASS_ID; }
inline int IsTex(Animatable *m) { return m->SuperClassID()==TEXMAP_CLASS_ID; }
inline int IsMtlBase(Animatable *m) { return IsMtl(m)||IsTex(m); }

// Combines the two materials into a multi-material.
// Either of the two input materials can themselves be multis.
// c1 and c2 will be set to the mat count for mat1 and mat2.
CoreExport Mtl *CombineMaterials(Mtl *mat1, Mtl *mat2, int &mat2Offset);

// Expand multi material size to the largest face ID
CoreExport Mtl *FitMaterialToMeshIDs(Mesh &mesh,Mtl *mat);
CoreExport Mtl *FitMaterialToShapeIDs(BezierShape &shape, Mtl *mat);
CoreExport Mtl *FitMaterialToPatchIDs(PatchMesh &patch, Mtl *mat);

// Adjust face IDs so that no face ID is greater then them multi size
CoreExport void FitMeshIDsToMaterial(Mesh &mesh, Mtl *mat);
CoreExport void FitShapeIDsToMaterial(BezierShape &shape, Mtl *mat);
CoreExport void FitPatchIDsToMaterial(PatchMesh &patch, Mtl *mat);

// Remove unused mats in a multi and shift face IDs.
CoreExport Mtl *CondenseMatAssignments(Mesh &mesh, Mtl *mat);
CoreExport Mtl *CondenseMatAssignments(BezierShape &shape, Mtl *mat);
CoreExport Mtl *CondenseMatAssignments(PatchMesh &patch, Mtl *mat);


// Attach materials dialog support -- TH 3/9/99

// Attach Mat values
#define ATTACHMAT_IDTOMAT 0
#define ATTACHMAT_MATTOID 1
#define ATTACHMAT_NEITHER 2

class AttachMatDlgUser {
	public:
		virtual int GetAttachMat()=0;
		virtual BOOL GetCondenseMat()=0;
		virtual void SetAttachMat(int value)=0;
		virtual void SetCondenseMat(BOOL sw)=0;
	};

CoreExport BOOL DoAttachMatOptionDialog(IObjParam *ip, AttachMatDlgUser *user);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\inode.h ===
/**********************************************************************
 *<
	FILE: inode.h

	DESCRIPTION:

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __INODE__H
#define __INODE__H

class ObjectState;
class Object;
class Control;
class ScaleValue;
class Mtl;
class RenderData;
class View;
class IDerivedObject;

// Transform modes -- passed to Move/Rotate/Scale
#define  PIV_NONE				0
#define  PIV_PIVOT_ONLY			1
#define  PIV_OBJECT_ONLY		2
#define  PIV_HIERARCHY_ONLY		3

// Node interface													   
class INode: public ReferenceTarget {
	public:
		// If this was a temporary INode (like an INodeTransformed) this will delete it.
		virtual void DisposeTemporary() {}

		// In the case of INodeTransformed, this gets a pointer to the real node.
		virtual INode *GetActualINode() {return this;}

		virtual TCHAR* 	GetName()=0;
		virtual	void	SetName(TCHAR *s)=0; 		
		
		// Get/Set node's transform ( without object-offset or WSM affect)
		virtual Matrix3	GetNodeTM(TimeValue t, Interval* valid=NULL)=0;
		virtual void 	SetNodeTM(TimeValue t, Matrix3& tm)=0;
		
		// Invalidate node's caches
		virtual void InvalidateTreeTM()=0;
		virtual void InvalidateTM()=0;
		virtual void InvalidateWS()=0;

		// Get object's transform (including object-offset)
		// and also the WSM affect when appropriate )
		// This is used inside object Display and HitTest routines
		virtual Matrix3 GetObjectTM(TimeValue time, Interval* valid=NULL)=0;

		// Get object's transform including object-offset but not WSM affect
		virtual Matrix3 GetObjTMBeforeWSM(TimeValue time, Interval* valid=NULL)=0;

		// Get object's transform including object-offset and WSM affect
		virtual Matrix3 GetObjTMAfterWSM(TimeValue time, Interval* valid=NULL)=0;

		// evaluate the State the object after offset and WSM's applied		
		// if evalHidden is FALSE and the node is hidden the pipeline will not
		// actually be evaluated (however the TM will).
		virtual	const ObjectState& EvalWorldState(TimeValue time,BOOL evalHidden=TRUE)=0;	

		// Hierarchy manipulation
		virtual INode* 	GetParentNode()=0;
		virtual void 	AttachChild(INode* node, int keepPos=1)=0; // make node a child of this one
		virtual	void 	Detach(TimeValue t, int keepPos=1)=0;  	  // detach node
		virtual int 	NumberOfChildren()=0;
		virtual INode* 	GetChildNode(int i)=0;
		// This will delete a node, handle removing from the hierarchy, and also handle Undo.		
		virtual void Delete(TimeValue t, int keepChildPosition) {} 

		// display attributes
		virtual void	Hide(BOOL onOff)=0;			// set node's hide bit
		virtual int		IsHidden(DWORD hflags=0,BOOL forRenderer=FALSE) {return 0;}
		virtual int		IsNodeHidden(BOOL forRenderer=FALSE) {return 0;}			// is node hidden in *any* way.
		virtual void	Freeze(BOOL onOff)=0;		// stop node from being pickable
		virtual int		IsFrozen()=0;
		virtual void	XRayMtl(BOOL onOff)=0;		// use x-ray material on node
		virtual int		HasXRayMtl()=0;
		virtual void	IgnoreExtents(BOOL onOff)=0;// ignore this node during zoom extents
		virtual int		GetIgnoreExtents()=0;
		virtual void	BoxMode(BOOL onOff)=0;		// display node with a bounding box
		virtual int		GetBoxMode()=0;
		virtual void	AllEdges(BOOL onOff)=0;		// display all edges, including "hidden" ones
		virtual int		GetAllEdges()=0;
		virtual void	BackCull(BOOL onOff)=0;		// backcull display toggle
		virtual int		GetBackCull()=0;
		virtual void 	SetCastShadows(BOOL onOff)=0; 
		virtual int		CastShadows()=0;
		virtual void 	SetRcvShadows(BOOL onOff)=0;
		virtual int		RcvShadows()=0;
		virtual void 	SetGenerateCaustics(BOOL onOff)	{}
		virtual int		GenerateCaustics()				{return 0;}
		virtual void 	SetRcvCaustics(BOOL onOff)		{}
		virtual int		RcvCaustics()					{return 0;}
		virtual void 	SetGenerateGlobalIllum(BOOL onOff)	{}
		virtual int		GenerateGlobalIllum()				{return 0;}
		virtual void 	SetRcvGlobalIllum(BOOL onOff)		{}
		virtual int		RcvGlobalIllum()					{return 0;}
		virtual void 	SetMotBlur(int kind)=0;	 // kind = 0: none, 1:object blur,  2: image  blur
		virtual int		MotBlur()=0;
		virtual float   GetImageBlurMultiplier(TimeValue t) { return 1.0f;}
		virtual void    SetImageBlurMultiplier(TimeValue t, float m){};
		virtual	void  	SetImageBlurMultController(Control *cont){}
		virtual	Control *GetImageBlurMultController() {return NULL; }

		// Object motion blur enable controller. This affects both object and image motion blur
		virtual BOOL GetMotBlurOnOff(TimeValue t) { return 1;  }
		virtual void  SetMotBlurOnOff(TimeValue t, BOOL m) { }
		virtual Control *GetMotBlurOnOffController() { return NULL;}
		virtual void SetMotBlurOnOffController(Control *cont) { }

		virtual void 	SetRenderable(BOOL onOff)=0;
		virtual int		Renderable()=0;
		virtual void    SetCVertMode(int onOff)		{}
		virtual int     GetCVertMode()				{return 0;}
		virtual void    SetShadeCVerts(int onOff)	{}
		virtual int     GetShadeCVerts()			{return 0;}
		virtual int		GetTrajectoryON() {return 0;}
		virtual void    SetTrajectoryON(BOOL onOff) {}

		// bone display attributes.
		virtual void 	ShowBone(int boneVis)=0;	// 0: off, 1: show bone, 2: show bone only
		virtual void	BoneAsLine(int onOff)=0; 	// display bone as simple line
		virtual BOOL	IsBoneShowing()=0;
		virtual BOOL	IsBoneOnly() { return 0; }  	// don't display node when displaying bone

		// used for hit-testing and selecting node and target as a single unit
		virtual void	SetTargetNodePair(int onOff) {}
		virtual int		GetTargetNodePair() { return 0; }

		// Access node's wire-frame color
		virtual DWORD 	GetWireColor()=0;
		virtual void 	SetWireColor(DWORD newcol)=0;

		// Test various flags
		virtual int 	IsRootNode()=0;
		virtual int 	Selected()=0;
		virtual int  	Dependent()=0;
		virtual int 	IsTarget()=0;
		virtual	void  	SetIsTarget(BOOL b)=0;

		// Node transform locks
		virtual BOOL GetTransformLock(int type, int axis)=0;
		virtual void SetTransformLock(int type, int axis, BOOL onOff)=0;

		// Get target node if any.
		virtual	INode* 	GetTarget()=0; 	// returns NULL if node has no target.
		virtual INode* 	GetLookatNode()=0; // if this is a target, this finds the node that looks at it.

		// This is just GetParent+GetNodeTM
		virtual Matrix3 GetParentTM(TimeValue t)=0;

		// This is just GetTarget+GetNodeTM
		virtual int 	GetTargetTM(TimeValue t, Matrix3& m)=0;

		// Object reference
		virtual Object* GetObjectRef()=0;	// skips over WSM's to the object
		virtual void 	SetObjectRef(Object *)=0;  // sets the object reference directly
		virtual Object* GetObjOrWSMRef()=0; // returns the object reference directly 

		// TM Controller
		virtual Control* GetTMController()=0;
		virtual void 	SetTMController(Control *m3cont)=0;

		// Visibility controller
		virtual Control *GetVisController()=0;
		virtual void    SetVisController(Control *cont)=0;
		virtual float   GetVisibility(TimeValue t,Interval *valid=NULL)=0;  // may be inherited
		virtual float   GetVisibility(TimeValue t,View &view,Interval *valid=NULL) {return GetVisibility(t,valid);}
		virtual void	SetVisibility(TimeValue t,float vis)=0;
		virtual float   GetLocalVisibility(TimeValue t,Interval *valid=NULL)=0; // not inherited
		virtual BOOL 	GetInheritVisibility()=0;
		virtual void 	SetInheritVisibility(BOOL onOff)=0;

		// Set/Get REnderOccluded property
		virtual void  SetRenderOccluded(BOOL onOff)=0;
		virtual BOOL  GetRenderOccluded()=0;

		// Renderer Materials
		virtual Mtl *GetMtl()=0;
		virtual void SetMtl(Mtl* matl)=0;

		// GraphicsWindow Materials
		virtual Material* Mtls()=0;   // Array  of GraphicsWindow Materials 
		virtual int 	NumMtls()=0;  // number of entries in Mtls

		// Object offset from node:
		virtual void 	SetObjOffsetPos(Point3 p)=0;
		virtual	Point3 	GetObjOffsetPos()=0;
		virtual	void 	SetObjOffsetRot(Quat q)=0;
		virtual	Quat 	GetObjOffsetRot()=0;
		virtual	void 	SetObjOffsetScale(ScaleValue sv)=0;
		virtual	ScaleValue GetObjOffsetScale()=0;
		
		// Misc.
		virtual void 	FlagForeground(TimeValue t,BOOL notify=TRUE)=0;
		virtual int 	IsActiveGrid()=0;

		// A place to hang temp data. Don't expect the data to stay around after you return control
		virtual void SetNodeLong(LONG l)=0;
		virtual LONG GetNodeLong()=0;

//		virtual void GetMaterial(Material &mtl)=0;  // Why do we need this?

		// Access render data
		virtual RenderData *GetRenderData()=0;
		virtual void SetRenderData(RenderData *rd)=0;

		//
		// Access user defined property text
		//
		// The first two functions access the entire buffer
		virtual void GetUserPropBuffer(TSTR &buf)=0;
		virtual void SetUserPropBuffer(const TSTR &buf)=0;

		// These get individual properties - return FALSE if the key is not found
		virtual BOOL GetUserPropString(const TSTR &key,TSTR &string)=0;
		virtual BOOL GetUserPropInt(const TSTR &key,int &val)=0;
		virtual BOOL GetUserPropFloat(const TSTR &key,float &val)=0;
		virtual BOOL GetUserPropBool(const TSTR &key,BOOL &b)=0;
		
		// These set individual properties - create the key if it doesn't exist
		virtual void SetUserPropString(const TSTR &key,const TSTR &string)=0;
		virtual void SetUserPropInt(const TSTR &key,int val)=0;
		virtual void SetUserPropFloat(const TSTR &key,float val)=0;
		virtual void SetUserPropBool(const TSTR &key,BOOL b)=0;
		
		// Just checks to see if a key exists
		virtual BOOL UserPropExists(const TSTR &key)=0;

		// G-Buffer ID's  (user settable)
		virtual ULONG GetGBufID()=0;
		virtual void SetGBufID(ULONG id)=0;

		// G-Buffer Render ID's (set by renderer)
		virtual UWORD GetRenderID() { return 0xffff; }
		virtual void SetRenderID(UWORD id) {}

		// Transform the node about a specified axis system.
		// Either the pivot point or the object or both can be transformed.
		// Also, the children can be counter transformed so they don't move.
		virtual void Move(TimeValue t, const Matrix3& tmAxis, const Point3& val, BOOL localOrigin=FALSE, BOOL affectKids=TRUE, int pivMode=PIV_NONE, BOOL ignoreLocks=FALSE)=0;
		virtual void Rotate(TimeValue t, const Matrix3& tmAxis, const AngAxis& val, BOOL localOrigin=FALSE, BOOL affectKids=TRUE, int pivMode=PIV_NONE, BOOL ignoreLocks=FALSE)=0;
		virtual void Rotate(TimeValue t, const Matrix3& tmAxis, const Quat& val, BOOL localOrigin=FALSE, BOOL affectKids=TRUE, int pivMode=PIV_NONE, BOOL ignoreLocks=FALSE)=0;
		virtual void Scale(TimeValue t, const Matrix3& tmAxis, const Point3& val, BOOL localOrigin=FALSE, BOOL affectKids=TRUE, int pivMode=PIV_NONE, BOOL ignoreLocks=FALSE)=0;

		virtual BOOL IsGroupMember()=0;
		virtual BOOL IsGroupHead()=0;
		virtual BOOL IsOpenGroupMember() {return 0; }
		virtual BOOL IsOpenGroupHead() {return 0; }

		virtual void SetGroupMember(BOOL b) {}
		virtual void SetGroupHead(BOOL b) {}
		virtual void SetGroupMemberOpen(BOOL b) {}
		virtual void SetGroupHeadOpen(BOOL b) {}

		// Some node IK params
		virtual float GetPosTaskWeight() {return 1.0f;}
		virtual float GetRotTaskWeight() {return 1.0f;}
		virtual void SetPosTaskWeight(float w) {}
		virtual void SetRotTaskWeight(float w) {}
		virtual BOOL GetTaskAxisState(int which,int axis) {return TRUE;} // which==0:pos  which==1:rot
		virtual void SetTaskAxisState(int which,int axis,BOOL onOff) {}
		virtual DWORD GetTaskAxisStateBits() {return 127;}		

		// Access to WSM Derived object. Note that there is at most one
		// WSM derived object per node. Calling CreateWSMDerivedObject()
		// will create a WSM derived object for the node if one doesn't 
		// already exist.
		virtual void CreateWSMDerivedObject() {}
		virtual IDerivedObject *GetWSMDerivedObject() {return NULL;}

		
		// Scene XRef related methods. These methods are only implemented by root nodes.
		// Scene XRefs are stored as complete scenes with root nodes where the XRef scene root
		// node is a child of the current scene's root node.
		virtual TSTR GetXRefFileName(int i) {return TSTR();}
		virtual void SetXRefFileName(int i,TCHAR *fname,BOOL reload) {}
		virtual int GetXRefFileCount() {return 0;}
		virtual BOOL AddNewXRefFile(TSTR &name, BOOL loadNow=TRUE) {return FALSE;}
		virtual BOOL DeleteXRefFile(int i) {return FALSE;} // removes scene xref
		virtual BOOL BindXRefFile(int i) {return FALSE;} // Deletes the xref after merging it into the scene
		virtual void DeleteAllXRefs() {} // Called when loading a new file, reseting or clearing the scene
		virtual BOOL ReloadXRef(int i) {return FALSE;}
		virtual void FlagXrefChanged(int i) {}
		virtual BOOL UpdateChangedXRefs(BOOL redraw=TRUE) {return FALSE;}
		virtual INode *GetXRefTree(int i) {return NULL;}
		virtual INode *GetXRefParent(int i) {return NULL;}
		virtual void SetXRefParent(int i, INode *par) {}
		virtual BOOL FindUnresolvedXRefs(Tab<TSTR*> &fnames) {return FALSE;}  // Returns TRUE if there are still unresolved refs
		virtual void AttemptToResolveUnresolvedXRefs() {} // Try to load any refs that are currently unresolved
		virtual DWORD GetXRefFlags(int i) {return 0;}
		virtual void SetXRefFlags(int i,DWORD flag,BOOL onOff) {}
		};		

// Xref flag bits
#define XREF_UPDATE_AUTO	(1<<0)
#define XREF_BOX_DISP		(1<<1)
#define XREF_HIDDEN			(1<<2)
#define XREF_DISABLED		(1<<3)
#define XREF_IGNORE_LIGHTS	(1<<4)
#define XREF_IGNORE_CAMERAS	(1<<5)
#define XREF_IGNORE_SHAPES	(1<<6)
#define XREF_IGNORE_HELPERS	(1<<7)
#define XREF_IGNORE_ANIM	(1<<8)
#define XREF_FILE_CHANGE	(1<<10)  // This bit is set when a change notification is sent indicating that the file may have changed. We don't know for sure if the file actually changed but the ref should be reloaded.
#define XREF_LOAD_ERROR		(1<<11)  // This bit will be set when a ref can't be resolved


// Transform lock types
#define INODE_LOCKPOS		0
#define INODE_LOCKROT		1
#define INODE_LOCKSCL		2

// Transform lock axis
#define INODE_LOCK_X		0
#define INODE_LOCK_Y		1
#define INODE_LOCK_Z		2

// Derive a class from this class, implementing the callback.
class ITreeEnumProc {
	public:
		virtual int callback( INode *node )=0;
	};

// Return values for the TreeEnum callback:
#define TREE_CONTINUE			0	// Continue enumerating
#define TREE_IGNORECHILDREN		1	// Don't enumerate children, but continue
#define TREE_ABORT				2	// Stop enumerating

// Node properties:
#define PROPID_PINNODE		PROPID_USER+1  	// Returns a pointer to the node this node is pinned to
#define PROPID_PRECEDENCE	PROPID_USER+2	// Returns an integer representing this node's precedence
#define PROPID_RELPOS		PROPID_USER+3	// Returns a pointer to the relative vector between the node and its pin
#define PROPID_RELROT		PROPID_USER+4	// Returns a pointer to the relative quaternion between the node and its pin



class INodeTransformed;

// INodeTransformed can be allocated on the stack, but if you need
// to create one dynamically, use these methods.
CoreExport void DeleteINodeTransformed(INodeTransformed *n);
CoreExport INodeTransformed *CreateINodeTransformed(INode *n,Matrix3 tm,BOOL dm=TRUE);

// This class provides a layer that will add in a transformation to the
// node's objectTM.
//
// Most methods pass through to the inode, except for the objectTM methods
// which pre-multiply in the given matrix.
//
class INodeTransformed : public INode {
	public:
		INode *node;
		Matrix3 tm;
		BOOL deleteMe;

		INodeTransformed(INode *n,Matrix3 tm,BOOL dm=TRUE) {node = n;this->tm = tm;deleteMe = dm;}
		
		void DisposeTemporary() {node->DisposeTemporary(); if (deleteMe) DeleteINodeTransformed(this);}
		INode *GetActualINode() {return node->GetActualINode();}
		
		TCHAR* 	GetName() {return node->GetName();}
		void	SetName(TCHAR *s) {node->SetName(s);}
		Matrix3	GetNodeTM(TimeValue t, Interval* valid=NULL) {return node->GetNodeTM(t,valid);}
		void 	SetNodeTM(TimeValue t, Matrix3& tm) {node->SetNodeTM(t,tm);}
		void InvalidateTreeTM() {node->InvalidateTreeTM();}
		void InvalidateTM() {node->InvalidateTM();}
		void InvalidateWS() {node->InvalidateWS();}
		Matrix3 GetObjectTM(TimeValue time, Interval* valid=NULL) {return tm*node->GetObjectTM(time,valid);}
		Matrix3 GetObjTMBeforeWSM(TimeValue time, Interval* valid=NULL) {return tm*node->GetObjTMBeforeWSM(time,valid);}
		Matrix3 GetObjTMAfterWSM(TimeValue time, Interval* valid=NULL) {return tm*node->GetObjTMAfterWSM(time,valid);}
		const ObjectState& EvalWorldState(TimeValue time,BOOL evalHidden=TRUE) {return node->EvalWorldState(time,evalHidden);}
		INode* 	GetParentNode() {return node->GetParentNode();}
		void 	AttachChild(INode* node, int keepPos=1) {node->AttachChild(node,keepPos);}
		void 	Detach(TimeValue t, int keepPos=1) {node->Detach(t,keepPos);}
		int 	NumberOfChildren() {return node->NumberOfChildren();}
		INode* 	GetChildNode(int i) {return node->GetChildNode(i);}
		void    Delete(TimeValue t, int keepChildPosition) { node->Delete(t,keepChildPosition); } 
		void	Hide(BOOL onOff) {node->Hide(onOff);}
		int		IsHidden(DWORD hflags=0,BOOL forRenderer=FALSE) {return node->IsHidden(hflags,forRenderer);}
		int		IsNodeHidden(BOOL forRenderer=FALSE) { return node->IsNodeHidden(forRenderer); }
		void	Freeze(BOOL onOff) {node->Freeze(onOff);}
		int		IsFrozen() {return node->IsFrozen();}
		void	XRayMtl(BOOL onOff) {node->XRayMtl(onOff);}
		int		HasXRayMtl() {return node->HasXRayMtl();}
		void	IgnoreExtents(BOOL onOff) {node->IgnoreExtents(onOff);}
		int		GetIgnoreExtents() {return node->GetIgnoreExtents();}
		void	BoxMode(BOOL onOff) {node->BoxMode(onOff);}
		int		GetBoxMode() {return node->GetBoxMode();}
		void	AllEdges(BOOL onOff) {node->AllEdges(onOff);}
		int		GetAllEdges() {return node->GetAllEdges();}
		void	BackCull(BOOL onOff) {node->BackCull(onOff);}
		int		GetBackCull() {return node->GetBackCull();}
		void 	SetCastShadows(BOOL onOff) { node->SetCastShadows(onOff); } 
		int		CastShadows() { return node->CastShadows(); }
		void 	SetRcvShadows(BOOL onOff) { node->SetRcvShadows(onOff); }
		int		RcvShadows() { return node->RcvShadows(); }
		void 	SetGenerateCaustics(BOOL onOff) { node->SetGenerateCaustics(onOff); } 
		int		GenerateCaustics() { return node->GenerateCaustics(); }
		void 	SetRcvCaustics(BOOL onOff) { node->SetRcvCaustics(onOff); }
		int		RcvCaustics() { return node->RcvCaustics(); }
		void 	SetGenerateGlobalIllum(BOOL onOff) { node->SetGenerateGlobalIllum(onOff); } 
		int		GenerateGlobalIllum() { return node->GenerateGlobalIllum(); }
		void 	SetRcvGlobalIllum(BOOL onOff) { node->SetRcvGlobalIllum(onOff); }
		int		RcvGlobalIllum() { return node->RcvGlobalIllum(); }

		void 	SetMotBlur(BOOL onOff) { node->SetMotBlur(onOff); }
		int		MotBlur() { return node->MotBlur(); }

		float   GetImageBlurMultiplier(TimeValue t) { return node->GetImageBlurMultiplier(t);}
		void    SetImageBlurMultiplier(TimeValue t, float m) {node->SetImageBlurMultiplier(t,m); };
		void  	SetImageBlurMultController(Control *cont){ node->SetImageBlurMultController(cont); }
		Control *GetImageBlurMultController() {return node->GetImageBlurMultController(); }

		// Object motion blur enable controller. This affects only object motion blur
		BOOL GetMotBlurOnOff(TimeValue t) { return node->GetMotBlurOnOff(t); }
		void  SetMotBlurOnOff(TimeValue t, BOOL m) { node->SetMotBlurOnOff(t,m); }
		Control *GetMotBlurOnOffController() { return node->GetMotBlurOnOffController();}
		void SetMotBlurOnOffController(Control *cont) { node->SetMotBlurOnOffController(cont);}

		void 	SetRenderable(BOOL onOff) { node->SetRenderable(onOff); }
		int		Renderable() { return node->Renderable(); }
		void 	ShowBone(int boneVis) {node->ShowBone(boneVis);}
		void	BoneAsLine(int onOff) {node->BoneAsLine(onOff);}
		BOOL	IsBoneShowing() {return node->IsBoneShowing();}
		BOOL	IsBoneOnly() { return node->IsBoneOnly(); }
		DWORD 	GetWireColor() {return node->GetWireColor();}
		void 	SetWireColor(DWORD newcol) {node->SetWireColor(newcol);}
		int 	IsRootNode() {return node->IsRootNode();}
		int 	Selected() {return node->Selected();}
		int  	Dependent() {return node->Dependent();}
		int 	IsTarget() {return node->IsTarget();}
		void  	SetIsTarget(BOOL b) { node->SetIsTarget(b);}
		BOOL 	GetTransformLock(int type, int axis) {return node->GetTransformLock(type,axis);}
		void 	SetTransformLock(int type, int axis, BOOL onOff) {node->SetTransformLock(type,axis,onOff);}
		INode* 	GetTarget() {return node->GetTarget();}
		INode* 	GetLookatNode() {return node->GetLookatNode();}
		Matrix3 GetParentTM(TimeValue t) {return node->GetParentTM(t);}
		int 	GetTargetTM(TimeValue t, Matrix3& m) {return node->GetTargetTM(t,m);}
		Object* GetObjectRef() {return node->GetObjectRef();}
		void 	SetObjectRef(Object *o) {node->SetObjectRef(o);}
		Object* GetObjOrWSMRef() { return node->GetObjOrWSMRef();}  
		Control* GetTMController() {return node->GetTMController();}
		void 	SetTMController(Control *m3cont) {node->SetTMController(m3cont);}		
		Control *GetVisController() {return node->GetVisController();}
		void    SetVisController(Control *cont) {node->SetVisController(cont);}
		float   GetVisibility(TimeValue t,Interval *valid=NULL) {return node->GetVisibility(t,valid);}
		void	SetVisibility(TimeValue t,float vis) { node->SetVisibility(t,vis); }
		float   GetLocalVisibility(TimeValue t,Interval *valid) { return node->GetLocalVisibility(t,valid); }
		BOOL 	GetInheritVisibility() { return node->GetInheritVisibility(); }
		void 	SetInheritVisibility(BOOL onOff) { node->SetInheritVisibility(onOff); }

		virtual void  SetRenderOccluded(BOOL onOff) { node->SetRenderOccluded(onOff); }
		virtual BOOL  GetRenderOccluded(){ return node->GetRenderOccluded(); }
		
		Mtl *GetMtl() { return node->GetMtl(); }
		void SetMtl(Mtl* matl) { node->SetMtl(matl); }

		Material* Mtls() { return node->Mtls(); }    
		int 	NumMtls() { return node->NumMtls(); }

		RenderData *GetRenderData() {return node->GetRenderData();}
		void SetRenderData(RenderData *rd) {node->SetRenderData(rd);}

		void 	SetObjOffsetPos(Point3 p) {node->SetObjOffsetPos(p);}
		Point3 	GetObjOffsetPos() {return node->GetObjOffsetPos();}
		void 	SetObjOffsetRot(Quat q) {node->SetObjOffsetRot(q);}
		Quat 	GetObjOffsetRot() {return node->GetObjOffsetRot();}		
		void 	FlagForeground(TimeValue t,BOOL notify=TRUE) {node->FlagForeground(t,notify);}
		int 	IsActiveGrid() {return node->IsActiveGrid();}
		void SetNodeLong(LONG l) {node->SetNodeLong(l);}
		LONG GetNodeLong() {return node->GetNodeLong();}

		void GetUserPropBuffer(TSTR &buf) {node->GetUserPropBuffer(buf);}
		void SetUserPropBuffer(const TSTR &buf) {node->SetUserPropBuffer(buf);}
		BOOL GetUserPropString(const TSTR &key,TSTR &string) {return node->GetUserPropString(key,string);}
		BOOL GetUserPropInt(const TSTR &key,int &val) {return node->GetUserPropInt(key,val);}
		BOOL GetUserPropFloat(const TSTR &key,float &val) {return node->GetUserPropFloat(key,val);}
		BOOL GetUserPropBool(const TSTR &key,BOOL &b) {return node->GetUserPropBool(key,b);}
		void SetUserPropString(const TSTR &key,const TSTR &string) {node->SetUserPropString(key,string);}
		void SetUserPropInt(const TSTR &key,int val) {node->SetUserPropInt(key,val);}
		void SetUserPropFloat(const TSTR &key,float val) {node->SetUserPropFloat(key,val);}
		void SetUserPropBool(const TSTR &key,BOOL b) {node->SetUserPropBool(key,b);}
		BOOL UserPropExists(const TSTR &key) {return node->UserPropExists(key);}
		ULONG GetGBufID() { return node->GetGBufID(); }
		void SetGBufID(ULONG id) { node->SetGBufID(id); }

		UWORD GetRenderID() { return node->GetRenderID(); }
		void SetRenderID(UWORD id) { node->SetRenderID(id); }

		CoreExport void 	SetObjOffsetScale(ScaleValue sv);
		CoreExport ScaleValue GetObjOffsetScale();

		void Move(TimeValue t, const Matrix3& tmAxis, const Point3& val, BOOL localOrigin=FALSE, BOOL affectKids=TRUE, int pivMode=PIV_NONE, BOOL ignoreLocks=FALSE) {node->Move(t,tmAxis,val,localOrigin,pivMode,ignoreLocks);}
		void Rotate(TimeValue t, const Matrix3& tmAxis, const AngAxis& val, BOOL localOrigin=FALSE, BOOL affectKids=TRUE, int pivMode=PIV_NONE, BOOL ignoreLocks=FALSE) {node->Rotate(t,tmAxis,val,localOrigin,pivMode,ignoreLocks);}
		void Rotate(TimeValue t, const Matrix3& tmAxis, const Quat& val, BOOL localOrigin=FALSE, BOOL affectKids=TRUE, int pivMode=PIV_NONE, BOOL ignoreLocks=FALSE) {node->Rotate(t,tmAxis,val,localOrigin,pivMode,ignoreLocks);}
		void Scale(TimeValue t, const Matrix3& tmAxis, const Point3& val, BOOL localOrigin=FALSE, BOOL affectKids=TRUE, int pivMode=PIV_NONE, BOOL ignoreLocks=FALSE) {node->Scale(t,tmAxis,val,localOrigin,pivMode,ignoreLocks);}

		BOOL IsGroupMember() {return node->IsGroupMember();}
		BOOL IsGroupHead() { return node->IsGroupHead();}
		BOOL IsOpenGroupMember(){return node->IsOpenGroupMember();}
		BOOL IsOpenGroupHead(){return node->IsOpenGroupHead();}

		void SetGroupMember(BOOL b) { node->SetGroupMember(b); }
		void SetGroupHead(BOOL b) { node->SetGroupHead(b); }
		void SetGroupMemberOpen(BOOL b) { node->SetGroupMemberOpen(b); }
		void SetGroupHeadOpen(BOOL b) { node->SetGroupHeadOpen(b); }

		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	         PartID& partID,  RefMessage message) {return REF_SUCCEED;}
	};


#endif //__INODE__H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\ILayer.h ===
/**********************************************************************
 *<
	FILE: ILayer.h

	DESCRIPTION: Declaration of the ILayer interface

	CREATED BY:	Peter Sauerbrei

	HISTORY: Created 19 October 1998

 *>	Copyright (c) 1998-99, All Rights Reserved.
 **********************************************************************/

#pragma once
#ifndef __ILAYER_H__
#define __ILAYER_H__
#include <maxtypes.h>

class LayerProperty : public ReferenceTarget
{
private: 
	int m_id;
	TSTR m_name;

public:
	LayerProperty() : m_id(-1), m_name("") {}
	LayerProperty(const TSTR & name, int id) : m_id(id), m_name(name) {}
	virtual ~LayerProperty() {}

	// child methods
	virtual void SetProperty(const int d) = 0;
	virtual void SetProperty(const float d) = 0;
	virtual void SetProperty(const Point3 & d) = 0;
	virtual void SetProperty(const TSTR & d) = 0;
	virtual void SetProperty(void * d) = 0;
	virtual bool GetProperty(int & i) const = 0;
	virtual bool GetProperty(float & f) const = 0;
	virtual bool GetProperty(Point3 & p) const = 0;
	virtual bool GetProperty(TSTR & n) const = 0;
	virtual bool GetProperty(void * v) const = 0;

	// local methods
	int GetID() const { return m_id; }
	void SetID(int id) { m_id = id; }
	TSTR GetName() const { return m_name; }
	void SetName(const TSTR & name) { m_name = name; }
};

class ILayer : public ReferenceTarget
{
public:
	static const SClass_ID kLayerSuperClassID;

	// from Animatable
	SClass_ID SuperClassID() { return kLayerSuperClassID; }

	// from ILayerRecord
	virtual bool AddToLayer(INode * rtarg) = 0;
	virtual bool DeleteFromLayer(INode * rtarg) = 0;
	virtual void SetName(const TSTR & name) = 0;
	virtual TSTR GetName() const = 0;		// user must delete the string
	virtual void SetWireColor(DWORD newcol) = 0;
	virtual DWORD GetWireColor() const = 0;
	virtual void Hide(bool onOff) = 0;
	virtual bool IsHidden() const = 0;
	virtual void Freeze(bool onOff) = 0;
	virtual bool IsFrozen() const = 0;
	virtual void SetRenderable(bool onOff) = 0;
	virtual bool Renderable() const = 0;
	virtual void XRayMtl(bool onOff) = 0;
	virtual bool HasXRayMtl() const = 0;
	virtual void IgnoreExtents(bool onOff) = 0;
	virtual bool GetIgnoreExtents() const = 0;
	virtual void BoxMode(bool onOff) = 0;
	virtual bool GetBoxMode() const = 0;
	virtual void AllEdges(bool onOff) = 0;
	virtual bool GetAllEdges() const = 0;
	virtual void VertTicks(bool onOff) = 0;
	virtual bool GetVertTicks() const = 0;
	virtual void BackCull(bool onOff) = 0;
	virtual bool GetBackCull() const = 0;
	virtual void SetCVertMode(bool onOff) = 0;
	virtual bool GetCVertMode() const = 0;
	virtual void SetShadeCVerts(bool onOff) = 0;
	virtual bool GetShadeCVerts() const = 0;
	virtual void SetCastShadows(bool onOff) = 0;
	virtual bool CastShadows() const = 0;
	virtual void SetRcvShadows(bool onOff) = 0;
	virtual bool RcvShadows() const = 0;
	virtual void SetMotBlur(int kind) = 0;
	virtual int MotBlur() const = 0;
	virtual int GetRenderFlags() const = 0;
	virtual void SetRenderFlags(int flags) = 0;
	virtual int GetDisplayFlags() const = 0;
	virtual int AddProperty(LayerProperty & lprop) = 0;
	virtual int SetProperty(LayerProperty & lprop) = 0;
	virtual int GetProperty(LayerProperty & lprop) const = 0;
	virtual bool Used(void) const = 0;
	virtual bool GetFlag(int mask) const = 0;
	virtual bool GetFlag2(int mask) const = 0;
	virtual void UpdateSelectionSet(void) = 0;
#ifdef DESIGN_VER
	virtual void SetInheritVisibility(bool onOff) = 0;
	virtual bool GetInheritVisibility() const = 0;
	virtual void Trajectory(bool onOff, bool temp = false) = 0;
	virtual bool GetTrajectory() const = 0;
	virtual void SetDisplayByLayer(BOOL onOff, INode *) = 0;
	virtual void SetRenderByLayer(BOOL onOff, INode *) = 0;
	virtual void SetMotionByLayer(BOOL onOff, INode *) = 0;
	virtual void SelectObjects(void) = 0;
	virtual void SetVisibility(TimeValue t, float vis) = 0;
	virtual float GetVisibility(TimeValue t,Interval *valid=NULL) = 0;
	virtual float GetVisibility(TimeValue t,View & view, Interval *valid=NULL) = 0;
	virtual float GetImageBlurMultiplier(TimeValue t) = 0;
	virtual void  SetImageBlurMultiplier(TimeValue t, float m) = 0;
	virtual bool GetMotBlurOnOff(TimeValue t) = 0;
	virtual void  SetMotBlurOnOff(TimeValue t, bool m) = 0;
	virtual bool IsHiddenByVisControl() = 0;
	virtual float GetLocalVisibility(TimeValue t,Interval *valid) = 0;
#endif
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\interpik.h ===
/**********************************************************************
 *<
	FILE: iterpik.h

	DESCRIPTION:  Implements IK related methods for interp controllers

	CREATED BY: Rolf Berteig

	HISTORY: created 6/19/95

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __INTERPIK_H__
#define __INTERPIK_H__


#define PROPID_INTERPUI		(PROPID_USER+1)
#define PROPID_JOINTPARAMS	(PROPID_USER+2)
#define PROPID_KEYINFO		(PROPID_USER+3)

// Flags for JointParams
#define JNT_XACTIVE		(1<<0)
#define JNT_YACTIVE		(1<<1)
#define JNT_ZACTIVE		(1<<2)
#define JNT_XLIMITED	(1<<3)
#define JNT_YLIMITED	(1<<4)
#define JNT_ZLIMITED	(1<<5)
#define JNT_XEASE		(1<<6)
#define JNT_YEASE		(1<<7)
#define JNT_ZEASE		(1<<8)
#define JNT_XSPRING		(1<<9)
#define JNT_YSPRING		(1<<10)
#define JNT_ZSPRING		(1<<11)

#define JP_HELD			(1<<27)
#define JNT_LIMITEXACT	(1<<28)
#define JNT_ROLLOPEN	(1<<29)
#define JNT_ROT			(1<<30) 
#define JNT_POS			(1<<31)


class InterpCtrlUI : public AnimProperty {
	public:
		HWND hParams;
		IObjParam *ip;
		Control *cont;
		
		InterpCtrlUI(HWND h,IObjParam *i,Control *c) 
			{hParams=h;ip=i;cont=c;}
		
		~InterpCtrlUI() {}
		DWORD ID() {return PROPID_INTERPUI;}		
	};

class InterpKeyInfo : public AnimProperty {
	public:
		DWORD ID() {return PROPID_KEYINFO;}
		virtual ~InterpKeyInfo() {}
	};


// IK Joint parameters
class JointParams : public AnimProperty {
	public:
		float *min, *max;
		float *damping;
		float *spring;
		float *stens;
		float scale;
		DWORD flags;
		int dofs;

		CoreExport JointParams(DWORD type=JNT_POS,int dofs=3,float s=1.0f);
		CoreExport JointParams(const JointParams &j);
		CoreExport ~JointParams();
		DWORD ID() {return PROPID_JOINTPARAMS;}

		CoreExport JointParams&  operator=(JointParams& j);

		// Returns TRUE if the curent state is the default.
		CoreExport BOOL IsDefault();
		
		CoreExport IOResult Save(ISave *isave);
		CoreExport IOResult Load(ILoad *iload);

		// Applies contraints to the given delta based on parameters and the current value v.
		CoreExport float ConstrainInc(int index,float v,float delta);		
		
		// Access bits
		BOOL Active(int i) {return (flags&(JNT_XACTIVE<<i))?TRUE:FALSE;}
		BOOL Limited(int i) {return (flags&(JNT_XLIMITED<<i))?TRUE:FALSE;}
		BOOL Ease(int i) {return (flags&(JNT_XEASE<<i))?TRUE:FALSE;}
		BOOL Spring(int i) {return (flags&(JNT_XSPRING<<i))?TRUE:FALSE;}
		DWORD Type() {return flags & (JNT_POS|JNT_ROT);}
		BOOL RollupOpen() {return (flags&JNT_ROLLOPEN)?TRUE:FALSE;}
		void SetActive(int i,BOOL s) {if (s) flags|=(JNT_XACTIVE<<i); else flags&=~(JNT_XACTIVE<<i);}
		void SetLimited(int i,BOOL s) {if (s) flags|=(JNT_XLIMITED<<i); else flags&=~(JNT_XLIMITED<<i);}
		void SetEase(int i,BOOL s) {if (s) flags|=(JNT_XEASE<<i); else flags&=~(JNT_XEASE<<i);}
		void SetSpring(int i,BOOL s) {if (s) flags|=(JNT_XSPRING<<i); else flags&=~(JNT_XSPRING<<i);}
		void SetType(DWORD type) {flags&=~(JNT_POS|JNT_ROT);flags|=type;}
		void SetRollOpen(BOOL open) {if (open) flags|=JNT_ROLLOPEN; else flags&= ~JNT_ROLLOPEN;}

		// This is the interactive adjustment of limits
		CoreExport virtual void SpinnerChange(InterpCtrlUI *ui,WORD id,ISpinnerControl *spin,BOOL interactive);

		// These methods manage the joint parameters dialog.
		CoreExport void InitDialog(InterpCtrlUI *ui);
		CoreExport void EndDialog(InterpCtrlUI *ui,BOOL dontDel=FALSE);		
		CoreExport void SpinnerDown(InterpCtrlUI *ui,WORD id,ISpinnerControl *spin);
		CoreExport void SpinnerUp(InterpCtrlUI *ui,WORD id,ISpinnerControl *spin,BOOL accept);
		CoreExport void Command(InterpCtrlUI *ui,WORD notify, WORD id, HWND hCtrl);
		CoreExport void EnableDisable(InterpCtrlUI *ui);

		CoreExport void MirrorConstraints(int axis);
	};

class JPLimitsRestore : public RestoreObj {
	public:
		JointParams *jp;
		float umin[6], umax[6], uspring[6];
		float rmin[6], rmax[6], rspring[6];
		
		JPLimitsRestore(JointParams *j) {
			jp = j;
			for (int i=0; i<jp->dofs; i++) {
				umin[i]    = jp->min[i];
				umax[i]    = jp->max[i];
				uspring[i] = jp->spring[i];
				}
			}
		void Restore(int isUndo) {
			if (isUndo) {
				for (int i=0; i<jp->dofs; i++) {
					rmin[i]    = jp->min[i];
					rmax[i]    = jp->max[i];
					rspring[i] = jp->spring[i];
					}
				}
			for (int i=0; i<jp->dofs; i++) {
				jp->min[i]    = umin[i];
				jp->max[i]    = umax[i];
				jp->spring[i] = uspring[i];
				}			
			}
		void Redo() {
			for (int i=0; i<jp->dofs; i++) {
				jp->min[i]    = rmin[i];
				jp->max[i]    = rmax[i];
				jp->spring[i] = rspring[i];
				}			
			}
		void EndHold() {
			jp->flags &= ~JP_HELD;
			}
	};


// Just holds a couple of pointers.
class JointDlgData {
	public:
		InterpCtrlUI *ui;
		JointParams *jp;	
		JointDlgData(InterpCtrlUI *ui,JointParams *jp) {this->ui=ui;this->jp=jp;}
	};

// A window proc for handling joint parameters.
CoreExport BOOL CALLBACK JointParamDlgProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam);


// Handles the IK functions for all types of point3 and quat key frame controllers.
void QuatEnumIKParams(Control *cont,IKEnumCallback &callback);
BOOL QuatCompDeriv(Control *cont,TimeValue t,Matrix3& ptm,IKDeriv& derivs,DWORD flags);
float QuatIncIKParam(Control *cont,TimeValue t,int index,float delta);
CoreExport void QuatBeginIKParams(Control *cont,IObjParam *ip, ULONG flags,Animatable *prev);
void Point3EnumIKParams(Control *cont,IKEnumCallback &callback);
BOOL Point3CompDeriv(Control *cont,TimeValue t,Matrix3& ptm,IKDeriv& derivs,DWORD flags);
float Point3IncIKParam(Control *cont,TimeValue t,int index,float delta);
CoreExport void Point3BeginIKParams(Control *cont,IObjParam *ip, ULONG flags,Animatable *prev);

CoreExport BOOL CanCopyIKParams(Control *cont,int which);
CoreExport IKClipObject *CopyIKParams(Control *cont,int which);
CoreExport BOOL CanPasteIKParams(Control *cont,IKClipObject *co,int which);
CoreExport void PasteIKParams(Control *cont,IKClipObject *co,int which);

CoreExport void InitIKJointsPos(Control *cont,InitJointData *posData);
CoreExport void InitIKJointsRot(Control *cont,InitJointData *rotData);
CoreExport BOOL GetIKJointsPos(Control *cont,InitJointData *posData);
CoreExport BOOL GetIKJointsRot(Control *cont,InitJointData *rotData);
CoreExport void QuatMirrorIKConstraints(Control *cont,int axis,int which);

class StdIKClipObject : public IKClipObject {
	public:
		JointParams *jp;
		SClass_ID sid;
		Class_ID cid;
		
		StdIKClipObject(SClass_ID s,Class_ID c,JointParams *j) 
			{sid=s;cid=c;jp=j;}
		~StdIKClipObject() {delete jp;}
		SClass_ID 	SuperClassID() {return sid;}
		Class_ID	ClassID() {return cid;}		
		void DeleteThis() {delete this;}
	};


#define SPRINGTENS_UI	(50.0f)
#define DEF_SPRINGTENS	(0.02f)

#endif //__INTERPIK_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\iparamb.h ===
/**********************************************************************
 *<
	FILE: iparamb.h

	DESCRIPTION: Interface to Parameter blocks

	CREATED BY: Rolf Berteig

	HISTORY: created 1/25/95

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __IPARAMB__
#define __IPARAMB__

class UserType : public ReferenceTarget {
	public:		
		virtual ~UserType() {};
		virtual Control* CreateController()=0;
		virtual BOOL operator==( const UserType &t )=0;
		virtual UserType& operator=( const UserType &t )=0;		
	};


// Built in data types
enum ParamType {
	TYPE_FLOAT,
	TYPE_INT,
	TYPE_RGBA,
	TYPE_POINT3,
	TYPE_BOOL,

	// We can add types up to 32 total.
	TYPE_USER,
	};


// Chunk IDs for loading/saving
#define PB_COUNT_CHUNK			0x0001
#define PB_PARAM_CHUNK			0x0002
#define PB_INDEX_CHUNK			0x0003
#define PB_ANIMATABLE_CHUNK		0x0004
#define PB_VERSION_CHUNK		0x0005
#define PB_FLOAT_CHUNK			(TYPE_FLOAT + 0x100)
#define PB_INT_CHUNK			(TYPE_INT + 0x100)
#define PB_RGBA_CHUNK			(TYPE_RGBA + 0x100)
#define PB_POINT3_CHUNK			(TYPE_POINT3 + 0x100)
#define PB_BOOL_CHUNK			(TYPE_BOOL + 0x100)

#define PB_TYPE_CHUNK			0x0200
#define PB_TYPE_FLOAT_CHUNK		(PB_TYPE_CHUNK + TYPE_FLOAT)
#define PB_TYPE_INT_CHUNK		(PB_TYPE_CHUNK + TYPE_INT)
#define PB_TYPE_RGBA_CHUNK		(PB_TYPE_CHUNK + TYPE_RGBA)
#define PB_TYPE_POINT3_CHUNK	(PB_TYPE_CHUNK + TYPE_POINT3)
#define PB_TYPE_BOOL_CHUNK		(PB_TYPE_CHUNK + TYPE_BOOL)
#define PB_TYPE_USER_CHUNK		(PB_TYPE_CHUNK + TYPE_USER)


// When a client of a param block receives the REFMSG_GET_PARAM_NAME
// message, the partID field is set to point at one of these structures.
// The client should fill in the parameter name.
class GetParamName {
	public:
		TSTR name;
		int index;
		GetParamName(TSTR n,int i) { name=n;index=i; }
	};

// When a client of a param block receives the REFMSG_GET_PARAM_DIM
// message, the partID field is set to point at one of these structs.
// The client should set dim to point at it's dim descriptor.
class GetParamDim {
	public:
		ParamDimension *dim;
		int index;
		GetParamDim(int i) {index=i;dim=NULL;}
	};


// To create a parameter block, pass an array of these descriptors
// into the Create function. 
// Items in the parameter block can be refered to by index. The 
// index is derived from the order in which the descriptors appear
// in the array. If a parameter is a UserType, then a pointer to a 
// new UserType must be passed in. The parameter block will be responsible
// for deleting it when it is done with it.

class ParamBlockDesc {
	public:
		ParamType type;
		UserType *user;	
		BOOL animatable;
	};

// This version of the descriptor has an ID for each parameter.
class ParamBlockDescID {
	public:
		ParamType type;
		UserType *user;	
		BOOL animatable;
		DWORD id;
	};

class IParamBlock;

// This class represents a virtual array of parameters.
// Parameter blocks are one such implementation of this class, but
// it can also be useful to implement a class that abstracts non-
// parameter block variables. 
//
// The ParamMap class (see IParamM.h) uses this base class so that
// a ParamMap can be used to control UI for not only parameter blocks
// but variables stored outside of parameter blocks.
class IParamArray {
	public:
		virtual BOOL SetValue( int i, TimeValue t, float v ) {return FALSE;}
		virtual BOOL SetValue( int i, TimeValue t, int v ) {return FALSE;}
		virtual BOOL SetValue( int i, TimeValue t, Point3& v ) {return FALSE;}
		
		virtual BOOL GetValue( int i, TimeValue t, float &v, Interval &ivalid ) {return FALSE;}
		virtual BOOL GetValue( int i, TimeValue t, int &v, Interval &ivalid ) {return FALSE;}
		virtual BOOL GetValue( int i, TimeValue t, Point3 &v, Interval &ivalid ) {return FALSE;}
	
		// If it is a param block, this will get a pointer to it, otherwise it will return NULL.
		// Note that casting won't work because of multiple iheritance.
		virtual IParamBlock *GetParamBlock() {return NULL;}

		// Checks to see if a keyframe exists for the given parameter at the given time
		virtual BOOL KeyFrameAtTime(int i, TimeValue t) {return FALSE;}
	};
		 
class IParamBlock : 			
			public ReferenceTarget,
			public IParamArray {
	public:
		// Get's the super class of a parameters controller
		virtual SClass_ID GetAnimParamControlType(int anim)=0;

		// Get the param type
		virtual ParamType GetParameterType(int i)=0;

		// one for each known type
		virtual BOOL SetValue( int i, TimeValue t, float v )=0;
		virtual BOOL SetValue( int i, TimeValue t, int v )=0;		
		virtual BOOL SetValue( int i, TimeValue t, Point3& v )=0;		
		virtual BOOL SetValue( int i, TimeValue t, Color& v )=0; // uses Point3 controller
		
		// one for each known type
		virtual BOOL GetValue( int i, TimeValue t, float &v, Interval &ivalid )=0;
		virtual BOOL GetValue( int i, TimeValue t, int &v, Interval &ivalid )=0;
		virtual BOOL GetValue( int i, TimeValue t, Point3 &v, Interval &ivalid )=0;
		virtual BOOL GetValue( int i, TimeValue t, Color &v, Interval &ivalid )=0; // uses Point3 Controller

		virtual Color  GetColor(int i, TimeValue t=0)=0;										
		virtual Point3 GetPoint3(int i, TimeValue t=0)=0;										
		virtual int    GetInt(int i, TimeValue t=0)=0;										
		virtual float  GetFloat(int i, TimeValue t=0)=0;										

		virtual DWORD GetVersion()=0;
		virtual int NumParams()=0;

		virtual void RemoveController(int i)=0;
		virtual Control* GetController(int i)=0;
		virtual void SetController(int i, Control *c, BOOL preserveFrame0Value=TRUE)=0;
		virtual	void SwapControllers(int j, int k )=0;

		// Given the parameter index, what is the refNum?
		virtual	int GetRefNum(int paramNum)=0;

		// Given the parameter index what is the animNum?
		virtual	int GetAnimNum(int paramNum)=0;

		// Given the animNum what is the parameter index?
		virtual	int AnimNumToParamNum(int animNum)=0;

		// Inherited from IParamArray
		IParamBlock *GetParamBlock() {return this;}
				
		// This is only for use in a RescaleWorldUnits() implementation:
		// The param block implementation of RescaleWorldUnits scales only tracks
		// that have dimension type = stdWorldDim. If letting the param block handle 
		// the rescaling is not sufficient, call this on just the parameters you need to rescale.
		virtual void RescaleParam(int paramNum, float f)=0;

		// When a NotifyRefChanged is received from a param block, you 
		// can call this method to find out which parameter generated the notify.
		virtual int LastNotifyParamNum()=0;
		};


CoreExport IParamBlock *CreateParameterBlock(ParamBlockDesc *pdesc, int count);

// Note: version must fit into 16 bits. (5/20/97)
CoreExport IParamBlock *CreateParameterBlock(ParamBlockDescID *pdesc, int count, DWORD version);

// This creates a new parameter block, based on an existing parameter block of
// a later version. The new parameter block inherits any parameters from
// the old parameter block whose parameter IDs match.
CoreExport IParamBlock *UpdateParameterBlock(
	ParamBlockDescID *pdescOld, int oldCount, IParamBlock *oldPB,
	ParamBlockDescID *pdescNew, int newCount, DWORD newVersion);


// ----------------------------------------------------------
// A handy post load call back for fixing up parameter blocks.

// This structure describes a version of the parameter block.
class ParamVersionDesc {
	public:
		ParamBlockDescID *desc;
		int count;
		DWORD version;
		ParamVersionDesc(ParamBlockDescID *d,int c,int v) {desc=d;count=c;version=v;}
	};

// This will look up the version of the loaded callback and 
// fix it up so it matches the current version.
// NOTE: this thing deletes itself when it's done.
class ParamBlockPLCB : public PostLoadCallback {
	public:
		ParamVersionDesc *versions;
		int count;
		ParamVersionDesc *cur;		
		ReferenceTarget *targ;
		int pbRefNum;

		ParamBlockPLCB(
			ParamVersionDesc *v,int cnt,ParamVersionDesc *c,
			ReferenceTarget *t,int refNum)
			{versions=v;count=cnt;cur=c;targ=t;pbRefNum=refNum;}
		CoreExport void proc(ILoad *iload);
		int Priority() { return 0; }
		CoreExport int Execute(int cmd, ULONG arg1=0, ULONG arg2=0, ULONG arg3=0);
	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\iparamb2.h ===
/**********************************************************************
 *<
	FILE: iparamb2.h

	DESCRIPTION: Interface to Parameter blocks, 2nd edition

	CREATED BY: Rolf Berteig,
				John Wainwright, 2nd Ed.

	HISTORY: created 1/25/95
			 2nd Ed. 9/2/98

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __IPARAMB2__
#define __IPARAMB2__

#include <iparamb.h>
#include <iparamm.h>

#ifdef BLD_PARAMBLK2
#	define PB2Export __declspec( dllexport )
#else
#	define PB2Export __declspec( dllimport )
#endif

// parameters & blocks have permanent, position independent IDs
typedef short ParamID;
typedef short BlockID;

// per descriptor flags
#define P_CLASS_PARAMS		0x01		// this block holds class-level parameters, attached to ClassDesc
#define P_AUTO_CONSTRUCT	0x02		// instructs ClassDesc2 to autoconstuct this block & wire it in, requires pblock refno
#define	P_AUTO_UI			0x04		// this block support automatic UI rollout managements, requires rollout template res ID, etc.
#define	P_USE_PARAMS		0x08		// this block shares (exactly) the paramdefs from another descriptor, requires addr of source descriptor
#define	P_INCLUDE_PARAMS	0x10		// this block loads in a copy the paramdefs from another descriptor, requires addr of source descriptor
// per descriptor internal flags
#define	P_SCRIPTED_CLASS	0x20		// belongs to a scripted plug-in class
#define	P_TEMPORARY			0x40		// temporary descripted built during scene load to support schema migration

// per param constructor-specifiable flags
#define P_ANIMATABLE		0x000001	// animatable param
#define P_TRANSIENT			0x000002	// do not store actual value, PBAccessor-derived
#define P_NO_INIT			0x000004	// do not initialize
#define P_COMPUTED_NAME		0x000008	// call compute name fn to get name
#define P_UNUSED			0x000010	
#define P_RESET_DEFAULT		0x000020	// do not make create params sticky, reset to defaults always
#define P_SUBANIM			0x000040	// non-animatable reference param is still a subanim (makes it visible in TV)
#define P_TV_SHOW_ALL		0x000080	// for Tab<> animatables, show all entries even if no controller assigned
#define P_NO_REF			0x000100	// for reftarg params do not maintain Reference automatically
#define P_OWNERS_REF		0x000200	// reference param maintained by owner, specify owner's refno in a p_refno =>P_NO_REF
#define P_CAN_CONVERT		0x000400	// indicates the p_classid validator is is in a CanConvertoTo() call, rather than as exact class
#define P_SUBTEX			0x000800	// indicates texmap param is kept by owner using MtlBase::xSubTexmap protocol, give subtex # in p_subtexno
#define P_VARIABLE_SIZE		0x001000	// Tab<> param is variable size allowing scripted changes
#define P_NO_AUTO_LABELS	0x002000	// don't auto-set map & mtl names for associated button UI controls
#define P_SHORT_LABELS		0x004000	// use short auto names for associated button UI controls
#define P_READ_ONLY			0x008000	// this parameter is not assignable through MAXScript (allows try-and-buy 3rd-party plugins)

// per param internal flags
#define P_IS_REF			0x010000	// is a reftarget param
#define P_HAS_DEFAULT		0x020000	// has accessor function => a virtual param
#define P_HAS_CUR_DEFAULT	0x040000	// has a snapshotted current default value
#define P_HAS_MS_DEFAULT	0x080000	// has a MAXScript default
#define P_HAS_RANGE			0x100000	// has a range specified
#define P_HAS_CLASS_ID		0x200000	// a classID validator was given
#define P_HAS_SCLASS_ID		0x400000	// an SClassID validator was given
#define P_UI_ENABLED		0x800000	// indicates whether UI controls are initially enabled or diabled
#define P_HAS_PROMPT	   0x1000000	// has status line prompt string res ID for various picker buttons
#define P_HAS_CAPTION	   0x2000000	// has caption string res ID for open/save file dlgs
#define P_HAS_FILETYPES	   0x4000000	// has file types string res ID for open/save file dlgs (in MAXScript type: form)
#define P_HAS_REFNO		   0x8000000	// has refno supplied
#define P_HAS_SUBTEXNO	  0x10000000	// has subtexno supplied
#define P_INCLUDED		  0x20000000	// included from another descriptor, don't double free

// Parameter types
//    several of these types fold to the same underlying value type but provide
//    either a more complete description of the type or imply non-standard dimensions that are
//    automatically applied.

#define TYPE_TAB	0x800		// flags the type as a Tab<>

enum ParamType2 
{
 // TYPE_FLOAT,  // these are defined in original ParamType...
 // TYPE_INT,
 // TYPE_RGBA,
 // TYPE_POINT3,
 // TYPE_BOOL,
	TYPE_ANGLE = TYPE_BOOL + 1,
	TYPE_PCNT_FRAC,
	TYPE_WORLD,
	TYPE_STRING,
	TYPE_FILENAME,
	TYPE_HSV,
	TYPE_COLOR_CHANNEL,
	TYPE_TIMEVALUE,
	TYPE_RADIOBTN_INDEX,
	TYPE_MTL,
	TYPE_TEXMAP,
	TYPE_BITMAP,
	TYPE_INODE,
	TYPE_REFTARG,
	// Tab<>s of above
	TYPE_FLOAT_TAB = TYPE_FLOAT + TYPE_TAB,
	TYPE_INT_TAB,
	TYPE_RGBA_TAB,
	TYPE_POINT3_TAB,
	TYPE_BOOL_TAB,
	TYPE_ANGLE_TAB,
	TYPE_PCNT_FRAC_TAB,
	TYPE_WORLD_TAB,
	TYPE_STRING_TAB,
	TYPE_FILENAME_TAB,
	TYPE_HSV_TAB,
	TYPE_COLOR_CHANNEL_TAB,
	TYPE_TIMEVALUE_TAB,
	TYPE_RADIOBTN_INDEX_TAB,
	TYPE_MTL_TAB,
	TYPE_TEXMAP_TAB,
	TYPE_BITMAP_TAB,
	TYPE_INODE_TAB,
	TYPE_REFTARG_TAB,

	TYPE_MSFLOAT = 254,
	TYPE_UNSPECIFIED = 255,
};

#define base_type(t)	((ParamType2)((t) & ~TYPE_TAB))		// get base type ignoring if table
#define is_tab(t)		((t) & TYPE_TAB)					// is this param a table?
#define is_ref(d)		(((d).flags & (P_IS_REF | P_NO_REF | P_OWNERS_REF)) == P_IS_REF) // is this param a true local refmaker?
#define has_ui(d)		((d).ctrl_count > 0)				// this param has UI info defined
#define animatable_type(t) (base_type(t) == TYPE_INT || base_type(t) == TYPE_RGBA ||  base_type(t) == TYPE_HSV || base_type(t) == TYPE_POINT3 || \
	                        base_type(t) == TYPE_FLOAT || base_type(t) == TYPE_ANGLE || base_type(t) == TYPE_BOOL || base_type(t) == TYPE_PCNT_FRAC || \
	                        base_type(t) == TYPE_WORLD || base_type(t) == TYPE_COLOR_CHANNEL || base_type(t) == TYPE_TIMEVALUE)
#define reftarg_type(t) (base_type(t) == TYPE_MTL || base_type(t) == TYPE_TEXMAP || base_type(t) == TYPE_INODE || \
	                     base_type(t) == TYPE_REFTARG)
        
class ParamBlockDesc2;
class ClassDesc;
class PBBitmap;
class ParamMap2UserDlgProc;
class MSPluginClass;
class Value;
class Rollout;

// parameter value
#pragma pack(push,parameter_entry)
#pragma pack(1)

class Texmap;
class Mtl;
class INode;
class IAutoMParamDlg;
class IAutoSParamDlg;
class IAutoEParamDlg;
struct ParamDef;

typedef struct 
{
	union 
	{
		int					i;
		float				f;
		Point3*				p;
		TimeValue			t;
		TCHAR*				s;
		PBBitmap*			bm;
		ReferenceTarget*	r;
		Control*			control;  // replaces i,f,p or t values if animated
	};
	BYTE flags;
	PB2Export BOOL is_constant();
	PB2Export void Free(ParamType2 type);
} PB2Value;

#pragma pack(pop,parameter_entry)

// defines a parameter alias
typedef struct 
{
	TCHAR*	alias;
	ParamID	ID;
	int		tabIndex;
} ParamAlias;

// the interface to a ParamBlock2
class IParamBlock2 : public ReferenceTarget 
{
	public:
		virtual DWORD		GetVersion()=0;
		virtual int			NumParams()=0;
		virtual TCHAR*		GetLocalName()=0;
		// acquire & release the descriptor for this paramblock, get individual paramdefs
		virtual ParamBlockDesc2* GetDesc()=0;
		virtual void		ReleaseDesc()=0;
		virtual void		SetDesc(ParamBlockDesc2* desc)=0;
		virtual ParamDef&	GetParamDef(ParamID id)=0;
		// access block ID
		virtual BlockID		ID()=0;
		// index-to/from-ID conversion
		virtual int			IDtoIndex(ParamID id)=0;
		virtual ParamID		IndextoID(int i)=0;
		// get object that owns this block
		virtual ReferenceMaker* GetOwner()=0;

		// Get's the super class of a parameters controller
		virtual SClass_ID GetAnimParamControlType(int anim)=0;
		virtual SClass_ID GetParamControlType(ParamID id)=0;
		// Get the param type & name
		virtual ParamType2 GetParameterType(ParamID id)=0;
		virtual TSTR GetLocalName(ParamID id, int tabIndex = -1)=0; 

		// parameter accessors, one for each known type
		virtual BOOL SetValue(ParamID id, TimeValue t, float v, int tabIndex=0)=0;
		virtual BOOL SetValue(ParamID id, TimeValue t, int v, int tabIndex=0)=0;		
		virtual BOOL SetValue(ParamID id, TimeValue t, Point3& v, int tabIndex=0)=0;		
		virtual BOOL SetValue(ParamID id, TimeValue t, Color& v, int tabIndex=0)=0;  // uses Point3 controller
		virtual BOOL SetValue(ParamID id, TimeValue t, TCHAR* v, int tabIndex=0)=0;
		virtual BOOL SetValue(ParamID id, TimeValue t, Mtl*	v, int tabIndex=0)=0;
		virtual BOOL SetValue(ParamID id, TimeValue t, Texmap* v, int tabIndex=0)=0;
		virtual BOOL SetValue(ParamID id, TimeValue t, PBBitmap* v, int tabIndex=0)=0;
		virtual BOOL SetValue(ParamID id, TimeValue t, INode* v, int tabIndex=0)=0;
		virtual BOOL SetValue(ParamID id, TimeValue t, ReferenceTarget*	v, int tabIndex=0)=0;

		virtual BOOL GetValue(ParamID id, TimeValue t, float& v, Interval &ivalid, int tabIndex=0)=0;
		virtual BOOL GetValue(ParamID id, TimeValue t, int& v, Interval &ivalid, int tabIndex=0)=0;
		virtual BOOL GetValue(ParamID id, TimeValue t, Point3& v, Interval &ivalid, int tabIndex=0)=0;
		virtual BOOL GetValue(ParamID id, TimeValue t, Color& v, Interval &ivalid, int tabIndex=0)=0; // uses Point3 controller
		virtual BOOL GetValue(ParamID id, TimeValue t, TCHAR*& v, Interval &ivalid, int tabIndex=0)=0;
		virtual BOOL GetValue(ParamID id, TimeValue t, Mtl*& v, Interval &ivalid, int tabIndex=0)=0;
		virtual BOOL GetValue(ParamID id, TimeValue t, Texmap*& v, Interval &ivalid, int tabIndex=0)=0;
		virtual BOOL GetValue(ParamID id, TimeValue t, PBBitmap*& v, Interval &ivalid, int tabIndex=0)=0;
		virtual BOOL GetValue(ParamID id, TimeValue t, INode*& v, Interval &ivalid, int tabIndex=0)=0;
		virtual BOOL GetValue(ParamID id, TimeValue t, ReferenceTarget*& v, Interval &ivalid, int tabIndex=0)=0;

		// short cut getters for each type
		virtual Color		GetColor(ParamID id, TimeValue t=0, int tabIndex=0)=0;
		virtual Point3		GetPoint3(ParamID id, TimeValue t=0, int tabIndex=0)=0;
		virtual int			GetInt(ParamID id, TimeValue t=0, int tabIndex=0)=0;
		virtual float		GetFloat(ParamID id, TimeValue t=0, int tabIndex=0)=0;
		virtual TimeValue	GetTimeValue(ParamID id, TimeValue t=0, int tabIndex=0)=0;
		virtual TCHAR*		GetStr(ParamID id, TimeValue t=0, int tabIndex=0)=0;
		virtual Mtl*		GetMtl(ParamID id, TimeValue t=0, int tabIndex=0)=0;
		virtual Texmap*		GetTexmap(ParamID id, TimeValue t=0, int tabIndex=0)=0;
		virtual PBBitmap*	GetBitmap(ParamID id, TimeValue t=0, int tabIndex=0)=0;
		virtual INode*		GetINode(ParamID id, TimeValue t=0, int tabIndex=0)=0;
		virtual ReferenceTarget* GetReferenceTarget(ParamID id, TimeValue t=0, int tabIndex=0)=0;
		// and one to get the value in a PB2Value 
		virtual PB2Value& GetPB2Value(ParamID id, int tabIndex=0)=0;


		// parameter Tab management
		virtual int		Count(ParamID id)=0;
		virtual void	ZeroCount(ParamID id)=0;
		virtual void	SetCount(ParamID id, int n)=0;
		virtual int		Delete(ParamID id, int start,int num)=0; 
		virtual int		Resize(ParamID id, int num)=0;
		virtual void	Shrink(ParamID id)=0;
		virtual void	Sort(ParamID id, CompareFnc cmp)=0;
		// Tab Insert for each type
		virtual int		Insert(ParamID id, int at, int num, float* el)=0;
		virtual int		Insert(ParamID id, int at, int num, Point3** el)=0;
		virtual int		Insert(ParamID id, int at, int num, Color** el)=0;
		virtual int		Insert(ParamID id, int at, int num, TimeValue* el)=0;
		virtual int		Insert(ParamID id, int at, int num, TCHAR** vel)=0;
		virtual int		Insert(ParamID id, int at, int num, Mtl** el)=0;
		virtual int		Insert(ParamID id, int at, int num, Texmap** el)=0;
		virtual int		Insert(ParamID id, int at, int num, PBBitmap** el)=0;
		virtual int		Insert(ParamID id, int at, int num, INode** v)=0;
		virtual int		Insert(ParamID id, int at, int num, ReferenceTarget** el)=0;
		// Tab Insert for each type
		virtual int		Append(ParamID id, int num, float* el, int allocExtra=0)=0;
		virtual int		Append(ParamID id, int num, Point3** el, int allocExtra=0)=0;
		virtual int		Append(ParamID id, int num, Color** el, int allocExtra=0)=0;
		virtual int		Append(ParamID id, int num, TimeValue* el, int allocExtra=0)=0;
		virtual int		Append(ParamID id, int num, TCHAR** el, int allocExtra=0)=0;
		virtual int		Append(ParamID id, int num, Mtl** el, int allocExtra=0)=0;
		virtual int		Append(ParamID id, int num, Texmap** el, int allocExtra=0)=0;
		virtual int		Append(ParamID id, int num, PBBitmap** el, int allocExtra=0)=0;
		virtual int		Append(ParamID id, int num, INode** el, int allocExtra=0)=0;
		virtual int		Append(ParamID id, int num, ReferenceTarget** el, int allocExtra=0)=0;

		// Checks to see if a keyframe exists for the given parameter at the given time
		virtual BOOL KeyFrameAtTime(int i,      TimeValue t, int tabIndex=0) { return FALSE; }
		virtual BOOL KeyFrameAtTime(ParamID id, TimeValue t, int tabIndex=0) { return KeyFrameAtTime(IDtoIndex(id), t, tabIndex); }

		virtual void		RemoveController(int i, int tabIndex)=0;
		virtual Control*	GetController(ParamID id, int tabIndex=0)=0;
		virtual Control*	GetController(int i, int tabIndex=0)=0;
		virtual void		SetController(int i, int tabIndex, Control *c, BOOL preserveFrame0Value=TRUE)=0;
		virtual void		SetController(ParamID id, int tabIndex, Control *c, BOOL preserveFrame0Value=TRUE) { SetController(IDtoIndex(id), tabIndex, c, preserveFrame0Value); }
		virtual	void		SwapControllers(int i1, int tabIndex1, int i2, int tabIndex2)=0;

		// Given the param num & optional Tab<> index, what is the refNum?
		virtual	int GetRefNum(int i, int tabIndex=0)=0;
		// Given the param num & optional Tab<> index, what is the animated param controller refnum?
		virtual	int GetControllerRefNum(int i, int tabIndex=0)=0;

		// Given the parameter ID what is the animNum?
		virtual	int GetAnimNum(ParamID id, int tabIndex=0)=0;

		// Given the animNum what is the parameter index?
		virtual	int AnimNumToParamNum(int animNum, int& tabIndex)=0;

		virtual	ParamDimension* GetParamDimension(int subAnim)=0;

		// This is only for use in a RescaleWorldUnits() implementation:
		// The param block implementation of RescaleWorldUnits scales only tracks
		// that have dimension type = stdWorldDim. If letting the param block handle 
		// the rescaling is not sufficient, call this on just the parameters you need to rescale.
		virtual void RescaleParam(int paramNum, int tabIndex, float f)=0;

		// When a NotifyRefChanged is received from a param block, you 
		// can call this method to find out which parameter generated the notify.
		virtual ParamID LastNotifyParamID()=0;

		// allows owner to signal pblock when P_OWNER_REF params are deleted
		virtual void RefDeleted(ParamID id, int tabIndex=0)=0;

		// ParamMap2 access, 
		virtual void SetMap(IParamMap2* m)=0;
		virtual IParamMap2* GetMap()=0;
		// rollout state, normally used by ParamMap2 to automatically save & restore state 
		virtual void SetRolloutOpen(BOOL open)=0;
		virtual BOOL GetRolloutOpen()=0;
		virtual void SetRolloutScrollPos(int pos)=0;
		virtual int GetRolloutScrollPos()=0;

		// ParamDlg access, 
		virtual IAutoMParamDlg* GetMParamDlg()=0;
		virtual IAutoEParamDlg* GetEParamDlg()=0;

		// init parameters with MAXScript defaults
		virtual void InitMSParameters()=0;

		// alias maintenance
		virtual void DefineParamAlias(TCHAR* alias_name, ParamID id, int tabIndex=-1)=0;
		virtual ParamAlias* FindParamAlias(TCHAR* alias_name)=0;
		virtual TCHAR* FindParamAlias(ParamID id, int tabIndex=-1)=0;
		virtual void ClearParamAliases()=0;
		virtual int ParamAliasCount()=0;
		virtual ParamAlias* GetParamAlias(int i)=0;

		// set subanim number for given param
		virtual void SetSubAnimNum(ParamID id, int subAnimNum, int tabIndex=0)=0;
		virtual void ClearSubAnimMap()=0;

		// parameter value copying, copy src_id param from src block to id param in this block
		virtual void Assign(ParamID id, IParamBlock2* src, ParamID src_id)=0;

		// find the param ID & tabIndex for given ReferenceTarget(either as a subanim or reftarg parameter)
		virtual ParamID FindRefParam(ReferenceTarget* ref, int& tabIndex)=0;

		// reset params to default values
		virtual void ResetAll(BOOL updateUI = TRUE, BOOL callSetHandlers = TRUE)=0;
		virtual void Reset(ParamID id, int tabIndex=-1, BOOL updateUI = TRUE, BOOL callSetHandlers = TRUE)=0;
		// force a call to the PBAccessor Get()/Set() functions for a param or all params
		virtual void CallSet(ParamID id, int tabIndex=-1)=0;
		virtual void CallGet(ParamID id, int tabIndex=-1)=0;
		virtual void CallSets()=0;
		virtual void CallGets()=0;
		// get validity of all params in all paramblock
		virtual void GetValidity(TimeValue t, Interval &valid)=0;
};

// specialize this class to provide a custom SetValue() validator
// the Validate() function should return falsi if the given PB2Value is
// not valid
class PBValidator
{
public:
	virtual BOOL Validate(PB2Value& v) = 0;
	virtual void DeleteThis() { };
};

// specialize this class to provide 'virtual' parameter value accessor functions
class PBAccessor
{
public:
	// get into v
	virtual void Get(PB2Value& v, ReferenceMaker* owner, ParamID id, int tabIndex, TimeValue t, Interval &valid) { }    
	// set from v
	virtual void Set(PB2Value& v, ReferenceMaker* owner, ParamID id, int tabIndex, TimeValue t) { }						 
	// computed keyframe presence
	virtual BOOL KeyFrameAtTime(ReferenceMaker* owner, ParamID id, int tabIndex, TimeValue t) { return FALSE; }
	// computed parameter localized (subanim) name, only called if P_COMPUTED_NAME is flagged
	virtual TSTR GetLocalName(ReferenceMaker* owner, ParamID id, int tabIndex) { return _T(""); }
	// implement this if your PBAccessors are dynamically allocated
	virtual void DeleteThis() { };
};


#include <commdlg.h>
#include <vfw.h>
#include "bmmlib.h"

// a wrapper for bitmap/bitmapinfo pairs for holding bitmaps in a ParamBlock
class PBBitmap 
{
public:
	BitmapInfo	bi;
	Bitmap		*bm;
	PB2Export   PBBitmap(BitmapInfo	&bi);
				PBBitmap() { bm = NULL; }
	PB2Export  ~PBBitmap();

	PB2Export void		Load();
	PB2Export PBBitmap*	Clone();
};

// UI control types
#include <custcont.h>
enum ControlType2
{
 // TYPE_SPINNER,	 these are defined in original ControlType...
 // TYPE_RADIO,
 // TYPE_SINGLECHEKBOX,
 // TYPE_MULTICHEKBOX,
 // TYPE_COLORSWATCH,
	TYPE_EDITBOX = TYPE_COLORSWATCH + 1,
	TYPE_CHECKBUTTON,
	TYPE_PICKNODEBUTTON,
	TYPE_TEXMAPBUTTON,
	TYPE_MTLBUTTON,
	TYPE_BITMAPBUTTON,
	TYPE_FILEOPENBUTTON,
	TYPE_FILESAVEBUTTON,
	TYPE_INTLISTBOX,
	TYPE_FLOATLISTBOX,
	TYPE_STRINGLISTBOX,
	TYPE_NODELISTBOX,
	TYPE_MAPLISTBOX,
// begin - mjm 12.19.98
	TYPE_SLIDER,
// end - mjm 12.19.98
};

// param definition optional info tags
enum ParamTags
{
	// make them large -ve for crude validation
	p_default = -(1<<30),		// default value (for UI creation)
	p_ms_default,				// default value when constructed by scripts 
	p_range,					// allowable ranges, used in MS validation and spinner/slider setup
	p_ui,						// associated UI rollout control IDs, etc., 
	p_validator,				// validator object
	p_accessor,					// accessor object
	p_vals,						// radio button values in button order if non-ordinal
//	p_subanim_order,			// overrides sequential subanim order
	p_refno,					// specifies reference # in owner for this reference param, base refo in case of a Tab<>
	p_subtexno,					// for Texmap items in Mtls, defines the SubText index for this Texmap in the owner Mtl
	p_submtlno,					// for Mtl items in Mtls, defines the SubMtl index for this Mtl in the owner Mtl
	p_dim,						// supply dimension for this parameter
	p_classID,					// class ID validator for the various reftarg params (used by scripter, picknode filter, etc.)
	p_sclassID,					// superclass ID "     "     "     "      "
	p_enabled,					// associated UI controls are disabled by default
	p_enable_ctrls,				// for TYPE_BOOLs, lists which other params would be automatically UI enabled/disabled by this param
	p_prompt,					// status line prompt string res ID for various picker buttons
	p_caption,					// caption string res ID for open/save file dlgs
	p_init_file,				// initial filename for open/save file dlgs
	p_file_types,				// file types string res ID for open/save file dlgs (in MAXScript type: form)
	p_ctrl_ids,					// <used internally> sets the ctrl_id array for the parameter
	end,
};

// Parameter Block Descriptors
//    in PB2s, there is one ParamBlockDesc2 per entire PB, containing
//    the metadata for all the parameters in the PB.  All the PBs
//    mapped by this structure contain pointers back to it and the 
//    owning class's ClassDesc contains all the PB2Descs for PBs in
//    its objects

// HEY!  for the moment, all the possible optional parameters are in extensis.  If
//       this proves a big memory hog, we can institute some kind of streaming
//       scheme that packs used optionals into a single mem buffer.  The GetDesc() 
//       function should be used to access the PBD in all cases to allow this caching.
//       sizeof(ParmDef) ~ 70 bytes, so for 2500 params =~ 175K bytes
 
#pragma pack(push, parameter_def)
#pragma pack(1)

struct ParamDef 
{
//public:
	ParamID		ID;				// pos independent ID
	TCHAR*		int_name;		// fixed internal name
	ParamType2	type;			// parameter type
	int			flags;			// status flags
	// optional
	int			local_name;		// localized (subabim) name (string res id)
	ParamDimension* dim;		// parameter dimension
	PB2Value	def;			// default value
	PB2Value	ms_def;			// default value for MAXScript & MacroRecorder
	PB2Value	cur_def;		// current 'sticky' default value, used to maintain creation defaults within a session
	int			description;	// one sentence description (string res id)
	PB2Value	range_low;		// range values
	PB2Value	range_high;
	PBValidator* validator;		// validator object
	PBAccessor*	accessor;		// virtual param accessor object
	short		tab_size;		// initial table size
	short		ref_no;			// block-owner's refno for non-hosted ReferenceTargets
	short		subobj_no;		// block-owner's SubTex/SubMtl index for Texmap/Mtl parameters in Mtl owners
	Class_ID	class_ID;		// validator for reftargs
	SClass_ID	sclass_ID;		//    "       "     "
	// UI optional
	ControlType2 ctrl_type;		// type of UI control
	EditSpinnerType spin_type;	// spinner type if spinner
	int*		ctrl_IDs;		// array of control IDs for this control  (or ui element names if for scripted plugin)
	short		ctrl_count;		// number of controls
	int*		val_bits;		// radiobutton vals or bit numbers for int bits controlled by multiple checkboxes
	float		scale;			// display scale
// begin - mjm 12.19.98
	int			numSegs;		// slider segments
// end - mjm 12.19.98
	ParamID*	enable_ctrls;	// array of which other params ahave their UI ctrls automatically enabled by this param
	short		enable_count;	// count of enable control params
	int			prompt;			// status line prompt string res ID for various picker buttons
	int			caption;		// caption string res ID for open/save file dlgs
	TCHAR*		init_file;		// initial filename for open/save file dlgs
	int			file_types;		// file types string res ID for open/save file dlgs (in MAXScript type: form)

	PB2Export void DeleteThis();
};
		
#pragma pack(pop, parameter_def)

/* ----------------------- ClassDesc2 ------------------------------------*/

// 2nd Edition of ClassDesc with necessary extra stuff for ParamBlock2 support
class ClassDesc2 : public ClassDesc 
{
		Tab<ParamBlockDesc2*>	pbDescs;		// parameter block descriptors
		Tab<IParamMap2*>		paramMaps;		// any current param maps
		IAutoMParamDlg*			masterMDlg;		// master material/mapParamDlg if any
		IAutoEParamDlg*			masterEDlg;		// master EffectParamDlg if any
	public:
		PB2Export				ClassDesc2();
		PB2Export			   ~ClassDesc2();
		PB2Export void			ResetClassParams(BOOL fileReset);
		// ParamBlock2-related metadata
		// access parameter block descriptors for this class
		PB2Export int			NumParamBlockDescs() { return pbDescs.Count(); }
		PB2Export ParamBlockDesc2*	GetParamBlockDesc(int i) { return pbDescs[i]; }
		PB2Export ParamBlockDesc2*	GetParamBlockDescByID(BlockID id);
		PB2Export ParamBlockDesc2*	GetParamBlockDescByName(TCHAR* name);
		PB2Export void			AddParamBlockDesc(ParamBlockDesc2* pbd);
		PB2Export void			ClearParamBlockDescs() { pbDescs.ZeroCount(); }
		// automatic command panel UI management
		PB2Export void			BeginEditParams(IObjParam *ip, ReferenceMaker* obj, ULONG flags, Animatable *prev);
		PB2Export void			EndEditParams(IObjParam *ip, ReferenceMaker* obj, ULONG flags, Animatable *prev);
		PB2Export void			InvalidateUI();
		PB2Export void			InvalidateUI(ParamBlockDesc2* pbd);
		PB2Export void			InvalidateUI(ParamBlockDesc2* pbd, ParamID id, int tabIndex=-1); // nominated param
		// automatic ParamBlock construction
		PB2Export void			MakeAutoParamBlocks(ReferenceMaker* owner);
		// access automatically-maintained ParamMaps, by simple index or by associated ParamBlockDesc
		PB2Export int			NumParamMaps() { return paramMaps.Count(); }
		PB2Export IParamMap2*	GetParamMap(int i) { return paramMaps[i]; }
		PB2Export IParamMap2*	GetParamMap(ParamBlockDesc2* pbd);
		// maintain user dialog procs on automatically-maintained ParamMaps
		PB2Export void			SetUserDlgProc(ParamBlockDesc2* pbd, ParamMap2UserDlgProc* proc=NULL);
		PB2Export ParamMap2UserDlgProc*	GetUserDlgProc(ParamBlockDesc2* pbd);
		// 	automatic UI management 
		PB2Export IAutoMParamDlg* CreateParamDlgs(HWND hwMtlEdit, IMtlParams *imp, MtlBase* obj);
		PB2Export IAutoMParamDlg* CreateParamDlg(BlockID id, HWND hwMtlEdit, IMtlParams *imp, MtlBase* obj);
		PB2Export IAutoEParamDlg* CreateParamDialogs(IRendParams *ip, Effect* obj);
		PB2Export IAutoEParamDlg* CreateParamDialog(BlockID id, IRendParams *ip, Effect* obj);
		PB2Export void			MasterDlgDeleted(IAutoMParamDlg* dlg);
		PB2Export void			MasterDlgDeleted(IAutoEParamDlg* dlg);
		PB2Export IAutoMParamDlg* GetMParamDlg() { return masterMDlg; }
		PB2Export IAutoEParamDlg* GetEParamDlg() { return masterEDlg; }
		// restore any saved rollout state
		PB2Export void			RestoreRolloutState();
		// find last modified param in all blocks, same as on IParamBlock2, but scans all pb's in the object
		PB2Export ParamID		LastNotifyParamID(ReferenceMaker* owner, IParamBlock2*& pb);
		// reset all params of all known paramblocks to default values, update any UI
		PB2Export void			Reset(ReferenceMaker* owner, BOOL updateUI = TRUE, BOOL callSetHandlers = TRUE);
		// get validity of all params in all owner's paramblocks
		PB2Export void			GetValidity(ReferenceMaker* owner, TimeValue t, Interval &valid);
};

// use the constructors to build both static & dynamic descriptors
class ParamBlockDesc2
{
private:
	va_list		check_param(va_list ap, int id);
	va_list		scan_param(va_list ap, int id, ParamDef* p);
	va_list		scan_option(va_list ap, int tag, ParamDef* p, TCHAR* parm_name, int& optionnum);

public:
	ParamDef*	paramdefs;		// parameter definitions
	ClassDesc2*	cd;				// owning class
	TCHAR*		int_name;		// fixed internal name
	int			local_name;		// localized (subanim) name string resource ID
	BlockID		ID;				// ID
	USHORT		count;			// number of params in block
	ULONG		version;		// paramblock version
	BYTE		flags;			// block type flags
	// auto-construct optional
	int			ref_no;			// reference number for auto-constructed pb
	// auto-ui optional
	int			dlg_template;	// rollout dialog template resource
	int			title;			// rollout title
	int			test_flags;		// BeginEditParams test flags
	int			rollup_flags;	// add roolup page flags
	ParamMap2UserDlgProc* dlgProc;  // IParamMap2 dialog proc
	// scripted plug-in stuff if this belongs to a scripted plug-in class
	MSPluginClass* pc;			// the scripted class if non-NULL (gc-protected by the scripted plugin class)
	Rollout*	rollout;		// rollout if specified (gc-protected by the scripted plugin class)
	// class param optional
	IParamBlock2* class_params;	// pointer to class paramblock if CLASS_PARAM descriptor
		
	// constructors
			    ParamBlockDesc2();
	PB2Export   ParamBlockDesc2(BlockID ID, TCHAR* int_name, int local_name, ClassDesc2* cd, BYTE flags, ...); 
	PB2Export  ~ParamBlockDesc2();

	// building descriptors incrementally
	PB2Export void AddParam(ParamID id, ...);
	PB2Export void ReplaceParam(ParamID id, ...);
	PB2Export void DeleteParam(ParamID id);
	PB2Export void ParamOption(ParamID id, int option_tag, ...);
	// for delayed setting of ClassDesc2
	PB2Export void SetClassDesc(ClassDesc2* cd);

	// param metrics
	USHORT		Count() { return count; }
	DWORD		Version() { return version; }
	PB2Export int IDtoIndex(ParamID id);
	PB2Export int NameToIndex(TCHAR* name);
	ParamID		IndextoID(int i) { return paramdefs[i].ID; }
	ParamDef&	GetParamDef(ParamID id) { return paramdefs[IDtoIndex(id)]; }

	// parameter accessors for static class param blocks, these bounce off to the class paramblock
	BOOL SetValue(ParamID id, TimeValue t, float v, int tabIndex=0) { return class_params->SetValue(id, t, v, tabIndex); }
	BOOL SetValue(ParamID id, TimeValue t, int v, int tabIndex=0) { return class_params->SetValue(id, t, v, tabIndex); }		
	BOOL SetValue(ParamID id, TimeValue t, Point3& v, int tabIndex=0) { return class_params->SetValue(id, t, v, tabIndex); }		
	BOOL SetValue(ParamID id, TimeValue t, Color& v, int tabIndex=0) { return class_params->SetValue(id, t, v, tabIndex); }  // uses Point3 controller
	BOOL SetValue(ParamID id, TimeValue t, TCHAR* v, int tabIndex=0) { return class_params->SetValue(id, t, v, tabIndex); }
	BOOL SetValue(ParamID id, TimeValue t, Mtl*	v, int tabIndex=0) { return class_params->SetValue(id, t, v, tabIndex); }
	BOOL SetValue(ParamID id, TimeValue t, Texmap* v, int tabIndex=0) { return class_params->SetValue(id, t, v, tabIndex); }
	BOOL SetValue(ParamID id, TimeValue t, PBBitmap* v, int tabIndex=0) { return class_params->SetValue(id, t, v, tabIndex); }
	BOOL SetValue(ParamID id, TimeValue t, INode* v, int tabIndex=0) { return class_params->SetValue(id, t, v, tabIndex); }
	BOOL SetValue(ParamID id, TimeValue t, ReferenceTarget*	v, int tabIndex=0) { return class_params->SetValue(id, t, v, tabIndex); }

	BOOL GetValue(ParamID id, TimeValue t, float& v, Interval &ivalid, int tabIndex=0) { return class_params->GetValue(id, t, v, ivalid, tabIndex); }
	BOOL GetValue(ParamID id, TimeValue t, int& v, Interval &ivalid, int tabIndex=0) { return class_params->GetValue(id, t, v, ivalid, tabIndex); }
	BOOL GetValue(ParamID id, TimeValue t, Point3& v, Interval &ivalid, int tabIndex=0) { return class_params->GetValue(id, t, v, ivalid, tabIndex); }
	BOOL GetValue(ParamID id, TimeValue t, Color& v, Interval &ivalid, int tabIndex=0) { return class_params->GetValue(id, t, v, ivalid, tabIndex); }
	BOOL GetValue(ParamID id, TimeValue t, TCHAR*& v, Interval &ivalid, int tabIndex=0) { return class_params->GetValue(id, t, v, ivalid, tabIndex); }
	BOOL GetValue(ParamID id, TimeValue t, Mtl*& v, Interval &ivalid, int tabIndex=0) { return class_params->GetValue(id, t, v, ivalid, tabIndex); }
	BOOL GetValue(ParamID id, TimeValue t, Texmap*& v, Interval &ivalid, int tabIndex=0) { return class_params->GetValue(id, t, v, ivalid, tabIndex); }
	BOOL GetValue(ParamID id, TimeValue t, PBBitmap*& v, Interval &ivalid, int tabIndex=0) { return class_params->GetValue(id, t, v, ivalid, tabIndex); }
	BOOL GetValue(ParamID id, TimeValue t, INode*& v, Interval &ivalid, int tabIndex=0) { return class_params->GetValue(id, t, v, ivalid, tabIndex); }
	BOOL GetValue(ParamID id, TimeValue t, ReferenceTarget*& v, Interval &ivalid, int tabIndex=0) { return class_params->GetValue(id, t, v, ivalid, tabIndex); }

	PB2Export Color			GetColor(ParamID id, TimeValue t=0, int tabIndex=0);
	PB2Export Point3		GetPoint3(ParamID id, TimeValue t=0, int tabIndex=0);
	PB2Export int			GetInt(ParamID id, TimeValue t=0, int tabIndex=0);
	PB2Export float			GetFloat(ParamID id, TimeValue t=0, int tabIndex=0);
	PB2Export TimeValue		GetTimeValue(ParamID id, TimeValue t=0, int tabIndex=0);
	PB2Export TCHAR*		GetStr(ParamID id, TimeValue t=0, int tabIndex=0);
	PB2Export Mtl*			GetMtl(ParamID id, TimeValue t=0, int tabIndex=0);
	PB2Export Texmap*		GetTexmap(ParamID id, TimeValue t=0, int tabIndex=0);
	PB2Export PBBitmap*		GetBitmap(ParamID id, TimeValue t=0, int tabIndex=0);
	PB2Export INode*		GetINode(ParamID id, TimeValue t=0, int tabIndex=0);
	PB2Export ReferenceTarget* GetReferenceTarget(ParamID id, TimeValue t=0, int tabIndex=0);

	// get a string resource from plug-in module's resource
	PB2Export TCHAR* GetString(int id);
	// invalidate any current UI (parammap2) currently open for this descriptor
	PB2Export void InvalidateUI() { cd->InvalidateUI(this); }
	PB2Export void InvalidateUI(ParamID id, int tabIndex=-1) { cd->InvalidateUI(this, id, tabIndex); } // nominated param
	// get/set user dialog proc for the param map currently open this descriptor
	PB2Export void SetUserDlgProc(ParamMap2UserDlgProc* proc=NULL);
	PB2Export ParamMap2UserDlgProc* GetUserDlgProc();
	// dynamically access the P_OWNERS_REF refno for given RefTarg parameter 
	PB2Export void SetOwnerRefNo(ParamID id, int refno);
	PB2Export int  GetOwnerRefNo(ParamID id);
	// dynamically access the p_subtexno/p_submtlno number for given map/mtl parameter 
	PB2Export void SetSubTexNo(ParamID id, int texno);
	PB2Export void SetSubMtlNo(ParamID id, int mtlno);
	PB2Export int  GetSubTexNo(ParamID id);
	PB2Export int  GetSubMtlNo(ParamID id);
	// dynamically access the TYPE_OPEN/SAVEFILEBUTTON p_init_file field 
	PB2Export void SetInitFile(ParamID id, TCHAR* s);
	PB2Export TCHAR* GetInitFile(ParamID id);
};

PB2Export IParamBlock2 *CreateParameterBlock2(ParamBlockDesc2 *pdesc, ReferenceMaker* iowner);
class MacroRecorder;
PB2Export void SetPB2MacroRecorderInterface(MacroRecorder* mri);
						

// This updates or creates a new ParamBlock2, based on an existing ParamBlock of
// an earlier version. The new/updated parameter block inherits any parameters from
// the old parameter block whose parameter IDs match.
PB2Export IParamBlock2* UpdateParameterBlock2(
	ParamBlockDescID *pdescOld, int oldCount, IParamBlock *oldPB,
	ParamBlockDesc2* pdescNew,
	IParamBlock2* newPB=NULL);

// Thsi post-load callback handles conversion of pre-ParamBlock2 versions
// of an object to a ParamBlock2 version.
// NOTE: this thing deletes itself when it's done.
class ParamBlock2PLCB : public PostLoadCallback 
{
public:
	ParamVersionDesc* versions;
	int				  count;
	ParamBlockDesc2*  curdesc;
	ReferenceTarget*  targ;
	int				  pbRefNum;
	
	ParamBlock2PLCB(ParamVersionDesc *v, int cnt, ParamBlockDesc2* pd, ReferenceTarget *t, int refNum)
	{ 
		versions = v; count = cnt; curdesc = pd; targ = t; pbRefNum = refNum;
	}

	PB2Export void proc(ILoad *iload);
	int Priority() { return 0; }
	PB2Export int Execute(int cmd, ULONG arg1=0, ULONG arg2=0, ULONG arg3=0);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\interval.h ===
/**********************************************************************
 *<
	FILE: interval.h

	DESCRIPTION:  Defines TimeValue and Interval Classes

	CREATED BY: Rolf Berteig

	HISTORY: created 13 September 1994
             950818 - Added methods for setting start/end individually (gus)

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/


#ifndef _INTERVAL_H_
#define _INTERVAL_H_


class Interval {
	private:
		TimeValue	start;
		TimeValue	end;

	public:		
		/* 
		 Constructors:
		 */		
		CoreExport Interval( TimeValue s, TimeValue e );
		Interval() { SetEmpty(); } 

		int operator==( const Interval& i ) { return( i.start==start && i.end==end ); }
		CoreExport int InInterval(const TimeValue t);
		int InInterval(const Interval interval) { return InInterval( interval.Start() ) && InInterval( interval.End() ); }
		int Empty() { return (start == TIME_NegInfinity) && (end == TIME_NegInfinity); }

		void Set       ( TimeValue s, TimeValue e ) { start = s; end = e; }
		void SetStart  ( TimeValue s )              { start = s;          }
		void SetEnd    ( TimeValue e )              { end = e;            }

		void SetEmpty() { start = TIME_NegInfinity; end = TIME_NegInfinity; }
		void SetInfinite() { start = TIME_NegInfinity; end = TIME_PosInfinity; }
		void SetInstant(const TimeValue t) { start = end = t; }
		TimeValue Start() const { return start; }
		TimeValue End() const { return end; }
		TimeValue Duration() const { return end-start+TimeValue(1); } // end points included

		// intersection of intervals
		CoreExport Interval operator&(const Interval i) const;
		Interval& operator&=(const Interval i) { return (*this = (*this&i)); }
		Interval& operator+=(const TimeValue t) { if (t<start) start=t; if (t>end) end=t; return *this; }
};

#define FOREVER Interval(TIME_NegInfinity, TIME_PosInfinity)
#define NEVER Interval(TIME_NegInfinity, TIME_NegInfinity)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\iparamm.h ===
/**********************************************************************
 *<
	FILE: IParamM.h

	DESCRIPTION:  Parameter Maps

	CREATED BY: Rolf Berteig

	HISTORY: created 10/10/95

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/


#ifndef __IPARAMM__
#define __IPARAMM__


class IParamMap;
class IRendParams;

// If custom handling of controls needs to be done, ParameterMap
// client can't implement one of these and set is as the ParameterMap's
// user callback.
class ParamMapUserDlgProc {
	public:
		virtual BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)=0;
		virtual void DeleteThis()=0;
		virtual void Update(TimeValue t) {}
	};

// Return this from DlgProc to get the viewports redrawn.
#define REDRAW_VIEWS	2



class IParamMap {
	public:
	 	// Mark the UI as needing to be updated.
	 	virtual void Invalidate()=0;
		
		// Swaps the existing parameter block with a new one and updates UI.
		virtual void SetParamBlock(IParamArray *pb)=0;

		// The given proc will be called _after_ default processing is done.
		// The callback can then apply constraints to controls.
		// Note that if the proc is non-NULL when the ParamMap is deleted
		// its DeleteThis() method will be called.
		virtual void SetUserDlgProc(ParamMapUserDlgProc *proc=NULL)=0;
		virtual ParamMapUserDlgProc *GetUserDlgProc()=0;

		// Changes a map entry to refer to a different item in the parameter block.
		virtual void SetPBlockIndex(int mapIndex, int blockIndex)=0;

		// Access the dialog window.
		virtual HWND GetHWnd()=0;

		// Access the parameter block
		virtual IParamArray *GetParamBlock()=0;

		// Is the dialog proc active
		virtual BOOL DlgActive()=0;
	};




enum ControlType {
	TYPE_SPINNER,
	TYPE_RADIO,
	TYPE_SINGLECHEKBOX,
	TYPE_MULTICHEKBOX,
	TYPE_COLORSWATCH,
	};


// Giving this value for scale specifies autoscale
#define SPIN_AUTOSCALE	-1.0f

class ParamUIDesc {
	public:
		// Float or int controlled by a single spinner
		CoreExport ParamUIDesc(
			int index,EditSpinnerType spinType,int idEdit,int idSpin,
			float lowLim,float highLim,float scale,ParamDimension *dim=defaultDim);

		// int controlelled by n radio buttons
		// vals[i] represents the value if ctrlIDs[i] is checked.
		// if vals=NULL then ctrlIDs[i] represents a value of i.
		//
		// OR
		// 
		// int controlled by multiple check boxes where each
		// check boxes controlls a single bit.
		// vals[i] specifies which bit ctrlIds[i] controls.
		// If vals=NULL ctrlIDs[i] controls the ith bit.		
		CoreExport ParamUIDesc(
			int index,ControlType type,int *ctrlIDs,int count,int *vals=NULL);

		// int controlled by a single check box (BOOL)
		// or Point3 controlled by a color swatch.
		CoreExport ParamUIDesc(int index,ControlType type,int id);

		// Point3 controlled by 3 spinners
		CoreExport ParamUIDesc(int index,
				EditSpinnerType spinType,
				int idEdit1,int idSpin1,
				int idEdit2,int idSpin2,
				int idEdit3,int idSpin3,
				float lowLim,float highLim,float scale,
				ParamDimension *dim=defaultDim);
		
		
		int	pbIndex;
		ParamType 	ptype;
		ControlType	ctype;
		int id[6];
		int *ids;
		int *vals;
		int count;

		EditSpinnerType spinType;
		float lowLim;
		float highLim;
		float scale;
		ParamDimension *dim;
	};

// Creates a parameter map that will handle a parameter block in a modeless
// dialog where time does not change and the viewport is not redrawn.
// Note that there is no need to destroy it. It executes the dialog and then
// destorys itself. Returns TRUE if the user selected OK, FALSE otherwise.
CoreExport BOOL CreateModalParamMap(
		ParamUIDesc *desc,int count,
		IParamArray *pb,
		TimeValue t,
		HINSTANCE hInst,
		TCHAR *dlgTemplate,
		HWND hParent,
		ParamMapUserDlgProc *proc=NULL);


// Creates a parameter map to handle the display of parameters in the command panal.
// 
// This will add a rollup page to the command panel.
// DestroyCPParamMap().
//
CoreExport IParamMap *CreateCPParamMap(
		ParamUIDesc *desc,int count,
		IParamArray *pb,
		Interface *ip,
		HINSTANCE hInst,
		TCHAR *dlgTemplate,
		TCHAR *title,
		DWORD flags);


CoreExport IParamMap *ReplaceCPParamMap(
		HWND oldhw,
		ParamUIDesc *desc,int count,
		IParamArray *pb,
		Interface *ip,
		HINSTANCE hInst,
		TCHAR *dlgTemplate,
		TCHAR *title,
		DWORD flags);

CoreExport void DestroyCPParamMap(IParamMap *m);


// Creates a parameter map to handle the display of render parameters or
// atmospheric plug-in parameters.
CoreExport IParamMap *CreateRParamMap(
		ParamUIDesc *desc,int count,
		IParamArray *pb,
		IRendParams *ip,
		HINSTANCE hInst,
		TCHAR *dlgTemplate,
		TCHAR *title,
		DWORD flags);
CoreExport void DestroyRParamMap(IParamMap *m);

// Creates a parameter map to handle the display of texture map or
// material parameters in the material editor.
CoreExport IParamMap *CreateMParamMap(
		ParamUIDesc *desc,int count,
		IParamArray *pb,
		IMtlParams *ip,
		HINSTANCE hInst,
		TCHAR *dlgTemplate,
		TCHAR *title,
		DWORD flags);
CoreExport void DestroyMParamMap(IParamMap *m);



#endif // __IPARAMM__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\iparamm2.h ===
/**********************************************************************
 *<
	FILE: IParamM2.h

	DESCRIPTION:  Parameter Maps, Edition 2 for use with ParamBlock2's

	CREATED BY: Rolf Berteig
			    John Wainwright, 2nd edition

	HISTORY: created 10/10/95
			 2nd Ed. 9/8/98

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

/*
 *   IParamMap2's are used to map and manage UI dialogs for the parameters
 *   in a ParamBlock2.  They work almost identically to IParamMaps except:
 *
 *    1. they only work with ParamBlock2-hosted parameters; there is no
 *       IParamArray equivalent.  Hopefully, the new capabilities of ParamBlock2's
 *       cover most of the reasons for using IParamArrays.  If not, install virtual
 *       paramters in the ParamBlock2 and supply accessor fns for them.
 *
 *	  2. they derive all UI-related metadata from the ParamBlockDesc2 structure now
 *       pointed to by a ParamBlock2; there is no ParamUIDesc equivalent.
 *
 *    3. some new methods on ClassDesc can be used to automatically construct & open
 *       rollouts, so you may not have to create these explicitly yourself.
 */

#ifndef __IPARAMM2__
#define __IPARAMM2__

class IParamMap2;
class IRendParams;
class Effect;

#include <iparamb2.h>

// If custom handling of controls needs to be done, ParameterMap
// client can't implement one of these and set is as the ParameterMap's
// user callback.
class ParamMap2UserDlgProc 
{
	public:
		virtual BOOL DlgProc(TimeValue t, IParamMap2 *map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)=0;
		virtual void DeleteThis()=0;
		virtual void SetThing(ReferenceTarget *m) { }
		virtual void Update(TimeValue t) { }
		virtual void SetParamBlock(IParamBlock2 *pb) { }
};

// Return this from DlgProc to get the viewports redrawn.
#define REDRAW_VIEWS	2

class IParamMap2 
{
	public:
	 	// UI updating.
	 	virtual void Invalidate()=0;    // whole UI
	 	virtual void Validate()=0;		// uninvalidate whole UI
		virtual void Invalidate(ParamID id, int tabIndex=0)=0;  // nominated param
		virtual void UpdateUI(TimeValue t)=0;  // update UI directly for time t
		virtual void RedrawViews(TimeValue t, DWORD flag=REDRAW_NORMAL)=0;  // redraw viewport

		// Swaps the existing parameter block with a new one and updates UI.
		virtual void SetParamBlock(IParamBlock2 *pb)=0;

		// The given proc will be called _after_ default processing is done.
		// The callback can then apply constraints to controls.
		// Note that if the proc is non-NULL when the ParamMap is deleted
		// its DeleteThis() method will be called.
		virtual void SetUserDlgProc(ParamMap2UserDlgProc *proc=NULL)=0;
		virtual ParamMap2UserDlgProc *GetUserDlgProc()=0;

		// Changes a map entry to refer to a different item in the parameter block.
		virtual void ReplaceParam(ParamID curParam, ParamID newParam) { }

		// Access the dialog window.
		virtual HWND GetHWnd()=0;
		// Access the rollup window containing this rollout dialog
		virtual IRollupWindow* GetIRollup() { return NULL; }

		// Access the parameter block
		virtual IParamBlock2 *GetParamBlock()=0;

		// Is the dialog proc active
		virtual BOOL DlgActive()=0;

		// Access my descriptor
		virtual ParamBlockDesc2* GetDesc()=0;

		// sent to indicate dialog is going inactive so, among other things, ColorSwatches can be told
		virtual void ActivateDlg(BOOL onOff)=0;

		// sent to a Material Editor map to find the SubTex or SubMtl index corresponding to the control hw	
		virtual int FindSubTexFromHWND(HWND hw)=0;
		virtual int FindSubMtlFromHWND(HWND hw)=0;

		// Individual enable of param UI controls
		virtual void Enable(ParamID id, BOOL onOff, int tabIndex=0)=0;

		// Set text of param UI control
		virtual void SetText(ParamID id, TCHAR* txt, int tabIndex=0)=0;

		// Set tooltip of param UI control
		virtual void SetTooltip(ParamID id, BOOL onOf, TCHAR* txt, int tabIndex=0)=0;

		// Set range of param UI control (spinner/slider)
		virtual void SetRange(ParamID id, float low, float high, int tabIndex=0)=0;

		// show or hide assciated controls
		virtual void Show(ParamID id, BOOL showHide, int tabIndex=0)=0;

		// sent by any AutoXXParamDlg as a courtesy when it receives a SetThing()
		virtual void SetThing(ReferenceTarget *m)=0;
};

// Giving this value for scale specifies autoscale
#define SPIN_AUTOSCALE	-1.0f

// Creates a parameter map that will handle a parameter block in a modeless
// dialog where time does not change and the viewport is not redrawn.
// Note that there is no need to destroy it. It executes the dialog and then
// destorys itself. Returns TRUE if the user selected OK, FALSE otherwise.
PB2Export BOOL CreateModalParamMap2(
		IParamBlock2 *pb,
		TimeValue t,
		HINSTANCE hInst,
		TCHAR *dlgTemplate,
		HWND hParent,
		ParamMap2UserDlgProc *proc=NULL);

// Creates a parameter map to handle the display of parameters in the command panal.
// This will add a rollup page to the command panel.
// DestroyCPParamMap().
PB2Export IParamMap2 *CreateCPParamMap2(
		IParamBlock2 *pb,
		Interface *ip,
		HINSTANCE hInst,
		TCHAR *dlgTemplate,
		TCHAR *title,
		DWORD flags,
		ParamMap2UserDlgProc* dlgProc=NULL,
		HWND hOldRollup=NULL);
PB2Export void DestroyCPParamMap2(IParamMap2 *m);

// create a child dialog of the given parent parammap (for tabbed dialogs, etc.)
PB2Export IParamMap2 *CreateChildCPParamMap2(
		IParamBlock2 *pb,
		Interface *ip,
		HINSTANCE hInst,
		IParamMap2* parent,
		TCHAR *dlgTemplate,
		TCHAR *title,
		ParamMap2UserDlgProc* dlgProc=NULL);
PB2Export void DestroyChildCPParamMap2(IParamMap2 *m);

// Creates a parameter map to handle the display of render parameters or
// atmospheric plug-in parameters.
PB2Export IParamMap2 *CreateRParamMap2(
		IParamBlock2 *pb,
		IRendParams *ip,
		HINSTANCE hInst,
		TCHAR *dlgTemplate,
		TCHAR *title,
		DWORD flags,
		ParamMap2UserDlgProc* dlgProc=NULL);
PB2Export void DestroyRParamMap2(IParamMap2 *m);

// create a parameter map for render or atmos params in a child dialog window
// of the given parent parammap, used typically to create tab child windows in 
// a tabbed rollout
PB2Export IParamMap2* CreateChildRParamMap2(
		IParamBlock2 *pb, 
		IRendParams *ip, 
		HINSTANCE hInst, 
		IParamMap2* parent,
		TCHAR *dlgTemplate, 
		TCHAR *title, 
		ParamMap2UserDlgProc* dlgProc=NULL);
PB2Export void DestroyChildRParamMap2(IParamMap2 *m);

// Creates a parameter map to handle the display of texture map or
// material parameters in the material editor.
PB2Export IParamMap2 *CreateMParamMap2(
		IParamBlock2 *pb,
		IMtlParams *ip,
		HINSTANCE hInst,
		HWND hmedit,
		TexDADMgr* tdad,
		MtlDADMgr* mdad,
		TCHAR *dlgTemplate,
		TCHAR *title,
		DWORD flags,
		ParamMap2UserDlgProc* dlgProc=NULL,
		HWND hOldRollup=NULL);
PB2Export void DestroyMParamMap2(IParamMap2 *m);

// create a child dialog of the given parent parammap (for tabbed dialogs, etc.)
PB2Export IParamMap2 *CreateChildMParamMap2(
		IParamBlock2 *pb,
		IMtlParams *ip,
		HINSTANCE hInst,
		IParamMap2* parent,
		TexDADMgr* tdad,
		MtlDADMgr* mdad,
		TCHAR *dlgTemplate,
		TCHAR *title,
		ParamMap2UserDlgProc* dlgProc=NULL);
PB2Export void DestroyChildMParamMap2(IParamMap2 *m);

//  Auto ParamDlg class for Material Editor auto-UI, instanced by ClassDesc2::CreateParamDlg()
//  It maintains a table of secondary ParamDlgs for master ParamDlgs (eg, the one returned 
//  from CreateParamDlg()) and will broadcast appropriate method calls to them
//  as the master receives them
class IAutoMParamDlg : public ParamDlg
{
	public:
		virtual void		InvalidateUI()=0;
		virtual void		MtlChanged()=0;
		// secondary dialog list management
		virtual int			NumDlgs()=0;
		virtual void		AddDlg(ParamDlg* dlg)=0;
		virtual ParamDlg*	GetDlg(int i)=0;
		virtual void		SetDlg(int i, ParamDlg* dlg)=0;
		virtual void		DeleteDlg(ParamDlg* dlg)=0;
		// access to this dlg's parammap stuff
		virtual IParamMap2* GetMap()=0;
};
// create an AutoMParamDlg for material editor
PB2Export IAutoMParamDlg* CreateAutoMParamDlg(HWND hMedit, IMtlParams *i, MtlBase* mtl,
											  IParamBlock2* pb, ClassDesc2* cd, HINSTANCE inst, 
											  TCHAR* dlgTemplate, TCHAR* title, int rollFlags,
											  ParamMap2UserDlgProc* dlgProc=NULL,
											  HWND hOldRollup=NULL);

//  Auto ParamDlg class for Effects auto-UI, instanced by ClassDesc2::CreateParamDialog()
//  It maintains a table of secondary EffectParamDlg for master EffectParamDlg (eg, the one returned 
//  from CreateParamDialog()) and will broadcast appropriate method calls to them
//  as the master receives them
class IAutoEParamDlg : public EffectParamDlg
{
	public:
		virtual void		InvalidateUI()=0;
		// secondary dialog list management
		virtual int			NumDlgs()=0;
		virtual void		AddDlg(SFXParamDlg* dlg)=0;
		virtual SFXParamDlg* GetDlg(int i)=0;
		virtual void		SetDlg(int i, SFXParamDlg* dlg)=0;
		virtual void		DeleteDlg(SFXParamDlg* dlg)=0;
		// access to this dlg's parammap stuff
		virtual IParamMap2* GetMap()=0;
};
// create an AutoEParamDlg for render effects
PB2Export IAutoEParamDlg* CreateAutoEParamDlg(IRendParams *i, Effect* e,
											  IParamBlock2* pb, ClassDesc2* cd, HINSTANCE inst, 
											  TCHAR* dlgTemplate, TCHAR* title, int rollFlags, 
											  ParamMap2UserDlgProc* dlgProc=NULL);


#endif // __IPARAMM2__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\ioapi.h ===
/**********************************************************************
 *<
	FILE: ioapi.h

	DESCRIPTION:

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __IOAPI__H
#define __IOAPI__H

#include "maxtypes.h"

class ILoad;
class INode;
class ReferenceMaker;
class ClassDesc;

class PostLoadCallback {
	public:
	virtual void proc(ILoad *iload)=0;
	// Lower priorities are run first-- allowable values {0..10}: 0 is reserved for ParamBlock2PLCB & ParamBlockPLCB 
	virtual int Priority() { return 5; }  
	virtual int Execute(int cmd, ULONG arg1=0, ULONG arg2=0, ULONG arg3=0) { return 0; }
	};


// Moved these to MAXTYPES.H
//typedef enum {IO_OK=0, IO_END=1, IO_ERROR=2} IOResult; 
//typedef enum {NEW_CHUNK=0, CONTAINER_CHUNK=1, DATA_CHUNK=2} ChunkType;
//typedef enum {IOTYPE_MAX=0, IOTYPE_MATLIB=1} FileIOType; 

class ISave {
	public:
		virtual ~ISave(){};
		
		// Returns the index of the referenced object in the Scene stream.
		virtual int GetRefID(void *ptarg)=0;

		// Begin a chunk.
		virtual void BeginChunk(USHORT id)=0;

		// End a chunk, and back-patch the length.
		virtual void EndChunk()=0;

		virtual	int CurChunkDepth()=0;  // for checking balanced BeginChunk/EndChunk

		// write a block of bytes to the output stream.
		virtual IOResult Write(const void  *buf, ULONG nbytes, ULONG *nwrit)=0;

		// Write character strings
		virtual IOResult WriteWString(const char *str)=0;
		virtual IOResult WriteWString(const wchar_t *str)=0;
		virtual IOResult WriteCString(const char *str)=0;
		virtual IOResult WriteCString(const wchar_t *str)=0;

		// are we saveing a MAX file or a MAT lib
		virtual FileIOType DoingWhat()=0;

		// Test this for saving old version.  
		// Returns 0 for the current version, 2000 for version 2.0.
		virtual DWORD SavingVersion() { return  0; }

		// <JBW> get a load ref id for the given RefMaker's ClassDesc in the ClassDirectory stream
		virtual USHORT GetClassDescID(ReferenceMaker* rm) { return 0xffff; }

		virtual int Execute(int cmd, ULONG arg1=0, ULONG arg2=0, ULONG arg3=0) { return 0; }
		};


class ILoad {
	public:
		virtual ~ILoad(){};
		
		// Returns the memory address of the ith object Scene stream.
		virtual void* GetAddr(int imaker)=0;

		// If GetAddr() returns NULL, then call this to get the address
		// backpatched later, when it is known.  patchThis must point at
		// a valid pointer location. RecordBackpatch will patch the
		// address immediately if it is available.
		virtual void RecordBackpatch(int imaker, void** patchThis)=0;

		// When the root of a reference hierarchy is loaded, its
		// Load() can call this to store away a pointer to itself
		// for later retrieval.
		virtual void SetRootAddr(void *addr)=0;
		virtual void* GetRootAddr()=0;

		// if OpenChunk returns IO_OK, use following 3 function to get the 
		// info about the chunk. IO_END indicates no more chunks at this level
		virtual IOResult OpenChunk()=0;

		// These give info about the most recently opened chunk
		virtual USHORT CurChunkID()=0;
		virtual ChunkType CurChunkType()=0;
		virtual	ULONG CurChunkLength()=0;  // chunk length NOT including header
		virtual	int CurChunkDepth()=0;  // for checking balanced OpenChunk/CloseChunk

		// close the currently opened chunk, and position at the next chunk
		//  return of IO_ERROR indicates there is no open chunk to close
		virtual IOResult CloseChunk()=0;

		// Look at the next chunk ID without opening it.
		// returns 0 if no more chunks
		virtual	USHORT PeekNextChunkID()=0;

		// Read a block of bytes from the output stream.
		virtual IOResult Read(void  *buf, ULONG nbytes, ULONG *nread )=0;

		// Read a string from a string chunk assumes chunk is already open, 
		// it will NOT close the chunk. Sets buf to point
		// to a char string.  Don't delete buf: ILoad will take care of it.

		//   Read a string that was stored as Wide chars. 
		virtual IOResult ReadWStringChunk(char** buf)=0;
		virtual IOResult ReadWStringChunk(wchar_t** buf)=0;

		//   Read a string that was stored as single byte chars
		virtual IOResult ReadCStringChunk(char** buf)=0;
		virtual IOResult ReadCStringChunk(wchar_t** buf)=0;

		// Call this if you encounter obsolete data to cause a
		//  message to be displayed after loading.
		virtual	void SetObsolete()=0;		

		// Register procedure to be called after loading. These will
		// be called in the order that they are registered.
		// It is assumed that if the callback needs to be deleted,
		// the proc will do it.
		virtual void RegisterPostLoadCallback(PostLoadCallback *cb)=0;

		// Gets the various directories. Constants are defined in
		// JAGAPI.H
		virtual TCHAR *GetDir(int which)=0;

		// are we Loading a MAX file or a MAT lib
		virtual FileIOType DoingWhat()=0;

		// Root node to attach to when loading node with no parent
		virtual INode *RootNode()=0;

		// <JBW> get the ClassDesc corresponding to the given refID in the ClassDirectory stream
		// companion to ISave::GetClassDescID() for saving & loading ClassDesc references
		virtual ClassDesc* GetClassDesc(USHORT refID) { return NULL; }

		virtual int Execute(int cmd, ULONG arg1=0, ULONG arg2=0, ULONG arg3=0) { return 0; }
	};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\ipoint3.h ===
/**********************************************************************
 *<
	FILE: ipoint3.h

	DESCRIPTION: Class definitions for IPoint3

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __IPOINT3__ 

#define __IPOINT3__

class ostream;

class IPoint3 {
public:
	int x,y,z;

	// Constructors
	IPoint3(){}
	IPoint3(int X, int Y, int Z)  { x = X; y = Y; z = Z;  }
	IPoint3(const IPoint3& a) { x = a.x; y = a.y; z = a.z; } 
	IPoint3(int ai[3]) { x = ai[0]; y = ai[1]; z = ai[2]; }

	// Access operators
	int& operator[](int i) { return (&x)[i]; }     
	const int& operator[](int i) const { return (&x)[i]; }  
 	
 	// Conversion function
	operator int*() { return(&x); }

	// Unary operators
	IPoint3 operator-() const { return(IPoint3(-x,-y,-z)); } 
	IPoint3 operator+() const { return *this; } 

	// Assignment operators
	DllExport IPoint3& operator-=(const IPoint3&);
	DllExport IPoint3& operator+=(const IPoint3&);

	// Binary operators
	DllExport IPoint3 operator-(const IPoint3&) const;
	DllExport IPoint3 operator+(const IPoint3&) const;
	DllExport int operator*(const IPoint3&) const;    // DOT PRODUCT
	DllExport int DotProd(const IPoint3&) const;    // DOT PRODUCT
	DllExport IPoint3 operator^(const IPoint3&) const;   // CROSS PRODUCT
	DllExport IPoint3 CrossProd(const IPoint3&) const;   // CROSS PRODUCT

	// Relational operators
	int operator==(const IPoint3& p) const { return (x == p.x && y == p.y && z == p.z); }
	int operator!=(const IPoint3& p) const { return ( (x != p.x) || (y != p.y) || (z != p.z) ); }
	};

    // friends, so you can write Length(A) instead of A.Length(), etc.
int DllExport MaxComponent(const IPoint3&);  // the component with the maximum abs value
int DllExport MinComponent(const IPoint3&);  // the component with the minimum abs value
	 
ostream DllExport &operator<<(ostream&, const IPoint3&); 

// Inlines:

inline float Length(const IPoint3& v) {	
	return (float)sqrt((double)(v.x*v.x+v.y*v.y+v.z*v.z));
	}

inline IPoint3& IPoint3::operator-=(const IPoint3& a) {	
	x -= a.x;	y -= a.y;	z -= a.z;
	return *this;
	}

inline IPoint3& IPoint3::operator+=(const IPoint3& a) {
	x += a.x;	y += a.y;	z += a.z;
	return *this;
	}

inline IPoint3 IPoint3::operator-(const IPoint3& b) const {
	return(IPoint3(x-b.x,y-b.y,z-b.z));
	}

inline IPoint3 IPoint3::operator+(const IPoint3& b) const {
	return(IPoint3(x+b.x,y+b.y,z+b.z));
	}

inline int IPoint3::operator*(const IPoint3& b) const {  
	return(x*b.x+y*b.y+z*b.z);	
	}

inline int IPoint3::DotProd(const IPoint3& b)  const { 
	return(x*b.x+y*b.y+z*b.z);	
	}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\IReagent.h ===
/**********************************************************************
 *<
	FILE: IReagent.h

	DESCRIPTION: Declares a class of objects which react

	CREATED BY:	John Hutchinson

	HISTORY: Created January 9, 1999

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#pragma once

#include <IAggregation.h>
class IAggregation;
class IGeomImp;
class IValence;
class ValenceDescIterator;
class IHost;

class IReagent 
{
public:
	//completes the construction process
	virtual void InitializeSubstrate(INode* n) = 0;//completes the construction process

	virtual IValence* OpenValence() = 0;
	virtual void OpenValenceTM(TimeValue t, Matrix3& tm)= 0;
	virtual void CloseValence(IValence* val, bool done = false)= 0;
	virtual int NumValenceTypes() = 0;
	virtual Class_ID GetValenceClassID(int which) = 0;
	//create a valence given a class descriptor and a node(used for its location)
	//may create a new instance of this type
	virtual IValence* PrepValence(ClassDesc* cd, INode* me, INode* loc) = 0;

	//pass back the chemistry/geometry of the reagent viz-a-viz the current reaction
	//Thus this excludes any pending reaction results.
	//Currently we assumes one reaction at a time. Could pass a valence to identify which.
	virtual IGeomImp* ReactionSite() = 0;
};


class IValence
{
public:
	enum bondtype {
		eStrongBond,//absorb the node
			eWeakBond,//don't absorb the node
	eTransientBond,//temporary but affect permanaent change to object stack
	eTopicalBond};//unused but coneptually a weaker type of transient bonds which just copy node properties

	//set up a controller and possibly record subobj hit data from the host
	virtual Control* Locate(INode* host, Control* c, Matrix3& oldP, Matrix3& newP) = 0;//may clone the controller
	virtual commitlevels Occupy(Object* obj) = 0;
	virtual Object* Occupant()=0;
	virtual bool Bind(TimeValue t, IGeomImp &complex_geom, Matrix3& tm, Interval iv, IHost* attentivehost = NULL) = 0;
	virtual commitlevels Validate(TimeValue t, int action,  commitlevels current, Matrix3* tm) = 0;
	virtual bondtype BondStrength()=0;
	virtual void SetOwner(Object* owner)=0;
};

/*
class ValenceDescIterator
{
public:
	ValenceDescIterator();
	~ValenceDescIterator();

	Class_ID First();
	virtual bool IsDone();
	Class_ID Next();
private:
	int m_current;
};
*/
//mechanism to test compatibility needs to be done at the class descriptor level. 
//Since this is what gets enumerated at the point prio to the valence getting created.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\ipoint2.h ===
/**********************************************************************
 *<
	FILE: ipoint2.h

	DESCRIPTION: Class definintion for IPoint2: Integer 2D point.

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __IPOINT2__ 

#define __IPOINT2__

class ostream;

class IPoint2 {
public:
	int x,y;

	// Constructors
	IPoint2(){}
	IPoint2(int X, int Y)  { x = X; y = Y;  }
	IPoint2(const IPoint2& a) { x = a.x; y = a.y; } 
	IPoint2(int af[2]) { x = af[0]; y = af[1]; }

	// Access operators
	int& operator[](int i) { return (&x)[i]; }     
	const int& operator[](int i) const { return (&x)[i]; }  

 	// Conversion function
	operator int*() { return(&x); }
	 
	// Unary operators
	IPoint2 operator-() const { return(IPoint2(-x,-y)); } 
	IPoint2 operator+() const { return *this; } 

	// Assignment operators
	IPoint2& operator-=(const IPoint2&);
	IPoint2& operator+=(const IPoint2&);
	DllExport IPoint2& operator*=(int);
	DllExport IPoint2& operator/=(int);

	// Binary operators
	DllExport IPoint2 operator-(const IPoint2&) const;
	DllExport IPoint2 operator+(const IPoint2&) const;
	DllExport int DotProd(const IPoint2&) const;    // DOT PRODUCT
	DllExport int operator*(const IPoint2&) const;    // DOT PRODUCT

	// Relational operators
	int operator==(const IPoint2& p) const { return (x == p.x && y == p.y); }
	int operator!=(const IPoint2& p) const { return (x != p.x || y != p.y); }
	};

int DllExport Length(const IPoint2&); 
IPoint2 DllExport Normalize(const IPoint2&); // Return a unit vector.
IPoint2 DllExport operator*(int, const IPoint2&);	// multiply by scalar
IPoint2 DllExport operator*(const IPoint2&, int);	// multiply by scalar
IPoint2 DllExport operator/(const IPoint2&, int);	// divide by scalar

ostream DllExport &operator<<(ostream&, const IPoint2&); 

// Inlines:

inline int MaxComponent(const IPoint2& p) { return(p.x>p.y?0:1); }
inline int MinComponent(const IPoint2& p) { return(p.x<p.y?0:1); }

inline int Length(const IPoint2& v) {	
	return (int)sqrt((double)(v.x*v.x+v.y*v.y));
	}

inline IPoint2& IPoint2::operator-=(const IPoint2& a) {	
	x -= a.x;	y -= a.y;  
	return *this;
	}

inline IPoint2& IPoint2::operator+=(const IPoint2& a) {
	x += a.x;	y += a.y;  
	return *this;
	}

inline IPoint2& IPoint2::operator*=(int f) {
	x *= f;   y *= f;	
	return *this;
	}

inline IPoint2& IPoint2::operator/=(int f) { 
	x /= f;	y /= f;		
	return *this; 
	}

inline IPoint2 IPoint2::operator-(const IPoint2& b) const{
	return(IPoint2(x-b.x,y-b.y));
	}

inline IPoint2 IPoint2::operator+(const IPoint2& b) const {
	return(IPoint2(x+b.x,y+b.y));
	}

inline int IPoint2::DotProd(const IPoint2& b) const{
	return(x*b.x+y*b.y);
	}

inline int IPoint2::operator*(const IPoint2& b)const {
	return(x*b.x+y*b.y);
	}

inline IPoint2 operator*(int f, const IPoint2& a) {
	return(IPoint2(a.x*f, a.y*f));
	}

inline IPoint2 operator*(const IPoint2& a, int f) {
	return(IPoint2(a.x*f, a.y*f));
	}

inline IPoint2 operator/(const IPoint2& a, int f) {
	return(IPoint2(a.x/f, a.y/f));
	}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\IRefArray.h ===
/**********************************************************************
 *<
	FILE: IRefArray.h

	DESCRIPTION:  An interface to facilitate maintaining multiple arrays of references.

	CREATED BY: John Hutchinson

	HISTORY: created 9/1/98

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#pragma once
#ifndef _IREFARRAY
#define _IREFARRAY

//Forward declarations
typedef Tab<ReferenceTarget*> ReferenceArray;




class IRefArray {
public :
	virtual int NumRefCols() const = 0; // The size of my arrays (same size!)
	virtual int NumRefRows() const = 0; // The number of arrays I maintain including inner
	virtual void EnlargeAndInitializeArrays(int newsize) = 0; //allocator
	virtual ReferenceArray& RefRow(int which)= 0; //access to the rows
	virtual const ReferenceArray& RefRow(int which) const = 0; //const version of above

protected:
	virtual int TotalRefs() const = 0; // Equivalent of NumRefs

	virtual IRefArray* Inner() = 0; //PI Access to the containee
	virtual const IRefArray* Inner() const = 0; //PI Access to the containee
	virtual int InnerArrays()  const = 0; //the number of arrays in any containee
	virtual int Remap(int row, int col) const = 0; //Converts an index for processing by the inner

	virtual int ArrayOffset() const = 0; // the number of special (non-array) references
	virtual bool IsSubArrayIndex(int i) const = 0;
	virtual RefTargetHandle GetSubArrayReference(int i) = 0;//
	virtual void SetSubArrayReference(int i, RefTargetHandle rtarg) = 0;

public:
	//Referencemaker overloads
	virtual RefTargetHandle GetReference(int row, int col) = 0;
	virtual void SetReference(int row, int col, RefTargetHandle rtarg) = 0;
	virtual RefResult MakeRefByID(Interval refInterval, int row, int col, RefTargetHandle rtarg) = 0;
	virtual RefResult ReplaceReference(int row, int col, RefTargetHandle newtarg, BOOL delOld=TRUE) = 0;
	virtual RefResult DeleteReference(int row, int col) = 0;
	virtual BOOL CanTransferReference(int row, int col) = 0;
	virtual bool FindRef(RefTargetHandle rtarg, int& row, int& col) = 0;
	virtual void CloneRefs(ReferenceMaker *, RemapDir& remap) = 0;
};
#endif //_IREFARRAY
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\KbdShortcut.h ===
/**********************************************************************
 *<
	FILE: KbdShortcut.h

	DESCRIPTION: Keyboard Shortcut table definitions

	CREATED BY:	Scott Morrison

	HISTORY: Created 10 July, 1998

 *>	Copyright (c) 1998, All Rights Reserved.
 **********************************************************************/

#ifndef __KBDSHORTCUT__
#define __KBDSHORTCUT__

// ShortcutTableIds used by the system
const ShortcutTableId kShortcutMainUI = 0;
const ShortcutTableId kShortcutTrackView = 1;
const ShortcutTableId kShortcutMaterialEditor = 2;
const ShortcutTableId kShortcutVideoPost = 3;
const ShortcutTableId kShortcutSchematicView = 5;


// Description of a command for building shortcut tables from static data
struct ShortcutDescription {
	int mCmdID;
	int mResourceID;
};

// Describes an operation that can be attached to a Shortcut
class ShortcutOperation {

public:
    CoreExport ShortcutOperation()
        {
            mCmdId = 0;
            mpName = NULL;
        }

    CoreExport int    GetId() { return mCmdId; }
    CoreExport void SetId(int id) { mCmdId = id; }
    CoreExport TCHAR*  GetName() { return mpName;}
    CoreExport void SetName(TCHAR* pName) { mpName = pName; }

private:
    int     mCmdId;     // The command id sent to the window proc
    TCHAR*  mpName;     // The name of the operation the user sees

};

// A table of accerators used by plug-ins
class ShortcutTable {

public:
    CoreExport ShortcutTable(ShortcutTableId id, TSTR& name, HACCEL hDefaults,
                             int numIds, ShortcutDescription* pOps,
                             HINSTANCE hInst);
    CoreExport ~ShortcutTable();

    CoreExport HACCEL GetHAccel() { return mhAccel; }
    CoreExport void SetHAccel(HACCEL hAccel) { mhAccel = hAccel; }
    CoreExport HACCEL GetDefaultHAccel() { return mhDefaultAccel; }
    CoreExport TSTR& GetName() { return mName; }
    CoreExport ShortcutTableId GetId() { return mId; }
    CoreExport ShortcutOperation& operator[](int i) { return mOps[i]; }
    CoreExport int Count() { return mOps.Count(); }
    CoreExport void DeleteThis() { delete this; }

    CoreExport TCHAR* GetString(int commandId);

private:
    // These values are set by the plug-in to describe a shortcut table

    // Unique identifier of table (like a class id)
    ShortcutTableId  mId;
    // Name to use in preference dlg drop-down
    TSTR mName;
    // Descriptors of all operations that can have Shortcuts
    Tab<ShortcutOperation>  mOps; 

    // The windows accelerator table in use
    HACCEL mhDefaultAccel;
    // The windows accelerator table in use
    HACCEL mhAccel;

};

class ShortcutCallback {
public:
    virtual BOOL KeyboardShortcut(int id) = 0;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\linklist.h ===
/**********************************************************************
 *<
	FILE: linklist.cpp

	DESCRIPTION:  Linked-list template classes

	CREATED BY: Tom Hudson

	HISTORY: created 10 December 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#ifndef __LINKLIST_H__

#define __LINKLIST_H__

template <class T> class LinkedEntryT {
public:
	T data;
	void *next;
	LinkedEntryT(T& d) { data = d; next = NULL; }
	};

template <class T,class TE> class LinkedListT {
private:
    TE* head;
	TE* tail;
	int count;
public:
					LinkedListT() { head = tail = NULL; count = 0; }
					~LinkedListT() { New(); }
		void		New() {
						while(head) {
							TE* next = (TE*)head->next;
							delete head;
							head = next;
							}
						head = tail = NULL;
						count = 0;
						}
		int			Count() { return count; }
		void		Append(T& item) {
						TE *entry = new TE(item);
						if(tail)
							tail->next = entry;
						tail = entry;
						if(!head)
							head = entry;
						count++;	
						}
		T			&operator[](int index) {
						TE *e = head;
						while(index && e) {
							e = (TE*)e->next;
							index--;
							}
						// This should never happen, so we'll punt and return...
						// the head's data
						if(!e) {
							assert(0);
							return head->data;
							}
						return e->data;
						}
		LinkedListT	&operator=(LinkedListT &from) {
						New();
						for(int i = 0; i < from.Count(); ++i)
							Append(from[i]);
						return *this;
						}
	};

// Handy macro for defining linked-lists

#define MakeLinkedList(TYPE) typedef LinkedEntryT<TYPE> TYPE##Entry; typedef LinkedListT<TYPE,TYPE##Entry> TYPE##List;

#endif // __LINKLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\keyreduc.h ===
/**********************************************************************
 *<
	FILE: keyreduc.h

	DESCRIPTION:  Key reduction

	CREATED BY: Rolf Berteig

	HISTORY: created 9/30/95

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __KEYREDUC__
#define __KEYREDUC__

#define DEFULAT_KEYREDUCE_THRESHOLD		(0.5f)

// Values returned from Progress
#define KEYREDUCE_ABORT		-1		// Stops processing and undoes any key reduction
#define KEYREDUCE_STOP		0		// Stops processing, but keeps any reduction done so far
#define KEYREDUCE_CONTINUE	1		// Keeps going.

// A callback so progress can be made during key reduction
class KeyReduceStatus {
	public:
		// Called once before reduction starts. 'total' is the number
		// reduction canidate keys.
		virtual void Init(int total)=0;

		// Called every now and again. 'p' is the number of keys
		// processed. So % done is p/total * 100.		
		virtual int Progress(int p)=0;
	};

// Attempts to delete keys that lie within the given time range.
// The controller will be sampled within the range in 'step' size
// increments. After the key reduction, the controller's values
// at each step are gauranteed to be withen 'threshold' distance
// from their original values.
//
CoreExport int ApplyKeyReduction(
		Control *cont,Interval range,float thresh,TimeValue step,
		KeyReduceStatus *status);


#endif  //__KEYREDUC__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\lockid.h ===
#ifndef __LOCKID_H__
#define __LOCKID_H__

extern unsigned int CoreExport HardwareLockID();
extern bool CoreExport IsTrialLicense();
extern bool CoreExport IsNetworkLicense();
extern bool CoreExport IsEmergencyLicense();


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\istdplug.h ===
/**********************************************************************
 *<
	FILE: istdplug.h

	DESCRIPTION:  Interfaces into some of the standard plug-ins 
	              that ship with MAX

	CREATED BY: Rolf Berteig	

	HISTORY: created 20 January 1996

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __ISTDPLUG__
#define __ISTDPLUG__

//----------------------------------------------------------------
// The following are parameter block IDs for procedural objects

// Arc
#define ARC_RADIUS		0
#define ARC_FROM		1
#define ARC_TO			2
#define ARC_PIE			3
#define ARC_REVERSE		4

// Box object
#define BOXOBJ_LENGTH	0
#define BOXOBJ_WIDTH	1
#define BOXOBJ_HEIGHT	2
#define BOXOBJ_WSEGS	3
#define BOXOBJ_LSEGS	4
#define BOXOBJ_HSEGS	5
#define BOXOBJ_GENUVS	6

// Circle
#define CIRCLE_RADIUS		0

// Cone
#define CONE_RADIUS1		0
#define CONE_RADIUS2		1
#define CONE_HEIGHT			2
#define CONE_SEGMENTS		3
#define CONE_CAPSEGMENTS	4
#define CONE_SIDES			5
#define CONE_SMOOTH			6
#define CONE_SLICEON		7
#define CONE_PIESLICE1		8
#define CONE_PIESLICE2		9
#define CONE_GENUVS			10

// Cylinder
#define CYLINDER_RADIUS			0
#define CYLINDER_HEIGHT			1
#define CYLINDER_SEGMENTS		2
#define CYLINDER_CAPSEGMENTS	3
#define CYLINDER_SIDES			4
#define CYLINDER_SMOOTH			5
#define CYLINDER_SLICEON		6
#define CYLINDER_PIESLICE1		7
#define CYLINDER_PIESLICE2		8
#define CYLINDER_GENUVS			9

// Donut
#define DONUT_RADIUS1		0
#define DONUT_RADIUS2		1

// Ellipse
#define ELLIPSE_LENGTH		0
#define ELLIPSE_WIDTH		1

// Hedra
#define HEDRA_RADIUS	0
#define HEDRA_FAMILY	1
#define HEDRA_P			2
#define HEDRA_Q			3
#define HEDRA_SCALEP	4
#define HEDRA_SCALEQ	5
#define HEDRA_SCALER	6
#define HEDRA_VERTS		7
#define HEDRA_GENUVS	8

// Helix
#define HELIX_RADIUS1		0
#define HELIX_RADIUS2		1
#define HELIX_HEIGHT		2
#define HELIX_TURNS			3
#define HELIX_BIAS			4
#define HELIX_DIRECTION		5

// NGon
#define NGON_RADIUS			0
#define NGON_SIDES			1
#define NGON_CIRCULAR		2

// PatchGrid
#define PATCHGRID_LENGTH	0
#define PATCHGRID_WIDTH		1
#define PATCHGRID_WSEGS		2
#define PATCHGRID_LSEGS		3
#define PATCHGRID_TEXTURE	4

// Rain/snow
#define RSPART_VPTPARTICLES		0
#define RSPART_RNDPARTICLES		1
#define RSPART_DROPSIZE			2
#define RSPART_SPEED			3
#define RSPART_VARIATION		4
#define RSPART_DISPTYPE			5
#define RSPART_STARTTIME		6
#define RSPART_LIFETIME			7
#define RSPART_EMITTERWIDTH		8
#define RSPART_EMITTERHEIGHT	9
#define RSPART_HIDEEMITTER		10
#define RSPART_BIRTHRATE		11
#define RSPART_CONSTANT			12
#define RSPART_RENDER			13
#define RSPART_TUMBLE			14
#define RSPART_SCALE			15

// Rectangle
#define RECTANGLE_LENGTH	0
#define RECTANGLE_WIDTH		1
#define RECTANGLE_FILLET	2

// Sphere
#define SPHERE_RADIUS	0
#define SPHERE_SEGS		1
#define SPHERE_SMOOTH	2
#define SPHERE_HEMI		3
#define SPHERE_SQUASH	4
#define SPHERE_RECENTER	5
#define SPHERE_GENUVS	6

// Star
#define START_RADIUS1		0
#define START_RADIUS2		1
#define START_POINTS		2
#define START_DISTORT		3
#define START_FILLET1		4
#define START_FILLET2		5


// Tea Pot
#define TEAPOT_RADIUS	0
#define TEAPOT_SEGS		1
#define TEAPOT_SMOOTH	2
#define TEAPOT_TEAPART	3
#define TEAPOT_BODY		4
#define TEAPOT_HANDLE	5
#define TEAPOT_SPOUT	6
#define TEAPOT_LID		7
#define TEAPOT_GENUVS	8


// Text
#define TEXT_SIZE 0
#define TEXT_KERNING 1
#define TEXT_LEADING 2

// torus
#define TORUS_RADIUS		0
#define TORUS_RADIUS2		1
#define TORUS_ROTATION		2
#define TORUS_TWIST			3
#define TORUS_SEGMENTS		4
#define TORUS_SIDES			5
#define TORUS_SMOOTH		6
#define TORUS_SLICEON		7
#define TORUS_PIESLICE1		8
#define TORUS_PIESLICE2		9
#define TORUS_GENUVS		10

// Tube
#define TUBE_RADIUS			0
#define TUBE_RADIUS2		1
#define TUBE_HEIGHT			2
#define TUBE_SEGMENTS		3
#define TUBE_CAPSEGMENTS	4
#define TUBE_SIDES			5
#define TUBE_SMOOTH			6
#define TUBE_SLICEON		7
#define TUBE_PIESLICE1		8
#define TUBE_PIESLICE2		9
#define TUBE_GENUVS			10

// Grid
#define GRIDHELP_LENGTH			0
#define GRIDHELP_WIDTH			1
#define GRIDHELP_GRID			2


//----------------------------------------------------------------
// The following are parameter block IDs for modifiers

// Bend
#define BEND_ANGLE		0
#define BEND_DIR		1
#define BEND_AXIS		2
#define BEND_DOREGION	3
#define BEND_FROM		4
#define BEND_TO			5

// Bomb
#define BOMB_STRENGTH		0
#define BOMB_GRAVITY		1
#define BOMB_CHAOS			2
#define BOMB_DETONATION		3

// Deflector
#define DEFLECTOR_BOUNCE	0
#define DEFLECTOR_WIDTH		1
#define DEFLECTOR_HEIGHT	2

// Displace (modifier and space warp object)
#define DISPLACE_MAPTYPE		0
#define DISPLACE_UTILE			1
#define DISPLACE_VTILE			2
#define DISPLACE_WTILE			3
#define DISPLACE_BLUR			4
#define DISPLACE_USEMAP			5
#define DISPLACE_APPLYMAP		6
#define DISPLACE_STRENGTH		7
#define DISPLACE_DECAY			8
#define DISPLACE_CENTERLUM		9
#define DISPLACE_UFLIP			10
#define DISPLACE_VFLIP			11
#define DISPLACE_WFLIP			12
#define DISPLACE_CENTERL		13
#define DISPLACE_CAP			14
#define DISPLACE_LENGTH			15
#define DISPLACE_WIDTH			16
#define DISPLACE_HEIGHT			17
#define DISPLACE_AXIS			18


// Extrude
#define EXTRUDE_AMOUNT			0
#define EXTRUDE_SEGS			1
#define EXTRUDE_CAPSTART		2
#define EXTRUDE_CAPEND			3
#define EXTRUDE_CAPTYPE			4
#define EXTRUDE_OUTPUT			5
#define EXTRUDE_MAPPING			6
#define EXTRUDE_GEN_MATIDS		7
#define EXTRUDE_USE_SHAPEIDS	8
#define EXTRUDE_SMOOTH			9

// Gravity
#define GRAVITY_STRENGTH		0
#define GRAVITY_DECAY			1
#define GRAVITY_TYPE			2
#define GRAVITY_DISPLENGTH		3

// Wind
#define WIND_STRENGTH		0
#define WIND_DECAY			1
#define WIND_TYPE			2
#define WIND_DISPLENGTH		3
#define WIND_TURBULENCE		4
#define WIND_FREQUENCY		5
#define WIND_SCALE			6

// UVW map
#define UVWMAP_MAPTYPE		0
#define UVWMAP_UTILE		1
#define UVWMAP_VTILE		2
#define UVWMAP_WTILE		3
#define UVWMAP_UFLIP		4
#define UVWMAP_VFLIP		5
#define UVWMAP_WFLIP		6
#define UVWMAP_CAP			7
#define UVWMAP_CHANNEL		8
#define UVWMAP_LENGTH		9
#define UVWMAP_WIDTH		10
#define UVWMAP_HEIGHT		11
#define UVWMAP_AXIS			12


// Noise mod
#define NOISEMOD_SEED			0
#define NOISEMOD_SCALE			1
#define NOISEMOD_FRACTAL		2
#define NOISEMOD_ROUGH			3
#define NOISEMOD_ITERATIONS		4
#define NOISEMOD_ANIMATE		5
#define NOISEMOD_FREQ			6
#define NOISEMOD_PHASE			7
#define NOISEMOD_STRENGTH		8

// Optimize
#define OPTMOD_RENDER			0
#define OPTMOD_VIEWS			1
#define OPTMOD_FACETHRESH1		2
#define OPTMOD_EDGETHRESH1		3
#define OPTMOD_BIAS1			4
#define OPTMOD_PRESERVEMAT1		5
#define OPTMOD_PRESERVESMOOTH1	6
#define OPTMOD_MAXEDGE1			7
#define OPTMOD_FACETHRESH2		8
#define OPTMOD_EDGETHRESH2		9
#define OPTMOD_BIAS2			10
#define OPTMOD_PRESERVEMAT2		11
#define OPTMOD_PRESERVESMOOTH2	12
#define OPTMOD_MAXEDGE2			13
#define OPTMOD_AUTOEDGE			14
#define OPTMOD_MANUPDATE		15

// Volume selection modifier
#define VOLSEL_LEVEL	0
#define VOLSEL_METHOD	1
#define VOLSEL_TYPE		2
#define VOLSEL_VOLUME	3
#define VOLSEL_INVERT	4

// Ripple/Wave space warp object and object space modifier
#define RWAVE_AMPLITUDE		0
#define RWAVE_AMPLITUDE2	1
#define RWAVE_WAVELEN		2
#define RWAVE_PHASE			3
#define RWAVE_DECAY			4

#define RWAVE_CIRCLES		5 // These last three are only valid for space warp objects
#define RWAVE_SEGMENTS		6
#define RWAVE_DIVISIONS		7

// Ripple/Wave binding (modifier)
#define RWAVE_FLEX			0

// Skew
#define SKEW_AMOUNT		0
#define SKEW_DIR		1
#define SKEW_AXIS		2
#define SKEW_DOREGION	3
#define SKEW_FROM		4
#define SKEW_TO			5

// Material modifier
#define MATMOD_MATID 0

// Smoothing group modifier
#define SMOOTHMOD_AUTOSMOOTH 	0
#define SMOOTHMOD_THRESHOLD		1
#define SMOOTHMOD_SMOOTHBITS	2

// Normal modifier
#define NORMMOD_UNIFY	0
#define NORMMOD_FLIP 	1

// SurfRev (Lathe) modifier
#define SURFREV_DEGREES			0
#define SURFREV_SEGS			1
#define SURFREV_CAPSTART		2
#define SURFREV_CAPEND			3
#define SURFREV_CAPTYPE			4
#define SURFREV_WELDCORE		5
#define SURFREV_OUTPUT			6
#define SURFREV_MAPPING			7
// Taper 
#define TAPER_AMT			0
#define TAPER_CRV			1
#define TAPER_AXIS			2
#define TAPER_EFFECTAXIS	3
#define TAPER_SYMMETRY		4
#define TAPER_DOREGION		5
#define TAPER_FROM			6
#define TAPER_TO			7

// Twist
#define TWIST_ANGLE		0
#define TWIST_BIAS		1
#define TWIST_AXIS		2
#define TWIST_DOREGION	3
#define TWIST_FROM		4
#define TWIST_TO		5

// Material mod
#define MATMOD_MATID	0

// Smooth mod
#define SMOOTH_AUTOSMOOTH 	0
#define SMOOTH_THRESHOLD	1
#define SMOOTH_SMOOTHBITS	2

// Normal mod
#define NORMALMOD_UNIFY		0
#define NORMALMOD_FLIP 		1

// Tessellation mod
#define TESSMOD_TYPE		0
#define TESSMOD_TENSION		1
#define TESSMOD_ITERATIONS	2
#define TESSMOD_FACE_TYPE	3

// UVW xform
#define UVWXFORM_UTILE		0
#define UVWXFORM_VTILE		1
#define UVWXFORM_WTILE		2
#define UVWXFORM_UOFFSET	3
#define UVWXFORM_VOFFSET	4
#define UVWXFORM_WOFFSET	5
#define UVWXFORM_UFLIP		6
#define UVWXFORM_VFLIP		7
#define UVWXFORM_WFLIP		8
#define UVWXFORM_CHANNEL	9


//-- Text shape object interface -------------------------

// Use GetTextObjectInterface() to get a pointer to an 
// ITextObject given a pointer to an Object. 


// Flags passed to ChangeFont()
#define TEXTOBJ_ITALIC		(1<<1)
#define TEXTOBJ_UNDERLINE	(1<<2)

// Alignment types
#define TEXTOBJ_LEFT 0
#define TEXTOBJ_CENTER 1
#define TEXTOBJ_RIGHT 2
#define TEXTOBJ_JUSTIFIED 3

class ITextObject {
	public:
		// Returns TRUE if string is changed. Can't change string if current font is not installed
		virtual BOOL ChangeText(TSTR string)=0;
		
		// Returns TRUE if font is successfully changed.
		virtual BOOL ChangeFont(TSTR name, DWORD flags)=0;

		// Get fount and string
		virtual TSTR GetFont()=0;
		virtual TSTR GetString()=0;
		
		// Get/Set styles
		virtual BOOL GetItalic()=0;
		virtual BOOL GetUnderline()=0;
		virtual void SetItalic(BOOL sw)=0;
		virtual void SetUnderline(BOOL sw)=0;

		// Get/Set alignment
		virtual BOOL SetAlignment(int type)=0;
		virtual int GetAlignment()=0;
	};



//-- Controller interfaces -------------------------------

// Base key class
class IKey {
	public:
		TimeValue time;
		DWORD flags;
		IKey() {time=0;flags=0;}
	};

//--- TCB keys -------------

class ITCBKey : public IKey {
	public:		
		float tens, cont, bias, easeIn, easeOut;
	};

class ITCBFloatKey : public ITCBKey {
	public:
		float val;		
	};

class ITCBPoint3Key : public ITCBKey {
	public:
		Point3 val;		
	};

class ITCBRotKey : public ITCBKey {
	public:
		AngAxis val;		
	};

class ITCBScaleKey : public ITCBKey {
	public:
		ScaleValue val;		
	};


//--- Bezier keys -------------

class IBezFloatKey : public IKey {
	public:
		float intan, outtan;
		float val;
	};

class IBezPoint3Key : public IKey {
	public:
		Point3 intan, outtan;
		Point3 val;
	};

class IBezQuatKey : public IKey  {
	public:		
		Quat val;
	};

class IBezScaleKey : public IKey  {
	public:
		Point3 intan, outtan;
		ScaleValue val;
	};


//--- Linear Keys --------------

class ILinFloatKey : public IKey {
	public:
		float val;
	};

class ILinPoint3Key : public IKey {
	public:
		Point3 val;
	};

class ILinRotKey : public IKey {
	public:
		Quat val;
	};

class ILinScaleKey : public IKey {
	public:
		ScaleValue val;
	};


// --- Flag bits for keys -------------------------------

// General flags
#define IKEY_SELECTED	(1<<0)
#define IKEY_XSEL		(1<<1)
#define IKEY_YSEL		(1<<2)
#define IKEY_ZSEL		(1<<3)
#define IKEY_FLAGGED	(1<<13)
#define IKEY_TIME_LOCK	(1<<14)

// TCB specific key flags
#define TCBKEY_QUATVALID	(1<<4) // When this bit is set the angle/axis is derived from the quat instead of vice/versa

// Bezier specific key flags
#define BEZKEY_XBROKEN		(1<<4) // Broken means not locked
#define BEZKEY_YBROKEN		(1<<5)
#define BEZKEY_ZBROKEN		(1<<6)

// The in and out types are stored in bits 7-13
#define BEZKEY_NUMTYPEBITS	3
#define BEZKEY_INTYPESHIFT	7
#define	BEZKEY_OUTTYPESHIFT	(BEZKEY_INTYPESHIFT+BEZKEY_NUMTYPEBITS)
#define BEZKEY_TYPEMASK		7

// Bezier tangent types
#define BEZKEY_SMOOTH	0
#define BEZKEY_LINEAR	1
#define BEZKEY_STEP		2
#define BEZKEY_FAST		3
#define BEZKEY_SLOW		4
#define BEZKEY_USER		5

#define NUM_TANGENTTYPES	6

// This key is interpolated using arclength as the interpolation parameter
#define BEZKEY_CONSTVELOCITY	(1<<15)

#define TangentsLocked(f,j) (!(f&(BEZKEY_XBROKEN<<j)))
#define SetTangentLock(f,j,l) {if (l) (f)=(f)&(~(BEZKEY_XBROKEN<<j)); else (f)|=(BEZKEY_XBROKEN<<j);}

// Macros to access hybrid tangent types
#define GetInTanType(f)  int(((f)>>BEZKEY_INTYPESHIFT)&BEZKEY_TYPEMASK)
#define GetOutTanType(f) int(((f)>>BEZKEY_OUTTYPESHIFT)&BEZKEY_TYPEMASK)
#define SetInTanType(f,t)  {(f) = ((f)&(~(BEZKEY_TYPEMASK<<BEZKEY_INTYPESHIFT)))|(t<<BEZKEY_INTYPESHIFT);}
#define SetOutTanType(f,t) {(f) = ((f)&(~(BEZKEY_TYPEMASK<<BEZKEY_OUTTYPESHIFT)))|(t<<BEZKEY_OUTTYPESHIFT);}


// Track flags
#define TFLAG_CURVESEL			(1<<0)
#define TFLAG_RANGE_UNLOCKED	(1<<1)
#define TFLAG_LOOPEDIN			(1<<3)
#define TFLAG_LOOPEDOUT			(1<<4)
#define TFLAG_COLOR				(1<<5)	// Set for Bezier Point3 controlers that are color controllers
#define TFLAG_HSV				(1<<6)	// Set for color controls that interpolate in HSV


//-------------------------------------------------------
// This is an interface into either a TCB or Bezier key
// frame controller. It is up to the client to make sure
// that the IKey* point to a key of the approriate derived
// class based on the ClassID() of the controller.

class IKeyControl {
	public:
		// Total number of keys.
		virtual int GetNumKeys()=0;
		
		// Sets the number of keys allocated. 
		// May add blank keys or delete existing keys
		virtual void SetNumKeys(int n)=0;
		
		// Fill in 'key' with the ith key
		virtual void GetKey(int i,IKey *key)=0;
		
		// Set the ith key
		virtual void SetKey(int i,IKey *key)=0;

		// Append a new key onto the end. Note that the
		// key list will ultimately be sorted by time. Returns
		// the key's index.
		virtual int AppendKey(IKey *key)=0;

		// If any changes are made that would require the keys to be sorted
		// this method should be called.
		virtual void SortKeys()=0;		

		// Access track flags
		virtual DWORD &GetTrackFlags()=0;
	};

// To get a pointer to the above interface given a pointer to a controller
// use the macro defined in animtbl.h: GetKeyControlInterface()

// Access to default key parameters
CoreExport void SetBezierDefaultTangentType(int in, int out);
CoreExport void GetBezierDefaultTangentType(int &in, int &out);

CoreExport void SetTCBDefaultParams(float t, float c, float b, float easeIn, float easeOut);
CoreExport void GetTCBDefaultParams(float &t, float &c, float &b, float &easeIn, float &easeOut);


//-----------------------------------------------------------
// A plug-in can register itself to read a particular APP_DATA 
// chunk when a 3DS file is loaded. If a chunk is encountered
// that matches a registered plug-in, that plug-in will be
// asked to create an instance of itself based on the contents
// of the APP_DATA chunk.

class TriObject;

class ObjectDataReaderCallback {
	public:
		// Chunk name
		virtual char *DataName()=0;

		// Create an instance of an object based on the data and the original mesh object
		virtual Object *ReadData(TriObject *obj, void *data, DWORD len)=0;

		virtual void DeleteThis()=0;
	};
 
CoreExport void RegisterObjectAppDataReader(ObjectDataReaderCallback *cb);
 
CoreExport Object *ObjectFromAppData(TriObject *obj, char *name, void *data, DWORD len);


// Note about 3DS App Data:
// If app data is encountered and no plug-in has registered to
// convert it, then it is just hung off the object (or INode in
// the case of KXP app data).
// For object app data, TriObject's super class and class ID are used
// to identify the chunk and the sub ID is set to 0.
// For node app data, INode's super class and class ID are used
// to identify the chunk and the sub ID is set to 0.
//
// This single MAX app data chunk will contain the entire
// 3DS app data chunk, which may have sub chunks (see IPAS SDK).
// The following routines will aid in parsing 3DS app data.

// Get the ID string out of an XDATA_ENTRY chunk and null terminates it
CoreExport void GetIDStr(char *chunk, char *idstring);

// Returns the offset into 'appd' of the specified chunk 
// or -1 if it is not found
CoreExport int FindAppDataChunk(void *appd, DWORD len, char *idstring);

// Similar to Find, but actually returns a pointer to the chunk
// or NULL if it is not found
CoreExport void *GetAppDataChunk(void *appd, DWORD len, char *idstring);

// Adds the chunk to the appdata chunk, preserving existing chunks.
// 'chunk' should point to the new chunk header followed by its data.
CoreExport int SetAppDataChunk(void **pappd, DWORD &len, void *chunk);

// Deletes a chunk from the appdata while preserving other chunks.
CoreExport int DeleteAppDataChunk(void **pappd, DWORD &len, char *idstring);

// Known sub chunks inside an appdata chunk
#define XDATA_ENTRY		0x8001
#define XDATA_APPNAME	0x8002



//---------------------------------------------------------
// Interface into MAX's default WAV sound object
// use the Interface method GetSoundObject() to get a pointer
// to the current sound object and then use the
// GetWaveSoundInterface() on the result to see if it supports
// this interface.

class IWaveSound {
	public:
		// Retreives the name of the current sound file
		virtual TSTR GetSoundFileName()=0;
		
		// Sets the sound file. This will cause the WAV to
		// be loaded into the tack view. Returns FALSE if
		// the file can't be opened or no wave track exist.
		virtual BOOL SetSoundFileName(TSTR name)=0;

		// Set the time offset for the wave
		virtual void SetStartTime(TimeValue t)=0;

		// Get the time offset for the wave
		virtual TimeValue GetStartTime()=0;		
		virtual TimeValue GetEndTime()=0;
	};


//-----------------------------------------------------------
//
// Access to the boolean object's parameters. Given a pointer to
// an object whose class ID is Class_ID(BOOLOBJ_CLASS_ID,0) or
// NEWBOOL_CLASS_ID, you can cast that pointer to the following
// class.  Note that some options do not work in the old Boolean
// (BOOLOBJ_CLASS_ID), and there is no Optimize parameter in
// the new Boolean.
//

#define BOOLOP_UNION			0
#define BOOLOP_INTERSECTION		1
#define BOOLOP_SUB_AB			2
#define BOOLOP_SUB_BA			3
#define BOOLOP_CUT				4

#define BOOLOP_CUT_REFINE  0
#define BOOLOP_CUT_SEPARATE  1
#define BOOLOP_CUT_REMOVE_IN  2
#define BOOLOP_CUT_REMOVE_OUT  3

#define BOOLUPDATE_ALWAYS		0
#define BOOLUPDATE_SELECTED		1
#define BOOLUPDATE_RENDER		2
#define BOOLUPDATE_MANUAL		3

#define BOOL_ADDOP_REFERENCE 0
#define BOOL_ADDOP_INSTANCE 1
#define BOOL_ADDOP_COPY 2
#define BOOL_ADDOP_MOVE 3

#define BOOL_MAT_NO_MODIFY 0
#define BOOL_MAT_IDTOMAT 1
#define BOOL_MAT_MATTOID 2
#define BOOL_MAT_DISCARD_ORIG 3
#define BOOL_MAT_DISCARD_NEW 4

class IBoolObject : public GeomObject {
public:
	virtual BOOL GetOperandSel(int which)=0;
	virtual void SetOperandSel(int which,BOOL sel)=0;
	virtual int GetBoolOp()=0;
	virtual void SetBoolOp(int op)=0;
	virtual int GetBoolCutType()=0;
	virtual void SetBoolCutType(int ct)=0;
	virtual BOOL GetDisplayResult()=0;
	virtual void SetDisplayResult(BOOL onOff)=0;
	virtual BOOL GetShowHiddenOps()=0;
	virtual void SetShowHiddenOps(BOOL onOff)=0;
	virtual int GetUpdateMode()=0;
	virtual void SetUpdateMode(int mode)=0;
	virtual BOOL GetOptimize()=0;
	virtual void SetOptimize(BOOL onOff)=0;
	virtual void SetOperandA (TimeValue t, INode *node)=0;
	virtual void SetOperandB (TimeValue t, INode *node, INode *boolNode,
		int addOpMethod=0, int matMergeMethod=0, bool *canUndo=NULL)=0;
};

// The boolean object has five references. 2 references to the
// operand objects, 2 references to transform controllers 
// providing a transformation matrix for the 2 operands,
// and one to the parameter block.
#define BOOLREF_OBJECT1		0
#define BOOLREF_OBJECT2		1
#define BOOLREF_CONT1		2
#define BOOLREF_CONT2		3
#define BOOLREF_PBLOCK     4

//-------------------------------------------------------------
// Access to path controller's parameters.
//

class IPathPosition : public Control {
	public:
		virtual BOOL SetPathNode(INode *node)=0;
		virtual void SetFollow(BOOL f)=0;
		virtual BOOL GetFollow()=0;
		virtual void SetBankAmount(float a)=0;
		virtual float GetBankAmount()=0;
		virtual void SetBank(BOOL b)=0;
		virtual BOOL GetBank()=0;
		virtual void SetTracking(float t)=0;		// smoothness
		virtual float GetTracking()=0;
		virtual void SetAllowFlip(BOOL f)=0;
		virtual BOOL GetAllowFlip()=0;
		virtual void SetConstVel(BOOL cv)=0;
		virtual BOOL GetConstVel()=0;
		virtual void SetFlip(BOOL onOff)=0;
		virtual BOOL GetFlip()=0;
		virtual void SetAxis(int axis)=0;
		virtual int GetAxis()=0;
	};

// Bank and tracking are scaled in the UI.
#define BANKSCALE 100.0f
#define FromBankUI(a) ((a)*BANKSCALE)
#define ToBankUI(a)	  ((a)/BANKSCALE)

#define TRACKSCALE 0.04f
#define FromTrackUI(a) ((a)*TRACKSCALE)
#define ToTrackUI(a)   ((a)/TRACKSCALE)

// percent controller, path node and paramblock2 refs
// #define PATHPOS_PERCENT_REF	0    // obsolete in Ed. 2, percent is an animatable in the ParamBlock
#define PATHPOS_PATH_REF	1
#define PATHPOS_PBLOCK_REF	2

//-------------------------------------------------------------
// Access to noise controller's parameters.
// All noise controllers are derived from this class
//

class INoiseControl : public StdControl {
	public:
		virtual void SetSeed(int seed)=0;
		virtual int GetSeed()=0;
		virtual void SetFrequency(float f)=0;
		virtual float GetFrequency()=0;
		virtual void SetFractal(BOOL f)=0;
		virtual BOOL GetFractal()=0;
		virtual void SetRoughness(float f)=0;
		virtual float GetRoughness()=0;
		virtual void SetRampIn(TimeValue in)=0;
		virtual TimeValue GetRampIn()=0;
		virtual void SetRampOut(TimeValue out)=0;
		virtual TimeValue GetRampOut()=0;
		virtual void SetPositiveOnly(int which,BOOL onOff)=0;
		virtual BOOL GetPositiveOnly(int which)=0;
		virtual Control *GetStrengthController()=0;
		virtual void SetStrengthController(Control *c)=0;
	};

//-------------------------------------------------------------
// Access to SurfPosition controller
//

class ISurfPosition : public Control {
	public:
		virtual void SetSurface(INode *node)=0;
		virtual int GetAlign()=0;
		virtual void SetAlign(int a)=0;
		virtual BOOL GetFlip()=0;
		virtual void SetFlip(BOOL f)=0;
	};

// Surface controller references
#define SURFCONT_U_REF			0
#define SURFCONT_V_REF			1
#define SURFCONT_SURFOBJ_REF	2


//-------------------------------------------------------------
// Access to the LinkCtrl
//

class ILinkCtrl : public Control {
	public:
		virtual int GetParentCount()=0;
		virtual TimeValue GetLinkTime(int i)=0;
		virtual void SetLinkTime(int i,TimeValue t)=0;
		virtual void LinkTimeChanged()=0; // call after changing link times
		virtual void AddNewLink(INode *node,TimeValue t)=0;
		virtual void DeleteLink(int i)=0;
	};

// LinkCtrl references
#define LINKCTRL_CONTROL_REF		0	// the TM controller
#define LINKCTRL_FIRSTPARENT_REF	1	// parent nodes... refs 1-n


//-------------------------------------------------------------
// Access to LookatControl
//

class ILookatControl : public Control {
	public:
		virtual void SetFlip(BOOL f)=0;
		virtual BOOL GetFlip()=0;
		virtual void SetAxis(int a)=0;
		virtual int GetAxis()=0;
	};

// References for the lookat controller
#define LOOKAT_TARGET_REF	0
#define LOOKAT_POS_REF		1
#define LOOKAT_ROLL_REF		2
#define LOOKAT_SCL_REF		3


//-------------------------------------------------------------
// Access to FFD modifiers
//

// Can either be casted to IFFDMod<Modifier> or IFFDMod<WSMObject> based on the ClassID
template <class T>
class IFFDMod : public T {
	public:
		virtual int			NumPts()=0;								// number of lattice control points 
		virtual int			NumPtConts()=0;							// number of CP's having controllers
		virtual Control*	GetPtCont(int i)=0;						// get i'th CP controller
		virtual void		SetPtCont(int i,Control *c)=0;			// set i'th CP controller
		virtual Point3		GetPt(int i)=0;							// get i'th CP
		virtual	void		SetPt(int i, Point3 p)=0;				// set i'th CP
		virtual	void		SetGridDim(IPoint3 d) { }				// set the lattice dimensions
		virtual	IPoint3		GetGridDim() { return IPoint3(0,0,0); }	// get the lattice dimensions
		virtual void		AnimateAll() { }						// assign controllers to all CP's				
		virtual	void		Conform() { }							// not valid for WSMObject's
		virtual void		SelectPt(int i, BOOL sel, BOOL clearAll=FALSE) { }
};

//-------------------------------------------------------------
// Access to mesh selections in editable mesh and edit mesh mod
//

#include "namesel.h"

// Selection levels:
#define IMESHSEL_OBJECT 0
#define IMESHSEL_VERTEX 1
#define IMESHSEL_FACE 2
#define IMESHSEL_EDGE 3

class IMeshSelect {
public:
	virtual DWORD GetSelLevel()=0;
	virtual void SetSelLevel(DWORD level)=0;
	virtual void LocalDataChanged()=0;
	virtual BOOL HasWeightedVertSel () { return FALSE; }
	virtual BOOL CanAssignWeightedVertSel () { return FALSE; }
};

class IMeshSelectData {
public:
	virtual BitArray GetVertSel()=0;
	virtual BitArray GetFaceSel()=0;
	virtual BitArray GetEdgeSel()=0;
	
	virtual void SetVertSel(BitArray &set, IMeshSelect *imod, TimeValue t)=0;
	virtual void SetFaceSel(BitArray &set, IMeshSelect *imod, TimeValue t)=0;
	virtual void SetEdgeSel(BitArray &set, IMeshSelect *imod, TimeValue t)=0;

	virtual GenericNamedSelSetList & GetNamedVertSelList ()=0;
	virtual GenericNamedSelSetList & GetNamedEdgeSelList ()=0;
	virtual GenericNamedSelSetList & GetNamedFaceSelList ()=0;

	virtual void GetWeightedVertSel (int nv, float *sel) {}
	virtual void SetWeightedVertSel (int nv, float *sel, IMeshSelect *imod, TimeValue t) {}
};

//-------------------------------------------------------------
// Access to spline selections and operations in SplineShape and EditSplineMod
//

// selection levels defined in splshape.h   

class ISplineSelect					// accessed via GetInterface(I_SPLINESELECT)
{
public:
	virtual DWORD GetSelLevel()=0;
	virtual void SetSelLevel(DWORD level)=0;
	virtual void LocalDataChanged()=0;
};

class ISplineSelectData				// accessed via GetInterface(I_SPLINESELECTDATA)
{
public:
	// access spline sub-object selections, current & named
	virtual BitArray GetVertSel()=0;
	virtual BitArray GetSegmentSel()=0;
	virtual BitArray GetSplineSel()=0;
	
	virtual void SetVertSel(BitArray &set, ISplineSelect *imod, TimeValue t)=0;
	virtual void SetSegmentSel(BitArray &set, ISplineSelect *imod, TimeValue t)=0;
	virtual void SetSplineSel(BitArray &set, ISplineSelect *imod, TimeValue t)=0;

	virtual GenericNamedSelSetList & GetNamedVertSelList ()=0;
	virtual GenericNamedSelSetList & GetNamedSegmentSelList ()=0;
	virtual GenericNamedSelSetList & GetNamedSplineSelList ()=0;
};

enum splineCommandMode { ScmCreateLine, ScmAttach, ScmInsert, ScmConnect, ScmRefine, ScmFillet, ScmChamfer, 
					     ScmBind, ScmRefineConnect, ScmOutline, ScmTrim, ScmExtend, ScmCrossInsert,
						 ScmBreak, ScmUnion, ScmSubtract,  };
enum splineButtonOp    { SopHide, SopUnhideAll, SopDelete, SopDetach, SopDivide, SopCycle,
						 SopUnbind, SopWeld, SopMakeFirst, SopAttachMultiple, SopExplode, SopReverse, 
						 SopClose, SopIntersect, SopMirrorHoriz, SopMirrorVert,
						 SopMirrorBoth, SopSelectByID, };

class ISplineOps				// accessed via GetInterface(I_SPLINEOPS)
{
public:
	// start up interactive command mode, uses mode enum above
	virtual void StartCommandMode(splineCommandMode mode)=0;
	// perform button op, uses op enum above
	virtual void ButtonOp(splineButtonOp opcode)=0;
};

//-------------------------------------------------------------
// Access to spline selections and operations in PatchObject and EditPatchMod
//

// selection levels defined in patchobj.h   

class IPatchSelect					// accessed via GetInterface(I_PATCHSELECT)
{
public:
	virtual DWORD GetSelLevel()=0;
	virtual void SetSelLevel(DWORD level)=0;
	virtual void LocalDataChanged()=0;
};

class IPatchSelectData				// accessed via GetInterface(I_PATCHSELECTDATA)
{
public:
	// access patch sub-object selections, current & named
	virtual BitArray GetVertSel()=0;
	virtual BitArray GetEdgeSel()=0;
	virtual BitArray GetPatchSel()=0;
	
	virtual void SetVertSel(BitArray &set, IPatchSelect *imod, TimeValue t)=0;
	virtual void SetEdgeSel(BitArray &set, IPatchSelect *imod, TimeValue t)=0;
	virtual void SetPatchSel(BitArray &set, IPatchSelect *imod, TimeValue t)=0;

	virtual GenericNamedSelSetList & GetNamedVertSelList ()=0;
	virtual GenericNamedSelSetList & GetNamedEdgeSelList ()=0;
	virtual GenericNamedSelSetList & GetNamedPatchSelList ()=0;
};

enum patchCommandMode { PcmAttach, PcmExtrude, PcmBevel, PcmBind };
enum patchButtonOp    { PopUnbind, PopHide, PopUnhideAll, PopWeld, PopDelete, PopSubdivide,
						PopAddTri, PopAddQuad, PopDetach };

class IPatchOps				// accessed via GetInterface(I_PATCHOPS)
{
public:
	// start up interactive command mode, uses mode enum above
	virtual void StartCommandMode(patchCommandMode mode)=0;
	// perform button op, uses op enum above
	virtual void ButtonOp(patchButtonOp opcode)=0;
};


#endif //__ISTDPLUG__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\linshape.h ===
/**********************************************************************
 *<
	FILE: linshape.h

	DESCRIPTION:  Defines a Linear Shape Object Class

	CREATED BY: Tom Hudson

	HISTORY: created 31 October 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#ifndef __LINSHAPE_H__ 

#define __LINSHAPE_H__

#include "polyshp.h"
extern CoreExport Class_ID  linearShapeClassID; 

class LinearShape : public ShapeObject {			   
	private:
		Interval geomValid;
		Interval topoValid;
		Interval selectValid;
		DWORD validBits; // for the remaining constant channels
		void CopyValidity(LinearShape *fromOb, ChannelMask channels);

	protected:
		//  inherited virtual methods for Reference-management
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message );

	public:
		PolyShape		shape;

		CoreExport LinearShape();
		CoreExport ~LinearShape();

 		//  inherited virtual methods:

		// From BaseObject
		CoreExport int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt);
		CoreExport void Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt);
		CoreExport int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
		CoreExport CreateMouseCallBack* GetCreateMouseCallBack();
		CoreExport RefTargetHandle Clone(RemapDir& remap = NoRemap());
		
		// From Object			 
		CoreExport ObjectState Eval(TimeValue time);
		CoreExport Interval ObjectValidity(TimeValue t);

		// The validity interval of channels necessary to do a convert to type
		CoreExport Interval ConvertValidity(TimeValue t);

		// get and set the validity interval for the nth channel
	   	CoreExport Interval ChannelValidity(TimeValue t, int nchan);
		CoreExport void SetChannelValidity(int i, Interval v);
		CoreExport void InvalidateChannels(ChannelMask channels);

		// Deformable object procs	
		int IsDeformable() { return 1; }  
		CoreExport int NumPoints();
		CoreExport Point3 GetPoint(int i);
		CoreExport void SetPoint(int i, const Point3& p);
		CoreExport BOOL IsPointSelected (int i);
		
		CoreExport void PointsWereChanged();
		CoreExport void GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm=NULL,BOOL useSel=FALSE );
		CoreExport void Deform(Deformer *defProc, int useSel);

		CoreExport int CanConvertToType(Class_ID obtype);
		CoreExport Object* ConvertToType(TimeValue t, Class_ID obtype);
		CoreExport void FreeChannels(ChannelMask chan);
		CoreExport Object *MakeShallowCopy(ChannelMask channels);
		CoreExport void ShallowCopy(Object* fromOb, ChannelMask channels);
		CoreExport void NewAndCopyChannels(ChannelMask channels);

		CoreExport DWORD GetSubselState();

		// From ShapeObject
		CoreExport ObjectHandle CreateTriObjRep(TimeValue t);  // for rendering, also for deformation		
		CoreExport void GetWorldBoundBox(TimeValue t, INode *inode, ViewExp* vpt, Box3& box );
		CoreExport void GetLocalBoundBox(TimeValue t, INode *inode, ViewExp* vpt, Box3& box );
		CoreExport int NumberOfVertices(TimeValue t, int curve);
		CoreExport int NumberOfCurves();
		CoreExport BOOL CurveClosed(TimeValue t, int curve);
		CoreExport Point3 InterpCurve3D(TimeValue t, int curve, float param, int ptype=PARAM_SIMPLE);
		CoreExport Point3 TangentCurve3D(TimeValue t, int curve, float param, int ptype=PARAM_SIMPLE);
		CoreExport float LengthOfCurve(TimeValue t, int curve);
		CoreExport int NumberOfPieces(TimeValue t, int curve);
		CoreExport Point3 InterpPiece3D(TimeValue t, int curve, int piece, float param, int ptype=PARAM_SIMPLE);
		CoreExport Point3 TangentPiece3D(TimeValue t, int curve, int piece, float param, int ptype=PARAM_SIMPLE);
		CoreExport MtlID GetMatID(TimeValue t, int curve, int piece);
		BOOL CanMakeBezier() { return TRUE; }
		CoreExport void MakeBezier(TimeValue t, BezierShape &shape);
		CoreExport ShapeHierarchy &OrganizeCurves(TimeValue t, ShapeHierarchy *hier = NULL);
		CoreExport void MakePolyShape(TimeValue t, PolyShape &shape, int steps = PSHAPE_BUILTIN_STEPS, BOOL optimize = FALSE);
		CoreExport int MakeCap(TimeValue t, MeshCapInfo &capInfo, int capType);
		CoreExport int MakeCap(TimeValue t, PatchCapInfo &capInfo);

		PolyShape& GetShape() { return shape; }

		// This does the job of setting all points in the PolyShape to "POLYPT_KNOT"
		// types, and removing the "POLYPT_INTERPOLATED" flag.  This is because the
		// LinearShape knows nothing about its origin
		CoreExport void SetPointFlags();

		// Animatable methods

		void DeleteThis() { delete this; }
		void FreeCaches() { shape.InvalidateGeomCache(FALSE); }
		Class_ID ClassID() { return linearShapeClassID; }
		CoreExport void GetClassName(TSTR& s);
		void NotifyMe(Animatable *subAnim, int message) {}
		int IsKeyable() { return 0;}
		int Update(TimeValue t) { return 0; }
		BOOL BypassTreeView() { return TRUE; }
		// This is the name that will appear in the history browser.
		CoreExport TCHAR *GetObjectName();

		// IO
		CoreExport IOResult Save(ISave *isave);
		CoreExport IOResult Load(ILoad *iload);

#ifdef DESIGN_VER // should be added to MAX after R3 ships
		// RefMaker methods
		CoreExport void RescaleWorldUnits(float f);
#endif //DESIGN_VER

	};				

CoreExport ClassDesc* GetLinearShapeDescriptor();

#endif // __LINSHAPE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\log.h ===
//-----------------------------------------------------------------------------
// ----------------
// File ....: log.h
// ----------------
// Author...: Gus Grubba
// Date ....: November 1996
//
// History .: Nov, 27 1996 - Started
//
//-----------------------------------------------------------------------------
		
#ifndef ERRORLOG_H_DEFINED
#define ERRORLOG_H_DEFINED

#define NO_DIALOG		FALSE
#define DISPLAY_DIALOG	TRUE

#define	SYSLOG_ERROR	0x00000001
#define	SYSLOG_WARN		0x00000002
#define	SYSLOG_INFO		0x00000004
#define	SYSLOG_DEBUG	0x00000008

#define	SYSLOG_LIFE_EVER	0
#define	SYSLOG_LIFE_DAYS	1
#define	SYSLOG_LIFE_SIZE	2

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//--   Frame   Range
//
	
class LogSys {

		DWORD	valTypes;
		int		logLife;
		DWORD	logDays;
		DWORD	logSize;

	 public:

		//-- Maintenance methods -----------------------------------------------
		//
		//	 Methods used internally

		//-- Queries what log types are enabled

		virtual		DWORD	LogTypes ( ) { return valTypes; }

		//-- Sets what log types are enabled

		virtual		void	SetLogTypes ( DWORD types ) { valTypes = types; }

		//-- Logging methods ---------------------------------------------------
		//
		//	 "type"	defines the type of log entry based on LogTypes above.
		//
		//   "dialogue" is DISPLAY_DIALOGUE if you want the message to be displayed
		//   in a dialogue. The system will determine if displaying a dialogue is
		//   appropriate based on network rendering mode. If this is just some
		//   information you don't want a dialogue for, or if you are handling
		//   the dialogue yourself, just set dialogue to NO_DIALOGUE.
		//
		//
		//   "title" is optional. If non NULL, it will be used to define the module
		//   that originated the log entry (and the title bar in the dialogue).
		//
		//
	 
		virtual		void	LogEntry		( DWORD type, BOOL dialogue, TCHAR *title, TCHAR *text,... ) = 0;

		//-- By turning on quiet mode the log system will not display any dialogues
		//-- even if it is not noetwork rendering.
		//-- The error will only be written to the log file.
		virtual		void	SetQuietMode( bool quiet ) = 0;
		virtual		bool	GetQuietMode( ) = 0;

		//-- Log File Longevity ------------------------------------------------

		virtual		int		Longevity		( )				{ return logLife; }
		virtual		void	SetLongevity	( int type )	{ logLife = type; }
		virtual		DWORD	LogDays			( )				{ return logDays; }
		virtual		DWORD	LogSize			( )				{ return logSize; }
		virtual		void	SetLogDays		( DWORD days ) 	{ logDays = days; }
		virtual		void	SetLogSize		( DWORD size ) 	{ logSize = size; }

		//-- State -------------------------------------------------------------

		virtual		void	SaveState		( void ) = 0;
		virtual		void	LoadState		( void ) = 0;

};

#endif

//-- EOF: log.h ---------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\matrix2.h ===
/**********************************************************************
 *<
	FILE: matrix2.h

	DESCRIPTION: Class definitions for Matrix2

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __MATRIX2__ 

#define __MATRIX2_

#include "ioapi.h"
#include "point2.h"
#include "point3.h"

class Matrix2 {
	Point2& operator[](int i) { return((Point2&)(*m[i]));  }
	Point2& operator[](int i) const { return((Point2&)(*m[i])); }
public:
	float m[3][2];

	// Constructors
	Matrix2(){}	 // NO INITIALIZATION done in this constructor!! (can use Zero or IdentityMatrix)
	Matrix2(BOOL init) { IdentityMatrix(); } // An option to initialize

	DllExport Matrix2(float (*fp)[2]); 
	
    // Data member
    static const Matrix2 Identity;
    
    // Assignment operators
	DllExport Matrix2& operator-=( const Matrix2& M);
	DllExport Matrix2& operator+=( const Matrix2& M); 
	DllExport Matrix2& operator*=( const Matrix2& M);  	// Matrix multiplication

 	// Conversion function
	operator float*() { return(&m[0][0]); }

	// Initialize matrix
	DllExport void IdentityMatrix(); 	// Set to the Identity Matrix
	DllExport void Zero();		// Set all elements to 0

	Point2 GetRow(int i) const { return (*this)[i]; }	
	DllExport void SetRow(int i, Point2 p) { (*this)[i] = p; }

	DllExport Point3 GetColumn(int i);
	DllExport void SetColumn(int i,  Point3 col);
	DllExport Point2 GetColumn2(int i);

	// Access the translation row
	void SetTrans(const Point2 p) { (*this)[2] = p;  }
	void SetTrans(int i, float v) { (*this)[2][i] = v;  }
	Point2 GetTrans() { return (*this)[2]; }
   
	// Apply Incremental transformations to this matrix
	DllExport void Translate(const Point2& p);
	DllExport void Rotate(float angle);  
	// if trans = FALSE the translation component is unaffected:
	DllExport void Scale(const Point2& s, BOOL trans=FALSE);

	// Apply Incremental transformations to this matrix
	// Equivalent to multiplying on the LEFT by transform 
	DllExport void PreTranslate(const Point2& p);
	DllExport void PreRotate(float angle);  
	DllExport void PreScale(const Point2& s, BOOL trans = FALSE);

    // Set matrix as described
    DllExport void SetTranslate(const Point2& s); // makes translation matrix
    DllExport void SetRotate(float angle);        // makes rotation matrix
    DllExport void Invert();
		
	// Binary operators		
	DllExport Matrix2 operator*(const Matrix2& B) const;	
	DllExport Matrix2 operator+(const Matrix2& B) const;
	DllExport Matrix2 operator-(const Matrix2& B) const;

	DllExport IOResult Save(ISave* isave);
	DllExport IOResult Load(ILoad* iload);

	};

// Build new matrices for transformations
Matrix2 DllExport RotateMatrix(float angle);   
Matrix2 DllExport TransMatrix(const Point2& p);
Matrix2 DllExport ScaleMatrix(const Point2& s);
 
Matrix2 DllExport Inverse(const Matrix2& M);

// Transform point with matrix:
Point2 DllExport operator*(const Matrix2& A, const Point2& V);
Point2 DllExport operator*( const Point2& V, const Matrix2& A);
Point2 DllExport VectorTransform(const Matrix2& M, const Point2& V);

// Printout
ostream DllExport &operator<< (ostream& s, const Matrix2& A); 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\macrorec.h ===
/*	
 *		macrorec.h - Interface to MAXScript macro recorder for MAX
 *
 *	The macro recorder 					
 *
 *			Copyright  Autodesk, Inc, 1998.  John Wainwright.
 *
 */

#ifndef _H_MACRORECORD
#define _H_MACRORECORD

#ifndef ScripterExport
#	ifdef BLD_MAXSCRIPT
#		define ScripterExport __declspec( dllexport )
#	else
#		define ScripterExport __declspec( dllimport )
#	endif
#endif

class ParamBlock2;

class MacroRecorder
{
public:
	// script constructors
	virtual BOOL BeginCreate(ClassDesc* cd, int flags = 0) = 0;
	virtual void SetNodeTM(INode* n, Matrix3 m) = 0;
	virtual void ParamBlockSetValue(ParamBlock* pb, int i, BYTE type, ...) = 0;
	virtual void ParamBlock2SetValue(IParamBlock2* pb, int i, int tabIndex, BYTE type, ...) = 0;
	virtual void ParamBlock2SetCount(IParamBlock2* pb, int i, int n) = 0;
	virtual void SetProperty(ReferenceTarget* targ, TCHAR* prop_name, BYTE type, ...) = 0;
	virtual void SetCopy(ReferenceTarget* to_copy) = 0;
	virtual void SetSelProperty(TCHAR* prop_name, BYTE type, ...) = 0;
	virtual void FunctionCall(TCHAR* op_name, int arg_count, int keyarg_count, ...) = 0;
	virtual void ScriptString(TCHAR* s) = 0;
	virtual void Assign(TCHAR* var_name, BYTE type, ...) = 0;
	virtual void Assign(BYTE type, ...) = 0;
	virtual void OpAssign(TCHAR* op, BYTE type, ...) = 0;
	virtual void OperandSequence(int count, BYTE type, ...) = 0;
	virtual BOOL BeginSelectNode() = 0;
	virtual void Select(INode*) = 0;
	virtual void DeSelect(INode*) = 0;
	virtual void MAXCommand(int com) = 0;
	virtual void Cancel() = 0;
	virtual void EmitScript() = 0;
	// scripter info extractors
	virtual TSTR GetSubMtlPropName(Mtl* m, int i) = 0;
	virtual TSTR GetSubTexmapPropName(MtlBase* m, int i) = 0;
	// nestable disable/enable
	virtual void Enable() = 0;
	virtual void Disable() = 0;
	virtual BOOL Enabled() = 0;
	// master enable and option controls
	virtual BOOL MasterEnable() = 0;
	virtual void MasterEnable(BOOL onOff) = 0;
	virtual BOOL ShowCommandPanelSwitch() = 0;
	virtual void ShowCommandPanelSwitch(BOOL onOff) = 0;
	virtual BOOL ShowToolSelections() = 0;
	virtual void ShowToolSelections(BOOL onOff) = 0;
	virtual BOOL ShowMenuSelections() = 0;
	virtual void ShowMenuSelections(BOOL onOff) = 0;
	virtual BOOL EmitAbsoluteSceneNames() = 0;
	virtual void EmitAbsoluteSceneNames(BOOL onOff) = 0;
	virtual BOOL EmitAbsoluteSubObjects() = 0;
	virtual void EmitAbsoluteSubObjects(BOOL onOff) = 0;
	virtual BOOL EmitAbsoluteTransforms() = 0;
	virtual void EmitAbsoluteTransforms(BOOL onOff) = 0;
//	virtual BOOL EmitExplicitCoordinates() = 0;   // deferred in Shiva
//	virtual void EmitExplicitCoordinates(BOOL onOff) = 0;
};
   
#if defined(BLD_CORE) || defined(BLD_PARAMBLK2)
	extern MacroRecorder *macroRecorder;
#else
	extern ScripterExport MacroRecorder *macroRecorder;
#endif

extern ScripterExport void InitMacroRecorder();

// value types:
enum { mr_int, mr_float, mr_string, mr_bool,			// basic C types
	   mr_point3, mr_color, mr_angaxis, mr_quat,		// MAX SDK types...
	   mr_time, mr_reftarg, mr_bitarray, mr_pbbitmap,
	   mr_matrix3, mr_nurbssel, mr_meshselbits, 
	   mr_meshsel, mr_subanim, mr_animatable,
	   mr_classid, mr_nurbsselbits, 
	   mr_sel, mr_funcall, mr_varname, mr_create,		// MAXScript types
	   mr_angle, mr_percent, mr_index, mr_prop,
	   mr_name, 
	   mr_dimfloat, mr_dimpoint3,						// explicitly dimensioned float & point
	};

#define macroRec GetCOREInterface()->GetMacroRecorder()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\maxtess.h ===
/**********************************************************************
 *<
	FILE: maxtess.h

	DESCRIPTION: Tessellation Approximation class

	CREATED BY: Charles Thaeler

	HISTORY: created 12 Dec 1996
			 Updated 12-10-98 Peter Watje to support hidden interior edges

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#ifndef MAXTESS_H
#define MAXTESS_H

typedef enum {
	TESS_SET,		// This is the old MAX form for Bezier Patches
	TESS_ISO,		// This is obsolete and should not be used.
	TESS_PARAM,
	TESS_SPATIAL,
	TESS_CURVE,
	TESS_LDA,
	TESS_REGULAR 
} TessType;

typedef enum {
	ISO_ONLY,
	ISO_AND_MESH,
	MESH_ONLY
} ViewConfig;

typedef enum {
	SUBDIV_TREE,
	SUBDIV_GRID,
	SUBDIV_DELAUNAY
} TessSubdivStyle;

class TessApprox {
public:
	TessType type;
	ViewConfig vpt_cfg;
	TessSubdivStyle subdiv;
	BOOL view;
	float merge;
	int u, v;
	int u_iso, v_iso;
	float ang, dist, edge;
	int minSub, maxSub, maxTris;

//watje 12-10-98
	BOOL showInteriorFaces;

	UtilExport TessApprox();
	UtilExport TessApprox(TessType type, float distance, float edge, float angle,
                          TessSubdivStyle subdivStyle, int minSub, int maxSub,
                          float m = 0.0f);
	UtilExport TessApprox(const TessApprox &tess);
	UtilExport TessApprox & operator=(const TessApprox& tess);
	UtilExport int operator==(const TessApprox &tess) const;


	UtilExport IOResult Load(ILoad* iload);
	UtilExport IOResult Save(ISave* isave);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\max.h ===
/**********************************************************************
 *<
	FILE: Max.h

	DESCRIPTION: Main include file for MAX plug-ins.

	CREATED BY: Rolf Berteig

	HISTORY: Created 10/01/95

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
       
#ifndef STRICT
#define STRICT
#endif

// System includes
#include <strbasic.h>
#include <windows.h>
#include <windowsx.h>
#include <ctl3d.h>
#include <commctrl.h>

// Some standard library includes
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <time.h>

// Defines which version of MAX to build
#include "buildver.h"

// Defines basic MAX types
#include "maxtypes.h"
#include "trig.h"

// Support libraries
#include "utillib.h"
#include "geomlib.h"
#include "gfxlib.h"
#include "meshlib.h"
#include "patchlib.h"

// Core include files
#include "coreexp.h"
#include "winutil.h"
#include "custcont.h"
#include "mouseman.h"
#include "plugin.h"
#include "units.h"
#include "stack.h"   			
#include "interval.h"
#include "hold.h"	
#include "channels.h"
#include "SvCore.h"
#include "animtbl.h"
#include "ref.h"
#include "inode.h"
#include "control.h"
#include "object.h"
#include "objmode.h"
#include "soundobj.h"
#include "iparamb.h"
#include "triobj.h"
#include "patchobj.h"
#include "cmdmode.h"
#include "appio.h"
#include "lockid.h"

// interfaces into MAX executable
#include "maxapi.h"
#include "ioapi.h"
#include "impapi.h"
#include "impexp.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\maxtypes.h ===
/**********************************************************************
 *<
	FILE: jagtypes.h

	DESCRIPTION:  Typedefs for general jaguar types.

	CREATED BY: Rolf Berteig

	HISTORY: created 19 November 1994

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __JAGTYPES__
#define __JAGTYPES__

typedef unsigned long ulong;
typedef unsigned char uchar;
typedef uchar UBYTE;
typedef unsigned short USHORT;
typedef unsigned short UWORD;
														 
struct Color24 { 
	uchar r,g,b;
	};

struct Color48 { 
	UWORD r,g,b;
	};

struct Color64 { 
	UWORD r,g,b,a;
	};

//-- Pixel storage classes used by BitmapManager ----------------------------------------------------

typedef struct {
   BYTE r,g,b;
} BMM_Color_24;

typedef struct {
   BYTE r,g,b,a;
} BMM_Color_32;

typedef struct {
   WORD r,g,b;
} BMM_Color_48;

typedef struct {
   WORD r,g,b,a;
} BMM_Color_64;

/* Time:
 */
typedef int TimeValue;

#define TIME_TICKSPERSEC	4800

#define TicksToSec( ticks ) ((float)(ticks)/(float)TIME_TICKSPERSEC)
#define SecToTicks( secs ) ((TimeValue)(secs*TIME_TICKSPERSEC))
#define TicksSecToTime( ticks, secs ) ( (TimeValue)(ticks)+SecToTicks(secs) )
#define TimeToTicksSec( time, ticks, secs ) { (ticks) = (time)%TIME_TICKSPERSEC; (secs) = (time)/TIME_TICKSPERSEC ; } 

#define TIME_PosInfinity	TimeValue(0x7fffffff)
#define TIME_NegInfinity 	TimeValue(0x80000000)


//-----------------------------------------------------
// Class_ID
//-----------------------------------------------------
class Class_ID {
	ULONG a,b;
	public:
		Class_ID() { a = b = 0xffffffff; }
		Class_ID(const Class_ID& cid) { a = cid.a; b = cid.b;	}
		Class_ID(ulong aa, ulong bb) { a = aa; b = bb; }
		ULONG PartA() { return a; }
		ULONG PartB() { return b; }
		void SetPartA( ulong aa ) { a = aa; } //-- Added 11/21/96 GG
		void SetPartB( ulong bb ) { b = bb; }
		int operator==(const Class_ID& cid) const { return (a==cid.a&&b==cid.b); }
		int operator!=(const Class_ID& cid) const { return (a!=cid.a||b!=cid.b); }
		Class_ID& operator=(const Class_ID& cid)  { a=cid.a; b = cid.b; return (*this); }
	};

// SuperClass ID
typedef ulong SClass_ID;  


// Types used by ISave, ILoad, AppSave, AppLoad 
typedef enum {IO_OK=0, IO_END=1, IO_ERROR=2} IOResult; 
typedef enum {NEW_CHUNK=0, CONTAINER_CHUNK=1, DATA_CHUNK=2} ChunkType;
typedef enum {IOTYPE_MAX=0, IOTYPE_MATLIB=1} FileIOType; 

#ifdef DESIGN_VER
enum TesselationType
{
    kTriangles,
    kQuadrilaterals,
    kTriStrips
};
#endif

#endif // __JAGTYPES__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\maxcom.h ===
/*********************************************************************
 *<
	FILE: #define MAXCOM.h

    DESCRIPTION: Command IDs passed to Interface::Execute#define MAXCOMmand()

	CREATED BY:	Rolf Berteig

	HISTORY: Created 3/13/96

 *>	Copyright (c) 1994 All Rights Reserved.
 **********************************************************************/

#ifndef __MAXCOM__
#define __MAXCOM__

#define MAXCOM_RESET_FILE				0	
#define MAXCOM_TIME_CONFIG				1
#define MAXCOM_UNFREEZE_BY_HIT			2
#define MAXCOM_BOX_TOGGLE				3
#define MAXCOM_CYCLE_SELECT_METHOD		4
#define MAXCOM_ZOOM_OUT_2X_ALL			5
#define MAXCOM_ZOOM_IN_2X_ALL			6
#define MAXCOM_IZOOM_OUT				7
#define MAXCOM_IZOOM_IN					8
#define MAXCOM_IPAN 					9
#define MAXCOM_SHOW_LAST_IMG 			10
#define MAXCOM_APPLY_IK 				11
#define MAXCOM_KEY_MODE 				12
#define MAXCOM_TOGGLE_IK 				13
#define MAXCOM_SHADE_SELECTED 			14
#define MAXCOM_SELECT_BY_COLOR 			15
#define MAXCOM_ZOOMEXT_SEL 				16
#define MAXCOM_ZOOMEXT_SEL_ALL 			17
#define MAXCOM_CREATE_MODE 				18
#define MAXCOM_MODIFY_MODE 				19
#define MAXCOM_HIERARCHY_MODE 			20
#define MAXCOM_MOTION_MODE 				21
#define MAXCOM_DISPLAY_MODE 			22
#define MAXCOM_UTILITY_MODE 			23
#define MAXCOM_TEXTURE_CORRECT 			24
#define MAXCOM_ZOOM_OUT_2X 				25
#define MAXCOM_ZOOM_IN_2X 				26
#define MAXCOM_DEF_LGT_TOGGLE 			27
#define MAXCOM_VPT_SHAPE 				28
#define MAXCOM_GROUP_ATTACH 			29
#define MAXCOM_GROUP_DETACH 			30
#define MAXCOM_PREV_MOD 				31
#define MAXCOM_NEXT_MOD 				32
#define MAXCOM_SAVEPLUS 				33
#define MAXCOM_VIEW_FILE 				34
#define MAXCOM_UNHIDE_BY_NAME 			35
#define MAXCOM_UNFREEZE_BY_NAME 		36
#define MAXCOM_SPINSNAP_TOGGLE 			37
#define MAXCOM_HIDE_INV 				38
#define MAXCOM_FREEZE_INV 				39
#define MAXCOM_UNFREEZE_ALL 			40
#define MAXCOM_WIRE_SMOOTH 				41
#define MAXCOM_WIRE_FACET 				42
#define MAXCOM_BOX_MODE 				43
#define MAXCOM_BACKFACE  				44
#define MAXCOM_TRAJECTORIES 			45
#define MAXCOM_UNHIDE_ALL  				46
#define MAXCOM_SCALE_CYCLE				47
#define MAXCOM_IK_TERMINATOR			48
#define MAXCOM_RENDER_SCENE 			49
#define MAXCOM_RENDER_LAST 				50
#define MAXCOM_QUICK_RENDER 			51
#define MAXCOM_GRID_NUDGE_UP 			52
#define MAXCOM_GRID_NUDGE_DOWN 			53
#define MAXCOM_CYCLE_SUBLEVEL 			54
#define MAXCOM_HIDE_SELECTION 			55
#define MAXCOM_FREEZE_SELECTION 		56
#define MAXCOM_SHADE_TOGGLE				57
#define MAXCOM_MIRROR 					58
#define MAXCOM_ARRAY 					60
#define MAXCOM_ALIGN 					61
#define MAXCOM_ALIGNNORMALS 			62
#define MAXCOM_HOLD  					63
#define MAXCOM_FETCH 					64
#define MAXCOM_SWAP_LAYOUTS 			65
#define MAXCOM_SAFEFRAME_TOGGLE 		66
#define MAXCOM_FILE_MERGE 				67
#define MAXCOM_TIME_BACK 				68
#define MAXCOM_TIME_FORWARD 			69
#define MAXCOM_TIME_PLAY 				70
#define MAXCOM_VIEWS_REDRAW 			71
#define MAXCOM_UNITSETUP				72
#define MAXCOM_DRAWINGAIDS				73
#define MAXCOM_SHOWHOMEGRID				74
#define MAXCOM_ACTHOMEGRID				75
#define MAXCOM_ACTGRIDOBJ				76
#define MAXCOM_GRIDS_ALIGN				77
#define MAXCOM_BACKGROUND				78
#define MAXCOM_SHOWAXISICON				79
#define MAXCOM_FULLINTERACT				80
#define MAXCOM_VPTCONFIG				81
#define MAXCOM_VIDEOPOST				82
#define MAXCOM_PREVIEW					83
#define MAXCOM_VIEWPREVIEW				84
#define MAXCOM_RENAMEPREVIEW			85
#define MAXCOM_TOOL_DUALPLANES 			86
#define MAXCOM_LINK						87
#define MAXCOM_UNLINK					88
#define MAXCOM_BINDWSM					89
#define MAXCOM_SELECT					90
#define MAXCOM_MOVE						91
#define MAXCOM_ROTATE					92
#define MAXCOM_SCALE					93
#define MAXCOM_TREEVIEW					94
#define MAXCOM_MTLEDIT					95
#define MAXCOM_PANVIEW					96
#define MAXCOM_DOLLY					97
#define MAXCOM_PERSP					98
#define MAXCOM_ROLL						99
#define MAXCOM_FOV						100
#define MAXCOM_TRUCK					101
#define MAXCOM_PANCAMERA				102
#define MAXCOM_ANGLE_SNAP_TOGGLE 		103
#define MAXCOM_EDIT_REDO 				104
#define MAXCOM_VIEW_REDO 				105
#define MAXCOM_VPT_TRACK 				106
#define MAXCOM_VPT_BOTTOM 				107
#define MAXCOM_SUBOBJECT_SEL 			108
#define MAXCOM_VPT_CAMERA 				109
#define MAXCOM_VPT_SPOT 				110
#define MAXCOM_HIDE_CAMERA_TOGGLE 		111
#define MAXCOM_VPT_DISABLE 				112
#define MAXCOM_VPT_FRONT 				113
#define MAXCOM_VPT_GRID 				114
#define MAXCOM_GRID_TOGGLE 				115
#define MAXCOM_TOOL_HLIST 				116
#define MAXCOM_HIDE_HELPER_TOGGLE 		117
#define MAXCOM_VPT_ISO_USER 			118
#define MAXCOM_VPT_BACK 				119
#define MAXCOM_VPT_LEFT 				120
#define MAXCOM_HIDE_LIGHT_TOGGLE 		121
#define MAXCOM_TOOL_ANIMMODE 			122
#define MAXCOM_FILE_NEW 				123
#define MAXCOM_OVERRIDE 				124
#define MAXCOM_FILE_OPEN 				125
#define MAXCOM_HIDE_OBJECT_TOGGLE 		126
#define MAXCOM_VPT_PERSP_USER 			127
#define MAXCOM_ACCEL_PAN 				128
#define MAXCOM_HIDE_SHAPE_TOGGLE 		129
#define MAXCOM_VPT_RIGHT 				130
#define MAXCOM_ROTATEVIEW 				131
#define MAXCOM_SNAP_TOGGLE 				132
#define MAXCOM_FILE_SAVE 				133
#define MAXCOM_FILE_SAVEAS 				134
#define MAXCOM_FILE_IMPORT 				135
#define MAXCOM_FILE_PREFERENCES			136
#define MAXCOM_HIDE_SYSTEM_TOGGLE 		137
#define MAXCOM_VPT_TOP 					138
#define MAXCOM_EDIT_DELETE 				139
#define MAXCOM_EDIT_SELECTALL			140
#define MAXCOM_EDIT_SELECTNONE			141
#define MAXCOM_EDIT_SELECTINVERT		142
#define MAXCOM_RNS						143
#define MAXCOM_TTI						144
#define MAXCOM_PROPERTIES				145
#define MAXCOM_GROUP_GROUP				146
#define MAXCOM_GROUP_OPEN				147
#define MAXCOM_GROUP_CLOSE				148
#define MAXCOM_GROUP_UNGROUP			149
#define MAXCOM_TIME_END 				150
#define MAXCOM_HELP_ABOUT 				151
#define MAXCOM_TOOL_X 					152
#define MAXCOM_TOOL_Y 					153
#define MAXCOM_TOOL_Z 					154
#define MAXCOM_TOOL_XY 					155
#define MAXCOM_TIME_START 				156
#define MAXCOM_SELECT_CHILD 			157
#define MAXCOM_SELECT_PARENT 			158
#define MAXCOM_SPACEBAR 				159
#define MAXCOM_TOOL_MAXIMIZE 			160
#define MAXCOM_TOOL_ZOOMREGION 			161
#define MAXCOM_HIDE_WSM_TOGGLE 			162
#define MAXCOM_TOOL_CENTER 				163
#define MAXCOM_TOOL_ZOOM 				164
#define MAXCOM_TOOL_ZOOMALL				165
#define MAXCOM_EDIT_UNDO 				166
#define MAXCOM_TOOL_ZOOMEXTENTS 		167
#define MAXCOM_VIEWS_UNDO 				168
#define MAXCOM_TOOL_ZOOMEXTENTS_ALL 	169
#define MAXCOM_TOGGLE_SOUND 			170
#define MAXCOM_VPT_TAB 					171
#define MAXCOM_VPT_SHIFTTAB 			172
#define MAXCOM_CONFIGURE_PATHS 			173
#define MAXCOM_ADAPTIVE_PERSP_GRID_TOGGLE	174
#define	MAXCOM_TOOL_EDIT_MOD_STACK		175
#define	MAXCOM_TOOL_EDGES_ONLY_TOGGLE	176
#define	MAXCOM_PERCENT_SNAP_TOGGLE		177
#define	MAXCOM_SNAPMODE_TOGGLE			178
#define	MAXCOM_RENDER_ATMOSPHERE		179
#define	MAXCOM_VIEWS_SAVEACTIVEVIEW		180
#define	MAXCOM_VIEWS_RESTOREACTIVEVIEW	181
#define	MAXCOM_VIEWS_SHOWDEP			182
#define	MAXCOM_FILE_EXPORT				183
#define	MAXCOM_EDIT_PLACEHIGHLIGHT		184
#define	MAXCOM_EDIT_SNAPSHOT			185
#define	MAXCOM_TOOL_REGION_TOGGLE		186
#define	MAXCOM_FILE_SUMMARYINFO			187
#define MAXCOM_SCHEMATICVIEW			188
#define MAXCOM_GROUP_EXPLODE			189
#define MAXCOM_FILE_SAVESELECTED		190
#define MAXCOM_FILE_XREFOBJECT			191
#define MAXCOM_FILE_XREFSCENE			192
#define MAXCOM_FILE_REPLACE				193
#define MAXCOM_FILE_INSERTTRACKS		194
#define MAXCOM_FILE_EXPORTSELECTED		195
#define MAXCOM_FILE_ARCHIVE				196
#define MAXCOM_TOOLS_DISPLAYFLOATER		197
#define MAXCOM_TOOLS_SELECTIONFLOATER	198
#define MAXCOM_TOOLS_ALIGNCAMERA		199
#define MAXCOM_TOOLS_ALIGNTOVIEW		200
#define MAXCOM_TOOLS_MTLMAPBROWSER		201
#define MAXCOM_TOOLS_SPACINGTOOL		202
#define MAXCOM_CUSTOMIZE_LOADCUI		203
#define MAXCOM_CUSTOMIZE_SAVECUIAS		204
#define MAXCOM_CUSTOMIZE_LOCKUILAYOUT	205
#define MAXCOM_CUSTOMIZE_REVERTCUI		206
#define MAXCOM_CUSTOMIZE_CUSTOMIZEUI	207
#define MAXCOM_KEYMODE_TOGGLE			208
#define MAXCOM_WINDOWCROSSING_TOGGLE	209
#define MAXCOM_KBDSHORTCUT_TOGGLE		210
#define MAXCOM_HIDE_FLOATERS			211
#define MAXCOM_HIDE_CMD_PAN				212
#define MAXCOM_HIDE_SHELF				213
#define MAXCOM_HIDE_MAIN_TB				214

#ifdef DESIGN_VER
#define MAXCOM_PRS_VIEWS_GRIDSETUP      220
#define MAXCOM_PRS_VIEWS_UNITSETUP      221
#endif

// these commands are API extensions, not macros
#define MAXCOM_API_START				10000
#define MAXCOM_API_PVW_GRID_OFF			10000
#define MAXCOM_API_PVW_GRID_ON			10001
#define MAXCOM_API_PVW_SMOOTH_MODE		10002
#define MAXCOM_API_PVW_FACET_MODE		10003
#define MAXCOM_API_PVW_WIRE_MODE		10004

										  
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\matrix3.h ===
/**********************************************************************
 *<
	FILE: matrix3.h

	DESCRIPTION: Class definitions for Matrix3

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#ifndef _MATRIX3_H 

#define _MATRIX3_H 

#include "ioapi.h"
#include "point3.h"
#include "point4.h"

//Flags
#define POS_IDENT  1
#define ROT_IDENT  2
#define SCL_IDENT  4
#define MAT_IDENT (POS_IDENT|ROT_IDENT|SCL_IDENT)

typedef float MRow[3];

class Quat;
class AngAxis;

class Matrix3 {
	friend Matrix3 DllExport RotateXMatrix(float angle);   
	friend Matrix3 DllExport RotateYMatrix(float angle); 
	friend Matrix3 DllExport RotateZMatrix(float angle); 
	friend Matrix3 DllExport TransMatrix(const Point3& p);
	friend Matrix3 DllExport ScaleMatrix(const Point3& s);
	friend Matrix3 DllExport RotateYPRMatrix(float Yaw, float Pitch, float Roll);
	friend Matrix3 DllExport RotAngleAxisMatrix(Point3& axis, float angle);
	friend Matrix3 DllExport Inverse(const Matrix3& M);
	friend Point3 DllExport operator*(const Matrix3& A, const Point3& V);
	friend Point3 DllExport operator*(const Point3& V, const Matrix3& A);
	friend Point3 DllExport VectorTransform(const Matrix3& M, const Point3& V); 
	friend Matrix3 DllExport XFormMat(const Matrix3& xm, const Matrix3& m);
    friend Point3 DllExport VectorTransform(const Point3& V, const Matrix3& M);
	friend class Quat;
	float m[4][3];
	// Access i-th row as Point3 for read or assignment:
	Point3& operator[](int i) { return((Point3&)(*m[i]));  }
	DWORD flags;

public:
	const Point3& operator[](int i) const { return((Point3&)(*m[i])); }
	// if change any components directly via GetAddr, must call this
	void SetNotIdent() { flags &= ~MAT_IDENT; }
	void SetIdentFlags(DWORD f) { flags &= ~MAT_IDENT; flags |= f; }
	DWORD GetIdentFlags() const { return flags; }
	void ClearIdentFlag(DWORD f) { flags &= ~f; }
	BOOL IsIdentity() const { return ((flags&MAT_IDENT)==MAT_IDENT); }
	DllExport void ValidateFlags(); // recomputes the IDENT flags

	// CAUTION: if you change the matrix via this pointer, you MUST clear the
	// proper IDENT flags !!!
	MRow* GetAddr() { return (MRow *)(m); }
	const MRow* GetAddr() const { return (MRow *)(m); }

	// Constructors
	Matrix3(){ flags = 0; }	 // NO INITIALIZATION done in this constructor!! 				 
	Matrix3(BOOL init) {flags=0; IdentityMatrix();} // RB: An option to initialize
	DllExport Matrix3(float (*fp)[3]);
    Matrix3(const Point3& U, const Point3& V, const Point3& N, const Point3& T) {
        flags = 0; SetRow(0, U); SetRow(1, V); SetRow(2, N); SetRow(3, T);
        ValidateFlags(); }

    Matrix3& Set(const Point3& U, const Point3& V, const Point3& N, const Point3& T) {
        flags = 0; SetRow(0, U); SetRow(1, V); SetRow(2, N); SetRow(3, T);
        ValidateFlags(); return *this; }

    // Data member
    static const Matrix3 Identity;

    // Comparison operators
    DllExport int operator==(const Matrix3& M) const;
    DllExport int Equals(const Matrix3& M, float epsilon = 1E-6f) const;

	// Assignment operators
	DllExport Matrix3& operator-=( const Matrix3& M);
	DllExport Matrix3& operator+=( const Matrix3& M); 
	DllExport Matrix3& operator*=( const Matrix3& M);  	// Matrix multiplication

	// Operations on matrix
	DllExport void IdentityMatrix(); 		// Make into the Identity Matrix
	DllExport void Zero();		// set all elements to 0
	
	Point3 GetRow(int i) const { return (*this)[i]; }	
	DllExport void SetRow(int i, Point3 p);

	DllExport Point4 GetColumn(int i) const;
	DllExport void SetColumn(int i,  Point4 col);
	DllExport Point3 GetColumn3(int i) const;

	// zero the translation part;
	DllExport void NoTrans();
	// null out the rotation part;
	DllExport void NoRot();
	// null out the scale part;
	DllExport void NoScale();
	
	// This is an "unbiased" orthogonalization
	// It seems to take a maximum of 4 iterations to converge.
	DllExport void Orthogonalize();

	// Access the translation row
	void SetTrans(const Point3 p) { (*this)[3] = p;  flags &= ~POS_IDENT; }
	void SetTrans(int i, float v) { (*this)[3][i] = v; flags &= ~POS_IDENT; }
	Point3 GetTrans() const { return (*this)[3]; }
   
	// Apply Incremental transformations to this matrix
	// Equivalent to multiplying on the RIGHT by transform
	DllExport void Translate(const Point3& p);
	DllExport void RotateX(float angle);  
	DllExport void RotateY(float angle);
	DllExport void RotateZ(float angle);
	// if trans = FALSE the translation component is unaffected:
	DllExport void Scale(const Point3& s, BOOL trans = FALSE);

	// Apply Incremental transformations to this matrix
	// Equivalent to multiplying on the LEFT by transform 
	DllExport void PreTranslate(const Point3& p);
	DllExport void PreRotateX(float angle);  
	DllExport void PreRotateY(float angle);
	DllExport void PreRotateZ(float angle);
	// if trans = FALSE the translation component is unaffected:
	DllExport void PreScale(const Point3& s, BOOL trans = FALSE);

    // set matrix as described
    DllExport void SetTranslate(const Point3& p);     // makes translation matrix
    DllExport void SetRotateX(float angle);           // makes rotation matrix
    DllExport void SetRotateY(float angle);
    DllExport void SetRotateZ(float angle);
    DllExport void SetRotate(const Quat& q);
    DllExport void SetRotate(const AngAxis& aa);
    DllExport void SetRotate(float yaw, float pitch, float roll);
    DllExport void SetAngleAxis(const Point3& axis, float angle);
    DllExport void SetScale(const Point3& s);          // makes scale matrix
    DllExport void SetFromToUp(const Point3& from, const Point3& to, const Point3& up);
    DllExport void Invert();                          // in place
		
    //binary operators
	DllExport Matrix3 operator*(const Matrix3&) const;
	DllExport Matrix3 operator+(const Matrix3&) const;
	DllExport Matrix3 operator-(const Matrix3&) const;

    DllExport Point3 PointTransform(const Point3& p) const;
    DllExport Point3 VectorTransform(const Point3& p) const;
    DllExport void TransformPoints(Point3 *array, int n,
                int stride = sizeof(Point3));
    DllExport void TransformPoints(const Point3 *array, Point3 *to, int n,
                int stride = sizeof(Point3), int strideTo = sizeof(Point3));
    DllExport void TransformVectors(Point3 *array, int n,
                int stride = sizeof(Point3));
    DllExport void TransformVectors(const Point3 *array, Point3 *to, int n,
                int stride = sizeof(Point3), int strideTo = sizeof(Point3));

    // Property function
    DllExport void GetYawPitchRoll(float *yaw, float *pitch, float *roll);

    // I/O
	DllExport IOResult Save(ISave* isave);
	DllExport IOResult Load(ILoad* iload);

	// Returns FALSE if right handed (normal case) and TRUE if right handed.
	DllExport BOOL Parity() const;
	};


// Build new matrices for transformations
Matrix3 DllExport RotateXMatrix(float angle);   
Matrix3 DllExport RotateYMatrix(float angle); 
Matrix3 DllExport RotateZMatrix(float angle); 
Matrix3 DllExport TransMatrix(const Point3& p);
Matrix3 DllExport ScaleMatrix(const Point3& s);
Matrix3 DllExport RotateYPRMatrix(float Yaw, float Pitch, float Roll);
Matrix3 DllExport RotAngleAxisMatrix(Point3& axis, float angle);
 
Matrix3 DllExport Inverse(const Matrix3& M);  // return Inverse of matrix

// These two versions of transforming a point with a matrix do the same thing,
// regardless of the order of operands (linear algebra rules notwithstanding).
Point3 DllExport operator*(const Matrix3& A, const Point3& V); // Transform Point with matrix
Point3 DllExport operator*(const Point3& V, const Matrix3& A); // Transform Point with matrix

// ditto
Point3 DllExport VectorTransform(const Matrix3& M, const Point3& V); 
Point3 DllExport VectorTransform(const Point3& V, const Matrix3& M); 

// transform a plane: this only works if M is orthogonal
Point4 DllExport TransformPlane(const Matrix3& M, const Point4& plin); 

// transformats matrix m so it is applied in the space of matrix xm:
//  returns xm*m*Inverse(xm)
Matrix3 DllExport XFormMat(const Matrix3& xm, const Matrix3& m);

#endif _MATRIX3_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\maxapi.h ===
/*********************************************************************
 *<
	FILE: maxapi.h

	DESCRIPTION: These are functions that are exported from the 
	             3DS MAX executable.

	CREATED BY:	Rolf Berteig

	HISTORY: Created 28 November 1994

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __JAGAPI__
#define __JAGAPI__

#include <ole2.h>
#include "cmdmode.h"
#include "sceneapi.h"
#include "rtclick.h"
#include "evuser.h"
#include "maxcom.h"
#include "plugin.h"
#include "log.h"

class ViewParams;
class ModContext;
class HitData;
class HitLog;
class CtrlHitLog;
class MtlBase;
class Mtl;
class Texmap;
class PickNodeCallback;
class Renderer;
class RendParams;
class RendProgressCallback;
class Bitmap;
class BitmapInfo;
class Texmap;
class SoundObj;
class GenCamera;
class GenLight;
class NameTab;
class ShadowType;
class MacroRecorder;
class CommandLineCallback;

// From KbdShortcut.h
class ShortcutTable;
class ShortcutCallback;
typedef long ShortcutTableId;

#ifdef _OSNAP
class IOsnapManager;
class MouseManager;
#endif
class MtlBaseLib;
class Atmospheric;
class IRollupWindow;
class ITrackViewNode;
class DllDir;
class Effect;
class SpaceArrayCallback;

// RB: I didn't want to include render.h here
#ifndef _REND_TYPE_DEFINED
#define _REND_TYPE_DEFINED
enum RendType { 
	RENDTYPE_NORMAL,
	RENDTYPE_REGION,
	RENDTYPE_BLOWUP,
	RENDTYPE_SELECT,
	RENDTYPE_REGIONCROP
	};
#endif

// values for dupAction, passed into MergeFromFile
#define MERGE_DUPS_PROMPT 0    // prompt user when duplicates encountered
#define MERGE_DUPS_MERGE  1	   // merge new, keep old when duplicates encountered
#define MERGE_DUPS_SKIP   2    // skip duplicates
#define MERGE_DUPS_DELOLD 3    // delete old when duplicates encountered
#define MERGE_LIST_NAMES  4    // Causes a list of objects in the file to be 
							   // placed into mrgList. No actual merging will be done. mergeAll must be TRUE.

// CCJ: Property Set definitions
// For internal reasons these must be bitflags
#define PROPSET_SUMMARYINFO		0x01
#define PROPSET_DOCSUMMARYINFO	0x02
#define PROPSET_USERDEFINED		0x04

// Interface::Execute cmd values
#define  I_EXEC_ACTIVATE_TEXTURE    1  //	arg1:  Texmap *tx;	arg2:  Mtl *mtl; arg3:  int subnum;
#define  I_EXEC_DEACTIVATE_TEXTURE  2  //	arg1:  Texmap *tx;	arg2:  Mtl *mtl; arg3:  int subnum;
#ifdef DESIGN_VER
#define  I_EXEC_OFFSET_SPLINE   80     //   arg1:  INode *spline; arg2: float amount;
#define  I_EXEC_OFFSET_MEASURE  81     //   arg1:  INode *spline; arg2: Point3 *point; arg3: float *result;
#define  I_EXEC_TRIM_EXTEND     82     //   arg1:  INodeTab *all; arg2: INodeTab *act;
#define  I_EXEC_NEW_OBJ_XREF_DLG 83    //   arg1:  INodeTab *nodes; arg2: BOOL forceSingle;
#define  I_EXEC_SET_DISABLED_COLOR 84  //   arg1:  COLORREF 
#endif

#define I_EXEC_COUNT_MTL_SCENEREFS  0x2001 // arg1 Mtl *mt: returns number of refs from scene 

// Interface::Execute return values
#ifdef DESIGN_VER
#define I_EXEC_RET_NULL_NODE    1
#define I_EXEC_RET_NULL_OBJECT  2
#define I_EXEC_RET_NOT_SPLINE   3
#endif
#define I_EXEC_RET_OFFSET_FAIL  4

// Extension ID's for the Interface class: GetInterface()
#ifdef DESIGN_VER //_COMMANDLINE
#define I_COMMANDLINE	0x2001
#define GetCommandLineInterface(i) i->GetInterface(I_COMMANDLINE)
#endif // DESIGN_VER //_COMMANDLINE

class NameMaker {
	public:
		virtual void MakeUniqueName(TSTR &name)=0;
		virtual void AddName(TSTR &name) = 0;
        virtual BOOL NameExists(TSTR& name) = 0;
        virtual ~NameMaker() {}
	};


//JH 05/06/98 
// VIEW_OTHER must be last, since "other" types are then numbered consecutively!!!
// And the order can't be changed, or old MAX files won't load properly DB 11/98
enum ViewType { VIEW_LEFT,VIEW_RIGHT,VIEW_TOP,VIEW_BOTTOM,VIEW_FRONT,VIEW_BACK, 
	VIEW_ISO_USER, VIEW_PERSP_USER, VIEW_CAMERA, VIEW_GRID, VIEW_NONE, VIEW_TRACK, 
	VIEW_SPOT, VIEW_SHAPE, VIEW_SCHEMATIC, VIEW_OTHER};


// class for registering a window that can appear in a MAX viewport DB 10/6/98
class ViewWindow {
public:
	virtual TCHAR *GetName()=0;
	virtual HWND CreateViewWindow(HWND hParent, int x, int y, int w, int h)=0;
	virtual void DestroyViewWindow(HWND hWnd)=0;
	// CanCreate can be overridden to return FALSE if a ViewWindow can only have
	// a single instance, and that instance is already present.  If CanCreate
	// returns FALSE, then the menu item for this ViewWindow will be grayed out.
	virtual BOOL CanCreate() { return TRUE; }
};

// class for accessing the TrackBar (the Mini TrackView)
#define TRACKBAR_FILTER_ALL			1
#define TRACKBAR_FILTER_TMONLY		2
#define TRACKBAR_FILTER_CURRENTTM	3
#define TRACKBAR_FILTER_OBJECT		4
#define TRACKBAR_FILTER_MATERIAL	5

class ITrackBar {
public:
	virtual void		SetVisible(BOOL bVisible) = 0;
	virtual BOOL		IsVisible() = 0;
	virtual void		SetFilter(UINT nFilter) = 0;
	virtual UINT		GetFilter() = 0;
	virtual TimeValue	GetNextKey(TimeValue tStart, BOOL bForward) = 0;
	};

// This class provides functions that expose the portions of View3D
// that are exported for use by plug-ins.
class ViewExp {
	public:
		virtual Point3 GetPointOnCP(const IPoint2 &ps)=0;
		virtual Point3 SnapPoint(const IPoint2 &in, IPoint2 &out, Matrix3 *plane2d = NULL, DWORD flags = 0)=0;
#ifdef _OSNAP
		virtual void SnapPreview(const IPoint2 &in, IPoint2 &out, Matrix3 *plane2d = NULL, DWORD flags = 0)=0;
		virtual void GetGridDims(float *MinX, float *MaxX, float *MinY, float *MaxY) = 0;
#endif							  
		virtual float SnapLength(float in)=0;
		virtual float GetCPDisp(const Point3 base, const Point3& dir, 
                        const IPoint2& sp1, const IPoint2& sp2, BOOL snap = FALSE )=0;
		virtual GraphicsWindow *getGW()=0;
		virtual int IsWire()=0;
		virtual Rect GetDammageRect()=0;		

		virtual Point3 MapScreenToView( IPoint2& sp, float depth )=0;
		virtual void MapScreenToWorldRay(float sx, float sy, Ray& ray)=0;

		// set the affine tm for the view and ret TRUE if the view is ISO_USER or PERSP_USER
		// else do nothing and return FALSE
		virtual BOOL SetAffineTM(const Matrix3& m)=0;
		virtual void GetAffineTM( Matrix3& tm )=0;
		virtual int GetViewType() = 0;
		virtual BOOL IsPerspView()=0;
		virtual float GetFOV()=0;
		virtual float GetFocalDist()=0;
		virtual float GetScreenScaleFactor(const Point3 worldPoint)=0;

		// return the viewPort screen width factor in world space at 
		// a point in world space
		virtual float GetVPWorldWidth(const Point3 wPoint)=0;
		virtual Point3 MapCPToWorld(const Point3 cpPoint)=0;
		virtual void GetConstructionTM( Matrix3 &tm )=0;
		virtual void SetGridSize( float size )=0;
		virtual float GetGridSize()=0;
		virtual BOOL IsGridVisible()=0;
		virtual int GetGridType()=0;

		// Get the camera if there is one.
		virtual INode *GetViewCamera()=0;

		// Set this viewport to a camera view
		virtual void SetViewCamera(INode *camNode)=0;

		// Set this viewport to a user view 
		virtual void SetViewUser(BOOL persp)=0;

		// Get the spot if there is one
		virtual INode *GetViewSpot()=0;

		// Set this viewport to a spotlight view
		virtual void SetViewSpot(INode *spotNode)=0;

		// node level hit-testing
		virtual void ClearHitList()=0;
		virtual INode *GetClosestHit()=0;
		virtual INode *GetHit(int i)=0;
		virtual int HitCount()=0;
		// subobject level hit-testing
		virtual	void LogHit(INode *nr, ModContext *mc, DWORD dist, ulong info, HitData *hitdat = NULL)=0;		
		virtual HitLog&	GetSubObjHitList()=0;
		virtual void ClearSubObjHitList()=0;
		virtual int NumSubObjHits()=0;

		// For controller apparatus hit testing
		virtual void CtrlLogHit(INode *nr,DWORD dist,ulong info,DWORD infoExtra)=0;
		virtual CtrlHitLog&	GetCtrlHitList()=0;
		virtual void ClearCtrlHitList()=0;
		
		virtual float NonScalingObjectSize()=0;  // 1.0 is "default"

		// Turn on and off image background display
		virtual BOOL setBkgImageDsp(BOOL onOff)=0;
		virtual int	getBkgImageDsp(void)=0;		

		// Turn on and off safe frame display
		virtual void setSFDisplay(int onOff)=0;
		virtual int getSFDisplay(void)=0;

		// This is the window handle of the viewport. This is the
		// same window handle past to GetViewport() to get a ViewExp*
		virtual HWND GetHWnd()=0;

		// Test if the viewport is active
		virtual	BOOL IsActive() = 0;
		// Test if the viewport is enabled
		virtual	BOOL IsEnabled() = 0;

		//methods for floating grids
		virtual void TrackImplicitGrid(IPoint2 m, Matrix3* mat = NULL) = 0;
		virtual void CommitImplicitGrid(IPoint2 m, int mouseflags, Matrix3* mat = NULL) = 0;
		virtual void ReleaseImplicitGrid() = 0;

		// Generic expansion function
		virtual int Execute(int cmd, ULONG arg1=0, ULONG arg2=0, ULONG arg3=0) { return 0; } 
	};


// return values for CreateMouseCallBack
#define CREATE_CONTINUE 1
#define CREATE_STOP	0	    // creation terminated normally
#define CREATE_ABORT -1		// delete the created object and node


// This is a specific call-back proc for handling the creation process
// of a plug-in object.
// The vpt passed in will have had setTransform called with the 
// transform of the current construction plane.
class CreateMouseCallBack {
	public:
		virtual int proc( 
			ViewExp *vpt,
			int msg, 
			int point, 
			int flags, 
			IPoint2 m,
			Matrix3& mat
			)=0;
		virtual int override(int mode) { return mode; }	// Defaults to mode supplied

        // Tells the system that we aren't starting a new creation
        virtual BOOL StartNewCreation() { return TRUE; }

		//Tells the system if ortho mode makes sense for this creation
		//In general this won't be true but splines and such...
		virtual BOOL TolerateOrthoMode() {	return FALSE; }
	};


class Object;
class ConstObject;
class MouseCallBack;
class IObjCreate;
class IObjParam;
class ModContext;
class ModContextList;
class INodeTab;

// Passed to getBkgFrameRange()
#define VIEWPORT_BKG_START			0
#define VIEWPORT_BKG_END			1

// Passed to setBkgORType().
#define VIEWPORT_BKG_BLANK			0
#define VIEWPORT_BKG_HOLD			1
#define VIEWPORT_BKG_LOOP			2

// Passed to setBkgImageAspect()
#define VIEWPORT_BKG_ASPECT_VIEW	0
#define VIEWPORT_BKG_ASPECT_BITMAP	1
#define VIEWPORT_BKG_ASPECT_OUTPUT	2


// Identify the transform tool buttons
#define MOVE_BUTTON		1
#define ROTATE_BUTTON	2
#define NUSCALE_BUTTON	3
#define USCALE_BUTTON	4
#define SQUASH_BUTTON	5
#define SELECT_BUTTON	6

// Axis constraints.
#define AXIS_XY		2
#define AXIS_ZX		1
#define AXIS_YZ		0
#define AXIS_X		3
#define AXIS_Y		4
#define AXIS_Z		5

// Origin modes		
#define ORIGIN_LOCAL		0	// Object's pivot
#define ORIGIN_SELECTION	1	// Center of selection set (or center of individual object for local or parent space)
#define ORIGIN_SYSTEM		2	// Center of the reference coord. system

// Reference coordinate system
#define COORDS_HYBRID	0
#define COORDS_SCREEN	1
#define COORDS_WORLD	2
#define COORDS_PARENT	3
#define COORDS_LOCAL	4
#define COORDS_OBJECT	5

// Task Modes
#define TASK_MODE_CREATE		1
#define TASK_MODE_MODIFY		2
#define TASK_MODE_HIERARCHY		3
#define TASK_MODE_MOTION		4
#define TASK_MODE_DISPLAY		5
#define TASK_MODE_UTILITY		6

// Max cursors
#define SYSCUR_MOVE			1
#define SYSCUR_ROTATE		2
#define SYSCUR_USCALE		3
#define SYSCUR_NUSCALE		4
#define SYSCUR_SQUASH		5
#define SYSCUR_SELECT		6
#define SYSCUR_DEFARROW		7
#define SYSCUR_MOVE_SNAP	8

// flags to pass to RedrawViews
#define REDRAW_BEGIN		(1<<0)
#define REDRAW_INTERACTIVE	(1<<1)
#define REDRAW_END			(1<<2)
#define REDRAW_NORMAL		(1<<3)

// Return values for GetNumAxis()
#define NUMAXIS_ZERO		0 	// Nothing to transform
#define NUMAXIS_ALL			1	// Use only one axis.
#define NUMAXIS_INDIVIDUAL	2	// Do all, one at a time

// MAX Directories
#define APP_FONT_DIR	 	   0
#define APP_SCENE_DIR		   1
#define APP_IMPORT_DIR		   2
#define APP_EXPORT_DIR		   3
#define APP_HELP_DIR		   4
#define APP_EXPRESSION_DIR	   5
#define APP_PREVIEW_DIR		   6
#define APP_IMAGE_DIR		   7
#define APP_SOUND_DIR		   8
#define APP_PLUGCFG_DIR		   9
#define APP_MAXSTART_DIR	   10
#define APP_VPOST_DIR		   11
#define APP_DRIVERS_DIR		   12
#define APP_AUTOBACK_DIR	   13
#define APP_MATLIB_DIR		   14
#define APP_SCRIPTS_DIR		   15
#define APP_STARTUPSCRIPTS_DIR 16
#define APP_UI_DIR			   17	// this must be next to last!!
#define APP_MAXROOT_DIR		   18	// this must be last!!

// Types for status numbers
#define STATUS_UNIVERSE					1
#define STATUS_SCALE					2
#define STATUS_ANGLE					3
#define STATUS_OTHER					4
#define STATUS_UNIVERSE_RELATIVE		5
#define STATUS_POLAR					6
#define STATUS_POLAR_RELATIVE			7

// Extended display modes
#define EXT_DISP_NONE				0
#define EXT_DISP_SELECTED			(1<<0)		// object is selected
#define EXT_DISP_TARGET_SELECTED	(1<<1)		// object's target is selected
#define EXT_DISP_LOOKAT_SELECTED	(1<<2)		// object's lookat node is selected
#define EXT_DISP_ONLY_SELECTED		(1<<3)		// object is only thing selected
#define EXT_DISP_DRAGGING			(1<<4)		// object is being "dragged"
#define EXT_DISP_ZOOM_EXT			(1<<5)		// object is being tested for zoom ext

// Render time types passed to SetRendTimeType()
#define REND_TIMESINGLE		0
#define REND_TIMESEGMENT	1
#define REND_TIMERANGE		2
#define REND_TIMEPICKUP		3

// Flag bits for hide by category.
#define HIDE_OBJECTS	0x0001
#define HIDE_SHAPES		0x0002
#define HIDE_LIGHTS		0x0004
#define HIDE_CAMERAS	0x0008
#define HIDE_HELPERS	0x0010
#define HIDE_WSMS		0x0020
#define HIDE_SYSTEMS	0x0040
#define HIDE_PARTICLES	0x0080
#define HIDE_ALL		0xffff
#define HIDE_NONE		0



// viewport layout configuration
//   VP_LAYOUT_ LEGEND
//		# is number of viewports (total) in view panel
//		V = vertical split
//		H = horizontal split
//		L/R	= left/right placement
//		T/B = top/bottom placement
//   CONSTANT LEGEND
//		bottom nibble is total number of views
#define VP_LAYOUT_1			0x0001
#define VP_LAYOUT_2V		0x0012
#define VP_LAYOUT_2H		0x0022
#define VP_LAYOUT_2HT		0x0032
#define VP_LAYOUT_2HB		0x0042
#define VP_LAYOUT_3VL		0x0033
#define VP_LAYOUT_3VR		0x0043
#define VP_LAYOUT_3HT		0x0053
#define VP_LAYOUT_3HB		0x0063
#define VP_LAYOUT_4			0x0074
#define VP_LAYOUT_4VL		0x0084
#define VP_LAYOUT_4VR		0x0094
#define VP_LAYOUT_4HT		0x00a4
#define VP_LAYOUT_4HB		0x00b4
#define VP_LAYOUT_1C		0x00c1
#define VP_NUM_VIEWS_MASK	0x000f


class DWORDTab : public Tab<DWORD> {};


// A callback object passed to Execute
#define  I_EXEC_REGISTER_POSTSAVE_CB  1001
#define  I_EXEC_UNREGISTER_POSTSAVE_CB  1002
#define  I_EXEC_REGISTER_PRESAVE_CB  1003
#define  I_EXEC_UNREGISTER_PRESAVE_CB  1004

class GenericCallback {
 public:
  virtual void Callme()=0;
 };

// A callback object passed to RegisterTimeChangeCallback()
class TimeChangeCallback {
	public:
		virtual void TimeChanged(TimeValue t)=0;
	};


// A callback object passed to RegisterCommandModeChangeCallback()
class CommandModeChangedCallback {
	public:
		virtual void ModeChanged(CommandMode *oldM, CommandMode *newM)=0;
	};

// A callback to allow plug-ins that aren't actually objects (such as utilities)
// to draw something in the viewports.
class ViewportDisplayCallback {
	public:
		virtual void Display(TimeValue t, ViewExp *vpt, int flags)=0;		
		virtual void GetViewportRect( TimeValue t, ViewExp *vpt, Rect *rect )=0;
		virtual BOOL Foreground()=0; // return TRUE if the object changes a lot or FALSE if it doesn't change much		
	};

// A callback object that will get called before the program exits.
class ExitMAXCallback {
	public:
		// MAX main window handle is passed in. Return FALSE to abort
		// the exit, TRUE otherwise.
		virtual BOOL Exit(HWND hWnd)=0;
	};

class MAXFileOpenDialog {
	public:
	virtual BOOL BrowseMAXFileOpen(TSTR& fileName, TSTR* defDir, TSTR* defFile) = 0;
	};

class MAXFileSaveDialog {
	public:
	virtual BOOL BrowseMAXFileSave(TSTR& fileName) = 0;
	};

// A callback object to filter selection in the track view.
class TrackViewFilter {
	public:
		// Return TRUE to accept the anim as selectable.
		virtual BOOL proc(Animatable *anim, Animatable *client,int subNum)=0;
	};

// Stores the result of a track view pick
class TrackViewPick {
	public:
		ReferenceTarget *anim;
		ReferenceTarget *client;
		int subNum;

		TrackViewPick() {anim=NULL;client=NULL;subNum=0;}
	};

// A callback object passed to SetPickMode()
class PickModeCallback {
	public:
		// Called when ever the pick mode needs to hit test. Return TRUE if something was hit
		virtual BOOL HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags)=0;
		
		// Called when the user picks something. The vpt should have the result of the hit test in it.
		// return TRUE to end the pick mode.
		virtual BOOL Pick(IObjParam *ip,ViewExp *vpt)=0;

		// Called when the user right-clicks or presses ESC
		// return TRUE to end the pick mode, FALSE to continue picking
		virtual BOOL RightClick(IObjParam *ip,ViewExp *vpt)	{ return FALSE; }

		// Called when the mode is entered and exited.
		virtual void EnterMode(IObjParam *ip) {}
		virtual void ExitMode(IObjParam *ip) {}

		virtual HCURSOR GetDefCursor(IObjParam *ip) {return NULL;}
		virtual HCURSOR GetHitCursor(IObjParam *ip) {return NULL;}

		// If the user hits the H key while in your pick mode, you
		// can provide a filter to filter the name list.
		virtual PickNodeCallback *GetFilter() {return NULL;}

		// Return TRUE to allow the user to pick more than one thing.
		// In this case the Pick method may be called more than once.
		virtual BOOL AllowMultiSelect() {return FALSE;}
	};

// Not to be confused with a PickMODEcallback...
// Used to filter node's during a hit test (PickNode)
class PickNodeCallback {
	public:
		// Return TRUE if this is an acceptable hit, FALSE otherwise.
		virtual BOOL Filter(INode *node)=0;
	};

// Used with DoHitByNameDialog();
class HitByNameDlgCallback {
public:
	virtual TCHAR *dialogTitle()	{ return _T(""); }
	virtual TCHAR *buttonText() 	{ return _T(""); }
	virtual BOOL singleSelect()		{ return FALSE; }
	virtual BOOL useFilter()		{ return TRUE; }
	virtual int filter(INode *node)	{ return TRUE; }
	virtual BOOL useProc()			{ return TRUE; }
	virtual void proc(INodeTab &nodeTab) {}
	virtual BOOL doCustomHilite()	{ return FALSE; }
	virtual BOOL doHilite(INode *node)	{ return FALSE; }
	virtual BOOL showHiddenAndFrozen()	{ return FALSE; }
};


class Interface;

// A callback used with RegisterRedrawViewsCallback()
class RedrawViewsCallback {
	public:
		// this will be called after all the viewport have completed drawing.
		virtual void proc(Interface *ip)=0;
	};

// A callback used with RegisterAxisChangeCallback()
class AxisChangeCallback {
	public:
		// this will be called when the axis system is changed
		virtual void proc(Interface *ip)=0;
	};

// parameters for creation of a preview
class PreviewParams {
public:
	BOOL	outputType;	// 0=default AVI codec, 1=user picks file, 2=user picks device
	int		pctSize;	// percent (0-100) of current rendering output res
	// frame limits
	int		start;
	int		end;
	int		skip;
	// frame rate
	int		fps;
	// display control
	BOOL	dspGeometry;
	BOOL	dspShapes;
	BOOL	dspLights;
	BOOL	dspCameras;
	BOOL	dspHelpers;
	BOOL	dspSpaceWarps;
	BOOL	dspGrid;
	BOOL	dspSafeFrame;
	BOOL	dspFrameNums;
	// rendering level
	int		rndLevel;	// 0=smooth/hi, 1=smooth, 2=facet/hi, 3=facet
						// 4=lit wire, 6=wire, 7=box
	int		dspBkg;
};

// Generic interface into Jaguar
class Interface {
	public:
		virtual HFONT GetAppHFont()=0;
		virtual void RedrawViews(TimeValue t,DWORD vpFlags=REDRAW_NORMAL, ReferenceTarget *change=NULL)=0;		
		virtual BOOL SetActiveViewport(HWND hwnd)=0;
		virtual ViewExp *GetActiveViewport()=0; // remember to release ViewExp* with ReleaseViewport()
		virtual IObjCreate *GetIObjCreate()=0;
		virtual IObjParam *GetIObjParam()=0;
		virtual HWND GetMAXHWnd()=0;

		// This will cause all viewports to be completely redrawn.
		// This is extremely heavy handed and should only be used when
		// necessary.
		virtual void ForceCompleteRedraw(BOOL doDisabled=TRUE)=0;

		// Turn scene redraw on/off.  Each call to disable redraw should be
		// matched by a call to enable it, since this is implemented with an
		// internal counter.  This can be used to stop scene redraws from 
		// happening during rendering, for example.
		virtual void DisableSceneRedraw()=0;
		virtual void EnableSceneRedraw()=0;
		virtual int	 IsSceneRedrawDisabled()=0;	// returns non-zero if disabled

		// Register a call back object that gets called evrytime
		// the viewports are redrawn.
		virtual void RegisterRedrawViewsCallback(RedrawViewsCallback *cb)=0;
		virtual void UnRegisterRedrawViewsCallback(RedrawViewsCallback *cb)=0;

		// For use with extended views: 
		// - make the extended viewport active (set on mouse click, for example)
		// - put up the view type popup menu (put up on right-click, for example)
		virtual void MakeExtendedViewportActive(HWND hWnd)=0;
		virtual void PutUpViewMenu(HWND hWnd, POINT pt)=0;

		// Execute a track view pick dialog.
		virtual BOOL TrackViewPickDlg(HWND hParent, TrackViewPick *res, TrackViewFilter *filter=NULL, DWORD flags=0)=0;
//watje
		virtual BOOL TrackViewPickMultiDlg(HWND hParent, Tab<TrackViewPick> *res, TrackViewFilter *filter=NULL,DWORD flags=0)=0;

		// Command mode methods
		virtual void PushCommandMode( CommandMode *m )=0;
		virtual void SetCommandMode( CommandMode *m )=0;
		virtual void PopCommandMode()=0;		
		virtual CommandMode* GetCommandMode()=0;
		virtual void SetStdCommandMode( int cid )=0;
		virtual void PushStdCommandMode( int cid )=0;		
		virtual void RemoveMode( CommandMode *m )=0;
		virtual void DeleteMode( CommandMode *m )=0;

		// This will set the command mode to a standard pick mode.
		// The callback implements hit testing and a method that is
		// called when the user actually pick an item.
		virtual void SetPickMode(PickModeCallback *pc)=0;
		
		// makes sure no pick modes are in the command stack.
		virtual void ClearPickMode()=0;

		// Puts up a hit by name dialog. If the callback is NULL it 
		// just does a standard select by name.
		// returns TRUE if the user OKs the dialog, FALSE otherwise.
		virtual BOOL DoHitByNameDialog(HitByNameDlgCallback *hbncb=NULL)=0;

		// status panel prompt stuff
		virtual void PushPrompt( TCHAR *s )=0;
		virtual void PopPrompt()=0;
		virtual void ReplacePrompt( TCHAR *s )=0;
		virtual void DisplayTempPrompt( TCHAR *s, int msec=1000)=0;
		virtual void RemoveTempPrompt()=0;

		// put up a directory choose dialog
		// hWnd = parent
		// title is dialog box title
		// dir is return value for chosen dir (empty on cancel)
		// desc, if non-null, puts up a description field and returns new desc.
		virtual void ChooseDirectory(HWND hWnd, TCHAR *title, TCHAR *dir, TCHAR *desc=NULL)=0;

		// auto-backup control -- times are in minutes
		virtual float GetAutoBackupTime()=0;
		virtual void SetAutoBackupTime(float minutes)=0;
		virtual BOOL AutoBackupEnabled()=0;
		virtual void EnableAutoBackup(BOOL onOff)=0;

		// status panel progress bar
		virtual BOOL ProgressStart(TCHAR *title, BOOL dispBar, LPTHREAD_START_ROUTINE fn, LPVOID arg)=0;
		virtual void ProgressUpdate(int pct, BOOL showPct = TRUE, TCHAR *title = NULL)=0;
		virtual void ProgressEnd()=0;
		virtual BOOL GetCancel()=0;
		virtual void SetCancel(BOOL sw)=0;

		// create preview from active view.
		// If pvp is NULL, this uses the parameters from the preview rendering dialog box.
		virtual void CreatePreview(PreviewParams *pvp=NULL)=0;
		
		// Some info about the current grid settings
		virtual float GetGridSpacing()=0;
		virtual int GetGridMajorLines()=0;

		// Write values to x,y,z status boxes. Before doing this, mouse
		// tracking must be disabled. Typically a plug-in would disable
		// mouse tracking on mouse down and enable it on mouse up.		
		virtual void DisableStatusXYZ()=0;
		virtual void EnableStatusXYZ()=0;
		virtual void SetStatusXYZ(Point3 xyz,int type)=0;
		virtual void SetStatusXYZ(AngAxis aa)=0; // this will convert the aa for status display

		// Extended display modes (such as camera cones that only appear when dragging a camera)
		virtual void SetExtendedDisplayMode(int flags)=0;
		virtual int GetExtendedDisplayMode()=0;

		// UI flyoff timing
		virtual void SetFlyOffTime(int msecs)=0;
		virtual int  GetFlyOffTime()=0;

		// Get standard Jaguar cursors.
		virtual HCURSOR GetSysCursor( int id )=0;

		// Turn on or off a cross hair cursor which draws horizontal and vertical
		// lines the size of the viewport's width and height and intersect at
		// the mouse position.
		virtual void SetCrossHairCur(BOOL onOff)=0;
		virtual BOOL GetCrossHairCur()=0;

		// This pops all modes above the create or modify mode.
		// NOTE: This is obsolete with the new modifiy panel design.
		virtual void RealizeParamPanel()=0;

		// Snap an angle value (in radians)
		virtual float SnapAngle(float angleIn, BOOL fastSnap=TRUE, BOOL forceSnap=FALSE)=0;

		// Snap a percentage value (1.0 = 100%)
		virtual float SnapPercent(float percentIn)=0;

		// Get the snap switch state
		virtual BOOL GetSnapState()=0;

		// Get the snap type -- Absolute or Relative (grid.h)
		virtual int GetSnapMode()=0;

		// Set the snap mode -- Set to absolute will fail if not in screen space
		// Returns TRUE if succeeded
		virtual BOOL SetSnapMode(int mode)=0;

		// Hit tests the screen position for nodes and returns a 
		// INode pointer if one is hit, NULL otherwise.
		virtual INode *PickNode(HWND hWnd,IPoint2 pt,PickNodeCallback *filt=NULL)=0;

		// Region hit testing. To access the result, use the ViewExp funtions
		// GetClosestHit() or GetHit().		
		virtual void BoxPickNode(ViewExp *vpt,IPoint2 *pt,BOOL crossing,PickNodeCallback *filt=NULL)=0;
		virtual void CirclePickNode(ViewExp *vpt,IPoint2 *pt,BOOL crossing,PickNodeCallback *filt=NULL)=0;
		virtual void FencePickNode(ViewExp *vpt,IPoint2 *pt,BOOL crossing,PickNodeCallback *filt=NULL)=0;

		//----- Modify-related Methods--------------------------

		// Registers the sub-object types for a given plug-in object type.
		virtual void RegisterSubObjectTypes( const TCHAR **types, int count,
                                             int startIndex = 0)=0;

		// Add sub-object named selection sets the named selection set drop down.
		// This should be done whenever the selection level changes.
		virtual void AppendSubObjectNamedSelSet(const TCHAR *set)=0;

		// Clear the named selections from the drop down.
		virtual void ClearSubObjectNamedSelSets()=0;

		// Clears the edit field of the named selection set drop down
		virtual void ClearCurNamedSelSet()=0;

		// Sets the edit field of the named selection set drop down
		virtual void SetCurNamedSelSet(TCHAR *setName)=0;

		// new for V2... tell the system that the named sets have changed at
		// that the drop down needs to be rebuilt.
		virtual void NamedSelSetListChanged()=0;

		// Returns the state of the sub object drop-down. 0 is object level
		// and >= 1 refer to the levels registered by the object.
		virtual int GetSubObjectLevel()=0;
		
		// Sets the sub-object drop down. This will cause the object being edited
		// to receive a notification that the current subobject level has changed.
        // if force == TRUE, the it will set the level even if the current
        // level is the same as the level requested.  This is to support
        // objects that change sub-object levels on the fly, like NURBS
		virtual void SetSubObjectLevel(int level, BOOL force = FALSE)=0;

		// Returns the number of entries in the sub-object drop down list.
		virtual int GetNumSubObjectLevels()=0;

		// Enables or disables sub object selection. Note that it
		// will already be disabled if there are no subobject levels
		// registered. In this case, it can not be enabled.
		virtual void EnableSubObjectSelection(BOOL enable)=0;
		virtual BOOL IsSubObjectSelectionEnabled()=0;

		// Notifies the system that the selection level in the pipeline has chaned.
		virtual void PipeSelLevelChanged()=0;

		// Returns the sub-object selection level at the point in the
		// pipeline  just before the current place in the history.
		virtual void GetPipelineSubObjLevel(DWORDTab &levels)=0;

		// Get's all instance contexts for the modifier at the current
		// place in the history.
		virtual void GetModContexts(ModContextList& list, INodeTab& nodes)=0;

		// Get the object (or modifier) that is currently being edited in the
		// modifier panel
		virtual BaseObject* GetCurEditObject()=0;

		// Hit tests the object currently being edited at the sub object level.
		virtual int SubObHitTest(TimeValue t, int type, int crossing, 
			int flags, IPoint2 *p, ViewExp *vpt)=0;

		// Is the selection set frozen?
		virtual BOOL SelectionFrozen()=0;
		virtual void FreezeSelection()=0;
		virtual void ThawSelection()=0;

		// Nodes in the current selection set.
		virtual INode *GetSelNode(int i)=0;
		virtual int GetSelNodeCount()=0;

		// Enable/disable, get/set show end result. 
		virtual void EnableShowEndResult(BOOL enabled)=0;
		virtual BOOL GetShowEndResult ()=0;
		virtual void SetShowEndResult (BOOL show)=0;

		// Returns the state of the 'crossing' preference for hit testing.
		virtual BOOL GetCrossing()=0;

		// Sets the state of one of the transform tool buttons.
		// TRUE indecates pressed, FALSE is not pressed.
		virtual void SetToolButtonState(int button, BOOL state )=0;
		virtual BOOL GetToolButtonState(int button)=0;
		virtual void EnableToolButton(int button, BOOL enable=TRUE )=0;

        // Enable and disable Undo/Redo.
        virtual void EnableUndo(BOOL enable)=0;

		// Get and set the command panel task mode
		virtual int GetCommandPanelTaskMode()=0;
		virtual void SetCommandPanelTaskMode(int mode)=0;

		// Finds the vpt given the HWND
		virtual ViewExp *GetViewport( HWND hwnd )=0;		
		virtual void ReleaseViewport( ViewExp *vpt )=0;		

		// Disables/Enables animate button
		virtual void EnableAnimateButton(BOOL enable)=0;
		virtual BOOL IsAnimateEnabled()=0;

		// Turns the animate button on or off
		virtual void SetAnimateButtonState(BOOL onOff)=0;

		// Registers a callback that gets called whenever the axis
		// system is changed.
		virtual void RegisterAxisChangeCallback(AxisChangeCallback *cb)=0;
		virtual void UnRegisterAxisChangeCallback(AxisChangeCallback *cb)=0;
		 
		// Gets/Sets the state of the axis constraints.
		virtual int GetAxisConstraints()=0;
		virtual void SetAxisConstraints(int c)=0;
		virtual void EnableAxisConstraints(int c,BOOL enabled)=0;
		// An axis constraint stack
		virtual void PushAxisConstraints(int c) = 0;
		virtual void PopAxisConstraints() = 0;

		// Gets/Sets the state of the coordinate system center
		virtual int GetCoordCenter()=0;
		virtual void SetCoordCenter(int c)=0;
		virtual void EnableCoordCenter(BOOL enabled)=0;

		// Gets/Sets the reference coordinate systems
		virtual int GetRefCoordSys()=0;
		virtual void SetRefCoordSys(int c)=0;
		virtual void EnableRefCoordSys(BOOL enabled)=0;

		// Get/Set the state of the plug-in keyaboard accel toggle.
		virtual BOOL GetPluginKeysEnabled()=0;
		virtual void SetPluginKeysEnabled(BOOL onOff)=0;

		// Gets the axis which define the space in which transforms should
		// take place. 
		// The node and subIndex refer to the object and sub object which the axis
		// system should be based on (this should be the thing the user clicked on)
		// If 'local' is not NULL, it will be set to TRUE if the center of the axis
		// is the pivot point of the node, FALSE otherwise.
		virtual Matrix3 GetTransformAxis(INode *node,int subIndex,BOOL* local = NULL)=0;

		// This returns the number of axis tripods in the scene. When transforming
		// multiple sub-objects, in some cases each sub-object is transformed in
		// a different space.
		// Return Values:
		// NUMAXIS_ZERO			- Nothing to transform
		// NUMAXIS_ALL			- Use only one axis.
		// NUMAXIS_INDIVIDUAL	- Do all, one at a time
		virtual int GetNumAxis()=0;

		// Locks axis tripods so that they will not be updated.
		virtual void LockAxisTripods(BOOL onOff)=0;
		virtual BOOL AxisTripodLocked()=0;

		// Registers a dialog window so IsDlgMesage() gets called for it.
		virtual void RegisterDlgWnd( HWND hDlg )=0;
		virtual int UnRegisterDlgWnd( HWND hDlg )=0;

		// Registers a keyboard accelerator table
        // These functions are obsolete.  Use the AcceleratorTable
        // funciton below to get tables that use the keyboard prefs dialog
		virtual void RegisterAccelTable( HWND hWnd, HACCEL hAccel )=0;
		virtual int UnRegisterAccelTable( HWND hWnd, HACCEL hAccel )=0;

        // Accerator tables that participate in the keyboard preference dialog
        // Shortcut tables are registered at DLL load-time.
        virtual int ActivateShortcutTable(ShortcutCallback* pCallback, ShortcutTableId id)=0;
        virtual int DeactivateShortcutTable(ShortcutCallback* pCallback, ShortcutTableId id)=0;
        virtual BOOL GetShortcutString(ShortcutTableId tableId, int commandId,
                                       TCHAR* buf)=0;
        virtual BOOL GetShortcutOpName(ShortcutTableId tableId, int commandId,
                                       TCHAR* buf)=0;
		virtual int GetShortcutCount(ShortcutTableId tableId)=0;
		virtual int GetShortcutCommandId(ShortcutTableId tableId, int index)=0;
		virtual TCHAR *GetShortcutCommandName(ShortcutTableId tableId, int index)=0;
		virtual ShortcutCallback* GetCurShortcutCallback()=0;
		virtual ShortcutTableId GetCurShortcutTableId()=0;

		// Adds rollup pages to the command panel. Returns the window
		// handle of the dialog that makes up the page.
		virtual HWND AddRollupPage( HINSTANCE hInst, TCHAR *dlgTemplate, 
				DLGPROC dlgProc, TCHAR *title, LPARAM param=0,DWORD flags=0 )=0;

		// Removes a rollup page and destroys it.
		virtual void DeleteRollupPage( HWND hRollup )=0;

		// Replaces existing rollup with another. (and deletes the old one)
		virtual HWND ReplaceRollupPage( HWND hOldRollup, HINSTANCE hInst, TCHAR *dlgTemplate, 
						DLGPROC dlgProc, TCHAR *title, LPARAM param=0,DWORD flags=0)=0;
		
		// Gets a rollup window interface to the command panel rollup
		virtual IRollupWindow *GetCommandPanelRollup()=0;

		// When the user mouses down in dead area, the plug-in should pass
		// mouse messages to this function which will pass them on to the rollup.
		virtual void RollupMouseMessage( HWND hDlg, UINT message, 
				WPARAM wParam, LPARAM lParam )=0;

		// get/set the current time.
		virtual TimeValue GetTime()=0;	
		virtual void SetTime(TimeValue t,BOOL redraw=TRUE)=0;

		// get/set the anim interval.
		virtual Interval GetAnimRange()=0;
		virtual void SetAnimRange(Interval range)=0;

		// Register a callback object that will get called every time the
		// user changes the frame slider.
		virtual void RegisterTimeChangeCallback(TimeChangeCallback *tc)=0;
		virtual void UnRegisterTimeChangeCallback(TimeChangeCallback *tc)=0;

		// Register a callback object that will get called when the user
		// causes the command mode to change
		virtual void RegisterCommandModeChangedCallback(CommandModeChangedCallback *cb)=0;
		virtual void UnRegisterCommandModeChangedCallback(CommandModeChangedCallback *cb)=0;

		// Register a ViewportDisplayCallback
		// If 'preScene' is TRUE then the callback will be called before object are rendered (typically, but not always).
		virtual void RegisterViewportDisplayCallback(BOOL preScene,ViewportDisplayCallback *cb)=0;
		virtual void UnRegisterViewportDisplayCallback(BOOL preScene,ViewportDisplayCallback *cb)=0;
		virtual void NotifyViewportDisplayCallbackChanged(BOOL preScene,ViewportDisplayCallback *cb)=0;

		// Register a ExitMAXCallback
		virtual void RegisterExitMAXCallback(ExitMAXCallback *cb)=0;
		virtual void UnRegisterExitMAXCallback(ExitMAXCallback *cb)=0;

		virtual RightClickMenuManager* GetRightClickMenuManager()=0;

		// Delete key notitfication
		virtual void RegisterDeleteUser(EventUser *user)=0;		// Register & Activate
		virtual void UnRegisterDeleteUser(EventUser *user)=0;	// Deactivate & UnRegister

		//----- Creation-related Methods--------------------------
		
		virtual void MakeNameUnique(TSTR &name)=0;
		virtual INode *CreateObjectNode( Object *obj)=0;		
		virtual GenCamera *CreateCameraObject(int type) = 0;
		virtual Object   *CreateTargetObject() = 0;
		virtual GenLight *CreateLightObject(int type) = 0;
		virtual void *CreateInstance(SClass_ID superID, Class_ID classID)=0;
		virtual int BindToTarget(INode *laNode, INode *targNode)=0;
		virtual int IsCPEdgeOnInView()=0;		
		virtual void DeleteNode(INode *node, BOOL redraw=TRUE, BOOL overrideSlaves=FALSE)=0;
		virtual INode *GetRootNode()=0;
		virtual void NodeInvalidateRect( INode *node )=0;
		virtual void SelectNode( INode *node, int clearSel = 1)=0;
		virtual void DeSelectNode(INode *node)=0;
		virtual void SelectNodeTab(INodeTab &nodes,BOOL sel,BOOL redraw=TRUE)=0;
		virtual void ClearNodeSelection(BOOL redraw=TRUE)=0;
		virtual void AddLightToScene(INode *node)=0; 
		virtual void AddGridToScene(INode *node) = 0;
		virtual void SetNodeTMRelConstPlane(INode *node, Matrix3& mat)=0;
		virtual void SetActiveGrid(INode *node)=0;
		virtual INode *GetActiveGrid()=0;

		// When a plug-in object implements it's own BeginCreate()/EndCreate()
		// it can cause EndCreate() to be called by calling this method.
		virtual void StopCreating()=0;

		// This creates a new object/node with out going throught the usual
		// create mouse proc sequence.
		// The matrix is relative to the contruction plane.
		virtual Object *NonMouseCreate(Matrix3 tm)=0;
		virtual void NonMouseCreateFinish(Matrix3 tm)=0;

		// directories
		virtual TCHAR *GetDir(int which)=0;		// which = APP_XXX_DIR
		virtual int	GetPlugInEntryCount()=0;	// # of entries in PLUGIN.INI
		virtual TCHAR *GetPlugInDesc(int i)=0;	// ith description
		virtual TCHAR *GetPlugInDir(int i)=0;	// ith directory

		// bitmap path
		virtual int GetMapDirCount()=0;			// number of dirs in path
		virtual TCHAR *GetMapDir(int i)=0;		// i'th dir of path
		virtual BOOL AddMapDir(TCHAR *dir)=0;	// add a path to the list

		virtual float GetLightConeConstraint()=0;

		// for light exclusion/inclusion lists
		virtual int DoExclusionListDialog(NameTab *nl, BOOL doShadows=TRUE)=0;
		
		virtual MtlBase *DoMaterialBrowseDlg(HWND hParent,DWORD flags,BOOL &newMat,BOOL &cancel)=0;

		virtual void PutMtlToMtlEditor(MtlBase *mb, int slot=-1)=0;
		virtual MtlBase* GetMtlSlot(int slot)=0;
		virtual MtlBaseLib* GetSceneMtls()=0;

		// Before assigning material to scene, call this to avoid duplicate names.
		// returns 1:OK  0:Cancel
		virtual	BOOL OkMtlForScene(MtlBase *m)=0;

		// Access names of current files
		virtual TSTR &GetCurFileName()=0;
		virtual TSTR &GetCurFilePath()=0;
		virtual TCHAR *GetMatLibFileName()=0;

		// These may bring up file requesters
		virtual void FileOpen()=0;
		virtual BOOL FileSave()=0;
		virtual BOOL FileSaveAs()=0;
		virtual void FileSaveSelected()=0;
		virtual void FileReset(BOOL noPrompt=FALSE)=0;
		virtual void FileMerge()=0;
		virtual void FileHold()=0;
		virtual void FileFetch()=0;
		virtual void FileOpenMatLib(HWND hWnd)=0;  // Window handle is parent window
		virtual void FileSaveMatLib(HWND hWnd)=0;
		virtual void FileSaveAsMatLib(HWND hWnd)=0;
		virtual BOOL FileImport()=0;
		virtual BOOL FileExport()=0;

		// This loads 3dsmax.mat (if it exists
		virtual void LoadDefaultMatLib()=0;

		// These do not bring up file requesters
		virtual int LoadFromFile(const TCHAR *name, BOOL refresh=TRUE)=0;
		virtual int SaveToFile(const TCHAR *fname)=0;		
		virtual void FileSaveSelected(TCHAR *fname)=0;
		virtual void FileSaveNodes(INodeTab* nodes, TCHAR *fname)=0;
		virtual int LoadMaterialLib(const TCHAR *name, MtlBaseLib *lib=NULL)=0;
		virtual int SaveMaterialLib(const TCHAR *name, MtlBaseLib *lib=NULL)=0;
		virtual int MergeFromFile(const TCHAR *name, 
				BOOL mergeAll=FALSE,    // when true, merge dialog is not put up
				BOOL selMerged=FALSE,   // select merged items?
				BOOL refresh=TRUE,      // refresh viewports ?
				int dupAction = MERGE_DUPS_PROMPT,  // what to do when duplicates are encountered
				NameTab* mrgList=NULL  // names to be merged (mergeAll must be TRUE)
				)=0;
		virtual BOOL ImportFromFile(const TCHAR *name, BOOL suppressPrompts=FALSE, Class_ID *importerID=NULL)=0;
		virtual BOOL ExportToFile(const TCHAR *name, BOOL suppressPrompts=FALSE, DWORD options=0, Class_ID *exporterID=NULL)=0;

		// Returns TRUE if this instance of MAX is in slave mode
		virtual BOOL InSlaveMode()=0;

		// Brings up the object color picker. Returns TRUE if the user
		// picks a color and FALSE if the user cancels the dialog.
		// If the user picks a color then 'col' will be set to the color.
		virtual BOOL NodeColorPicker(HWND hWnd,DWORD &col)=0;

		
		// The following gourping functions will operate on the table
		// of nodes passed in or the current selection set if the table is NULL
		
		// If name is NULL a dialog box will prompt the user to select a name. 
		// If sel group is TRUE, the group node will be selected after the operation completes.
		// returns a pointer to the group node created.
		virtual INode *GroupNodes(INodeTab *nodes=NULL,TSTR *name=NULL,BOOL selGroup=TRUE)=0;
		virtual void UngroupNodes(INodeTab *nodes=NULL)=0;
		virtual void ExplodeNodes(INodeTab *nodes=NULL)=0;
		virtual void OpenGroup(INodeTab *nodes=NULL,BOOL clearSel=TRUE)=0;
		virtual void CloseGroup(INodeTab *nodes=NULL,BOOL selGroup=TRUE)=0;

		// Flashes nodes (to be used to indicate the completion of a pick operation, for example)
		virtual void FlashNodes(INodeTab *nodes)=0;

		// If a plug-in needs to do a PeekMessage() and wants to actually remove the
		// message from the queue, it can use this method to have the message
		// translated and dispatched.
		virtual void TranslateAndDispatchMAXMessage(MSG &msg)=0;
		
		// This will go into a PeekMessage loop until there are no more
		// messages left. If this method returns FALSE then the user
		// is attempting to quit MAX and the caller should return.
		virtual BOOL CheckMAXMessages()=0;

		// Access viewport background image settings.
		virtual BOOL		setBkgImageName(TCHAR *name)=0;
		virtual TCHAR *		getBkgImageName(void)=0;
		virtual void		setBkgImageAspect(int t)=0;
		virtual int			getBkgImageAspect()=0;
		virtual void		setBkgImageAnimate(BOOL onOff)=0;
		virtual int			getBkgImageAnimate(void)=0;
		virtual void		setBkgFrameRange(int start, int end, int step=1)=0;
		virtual int			getBkgFrameRangeVal(int which)=0;
		virtual void		setBkgORType(int which, int type)=0; // which=0 => before start, which=1 =>	after end
		virtual int			getBkgORType(int which)=0;
		virtual void		setBkgStartTime(TimeValue t)=0;
		virtual TimeValue	getBkgStartTime()=0;
		virtual void		setBkgSyncFrame(int f)=0;
		virtual int			getBkgSyncFrame()=0;
		virtual int			getBkgFrameNum(TimeValue t)=0;

		// Gets the state of the real-time animation playback toggle.
		virtual BOOL GetRealTimePlayback()=0;
		virtual void SetRealTimePlayback(BOOL realTime)=0;
		virtual BOOL GetPlayActiveOnly()=0;
		virtual void SetPlayActiveOnly(BOOL playActive)=0;
		virtual void StartAnimPlayback(int selOnly=FALSE)=0;
		virtual void EndAnimPlayback()=0;
		virtual BOOL IsAnimPlaying()=0;
		virtual int GetPlaybackSpeed()=0;
		virtual void SetPlaybackSpeed(int s)=0;
		
		// The following APIs provide a simplistic method to call
		// the renderer and render frames. The renderer just uses the
		// current user specified parameters.
		// Note that the renderer uses the width, height, and aspect
		// of the specified bitmap so the caller can control the size
		// of the rendered image rendered.

		// Renderer must be opened before frames can be rendered.
		// Either camNode or view must be non-NULL but not both.
		// 
		// Returns the result of the open call on the current renderer.
		// 0 is fail and 1 is succeed.
		virtual int OpenCurRenderer(INode *camNode,ViewExp *view,RendType t = RENDTYPE_NORMAL, int w=0, int h=0)=0;

		// optional way to specify the view when Opening the renderer.
		virtual int OpenCurRenderer(ViewParams *vpar,RendType t = RENDTYPE_NORMAL, int w=0, int h=0)=0;

		// The renderer must be closed when you are done with it.
		virtual void CloseCurRenderer()=0;

		// Renders a frame to the given bitmap.
		// The RendProgressCallback is an optional callback (the base class is
		// defined in render.h).
		//
		// Returns the result of the render call on the current renderer.
		// 0 is fail and 1 is succeed.
		virtual int CurRendererRenderFrame(TimeValue t,Bitmap *bm,RendProgressCallback *prog=NULL, float frameDur = 1.0f, ViewParams *vp=NULL, RECT *regionRect = NULL)=0;


		// To get more control over the renderer, the renderer can
		// be called dircetly. The following methods give access to
		// the current renderer and the the user's current rendering settings.

		// Retreives a pointer the renderer currently set to be the
		// active renderer. 
		virtual Renderer *GetCurrentRenderer()=0;
		virtual Renderer *GetProductionRenderer()=0;
		virtual Renderer *GetDraftRenderer()=0;
		virtual void AssignCurRenderer(Renderer *rend)=0;   
		virtual void AssignProductionRenderer(Renderer *rend)=0; 
		virtual void AssignDraftRenderer(Renderer *rend)=0;
		virtual void SetUseDraftRenderer(BOOL b)=0;
		virtual BOOL GetUseDraftRenderer()=0;

		// Fills in a RendParams structure that can be passed to the
		// renderer with the user's current rendering settings.
		// A vpt pointer only needs to be passed in if the RendType
		// is RENDTYPE_REGION or RENDTYPE_BLOWUP. In these cases it will
		// set up the RendParams regxmin,regxmax,regymin,regymax from
		// values stored in the viewport.
		virtual void SetupRendParams(RendParams &rp, ViewExp *vpt, RendType t = RENDTYPE_NORMAL)=0;

		// Call during render to check if user has cancelled render.  
		// Returns TRUE iff user has cancelled.
		virtual BOOL CheckForRenderAbort()=0;

		// These give access to individual user specified render parameters
		// These are either parameters that the user specifies in the
		// render dialog or the renderer page of the preferences dialog.
		virtual int GetRendTimeType()=0;
		virtual void SetRendTimeType(int type)=0;
		virtual TimeValue GetRendStart()=0;
		virtual void SetRendStart(TimeValue start)=0;
		virtual TimeValue GetRendEnd()=0;
		virtual void SetRendEnd(TimeValue end)=0;
		virtual int GetRendNThFrame()=0;
		virtual void SetRendNThFrame(int n)=0;
		virtual BOOL GetRendShowVFB()=0;
		virtual void SetRendShowVFB(BOOL onOff)=0;
		virtual BOOL GetRendSaveFile()=0;
		virtual void SetRendSaveFile(BOOL onOff)=0;
		virtual BOOL GetRendUseDevice()=0;
		virtual void SetRendUseDevice(BOOL onOff)=0;
		virtual BOOL GetRendUseNet()=0;
		virtual void SetRendUseNet(BOOL onOff)=0;
		virtual BitmapInfo& GetRendFileBI()=0;
		virtual BitmapInfo& GetRendDeviceBI()=0;
		virtual int GetRendWidth()=0;
		virtual void SetRendWidth(int w)=0;
		virtual int GetRendHeight()=0;
		virtual void SetRendHeight(int h)=0;
		virtual float GetRendApect()=0;
		virtual void SetRendAspect(float a)=0;
		virtual float GetRendImageAspect()=0;
		virtual float GetRendApertureWidth()=0;	 // get aperture width in mm.
		virtual void SetRendApertureWidth(float aw)=0; // set aperture width in mm.
		virtual BOOL GetRendFieldRender()=0;
		virtual void SetRendFieldRender(BOOL onOff)=0;
		virtual BOOL GetRendColorCheck()=0;
		virtual void SetRendColorCheck(BOOL onOff)=0;
		virtual BOOL GetRendSuperBlack()=0;
		virtual void SetRendSuperBlack(BOOL onOff)=0;
		virtual BOOL GetRendHidden()=0;
		virtual void SetRendHidden(BOOL onOff)=0;
		virtual BOOL GetRendForce2Side()=0;
		virtual void SetRendForce2Side(BOOL onOff)=0;
		virtual BOOL GetRendAtmosphere()=0;
		virtual void SetRendAtmosphere(BOOL onOff)=0;
		virtual BOOL GetRendEffects()=0;
		virtual void SetRendEffects(BOOL onOff)=0;
		virtual BOOL GetRendDisplacement()=0;
		virtual void SetRendDisplacement(BOOL onOff)=0;
		virtual TSTR& GetRendPickFramesString()=0;
		virtual BOOL GetRendDitherTrue()=0;
		virtual void SetRendDitherTrue(BOOL onOff)=0;
		virtual BOOL GetRendDither256()=0;
		virtual void SetRendDither256(BOOL onOff)=0;
		virtual BOOL GetRendMultiThread()=0;
		virtual void SetRendMultiThread(BOOL onOff)=0;
		virtual BOOL GetRendNThSerial()=0;
		virtual void SetRendNThSerial(BOOL onOff)=0;
		virtual int GetRendVidCorrectMethod()=0; // 0->FLAG, 1->SCALE_LUMA 2->SCALE_SAT
		virtual void SetRendVidCorrectMethod(int m)=0;
		virtual int GetRendFieldOrder()=0; // 0->even, 1-> odd
		virtual void SetRendFieldOrder(int fo)=0;
		virtual int GetRendNTSC_PAL()=0; // 0 ->NTSC,  1 ->PAL
		virtual void SetRendNTSC_PAL(int np)=0;
		virtual int GetRendSuperBlackThresh()=0;
		virtual void SetRendSuperBlackThresh(int sb)=0;
//		virtual float GetRendMaxPixelSize()=0;
//		virtual void SetRendMaxPixelSize(float s)=0;
		virtual int GetRendFileNumberBase()=0;
		virtual void SetRendFileNumberBase(int n)=0;

		virtual BOOL GetSkipRenderedFrames()=0;
		virtual void SetSkipRenderedFrames(BOOL onOff)=0;

		virtual DWORD GetHideByCategoryFlags()=0;
		virtual void SetHideByCategoryFlags(DWORD f)=0;

		virtual int GetViewportLayout()=0;
		virtual void SetViewportLayout(int layout)=0;
		virtual BOOL IsViewportMaxed()=0;
		virtual void SetViewportMax(BOOL max)=0;

		// Zoom extents the active viewport, or all
		virtual void ViewportZoomExtents(BOOL doAll, BOOL skipPersp=FALSE)=0;

		// Gets the world space bounding box of the selection.
		virtual void GetSelectionWorldBox(TimeValue t,Box3 &box)=0;
		
		// Find an INode with the given name
		virtual INode *GetINodeByName(const TCHAR *name)=0;

		// For use with gbuffer BMM_CHAN_NODE_RENDER_ID channel during video post
		virtual INode *GetINodeFromRenderID(UWORD id)=0;

		// Executes a MAX command. See maxcom.h for available commands
		virtual void ExecuteMAXCommand(int id)=0;

		// Returns a class used for efficiently creating unique names
		virtual NameMaker* NewNameMaker(BOOL initFromScene = TRUE)=0;

		// Get set the viewport background color.
		virtual void SetViewportBGColor(const Point3 &color)=0;
		virtual Point3 GetViewportBGColor()=0;

		// Get/Set the environment texture map, ambient light and other effects
		virtual Texmap *GetEnvironmentMap()=0;
		virtual void SetEnvironmentMap(Texmap *map)=0;
		virtual BOOL GetUseEnvironmentMap()=0;
		virtual void SetUseEnvironmentMap(BOOL onOff)=0;

		virtual Point3 GetAmbient(TimeValue t,Interval &valid)=0;
		virtual void SetAmbient(TimeValue t, Point3 col)=0;
		virtual Control *GetAmbientController()=0;
		virtual void SetAmbientController(Control *c)=0;

		virtual Point3 GetLightTint(TimeValue t,Interval &valid)=0;
		virtual void SetLightTint(TimeValue t, Point3 col)=0;
		virtual Control *GetLightTintController()=0;
		virtual void SetLightTintController(Control *c)=0;

		virtual float GetLightLevel(TimeValue t,Interval &valid)=0;
		virtual void SetLightLevel(TimeValue t, float lev)=0;
		virtual Control *GetLightLevelController()=0;
		virtual void SetLightLevelController(Control *c)=0;

		virtual int NumAtmospheric()=0;
		virtual Atmospheric *GetAtmospheric(int i)=0;
		virtual void SetAtmospheric(int i,Atmospheric *a)=0;
		virtual void AddAtmosphere(Atmospheric *atmos)=0;
		virtual void DeleteAtmosphere(int i)=0;
		virtual void EditAtmosphere(Atmospheric *a, INode *gizmo=NULL)=0;

		virtual int NumEffects()=0;
		virtual Effect *GetEffect(int i)=0;
		virtual void SetEffect(int i,Effect *e)=0;
		virtual void AddEffect(Effect *eff)=0;
		virtual void DeleteEffect(int i)=0;
		virtual void EditEffect(Effect *e, INode *gizmo=NULL)=0;

		virtual Point3 GetBackGround(TimeValue t,Interval &valid)=0;
		virtual void SetBackGround(TimeValue t,Point3 col)=0;
		virtual Control *GetBackGroundController()=0;
		virtual void SetBackGroundController(Control *c)=0;

		// Get/Set the current sound object.
		virtual SoundObj *GetSoundObject()=0;
		virtual void SetSoundObject(SoundObj *snd)=0;

#ifdef _OSNAP
		virtual IOsnapManager *GetOsnapManager()=0;
		virtual MouseManager *GetMouseManager()=0;
		virtual void InvalidateOsnapdraw()=0;
#endif

		// Access the current mat lib loaded.
		virtual MtlBaseLib& GetMaterialLibrary()=0;

		virtual BOOL IsNetServer()=0; // returns 1 iff is network server
		//-- GUPSTART
		virtual void SetNetServer()=0;
		//-- GUPEND


		//-- Logging Facilities (Replaces the old NetLog() stuff)
		// 
		//   Check log.h for methods

		virtual LogSys *Log()=0;


		// get ref to the central DLL directory
		virtual DllDir& GetDllDir()=0; 

		// Generic expansion function
		virtual int Execute(int cmd, ULONG arg1=0, ULONG arg2=0, ULONG arg3=0)=0; 
		virtual void *GetInterface(DWORD id)=0;

		// Get pointer to the scene.
		virtual ReferenceTarget *GetScenePointer()=0;

		// Get a pointer to the Track View root node.
		virtual ITrackViewNode *GetTrackViewRootNode()=0;

		// Free all bitmaps used by the scene
		virtual void FreeSceneBitmaps()=0;

		// Access the DllDir
		virtual DllDir *GetDllDirectory()=0;

		// Enumerate Bitmap Files
		virtual void EnumAuxFiles(NameEnumCallback& nameEnum, DWORD flags)=0;

		// Render a 2D bitmap from a procedural texture
		virtual void RenderTexmap(Texmap *tex, Bitmap *bm, float scale3d=1.0f, BOOL filter=FALSE, BOOL display=FALSE, float z=0.0f)=0;

		// Activate and deactivate a texture map in the viewports. 
		// mtl is the TOP LEVEL of the material containing the texture map. If it
		// is a Multi-material, then subNum specifies which sub branch of the
		// multi contains tx.
		CoreExport void DeActivateTexture(Texmap *tx, Mtl *mtl, int subNum=-1);
		CoreExport void ActivateTexture(Texmap *tx, Mtl *mtl, int subNum=-1);

		// Access to named selection sets at the object level
		virtual int GetNumNamedSelSets()=0;
		virtual TCHAR *GetNamedSelSetName(int setNum)=0;
		virtual int GetNamedSelSetItemCount(int setNum)=0;
		virtual INode *GetNamedSelSetItem(int setNum,int i)=0;
		virtual void AddNewNamedSelSet(INodeTab &nodes,TSTR &name)=0;
		virtual void RemoveNamedSelSet(TSTR &name)=0;
		virtual void ReplaceNamedSelSet(INodeTab &nodes,int setNum)=0;
		virtual void GetNamedSelSetList(INodeTab &nodes,int setNum)=0;

		// Get new material and map names to maintain name uniqueness
		virtual void AssignNewName(Mtl *m)=0;
		virtual void AssignNewName(Texmap *m)=0;

		// rescale world units of entire scene, or selection
		virtual void RescaleWorldUnits(float f, BOOL selected)=0;

		// Initialize snap info structure with current snap settings
		// (Returns zero if snap is OFF)
		virtual int InitSnapInfo(SnapInfo *info)=0;

		// Time configuration dialog key step options
		virtual BOOL GetKeyStepsSelOnly()=0;
		virtual void SetKeyStepsSelOnly(BOOL onOff)=0;
		virtual BOOL GetKeyStepsUseTrans()=0;
		virtual void SetKeyStepsUseTrans(BOOL onOff)=0;
		virtual BOOL GetKeyStepsPos()=0;
		virtual void SetKeyStepsPos(BOOL onOff)=0;
		virtual BOOL GetKeyStepsRot()=0;
		virtual void SetKeyStepsRot(BOOL onOff)=0;
		virtual BOOL GetKeyStepsScale()=0;
		virtual void SetKeyStepsScale(BOOL onOff)=0;
		virtual BOOL GetKeyStepsUseTrackBar()=0;
		virtual void SetKeyStepsUseTrackBar(BOOL onOff)=0;

		// Enables/disables the use of Transform Gizmos
		virtual BOOL GetUseTransformGizmo()=0;
		virtual void SetUseTransformGizmo(BOOL onOff)=0;

		// Get/Set if the TGiz restores the previous axis when released.
		virtual void SetTransformGizmoRestoreAxis(BOOL bOnOff)=0;
		virtual BOOL GetTransformGizmoRestoreAxis()=0;

		// Turn off axis follows transform mode AI.
		virtual BOOL GetConstantAxisRestriction()=0;
		virtual void SetConstantAxisRestriction(BOOL onOff)=0;

		// Used to hittest transform Gizmos for sub-objects
		virtual int HitTestTransformGizmo(IPoint2 *p, ViewExp *vpt, int axisFlags) = 0;

		// Used to deactiveate the Transform Gizmo when it is released.
		virtual void DeactivateTransformGizmo() = 0;

		// put up dialog to let user configure the bitmap loading paths.
		// returns 1: OK ,  0: Cancel.
		virtual int ConfigureBitmapPaths()=0;

		// Puts up the space array dialog. If the callback is NULL it 
		// just does the standard space array tool.
		// returns TRUE if the user OKs the dialog, FALSE otherwise.
		virtual BOOL DoSpaceArrayDialog(SpaceArrayCallback *sacb=NULL)=0;

		// dynamically add plugin-class.
		// returns -1 if superclass was unknown
		// returns 0 if class already exists
		// returns 1 if class added successfully
		virtual int AddClass(ClassDesc *cd)=0;

		// dynamically delete plugin-class.
		// returns -1 if superclass was unknown
		// returns 0 if class does not exist
		// returns 1 if class deleted successfully
		virtual int DeleteClass(ClassDesc *cd)=0;

		// Number of CommandModes in the command mode stack
		virtual int GetCommandStackSize()=0;
		// Get the CommandMode at this position in the command mode stack (0 = current)
		virtual CommandMode* GetCommandStackEntry(int entry)=0;

		
		// This method should be called in an light's BeginEditParams, after adding rollups 
		// to the modify panel: it puts up a rollup containing a list of all Atmospherics 
		// and Effects that use the current selected node as a "gizmo"
		virtual void AddSFXRollupPage(ULONG flags=0)=0; // flags are for future use

		// This is called in a light's EndEditParams when removing rollups
		virtual void DeleteSFXRollupPage()=0;

		// This is called by an Atmospheric or Effect when it adds or removes a "gizmo" reference.
		virtual void RefreshSFXRollupPage()=0;

		// PropertySet access
		// Legal values for "int PropertySet" are defined above:
		//	PROPSET_SUMMARYINFO
		//	PROPSET_DOCSUMMARYINFO
		//	PROPSET_USERDEFINED
		virtual int					GetNumProperties(int PropertySet)=0;
		virtual int					FindProperty(int PropertySet, const PROPSPEC* propspec)=0;
		virtual const PROPVARIANT*	GetPropertyVariant(int PropertySet, int idx)=0;
		virtual const PROPSPEC*		GetPropertySpec(int PropertySet, int idx)=0;
		virtual void				AddProperty(int PropertySet, const PROPSPEC* propspec, const PROPVARIANT* propvar)=0;
		virtual void				DeleteProperty(int PropertySet, const PROPSPEC* propspec)=0;

		// register a window that can appear in a MAX viewport
		virtual BOOL RegisterViewWindow(ViewWindow *vw)=0;
		
		// Get and set the global shadow generator ( used by light.cpp)
		virtual ShadowType *GetGlobalShadowGenerator()=0;
		virtual void SetGlobalShadowGenerator(ShadowType *st)=0;

		// Get the Import zoom-extents flag
		virtual BOOL GetImportZoomExtents()=0;

		virtual unsigned int HardwareLockID()=0;
		virtual BOOL CheckForSave()=0;

		virtual ITrackBar*	GetTrackBar()=0;

		// For scene XRefs. Most of the time the XRef trees (whose root node is a child of the
		// client scene's root node) are skipped when traversing the hierarchy. When this option
		// is turned on, all root nodes will include child XRef scene root nodes in any traversal
		// related functions such as NumberOfChildren() and GetChildNode(i).
		// 
		// This option is turned on automatically before rendering and turned off after so that
		// scene XRefs appear in the production renderer. This option should not be left on if
		// it is turned on since it would cause scene XRef objects to be accessible to the user in the client scene.
		virtual void SetIncludeXRefsInHierarchy(BOOL onOff)=0;
		virtual BOOL GetIncludeXRefsInHierarchy()=0;

		// Use these two suspend automatic reloading of XRefs. 
		virtual BOOL IsXRefAutoUpdateSuspended()=0;
		virtual void SetXRefAutoUpdateSuspended(BOOL onOff)=0;

		// get the macroRecorder interface pointer
		virtual MacroRecorder* GetMacroRecorder()=0;


		// DS 2/2/99: 
		virtual void UpdateMtlEditorBrackets()=0;

		// PRS 2/4/99
		virtual bool IsTrialLicense() = 0;
		virtual bool IsNetworkLicense() = 0;
		virtual bool IsEmergencyLicense() = 0;

		// CCJ - 2/12/99
		virtual void SetMAXFileOpenDlg(MAXFileOpenDialog* dlg) = 0;
		virtual void SetMAXFileSaveDlg(MAXFileSaveDialog* dlg) = 0;

		virtual void RAMPlayer(HWND hWndParent, TCHAR* szChanA=NULL, TCHAR* szChanB=NULL) = 0;

		//KAE - 3/4/99
		virtual void FlushUndoBuffer() = 0;

		// CCJ 3/16/99
		virtual bool DeferredPluginLoadingEnabled() = 0;
		virtual void EnableDeferredPluginLoading(bool onOff) = 0;

		// RB: 3/30/99
		virtual BOOL IsSceneXRefNode(INode *node)=0;
	
}; // class Interface

#ifdef DESIGN_VER
class IAggregation;
class VizInterface : public Interface
{
public:
 	virtual IAggregation& GetAggregationMgr()= 0;

	// MEP 4/19/99
	virtual bool CanImportFile(const TCHAR* filename)=0;
	virtual bool IsMaxFile(const TCHAR* filename)=0;
	virtual bool IsInternetCachedFile(const TCHAR* filename)=0;

	// MEP 6/21/99
	virtual bool CanImportBitmap(const TCHAR* filename)=0;
};
class IObjParam: public VizInterface{};
#else
class IObjParam: public Interface{};
#endif // DESIGN_VER

class IObjCreate: public IObjParam{};

#endif // __JAGAPI__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Meshacc.h ===
/*****************************************************************************
 *<
	FILE: meshacc.h

	DESCRIPTION:  A class for getting at the private snap data of the mesh class

	CREATED BY: John Hutchinson		

	HISTORY: created 1/2/97

 *>	Copyright (c) 1994, All Rights Reserved.
 *****************************************************************************/
#ifndef _MESHACC_H_

#define _MESHACC_H_
#include "export.h"
#include "mesh.h"

class MeshAccess {
private:
	Mesh *mymesh;
public:
	MeshAccess(Mesh *somemesh){mymesh = somemesh;}
	DllExport int BuildSnapData(GraphicsWindow *gw,int verts,int edges);
	char* GetsnapV(){
		return mymesh->snapV;
	}
	char* GetsnapF(){
		return mymesh->snapF;
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\mcapdev.h ===
/**********************************************************************
 *<
	FILE: mcapdev.h

	DESCRIPTION: Motion capture device plug-in interface

	CREATED BY: Rolf Berteig

	HISTORY: May 01, 1997

 *>	Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/

#ifndef _MCAPDEV_
#define _MCAPDEV_


class IMCParamDlg;
class MCDeviceBinding;

// Motion capture controller class IDs
#define POS_MOTION_CLASS_ID			0xff8826de
#define ROT_MOTION_CLASS_ID			0xff7826df
#define SCALE_MOTION_CLASS_ID		0xff6826da
#define FLOAT_MOTION_CLASS_ID		0xff5826db
#define POINT3_MOTION_CLASS_ID		0xff4826dc

// If a controller has one of the above class IDs, then it
// can be cast into this class.
class IMCControl : public Control {
	public:
		virtual BOOL IsLiveOn()=0;
		virtual BOOL IsRecordOn()=0;
		virtual int NumDeviceBindings()=0;
		virtual MCDeviceBinding *GetDeviceBinding(int i)=0;
		virtual void SetDeviceBinding(int i,MCDeviceBinding *b)=0;		
		virtual void GetValueLive(TimeValue t,void *val, GetSetMethod method)=0;
	};

class IMCapManager {
	public:
		virtual void MidiNote(int channel, int note)=0;
		virtual TimeValue GetTime()=0;
	};

// Base class for an input device
class MCInputDevice {
	public:
		virtual TSTR DeviceName()=0;
		virtual MCDeviceBinding *CreateBinding()=0;
		virtual void UtilityStarted(IMCapManager *im) {}
		virtual	void UtilityStopped(IMCapManager *im) {}
		virtual void Cycle(UINT tick) {}		

	};

// An instance of this class is created when a motion caprture controller
// binds one of its parameters to a device. The main purpose of this
// class is to store any parameters that describe the binding.
class MCDeviceBinding : public ReferenceTarget {
	public:
		virtual MCInputDevice *GetDevice()=0;
		virtual TSTR BindingName()=0;
		virtual float Eval(TimeValue t)=0;
		virtual void DeleteThis()=0;		
		virtual void AddRollup(IMCParamDlg *dlg)=0;
		virtual void UpdateRollup(IRollupWindow *iRoll)=0;
		virtual void BeginActivate(BOOL reset=TRUE) {}
		virtual void EndActivate() {}
		virtual void Accumulate(TimeValue t) {}

		SClass_ID SuperClassID() {return MOT_CAP_DEVBINDING_CLASS_ID;}		
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	         PartID& partID,  RefMessage message) {return REF_SUCCEED;}

	};

class IMCParamDlg : public ReferenceMaker {
	public:
		MCDeviceBinding *binding;
		IRollupWindow *iRoll;
	};



#endif //_MCAPDEV_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\mesh.h ===
/**********************************************************************
 *<
	FILE: mesh.h

	DESCRIPTION: Main include file for triangle meshes.

	CREATED BY: Don Brittain

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef _MESH_H_

#define _MESH_H_

#include "channels.h"
#include "snap.h"
#include <ioapi.h>
#include "export.h"
#include "vedge.h"  //DS
#include "utillib.h"
#include "tab.h"

#if 0	// moved to gfx.h
typedef Tab<DWORD> DWTab;
typedef unsigned short MtlID;
#endif

// This a UV coordinate. These cound be Point2s
typedef Point3 UVVert;

// We may want these to by 24bit RGBs instead of floats
typedef Point3 VertColor;


#define MESH_MULTI_PROCESSING	TRUE		// TRUE turns on mp vertex transformation

class ISave;
class ILoad;

#define NEWMESH

class RNormal {
	public:
		RNormal()	{ smGroup = mtlIndex = 0; }
		void		setNormal(const Point3 &nor) { normal = nor; }
		void		addNormal(const Point3 &nor) { normal += nor; }	
		void		normalize(void) 	{ normal = Normalize(normal); }
		Point3 &	getNormal(void) 	{ return normal; }
		void		setSmGroup(DWORD g)	{ smGroup = g; }
		void		addSmGroup(DWORD g) { smGroup |= g; }
		DWORD		getSmGroup(void)	{ return smGroup; }
		void		setMtlIndex(MtlID i){ mtlIndex = i; }
		MtlID		getMtlIndex(void)	{ return mtlIndex; }
		void		setRGB(Point3 &clr)	{ rgb = clr; };
		Point3 &	getRGB(void)		{ return rgb; }
		
	private:	
		Point3		normal;	   
		DWORD		smGroup;    
		MtlID		mtlIndex;   
		Point3		rgb;	   
	};					   



// RVertex flags: contain clip flags, number of normals at the vertex
// and the number of normals that have already been rendered.
// fine PLANE_MASK	0x00003f00UL -- now in gfx.h
#define NORCT_MASK			0x000000ffUL
#define SPECIFIED_NORMAL	0x00004000UL
#define OUT_LEFT			0x00010000UL
#define OUT_RIGHT			0x00020000UL
#define OUT_TOP				0x00040000UL
#define OUT_BOTTOM			0x00080000UL
#define RECT_MASK			0x000f0000UL
#define RND_MASK			0xfff00000UL
#define RND_NOR0			0x00100000UL
#define RND_NOR(n)  		(RND_NOR0 << (n))

class RVertex {
	public:
		RVertex()	{ rFlags = 0; ern = NULL; }
		DllExport ~RVertex();	

		DWORD		rFlags;     
		int			pos[3];	
		RNormal		rn;		   
		RNormal 	*ern;		 
	};					  



// Face Flags:
// 		3 LSBs hold the edge visibility flags
// 		Bit 3 indicates the presence of texture verticies

// if bit is 1, edge is visible
#define EDGE_VIS			1
#define EDGE_INVIS			0

// first edge-visibility bit field
#define VIS_BIT				0x0001
#define VIS_MASK			0x0007

#define EDGE_A		(1<<0)
#define EDGE_B		(1<<1)
#define EDGE_C		(1<<2)
#define EDGE_ALL	(EDGE_A|EDGE_B|EDGE_C)

#define FACE_HIDDEN	(1<<3)
#define HAS_TVERTS	(1<<4)
#define FACE_WORK	(1<<5) // used in various algorithms
#define FACE_STRIP	(1<<6)

// The mat ID is stored in the HIWORD of the face flags
#define FACE_MATID_SHIFT	16
#define FACE_MATID_MASK		0xFFFF


class Face {	
	public:
		DWORD	v[3];
		DWORD	smGroup;
		DWORD	flags;

		Face()	{ smGroup = flags = 0; }
		MtlID	getMatID() {return (int)((flags>>FACE_MATID_SHIFT)&FACE_MATID_MASK);}
		void    setMatID(MtlID id) {flags &= 0xFFFF; flags |= (DWORD)(id<<FACE_MATID_SHIFT);}
		void	setSmGroup(DWORD i) { smGroup = i; }
		DWORD	getSmGroup(void)	{ return smGroup; }
		void	setVerts(DWORD *vrt){ memcpy(v, vrt, 3*sizeof(DWORD)); }
		void	setVerts(int a, int b, int c)  { v[0]=a; v[1]=b; v[2]=c; }
		DllExport void	setEdgeVis(int edge, int visFlag);
		DllExport void    setEdgeVisFlags(int va, int vb, int vc); 
		int		getEdgeVis(int edge){ return flags & (VIS_BIT << edge); }
		DWORD	getVert(int index)	{ return v[index]; }
		DWORD *	getAllVerts(void)	{ return v; }
		BOOL	Hidden() {return flags&FACE_HIDDEN?TRUE:FALSE;}
		void	Hide() {flags|=FACE_HIDDEN;}
		void	Show() {flags&=~FACE_HIDDEN;}
		void	SetHide(BOOL hide) {if (hide) Hide(); else Show();}

		DllExport DWORD GetOtherIndex (DWORD v0, DWORD v1);
		DllExport DWORD GetEdgeIndex (DWORD v0, DWORD v1);
		DllExport int Direction (DWORD v0, DWORD v1);
		DllExport DWORD GetVertIndex (DWORD v0);
		DllExport void OrderVerts (DWORD & v0, DWORD & v1);	// switches v0,v1 if needed to put them in face-order.
	};


// This is used both for UVWs and color verts
class TVFace {
public:
	DWORD	t[3];  // indices into tVerts

	TVFace() {}
	TVFace(DWORD a, DWORD b, DWORD c) {t[0]=a; t[1]=b; t[2]=c;}
	void	setTVerts(DWORD *vrt){ memcpy(t, vrt, 3*sizeof(DWORD)); }
	void	setTVerts(int a, int b, int c)  { t[0]=a; t[1]=b; t[2]=c; }	
	DWORD	getTVert(int index)	{ return t[index]; }
	DWORD *	getAllTVerts(void)	{ return t; }

	DllExport DWORD GetVertIndex (DWORD v0);
	DllExport DWORD GetOtherIndex (DWORD v0, DWORD v1);
	DllExport int Direction (DWORD v0, DWORD v1);
	DllExport void OrderVerts (DWORD & v0, DWORD & v1);	// switches v0,v1 if needed to put them in face-order.
};


// MeshMap stuff:

#define MAX_MESHMAPS 100

#define MESHMAP_USED 0x0001
#define MESHMAP_TEXTURE 0x0002
#define MESHMAP_VERTCOLOR 0x0004
#define MESHMAP_USER 0x0100

class MeshMap {
public:
	DWORD flags;
	UVVert *tv;
	TVFace *tf;
	int vnum, fnum;

	MeshMap () { flags=0x0; tv=NULL; tf=NULL; vnum = fnum = 0; }
	~MeshMap () { if (tv) delete [] tv; if (tf) delete [] tf; }

	int getNumVerts () { return vnum; }
	DllExport void setNumVerts (int vn, BOOL keep=FALSE);
	int getNumFaces () { return fnum; }
	DllExport void setNumFaces (int fn, BOOL keep=FALSE, int oldCt=0);
	void Clear () { if (tv) delete [] tv; if (tf) delete [] tf; tv=NULL; tf=NULL; vnum = fnum = 0; }
	DllExport BitArray GetIsoVerts ();
	DllExport void DeleteVertSet (BitArray set, BitArray *delFace=NULL);
	DllExport void DeleteFaceSet (BitArray set, BitArray *isoVert=NULL);

	void SetFlag (DWORD fl) { flags |= fl; }
	void ClearFlag (DWORD fl) { flags &= ~fl; }
	BOOL GetFlag (DWORD fl) { return (flags & fl) ? TRUE : FALSE; }
	BOOL IsUsed () { return (flags & MESHMAP_USED) ? TRUE : FALSE; }

	DllExport void SwapContents (MeshMap & from);
	DllExport MeshMap & operator= (MeshMap & from);
};


// Following is used for arbitrary per-element info in meshes, such as weighted verts
// or weighted vert selections.  Methods are deliberately made to look like Tab<> methods.

// For per-vertex info: set a maximum, and reserve first ten channels
// for Discreet's use only.
#define MAX_VERTDATA 100
#define VDATA_USER 10	// Third parties should use this channel or higher.

// Indices of important per-vertex data
#define VDATA_SELECT  0   // Soft Selection
#define VDATA_WEIGHT  1   // Vertex weights (for NURMS MeshSmooth)
#define VDATA_ALPHA   2   // Vertex Alpha values

// Related constants:
#define MAX_WEIGHT ((float)1e5)
#define MIN_WEIGHT ((float)1e-5)

// Types of data
#define PERDATA_TYPE_FLOAT 0

// Vertex-specific methods:
DllExport int VertexDataType (int vdID);
DllExport void *VertexDataDefault (int vdID);

class PerData {
public:
	int dnum, type, alloc;
	void *data;

	PerData () { data=NULL; dnum=0; alloc=0; type=0; }
	PerData (int n, int tp) { data=NULL; dnum=0; alloc=0; type=tp; setAlloc (n, FALSE); }
	~PerData () { Clear (); }

	// Following only depend on type:
	DllExport void *AllocData (int num);
	DllExport void FreeData (void *addr);
	DllExport int DataSize ();
	void *Addr (void *ptr, int at) { BYTE *vd=(BYTE *)ptr; return (void *)(vd+at*DataSize()); }
	void *Addr (int at) { return Addr(data,at); }
	DllExport void CopyData (void *to, void *from, int num=1);
	void CopyData ( int to,  int from, int num=1) { CopyData (Addr(to), Addr(from), num); }
	DllExport void WeightedSum (void *to, void *fr1, float prop1, void *fr2, float prop2);
	void WeightedSum (int to, int fr1, float prop1, int fr2, float prop2) { WeightedSum (Addr(to), Addr(fr1), prop1, Addr(fr2), prop2); }

	DllExport void setAlloc (int num, BOOL keep=TRUE);
	void SetCount (int num, BOOL keep = FALSE) { setAlloc (num, keep); dnum=num; }
	void Shrink () { if (alloc>dnum) setAlloc(dnum); }
	int Count () { return dnum; }
	DllExport void Clear ();
	DllExport void DeleteSet (BitArray del);
	DllExport void Delete (int at, int num);
	DllExport void Insert (int at, int num, void *el);
	DllExport void Append (int num, void *el);
	DllExport void InsertCopies (int at, int num, void *el);
	DllExport void AppendCopies (int num, void *el);

	DllExport void SwapContents (PerData & from);
	DllExport PerData & operator= (const PerData & from);
	DllExport void MyDebugPrint ();
};

// Mesh::flags definitions
#define MESH_EDGE_LIST     (1<<1)
// Set this to prevent renderData from being deleted (except when mesh is deleted)
#define MESH_LOCK_RENDDATA (1<<2)
#define MESH_SMOOTH_BIT1   (1<<3)
#define MESH_SMOOTH_BIT2   (1<<4)
#define MESH_SMOOTH_BIT3   (1<<5)
#define MESH_SMOOTH_BIT4   (1<<6)
#define MESH_SMOOTH_MASK   0x78		// mask for SMOOTH_BIT's 1 thru 4
#define MESH_BEEN_DSP	   (1<<9)
#define MESH_SMOOTH_SUBSEL (1<<10)

#define COMP_TRANSFORM	0x0001	// forces recalc of model->screen transform; else will attempt to use cache
#define COMP_IGN_RECT	0x0002	// forces all polys to be rendered; else only those intersecting the box will be
#define COMP_LIGHTING	0x0004	// forces re-lighting of all verts (as when a light moves); else only relight moved verts

#define COMP_ALL		0x00ff

// If this bit is set then the node being displayed by this mesh is selected.
// Certain display flags only activate when this bit is set.
#define COMP_OBJSELECTED	(1<<8)

#if 0	// moved to gfx.h

// strip-related stuff

class Strip {
public:
	MtlID	mID;
	DWORD	smGrp;
	DWTab	v;
	void AddVert(DWORD vtx)	{ v.Append(1, &vtx); }
	DWTab	tv;
	void AddVert(DWORD vtx, DWORD tvtx) { v.Append(1, &vtx); tv.Append(1, &tvtx); }
};

typedef Strip *StripPtr;
typedef Tab<StripPtr> StripTab;

#endif

class StripData {
public:
	int ct;
	DWORD f[6];
	void AddFace(DWORD face)
		{ if(ct < 6) f[ct++] = face; }
};

typedef int (*INTRFUNC)();

DllExport void setMeshIntrFunc(INTRFUNC fn);


class MeshSubHitRec {
	private:		
		MeshSubHitRec *next;
	public:
		DWORD	dist;
		int		index;
		DWORD	flags;

		MeshSubHitRec(DWORD dist, int index, MeshSubHitRec *next) 
			{this->dist = dist; this->index = index; this->next = next;}
		MeshSubHitRec(DWORD dist, int index, DWORD flags, MeshSubHitRec *next) 
			{this->dist = dist; this->index = index; this->next = next;this->flags = flags;}

		MeshSubHitRec *Next() { return next; }		
	};

class SubObjHitList {
	private:
		MeshSubHitRec *first;
	public:
		SubObjHitList() { first = NULL; }
		~SubObjHitList() {
			MeshSubHitRec *ptr = first, *fptr;
			while (ptr) {
				fptr = ptr;
				ptr = ptr->Next();
				delete fptr;
				}
			first = NULL;
			}	

		MeshSubHitRec *First() { return first; }
		void AddHit( DWORD dist, int index ) {
			first = new MeshSubHitRec(dist,index,first);
			}
	};



// Flags for sub object hit test

// NOTE: these are the same bits used for object level.
#define SUBHIT_SELONLY		(1<<0)
#define SUBHIT_UNSELONLY	(1<<2)
#define SUBHIT_ABORTONHIT	(1<<3)
#define SUBHIT_SELSOLID		(1<<4)

#define SUBHIT_USEFACESEL	(1<<23)   // When this bit is set, the sel only and unsel only tests will use the faces selection when doing a vertex level hit test
#define SUBHIT_VERTS		(1<<24)
#define SUBHIT_FACES		(1<<25)
#define SUBHIT_EDGES		(1<<26)
#define SUBHIT_TYPEMASK		(SUBHIT_VERTS|SUBHIT_FACES|SUBHIT_EDGES)


// Display flags
#define DISP_VERTTICKS		(1<<0)
#define DISP_SELVERTS		(1<<10)
#define DISP_SELFACES		(1<<11)
#define DISP_SELEDGES		(1<<12)
#define DISP_SELPOLYS		(1<<13)

// Selection level bits.
#define MESH_OBJECT		(1<<0)
#define MESH_VERTEX		(1<<1)
#define MESH_FACE		(1<<2)
#define MESH_EDGE		(1<<3)


class MeshOpProgress;
class UVWMapper;

class MeshRenderData {
	public:
	virtual void DeleteThis()=0;
	};

class AdjFaceList;

class Mesh {
	friend class Face;
	friend class MeshAccess;
	friend void gfxCleanup(void *data);

	private:
#if MESH_MULTI_PROCESSING
		static int		refCount;
		static HANDLE	xfmThread;
		static HANDLE	xfmMutex;
		static HANDLE	xfmStartEvent;
		static HANDLE	xfmEndEvent;
		friend DWORD WINAPI xfmFunc(LPVOID ptr);
		static HANDLE	fNorThread;
		static HANDLE	fNorMutex;
		static HANDLE	fNorStartEvent;
		static HANDLE	fNorEndEvent;
		friend DWORD WINAPI fNorFunc(LPVOID ptr);

		static HANDLE	workThread;
		static HANDLE	workMutex;
		static HANDLE	workStartEvent;
		static HANDLE	workEndEvent;
		friend DWORD WINAPI workFunc(LPVOID ptr);
#endif
		// derived data-- can be regenerated
		RVertex 		*rVerts;		// <<< instance specific.
		GraphicsWindow 	*cacheGW;  		// identifies rVerts cache
		Point3	 		*faceNormal;	// object space--depends on geom+topo
		Box3			bdgBox;			// object space--depends on geom+topo
		int 			numVisEdges;	// depends on topo 
		int				edgeListHasAll;	// depends on topo
		VEdge 			*visEdge;		// depends on topo 	
 
 		// Vertex and face work arrays -- for snap code
		int			snapVCt;
		int			snapFCt;
		char		*snapV;
		char		*snapF;

		// -------------------------------------
		//
		long   		flags;		  	// work flags- 

		float 		norScale;	    // scale of normals -- couldn't this be done
		 							// automatically relative to bdgBox?

		// Rolf: these are instance specific and should be pulled out of here,
		// and just passed in from the Node.
		BYTE		dspNormals;    // display surface normals--- put in flags?
		BYTE		dspAllEdges;   // shows hidden edges  ---- put in flags?
		BYTE		dspVertTicks;  // shows vertex ticks

		int 		renderFace(GraphicsWindow *gw, DWORD index, int *custVis=NULL);
		int			renderEdge(GraphicsWindow *gw, DWORD face, DWORD edge);
		void		renderStrip(GraphicsWindow *gw, Strip *s);
		void 		render3DFace(GraphicsWindow *gw, DWORD index, int *custVis=NULL);
		void		render3DStrip(GraphicsWindow *gw, Strip *s);
		void		render3DWireStrip(GraphicsWindow *gw, Strip *s);
		BOOL		CanDrawStrips(DWORD rndMode, Material *mtl, int numMtls);
		BOOL		NormalsMatchVerts();
		void		checkRVertsAlloc(void);
		void  		calcNormal(int i);
		void		buildFaceNormals();		// calcs just the face normals
		void		setCacheGW(GraphicsWindow *gw)	{ cacheGW = gw; }
		GraphicsWindow *getCacheGW(void)			{ return cacheGW; }

		void 		freeVerts();
		void        freeVertCol();
		void  		freeFaces();
		void		freeFaceNormals();  
		void  		freeRVerts(BOOL forceDelete=FALSE);
		void  		freeTVerts();
		void  		freeTVFaces();
		void  		freeVCFaces();
		void		freeSnapData();
		int			buildSnapData(GraphicsWindow *gw,int verts,int edges);

	public:
		// Topology
		int			numVerts;
		int	 		numFaces;
		Face *		faces;

		// Geometry
		Point3 *	verts;		

		// Texture Coord assignment 
		int			numTVerts;
		UVVert *	tVerts;
		TVFace *	tvFace;  	 

		// Color per vertex
		int numCVerts;
		VertColor * vertCol;
		TVFace *    vcFace;

		// More maps:
		int numMaps;
		MeshMap *maps;

		// Per-vertex info (of any kind):
		BitArray vdSupport;
		PerData *vData;

		// Material assignment
		MtlID		mtlIndex;		// object material

		// Selection
		BitArray	vertSel;  		// selected vertices
		BitArray	faceSel;  		// selected faces
		BitArray	edgeSel;		// selected edges, identified as 3*faceIndex + edgeIndex
		BitArray	vertHide;		// Hide flags for vertices

		// Display attribute flags
		DWORD		dispFlags;

		// Selection level
		DWORD		selLevel;

		// true if normals have been built for the current mesh
		int			normalsBuilt;

		MeshRenderData*	 renderData;  // used by the renderer

		// derived data-- can be regenerated
		StripTab		*stab;		// depends on topo
#ifdef PUT_NORMALS_IN_STRIPS
		DWTab		norInd;			// indirection array for fast normal lookup
		int			normalCount;	// total number of normals
		Point3 *	gfxNormals;		// flattened list of normals
#endif

		DllExport Mesh();
		DllExport Mesh(const Mesh& fromMesh);
		DllExport ~Mesh(); 
		void 		Init();
		DllExport void DeleteThis();

		DllExport Mesh& operator=(const Mesh& fromMesh);
		
		DllExport BOOL 	setNumVerts(int ct, BOOL keep=FALSE, BOOL synchSel=TRUE);
		int				getNumVerts(void) const	{ return numVerts; }
		
		DllExport BOOL	setNumFaces(int ct, BOOL keep=FALSE, BOOL synchSel=TRUE);
		int				getNumFaces(void) const{ return numFaces; }
		
		// Original mapping coordinates (map channel 1)
		DllExport BOOL	setNumTVerts(int ct, BOOL keep=FALSE);
		int				getNumTVerts(void) const { return numTVerts; }
		DllExport BOOL 	setNumTVFaces(int ct, BOOL keep=FALSE, int oldCt=0);

		// Color per vertex array (map channel 0)
		DllExport BOOL 	setNumVertCol(int ct,BOOL keep=FALSE);
		int             getNumVertCol() const {return numCVerts;}
		DllExport BOOL 	setNumVCFaces(int ct, BOOL keep=FALSE, int oldCt=0);

		// For mp in following: 0=vert colors, 1=original TVerts, 2&up = new map channels
		DllExport void setNumMaps (int ct, BOOL keep=FALSE);
		int getNumMaps () const { return numMaps; }

		DllExport BOOL mapSupport (int mp) const;
		DllExport void setMapSupport (int mp, BOOL support=TRUE);
		DllExport void setNumMapVerts (int mp, int ct, BOOL keep=FALSE);
		DllExport int getNumMapVerts (int mp) const;
		DllExport void setNumMapFaces (int mp, int ct, BOOL keep=FALSE, int oldCt=0);

		DllExport UVVert *mapVerts (int mp) const;
		DllExport TVFace *mapFaces (int mp) const;
		void		setMapVert (int mp, int i, const UVVert&xyz) { if (mapVerts(mp)) mapVerts(mp)[i] = xyz; }
		DllExport void MakeMapPlanar (int mp);	// Copies mesh topology, vert locations into map.
		DllExport BitArray GetIsoMapVerts (int mp);
		DllExport void DeleteMapVertSet (int mp, BitArray set, BitArray *fdel=NULL);
		DllExport void DeleteIsoMapVerts (int mp=-1);	//	 default indicates to do all active maps
		DllExport void freeMapVerts (int mp);
		DllExport void freeMapFaces (int mp);

		DllExport void setNumVData (int ct, BOOL keep=FALSE);
		int getNumVData () const { return vdSupport.GetSize(); }

		DllExport BOOL vDataSupport (int vd) const;
		DllExport void setVDataSupport (int vd, BOOL support=TRUE);
		void *vertexData (int vd) const { return vDataSupport(vd) ? vData[vd].data : NULL; }
		float *vertexFloat (int vd) const { return (float *) vertexData (vd); }
		DllExport void freeVData (int vd);
		DllExport void freeAllVData ();

		// Two specific vertex scalars.
		float *getVertexWeights () { return vertexFloat(VDATA_WEIGHT); }
		void SupportVertexWeights () { setVDataSupport (VDATA_WEIGHT); }
		void ClearVertexWeights() { setVDataSupport (VDATA_WEIGHT, FALSE); }
		void freeVertexWeights () { freeVData (VDATA_WEIGHT); }
		float *getVSelectionWeights () { return vertexFloat(VDATA_SELECT); }
		void SupportVSelectionWeights () { setVDataSupport (VDATA_SELECT); }
		void ClearVSelectionWeights() { setVDataSupport (VDATA_SELECT, FALSE); }
		void freeVSelectionWeights () { freeVData (VDATA_SELECT); }

		// these flags are restricted to 4 bits and force the topology (strips & edges)
		// to be invalidated when they change.  Used by primitives with smoothing checkboxes
		DllExport void  setSmoothFlags(int f);
		DllExport int   getSmoothFlags();

		void		setVert(int i, const Point3 &xyz)	{ verts[i] = xyz; }
		void		setVert(int i, float x, float y, float z)	{ verts[i].x=x; verts[i].y=y; verts[i].z=z; }
		void		setTVert(int i, const UVVert &xyz)	{ tVerts[i] = xyz; }
		void		setTVert(int i, float x, float y, float z)	{ tVerts[i].x=x; tVerts[i].y=y; tVerts[i].z=z; }
		
		DllExport void		setNormal(int i, const Point3 &xyz); 
		DllExport Point3 &	getNormal(int i) const; // mjm - made const - 2.16.99

		void		setFaceNormal(int i, const Point3 &xyz) { faceNormal[i] =  xyz; }
		Point3 &	getFaceNormal(int i) { return faceNormal[i]; }

		Point3 &	getVert(int i)		{ return verts[i];  }
		Point3 *	getVertPtr(int i)	{ return verts+i; }
		UVVert &	getTVert(int i)		{ return tVerts[i];  }
		UVVert *	getTVertPtr(int i)	{ return tVerts+i; }
		RVertex &	getRVert(int i)		{ return rVerts[i]; }
		RVertex *	getRVertPtr(int i)	{ return rVerts+i; }
		
		void		setMtlIndex(MtlID	i)	{ mtlIndex = i; }
		MtlID		getMtlIndex(void) 		{ return mtlIndex; }

		// Face MtlIndex access methods;
	    DllExport MtlID		getFaceMtlIndex(int i);
		DllExport void		setFaceMtlIndex(int i, MtlID id); 	
		
		DllExport void		buildNormals();			// calcs face and vertex normals
		DllExport void 		buildRenderNormals();	// like buildNormals, but ignores mtlIndex
		// checkNormals can be used to build the normals and allocate RVert space 
		// only if necessary.  This is a very cheap call if the normals are already calculated.
		// When illum is FALSE, only the RVerts allocation is checked (since normals aren't
		// needed for non-illum rendering).  When illum is TRUE, normals will also be built, if
		// they aren't already.  So, to make sure normals are built, call this with illum=TRUE.
		DllExport void		checkNormals(BOOL illum);

		DllExport void		render(GraphicsWindow *gw, Material *ma, RECT *rp, int compFlags, int numMat=1);
		DllExport BOOL		select(GraphicsWindow *gw, Material *ma, HitRegion *hr, int abortOnHit = FALSE, int numMat=1);
		DllExport void		snap(GraphicsWindow *gw, SnapInfo *snap, IPoint2 *p, Matrix3 &tm);
		DllExport BOOL 		SubObjectHitTest(GraphicsWindow *gw, Material *ma, HitRegion *hr,
								DWORD flags, SubObjHitList& hitList, int numMat=1 );

		void		displayNormals(int b, float sc)	{ dspNormals = b; if(sc != (float)0.0) norScale = sc; }
		void		displayAllEdges(int b)	{ dspAllEdges = b; }
		DllExport void		buildBoundingBox(void);
		DllExport Box3 		getBoundingBox(Matrix3 *tm=NULL); // RB: optional TM allows the box to be calculated in any space.
		                                              // NOTE: this will be slower becuase all the points must be transformed.
		// Cache invalidation
		DllExport void 		InvalidateGeomCache();
		DllExport void 		InvalidateTopologyCache();
		DllExport void 		FreeAll(); //DS
		DllExport void      ZeroTopologyCache(); // RB set pointers to NULL but don't delete from mem.

		// edge list functions		
		DllExport void		EnableEdgeList(int e);
		DllExport void     	BuildVisEdgeList();
		DllExport void 		DrawVisEdgeList(GraphicsWindow *gw, DWORD flags);
		DllExport void 		Draw3DVisEdgeList(GraphicsWindow *gw, DWORD flags);
		DllExport void		HitTestVisEdgeList(GraphicsWindow *gw, int abortOnHit ); // RB
		DllExport void		InvalidateEdgeList(); // RB

		// strip functions				
		DllExport BOOL     	BuildStrips();
		DllExport void		Stripify(Strip *s, StripData *sd, int vtx);
		DllExport void		getStripVertColor(GraphicsWindow *gw, int cv, int flipped, MtlID mID, DWORD smGroup, Point3 &rgb);
		DllExport void		getStripNormal(int cv, MtlID mID, DWORD smGroup, Point3 &nor);
		DllExport int		getStripNormalIndex(int cv, MtlID mID, DWORD smGroup);
		DllExport BOOL		getStripTVert(GraphicsWindow *gw, int cv, int ctv, Point3 &uvw);
		DllExport void 		DrawStrips(GraphicsWindow *gw, Material *ma, int numMat);
		DllExport void 		Draw3DStrips(GraphicsWindow *gw, Material *ma, int numMat);
		DllExport void 		Draw3DWireStrips(GraphicsWindow *gw, Material *ma, int numMat);
		DllExport void		InvalidateStrips();

		DllExport void		BuildStripsAndEdges();

		// functions for use in data flow evaluation
		DllExport void 		ShallowCopy(Mesh *amesh, unsigned long channels);
		DllExport void 		DeepCopy(Mesh *amesh, unsigned long channels);
		DllExport void		NewAndCopyChannels(unsigned long channels);
		DllExport void 		FreeChannels( unsigned long channels, int zeroOthers=1);

		// Mesh flags
		void		SetFlag(DWORD f) { flags |= f; }
		DWORD		GetFlag(DWORD f) { return flags & f; }
		void		ClearFlag(DWORD f) { flags &= ~f; }

		// Display flags
		void		SetDispFlag(DWORD f) { dispFlags |= f; }
		DWORD		GetDispFlag(DWORD f) { return dispFlags & f; }
		void		ClearDispFlag(DWORD f) { dispFlags &= ~f; }

		// Selection access
		BitArray& 	VertSel() { return vertSel;  }	
		BitArray& 	FaceSel() { return faceSel;  }	

		// Constructs a vertex selection list based on the current selection level.
		DllExport BitArray 	VertexTempSel();

		DllExport IOResult Save(ISave* isave);
		DllExport IOResult Load(ILoad* iload);

		// RB: added so all objects can easily support the GeomObject method of the same name.
		DllExport int IntersectRay(Ray& ray, float& at, Point3& norm);
		DllExport int IntersectRay(Ray& ray, float& at, Point3& norm, DWORD &fi, Point3 &bary);

		// RB: I couldn't resist adding these <g>
		DllExport Mesh operator+(Mesh &mesh);  // Union
		DllExport Mesh operator-(Mesh &mesh);  // Difference
		DllExport Mesh operator*(Mesh &mesh);  // Intersection
		DllExport void MyDebugPrint ();

		DllExport void WeldCollinear(BitArray &set);

		DllExport void Optimize(
			float normThresh, float edgeThresh, 
			float bias, float maxEdge, DWORD flags, 
			MeshOpProgress *prog=NULL);

		DllExport void ApplyUVWMap(int type,
			float utile, float vtile, float wtile,
			int uflip, int vflip, int wflip, int cap,
			const Matrix3 &tm, int channel=1);
		DllExport void ApplyMapper (UVWMapper & map, int channel=1);

		DllExport void FlipNormal(int i);
		DllExport void UnifyNormals(BOOL selOnly);
		DllExport void AutoSmooth(float angle,BOOL useSel,BOOL preventIndirectSmoothing=FALSE);

		DllExport Edge *MakeEdgeList(int *edgeCount, int flagdbls=0);
		DllExport int DeleteFlaggedFaces(); // deletes all faces with FACE_WORK flag set
				
		
		// deletes all seleted elements of the current selection level
		DllExport void DeleteSelected();	
		
		// Deletes vertices as specified by the bit array
		DllExport void DeleteVertSet(BitArray set);
		
		// Deletes faces as specified by the bit array. If isoVert is non
		// null then it will be setup to flag vertices that were isolated
		// by the face deletetion. This set can then be passed to
		// DeleteVertSet to delete isolated vertices.
		DllExport void DeleteFaceSet(BitArray set, BitArray *isoVert=NULL);

		// Returns TRUE if an equivalent face already exists.
		DllExport BOOL DoesFaceExist(DWORD v0, DWORD v1, DWORD v2);

		// Removes faces that have two or more equal indices.
		// Returns TRUE if any degenerate faces were found
		DllExport BOOL RemoveDegenerateFaces();

		// Removes faces that have indices that are out of range
		// Returns TRUE if any illegal faces were found
		DllExport BOOL RemoveIllegalFaces();

		DllExport Point3 FaceNormal (DWORD fi, BOOL nrmlize=FALSE);
		DllExport Point3 FaceCenter (DWORD fi);
		DllExport float AngleBetweenFaces(DWORD f0, DWORD f1);

		// Compute the barycentric coords of a point in the plane of
		// a face relative to that face.
		DllExport Point3 BaryCoords(DWORD face, Point3 p);

		// Some edge operations
		DllExport void DivideEdge(DWORD edge, float prop=.5f, bool visDiag1=TRUE,
			bool fixNeighbors=TRUE, bool visDiag2=TRUE);
		DllExport void DivideFace(DWORD face, DWORD e1, DWORD e2, 
			float prop1=.5f, float prop2=.5f, bool fixNeighbors=TRUE, bool split=FALSE);
		DllExport void TurnEdge (DWORD edge, DWORD *otherEdge=NULL);

		// Tessellation
		DllExport void FaceCenterTessellate(BOOL ignoreSel=FALSE, MeshOpProgress *mop=NULL);
		DllExport void EdgeTessellate(float tens,BOOL ignoreSel=FALSE, MeshOpProgress *mop=NULL);

		// Extrudes selected faces. Note that this is just a topological
		// change. The new extruded faces do not change position but
		// are left on top of the original faces.
		// If doFace is FALSE then selected edges are extruded.
		DllExport void ExtrudeFaces(BOOL doFace=TRUE);

		// Indents selected faces, in a manner consistent with the outlining used in Bevel.
		// Added by SteveA for Shiva, 6/98
		DllExport void IndentSelFaces (float amount);

		// Splits verts specified in bitarray so that they are only
		// used by a single face
		DllExport void BreakVerts(BitArray set);

		// Deletes verts that aren't used by any faces
		DllExport BitArray GetIsoVerts ();
		DllExport void DeleteIsoVerts ();

		// Clone faces (and verts used by those faces)
		DllExport void CloneFaces(BitArray fset);
		DllExport void PolyFromFace (DWORD f, BitArray &set, float thresh, BOOL ignoreVisEdges, AdjFaceList *af=NULL);
		DllExport void ElementFromFace (DWORD f, BitArray &set, AdjFaceList *af=NULL);
		DllExport void FindVertsUsedOnlyByFaces (BitArray & fset, BitArray & vset);
		DllExport void FindOpenEdges (BitArray & edges);
		DllExport void FindVertexAngles (float *vang, BitArray *set=NULL);

		// used by the renderer
		void  SetRenderData(MeshRenderData *p) {renderData = p; } 
		MeshRenderData * GetRenderData() { return renderData; }
	};

class ImbMesh: public Mesh {
	public:
		~ImbMesh();
	};

// Mapping types passed to ApplyUVWMap()
#define MAP_PLANAR		0
#define MAP_CYLINDRICAL	1
#define MAP_SPHERICAL	2
#define MAP_BALL		3
#define MAP_BOX			4
#define MAP_FACE		5


// Optimize flags
#define OPTIMIZE_SAVEMATBOUNDRIES		(1<<0)
#define OPTIMIZE_SAVESMOOTHBOUNDRIES	(1<<1)
#define OPTIMIZE_AUTOEDGE				(1<<2)

void DllExport setUseVisEdge(int b);
int DllExport getUseVisEdge();

#define SMALL_VERTEX_DOTS	0
#define LARGE_VERTEX_DOTS	1

void DllExport setUseVertexDots(int b);
int DllExport getUseVertexDots();

void DllExport setVertexDotType(int t);
int DllExport getVertexDotType();

// a callback to update progress UI while doing a
// lengthy operation to a mesh
class MeshOpProgress {
	public:
		// called once with the total increments
		virtual void Init(int total)=0;

		// Called to update progress. % done = p/total
		virtual BOOL Progress(int p)=0;
	};

// Boolean operations for meshes:
#define MESHBOOL_UNION 				1
#define MESHBOOL_INTERSECTION  		2
#define MESHBOOL_DIFFERENCE 		3

//
// mesh = mesh1 op mesh2
// If tm1 or tm2 are non-NULL, the points of the corresponding
// mesh will be transformed by these tm before the bool op
// The mesh will be transformed back by either Inverse(tm1) or
// Inverse(tm2) depending whichInv (0=>tm1, 1=>tm2)
// unless whichInv is -1 in which case it will not be transformed
// back.
//
int DllExport CalcBoolOp(
	Mesh &mesh, Mesh &mesh1, Mesh &mesh2, int op,
	MeshOpProgress *prog = NULL,
	Matrix3 *tm1 = NULL,
	Matrix3 *tm2 = NULL,
	int whichInv = 0,
	int weld = TRUE);


// Combines two meshes. The matrix and whichInv parameters have
// the same meaning as they do for the CalcBoolOp above.
void DllExport CombineMeshes(
		Mesh &mesh,Mesh &mesh1,Mesh &mesh2,
		Matrix3 *tm1=NULL, Matrix3 *tm2=NULL, int whichInv=0);

// Slices a single mesh.  The Point3 N and the float offset define a
// slicing plane (by DotProd (N,X) = offset).  Default behavior is to
// split faces that cross the plane, producing 1-2 new faces on each side
// and a new vert in the middle of each edge crossing the plane.  split
// means to add 2 different but coincident points to the top and bottom
// sets of faces, splitting the mesh into two meshes.  remove means to
// delete all faces & verts below the plane.
void DllExport SliceMesh (Mesh & mesh,
						  Point3 N, float off, bool split=FALSE, bool remove=FALSE);

// Handy utilities to go with meshes:

// Translates map type into 3d location -> uvw coord mapper:
class UVWMapper {
public:
	int     type, cap;
	float   utile, vtile, wtile;
	int     uflip, vflip, wflip;
	Matrix3 tm;

	DllExport UVWMapper();
	DllExport UVWMapper(int type, const Matrix3 &tm, int cap=FALSE,
		float utile=1.0f, float vtile=1.0f, float wtile=1.0f,
		int uflip=FALSE, int vflip=FALSE, int wflip=FALSE);
	DllExport UVWMapper(UVWMapper& m);

	DllExport UVVert MapPoint(Point3 p, const Point3 & norm, int *nan=NULL);
	DllExport UVVert TileFlip (UVVert uvw);
	DllExport int MainAxis (const Point3 & n);
	bool NormalMatters () { return ((type==MAP_BOX)||((type==MAP_CYLINDRICAL)&&cap)) ? TRUE:FALSE; }
};

DllExport Mesh * CreateNewMesh();

#endif // _MESH_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\MeshDelta.h ===
// MeshDelta.h
// By Steve Anderson of Kinetix.
// Created June 1998

#ifndef __MESHDELTA__
#define __MESHDELTA__

#include "export.h"
#ifndef __MESHADJ__
#include "meshadj.h"
#endif

// STEVE: MeshDeltas and/or MapDeltas lack the following clever features:
// - Realloc amounts: currently we realloc arrays with no extra room for growth (dv especially).

// These classes encompass the notion of a "Mesh Edit".  They are the principal means
// of keeping track of what's going on in the Edit Mesh modifier, and have many standard
// mesh edits available for use elsewhere.

// Principle is that, while these work as designed on the right mesh, they will give
// some result on the wrong mesh.

// Order of operations:
// Verts/TVerts/CVerts created or cloned.
// Faces created -- indices correspond to original vert list, then create, then clone.
// Face attributes & indices changed.
// Verts & faces deleted.

// "Channels" of data in MeshDelta -- different from PART_GEOM type channels!
#define MDELTA_VMOVE 0x0001
#define MDELTA_VCREATE 0x0002
#define MDELTA_VCLONE 0x0004
#define MDELTA_VDELETE 0x0008
#define MDELTA_VDATA 0x0010
#define MDELTA_FREMAP 0x0020
#define MDELTA_FCHANGE 0x0040
#define MDELTA_FCREATE 0x0080
#define MDELTA_FDELETE 0x0100
#define MDELTA_FDATA 0x0200
#define MDELTA_NUMBERS 0x0400
#define MDELTA_FSMOOTH 0x0800
#define MDELTA_ALL 0xffff

class VertMove {
public:
	DWORD vid;
	Point3 dv;

	VertMove () {}
	VertMove (DWORD i, Point3 p) { vid=i; dv=p; }
	~VertMove () {}
	VertMove & operator= (VertMove & from) { vid=from.vid; dv=from.dv; return (*this); }
};

class UVVertSet {
public:
	DWORD vid;
	UVVert v;

	UVVertSet () {}
	UVVertSet (DWORD i, UVVert p) { vid=i; v=p; }
	~UVVertSet () {}
	UVVertSet & operator= (UVVertSet & from) { vid=from.vid; v=from.v; return (*this); }
};

#define FR_V0	1
#define FR_V1	2
#define FR_V2	4
#define FR_ALL	7

class FaceRemap {
public:
	DWORD f, flags, v[3];	// Face being remapped
	FaceRemap () { f=flags=0; }
	FaceRemap (DWORD ff, DWORD fl, DWORD *vv) { f=ff; flags=fl; memcpy (v,vv,3*sizeof(DWORD)); }
	DllExport void Apply (Face &ff);
	DllExport void Apply (TVFace & tf);
	DllExport void Apply (FaceRemap & fr);
	Face operator* (Face &ff) { Face nf=ff; Apply(nf); return nf; }
	TVFace operator* (TVFace & ff) { TVFace nf=ff; Apply(nf); return nf; }
};

// Attribute changes available for faces:
#define ATTRIB_EDGE_A		(1<<0)
#define ATTRIB_EDGE_B		(1<<1)
#define ATTRIB_EDGE_C		(1<<2)
#define ATTRIB_EDGE_ALL	 7
#define ATTRIB_HIDE_FACE		(1<<3)
#define ATTRIB_MATID		(1<<4)

// Mat ID takes bits 5-21
#define ATTRIB_MATID_SHIFT	5
#define ATTRIB_MATID_MASK	0xffff

class FaceChange {
public:
	DWORD f, flags, val;
	FaceChange () { f=flags=0; }
	FaceChange (DWORD ff, DWORD fl, DWORD v) { f=ff; flags=fl; val=v; }
	DllExport void Apply (Face &ff);
	DllExport void Apply (FaceChange & fa);
};

class FaceSmooth {
public:
	DWORD f, mask, val;
	FaceSmooth () { f=mask=0; }
	FaceSmooth (DWORD ff, DWORD mk, DWORD vl) { f=ff; mask=mk; val=vl; }
	DllExport void Apply (Face &ff);
	DllExport void Apply (FaceSmooth & fs);
};

//STEVE: someday support applying a standard mapping to selected faces?
class MapDelta {
public:
	DWORD vnum, fnum;
	Tab<UVVertSet> vSet;
	Tab<Point3> vCreate;
	Tab<TVFace> fCreate;	// New texture vert faces -- matches master MeshDelta fCreate in size.
	Tab<FaceRemap> fRemap;	// ordered list of faces using at least one new vertex.

	MapDelta () { vnum=0; fnum=0; }
	DllExport void ClearAllOps ();

	// Bookkeeping:
	DllExport int NumVSet (DWORD inVNum);
	DllExport void SetInVNum (DWORD n);
	DllExport void SetInFNum (DWORD n);
	DWORD outVNum () { return vnum + vCreate.Count(); }
	DWORD outVNum (DWORD inVNum) { return inVNum + vCreate.Count(); }
	bool IsCreate (DWORD i) { int j=i-vnum; return ((j>=0) && (j<vCreate.Count())); }
	DllExport DWORD SetID (DWORD i);

	// Topological ops:
	DllExport DWORD VCreate (UVVert *v, int num=1);
	DllExport void FCreate (TVFace *f, int num=1);
	DllExport void FCreateDefault (int num=1);
	DllExport void FCreateQuad (DWORD *t);
	DllExport void FClone (TVFace & tf, DWORD remapFlags=0, DWORD *v=NULL);
	DllExport void FRemap (DWORD f, DWORD flags, DWORD *v);	// Creates a (or modifies an existing) remap record.
	void FRemap (FaceRemap & fr) { FRemap (fr.f, fr.flags, fr.v); }
	DllExport DWORD RemapID (DWORD ff);
	DllExport DWORD IsRemapped (DWORD ff, DWORD vid);
	DllExport TVFace OutFace (TVFace *mf, DWORD ff);
	DllExport void FDelete (int offset, BitArray & fdel);

	// Geometric ops:
	DllExport void Set (DWORD i, const UVVert & p);
	DllExport void Set (BitArray & sel, const UVVert & p);

	// Uses:
	MapDelta & operator=(MapDelta & from) { CopyMDChannels (from, MDELTA_ALL); return *this; }
	DllExport MapDelta & operator*=(MapDelta & from);
	DllExport void Apply (UVVert *tv, TVFace *tf, DWORD inVNum, DWORD inFNum);

	// Handy debugging output
	DllExport void MyDebugPrint ();

	// Backup stuff:
	DllExport DWORD ChangeFlags ();
	DllExport void CopyMDChannels (MapDelta & from, DWORD channels);

	// Double-checking routines, good for after loading.
	// Return TRUE if already correct, FALSE if they had to make a correction.
	DllExport BOOL CheckOrder ();	// Checks for out of order sets or remaps
	DllExport BOOL CheckFaces ();	// Checks remaps & fCreates for out of bound map vert id's.
};

class VDataDelta {
public:
	PerData *out;

	VDataDelta () { out=NULL; }
	~VDataDelta () { if (out) delete out; }
	void SetVNum (int nv, BOOL keep=FALSE) { if (out) out->SetCount(nv,keep); }
	void Activate (int vnum, int vdID) { if (out==NULL) out = new PerData(vnum, VertexDataType(vdID)); }
	DllExport void Set (int where, void *data, int num=1);
};

class MeshDelta {
	DWORD *vlut, *flut;
	int vlutSize, flutSize;

	// Internal methods:
	// Parts of Cut:
	DWORD FindBestNextFace (Mesh & m, Tab<DWORD> *vfac, Point3 *cpv, DWORD startV, Point3 & svP);
	DWORD FindOtherFace (DWORD ff, Tab<DWORD> * vfa, Tab<DWORD> * vfb);
public:
	DWORD vnum, fnum;

	Tab<VertMove> vMove;	// Ordered list of moves to existing verts
	Tab<Point3> vCreate;	// Creation-order list of new points
	Tab<VertMove> vClone;	// Creation-order list of cloned points.
	BitArray vDelete;

	Tab<Face> fCreate;			// New faces
	Tab<FaceRemap> fRemap;	// existing faces using new verts.  (Ordered list.)
	Tab<FaceChange> fChange;	// ordered list of face flag changes
	Tab<FaceSmooth> fSmooth;	// ordered list of face smoothing group changes
	BitArray fDelete;	// Also applies to map faces.

	BitArray vsel, esel, fsel, vhide;	// Based on output mesh indexing.

	MapDelta *map;
	BitArray mapSupport;

	VDataDelta *vd;	// Based on output mesh indexing.
	BitArray vdSupport;

	DllExport MeshDelta ();
	DllExport MeshDelta (const Mesh & m);
	DllExport ~MeshDelta ();

	DllExport void InitToMesh (const Mesh & m);
	DllExport void ClearAllOps ();
	DllExport void SetMapNum (int n, bool keep=TRUE);
	int GetMapNum () { return mapSupport.GetSize(); }
	DllExport void SetVDataNum (int size, bool keep=TRUE);
	int GetVDataNum () { return vdSupport.GetSize(); }
	DllExport DWORD PartsChanged ();

	// The main work of a MeshDelta.
	DllExport void Apply(Mesh& mesh);
	MeshDelta& operator=(MeshDelta& td) { CopyMDChannels (td, MDELTA_ALL); return *this; }
	MeshDelta& operator*=(MeshDelta& td) { Compose(td); return *this; }
	DllExport void Compose (MeshDelta & td, Tab<DWORD> *cloneRemapTable=NULL);

	// Following give numbers of clones or deletions, given the input numbers.
	// (We can't delete vertex 10 on an 8-vert mesh; this counts the number of valid entries.)
	DllExport DWORD NumVMove (DWORD inVNum);
	DllExport DWORD NumVClone (DWORD inVNum);
	DllExport DWORD NumVDelete (DWORD inVNum);
	DllExport DWORD NumFDelete (DWORD inFNum);

	// Sets the size of the input object -- should be used only in multiplying MeshDeltas,
	// since it destroys records of changes to out-of-range components.
	// MeshDelta may be applied to mesh without using these.
	DllExport void SetInFNum (int nface);
	DllExport void SetInVNum (int nv);

	int outVNum () { return vnum + vCreate.Count() + vClone.Count() - vDelete.NumberSet(); }
	int outVNum (int inVNum) { return inVNum + vCreate.Count() + NumVClone(inVNum) - NumVDelete(inVNum); }
	int outFNum () { return fnum + fCreate.Count() - fDelete.NumberSet(); }
	int outFNum (int inFNum) { return inFNum + fCreate.Count() - NumFDelete(inFNum); }

	DllExport void FillInFaces (Mesh & m);	// Fills in undefined mapping face verts.
	DllExport void AddVertexColors ();	// Adds vertex color mapdelta to match this meshdelta.
	DllExport void AddMap (int mapID); // Adds mapdelta on specified channel to match this meshdelta.
	DllExport void AddVertexData (int vdChan, Mesh *m=NULL);

	// Create lookup tables for fast conversion of pre- and post- vert/face indices.
	DllExport void UpdateLUTs (int extraV=0, int extraF=0);
	DllExport void ClearLUTs ();

	// Following methods turn output indices to input indices.
	DllExport DWORD VLut (DWORD i);
	DllExport DWORD FLut (DWORD i);
	// Following methods turn input indices to output indices.
	DllExport DWORD PostVIndex (DWORD i);
	DllExport DWORD PostFIndex (DWORD i);
	// Following operate on output indices
	bool IsVClone (DWORD i) { int j=VLut(i)-vnum-vCreate.Count(); return ((j>=0) && (j<vClone.Count())); }
	DWORD VCloneOf (DWORD i) { int j=VLut(i)-vnum-vCreate.Count(); return ((j>=0) && (j<vClone.Count())) ? vClone[j].vid : UNDEFINED; }
	bool IsVCreate (DWORD i) { int j=VLut(i)-vnum; return ((j>=0) && (j<vCreate.Count())); }
	bool IsFCreate (DWORD i) { int j=FLut(i)-fnum; return ((j>=0) && (j<fCreate.Count())); }
	DllExport DWORD MoveID (DWORD i);

	// Basic topological operations:
	// Those that accept DWORD indices require post-operation indices.
	DllExport DWORD VCreate (Point3 *p, int num=1, BitArray *sel=NULL, BitArray *hide=NULL);
	DllExport DWORD VClone (DWORD *v, int num=1);
	DllExport DWORD VClone (DWORD *v, Point3 *off, int num=1);
	DllExport DWORD VClone (VertMove *vm, int num=1);
	DWORD VClone (DWORD v) { return VClone (&v, 1); }
	DWORD VClone (DWORD v, Point3 off) { return VClone (&v, &off, 1); }
	DllExport Point3 OutVert (Mesh & m, DWORD v);
	DllExport void VDelete (DWORD *v, int num=1);
	DllExport void VDelete (BitArray & vdel);
	DllExport DWORD FCreate (Face *f, int num=1);
	DllExport DWORD FCreateQuad (DWORD *v, DWORD smG=0, MtlID matID=0);
	DllExport DWORD FClone (Face & f, DWORD ff, DWORD remapFlags=0, DWORD *v=NULL);
	DllExport void CreateDefaultMapFaces (int num=1);
	DllExport void FRemap (FaceRemap *f, int num=1);
	DllExport void FRemap (DWORD f, DWORD flags, DWORD *v);
	DllExport DWORD RemapID (DWORD ff);
	DllExport DWORD IsRemapped (DWORD ff, DWORD vid);
	DllExport Face OutFace (Mesh & m, DWORD ff);
	DllExport void FChange (FaceChange *f, int num=1);
	DllExport void FChange (DWORD f, DWORD flags, DWORD dat);
	DllExport void FSmooth (FaceSmooth *f, int num=1);
	DllExport void FSmooth (DWORD f, DWORD mask, DWORD val);
	void SetMatID (DWORD f, MtlID mt) { FChange (f, ATTRIB_MATID, mt<<ATTRIB_MATID_SHIFT); }
	void SetSmGroup (DWORD f, DWORD smG) { FSmooth (f, ~0x0, smG); }
	void SetEdgeVis (DWORD f, DWORD ed, BOOL vis=TRUE) { FChange (f, (1<<ed), vis?(1<<ed):0); }
	DllExport void FDelete (DWORD *f, int num=1);
	DllExport void FDelete (BitArray & fdel);

	// Following method will turn vertex clones-of-creates into separate creates, fixing rest of MeshDelta to match.
	DllExport void DigestClones (Tab<DWORD> *cloneRemapTable=NULL);

	// Geometric ops:
	DllExport void Move (int i, const Point3 & p);
	DllExport void Move (BitArray & sel, const Point3 & p);
	DllExport void Move (VertMove *vm, int num);

	// Gotta be able to save and load this complex thing...
	DllExport IOResult Save (ISave *isave);
	DllExport IOResult Load (ILoad *iload);

	// Handy debugging output
	DllExport void MyDebugPrint (bool lut=FALSE, bool mp=FALSE);

	// Backup-relevant characteristics:
	DllExport DWORD ChangeFlags (Tab<DWORD> *mChannels=NULL);
	DllExport void CopyMDChannels (MeshDelta & from, DWORD channels, Tab<DWORD> *mChannels=NULL);

	// Double-checking routines, good for after loading.
	// Returns TRUE if order was already correct, FALSE if it had to make a correction.
	DllExport BOOL CheckOrder ();
	DllExport BOOL CheckMapFaces ();

	// More complex operations, built on the list above.
	// Mesh given is expected to be result of the current MeshDelta.
	// Found in MDAppOps.cpp
	DllExport void AutoSmooth(Mesh &m, BitArray sel, float angle, AdjFaceList *af=NULL, AdjEdgeList *ae=NULL);
	DllExport void Bevel (Mesh & m, BitArray vset, float outline, Tab<Point3> *odir,
		float height, Tab<Point3> *hdir);
	DllExport DWORD CreatePolygon (Mesh & m, int deg, int *v, DWORD smG=0, MtlID matID=0);
	DllExport void DeleteVertSet (Mesh & m, BitArray sel);	// does delete faces
	DllExport void DeleteEdgeSet (Mesh & m, BitArray sel);	// doesn't delete verts
	DllExport void DeleteFaceSet (Mesh & m, BitArray sel);	// doesn't delete verts.
	DllExport void DeleteSelected (Mesh & m);
	DllExport void DeleteIsoVerts (Mesh & m);
	DllExport void FlipNormal (Mesh & m, DWORD face);
	DllExport void MakeSelFacesPlanar (Mesh &m, BitArray sel);
	DllExport void MakeSelVertsPlanar (Mesh &m, BitArray sel);
	DllExport void MoveVertsToPlane (Mesh & m, BitArray sel, Point3 & N, float offset);
	DllExport void RestrictMatIDs (Mesh & m, int numMats);	// like "FitMeshIDsToMaterial".
	DllExport void SelectFacesByFlags (Mesh & m, BOOL onoff, DWORD flagmask, DWORD flags);
	// if adj is non-NULL, it uses it to set the "other side" visible too.
	DllExport void SetSingleEdgeVis (Mesh & m, DWORD ed, BOOL vis, AdjFaceList *adj=NULL);

	// Following will initialize to the mesh given: they can't be used to "add" ops to an existing MeshDelta.
	// (To add these ops, make a new MeshDelta, call one of the following, and append it to your previous one with Compose.)
	// Found in MDOps.cpp
	DllExport void AttachMesh (Mesh & m, Mesh &attachment, Matrix3 & relativeTransform,
		int matOffset);
	DllExport void BreakVerts (Mesh & m, BitArray vset);
	DllExport void ChamferEdges (Mesh & m, BitArray eset, MeshChamferData &mcd, AdjEdgeList *ae=NULL);
	DllExport void ChamferMove (Mesh & m, MeshChamferData &mcd, float amount, AdjEdgeList *ae=NULL);
	DllExport void ChamferVertices (Mesh & m, BitArray vset, MeshChamferData &mcd, AdjEdgeList *ae=NULL);
	DllExport void CloneFaces (Mesh & m, BitArray fset);
	DllExport void CloneVerts (Mesh & m, BitArray vset);
	DllExport void CollapseEdges(Mesh &m, BitArray ecol, AdjEdgeList *ae=NULL);
	DllExport DWORD Cut (Mesh & m, DWORD ed1, float prop1, DWORD ed2, float prop2,
		Point3 & norm, bool fixNeighbors=TRUE, bool split=FALSE);
	DllExport void Detach (Mesh & m, Mesh *out, BitArray fset, BOOL faces, BOOL del, BOOL elem);
	DllExport void DivideEdge (Mesh & m, DWORD ed, float prop=.5f, AdjEdgeList *el=NULL,
		bool visDiag1=FALSE, bool fixNeighbors=TRUE, bool visDiag2=FALSE, bool split=FALSE);
	DllExport void DivideEdges (Mesh & m, BitArray eset, AdjEdgeList *el=NULL);
	DllExport void DivideFace (Mesh & m, DWORD f, float *bary=NULL);
	DllExport void DivideFaces (Mesh & m, BitArray fset, MeshOpProgress *mop=NULL);
	DllExport void EdgeTessellate(Mesh &m, BitArray fset, float tens,
		AdjEdgeList *ae=NULL, AdjFaceList *af=NULL, MeshOpProgress *mop=NULL);
	DllExport void ExplodeFaces(Mesh &m, float thresh, bool useFaceSel=FALSE, AdjFaceList *af=NULL);
	DllExport void ExtrudeEdges (Mesh & m, BitArray eset, Tab<Point3> *edir=NULL);
	DllExport void ExtrudeFaces (Mesh & m, BitArray fset, AdjEdgeList *el=NULL);
	DllExport void ResetVertWeights (Mesh & m);
	DllExport void SetFaceColors (Mesh &m, BitArray fset, VertColor vc);
	DllExport void SetVertColors (Mesh &m, BitArray vset, VertColor vc);
	DllExport void SetVertWeights (Mesh &m, BitArray vset, float weight);
	DllExport DWORD TurnEdge (Mesh & m, DWORD ed, AdjEdgeList *el=NULL);
	DllExport BOOL WeldByThreshold (Mesh & m, BitArray vset, float thresh);
	DllExport void WeldVertSet (Mesh & m, BitArray vset, Point3 *weldPoint=NULL);
	DllExport void PropagateFacing (Mesh & m, BitArray & fset, int face,
		AdjFaceList &af, BitArray &done,BOOL bias=1);
	DllExport void UnifyNormals (Mesh & m, BitArray fset, AdjFaceList *af=NULL);

	// In slicer.cpp:
	DllExport void Slice (Mesh & m, Point3 N, float off, bool sep=FALSE, bool remove=FALSE, BitArray *fslice=NULL, AdjEdgeList *ae=NULL);
};

// Following classes provide standard interface for modifiers and objects that
// use mesh deltas -- specifically Edit Mesh and Editable Mesh for now.

enum meshCommandMode { McmCreate, McmAttach, McmExtrude, McmBevel, McmChamfer,
		McmSlicePlane, McmCut, McmWeldTarget, McmFlipNormalMode, McmDivide, McmTurnEdge };
enum meshButtonOp    { MopHide, MopUnhideAll, MopDelete, MopDetach, MopBreak, MopViewAlign,
		MopGridAlign, MopMakePlanar, MopCollapse, MopTessellate, MopExplode, MopSlice, MopWeld,
		MopRemoveIsolatedVerts, MopSelectOpenEdges, MopCreateShapeFromEdges, MopShowNormal,
		MopFlipNormal, MopUnifyNormal, MopAutoSmooth, MopVisibleEdge, MopInvisibleEdge, MopAutoEdge };
enum meshUIParam { MuiSelByVert, MuiIgBack, MuiIgnoreVis, MuiPolyThresh, MuiSoftSel,
		MuiSSUseEDist, MuiSSEDist, MuiSSBack, MuiFalloff, MuiPinch, MuiBubble,
		MuiWeldBoxSize, MuiWeldDist, MuiExtrudeType };

#define EM_SL_OBJECT 0
#define EM_SL_VERTEX 1
#define EM_SL_EDGE 2
#define EM_SL_FACE 3
#define EM_SL_POLYGON 4
#define EM_SL_ELEMENT 5

class MeshDeltaUser {
public:
	virtual void LocalDataChanged (DWORD parts)=0;
	// start or stop interactive command mode, uses mode enum above
	virtual void ToggleCommandMode (meshCommandMode mode)=0;
	// perform button op, uses op enum above
	virtual void ButtonOp (meshButtonOp opcode)=0;

	// UI controls access
	virtual void GetUIParam (meshUIParam uiCode, int & ret) { }
	virtual void SetUIParam (meshUIParam uiCode, int val) { }
	virtual void GetUIParam (meshUIParam uiCode, float & ret) { }
	virtual void SetUIParam (meshUIParam uiCode, float val) { }
	virtual void UpdateApproxUI () { }

	// Should work on any local command mode.
	virtual void ExitCommandModes ()=0;

	virtual bool Editing () { return FALSE; }	// returns TRUE iff between BeginEditParams, EndEditParams
	virtual DWORD GetEMeshSelLevel () { return EM_SL_OBJECT; }
	virtual void SetEMeshSelLevel (DWORD sl) { }
};

class MeshDeltaUserData {
public:
	virtual void ApplyMeshDelta (MeshDelta & md, MeshDeltaUser *mdu, TimeValue t)=0;
	virtual MeshDelta *GetCurrentMDState () { return NULL; }	// only non-null in Edit Mesh
	// functional interface to mesh ops
	virtual void MoveSelection(int level, TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin)=0;
	virtual void RotateSelection(int level, TimeValue t, Matrix3& partm, Matrix3& tmAxis, Quat& val, BOOL localOrigin)=0;
	virtual void ScaleSelection(int level, TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin)=0;
	virtual void ExtrudeSelection(int level, BitArray* sel, float amount, float bevel, BOOL groupNormal, Point3* direction)=0;
};

// Constants used in Edit(able) Mesh's shortcut table - THESE MUST BE MATCHED to values in Editable Mesh's resources.
#define EM_SHORTCUT_ID 0x38ba1366

#define MDUID_EM_SELTYPE                   40001
#define MDUID_EM_SELTYPE_BACK              40002
#define MDUID_EM_SELTYPE_VERTEX            40003
#define MDUID_EM_SELTYPE_EDGE              40004
#define MDUID_EM_SELTYPE_FACE              40005
#define MDUID_EM_SELTYPE_POLYGON           40006
#define MDUID_EM_SELTYPE_ELEMENT           40007
#define MDUID_EM_SELTYPE_OBJ               40008
#define MDUID_EM_AUTOSMOOTH                40009
#define MDUID_EM_ATTACH                    40010
#define MDUID_EM_BREAK                     40011
#define MDUID_EM_IGBACK                    40012
#define MDUID_EM_BEVEL                     40013
#define MDUID_EM_CREATE                    40014
#define MDUID_EM_CUT                       40015
#define MDUID_EM_DIVIDE                    40016
#define MDUID_EM_EXTRUDE                   40017
#define MDUID_EM_FLIPNORM                  40018
#define MDUID_EM_SS_BACKFACE               40019
#define MDUID_EM_UNIFY_NORMALS             40020
#define MDUID_EM_HIDE                      40021
#define MDUID_EM_EDGE_INVIS                40022
#define MDUID_EM_IGNORE_INVIS                 40023
#define MDUID_EM_IGNORE_INVIS              40023
#define MDUID_EM_COLLAPSE                  40024
#define MDUID_EM_SHOWNORMAL                40025
#define MDUID_EM_SELOPEN                   40026
#define MDUID_EM_REMOVE_ISO                40027
#define MDUID_EM_SLICEPLANE                40028
#define MDUID_EM_SOFTSEL                   40029
#define MDUID_EM_SLICE                     40030
#define MDUID_EM_DETACH                    40031
#define MDUID_EM_TURNEDGE                  40032
#define MDUID_EM_UNHIDE                    40033
#define MDUID_EM_EDGE_VIS                  40034
#define MDUID_EM_SELBYVERT                 40035
#define MDUID_EM_AUTOEDGE                  40036
#define MDUID_EM_WELD                      40038
#define MDUID_EM_EXPLODE                   40039

DllExport void FindTriangulation (Mesh & m, int deg, int *vv, int *tri);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\meshadj.h ===
/**********************************************************************
 *<
	FILE: meshadj.h

	DESCRIPTION: Adjacency list for meshes.

	CREATED BY: Rolf Berteig

	HISTORY:	Extended for Shiva by: Steve Anderson

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __MESHADJ__
#define __MESHADJ__

#include "export.h"

#ifndef UNDEFINED
#define UNDEFINED	0xffffffff
#endif

class AdjFaceList;

class MEdge {
public:
	DWORD f[2];
	DWORD v[2];

	DllExport int EdgeIndex(Face *faces,int side);
	DllExport BOOL Selected (Face *faces,BitArray &esel);
	DllExport BOOL Visible (Face *faces);
	DllExport BOOL Hidden (Face *faces);
	DllExport Point3 Center(Point3 *verts);
	DllExport BOOL AFaceSelected(BitArray &fsel);
	DllExport Point3 ButterFlySubdivide(Mesh *mesh,AdjFaceList *af,float tens);
	DWORD OtherVert (DWORD vv) { return (v[0] == vv) ? v[1] : v[0]; }
	DWORD OtherFace (DWORD ff) { return (f[0] == ff) ? f[1] : f[0]; }
};

class AdjEdgeList {
public:
	DWORDTab *list; 	// 1 DWORDTab per vertex. The Tab is a list of indices into the edge list, 1 for each edge adjacent to the vertex
	Tab<MEdge> edges;	// Table of edges
	int nverts;			// size of 'list'.

	DllExport AdjEdgeList(Mesh& amesh);
	~AdjEdgeList() { if (list) delete [] list; }

	DllExport void AddEdge( DWORD fi, DWORD v1, DWORD v2 );
	DWORDTab& operator[](int i) { return list[i]; }
	DllExport int FindEdge(DWORD v0, DWORD v1);
	DllExport int FindEdge(DWORDTab& vmap,DWORD v0, DWORD v1);		
	DllExport void TransferEdges(DWORD from,DWORD to,DWORD except1,DWORD except2,DWORD del);
	DllExport void RemoveEdge(DWORD from,DWORD e);
	DllExport void OrderAllEdges (Face *faces);	// only affects order in each vert's list.
	DllExport void OrderVertEdges (DWORD v, Face *faces, Tab<DWORD> *flist=NULL);
	DllExport void GetFaceList (DWORD v, Tab<DWORD> & flist);

	DllExport void MyDebugPrint ();

	void AddEdgeToVertex(DWORD v,DWORD e) { list[v].Append (1, &e); }
};

class AdjFace {
public:
	DWORD f[3];
	AdjFace() {f[0] = f[1] = f[2] = UNDEFINED;}
};

class AdjFaceList {
public:
	Tab<AdjFace> list;

	AdjFace& operator[](int i) {return list[i];}
	DllExport AdjFaceList(Mesh& mesh,AdjEdgeList& el);
};

class FaceElementList {
public:
	// For each face, which element is it in
	DWORDTab elem;
	DWORD count;
	DllExport FaceElementList(Mesh &mesh,AdjFaceList& af);
	DWORD operator[](int i) {return elem[i];}
};

class FaceClusterList {
public:
	// Cluster #, one for each face - non-selected faces have UNDEFINED for their id.
	DWORDTab clust;
	DWORD count;

	// This version separates cluster also using a minimum angle and optionally the selection set
	DllExport FaceClusterList(Mesh *mesh, AdjFaceList& adj,float angle,BOOL useSel=TRUE);		
	// Uses selection set
	DllExport FaceClusterList (BitArray& fsel, AdjFaceList& adj);		
	DWORD operator[](int i) { return clust[i]; }
	DllExport void MakeVertCluster(Mesh &mesh, Tab<DWORD> & vclust);
	DllExport void GetNormalsCenters (Mesh &mesh, Tab<Point3> & norm, Tab<Point3> & ctr);
	DllExport void GetBorder (DWORD clustID, AdjFaceList & af, Tab<DWORD> & cbord);
	DllExport void GetOutlineVectors (Mesh & m, AdjFaceList & af, Tab<Point3> & cnorms, Tab<Point3> & odir);
};

class EdgeClusterList {
public:
	DWORDTab clust;
	DWORD count;

	DllExport EdgeClusterList(Mesh &mesh,BitArray &esel,AdjEdgeList &adj);
	DWORD ID(int f, int e) {return clust[f*3+e];}
	DWORD operator[](int i) {return clust[i];}
	DllExport void MakeVertCluster (Mesh &mesh, Tab<DWORD> & vclust);
	DllExport void GetNormalsCenters (Mesh &mesh, Tab<Point3> & norm, Tab<Point3> & ctr);
};

class MeshChamferData {
public:
	Tab<Point3> vdir;
	Tab<float> vmax;
	Tab<UVVert> *mdir;

	MeshChamferData () { mdir=NULL; }
	MeshChamferData (const Mesh & m) { mdir=NULL; InitToMesh(m); }
	~MeshChamferData () { if (mdir) delete [] mdir; }

	DllExport void InitToMesh (const Mesh & m);
	DllExport void setNumVerts (int nv, bool keep=TRUE, int resizer=0);
};

// following is never saved: it's a collection of all the temporary data you might want to cache about a mesh.
// Extrusion types:
#define MESH_EXTRUDE_CLUSTER 1
#define MESH_EXTRUDE_LOCAL 2

class MeshTempData {
private:
	AdjEdgeList *adjEList;
	AdjFaceList *adjFList;
	EdgeClusterList *edgeCluster;
	FaceClusterList *faceCluster;
	Tab<DWORD> *vertCluster;
	Tab<Point3> *normals;
	Tab<Point3> *centers;
	Tab<Point3> *vnormals;
	Tab<Tab<float> *> *clustDist;
	Tab<float> *selDist;
	Tab<float> *vsWeight;
	MeshChamferData *chamData;

	Tab<Point3> *extDir;
	Tab<Point3> *outlineDir;

	Mesh *mesh;

public:
	DllExport MeshTempData ();
	DllExport MeshTempData (Mesh *m);
	DllExport ~MeshTempData ();

	void SetMesh (Mesh *m) { mesh = m; }

	DllExport AdjEdgeList *AdjEList ();
	DllExport AdjFaceList *AdjFList ();
	DllExport FaceClusterList *FaceClusters ();
	DllExport EdgeClusterList *EdgeClusters ();
	DllExport Tab<DWORD> *VertexClusters (DWORD sl);
	DllExport Tab<Point3> *ClusterNormals (DWORD sl);
	DllExport Tab<Point3> *ClusterCenters (DWORD sl);
	DllExport Matrix3 ClusterTM (int clust);
	DllExport Tab<Point3> *VertexNormals ();
	DllExport Tab<float> *VSWeight (BOOL useEdgeDist, int edgeIts,
									BOOL ignoreBack, float falloff, float pinch, float bubble);
	DllExport Tab<float> *SelectionDist (BOOL useEdgeDist, int edgeIts);
	DllExport Tab<float> *ClusterDist (DWORD sl, int clustId, BOOL useEdgeDist, int edgeIts);
	DllExport Tab<Point3> *EdgeExtDir (Tab<Point3> *edir, int extrusionType);
	DllExport Tab<Point3> *FaceExtDir (int extrusionType);
	Tab<Point3> *CurrentExtDir () { return extDir; }
	DllExport Tab<Point3> *OutlineDir (int extrusionType);

	DllExport MeshChamferData *ChamferData();

	DllExport void Invalidate (DWORD part);
	DllExport void InvalidateDistances ();
	DllExport void InvalidateAffectRegion ();
	DllExport void freeClusterDist ();
	DllExport void freeBevelInfo ();
	DllExport void freeChamferData();
	DllExport void freeAll ();
};

DllExport float AffectRegionFunction (float dist, float falloff, float pinch, float bubble);
DllExport Point3 SoftSelectionColor (float selAmount);
DllExport void MatrixFromNormal (Point3& normal, Matrix3& mat);
DllExport void AverageVertexNormals (Mesh & mesh, Tab<Point3> & vnormals);
DllExport Point3 AverageSelVertNormal (Mesh& mesh);
DllExport Point3 AverageSelVertCenter (Mesh& mesh);
DllExport void DeselectHiddenFaces (Mesh &mesh);
DllExport void DeselectHiddenEdges (Mesh &mesh);
DllExport void HiddenFacesToVerts (Mesh &mesh, BitArray alsoHide);
DllExport void SelectionDistance (Mesh & mesh, float *selDist);
DllExport void SelectionDistance (Mesh & mesh, float *selDist, int iters, AdjEdgeList *ae=NULL);
DllExport void ClustDistances (Mesh & mesh, DWORD numClusts, DWORD *vclust,
							   Tab<float> **clustDist);
DllExport void ClustDistances (Mesh & mesh, DWORD numClusts, DWORD *vclust,
							   Tab<float> **clustDist, int iters, AdjEdgeList *ae=NULL);

#endif //__MESHADJ__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\meshlib.h ===
#ifndef _MESHLIB_H_

#define _MESHLIB_H_

#define IMPORTING
#include "mesh.h"
#undef IMPORTING

#endif // _MESHLIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\MNMath.h ===
// MN Math.h
// Collection of headers for MNMath library

#ifndef __MNMATH_H_
#define __MNMATH_H_

#include "MNCommon.h"
#include "MNMesh.h"
#include "MNBigMat.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\MeshDLib.h ===
#ifndef _MESHADJLIB_H_

#define _MESHADJLIB_H_
#define IMPORTING
#include "export.h"
#include "meshadj.h"
#include "MeshDelta.h"
#undef IMPORTING

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\MNBigMat.h ===
// MNBigMat.h
// Created by Steve Anderson, Nov. 22 1996.

// BigMatrix is for when I need good old-fashioned mxn matrices.

// Classes:
// BigMatrix

#ifndef __MN_BIGMAT_H_
#define __MN_BIGMAT_H_

#define BIGMAT_MAX_SIZE 10000

class BigMatrix {
public:
	int m, n;
	float *val;

	BigMatrix () { val=NULL; m=0; n=0; }
	DllExport BigMatrix (int mm, int nn);
	DllExport BigMatrix (const BigMatrix & from);
	~BigMatrix () { Clear (); }

	DllExport void Clear ();
	DllExport int SetSize (int mm, int nn);

	DllExport float *operator[](int i) const;
	DllExport BigMatrix & operator= (const BigMatrix & from);

	DllExport void SetTranspose (BigMatrix & trans) const;
	DllExport float Invert();
	DllExport void Identity ();

	// Debugging functions:
	DllExport void Randomize (float scale);
	DllExport void MNDebugPrint ();

	// Do not use -- does nothing.  (Replaced by MNDebugPrint.)
	DllExport void dump (FILE *fp);
};

DllExport extern BOOL BigMatMult (BigMatrix & a, BigMatrix & b, BigMatrix &c);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\midiman.h ===
/**********************************************************************
 *<
	FILE: midiman.h

	DESCRIPTION: A manager for MIDI

	CREATED BY: Rolf Berteig

	HISTORY: 6/7/97

 *>	Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/

#ifndef __MIDIMAN__
#define __MIDIMAN__

#include <mmsystem.h>
#include <mmreg.h>


// This is the same function type that is passed to the Win32 API midiInOpen()
// except that it returns a DWORD instead of void.
typedef DWORD(*MIDI_IN_PROC)(HMIDIIN hMidiIn,UINT wMsg, DWORD dwInstance,DWORD dwParam1, DWORD dwParam2);

// Return values from MIDI_IN_PROC
#define MIDIPROC_PROCESSED		1			// The message was processed and so no other callbacks should be called.
#define MIDIPROC_NOTPROCESSED	0			// The message was not processed.

// These can be called to open/close/start/stop the midi in device.
// The MIDI device can be opened more than once... it will only actually
// close when Close() is called as many times as Open().
CoreExport MMRESULT MIDIMan_Open(MIDI_IN_PROC proc,DWORD dwInstance,int priority=0);
CoreExport MMRESULT MIDIMan_Close(MIDI_IN_PROC proc,DWORD dwInstance);
CoreExport MMRESULT MIDIMan_Start();
CoreExport MMRESULT MIDIMan_Stop();
CoreExport BOOL MIDIMan_IsOpened();
CoreExport BOOL MIDIMan_IsStarted();

// To temporary close and stop the MIDI device use these methods. These
// will preserve the state of the Open/Close Start/Stop stack.
CoreExport void MIDIMan_Suspend();
CoreExport void MIDIMan_Resume();

// Macros to pull out peices of param1
#define MIDI_CHANNEL(a)				((a)&0x0f)
#define MIDI_EVENT(a)				((a)&0xf0)
#define MIDI_NOTENUMBER(a)			(((a)&0xff00)>>8)
#define MIDI_VELOCITY(a)			(((a)&0xff0000)>>16)
#define MIDI_PITCHBEND(a)			(((a)&0xff0000)>>16)
#define MIDI_NOTEFLOAT(a,low,high)	(float((a)-(low))/float((high)-(low)))
#define MIDI_VELFLOAT(a)            (float(a)/127.0f)
#define MIDI_BENDFLOAT(a)			(float(a)/127.0f)

// MIDI events
#define MIDI_NOTE_ON		0x90
#define MIDI_NOTE_OFF		0x80
#define MIDI_PITCH_BEND		0xe0
#define MIDI_CONTROLCHANGE	0xb0


#endif // __MIDIMAN__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\MNMesh.h ===
/**********************************************************************
 *<
	FILE: MNMesh.h

	DESCRIPTION:  Special mesh structures useful for face and edge based mesh operations.

	CREATED BY: Steve Anderson, working for Kinetix!

	HISTORY: created March 1997 from old SDMesh and WMesh.

 *>	Copyright (c) 1996 Autodesk, Inc., All Rights Reserved.
 **********************************************************************/

// Necessary prior inclusions: max.h

// Classes:
// MNMesh
// MNVert
// MNEdge
// MNFace
// MNMeshBorder

#ifndef __MN_MESH_H_
#define __MN_MESH_H_

#define REALLOC_SIZE 10

// Boolean types: we use the same ones defined in mesh.h
//#define MESHBOOL_UNION 1
//#define MESHBOOL_INTERSECTION 2
//#define MESHBOOL_DIFFERENCE 3

// General flags for all components
// For MNVerts, MNEdges, and MNFaces, bits 0-7 are used for common characteristics
// of all components.  Bits 8-15 are used for component-specific flags.  Bits 16-23 are reserved
// for temporary use in MNMesh algorithms.  Bits 24-31 are reserved for MNMath.lib users.
#define MN_SEL (1<<0)
#define MN_DEAD (1<<1)
#define MN_TARG (1<<2)
#define MN_BACKFACING (1<<3)
#define MN_HIDDEN (1<<4)
#define MN_WHATEVER (1<<16) // Temporary flag used internally for whatever.
#define MN_USER (1<<24)	// Anything above this can be used by applications.

// Vertex flags
#define MN_VERT_DONE (1<<8)
#define MN_VERT_HIDDEN (1<<9)	// different from MN_HIDDEN - means a vert is on a face's hvtx list.

class MNMesh;

class MNVert : public FlagUser {
public:
	Point3 p;
	int orig;	// Original point this vert comes from. -- STEVE, remove, only used in connect.

	MNVert () { orig = -1; }
	DllExport MNVert & operator= (MNVert & from);
};

// Edge flags
#define MN_EDGE_INVIS (1<<8)
#define MN_EDGE_NOCROSS (1<<9)
#define MN_EDGE_MAP_SEAM (1<<10)

// Edge goes from v1 to v2
// f1 is forward-indexing face (face on "left" if surface normal above, v2 in front)
// f2 is backward-indexing face, or -1 if no such face exists.  (Face on "right")
class MNEdge : public FlagUser {
public:
	int v1, v2;
	int f1, f2;
	int track;	// Keep track of whatever.

	MNEdge() { Init(); }
	MNEdge (int vv1, int vv2, int fc) { f1=fc; f2=-1; v1=vv1; v2=vv2; track=-1; }
	void Init() { v1=v2=f1=0; f2=-1; track=-1; }
	int OtherFace (int ff) { return (ff==f1) ? f2 : f1; }
	int OtherVert (int vv) { return (vv==v1) ? v2 : v1; }
	void Invert () { int hold=v1; v1=v2; v2=hold; hold=f1; f1=f2; f2=hold; }
	DllExport void ReplaceFace (int of, int nf, int vv1=-1);
	void ReplaceVert (int ov, int nv) { if (v1 == ov) v1 = nv; else { MaxAssert (v2==ov); v2 = nv; } }
	DllExport bool Uncrossable ();
	DllExport MNEdge & operator= (const MNEdge & from);
	DllExport void MNDebugPrint ();
};

class MNMapFace {
	friend class MNMesh;
	int dalloc, halloc;
public:
	int deg, hdeg;
	int *tv, *htv;

	MNMapFace() { Init(); }
	DllExport MNMapFace (int d, int h=0);
	~MNMapFace () { Clear(); }
	DllExport void Init();
	DllExport void Clear();
	DllExport void SetAlloc (int d, int h=0);
	void SetSize (int d, int h=0) { SetAlloc(d,h); deg=d; hdeg=h; }
	DllExport void MakePoly (int fdeg, int *tt);
	DllExport void Insert (int pos, int num=1);
	DllExport void Delete (int pos, int num=1);
	DllExport void HInsert (int pos, int num=1);
	DllExport void HDelete (int pos, int num=1);
	DllExport void RotateStart (int newstart);
	DllExport void Flip ();	// Reverses order of verts.  0 remains start.

	DllExport int VertIndex (int vv);
	DllExport void ReplaceVert (int ov, int nv);

	DllExport MNMapFace & operator= (const MNMapFace & from);
	DllExport void MNDebugPrint (bool hinfo=TRUE);
};

// MNFace flags:
#define MN_FACE_OPEN_REGION (1<<8)	// Face is not part of closed submesh.
#define MN_FACE_CHECKED (1<<9)	// for recursive face-and-neighbor-checking
#define MN_FACE_CHANGED (1<<10)

class MNFace : public FlagUser {
	friend class MNMesh;
	int dalloc, halloc, talloc;
	void Init();
	void SwapContents (MNFace & from);
public:
	int deg;	// Degree: number of vtx's and edg's that are relevant.
	int *vtx;	// Defining verts of this face.
	int *edg;
	int *tri;	// Triangulation
	int hdeg;
	int *hvtx;	// Hidden verts
	DWORD smGroup;
	MtlID material;
	int track;	// Keep track of whatever -- MNMesh internal use only.
	BitArray visedg, edgsel;

	MNFace() { Init(); }
	DllExport MNFace (int d, int h=0);
	DllExport MNFace (const MNFace *from);
	~MNFace () { Clear(); }
	DllExport void Clear();
	int TriNum() { return deg - 2 + 2*hdeg; }
	DllExport int TriVert(int k);
	DllExport void SetAlloc (int d, int h=0);
	DllExport void MakePoly (int fdeg, int *vv, bool *vis=NULL, bool *sel=NULL);
	DllExport void Insert (int pos, int num=1);
	DllExport bool Delete (int pos, int num=1, int edir=1, bool fixtri=TRUE);
	DllExport void HInsert (int pos, int num=1);
	DllExport void HDelete (int pos, int num=1);
	DllExport void RotateStart (int newstart);
	DllExport void Flip ();	// Reverses order of verts.  0 remains start.

	DllExport int VertIndex (int vv, int ee=-1);
	DllExport int EdgeIndex (int ee, int vv=-1);
	DllExport void ReplaceVert (int ov, int nv, int ee=-1);
	DllExport void ReplaceEdge (int oe, int ne, int vv=-1);

	DllExport MNFace & operator= (const MNFace & from);
	DllExport void MNDebugPrint (bool triprint=FALSE, bool hinfo=TRUE);

	DllExport IOResult Save (ISave *isave);
	DllExport IOResult Load (ILoad *iload);
};

/*
class MNFaceTriCache {
friend class MNMesh;
	int fid;
	int deg;
	int *tri;
	int hdeg;
	int *htri;
	double *hbary;

	MNFaceTriCache () { tri=NULL; htri=NULL; hbary=NULL; hdeg=0; deg=0; fid=-1; }
	~MNFaceTriCache () { if (tri) delete [] tri; if (htri) delete [] htri; if (hbary) delete [] hbary; }

	DllExport void SetDeg (int degg);
	DllExport void SetHDeg (int hdegg);
};
*/

class MNMap : public FlagUser {
	friend class MNMesh;
	int nv_alloc, nf_alloc;
public:
	MNMapFace *f;
	UVVert *v;

	int numv, numf;

	MNMap () { Init(); }
	~MNMap () { ClearAndFree (); }

	// Initialization, allocation:
	DllExport void Init ();
	DllExport void VAlloc (int num, bool keep=TRUE);
	DllExport void FAlloc (int num, bool keep=TRUE);

	// Data access:
	int VNum () const { return numv; }
	UVVert V(int i) const { return v[i]; }
	int FNum () const { return numf; }
	MNMapFace *F(int i) const { return &(f[i]); }

	// Adding new components -- all allocation should go through here!
	DllExport int NewTri (int a, int b, int c);
	DllExport int NewTri (int *vv);
	DllExport int NewQuad (int a, int b, int c, int d);
	DllExport int NewQuad (int *vv);
	DllExport int NewFace (int degg=0, int *vv=NULL);
	DllExport void setNumFaces (int nfnum);
	DllExport int NewVert (UVVert p, int uoff=0, int voff=0);
	DllExport void setNumVerts (int nvnum);

	DllExport void CollapseDeadVerts (MNFace *faces);	// Figures out which are dead.
	DllExport void CollapseDeadFaces (MNFace *faces);
	DllExport void Clear ();	// Deletes everything.
	DllExport void ClearAndFree ();	// Deletes everything, frees all memory

	DllExport void Transform (Matrix3 & xfm);	// o(n) -- transforms verts

	// operators and debug printing
	DllExport MNMap & operator= (const MNMap & from);
	DllExport MNMap & operator+= (const MNMap & from);
	DllExport MNMap & operator+= (const MNMesh & from);
	DllExport void ShallowCopy (const MNMap & from);
	DllExport void NewAndCopy ();
	DllExport void MNDebugPrint (MNFace *faces);
	DllExport bool CheckAllData (int mp, int nf, MNFace *faces);

	DllExport IOResult Save (ISave *isave, MNFace *faces=NULL);
	DllExport IOResult Load (ILoad *iload, MNFace *faces=NULL);
};

// Per-edge data
#define MAX_EDGEDATA 10
#define EDATA_KNOT 0

DllExport int EdgeDataType (int edID);
DllExport void *EdgeDataDefault (int edID);

#define MN_MESH_NONTRI (1<<0) // At least 2 triangles have been joined
#define MN_MESH_FILLED_IN (1<<1) // All topological links complete
#define MN_MESH_RATSNEST (1<<2) // Set if we've replicated points to avoid rats' nest meshes.
#define MN_MESH_NO_BAD_VERTS (1<<3)	// Set if we've established that each vert has exactly one connected component of faces & edges.
#define MN_MESH_VERTS_ORDERED (1<<4)	// Set if we've ordered the fac, edg tables in each vert.
#define MN_MESH_HAS_VOLUME (1<<7)	// Some subset of mesh describes closed surface of solid

#define MN_MESH_CACHE_FLAGS (MN_MESH_FILLED_IN|MN_MESH_NO_BAD_VERTS|MN_MESH_VERTS_ORDERED)

class MNMeshBorder;

typedef MNMap * MNMP;

// MNMesh selection levels:
#define MNM_SL_OBJECT 0
#define MNM_SL_VERTEX 1
#define MNM_SL_EDGE 2
#define MNM_SL_FACE 3
#define MNM_SL_TRI 4

// MNMesh display flags
#define MNDISP_VERTTICKS 0x01
#define MNDISP_SELVERTS	0x02
#define MNDISP_SELFACES	0x04
#define MNDISP_SELEDGES	0x08
#define MNDISP_NORMALS 0x10
#define MNDISP_SMOOTH_SUBSEL 0x20
#define MNDISP_BEEN_DISP 0x40

class MNMesh : public FlagUser {
private:
	int nv_alloc, ne_alloc, nf_alloc, nm_alloc;

	// Cache geometric data for quick rendering
	Box3 bdgBox;
	Point3 *fnorm;
	RVertex *rVerts;		// <<< instance specific.
	GraphicsWindow *cacheGW;  		// identifies rVerts cache
	int normalsBuilt;
	float norScale;

	//Tab<MNFaceTriCache *> tcache;

	// Internal part of SabinDoo method:
	void SDVEdgeFace (int id, int vid, int *fv, Tab<Tab<int> *> & fmv, DWORD selLevel);

	// Internal part of recursive smoothing-group search.
	DWORD FindReplacementSmGroup (int ff, DWORD os, int call);

	// Internal parts of Boolean. (MNBool.cpp)
	int BooleanZip (DWORD sortFlag, float weldThresh);
	bool BoolZipSeam (Tab<int> *lpi, Tab<int> *lpj, int & starth, int & startk, float weldThresh);
	void BoolPaintClassification (int ff, DWORD classification, int calldepth);

	// Internal data cache stuff (MNPipe.cpp)
	void buildBoundingBox ();
	void buildFaceNormals ();

public:
	MNVert *v;
	MNEdge *e;
	MNFace *f;
	MNMap *m;
	int numv, nume, numf, numm;

	// Vertex Data -- handled as in Meshes:
	PerData *vd;
	BitArray vdSupport;

	// Edge Data
	PerData *ed;
	BitArray edSupport;

	DWORD selLevel;
	DWORD dispFlags;

	// Derived data:
	Tab<int> *vedg;
	Tab<int> *vfac;

	// Basic class ops
	MNMesh () { Init(); DefaultFlags (); }
	MNMesh (const Mesh & from) { Init(); SetFromTri (from); FillInMesh (); }
	MNMesh (const MNMesh & from) { Init(); DefaultFlags(); *this = from; }
	~MNMesh() { ClearAndFree (); }

	// Initialization:
	void DefaultFlags () { ClearAllFlags (); }
	DllExport void Init ();

	// Array allocation: these functions (& Init) have sole control over nvalloc, etc.
	void VAlloc (int num, bool keep=TRUE);
	void VShrink (int num=-1);	// default means "Shrink array allocation to numv"
	void freeVEdge();
	void VEdgeAlloc();
	void freeVFace();
	void VFaceAlloc();
	void EAlloc (int num, bool keep=TRUE);
	void EShrink (int num=-1);
	void FAlloc (int num, bool keep=TRUE);
	void FShrink (int num=-1);
	void MAlloc (int num, bool keep=TRUE);
	void MShrink (int num=-1);

	// Access to components
	int VNum () const { return numv; }
	MNVert *V(int i) const { return &(v[i]); }
	Point3 & P(int i) const { return v[i].p; }
	int ENum () const { return nume; }
	MNEdge *E(int i) const { return &(e[i]); }
	int FNum () const { return numf; }
	MNFace *F(int i) const { return &(f[i]); }
	int MNum () const { return numm; }
	MNMap *M(int i) const { return &(m[i]); }
	DllExport void SetMapNum (int mpnum);
	DllExport void InitMap (int mp);	// Inits to current MNMesh topology.
	void ClearMap (int mp) { if (mp<numm) { m[mp].SetFlag (MN_DEAD); m[mp].ClearAndFree (); } }
	UVVert MV (int mp, int i) const { return m[mp].v[i]; }
	MNMapFace *MF (int mp, int i) const { return m[mp].F(i); }
	DllExport int TriNum () const;
	DllExport int HVNum (bool selFaces=FALSE) const;

	// Per Vertex Data:
	DllExport void setNumVData (int ct, BOOL keep=FALSE);
	int VDNum () const { return vdSupport.GetSize(); }

	DllExport BOOL vDataSupport (int vdChan) const;
	DllExport void setVDataSupport (int vdChan, BOOL support=TRUE);
	void *vertexData (int vdChan) const { return vDataSupport(vdChan) ? vd[vdChan].data : NULL; }
	float *vertexFloat (int vdChan) const { return (float *) vertexData (vdChan); }
	DllExport void freeVData (int vdChan);
	DllExport void freeAllVData ();

	// Two specific vertex data: these VDATA constants are defined in mesh.h
	float *getVertexWeights () { return vertexFloat(VDATA_WEIGHT); }
	void SupportVertexWeights () { setVDataSupport (VDATA_WEIGHT); }
	void freeVertexWeights () { freeVData (VDATA_WEIGHT); }
	float *getVSelectionWeights () { return vertexFloat(VDATA_SELECT); }
	void SupportVSelectionWeights () { setVDataSupport (VDATA_SELECT); }
	void freeVSelectionWeights () { freeVData (VDATA_SELECT); }

	// Per Edge Data:
	DllExport void setNumEData (int ct, BOOL keep=FALSE);
	int EDNum () const { return edSupport.GetSize(); }

	DllExport BOOL eDataSupport (int edChan) const;
	DllExport void setEDataSupport (int edChan, BOOL support=TRUE);
	void *edgeData (int edChan) const { return eDataSupport(edChan) ? ed[edChan].data : NULL; }
	float *edgeFloat (int edChan) const { return (float *) edgeData (edChan); }
	DllExport void freeEData (int edChan);
	DllExport void freeAllEData ();

	// One specific edge data: this EDATA constant is defined above
	float *getEdgeKnots () { return edgeFloat(EDATA_KNOT); }
	void SupportEdgeKnots () { setEDataSupport (EDATA_KNOT); }
	void freeEdgeKnots () { freeEData (EDATA_KNOT); }

	// Vertex face/edge list methods:
	DllExport void VClear (int vv);
	DllExport void VInit (int vv);
	DllExport int VFaceIndex (int vv, int ff, int ee=-1);
	DllExport int VEdgeIndex (int vv, int ee);
	void VDeleteEdge (int vv, int ee) { if (vedg) vedg[vv].Delete (VEdgeIndex(vv, ee), 1); }
	DllExport void VDeleteFace (int vv, int ff);
	DllExport void VReplaceEdge (int vv, int oe, int ne);
	DllExport void VReplaceFace (int vv, int of, int nf);
	DllExport void CopyVert (int nv, int ov);	// copies face & edge too if appropriate
	DllExport void MNVDebugPrint (int vv);

	// Adding new components -- all allocation should go through here!
	DllExport int NewTri (int a, int b, int c, DWORD smG=0, MtlID mt=0);
	DllExport int NewTri (int *vv, DWORD smG=0, MtlID mt=0);
	DllExport int NewQuad (int a, int b, int c, int d, DWORD smG=0, MtlID mt=0);
	DllExport int NewQuad (int *vv, DWORD smG=0, MtlID mt=0);
	DllExport int NewFace (int initFace, int degg=0, int *vv=NULL, bool *vis=NULL, bool *sel=NULL);
	DllExport int AppendNewFaces (int nfnum);
	DllExport void setNumFaces (int nfnum);
	DllExport int RegisterEdge (int v1, int v2, int f, int fpos);
	DllExport int SimpleNewEdge (int v1, int v2);
	DllExport int NewEdge (int v1, int v2, int f, int fpos);
	DllExport int AppendNewEdges (int nenum);
	DllExport void setNumEdges (int nenum);
	DllExport int NewVert (Point3 & p);
	DllExport int NewVert (Point3 & p, int vid);
	DllExport int NewVert (int vid);
	DllExport int NewVert (int v1, int v2, float prop);
	DllExport int AppendNewVerts (int nvnum);
	DllExport void setNumVerts (int nvnum);

	DllExport void KillUnusedHiddenVerts ();
	// To delete, set MN_*_DEAD flag and use following routines, which are all o(n).
	DllExport void CollapseDeadVerts ();
	DllExport void CollapseDeadEdges ();
	DllExport void CollapseDeadFaces ();
	DllExport void CollapseDeadStructs();
	DllExport void Clear ();	// Deletes everything.
	DllExport void ClearAndFree ();	// Deletes everything, frees all memory
	DllExport void freeVerts();
	DllExport void freeEdges();
	DllExport void freeFaces();
	DllExport void freeMap(int mp);
	DllExport void freeMaps();
	//DllExport void freeTCache();

	// En Masse flag-clearing and setting:
	void ClearVFlags (DWORD fl) { for (int i=0; i<numv; i++) v[i].ClearFlag (fl); }
	void ClearEFlags (DWORD fl) { for (int i=0; i<nume; i++) e[i].ClearFlag (fl); }
	void ClearFFlags (DWORD fl) { for (int i=0; i<numf; i++) f[i].ClearFlag (fl); }
	DllExport void PaintFaceFlag (int ff, DWORD fl, DWORD fenceflags=0x0);
	DllExport void VertexSelect (const BitArray & vsel);
	DllExport void EdgeSelect (const BitArray & esel);
	DllExport void FaceSelect (const BitArray & fsel);
	bool getVertexSel (BitArray & vsel) { return getVerticesByFlag (vsel, MN_SEL); }
	bool getEdgeSel (BitArray & esel) { return getEdgesByFlag (esel, MN_SEL); }
	bool getFaceSel (BitArray & fsel) { return getFacesByFlag (fsel, MN_SEL); }
	// In following 3, if fmask is 0 it's set to flags, so only those flags are compared.
	DllExport bool getVerticesByFlag (BitArray & vset, DWORD flags, DWORD fmask=0x0);
	DllExport bool getEdgesByFlag (BitArray & eset, DWORD flags, DWORD fmask=0x0);
	DllExport bool getFacesByFlag (BitArray & fset, DWORD flags, DWORD fmask=0x0);
	DllExport void ElementFromFace (int ff, BitArray & fset);
	DllExport void BorderFromEdge (int ee, BitArray & eset);

	// Following also set visedg, edgsel bits on faces:
	DllExport void SetEdgeVis (int ee, BOOL vis=TRUE);
	DllExport void SetEdgeSel (int ee, BOOL sel=TRUE);

	// I/O with regular Meshes.
	void SetFromTri (const Mesh & from) { Clear (); AddTri (from); }
	DllExport void AddTri (const Mesh & from);	// o(n) -- Add another mesh -- simple union
	DllExport void OutToTri (Mesh & tmesh);	// o(n)

	// Internal computation: each of the following 3 requires the previous.
	DllExport void FillInMesh ();	// o(n*5) or so
	DllExport void EliminateBadVerts ();	// o(n*8) or so
	DllExport void OrderVerts ();	// o(n*3) or so
	DllExport void Triangulate ();	// o(n)
	DllExport void TriangulateFace (int ff);	// o(triangles)

	// Random useful stuff.
	DllExport void Transform (Matrix3 & xfm);	// o(n) -- transforms verts
	bool IsClosed() { for (int i=0; i<nume; i++) if (e[i].f2<0) return FALSE; return nume?TRUE:FALSE; } // o(n)
	DllExport void FaceBBox (int ff, Box3 & bbox);
	DllExport void BBox (Box3 & bbox, bool targonly=FALSE);

	// Methods for handling MN_TARG flags.
	DllExport int TargetVertsBySelection (DWORD selLevel);	// o(n)
	DllExport int TargetEdgesBySelection (DWORD selLevel);	// o(n)
	DllExport int TargetFacesBySelection (DWORD selLevel);	// o(n)
	DllExport int PropegateComponentFlags (DWORD slTo, DWORD flTo,
		DWORD slFrom, DWORD flFrom, bool ampersand=FALSE, bool set=TRUE);
	DllExport void DetargetVertsBySharpness (float sharpval);	// o(n*deg)

	// Face-center methods
	DllExport void ComputeCenters (Point3 *ctr, bool targonly=FALSE);	// o(n)
	DllExport void ComputeCenter (int ff, Point3 & ctr);
	DllExport void ComputeSafeCenters (Point3 *ctr, bool targonly=FALSE, bool detarg=FALSE);	// o(n)
	DllExport bool ComputeSafeCenter (int ff, Point3 & ctr);	// o(deg^2)

	// Triangulation-of-polygon methods:
	DllExport void RetriangulateFace (int ff);	// o(deg^2)
	DllExport void FindExternalTriangulation (int ff, int *tri);
	DllExport void BestConvexTriangulation (int ff, int *tri=NULL);

	// Normal methods
	DllExport int FindEdgeFromVertToVert (int vrt1, int vrt2);	// o(deg)
	DllExport Point3 GetVertexNormal (int vrt);	// o(deg)
	DllExport Point3 GetEdgeNormal (int ed);	// o(deg)
	DllExport Point3 GetFaceNormal (int fc, bool nrmlz=FALSE);	//o(deg)
	Point3 GetEdgeNormal (int vrt1, int vrt2) { return GetEdgeNormal (FindEdgeFromVertToVert(vrt1, vrt2)); }

	// Smoothing-group handling
	DllExport void Resmooth (bool smooth=TRUE, bool targonly=FALSE, DWORD targmask=~0x0);	// o(n)
	DllExport DWORD CommonSmoothing (bool targonly=FALSE);	// o(n)
	DllExport DWORD GetNewSmGroup (bool targonly=FALSE);	// o(n)
	DllExport MtlID GetNewMtlID (bool targonly = FALSE); // o(n)
	DllExport DWORD GetOldSmGroup (bool targonly=FALSE);	// up to o(n).
	DllExport DWORD GetAllSmGroups (bool targonly=FALSE);	// up to o(n)
	DllExport DWORD FindReplacementSmGroup (int ff, DWORD os);
	DllExport void PaintNewSmGroup (int ff, DWORD os, DWORD ns);
	DllExport bool SeparateSmGroups (int v1, int v2);

	// Use following to unify triangles into polygons across invisible edges.
	DllExport void MakePolyMesh (int maxdeg=0, BOOL elimCollin=TRUE);
	// NOTE: MakeConvexPolyMesh result not guaranteed for now.  Still requires MakeConvex() afterwards to be sure.
	DllExport void MakeConvexPolyMesh (int maxdeg=0);
	DllExport void RemoveEdge (int edge);
	DllExport void MakeConvex ();
	DllExport void MakeFaceConvex (int ff);
	DllExport void EliminateCollinearVerts ();
	DllExport void EliminateCoincidentVerts (float thresh=MNEPS);

	// Following set NOCROSS flags, delete INVIS flags to make "fences" for Sabin-Doo
	DllExport void FenceMaterials ();
	DllExport void FenceSmGroups ();
	DllExport void FenceFaceSel ();
	DllExport void FenceOneSidedEdges();
	DllExport void FenceNonPlanarEdges (float thresh=.9999f);
	DllExport void SetMapSeamFlags (int mapID=-1);

	// Find get detail about a point on a face.
	DllExport int FindFacePointTri (int ff, Point3 & pt, double *bary=NULL, int *tri=NULL, int tnum=0);
	DllExport UVVert FindFacePointMapValue (int ff, Point3 & pt, int mp);

	// Extrapolate map information about a point near a face.
	DllExport UVVert ExtrapolateMapValue (int face, int edge, Point3 & pt, int mp);

	// Useful for tessellation algorithms
	DllExport void Relax (float relaxval, bool targonly=TRUE);

	// Returns map verts for both ends of each edge (from f1's perspective)
	// (Very useful for creating new faces at borders.) mv[j*2] corresponds to edge j's v1.
	DllExport void FindEdgeListMapVerts (const Tab<int> & lp, Tab<int> & mv, int mp);

	// Following functions can be used to find & fix holes in a mesh, if any.
	DllExport void GetBorder (MNMeshBorder & brd, DWORD selLevel=MESH_OBJECT);
	DllExport void FillInBorders (MNMeshBorder *b=NULL);
	DllExport void FindOpenRegions ();

	// To make hidden verts behave when moving real ones, use following:
	DllExport void PrepForGeomChange ();
	DllExport void CompleteGeomChange ();

	// operators and debug printing (MNFace.cpp)
	DllExport MNMesh & operator= (const MNMesh & from);
	DllExport MNMesh & operator+= (const MNMesh & from);
	DllExport void MNDebugPrint (bool triprint=FALSE);
	DllExport void MNDebugPrintVertexNeighborhood (int vv, bool triprint=FALSE);
	DllExport bool CheckAllData ();

	// Split functions maintain topological info.  (MNSplit.cpp)
	DllExport int SplitTriEdge (int ee, float prop=.5f, float thresh=MNEPS,
		bool neVis=TRUE, bool neSel=FALSE);
	DllExport int SplitTriFace (int ff, double *bary=NULL, float thresh=MNEPS,
		bool neVis=TRUE, bool neSel=FALSE);
	DllExport void SplitTri6 (int ff, double *bary=NULL, int *nv=NULL);
	DllExport int SplitEdge (int ee, float prop=.5f);
	DllExport int SplitEdge (int ee, float prop, int *ntv);
	DllExport int SplitEdge (int ff, int ed, float prop, bool right, int *nf=NULL,
		int *ne=NULL, bool neVis=FALSE, bool neSel=FALSE, bool allconvex=FALSE);
	DllExport int IndentFace (int ff, int ei, int nv, int *ne=NULL, bool nevis=TRUE, bool nesel=FALSE);
	DllExport void SeparateFace (int ff, int a, int b, int & nf, int & ne, bool neVis=FALSE, bool neSel=FALSE);
	DllExport void Slice (Point3 & N, float off, float thresh, bool split, bool remove, DWORD selLevel);
	DllExport void DeleteFlaggedFaces (DWORD deathflags, DWORD nvCopyFlags=0x0);
	DllExport bool WeldVerts (int a, int b);
	DllExport bool WeldEdge (int ee);

	// Tessellation methods: (MNTess.cpp)
	DllExport void TessellateByEdges (float bulge, MeshOpProgress *mop=NULL);
	DllExport bool AndersonDo (float interp, DWORD selLevel, MeshOpProgress *mop=NULL);
	DllExport void TessellateByCenters (MeshOpProgress *mop=NULL);

	// Sabin-Doo tessellation: (MNSabDoo.cpp)
	DllExport void SabinDoo (float interp, DWORD selLevel, MeshOpProgress *mop=NULL, Tab<Point3> *offsets=NULL);
	DllExport void SabinDooVert (int vid, float interp, DWORD selLevel, Point3 *ctr, Tab<Point3> *offsets=NULL);

	// Non-uniform Rational Mesh Smooth (NURMS.cpp)
	DllExport void CubicNURMS (MeshOpProgress *mop=NULL, Tab<Point3> *offsets=NULL);
	DllExport void QuadraticNURMS (MeshOpProgress *mop=NULL, Tab<Point3> *offsets=NULL);

	// Boolean functions: (MNBool.cpp)
	DllExport void PrepForBoolean ();
	DllExport bool BooleanCut (MNMesh & m2, int cutType, int fstart=0, MeshOpProgress *mop=NULL);
	DllExport bool MakeBoolean (MNMesh & m1, MNMesh & m2, int type, MeshOpProgress *mop=NULL);

	// New functionality: mostly pipeline object requirements.  (MNPipe.cpp)
	DllExport void ApplyMapper (UVWMapper & mp, BOOL channel=0, BOOL useSel=FALSE);
	DllExport void InvalidateGeomCache ();
	DllExport void InvalidateTopoCache ();
	DllExport void allocRVerts ();
	DllExport void updateRVerts (GraphicsWindow *gw);
	DllExport void freeRVerts ();

	GraphicsWindow *getCacheGW() { return cacheGW; }
	void setCacheGW(GraphicsWindow *gw) { cacheGW = gw; }

	DllExport void checkNormals (BOOL illum);
	DllExport void buildNormals ();
	DllExport void buildRenderNormals ();
	DllExport void UpdateBackfacing (GraphicsWindow *gw, bool force);

	// Display flags
	void		SetDispFlag(DWORD f) { dispFlags |= f; }
	DWORD		GetDispFlag(DWORD f) { return dispFlags & f; }
	void		ClearDispFlag(DWORD f) { dispFlags &= ~f; }

	DllExport void render(GraphicsWindow *gw, Material *ma, RECT *rp, int compFlags, int numMat=1);
	DllExport void renderFace (GraphicsWindow *gw, int ff);
	DllExport void renderEdge (GraphicsWindow *gw, int ee);
	DllExport BOOL select (GraphicsWindow *gw, Material *ma, HitRegion *hr, int abortOnHit=FALSE, int numMat=1);
	DllExport void		snap(GraphicsWindow *gw, SnapInfo *snap, IPoint2 *p, Matrix3 &tm);
	DllExport BOOL 		SubObjectHitTest(GraphicsWindow *gw, Material *ma, HitRegion *hr,
							DWORD flags, SubObjHitList& hitList, int numMat=1 );
	DllExport int IntersectRay (Ray& ray, float& at, Point3& norm);
	DllExport int IntersectRay (Ray& ray, float& at, Point3& norm, int &fi, int &ti, Point3 &bary);
	DllExport BitArray VertexTempSel (DWORD fmask=MN_DEAD, DWORD fset=0);

	DllExport void 		ShallowCopy(MNMesh *amesh, DWORD channels);
	DllExport void		NewAndCopyChannels(DWORD channels);
	DllExport void 		FreeChannels (DWORD channels, BOOL zeroOthers=1);

	DllExport IOResult Save (ISave *isave);
	DllExport IOResult Load (ILoad *iload);
};

class MNMeshBorder {
	friend class MNMesh;
	Tab<Tab<int> *> bdr;
	BitArray btarg;
public:
	~MNMeshBorder () { Clear(); }
	void Clear () { for (int i=0; i<bdr.Count(); i++) if (bdr[i]) delete bdr[i]; bdr.ZeroCount(); }
	int Num () { return bdr.Count(); }
	Tab<int> *Loop (int i) { return bdr[i]; }
	bool LoopTarg (int i) { return ((i>=0) && (i<bdr.Count()) && (btarg[i])); }
	DllExport void MNDebugPrint (MNMesh *m);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\MNCommon.h ===
// Common macros for all MNMath.

#ifndef MNEPS
#define MNEPS 1e-04f
#endif

// Selection levels for internal use:
#define MN_SEL_DEFAULT 0	// Default = use whatever's in mesh.
#define MN_SEL_OBJECT 1
#define MN_SEL_VERTEX 2
#define MN_SEL_EDGE 3
#define MN_SEL_FACE 4

// Got sick of redoing the following everywhere:
class FlagUser {
	DWORD FlagUserFlags;
public:
	FlagUser () { FlagUserFlags=0; }
	void SetFlag (DWORD fl, bool val=TRUE) { if (val) FlagUserFlags |= fl; else FlagUserFlags -= (FlagUserFlags & fl); }
	void ClearFlag (DWORD fl) { FlagUserFlags -= (FlagUserFlags & fl); }
	bool GetFlag (DWORD fl) const { return (FlagUserFlags & fl) ? 1 : 0; }
	void ClearAllFlags () { FlagUserFlags = 0; }

	void CopyFlags (DWORD fl) { FlagUserFlags = fl; }
	void CopyFlags (const FlagUser & fu) { FlagUserFlags = fu.FlagUserFlags; }
	void CopyFlags (const FlagUser * fu) { FlagUserFlags = fu->FlagUserFlags; }

	void CopyFlags (DWORD fl, DWORD mask) { FlagUserFlags |= (fl & mask); }
	void CopyFlags (const FlagUser &fu, DWORD mask) { FlagUserFlags |= (fu.FlagUserFlags & mask); }
	void CopyFlags (const FlagUser *fu, DWORD mask) { FlagUserFlags |= (fu->FlagUserFlags & mask); }

	void OrFlags (const FlagUser & fu) { FlagUserFlags |= fu.FlagUserFlags; }
	void OrFlags (const FlagUser * fu) { FlagUserFlags |= fu->FlagUserFlags; }

	void AndFlags (const FlagUser & fu) { FlagUserFlags &= fu.FlagUserFlags; }
	void AndFlags (const FlagUser * fu) { FlagUserFlags &= fu->FlagUserFlags; }

	bool FlagMatch (DWORD fmask, DWORD fl) const {
		return ((FlagUserFlags & fmask) == (fl & fmask));
	}
	bool FlagMatch (DWORD fmask, const FlagUser & fu) const {
		return ((FlagUserFlags & fmask) == (fu.FlagUserFlags & fmask));
	}
	bool FlagMatch (DWORD fmask, const FlagUser * fu) const {
		return ((FlagUserFlags & fmask) == (fu->FlagUserFlags & fmask));
	}

	DWORD ExportFlags () const { return FlagUserFlags; }
	void ImportFlags (DWORD fl) { FlagUserFlags = fl; }

	IOResult WriteFlags (ISave *isave, ULONG *nb) const {
		return isave->Write(&FlagUserFlags, sizeof(DWORD), nb);
	}
	IOResult ReadFlags (ILoad *iload, ULONG *nb) {
		return iload->Read (&FlagUserFlags, sizeof(DWORD), nb);
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\mouseman.h ===
/**********************************************************************
 *<
	FILE: mouseman.h

	DESCRIPTION:  Manages mouse input

	CREATED BY: Rolf Berteig
	
	HISTORY: created 18 October 1994

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __MOUSEMAN__
#define __MOUSEMAN__

#include "coreexp.h"

/* To create a mouse call back, derive a sub class of this
 * class and redefine 'proc'
 */

class MouseManager;

class MouseCallBack {
		MouseManager * mouseMan;
	public:
		virtual ~MouseCallBack() {}

		CoreExport virtual int proc( 
			HWND hwnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m );
		virtual void pan(IPoint2 offset) {}
		virtual int override(int mode) { return mode; }		// Return given mouse mode by default
		void setMouseManager(MouseManager *mm)  { mouseMan = mm; }
		MouseManager *getMouseManager()  { return mouseMan; }

		// Transform Gizmo Interface
		virtual BOOL SupportTransformGizmo() { return FALSE; }
		virtual void DeactivateTransformGizmo() {}
		// End of Transform Gizmo Interface

		virtual BOOL SupportAutoGrid(){return FALSE;}
		virtual BOOL TolerateOrthoMode(){return FALSE; }
	};


// Messages to a mouse procedure and mouseModes.
//
#define MOUSE_ABORT 		0
#define MOUSE_IDLE			0
#define MOUSE_POINT			1
#define MOUSE_MOVE			2
#define MOUSE_DBLCLICK		3
#define MOUSE_INIT			4
#define MOUSE_UNINIT		5
#define MOUSE_FREEMOVE		6
#define MOUSE_KEYBOARD		7
#define MOUSE_PROPCLICK		8
#define MOUSE_SNAPCLICK		9

// Drag modes.
#define CLICK_MODE_DEFAULT	0	// Returned by CreateMouseCallBack to indicate use of system mouse mode
#define CLICK_DRAG_CLICK	1
#define CLICK_MOVE_CLICK	2
#define CLICK_DOWN_POINT	3	// Point messages on mouse-down only

// Buttons
#define LEFT_BUTTON			0
#define MIDDLE_BUTTON		1
#define RIGHT_BUTTON		2

// Flags to mouse callback.
#define MOUSE_SHIFT			(1<<0)
#define MOUSE_CTRL			(1<<1)
#define MOUSE_ALT			(1<<2)
#define MOUSE_LBUTTON		(1<<3)	// Left button is down
#define MOUSE_MBUTTON		(1<<4)	// Middle button is down
#define MOUSE_RBUTTON		(1<<5)	// Right button is down

class MouseManager {
	private:
		// This is shared by all instances.
		static int clickDragMode;
		
		// These are local to each instance.
		int 			mouseMode;
		int 			curPoint;
		int         	curButton;
		MouseCallBack 	*TheMouseProc[3];
		int 			numPoints[3];
		int				buttonState[3];
		int				mouseProcReplaced;
		int 			inMouseProc;
#ifdef _OSNAP
		UINT			m_msg;
#endif
		HWND			captureWnd;

	public:
		// Constructor/Destructor
		CoreExport MouseManager();
		CoreExport ~MouseManager();

		CoreExport int SetMouseProc( MouseCallBack *mproc, int button, int numPoints=2 );
		CoreExport int SetDragMode( int mode );
		CoreExport int GetDragMode( );
		CoreExport int SetNumPoints( int numPoints, int button );
		CoreExport int ButtonFlags();
		CoreExport void Pan(IPoint2 p);
		CoreExport LRESULT CALLBACK MouseWinProc( 
			HWND hwnd, 
			UINT message, 
			WPARAM wParam, 
			LPARAM lParam );
		
		// RB 4-3-96: Resets back to the MOUSE_IDLE state
		CoreExport void Reset();
		int GetMouseMode() {return mouseMode;}
#ifdef _OSNAP
		UINT GetMouseMsg() {return m_msg;}
		int GetMousePoint() {return curPoint;}
#endif

		CoreExport void SetCapture(HWND hWnd);
		CoreExport HWND HasCapture();
		CoreExport void ReleaseCapture();
		CoreExport void RestoreCapture();
	};


#define WM_MOUSEABORT	(WM_USER + 7834)

// Indicates if ANY mouse proc is currently in the process of
// aborting a mouse proc.
CoreExport BOOL GetInMouseAbort();


#endif // __MOUSEMAN__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\modstack.h ===
/**********************************************************************
 *<
	FILE: modstack.h

	DESCRIPTION:

	CREATED BY: Rolf Berteig

	HISTORY: created January 20, 1996

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __MODSTACK__
#define __MODSTACK__


// These are the class IDs for object space derived objects and
// world space derived objects
extern CoreExport Class_ID derivObjClassID;
extern CoreExport Class_ID WSMDerivObjClassID;


class IDerivedObject : public Object {
	public:
		// Adds a modifier to the derived object.
		// before = 0				:Place modifier at the end of the pipeline (top of stack)
		// before = NumModifiers()	:Place modifier at the start of the pipeline (bottom of stack)
		virtual void AddModifier(Modifier *mod, ModContext *mc=NULL, int before=0)=0;				
		virtual void DeleteModifier(int index=0)=0;
		virtual int NumModifiers()=0;		

		// Searches down the pipeline for the base object (an object that is not a
		// derived object). May step into other derived objects. 
		// This function has been moved up to Object, with a default implementation
		// that just returns "this".  It is still implemented by derived objects and
		// WSM's to search down the pipeline.  This allows you to just call it on
		// a Nodes ObjectRef without checking for type.
//		virtual Object *FindBaseObject()=0;
		
		// Get and set the object that this derived object reference.
		// This is the next object down in the stack and may be the base object.
		virtual Object *GetObjRef()=0;
		virtual RefResult ReferenceObject(Object *pob)=0;

		// Access the ith modifier.
		virtual Modifier *GetModifier(int index)=0;

		// Replaces the ith modifier in the stack
		virtual void SetModifier(int index, Modifier *mod)=0;

		// Access the mod context for the ith modifier
		virtual ModContext* GetModContext(int index)=0;
	};

// Create a world space or object space derived object.
// If the given object pointer is non-NULL then the derived
// object will be set up to reference that object.
CoreExport IDerivedObject *CreateWSDerivedObject(Object *pob=NULL);
CoreExport IDerivedObject *CreateDerivedObject(Object *pob=NULL);


#endif //__MODSTACK__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\mstshape.h ===
/**********************************************************************
 *<
	FILE: mstshape.h

	DESCRIPTION:  Vestigal file; Left in due to multiple makefile dependencies

	CREATED BY: Tom Hudson

	HISTORY: created 12 May 1997

 *>	Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\mtl.h ===
/**********************************************************************
 *<
	FILE: mtl.h

	DESCRIPTION: Material and texture class definitions

	CREATED BY: Don Brittain

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#if !defined(_MTL_H_)


#define UVSOURCE_MESH  0      // use UVW coords from a standard map channel
#define UVSOURCE_XYZ   1      // compute UVW from object XYZ
#define UVSOURCE_MESH2 2      // use UVW2 (vertexCol) coords
#define UVSOURCE_WORLDXYZ 3   // use world XYZ as UVW
#ifdef DESIGN_VER
#define UVSOURCE_GEOXYZ 4
#endif

#define _MTL_H_

// main material class definition
class  Material {
public:
	DllExport Material();
	DllExport ~Material();
	
    Point3		Ka;
    Point3		Kd;
    Point3		Ks;
    float		shininess;
    float		shinStrength;
    float		opacity;
	float		selfIllum;
	int			dblSided;
	int			shadeLimit;
	int			useTex;
	int			faceMap;
	DWORD 		textHandle;  // texture handle
	int 		uvwSource;  
	int         mapChannel;
	Matrix3 	textTM;  // texture transform
	UBYTE 		tiling[3]; // u,v,w tiling:  GW_TEX_REPEAT, GW_TEX_MIRROR, or GW_TEX_NO_TILING
};

#endif // _MTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\namesel.h ===
/**********************************************************************
 *<
	FILE: namesel.h

	DESCRIPTION:  A named sel set class for sub-object named selections ets

	CREATED BY: Rolf Berteig

	HISTORY: 3/18/96

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __NAMEDSEL__
#define __NAMEDSEL__

class GenericNamedSelSetList {
	public:
		Tab<TSTR*> names;
		Tab<BitArray*> sets;
		Tab<DWORD> ids;

		CoreExport ~GenericNamedSelSetList();		
		CoreExport BitArray *GetSet(TSTR &name);
		CoreExport BitArray *GetSet(DWORD id);
		CoreExport BitArray *GetSetByIndex(int index);
		int Count() {return sets.Count();}
		CoreExport void AppendSet(BitArray &nset,DWORD id=0,TSTR &name=TSTR(""));
		CoreExport void InsertSet(int pos, BitArray &nset,DWORD id=0,TSTR &name=TSTR(""));
		CoreExport int InsertSet(BitArray &nset,DWORD id=0,TSTR &name=TSTR(""));
		CoreExport BOOL RemoveSet(TSTR &name);
		CoreExport BOOL RemoveSet(DWORD id);
		CoreExport IOResult Load(ILoad *iload);
		CoreExport IOResult Save(ISave *isave);
		CoreExport void SetSize(int size);
		CoreExport GenericNamedSelSetList& operator=(GenericNamedSelSetList& from);
		CoreExport void DeleteSetElements(BitArray &set,int m=1);
		CoreExport void DeleteSet(int i);
		CoreExport BOOL RenameSet(TSTR &oldName, TSTR &newName);
		CoreExport void Alphabetize ();	// Bubble Sort!
		BitArray &operator[](int i) {return *sets[i];}
	};

// TH: These methods are implemented in core\namesel.cpp.
// This class is used by the edit mesh and edit patch modifiers.

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\MouseProc.h ===
/**********************************************************************
 *<
    FILE: MouseProc.h

    DESCRIPTION:  Declares DataEntryMouseProc class

    CREATED BY: Scott Morrison

    HISTORY: created 7 December, 1998

 *> Copyright (c) 1998, All Rights Reserved.
 **********************************************************************/

class DataEntryMouseProc : public MouseCallBack {
public:
    CoreExport DataEntryMouseProc(Object* pObj, int cursor, HINSTANCE hInst);

    CoreExport DataEntryMouseProc();

    // Called when a point is selected
    CoreExport virtual BOOL OnPointSelected()      {return TRUE; }
    // Called on every mouse move event
    CoreExport virtual void OnMouseMove(Point3& p) {}
    // Tells the system when to allow drawing in mutiple viewports
    CoreExport virtual BOOL AllowAnyViewport()     { return TRUE; }
    // Called when backspace is pressed
    CoreExport virtual void RemoveLastPoint()      {}
    // Called when the creation is finished
    CoreExport virtual int OnMouseAbort()          { return CREATE_ABORT; }
    // Says whether the mouse proc should perform redraws
    // When used in a CreateMouseCallBack, this should return FALSE
    CoreExport virtual BOOL PerformRedraw()        { return TRUE; }

    // These methods need to be implemented to get the offset line drawn

    // Tells the object to draw offset lines
    CoreExport virtual void SetUseConstructionLine(BOOL useLine) = 0;
    // Sets the endpoints of the line (0 is start, 1 is end)
    CoreExport virtual void SetConstructionLine(int i, Point3 p) = 0;
    
    // The mouse callback function
    CoreExport int proc(HWND hwnd, int msg, int point, int flags, IPoint2 m );
    
    friend class DataEntryBackspaceUser;
    
    CoreExport void ClearCreationParams();
    
    CoreExport void SetParams(HINSTANCE hInst, Object* pObj, int cursor);
    
private:
    Point3 GetPoint(IPoint2 m, HWND hWnd, ViewExp* pVpt);
    void SetOffsetBase(IPoint2 m, HWND hWnd, ViewExp* pVpt);
    BOOL GetNodeTM(Matrix3& tm);
    IPoint2 ProjectPointToViewport(ViewExp *pVpt, Point3 fp);
    IPoint2 AngleSnapPoint(Point3 in3, ViewExp* pVpt);

    // The inverse of the transform on the node (or viewport transform,
    // for creation mouse procs)
    Matrix3        mTM;

    // Indicates when to ignore upclicks close to down clicks
    BOOL           mDoNotDouble;
    // The resource id of the cursor to use
    int            mCursor;
    // The instance of the dll using the mouse proc
    HINSTANCE      mInstance;

    // State for off-construction plane creation
    Point3         mSnappedPoint;
    Matrix3        mOriginalViewTM;

    int            mPreviousFlags;

protected:
    // The object using the mouse proc
    Object*        mpObject;

    // The number of points selected so far.
    int            mMouseClick;
    // The 3D coordinates of the points, in the local coordinate system
    Tab<Point3>    mPoints;
    // The 2D points the user selected in the viewport.
    Tab<IPoint2>   mClickPoints;
    // TRUE when in the mode where we lift off the construction plane
    BOOL           mLiftOffCP;
    // The last window we had an event in
    HWND           mHwnd;
    IPoint2        mLastMovePoint;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\nametab.h ===
/*******************************************************************
 *
 *    DESCRIPTION: Name table.
 *
 *    AUTHOR:	Dan Silva
 *
 *    HISTORY:    
 *
 *******************************************************************/

#ifndef __NAMETAB__H
#define __NAMETAB__H

#include <ioapi.h>

#define NT_INCLUDE			1
#define NT_AFFECT_ILLUM		 2
#define NT_AFFECT_SHADOWCAST  4

class NameTab: public Tab<TCHAR *> {
	ULONG flags;
	public:
		NameTab() { flags = NT_AFFECT_ILLUM|NT_AFFECT_SHADOWCAST; }
		UtilExport ~NameTab();
		UtilExport NameTab& operator=(const NameTab&	 n);
		void SetFlag(ULONG f, BOOL b=1){ if (b) flags|=f; else flags &= ~f; }
		BOOL TestFlag(ULONG f){ return (flags&f)?1:0; }
		UtilExport int AddName(TCHAR *n);
		UtilExport void SetName(int i, TCHAR *n);
		UtilExport void SetSize(int num);
		UtilExport void RemoveName(int i);
		UtilExport int FindName(TCHAR* n);
		UtilExport IOResult Load(ILoad *iload);
		UtilExport IOResult Save(ISave *isave);
	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\nsclip.h ===
/**********************************************************************
 *<
	FILE: nsclip.h

	DESCRIPTION: Clip board for named selection sets

	CREATED BY: Rolf Berteig

	HISTORY: 1/9/97

 *>	Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/

#ifndef __NSCLIP_H__
#define __NSCLIP_H__
#include "shpsels.h"

// The mesh select modifier and the editable tri object need
// to be able to share the clipboard for named selection sets,
// however they are in two separate DLLs. So I've provided a 
// place in CORE for the clipboard. Note that if 3rd parties
// run into a similar problem they could always create their
// own shared DLL, I just used CORE because it was handy.

class MeshNamedSelClip {
	public:
		TSTR name;
		Tab<BitArray*> sets;

		MeshNamedSelClip(TSTR &n) {name=n;}
		CoreExport ~MeshNamedSelClip();
	};

#define CLIP_VERT	1
#define CLIP_FACE	2
#define CLIP_EDGE	3

CoreExport void SetMeshNamedSelClip(MeshNamedSelClip *clip, int which);
CoreExport MeshNamedSelClip *GetMeshNamedSelClip(int which);

// Here is the equivalent for patches

class PatchNamedSelClip {
	public:
		TSTR name;
		Tab<BitArray*> sets;

		PatchNamedSelClip(TSTR &n) {name=n;}
		CoreExport ~PatchNamedSelClip();
	};

#define CLIP_P_VERT		1
#define CLIP_P_PATCH	2
#define CLIP_P_EDGE		3

CoreExport void SetPatchNamedSelClip(PatchNamedSelClip *clip, int which);
CoreExport PatchNamedSelClip *GetPatchNamedSelClip(int which);

// Here are the equivalents for shapes:

class ShapeNamedVertSelClip {
	public:
		TSTR name;
		Tab<ShapeVSel*> sets;

		ShapeNamedVertSelClip(TSTR &n) {name=n;}
		CoreExport ~ShapeNamedVertSelClip();
	};

CoreExport void SetShapeNamedVertSelClip(ShapeNamedVertSelClip *clip);
CoreExport ShapeNamedVertSelClip *GetShapeNamedVertSelClip();

class ShapeNamedSegSelClip {
	public:
		TSTR name;
		Tab<ShapeSSel*> sets;

		ShapeNamedSegSelClip(TSTR &n) {name=n;}
		CoreExport ~ShapeNamedSegSelClip();
	};

CoreExport void SetShapeNamedSegSelClip(ShapeNamedSegSelClip *clip);
CoreExport ShapeNamedSegSelClip *GetShapeNamedSegSelClip();

class ShapeNamedPolySelClip {
	public:
		TSTR name;
		Tab<ShapePSel*> sets;

		ShapeNamedPolySelClip(TSTR &n) {name=n;}
		CoreExport ~ShapeNamedPolySelClip();
	};

CoreExport void SetShapeNamedPolySelClip(ShapeNamedPolySelClip *clip);
CoreExport ShapeNamedPolySelClip *GetShapeNamedPolySelClip();

#endif //__NSCLIP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\object.h ===
/**********************************************************************
 *<
	FILE: object.h
				  
	DESCRIPTION:  Defines Object Classes

	CREATED BY: Dan Silva

	HISTORY: created 9 September 1994

 *>     Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef _OBJECT_

#define _OBJECT_

#include "inode.h"
#include "maxapi.h"
#include "plugapi.h"
#include "snap.h"
#include "genshape.h"
#include <hitdata.h>
#include "imtl.h"

typedef short MtlIndex; 
typedef short TextMapIndex;

CoreExport void setHitType(int t);
CoreExport int  getHitType(void);
CoreExport BOOL doingXORDraw(void);

// Hit test types:
#define HITTYPE_POINT   1
#define HITTYPE_BOX             2
#define HITTYPE_CIRCLE  3
#define HITTYPE_SOLID   4
#define HITTYPE_FENCE   5

// Flags for hit test.
#define HIT_SELONLY				(1<<0)
#define HIT_UNSELONLY			(1<<2)
#define HIT_ABORTONHIT			(1<<3)
#define HIT_SELSOLID			(1<<4)
#define HIT_ANYSOLID			(1<<5)
#define HIT_TRANSFORMGIZMO		(1<<6)	// CCJ - 06/29/98 - Hittest transform gizmo
#define HIT_SWITCH_GIZMO		(1<<7)	// CCJ - 06/29/98 - Switch axis when hit

// These are filters for hit testing. They also
// are combined into the flags parameter.
#define HITFLTR_ALL                     (1<<10)
#define HITFLTR_OBJECTS         (1<<11)
#define HITFLTR_CAMERAS         (1<<12)
#define HITFLTR_LIGHTS          (1<<13)
#define HITFLTR_HELPERS         (1<<14)
#define HITFLTR_WSMOBJECTS      (1<<15)
#define HITFLTR_SPLINES         (1<<16)

// Starting at this bit through the 31st bit can be used
// by plug-ins for sub-object hit testing
#define HITFLAG_STARTUSERBIT    24


#define VALID(x) (x)

class Modifier;
class Object;
class NameTab; 
class Texmap;
  
typedef Object* ObjectHandle;

MakeTab(TextMapIndex)
typedef TextMapIndexTab TextTab;

//---------------------------------------------------------------  
class IdentityTM: public Matrix3 {
	public:
		IdentityTM() { IdentityMatrix(); }              
	};

CoreExport extern IdentityTM idTM;


//-------------------------------------------------------------
// This is passed in to GetRenderMesh to allow objects to do
// view dependent rendering.
//

// flag defines for View::flags
#define RENDER_MESH_DISPLACEMENT_MAP  1   // enable displacement mapping

class View {
	public: 
		float screenW, screenH;  // screen dimensions
		Matrix3 worldToView;
		virtual Point2 ViewToScreen(Point3 p)=0;
		// the following added for GAP
		int projType;
		float fov, pixelSize;
		Matrix3 affineTM;         // worldToCam
		DWORD flags;

		// Call during render to check if user has cancelled render.  
		// Returns TRUE iff user has cancelled.
		virtual BOOL CheckForRenderAbort() { return FALSE; }

		// Generic expansion function
		virtual int Execute(int cmd, ULONG arg1=0, ULONG arg2=0, ULONG arg3=0) { return 0; } 

		View() { projType = -1; flags = RENDER_MESH_DISPLACEMENT_MAP; } // projType not set, this is to deal with older renderers.
	};
//-------------------------------------------------------------

// Class ID of general deformable object.
extern CoreExport Class_ID defObjectClassID;

//-------------------------------------------------------------

// Class ID of general texture-mappable object.
extern CoreExport Class_ID mapObjectClassID;

//-------------------------------------------------------------
// ChannelMask: bits specific channels in the OSM dataflow. 

typedef unsigned long ChannelMask;

// an array of channel masks for all the channels *within*
// the Object.
CoreExport extern ChannelMask chMask[];

class Object;

//-- ObjectState ------------------------------------------------------------
// This is what is passed down the pipeline, and ultimately used by the Node
//  to Display, Hittest, render:

// flags bits

class ObjectState {
		ulong flags;
		Matrix3 *tm;
		Interval tmvi;   
		int mtl;
		Interval mtlvi;                         
		void AllocTM();
	public: 
		Object *obj;  // object: provides interval with obj->ObjectValidity()
		CoreExport ObjectState();
		CoreExport ObjectState(Object *ob);
		CoreExport ObjectState(const ObjectState& os); 
		CoreExport ~ObjectState();
		void OSSetFlag(ulong f) { flags |= f; }
		void OSClearFlag(ulong f) { flags &= ~f; }
		ulong OSTestFlag(ulong f) const { return flags&f; }
		CoreExport void OSCopyFlag(ulong f, const ObjectState& fromos);
		CoreExport ObjectState& operator=(const ObjectState& os);
		Interval tmValid() const { return tmvi; }
		Interval mtlValid() const  { return mtlvi; }
		CoreExport Interval Validity(TimeValue t) const;
		CoreExport int TMIsIdentity() const;
		CoreExport void SetTM(Matrix3* mat, Interval iv);
		CoreExport Matrix3* GetTM() const;
		CoreExport void SetIdentityTM();
		CoreExport void ApplyTM(Matrix3* mat, Interval iv);
		CoreExport void CopyTM(const ObjectState &fromos);
		CoreExport void CopyMtl(const ObjectState &fromos);
		CoreExport void Invalidate(ChannelMask channels, BOOL checkLock=FALSE);
		CoreExport void DeleteObj(BOOL checkLock=FALSE);
	};

class INodeTab : public Tab<INode*> {
	public:         
		void DisposeTemporary() {
			for (int i=0; i<Count(); i++) (*this)[i]->DisposeTemporary();
			}
	};

//---------------------------------------------------------------  
// A reference to a pointer to an instance of this class is passed in
// to ModifyObject(). The value of the pointer starts out as NULL, but
// the modifier can set it to point at an actual instance of a derived
// class. When the mod app is deleted, if the pointer is not NULL, the
// LocalModData will be deleted - the virtual destructor alows this to work.

class LocalModData {
	public:
		virtual ~LocalModData() {}
		virtual LocalModData *Clone()=0;
		virtual void* GetInterface(ULONG id) { return NULL; }  // to access sub-obj selection interfaces, JBW 2/5/99
	}; 

class ModContext {
	public:
	Matrix3                 *tm;
	Box3                    *box;
	LocalModData    *localData;
	
	CoreExport ~ModContext();
	CoreExport ModContext();
	CoreExport ModContext(const ModContext& mc);
	CoreExport ModContext(Matrix3 *tm, Box3 *box, LocalModData *localData);
	};

class ModContextList : public Tab<ModContext*> {};


class HitRecord;


// Values passed to NewSetByOperator()
#define NEWSET_MERGE			1
#define NEWSET_INTERSECTION		2
#define NEWSET_SUBTRACT			3


// Flags passed to Display()
#define USE_DAMAGE_RECT                 (1<<0)  
#define DISP_SHOWSUBOBJECT              (1<<1)

// The base class of Geometric objects, Lights, Cameras, Modifiers, 
//  Deformation objects--
// --anything with a 3D representation in the UI scene. 

class IParamArray;

class BaseObject: public ReferenceTarget {
	public:
		CoreExport void* GetInterface(ULONG id);

		virtual int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt){return 0;};
		virtual void SetExtendedDisplay(int flags)      {}      // for setting mode-dependent display attributes
		virtual int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags) { return 0; };   // quick render in viewport, using current TM.         
		virtual void Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt) {}       // Check for snap, updating SnapInfo
		virtual void GetWorldBoundBox(TimeValue t, INode * inode, ViewExp* vp, Box3& box ){};  // Box in world coords.
		virtual void GetLocalBoundBox(TimeValue t, INode* inode, ViewExp* vp,  Box3& box ){};  // box in objects local coords
		virtual CreateMouseCallBack* GetCreateMouseCallBack()=0;
		
		// This is the name that will appear in the history browser.
		virtual TCHAR *GetObjectName() { return _T("Object"); }

		// Sends the REFMSG_IS_OK_TO_CHANGE_TOPOLOGY off to see if any
		// modifiers or objects down the pipeline depend on topology.
		// modName will be set to the dependent modifier's name if there is one.
		CoreExport virtual BOOL OKToChangeTopology(TSTR &modName);

		// Return true if this object(or modifier) is cabable of changing 
		//topology when it's parameters are being edited.
		virtual BOOL ChangeTopology() {return TRUE;}

		virtual void ForceNotify(Interval& i)
			{NotifyDependents(i, PART_ALL,REFMSG_CHANGE);}
				
		// If an object or modifier wishes it can make its parameter block
		// available for other plug-ins to access. The system itself doesn't
		// actually call this method -- this method is optional.
		virtual IParamArray *GetParamBlock() {return NULL;}
		
		// If a plug-in make its parameter block available then it will
		// need to provide #defines for indices into the parameter block.
		// These defines should probably not be directly used with the
		// parameter block but instead converted by this function that the
		// plug-in implements. This way if a parameter moves around in a 
		// future version of the plug-in the #define can be remapped.
		// -1 indicates an invalid parameter id
		virtual int GetParamBlockIndex(int id) {return -1;}


		///////////////////////////////////////////////////////////////////////////
		///////////////////////////////////////////////////////////////////////////
		//
		// The following methods are for sub-object selection. If the
		// derived class is NOT a modifier, the modContext pointer passed
		// to some of the methods will be NULL.
		//

		// Affine transform methods
		virtual void Move( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin=FALSE ){}
		virtual void Rotate( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Quat& val, BOOL localOrigin=FALSE ){}
		virtual void Scale( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin=FALSE ){}

		// The following is called before the first Move(), Rotate() or Scale() call and
		// before a hold is in effect
		virtual void TransformStart(TimeValue t) {}

		// The following is called before the first Move(), Rotate() or Scale() call and
		// after a hold is in effect
		virtual void TransformHoldingStart(TimeValue t) {}

		// The following is called after the user has completed the Move, Rotate or Scale operation and
		// before the undo object has been accepted.
		virtual void TransformHoldingFinish(TimeValue t) {}             

		// The following is called after the user has completed the Move, Rotate or Scale operation and
		// after the undo object has been accepted.
		virtual void TransformFinish(TimeValue t) {}            

		// The following is called when the transform operation is cancelled by a right-click and
		// the undo has been cancelled.
		virtual void TransformCancel(TimeValue t) {}            

		virtual int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc) { return 0; }
		virtual int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags, ModContext* mc) { return 0; };   // quick render in viewport, using current TM.         
		virtual void GetWorldBoundBox(TimeValue t,INode* inode, ViewExp *vpt, Box3& box, ModContext *mc) {}
		
		virtual void CloneSelSubComponents(TimeValue t) {}
		virtual void AcceptCloneSelSubComponents(TimeValue t) {}

		// Changes the selection state of the component identified by the
		// hit record.
		virtual void SelectSubComponent(
			HitRecord *hitRec, BOOL selected, BOOL all, BOOL invert=FALSE) {}
		
		// Clears the selection for the given sub-object type.
		virtual void ClearSelection(int selLevel) {}
		virtual void SelectAll(int selLevel) {}
		virtual void InvertSelection(int selLevel) {}

		// Returns the index of the subobject entity identified by hitRec.
		virtual int SubObjectIndex(HitRecord *hitRec) {return 0;}               
		
		// This notifies an object being edited that the current sub object
		// selection level has changed. level==0 indicates object level selection.
		// level==1 or greater refer to the types registered by the object in the
		// order they appeared in the list when registered.
		// If level >= 1, the object should specify sub-object xform modes in the
		// modes structure (defined in cmdmode.h).
		virtual void ActivateSubobjSel(int level, XFormModes& modes ) {}

		// An object that supports sub-object selection can choose to
		// support named sub object selection sets. Methods in the the
		// interface passed to objects allow them to add items to the
		// sub-object selection set drop down.
		// The following methods are called when the user picks items
		// from the list.
		virtual BOOL SupportsNamedSubSels() {return FALSE;}
		virtual void ActivateSubSelSet(TSTR &setName) {}
		virtual void NewSetFromCurSel(TSTR &setName) {}
		virtual void RemoveSubSelSet(TSTR &setName) {}

		// New for version 2. To support the new edit named selections dialog,
		// plug-ins must implemented the following methods:
		virtual void SetupNamedSelDropDown() {}
		virtual int NumNamedSelSets() {return 0;}
		virtual TSTR GetNamedSelSetName(int i) {return _T("");}
		virtual void SetNamedSelSetName(int i,TSTR &newName) {}
		virtual void NewSetByOperator(TSTR &newName,Tab<int> &sets,int op) {}


		// New way of dealing with sub object coordinate systems.
		// Plug-in enumerates its centers or TMs and calls the callback once for each.
		// NOTE:cb->Center() should be called the same number of times and in the
		// same order as cb->TM()
		// NOTE: The SubObjAxisCallback class is defined in animatable and used in both the
		// controller version and this version of GetSubObjectCenters() and GetSubObjectTMs()
		virtual void GetSubObjectCenters(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc) {}
		virtual void GetSubObjectTMs(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc) {}                          


		// Find out if the Object or Modifer is is generating UVW's
		// on map channel 1.
		virtual BOOL HasUVW () { return 0; }
		// or on any map channel:
		virtual BOOL HasUVW (int mapChannel) { return (mapChannel==1) ? HasUVW() : FALSE; }

		// Change the state of the object's Generate UVW boolean.
		// IFF the state changes, the object should send a REFMSG_CHANGED down the pipe.
		virtual void SetGenUVW(BOOL sw) {  }	// applies to mapChannel 1
		virtual void SetGenUVW (int mapChannel, BOOL sw) { if (mapChannel==1) SetGenUVW (sw); }

		// Notify the BaseObject that the end result display has been switched.
		// (Sometimes this is needed for display changes.)
		virtual void ShowEndResultChanged (BOOL showEndResult) { }

		//
		//
		///////////////////////////////////////////////////////////////////////////
		///////////////////////////////////////////////////////////////////////////
		
	private:
	};

//-------------------------------------------------------------
// Callback object used by Modifiers to deform "Deformable" objects
class Deformer {
	public:
		virtual Point3 Map(int i, Point3 p) = 0; 
		void ApplyToTM(Matrix3* tm);
	};

// Mapping types passed to ApplyUVWMap()
#define MAP_PLANAR              0
#define MAP_CYLINDRICAL 1
#define MAP_SPHERICAL   2
#define MAP_BALL                3
#define MAP_BOX                 4

/*------------------------------------------------------------------- 
   Object is the class of all objects that can be pointed to by a node:
   It INcludes Lights,Cameras, Geometric objects, derived objects,
   and deformation Objects (e.g. FFD lattices)
   It EXcludes Modifiers
---------------------------------------------------------------------*/
#define OBJECT_LOCKED 0x8000000

class ShapeObject;

class Object: public BaseObject {
		ulong locked;   // lock flags for each channel + object locked flag
		Interval noEvalInterval;  // used in ReducingCaches
	public:
		Object() { locked = OBJECT_LOCKED; noEvalInterval = FOREVER; }

		virtual int IsRenderable()=0;  // is this a renderable object?
		virtual void InitNodeName(TSTR& s)=0;
		virtual int UsesWireColor() { return TRUE; }    // TRUE if the object color is used for display
		virtual int DoOwnSelectHilite() { return 0; }
		// validity interval of Object as a whole at current time
		virtual Interval ObjectValidity(TimeValue t) { return FOREVER; }

		// This used to be in GeomObject but I realized that other types of objects may
		// want this (mainly to participate in normal align) such as grid helper objects.
		virtual int IntersectRay(TimeValue t, Ray& r, float& at, Point3& norm) {return FALSE;}

		// Objects that don't support IntersectRay() (like helpers) can implement this
		// method to provide a default vector for normal align.
		virtual BOOL NormalAlignVector(TimeValue t,Point3 &pt, Point3 &norm) {return FALSE;}

		// locking of object as whole. defaults to NOT modifiable.
		void LockObject() { locked |= OBJECT_LOCKED; }
		void UnlockObject() { locked &= ~OBJECT_LOCKED; }
		int  IsObjectLocked() { return locked&OBJECT_LOCKED; }

		// the validity intervals are now in the object.
		virtual ObjectState Eval(TimeValue t)=0;

		// Access the lock flags for th specified channels
		void LockChannels(ChannelMask channels) { locked |= channels; } 
		void UnlockChannels(ChannelMask channels) { locked &= ~channels; }
		ChannelMask     GetChannelLocks() { return locked; }    
		void SetChannelLocks(ChannelMask channels) { locked = channels; }       
		ChannelMask GetChannelLocks(ChannelMask m) { return locked; }
		
		// Can this object have channels cached?
		// Particle objects flow up the pipline without making shallow copies of themselves and therefore cannot be cached
		virtual BOOL CanCacheObject() {return TRUE;}

		// This is called by a node when the node's world space state has
		// become invalid. Normally an object does not (and should not) be
		// concerned with this, but in certain cases (particle systems) an
		// object is effectively a world space object an needs to be notified.
		virtual void WSStateInvalidate() {}

		// Identifies the object as a world space object. World space
		// objects (particles for example) can not be instanced because
		// they exist in world space not object space.
		virtual BOOL IsWorldSpaceObject() {return FALSE;}
		
		// This is only valid for world-space objects (they must return TRUE for
		// the IsWorldSpaceObject method).  It locates the node which contains the
		// object.  Non-world-space objects will return NULL for this!
		CoreExport INode *GetWorldSpaceObjectNode();

		// Is the derived class derived from ParticleObject?
		virtual BOOL IsParticleSystem() {return FALSE;}

		// copy specified flags from obj
		CoreExport void CopyChannelLocks(Object *obj, ChannelMask needChannels);

		// access the current validity interval for the nth channel
		CoreExport virtual Interval ChannelValidity(TimeValue t, int nchan);
		virtual void SetChannelValidity(int nchan, Interval v) { }
		CoreExport void UpdateValidity(int nchan, Interval v);  // AND in interval v to channel validity

		// invalidate the specified channels
		virtual void InvalidateChannels(ChannelMask channels) { }

		// topology has been changed by a modifier -- update mesh strip/edge lists
		virtual void TopologyChanged() { }

		//
		// does this object implement the generic Deformable Object procs?
		//
		virtual int IsDeformable() { return 0; } 

		// DeformableObject procs: only need be implemented  
		// IsDeformable() returns TRUE.
		virtual int NumPoints(){ return 0;}
		virtual Point3 GetPoint(int i) { return Point3(0,0,0); }
		virtual void SetPoint(int i, const Point3& p) {}             
			
		// Completes the deformable object access with two methods to
		// query point selection. 
		// IsPointSelected returns a TRUE/FALSE value
		// PointSelection returns the weighted point selection, if supported.
		// Harry D, 11/98
		virtual BOOL IsPointSelected (int i) { return FALSE; }
		virtual float PointSelection (int i) {
			return IsPointSelected(i) ? 1.0f : 0.0f;
		}

		// These allow the NURBS Relational weights to be modified
		virtual BOOL HasWeights() { return FALSE; }
		virtual double GetWeight(int i) { return 1.0; }
		virtual void SetWeight(int i, const double w) {}

        // Get the count of faces and vertices for the polyginal mesh
        // of an object.  If it return FALSE, then this function
        // isn't supported.  Plug-ins should use GetPolygonCount(Object*, int&, int&)
        // to count the polys in an arbitrary object
        virtual BOOL PolygonCount(TimeValue t, int& numFaces, int& numVerts) { return FALSE; }

		// informs the object that its points have been deformed,
		// so it can invalidate its cache.
		virtual void PointsWereChanged(){}

		// deform the object with a deformer.
		CoreExport virtual void Deform(Deformer *defProc, int useSel=0);

		// box in objects local coords or optional space defined by tm
		// If useSel is true, the bounding box of selected sub-elements will be taken.
		CoreExport virtual void GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm=NULL, BOOL useSel=FALSE );

		//
		// does this object implement the generic Mappable Object procs?
		//
		virtual int IsMappable() { return 0; }
		virtual int NumMapChannels () { return IsMappable(); }	// returns number possible.
		virtual int NumMapsUsed () { return NumMapChannels(); }	// at least 1+(highest channel in use).

		// This does the texture map application -- Only need to implement if
		// IsMappable returns TRUE
		virtual void ApplyUVWMap(int type,
			float utile, float vtile, float wtile,
			int uflip, int vflip, int wflip, int cap,
			const Matrix3 &tm,int channel=1) {}

		// Objects need to be able convert themselves 
		// to TriObjects. Most modifiers will ask for
		// Deformable Objects, and triobjects will suffice.

		CoreExport virtual int CanConvertToType(Class_ID obtype);
		CoreExport virtual Object* ConvertToType(TimeValue t, Class_ID obtype);
		
		// Indicate the types this object can collapse to
		virtual Class_ID PreferredCollapseType() {return Class_ID(0,0);}
		CoreExport virtual void GetCollapseTypes(Tab<Class_ID> &clist,Tab<TSTR*> &nlist);

		// return the current sub-selection state
		virtual DWORD GetSubselState() {return 0;} 
		virtual void SetSubSelState(DWORD s) {}

		// If the requested channels are locked, replace their data
		// with a copy/ and unlock them, otherwise leave them alone
		CoreExport void ReadyChannelsForMod(ChannelMask channels);

		// Virtual methods to be implemented by plug-in object:-----
		
		// Makes a copy of its "shell" and shallow copies only the
		// specified channels.  Also copies the validity intervals of
		// the copied channels, and sets Invalidates the other intervals.
		virtual Object *MakeShallowCopy(ChannelMask channels) { return NULL; }

		// Shallow-copies the specified channels from the fromOb to this.
		// Also copies the validity intervals. 
		virtual void ShallowCopy(Object* fromOb, ChannelMask channels) {}

		// This replaces locked channels with newly allocated copies.
		// It will only be called if the channel is locked.
		virtual void NewAndCopyChannels(ChannelMask channels) {}                

		// Free the specified channels
		virtual void FreeChannels(ChannelMask channels) {}                                      
	  
		Interval GetNoEvalInterval() { return noEvalInterval; }
		void SetNoEvalInterval(Interval iv) {noEvalInterval = iv; }

		// Give the object chance to reduce its caches, 
		// depending on the noEvalInterval.
		CoreExport virtual void ReduceCaches(TimeValue t);

		// Is this object a construction object:
		virtual int IsConstObject() { return 0; }               

		// Retreives sub-object branches from an object that supports branching.
		// Certain objects combine a series of input objects (pipelines) into
		// a single object. These objects act as a multiplexor allowing the
		// user to decide which branch(s) they want to see the history for.
		//
		// It is up to the object how they want to let the user choose. The object
		// may use sub object selection to allow the user to pick a set of
		// objects for which the common history will be displayed.
		// 
		// When the history changes for any reason, the object should send
		// a notification (REFMSG_BRANCHED_HISTORY_CHANGED) via NotifyDependents.
		//
		virtual int NumPipeBranches() {return 0;}
		virtual Object *GetPipeBranch(int i) {return NULL;}
		
		// When an object has sub-object branches, it is likely that the
		// sub-objects are transformed relative to the object. This method
		// gives the object a chance to modify the node's transformation so
		// that operations (like edit modifiers) will work correctly when 
		// editing the history of the sub object branch.
		virtual INode *GetBranchINode(TimeValue t,INode *node,int i) {return node;}

		// Shape viewports can reference shapes contained within objects, so we
		// need to be able to access shapes within an object.  The following methods
		// provide this access
		virtual int NumberOfContainedShapes() { return -1; }    // NOT a container!
		virtual ShapeObject *GetContainedShape(TimeValue t, int index) { return NULL; }
		virtual void GetContainedShapeMatrix(TimeValue t, int index, Matrix3 &mat) {}
		virtual BitArray ContainedShapeSelectionArray() { return BitArray(); }

        // Return TRUE for ShapeObject class or GeomObjects that are Shapes too
        virtual BOOL IsShapeObject() { return FALSE; }
    
		// For debugging only. TriObject inplements this method by making sure
		// its face's vert indices are all valid.
		virtual BOOL CheckObjectIntegrity() {return TRUE;}              

		// Find out if the Object is generating UVW's
		virtual BOOL HasUVW() { return 0; }
		// or on any map channel:
		virtual BOOL HasUVW (int mapChannel) { return (mapChannel==1) ? HasUVW() : FALSE; }

		// This is overridden by DerivedObjects to search up the pipe for the base object
		virtual Object *FindBaseObject() { return this;	}

		// Access a parametric position on the surface of the object
		virtual BOOL IsParamSurface() {return FALSE;}
		virtual int NumSurfaces(TimeValue t) {return 1;}
		// Single-surface version (surface 0)
		virtual Point3 GetSurfacePoint(TimeValue t, float u, float v,Interval &iv) {return Point3(0,0,0);}
		// Multiple-surface version (Implement if you override NumSurfaces)
		virtual Point3 GetSurfacePoint(TimeValue t, int surface, float u, float v,Interval &iv) {return Point3(0,0,0);}
		// Get information on whether a surface is closed (default is closed both ways)
		virtual void SurfaceClosed(TimeValue t, int surface, BOOL &uClosed, BOOL &vClosed) {uClosed = vClosed = TRUE;}

		// Allow an object to return extended Properties fields
		// Return TRUE if you take advantage of these, and fill in all strings
		virtual BOOL GetExtendedProperties(TimeValue t, TSTR &prop1Label, TSTR &prop1Data, TSTR &prop2Label, TSTR &prop2Data) {return FALSE;}

		// Allow the object to enlarge its viewport rectangle, if it wants to.
		virtual void MaybeEnlargeViewportRect(GraphicsWindow *gw, Rect &rect) {}

		// Animatable Overides...
		CoreExport SvGraphNodeReference SvTraverseAnimGraph(IGraphObjectManager *gom, Animatable *owner, int id, DWORD flags);
		CoreExport bool SvHandleDoubleClick(IGraphObjectManager *gom, IGraphNode *gNode);
		CoreExport TSTR SvGetName(IGraphObjectManager *gom, IGraphNode *gNode, bool isBeingEdited);
		CoreExport COLORREF SvHighlightColor(IGraphObjectManager *gom, IGraphNode *gNode);
		CoreExport bool SvIsSelected(IGraphObjectManager *gom, IGraphNode *gNode);
		CoreExport MultiSelectCallback* SvGetMultiSelectCallback(IGraphObjectManager *gom, IGraphNode *gNode);
		CoreExport bool SvCanSelect(IGraphObjectManager *gom, IGraphNode *gNode);
	};


// This function should be used to count polygons in an object.
// It uses Object::PolygonCount() if it is supported, and converts to
// a TriObject and counts faces and vertices otherwise.
CoreExport void GetPolygonCount(TimeValue t, Object* pObj, int& numFaces, int& numVerts);

/*------------------------------------------------------------------- 
  CameraObject:  
---------------------------------------------------------------------*/

#define CAM_HITHER_CLIP         1
#define CAM_YON_CLIP            2

#define ENV_NEAR_RANGE          0
#define ENV_FAR_RANGE           1

struct CameraState {
	BOOL isOrtho;	// true if cam is ortho, false for persp
	float fov;      // field-of-view for persp cams, width for ortho cams
	float tdist;    // target distance for free cameras
	BOOL horzLine;  // horizon line display state
	int manualClip;
	float hither;
	float yon;
	float nearRange;
	float farRange;
	};

class  CameraObject: public Object {
	public:
	SClass_ID SuperClassID() { return CAMERA_CLASS_ID; }
	int IsRenderable() { return(0);}
	virtual void InitNodeName(TSTR& s) { s = _T("Camera"); }
	virtual int UsesWireColor() { return FALSE; }   // TRUE if the object color is used for display
	
	// Method specific to cameras:
	virtual RefResult EvalCameraState(TimeValue time, Interval& valid, CameraState* cs)=0;
	virtual void SetOrtho(BOOL b)=0;
	virtual BOOL IsOrtho()=0;
	virtual void SetFOV(TimeValue time, float f)=0; 
	virtual float GetFOV(TimeValue t, Interval& valid = Interval(0,0))=0;
	virtual void SetTDist(TimeValue time, float f)=0; 
	virtual float GetTDist(TimeValue t, Interval& valid = Interval(0,0))=0;
	virtual int GetManualClip()=0;
	virtual void SetManualClip(int onOff)=0;
	virtual float GetClipDist(TimeValue t, int which, Interval &valid=Interval(0,0))=0;
	virtual void SetClipDist(TimeValue t, int which, float val)=0;
	virtual void SetEnvRange(TimeValue time, int which, float f)=0; 
	virtual float GetEnvRange(TimeValue t, int which, Interval& valid = Interval(0,0))=0;
	virtual void SetEnvDisplay(BOOL b, int notify=TRUE)=0;
	virtual BOOL GetEnvDisplay(void)=0;
	virtual void RenderApertureChanged(TimeValue t)=0;
	virtual void UpdateTargDistance(TimeValue t, INode* inode) {}
	};


/*------------------------------------------------------------------- 
  LightObject:   
---------------------------------------------------------------------*/

#define LIGHT_ATTEN_START       0
#define LIGHT_ATTEN_END         1

struct LightState {
    LightType type;
	Matrix3 tm;
	Color color;
	float 	intens;  // multiplier value
	float 	hotsize; 
	float 	fallsize;
	int		useNearAtten;
	float	nearAttenStart;
	float	nearAttenEnd;
	int   	useAtten;
	float 	attenStart;
	float 	attenEnd;
	int   	shape;
	float 	aspect;
	BOOL   	overshoot;
	BOOL   	shadow;
    BOOL 	on;      // light is on
	BOOL	affectDiffuse;
	BOOL	affectSpecular;
	BOOL 	ambientOnly;  // affect only ambient component
	DWORD   extra;
	};

class LightDesc;
class RendContext;


// This is a callback class that can be given to a ObjLightDesc
// to have a ray traced through the light volume.
class LightRayTraversal {
	public:
		// This is called for every step (return FALSE to halt the integration).
		// t0 and t1 define the segment in terms of the given ray.
		// illum is the light intensity over the entire segment. It can be
		// assumed that the light intensty is constant for the segment.
		virtual BOOL Step(float t0, float t1, Color illum, float distAtten)=0;
	};

// Flags passed to TraverseVolume
#define TRAVERSE_LOWFILTSHADOWS (1<<0)
#define TRAVERSE_HIFILTSHADOWS  (1<<1)
#define TRAVERSE_USESAMPLESIZE	(1<<2)

// A light must be able to create one of these to give to the renderer.
// The Illuminate() method (inherited from LightDesc) is called by the renderer
// to illuminate a surface point.
class ObjLightDesc : public LightDesc {
	public:         
		// This data will be set up by the default implementation of Update()
		LightState ls;
		INode *inode;
		BOOL uniformScale; // for optimizing
		Point3 lightPos;
		Matrix3 lightToWorld;
		Matrix3 worldToLight;
		Matrix3 lightToCam;   // updated in UpdateViewDepParams
		Matrix3 camToLight;   // updated in UpdateViewDepParams
		int renderNumber;   // set by the renderer. Used in RenderInstance::CastsShadowsFrom()

		CoreExport ObjLightDesc(INode *n);
		CoreExport virtual ~ObjLightDesc();

		virtual NameTab* GetExclList() { return NULL; }  

		// update light state that depends on position of objects&lights in world.
		CoreExport virtual int Update(TimeValue t, const RendContext &rc, RenderGlobalContext *rgc, BOOL shadows, BOOL shadowGeomChanged);

		// update light state that depends on global light level.
		CoreExport virtual void UpdateGlobalLightLevel(Color globLightLevel) {}

		// update light state that depends on view matrix.
		CoreExport virtual int UpdateViewDepParams(const Matrix3& worldToCam);

		// default implementation 
		CoreExport virtual Point3 LightPosition() { return lightPos; }
		
		// This function traverses a ray through the light volume.
		// 'ray' defines the parameter line that will be traversed.
		// 'minStep' is the smallest step size that caller requires, Note that
		// the callback may be called in smaller steps if they light needs to
		// take smaller steps to avoid under sampling the volume.
		// 'tStop' is the point at which the traversal will stop (ray.p+tStop*ray.dir).
		// Note that the traversal can terminate earlier if the callback returns FALSE.
		// 'proc' is the callback object.
		//
		// attenStart/End specify a percent of the light attenuation distances
		// that should be used for lighting durring the traversal.
		//
		// The shade context passed in should only be used for state (like are
		// shadows globaly disabled). The position, normal, etc. serve no purpose.
		virtual void TraverseVolume(
			ShadeContext& sc,       
			const Ray &ray, int samples, float tStop,
			float attenStart, float attenEnd,
			DWORD flags,
			LightRayTraversal *proc) {}
	};

// Values returned from GetShadowMethod()
#define LIGHTSHADOW_NONE                0
#define LIGHTSHADOW_MAPPED              1
#define LIGHTSHADOW_RAYTRACED   2


class  LightObject: public Object {
	public:
	SClass_ID SuperClassID() { return LIGHT_CLASS_ID; }
	int IsRenderable() { return(0);}
	virtual void InitNodeName(TSTR& s) { s = _T("Light"); }

	// Methods specific to Lights:
	virtual RefResult EvalLightState(TimeValue time, Interval& valid, LightState *ls)=0;
	virtual ObjLightDesc *CreateLightDesc(INode *n) {return NULL;}
	virtual void SetUseLight(int onOff)=0;
	virtual BOOL GetUseLight(void)=0;
	virtual void SetHotspot(TimeValue time, float f)=0; 
	virtual float GetHotspot(TimeValue t, Interval& valid = Interval(0,0))=0;
	virtual void SetFallsize(TimeValue time, float f)=0; 
	virtual float GetFallsize(TimeValue t, Interval& valid = Interval(0,0))=0;
	virtual void SetAtten(TimeValue time, int which, float f)=0; 
	virtual float GetAtten(TimeValue t, int which, Interval& valid = Interval(0,0))=0;
	virtual void SetTDist(TimeValue time, float f)=0; 
	virtual float GetTDist(TimeValue t, Interval& valid = Interval(0,0))=0;
	virtual void SetConeDisplay(int s, int notify=TRUE)=0;
	virtual BOOL GetConeDisplay(void)=0;
	virtual int GetShadowMethod() {return LIGHTSHADOW_NONE;}
	virtual void SetRGBColor(TimeValue t, Point3& rgb) {}
	virtual Point3 GetRGBColor(TimeValue t, Interval &valid = Interval(0,0)) {return Point3(0,0,0);}        
	virtual void SetIntensity(TimeValue time, float f) {}
	virtual float GetIntensity(TimeValue t, Interval& valid = Interval(0,0)) {return 0.0f;}
	virtual void SetAspect(TimeValue t, float f) {}
	virtual float GetAspect(TimeValue t, Interval& valid = Interval(0,0)) {return 0.0f;}    
	virtual void SetUseAtten(int s) {}
	virtual BOOL GetUseAtten(void) {return FALSE;}
	virtual void SetAttenDisplay(int s) {}
	virtual BOOL GetAttenDisplay(void) {return FALSE;}      
	virtual void Enable(int enab) {}
	virtual void SetMapBias(TimeValue t, float f) {}
	virtual float GetMapBias(TimeValue t, Interval& valid = Interval(0,0)) {return 0.0f;}
	virtual void SetMapRange(TimeValue t, float f) {}
	virtual float GetMapRange(TimeValue t, Interval& valid = Interval(0,0)) {return 0.0f;}
	virtual void SetMapSize(TimeValue t, int f) {}
	virtual int GetMapSize(TimeValue t, Interval& valid = Interval(0,0)) {return 0;}
	virtual void SetRayBias(TimeValue t, float f) {}
	virtual float GetRayBias(TimeValue t, Interval& valid = Interval(0,0)) {return 0.0f;}
	virtual int GetUseGlobal() {return 0;}
	virtual void SetUseGlobal(int a) {}
	virtual int GetShadow() {return 0;}
	virtual void SetShadow(int a) {}
	virtual int GetShadowType() {return 0;}
	virtual void SetShadowType(int a) {}
	virtual int GetAbsMapBias() {return 0;}
	virtual void SetAbsMapBias(int a) {}
	virtual int GetOvershoot() {return 0;}
	virtual void SetOvershoot(int a) {}
	virtual int GetProjector() {return 0;}
	virtual void SetProjector(int a) {}
	virtual NameTab* GetExclList() {return NULL;}
	virtual BOOL Include() {return FALSE;}
	virtual Texmap* GetProjMap() {return NULL;}
	virtual void SetProjMap(Texmap* pmap) {}
	virtual void UpdateTargDistance(TimeValue t, INode* inode) {}
	};

/*------------------------------------------------------------------- 
  HelperObject:
---------------------------------------------------------------------*/

class  HelperObject: public Object {
	public:
	SClass_ID SuperClassID() { return HELPER_CLASS_ID; }
	int IsRenderable() { return(0); }
	virtual void InitNodeName(TSTR& s) { s = _T("Helper"); }
	virtual int UsesWireColor() { return FALSE; }   // TRUE if the object color is used for display
	virtual BOOL NormalAlignVector(TimeValue t,Point3 &pt, Point3 &norm) {pt=Point3(0,0,0);norm=Point3(0,0,-1);return TRUE;}
	};

/*------------------------------------------------------------------- 
  ConstObject:
---------------------------------------------------------------------*/

#define GRID_PLANE_NONE		-1
#define GRID_PLANE_TOP		0
#define GRID_PLANE_LEFT		1
#define GRID_PLANE_FRONT	2
#define GRID_PLANE_BOTTOM	3
#define GRID_PLANE_RIGHT	4
#define GRID_PLANE_BACK		5

class  ConstObject: public HelperObject {
	private:
		bool m_transient;
	public:
		ConstObject():m_transient(false){};
	
	// Override this function in HelperObject!
	int IsConstObject() { return 1; }

	// Methods specific to construction grids:
	virtual void GetConstructionTM( TimeValue t, INode* inode, ViewExp *vpt, Matrix3 &tm ) = 0;     // Get the transform for this view
	virtual void SetConstructionPlane(int which, int notify=TRUE) = 0;
	virtual int  GetConstructionPlane(void) = 0;
	virtual Point3 GetSnaps( TimeValue t ) = 0;    // Get snap values
	virtual void SetSnaps(TimeValue t, Point3 p) = 0;

	virtual BOOL NormalAlignVector(TimeValue t,Point3 &pt, Point3 &norm) {pt=Point3(0,0,0);norm=Point3(0,0,-1);return TRUE;}

	//JH 09/28/98 for design ver
	bool IsTransient()const {return m_transient;}
	void SetTransient(bool state = true) {m_transient = state;}

	//JH 11/16/98
	virtual void SetExtents(TimeValue t, Point3 halfbox)=0;
	virtual Point3 GetExtents(TimeValue t)=0;
	//JH 09/28/98 for design ver
//	bool IsImplicit()const {return m_implicit;}
//	void SetImplicit(bool state = true) {m_implicit = state;}

	};

/*------------------------------------------------------------------- 
  GeomObject: these are the Renderable objects.  
---------------------------------------------------------------------*/

class  GeomObject: public Object {
	public:         
		virtual void InitNodeName(TSTR& s) { s = _T("Object"); }
		SClass_ID SuperClassID() { return GEOMOBJECT_CLASS_ID; }
		
		virtual int IsRenderable() { return(1); }               

		// If an object creates different  meshes depending on the 
		// particular instance (view-dependent) it should return 1.
		virtual int IsInstanceDependent() { return 0; }

		// GetRenderMesh should be implemented by all renderable GeomObjects.
		// set needDelete to TRUE if the render should delete the mesh, FALSE otherwise
		// Primitives that already have a mesh cached can just return a pointer
		// to it (and set needDelete = FALSE).
		CoreExport virtual Mesh* GetRenderMesh(TimeValue t, INode *inode, View& view, BOOL& needDelete);

		// If this returns NULL, then GetRenderMesh will be called
		CoreExport virtual PatchMesh* GetRenderPatchMesh(TimeValue t, INode *inode, View& view, BOOL& needDelete);

		CoreExport Class_ID PreferredCollapseType();

		virtual BOOL CanDoDisplacementMapping() { return 0; }

	private:
	};


//-- Particle Systems ---------------------------------------------------

// A force field can be applied to a particle system by a SpaceWarp.
// The force field provides a function of position in space, velocity
// and time that gives a force.
// The force is then used to compute an acceleration on a particle
// which modifies its velocity. Typically, particles are assumed to
// to have a normalized uniform mass==1 so the acceleration is F/M = F.
class ForceField {
	public:
		virtual Point3 Force(TimeValue t,const Point3 &pos, const Point3 &vel, int index)=0;
		virtual void DeleteThis() {}
	};

// A collision object can be applied to a particle system by a SpaceWarp.
// The collision object checks a particle's position and velocity and
// determines if the particle will colide with it in the next dt amount of
// time. If so, it modifies the position and velocity.
class CollisionObject {
	public:
		// Check for collision. Return TRUE if there was a collision and the position and velocity have been modified.
		virtual BOOL CheckCollision(TimeValue t,Point3 &pos, Point3 &vel, float dt,int index, float *ct=NULL, BOOL UpdatePastCollide=TRUE)=0;
		virtual Object *GetSWObject()=0;
	};


// Values returned from ParticleCenter()
#define PARTCENTER_HEAD		1  // Particle geometry lies behind the particle position
#define PARTCENTER_CENTER	2  // Particle geometry is centered around particle position
#define PARTCENTER_TAIL		3  // Particle geometry lies in front of the particle position

// The particle system class derived from GeomObject and still has
// GEOMOBJECT_CLASS_ID as its super class.
//
// Given an object, to determine if it is a ParticleObject, call
// GetInterface() with the ID  I_PARTICLEOBJ or use the macro
// GetParticleInterface(anim) which returns a ParticleObject* or NULL.
class ParticleObject: public GeomObject {
	public:
		BOOL IsParticleSystem() {return TRUE;}

		virtual void ApplyForceField(ForceField *ff)=0;
		virtual BOOL ApplyCollisionObject(CollisionObject *co)=0; // a particle can choose no to support this and return FALSE

		// A particle object IS deformable, but does not let itself be
		// deformed using the usual GetPoint/SetPoint methods. Instead
		// a space warp must apply a force field to deform the particle system.
		int IsDeformable() {return TRUE;} 

		// Particle objects don't actually do a shallow copy and therefore 
		// cannot be cached.
		BOOL CanCacheObject() {return FALSE;}


		virtual BOOL NormalAlignVector(TimeValue t,Point3 &pt, Point3 &norm) {pt=Point3(0,0,0);norm=Point3(0,0,-1);return TRUE;}


		// These methods provide information about individual particles
		virtual Point3 ParticlePosition(TimeValue t,int i) {return Point3(0,0,0);}
		virtual Point3 ParticleVelocity(TimeValue t,int i) {return Point3(0,0,0);}
		virtual float ParticleSize(TimeValue t,int i) {return 0.0f;}
		virtual int ParticleCenter(TimeValue t,int i) {return PARTCENTER_CENTER;}
		virtual TimeValue ParticleAge(TimeValue t, int i) {return -1;}
		virtual TimeValue ParticleLife(TimeValue t, int i) {return -1;}

		// This tells the renderer if the ParticleObject's topology doesn't change over time
		// so it can do better motion blur.  This means the correspondence of vertex id to
		// geometrical vertex must be invariant.
		virtual BOOL HasConstantTopology() { return FALSE; }
	};

//----------------------------------------------------------------------


/*------------------------------------------------------------------- 
  ShapeObject: these are the open or closed hierarchical shape objects.  
---------------------------------------------------------------------*/

class PolyShape;
class BezierShape;
class MeshCapInfo;
class PatchCapInfo;
class ShapeHierarchy;

// This class may be requested in the pipeline via the GENERIC_SHAPE_CLASS_ID,
// also set up in the Class_ID object genericShapeClassID

// Options for steps in MakePolyShape (>=0: Use fixed steps)
#define PSHAPE_BUILTIN_STEPS -2         // Use the shape's built-in steps/adaptive settings (default)
#define PSHAPE_ADAPTIVE_STEPS -1        // Force adaptive steps

// Parameter types for shape interpolation (Must match types in spline3d.h & polyshp.h)
#define PARAM_SIMPLE 0		// Parameter space based on segments
#define PARAM_NORMALIZED 1	// Parameter space normalized to curve length

class ShapeObject: public GeomObject {
		BOOL renderable;	// Is it renderable?
		float thickness;	// Renderable thickness
		BOOL generateUVs;	// Generate UV coords on renderable shape if TRUE
	public:
		CoreExport ShapeObject();
		CoreExport ~ShapeObject();	// Must call this on destruction

        virtual BOOL IsShapeObject() { return TRUE; }

		virtual int IntersectRay(TimeValue t, Ray& ray, float& at, Point3& norm) {return FALSE;}
		virtual void InitNodeName(TSTR& s) { s = _T("Shape"); }
		SClass_ID SuperClassID() { return SHAPE_CLASS_ID; }
		virtual int IsRenderable() { return (int)renderable;}
		CoreExport virtual void CopyBaseData(ShapeObject &from);
		// Access methods
		virtual BOOL GetRenderable() { return renderable; }
		virtual float GetThickness() { return thickness; }
		virtual BOOL GetGenUVs() { return generateUVs; }
		CoreExport virtual void SetRenderable(BOOL sw);
		CoreExport virtual void SetThickness(float t);
		CoreExport virtual void SetGenUVs(BOOL sw);
		CoreExport virtual Mesh* GetRenderMesh(TimeValue t, INode *inode, View& view, BOOL& needDelete);
		CoreExport virtual void GetRenderMeshInfo(TimeValue t, INode *inode, View& view, int &nverts, int &nfaces);	// Get info on the rendering mesh
		virtual int NumberOfVertices(TimeValue t, int curve = -1) { return 0; }	// Informational only, curve = -1: total in all curves
		virtual int NumberOfCurves()=0;                 // Number of curve polygons in the shape
		virtual BOOL CurveClosed(TimeValue t, int curve)=0;     // Returns TRUE if the curve is closed
		virtual Point3 InterpCurve3D(TimeValue t, int curve, float param, int ptype=PARAM_SIMPLE)=0;    // Interpolate from 0-1 on a curve
		virtual Point3 TangentCurve3D(TimeValue t, int curve, float param, int ptype=PARAM_SIMPLE)=0;   // Get tangent at point on a curve
		virtual float LengthOfCurve(TimeValue t, int curve)=0;  // Get the length of a curve
		virtual int NumberOfPieces(TimeValue t, int curve)=0;   // Number of sub-curves in a curve
		virtual Point3 InterpPiece3D(TimeValue t, int curve, int piece, float param, int ptype=PARAM_SIMPLE)=0; // Interpolate from 0-1 on a sub-curve
		virtual Point3 TangentPiece3D(TimeValue t, int curve, int piece, float param, int ptype=PARAM_SIMPLE)=0;        // Get tangent on a sub-curve
		virtual MtlID GetMatID(TimeValue t, int curve, int piece) { return 0; }
		virtual BOOL CanMakeBezier() { return FALSE; }                  // Return TRUE if can turn into a bezier representation
		virtual void MakeBezier(TimeValue t, BezierShape &shape) {}     // Create the bezier representation
		virtual ShapeHierarchy &OrganizeCurves(TimeValue t, ShapeHierarchy *hier=NULL)=0;       // Ready for lofting, extrusion, etc.
		virtual void MakePolyShape(TimeValue t, PolyShape &shape, int steps = PSHAPE_BUILTIN_STEPS, BOOL optimize = FALSE)=0;   // Create a PolyShape representation with optional fixed steps & optimization
		virtual int MakeCap(TimeValue t, MeshCapInfo &capInfo, int capType)=0;  // Generate mesh capping info for the shape
		virtual int MakeCap(TimeValue t, PatchCapInfo &capInfo) { return 0; }	// Only implement if CanMakeBezier=TRUE -- Gen patch cap info
		virtual BOOL AttachShape(TimeValue t, INode *thisNode, INode *attachNode, BOOL weldEnds=FALSE, float weldThreshold=0.0f) { return FALSE; }	// Return TRUE if attached
		// UVW Mapping switch access
		virtual BOOL HasUVW() { return GetGenUVs(); }
		virtual void SetGenUVW(BOOL sw) { SetGenUVs(sw); }
		// These handle loading and saving the data in this class. Should be called
		// by derived class BEFORE it loads or saves any chunks
		CoreExport virtual IOResult Save(ISave *isave);
		CoreExport virtual IOResult Load(ILoad *iload);		

		CoreExport virtual Class_ID PreferredCollapseType();
		CoreExport virtual BOOL GetExtendedProperties(TimeValue t, TSTR &prop1Label, TSTR &prop1Data, TSTR &prop2Label, TSTR &prop2Data);
		CoreExport virtual void RescaleWorldUnits(float f);
	private:
	};

// Set ShapeObject's global Constant Cross-Section angle threshold (angle in radians) --
// Used for renderable shapes.
CoreExport void SetShapeObjectCCSThreshold(float angle);

/*------------------------------------------------------------------- 
  WSMObject : This is the helper object for the WSM modifier
---------------------------------------------------------------------*/

class  WSMObject: public Object {
	public:                                         
		SClass_ID SuperClassID() { return WSM_OBJECT_CLASS_ID; }                
		virtual Modifier *CreateWSMMod(INode *node)=0;
		virtual int UsesWireColor() { return FALSE; }   // TRUE if the object color is used for display
		virtual BOOL NormalAlignVector(TimeValue t,Point3 &pt, Point3 &norm) {pt=Point3(0,0,0);norm=Point3(0,0,-1);return TRUE;}
		virtual BOOL SupportsDynamics() { return FALSE; } // TRUE if spacewarp or collision object supports Dynamics

		virtual ForceField *GetForceField(INode *node) {return NULL;}		
	private:
	};



//--- Interface to XRef objects ---------------------------------------------------

class IXRefObject: public Object {
	public:
		Class_ID ClassID() {return Class_ID(XREFOBJ_CLASS_ID,0);}
		SClass_ID SuperClassID() {return SYSTEM_CLASS_ID;}

		// Initialize a new XRef object
		virtual void Init(TSTR &fname, TSTR &oname, Object *ob, BOOL asProxy=FALSE)=0;

		virtual void SetFileName(TCHAR *name, BOOL proxy=FALSE, BOOL update=TRUE)=0;
		virtual void SetObjName(TCHAR *name, BOOL proxy=FALSE)=0;
		virtual void SetUseProxy(BOOL onOff,BOOL redraw=TRUE)=0;
		virtual void SetRenderProxy(BOOL onOff)=0;
		virtual void SetUpdateMats(BOOL onOff)=0;
		virtual void SetIgnoreAnim(BOOL onOff,BOOL redraw=TRUE)=0;
		
		virtual TSTR GetFileName(BOOL proxy=FALSE)=0;
		virtual TSTR GetObjName(BOOL proxy=FALSE)=0;
		virtual TSTR &GetCurFileName()=0;
		virtual TSTR &GetCurObjName()=0;
		virtual BOOL GetUseProxy()=0;
		virtual BOOL GetRenderProxy()=0;
		virtual BOOL GetUpdateMats()=0;
		virtual BOOL GetIgnoreAnim()=0;		
		
		// Causes browse dialogs to appear
		virtual void BrowseObject(BOOL proxy)=0;
		virtual void BrowseFile(BOOL proxy)=0;

		// Try to reload ref
		virtual void ReloadXRef()=0;
	};



//---------------------------------------------------------------------------------


class ControlMatrix3;

// Used with EnumModContexts()
class ModContextEnumProc {
	public:
		virtual BOOL proc(ModContext *mc)=0;  // Return FALSE to stop, TRUE to continue.
	};

/*------------------------------------------------------------------- 
  Modifier: these are the ObjectSpace and World Space modifiers: They are 
  subclassed off of BaseObject so that they can put up a graphical 
  representation in the viewport. 
---------------------------------------------------------------------*/

class  Modifier: public BaseObject {
		friend class ModNameRestore;
		TSTR modName;
	public:
		
		CoreExport virtual TSTR GetName();
		CoreExport virtual void SetName(TSTR n);

		SClass_ID SuperClassID() { return OSM_CLASS_ID; }
		
		// Disables all mod apps that reference this modifier _and_ have a select
		// anim flag turned on.
		void DisableModApps() { NotifyDependents(FOREVER,PART_OBJ,REFMSG_DISABLE); }
		void EnableModApps() {  NotifyDependents(FOREVER,PART_OBJ,REFMSG_ENABLE); }
		
		// This disables or enables the mod. All mod apps referencing will be affected.
		void DisableMod() { 
			SetAFlag(A_MOD_DISABLED);
			NotifyDependents(FOREVER,PART_ALL|PART_OBJECT_TYPE,REFMSG_CHANGE); 
			}
		void EnableMod() {      
			ClearAFlag(A_MOD_DISABLED);
			NotifyDependents(FOREVER,PART_ALL|PART_OBJECT_TYPE,REFMSG_CHANGE); 
			}
		int IsEnabled() { return !TestAFlag(A_MOD_DISABLED); }

		// Same as above but for viewports only
		void DisableModInViews() { 
			SetAFlag(A_MOD_DISABLED_INVIEWS);
			NotifyDependents(FOREVER,PART_ALL|PART_OBJECT_TYPE,REFMSG_CHANGE); 
			}
		void EnableModInViews() {      
			ClearAFlag(A_MOD_DISABLED_INVIEWS);
			NotifyDependents(FOREVER,PART_ALL|PART_OBJECT_TYPE,REFMSG_CHANGE); 
			}
		int IsEnabledInViews() { return !TestAFlag(A_MOD_DISABLED_INVIEWS); }

		CoreExport virtual Interval LocalValidity(TimeValue t);
		virtual ChannelMask ChannelsUsed()=0;
		virtual ChannelMask ChannelsChanged()=0;
		// this is used to invalidate cache's in Edit Modifiers:
		virtual void NotifyInputChanged(Interval changeInt, PartID partID, RefMessage message, ModContext *mc) {}

		// These call ChannelsUsed/Changed() but also OR in GFX_DATA_CHANNEL as appropriate.
		CoreExport ChannelMask TotalChannelsUsed();
		CoreExport ChannelMask TotalChannelsChanged();
		
		// This is the method that is called when the modifier is needed to 
		// apply its effect to the object. Note that the INode* is always NULL
		// for object space modifiers.
		virtual void ModifyObject(TimeValue t, ModContext &mc, ObjectState* os, INode *node)=0;

		// this should return FALSE for things like edit modifiers
		virtual int NeedUseSubselButton() { return 1; }
			  
		// Modifiers that place a dependency on topology should return TRUE
		// for this method. An example would be a modifier that stores a selection
		// set base on vertex indices.
		virtual BOOL DependOnTopology(ModContext &mc) {return FALSE;}

		// this can return:
		//   DEFORM_OBJ_CLASS_ID -- not really a class, but so what
		//   MAPPABLE_OBJ_CLASS_ID -- ditto
		//   TRIOBJ_CLASS_ID
		//   BEZIER_PATCH_OBJ_CLASS_ID
		virtual Class_ID InputType()=0;

		virtual void ForceNotify(Interval& i) 
			{NotifyDependents(i,ChannelsChanged(),REFMSG_CHANGE );}

		virtual IOResult SaveLocalData(ISave *isave, LocalModData *ld) { return IO_OK; }  
		virtual IOResult LoadLocalData(ILoad *iload, LocalModData **pld) { return IO_OK; }  

		// These handle loading and saving the modifier name. Should be called
		// by derived class BEFORE it loads or saves any chunks
		CoreExport IOResult Save(ISave *isave);
		CoreExport IOResult Load(ILoad *iload);

		// This will call proc->proc once for each application of the modifier.
		CoreExport void EnumModContexts(ModContextEnumProc *proc);

		// Animatable Overides...
		CoreExport SvGraphNodeReference SvTraverseAnimGraph(IGraphObjectManager *gom, Animatable *owner, int id, DWORD flags);
		CoreExport TSTR SvGetName(IGraphObjectManager *gom, IGraphNode *gNode, bool isBeingEdited);
		CoreExport bool SvCanSetName(IGraphObjectManager *gom, IGraphNode *gNode);
		CoreExport bool SvSetName(IGraphObjectManager *gom, IGraphNode *gNode, TSTR &name);
		CoreExport bool SvHandleDoubleClick(IGraphObjectManager *gom, IGraphNode *gNode);
		CoreExport COLORREF SvHighlightColor(IGraphObjectManager *gom, IGraphNode *gNode);
		CoreExport bool SvIsSelected(IGraphObjectManager *gom, IGraphNode *gNode);
		CoreExport MultiSelectCallback* SvGetMultiSelectCallback(IGraphObjectManager *gom, IGraphNode *gNode);
		CoreExport bool SvCanSelect(IGraphObjectManager *gom, IGraphNode *gNode);
		CoreExport bool SvCanInitiateLink(IGraphObjectManager *gom, IGraphNode *gNode);
		CoreExport bool SvCanConcludeLink(IGraphObjectManager *gom, IGraphNode *gNode, IGraphNode *gNodeChild);
		CoreExport bool SvLinkChild(IGraphObjectManager *gom, IGraphNode *gNodeThis, IGraphNode *gNodeChild);
		CoreExport bool SvCanRemoveThis(IGraphObjectManager *gom, IGraphNode *gNode);
		CoreExport bool SvRemoveThis(IGraphObjectManager *gom, IGraphNode *gNode);
	private:
	};

class  OSModifier: public Modifier {
	public:
		SClass_ID SuperClassID() { return OSM_CLASS_ID; }
	};

class  WSModifier: public Modifier {
	public:
		SClass_ID SuperClassID() { return WSM_CLASS_ID; }
	};

void CoreExport MakeHitRegion(HitRegion& hr, int type, int crossing, int epsi, IPoint2 *p);

class PolyLineProc {
	public:
	virtual int proc(Point3 *p, int n)=0;
	virtual void SetLineColor(float r, float g, float b) {}
	virtual void SetLineColor(Point3 c) {}
	virtual void Marker(Point3 *p,MarkerType type) {}
	};

class DrawLineProc:public PolyLineProc {
	GraphicsWindow *gw;
	public:
		DrawLineProc() { gw = NULL; }
		DrawLineProc(GraphicsWindow *g) { gw = g; }
		int proc(Point3 *p, int n) { gw->polyline(n, p, NULL, NULL, 0, NULL); return 0; }
		void SetLineColor(float r, float g, float b) {gw->setColor(LINE_COLOR,r,g,b);}
		void SetLineColor(Point3 c) {gw->setColor(LINE_COLOR,c);}
		void Marker(Point3 *p,MarkerType type) {gw->marker(p,type);}
	};

class BoxLineProc:public PolyLineProc {
	Box3 box;
	Matrix3 *tm;
	public:
		BoxLineProc() { box.Init();}
		BoxLineProc(Matrix3* m) { tm = m;  box.Init(); }
		Box3& Box() { return box; }
		CoreExport int proc(Point3 *p, int n);
		CoreExport void Marker(Point3 *p,MarkerType type);
	};


// Apply the PolyLineProc to each edge (represented by an array of Point3's) of the box
// after passing it through the Deformer def.
void CoreExport DoModifiedBox(Box3& box, Deformer &def, PolyLineProc& lp);
void CoreExport DoModifiedLimit(Box3& box, float z, int axis, Deformer &def, PolyLineProc& lp);
void CoreExport DrawCenterMark(PolyLineProc& lp, Box3& box );

// Some functions to draw mapping icons
void CoreExport DoSphericalMapIcon(BOOL sel,float radius, PolyLineProc& lp);
void CoreExport DoCylindricalMapIcon(BOOL sel,float radius, float height, PolyLineProc& lp);
void CoreExport DoPlanarMapIcon(BOOL sel,float width, float length, PolyLineProc& lp);

//---------------------------------------------------------------------
// Data structures for keeping log of hits during sub-object hit-testing.
//---------------------------------------------------------------------

class HitLog;
class HitRecord {
	friend class HitLog;    
	HitRecord *next;
	public:         
		INode *nodeRef;
		ModContext *modContext;
		DWORD distance;
		ulong hitInfo;
		HitData *hitData;
		HitRecord() { next = NULL; modContext = NULL; distance = 0; hitInfo = 0; hitData = NULL;}
		HitRecord(INode *nr, ModContext *mc, DWORD d, ulong inf, HitData *hitdat) {
			next = NULL;
			nodeRef = nr; modContext = mc; distance = d; hitInfo = inf; hitData = hitdat;
			}               
		HitRecord(HitRecord *n,INode *nr, ModContext *mc, DWORD d, ulong inf, HitData *hitdat) {
			next = n;
			nodeRef = nr; modContext = mc; distance = d; hitInfo = inf; hitData = hitdat;
			}               
		HitRecord *     Next() { return next; }
		~HitRecord() { if (hitData) { delete hitData; hitData = NULL; } }
	};                                      

class HitLog {
	HitRecord *first;
	int hitIndex;
	public:
		HitLog()  { first = NULL; hitIndex = 0; }
		~HitLog() { Clear(); }
		CoreExport void Clear();
		CoreExport void ClearHitIndex()		{ hitIndex = 0; }
		CoreExport void IncrHitIndex()		{ hitIndex++; }
		HitRecord* First() { return first; }
		CoreExport HitRecord* ClosestHit();
		CoreExport void LogHit(INode *nr, ModContext *mc, DWORD dist, ulong info, HitData *hitdat = NULL);
	};


// Creates a new empty derived object, sets it to point at the given
// object and returns a pointer to the derived object.
CoreExport Object *MakeObjectDerivedObject(Object *obj);


// Category strings for space warp objects:

#define SPACEWARP_CAT_GEOMDEF		1
#define SPACEWARP_CAT_MODBASED		2
#define SPACEWARP_CAT_PARTICLE		3

CoreExport TCHAR *GetSpaceWarpCatString(int id);


#endif //_OBJECT_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\notetrck.h ===
/**********************************************************************
 *<
	FILE:  notetrck.h

	DESCRIPTION:  Note track plug-in class

	CREATED BY: Rolf Berteig

	HISTORY: created July 20, 1995

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/


#ifndef __NOTETRCK_H__
#define __NOTETRCK_H__

class NoteTrack : public ReferenceTarget {
	public:
		SClass_ID SuperClassID() {return SClass_ID(NOTETRACK_CLASS_ID);}
		RefResult AutoDelete() {return REF_SUCCEED;}
	};

class NoteAnimProperty : public AnimProperty {
	public:		
		NoteTrack *note;
		DWORD ID() {return PROPID_NOTETRACK;}

		NoteAnimProperty(NoteTrack *n=NULL) {note = n;}
		~NoteAnimProperty() {if (note) note->DeleteMe();}
	};


CoreExport NoteTrack *NewDefaultNoteTrack();




// Standard note track plug-in class definitions:

// Note Key Flags
#define NOTEKEY_SELECTED	(1<<0)
#define NOTEKEY_LOCKED		(1<<1)
#define NOTEKEY_FLAGGED		(1<<2)

class NoteKey {
	public:
		TimeValue time;
		TSTR note;
		DWORD flags;
		
		NoteKey(TimeValue t,const TSTR &n,DWORD f=0) {time=t;note=n;flags=f;}
		NoteKey(NoteKey& n) {time=n.time;note=n.note;flags=n.flags;}

		void SetFlag(DWORD mask) { flags|=(mask); }
		void ClearFlag(DWORD mask) { flags &= ~(mask); }
		BOOL TestFlag(DWORD mask) { return(flags&(mask)?1:0); }
	};

class NoteKeyTab : public Tab<NoteKey*> {
	public:
		~NoteKeyTab() {Clear();}
		CoreExport void Clear();
		void DelKey(int i) {delete (*this)[i]; Delete(i,1);}
		CoreExport NoteKeyTab &operator=(NoteKeyTab &keys);
		CoreExport void KeysChanged();
	};

class NoteKeyClipObject : public TrackClipObject {
	public:
		NoteKeyTab tab;

		Class_ID ClassID() {return Class_ID(NOTETRACK_CLASS_ID,0);}
		SClass_ID SuperClassID() { return NOTETRACK_CLASS_ID; }
		void DeleteThis() {delete this;}

		NoteKeyClipObject(Interval iv) : TrackClipObject(iv) {}
	};

class DefNoteTrack : public NoteTrack {
	public:
		NoteKeyTab keys;
		
		DefNoteTrack() {}
		DefNoteTrack(DefNoteTrack &n) {keys=n.keys;}
		DefNoteTrack& operator=(DefNoteTrack &track) {keys=track.keys;return *this;}
		CoreExport void HoldTrack();

		Class_ID ClassID() {return Class_ID(NOTETRACK_CLASS_ID,0);}

		// Tree view methods from animatable
		int NumKeys() {return keys.Count();}
		TimeValue GetKeyTime(int index) {return keys[index]->time;}
		CoreExport void MapKeys(TimeMap *map,DWORD flags );
		CoreExport void DeleteKeys( DWORD flags );
		CoreExport void CloneSelectedKeys(BOOL offset);		
		CoreExport void DeleteTime( Interval iv, DWORD flags );
		CoreExport void ReverseTime( Interval iv, DWORD flags );
		CoreExport void ScaleTime( Interval iv, float s);
		CoreExport void InsertTime( TimeValue ins, TimeValue amount );
		CoreExport void AddNewKey(TimeValue t,DWORD flags);
		CoreExport int GetSelKeyCoords(TimeValue &t, float &val,DWORD flags);
		CoreExport void SetSelKeyCoords(TimeValue t, float val,DWORD flags);
		CoreExport int GetTrackVSpace( int lineHeight ) {return 1;}
		CoreExport BOOL CanCopyTrack(Interval iv,DWORD flags) {return 1;}
		CoreExport BOOL CanPasteTrack(TrackClipObject *cobj,Interval iv,DWORD flags) {return cobj->ClassID()==ClassID();}
		CoreExport TrackClipObject *CopyTrack(Interval iv,DWORD flags);
		CoreExport void PasteTrack(TrackClipObject *cobj,Interval iv,DWORD flags);
		CoreExport Interval GetTimeRange(DWORD flags) ;		
		CoreExport int HitTestTrack(TrackHitTab& hits,Rect& rcHit,Rect& rcTrack,float zoom,int scroll,DWORD flags );
		CoreExport int PaintTrack(ParamDimensionBase *dim,HDC hdc,Rect& rcTrack,Rect& rcPaint,float zoom,int scroll,DWORD flags );
		CoreExport void SelectKeys( TrackHitTab& sel, DWORD flags );
		CoreExport void SelectKeyByIndex(int i,BOOL sel);
		CoreExport int NumSelKeys();
		CoreExport void FlagKey(TrackHitRecord hit);
		CoreExport int GetFlagKeyIndex();		
		CoreExport BOOL IsAnimated() {return TRUE;}
		CoreExport void EditTrackParams(TimeValue t,ParamDimensionBase *dim,TCHAR *pname,HWND hParent,IObjParam *ip,DWORD flags);
		CoreExport int TrackParamsType() {return TRACKPARAMS_KEY;}
		CoreExport BOOL SupportTimeOperations() {return TRUE;}

		CoreExport IOResult Save(ISave *isave);
		CoreExport IOResult Load(ILoad *iload);

		void DeleteThis() {delete this;}
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget,
	         PartID& partID, RefMessage message) {return REF_SUCCEED;}
		RefTargetHandle Clone(RemapDir &remap);
	};


#endif // __NOTETRCK_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Omanapi.h ===
/**********************************************************************
 	FILE: omanapi.h

	DESCRIPTION:  Defines an interface to the osnapmanager class

	CREATED BY: John Hutchinson
	HISTORY: May 14, 1997
	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#ifndef _IOMAN_H
#define _IOMAN_H
// This class provides an interface to the OsnapManager. People who implement osnaps
// need to record hits with the manager. People implementing command modes are responsible 
// for getting the snap preview done and may be responsible for initting and closing point
// sequences.
class OsnapHit;
  
class IOsnapManager
{
public:
	virtual BOOL getactive() const =0;
	virtual BOOL getAxisConstraint()=0;
	virtual void RecordHit(OsnapHit* somehit)=0;
	virtual BOOL OKForRelativeSnap()=0;
	virtual BOOL RefPointWasSnapped()=0;
	virtual Point3 GetRefPoint(BOOL top = TRUE)=0;
	virtual BOOL IsHolding()=0;
	virtual OsnapHit &GetHit()=0;
	virtual ViewExp* GetVpt()=0;
	virtual INode* GetNode()=0;
	virtual int GetSnapStrength()=0;
	virtual Matrix3 GetObjectTM()=0;
	virtual TimeValue GetTime()=0;
	virtual void wTranspoint(Point3 *inpt, IPoint3 *outpt)=0;
	virtual void Reset() =0;
	virtual BOOL TestAFlag(int mask)=0;
	virtual Point3 GetCurrentPoint()=0;
};

#endif// _IOMAN_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\notify.h ===
/**********************************************************************
 *<
	FILE: notify.h

	DESCRIPTION: Include file for event notification support

	CREATED BY: Tom Hudson

	HISTORY: Created 8 April 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#ifndef _NOTIFY_H_

#define _NOTIFY_H_

// Pre-defined Jaguar system notification codes

#define NOTIFY_UNITS_CHANGE			0x00000001
#define NOTIFY_TIMEUNITS_CHANGE	 	0x00000002
#define NOTIFY_VIEWPORT_CHANGE	 	0x00000003
#define NOTIFY_SPACEMODE_CHANGE	 	0x00000004
#define NOTIFY_SYSTEM_PRE_RESET	 	0x00000005	// Sent before system is reset
#define NOTIFY_SYSTEM_POST_RESET 	0x00000006	// Sent after system is reset
#define NOTIFY_SYSTEM_PRE_NEW		0x00000007	// Sent before system is NEW'd-out
#define NOTIFY_SYSTEM_POST_NEW		0x00000008	// Sent after system is NEW'd-out
#define NOTIFY_FILE_PRE_OPEN		0x00000009	// Sent before a new file is opened
#define NOTIFY_FILE_POST_OPEN		0x0000000A	// Sent after a new file is opened successfully
#define NOTIFY_FILE_PRE_MERGE		0x0000000B	// Sent before a file is merged
#define NOTIFY_FILE_POST_MERGE		0x0000000C	// Sent after a file is merged successfully
#define NOTIFY_FILE_PRE_SAVE		0x0000000D	// Sent before a file is saved
#define NOTIFY_FILE_POST_SAVE		0x0000000E	// Sent after a file is saved
#define NOTIFY_FILE_PRE_SAVE_OLD 	0x00000010	// Sent before an old version file is saved
#define NOTIFY_FILE_POST_SAVE_OLD	0x00000011	// Sent after an old version file is saved
#define NOTIFY_SELECTIONSET_CHANGED	0x00000012	// Sent after the selection set has changed
#define NOTIFY_BITMAP_CHANGED		0x00000013	// Sent after the bitmap is reloaded ( callParam is TCHAR * to bitmap file name )
#define NOTIFY_PRE_RENDER			0x00000014	// Sent before rendering is started
#define NOTIFY_POST_RENDER			0x00000015	// Sent after rendering has finished
// Note: The NOTIFY_PRE_RENDERFRAME and NOTIFY_POST_RENDERFRAME callbacks are for internal use.
// The scene is to be considered read-only at those callbacks.
#define NOTIFY_PRE_RENDERFRAME		0x00000016	// Sent before rendering each frame ( callParam is RenderGlobalContext* )
#define NOTIFY_POST_RENDERFRAME		0x00000017	// Sent after rendering each frame  ( callParam is RenderGlobalContext* )
#define NOTIFY_PRE_IMPORT			0x00000018	// Sent before a file is imported
#define NOTIFY_POST_IMPORT			0x00000019	// Sent after a file is imported
#define NOTIFY_IMPORT_FAILED		0x0000001A	// Sent if import fails
#define NOTIFY_PRE_EXPORT			0x0000001B	// Sent before a file is exported
#define NOTIFY_POST_EXPORT			0x0000001C	// Sent after a file is exported
#define NOTIFY_EXPORT_FAILED		0x0000001D	// Sent if export fails
#define NOTIFY_NODE_RENAMED		    0x0000001E	// Sent if node renamed. (call Param is pointer to struct{ TCHAR* oldname; TCHAR* newname; } }
#define NOTIFY_PRE_PROGRESS			0x0000001F	// Sent before the progress bar is displayed (so you can hide your window)
#define NOTIFY_POST_PROGRESS		0x00000020	// Sent after the progress bar is finished (so you can show your window again)
#define NOTIFY_MODPANEL_SEL_CHANGED	0x00000021	// Sent when the modify panel focuses on a new object (via open Mod panel or changing selection)
#define NOTIFY_HEIGHT_CHANGED		0x00000022	// VIZ Sent when the user operates the height menu
#define NOTIFY_RENDPARAM_CHANGED	0x00000023	// VIZ Sent when the common renderer parameters have changed
#define NOTIFY_MATLIB_PRE_OPEN		0x00000024	// Sent before loading a material library
#define NOTIFY_MATLIB_POST_OPEN		0x00000025	// Sent after loading a material library (call Param is ptr to MtlBaseLib if success, else NULL)
#define NOTIFY_MATLIB_PRE_SAVE		0x00000026	// Sent before saving a material library
#define NOTIFY_MATLIB_POST_SAVE		0x00000027	// Sent after saving a material library
#define NOTIFY_MATLIB_PRE_MERGE		0x00000028	// Sent before merging a material library
#define NOTIFY_MATLIB_POST_MERGE	0x00000029	// Sent after merging a material library
#define NOTIFY_FILELINK_PRE_BIND	0x00000030	// VIZ Sent before a file link bind
#define NOTIFY_FILELINK_POST_BIND	0x00000031	// VIZ Sent after a file link bind
#define NOTIFY_FILELINK_PRE_DETACH	0x00000032	// VIZ Sent before a file link detach
#define NOTIFY_FILELINK_POST_DETACH	0x00000033	// VIZ Sent after a file link detach
#define NOTIFY_FILELINK_PRE_RELOAD	0x00000034	// VIZ Sent before a file link reload (partial, full, or dynamic)
#define NOTIFY_FILELINK_POST_RELOAD	0x00000035	// VIZ Sent after a file link reload (partial, full, or dynamic)
#define NOTIFY_FILELINK_PRE_ATTACH	0x00000036	// VIZ Sent before a file link attach
#define NOTIFY_FILELINK_POST_ATTACH	0x00000037	// VIZ Sent after a file link attach
#define NOTIFY_AB_NAVIGATE_URL      0x00000038  // VIZ request to load a URL into the Asset Browser
#define NOTIFY_RENDER_PREEVAL       0x00000039  // Sent before the render start evaluating objects

// Notification information structure -- Passed to NOTIFYPROC to inform it what
// it's being notified about...
typedef struct {
	int intcode;
	void *callParam;  // this param can be passed in with BroadcastNotification;
	} NotifyInfo;

// The notification callback function
typedef void (* NOTIFYPROC)(void *param, NotifyInfo *info);

// Integer versions -- For pre-defined MAX codes
int CoreExport RegisterNotification(NOTIFYPROC proc, void *param, int code);
int CoreExport UnRegisterNotification(NOTIFYPROC proc, void *param, int code);
void CoreExport BroadcastNotification(int code);
void CoreExport BroadcastNotification(int code, void *callParam);

// Unregister a callback from all codes
int CoreExport UnRegisterNotification(NOTIFYPROC proc, void *param);

#endif // _NOTIFY_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\objmode.h ===
/**********************************************************************
 *<
	FILE: objmode.h

	DESCRIPTION: Provides some standard modes for subobject manipulation

	CREATED BY: Rolf Berteig

	HISTORY: Created 3-14-95

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __OBJMODE__
#define __OBJMODE__


class Transformer {
	protected:
		Matrix3 tmAxis;
		IObjParam *ip;
		IPoint2 mBase, mCur;
		
	public:
		Transformer(IObjParam *i) { ip = i; }
		CoreExport virtual void BeginDrag( IPoint2& m, Matrix3& tmAxis );
		CoreExport virtual void EndDrag( IPoint2& m );
		CoreExport void SetMouse( IPoint2& m );
#ifdef _OSNAP
		CoreExport virtual void SnapPreview(ViewExp *vpt, IPoint2 in, IPoint2 out, Matrix3 *m , DWORD flags){};
#endif
		virtual void Accumulate() {mBase=mCur;}
		Matrix3& Axis() { return tmAxis; }
		IPoint2 Base() { return mBase; }
	};

class MoveTransformer : public Transformer {
 		Point3 lastDelta;
		Point3 absSnapOrigin;
		BOOL selfSnap;
 	public:
 		void SetSelfSnap(BOOL ss) {selfSnap=ss;}
		BOOL GetSelfSnap() {return selfSnap;}
		CoreExport void BeginDrag( IPoint2& m, Matrix3& tmAxis );
 		CoreExport Point3 Eval(ViewExp *vpt,BOOL status=TRUE);
#ifdef DESIGN_VER
		CoreExport virtual void EndDrag( IPoint2& m );
#endif
		MoveTransformer(IObjParam *i,BOOL so=FALSE) : Transformer(i) {lastDelta = Point3(0,0,0); selfSnap=so;}
		CoreExport void Accumulate();
#ifdef _OSNAP
		CoreExport void SnapPreview(ViewExp *vpt, IPoint2 in, IPoint2 out, Matrix3 *m , DWORD flags);
#endif
 		};	

class RotateTransformer : public Transformer {
 		Quat qPrev;
 	public:
 		CoreExport AngAxis Eval(ViewExp *vpt,BOOL status=TRUE);
		CoreExport void BeginDrag( IPoint2& m, Matrix3& tmAxis );
		RotateTransformer(IObjParam *i) : Transformer(i) {qPrev.Identity();}
#ifdef _OSNAP
		CoreExport void SnapPreview(ViewExp *vpt, IPoint2 in, IPoint2 out, Matrix3 *m , DWORD flags);
#endif
 		};	

class ScaleTransformer : public Transformer {
 	public:
 		CoreExport Point3 Eval(ViewExp *vpt,BOOL status=TRUE);
		ScaleTransformer(IObjParam *i) : Transformer(i) {}
#ifdef _OSNAP
		CoreExport void BeginDrag( IPoint2& m, Matrix3& tmAxis );
		CoreExport void SnapPreview(ViewExp *vpt, IPoint2 in, IPoint2 out, Matrix3 *m , DWORD flags);
#endif
 		};	


class ChangeFGObject : public ChangeForegroundCallback {	
		ReferenceTarget *obj;
		BOOL valid;
	public:		
		ChangeFGObject() { obj = NULL; valid = TRUE; }
		ChangeFGObject(ReferenceTarget *o) { obj = o; valid = TRUE; }
		void SetObj(ReferenceTarget *o ) { obj = o; }
		
		BOOL IsValid() { return valid; }
		void Invalidate() { valid = FALSE; }
		void Validate() { valid = TRUE; }
		void callback(TimeValue t,IScene *scene)
			{
			obj->FlagDependents(t);			
			}
	};



class SelectionProcessor : public MouseCallBack {
	private:
		MouseCallBack *mcallback;
		BOOL brokenThresh, hitSel, drag, toggle, cloning, clear, invert;
		IPoint2 offset;
		IPoint2 om,lm;

	protected:
		IObjParam *ip;

		virtual BOOL HitTest( ViewExp *vpt, IPoint2 *p, int type, int flags )=0;
		virtual BOOL AnyHits( ViewExp *vpt )=0;
		virtual HCURSOR GetTransformCursor()=0;
		virtual void Select(ViewExp *vpt,BOOL all,BOOL clear,BOOL invert)=0;
		virtual void DeSelect(ViewExp *vpt,BOOL all)=0;
		virtual void ClearSelection()=0;
		virtual void CloneSelected(int initialCall=TRUE)=0;
		virtual void AbortClone()=0;
		virtual void AcceptClone()=0;
		virtual void SelectChildren(ViewExp *vpt) {}

	public:
		SelectionProcessor(MouseCallBack *m,IObjParam *i) 
			{ mcallback = m; ip = i; offset = IPoint2(0,0); }
		
		CoreExport virtual int proc( 
			HWND hwnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m );

		CoreExport void pan(IPoint2 d);
	};


class TransformModBox : public MouseCallBack {
	protected:
		BaseObject *obj;
		IObjParam *ip;		
		Matrix3 ptm;

	public:
		CoreExport TransformModBox(BaseObject *o, IObjParam *i);
		CoreExport ~TransformModBox();

		// These are called before and after the DoTransform operations
		CoreExport virtual void PreTransform();
		CoreExport virtual void PreTransformHolding();
		CoreExport virtual void PostTransformHolding();
		CoreExport virtual void PostTransform();
		CoreExport virtual void CancelTransform();

		virtual Transformer& GetTransformer()=0;
		virtual void DoTransform(ViewExp *vpt)=0;
		virtual HCURSOR GetTransformCursor()=0;
		virtual int UndoStringID()=0;

		CoreExport int proc( 
			HWND hwnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m );
	};


class GenModSelectionProcessor : public SelectionProcessor {
	protected:
		BaseObject *obj;
		BOOL transformGizmoActive;

		CoreExport BOOL HitTest( ViewExp *vpt, IPoint2 *p, int type, int flags );
		BOOL AnyHits( ViewExp *vpt ) { return vpt->NumSubObjHits(); }		
		CoreExport void Select(ViewExp *vpt,BOOL all,BOOL clear,BOOL invert);
		CoreExport void DeSelect(ViewExp *vpt,BOOL all);
		CoreExport void ClearSelection();
		CoreExport void CloneSelected(int initialCall=TRUE);
		CoreExport void AbortClone();
		CoreExport void AcceptClone();

	public:
		GenModSelectionProcessor(MouseCallBack *mc, BaseObject *o, IObjParam *i) 
			: SelectionProcessor(mc,i) {obj = o; transformGizmoActive=FALSE; }
	};

class SubModSelectionProcessor : public GenModSelectionProcessor {
	private:		
		TransformModBox *tproc;
		BOOL supportTransformGizmo;

	protected:
		HCURSOR GetTransformCursor() { return tproc ? tproc->GetTransformCursor() : LoadCursor(NULL, IDC_ARROW); }
		
	public:
		SubModSelectionProcessor(TransformModBox *mc, BaseObject *o, IObjParam *i) 
			: GenModSelectionProcessor(mc,o,i) { 
				tproc = mc; supportTransformGizmo=FALSE; }

		// Transform Gizmo Interface
		BOOL SupportTransformGizmo() { return supportTransformGizmo; }
		void DeactivateTransformGizmo() {
			if (transformGizmoActive) {
				ip->DeactivateTransformGizmo();
				transformGizmoActive = FALSE;
				}
			}
		// End of Transform Gizmo Interface
		// Private gizmo stuff
		void SetSupportTransformGizmo(BOOL b) { supportTransformGizmo = b; }
	};


class MoveModBox : public TransformModBox {
	private:
		MoveTransformer moveTrans;
	public:
		MoveModBox(BaseObject *o, IObjParam *i) : moveTrans(i,TRUE), TransformModBox(o,i) {}
		Transformer& GetTransformer() { return moveTrans; }
		CoreExport void DoTransform(ViewExp *vpt);
		HCURSOR GetTransformCursor() { return ip->GetSysCursor(SYSCUR_MOVE); }
		CoreExport int UndoStringID();
		};
class RotateModBox : public TransformModBox {
	private:
		RotateTransformer rotTrans;
	public:
		RotateModBox(BaseObject *o, IObjParam *i) : rotTrans(i), TransformModBox(o,i) {}
		Transformer& GetTransformer() { return rotTrans; }
		CoreExport void DoTransform(ViewExp *vpt);
		HCURSOR GetTransformCursor() { return ip->GetSysCursor(SYSCUR_ROTATE); }
		CoreExport int UndoStringID();
		};
class ScaleModBox : public TransformModBox {
	private:
		ScaleTransformer scaleTrans;
	public:
		ScaleModBox(BaseObject *o, IObjParam *i) : scaleTrans(i), TransformModBox(o,i) {}
		Transformer& GetTransformer() { return scaleTrans; }
		CoreExport void DoTransform(ViewExp *vpt);
		CoreExport HCURSOR GetTransformCursor();
		CoreExport int UndoStringID();
		};
class SelectModBox : public TransformModBox {
	private:
		MoveTransformer moveTrans;
	public:
		SelectModBox(BaseObject *o, IObjParam *i) : moveTrans(i), TransformModBox(o,i) {}
		Transformer& GetTransformer() { return moveTrans; }
		void DoTransform(ViewExp *vpt) {}
		HCURSOR GetTransformCursor() { return ip->GetSysCursor(SYSCUR_SELECT); }
		CoreExport int UndoStringID();
		};


class MoveModBoxCMode : public CommandMode {
	
	private:
		ChangeFGObject fgProc;
		SubModSelectionProcessor mouseProc;
		MoveModBox transProc;
		IObjParam *ip;

	public:
		MoveModBoxCMode( BaseObject *o, IObjParam *i ) : 
			fgProc(o), transProc(o,i), mouseProc(&transProc,o,i) 
				{ ip = i; mouseProc.SetSupportTransformGizmo(TRUE); }
		
		int Class() { return MOVE_COMMAND; }
		int ID() { return CID_SUBOBJMOVE; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints=2; return &mouseProc; }
		ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
		BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
		void EnterMode() { ip->SetToolButtonState(MOVE_BUTTON,TRUE); }
		void ExitMode() { ip->SetToolButtonState(MOVE_BUTTON,FALSE); }
	};

class RotateModBoxCMode : public CommandMode {
	
	private:
		ChangeFGObject fgProc;
		SubModSelectionProcessor mouseProc;
		RotateModBox transProc;
		IObjParam *ip;

	public:
		RotateModBoxCMode( BaseObject *o, IObjParam *i ) : 
			fgProc(o), transProc(o,i), mouseProc(&transProc,o,i) 
				{ ip = i; mouseProc.SetSupportTransformGizmo(TRUE); }
		
		int Class() { return ROTATE_COMMAND; }
		int ID() { return CID_SUBOBJROTATE; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints=2; return &mouseProc; }
		ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
		BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
		void EnterMode() { ip->SetToolButtonState(ROTATE_BUTTON,TRUE); }
		void ExitMode() { ip->SetToolButtonState(ROTATE_BUTTON,FALSE); }
	};

class UScaleModBoxCMode : public CommandMode {
	
	private:
		ChangeFGObject fgProc;
		SubModSelectionProcessor mouseProc;
		ScaleModBox transProc;
		IObjParam *ip;

	public:
		UScaleModBoxCMode( BaseObject *o, IObjParam *i ) : 
			fgProc(o), transProc(o,i), mouseProc(&transProc,o,i) 
				{ ip = i; mouseProc.SetSupportTransformGizmo(TRUE); }
		
		int Class() { return USCALE_COMMAND; }
		int ID() { return CID_SUBOBJUSCALE; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints=2; return &mouseProc; }
		ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
		BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
		void EnterMode() { ip->SetToolButtonState(USCALE_BUTTON,TRUE); }
		void ExitMode() { ip->SetToolButtonState(USCALE_BUTTON,FALSE); }
	};

class NUScaleModBoxCMode : public CommandMode {
	
	private:
		ChangeFGObject fgProc;
		SubModSelectionProcessor mouseProc;
		ScaleModBox transProc;
		IObjParam *ip;

	public:
		NUScaleModBoxCMode( BaseObject *o, IObjParam *i ) : 
			fgProc(o), transProc(o,i), mouseProc(&transProc,o,i) 
				{ ip = i; mouseProc.SetSupportTransformGizmo(TRUE); }
		
		int Class() { return SCALE_COMMAND; }
		int ID() { return CID_SUBOBJSCALE; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints=2; return &mouseProc; }
		ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
		BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
		void EnterMode() { ip->SetToolButtonState(NUSCALE_BUTTON,TRUE); }
		void ExitMode() { ip->SetToolButtonState(NUSCALE_BUTTON,FALSE); }
	};

class SquashModBoxCMode : public CommandMode {
	
	private:
		ChangeFGObject fgProc;
		SubModSelectionProcessor mouseProc;
		ScaleModBox transProc;
		IObjParam *ip;

	public:
		SquashModBoxCMode( BaseObject *o, IObjParam *i ) : 
			fgProc(o), transProc(o,i), mouseProc(&transProc,o,i) 
				{ ip = i; mouseProc.SetSupportTransformGizmo(TRUE); }
		
		int Class() { return SQUASH_COMMAND; }
		int ID() { return CID_SUBOBJSQUASH; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints=2; return &mouseProc; }
		ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
		BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
		void EnterMode() { ip->SetToolButtonState(SQUASH_BUTTON,TRUE); }
		void ExitMode() { ip->SetToolButtonState(SQUASH_BUTTON,FALSE); }
	};

class SelectModBoxCMode : public CommandMode {
	
	private:
		ChangeFGObject fgProc;
		SubModSelectionProcessor mouseProc;
		SelectModBox transProc;
		IObjParam *ip;

	public:
		SelectModBoxCMode( BaseObject *o, IObjParam *i ) : 
			fgProc(o), transProc(o,i), mouseProc(NULL/*&transProc*/,o,i) 
				{ ip = i; }
		
		int Class() { return SELECT_COMMAND; }
		int ID() { return CID_SUBOBJSELECT; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints=2; return &mouseProc; }
		ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
		BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
		void EnterMode() { ip->SetToolButtonState(SELECT_BUTTON,TRUE); }
		void ExitMode() { ip->SetToolButtonState(SELECT_BUTTON,FALSE); }
	};



///////////////////////////////////////////////////////////////////////////

class TransformCtrlApparatus : public MouseCallBack {
	protected:
		Control *ctrl;
		IObjParam *ip;		
		Matrix3 ptm;

	public:
		CoreExport TransformCtrlApparatus(Control *c, IObjParam *i);
		CoreExport ~TransformCtrlApparatus();

		virtual Transformer& GetTransformer()=0;
		virtual void DoTransform(ViewExp *vpt)=0;
		virtual HCURSOR GetTransformCursor()=0;
		virtual int UndoStringID()=0;

		CoreExport int proc( 
			HWND hwnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m );
	};


class GenControlSelectionProcessor : public SelectionProcessor {
	protected:
		Control *ctrl;
		BOOL transformGizmoActive;

		CoreExport BOOL HitTest( ViewExp *vpt, IPoint2 *p, int type, int flags );
		BOOL AnyHits( ViewExp *vpt ) { return vpt->NumSubObjHits(); }		
		CoreExport void Select(ViewExp *vpt,BOOL all,BOOL clear,BOOL invert);
		CoreExport void DeSelect(ViewExp *vpt,BOOL all);
		CoreExport void ClearSelection();
		void CloneSelected(int initialCall=TRUE) {};
		void AbortClone() {};
		void AcceptClone() {};

	public:
		GenControlSelectionProcessor(MouseCallBack *mc,Control *c,IObjParam *i) 
			: SelectionProcessor(mc,i) {ctrl=c; transformGizmoActive=FALSE; }
	};

class SubControlSelectionProcessor : public GenControlSelectionProcessor {
	private:		
		TransformCtrlApparatus *tproc;
		BOOL supportTransformGizmo;

	protected:
		HCURSOR GetTransformCursor() { return tproc->GetTransformCursor(); }
		
	public:
		SubControlSelectionProcessor(TransformCtrlApparatus *tc,Control *c,IObjParam *i) 
			: GenControlSelectionProcessor(tc,c,i) { 
				tproc = tc; supportTransformGizmo=FALSE; }

		// Transform Gizmo Interface
		BOOL SupportTransformGizmo() { return supportTransformGizmo; }
		void DeactivateTransformGizmo() {
			if (transformGizmoActive) {
				ip->DeactivateTransformGizmo();
				transformGizmoActive = FALSE;
				}
			}
		// End of Transform Gizmo Interface
		// Private gizmo stuff
		void SetSupportTransformGizmo(BOOL b) { supportTransformGizmo = b; }

	};


class MoveCtrlApparatus : public TransformCtrlApparatus {
	private:
		MoveTransformer moveTrans;
	public:
		MoveCtrlApparatus(Control *c, IObjParam *i) : moveTrans(i,TRUE), TransformCtrlApparatus(c,i) {}
		Transformer& GetTransformer() { return moveTrans; }
		CoreExport void DoTransform(ViewExp *vpt);
		HCURSOR GetTransformCursor() { return ip->GetSysCursor(SYSCUR_MOVE); }
		CoreExport int UndoStringID();
		};
class RotateCtrlApparatus : public TransformCtrlApparatus {
	private:
		RotateTransformer rotTrans;
	public:
		RotateCtrlApparatus(Control *c, IObjParam *i) : rotTrans(i), TransformCtrlApparatus(c,i) {}
		Transformer& GetTransformer() { return rotTrans; }
		CoreExport void DoTransform(ViewExp *vpt);
		HCURSOR GetTransformCursor() { return ip->GetSysCursor(SYSCUR_ROTATE); }
		CoreExport int UndoStringID();
		};
class ScaleCtrlApparatus : public TransformCtrlApparatus {
	private:
		ScaleTransformer scaleTrans;
	public:
		ScaleCtrlApparatus(Control *c, IObjParam *i) : scaleTrans(i), TransformCtrlApparatus(c,i) {}
		Transformer& GetTransformer() { return scaleTrans; }
		CoreExport void DoTransform(ViewExp *vpt);
		CoreExport HCURSOR GetTransformCursor();
		CoreExport int UndoStringID();
		};
class SelectCtrlApparatus : public TransformCtrlApparatus {
	private:
		MoveTransformer moveTrans;
	public:
		SelectCtrlApparatus(Control *c, IObjParam *i) : moveTrans(i), TransformCtrlApparatus(c,i) {}
		Transformer& GetTransformer() { return moveTrans; }
		void DoTransform(ViewExp *vpt) {}
		HCURSOR GetTransformCursor() { return ip->GetSysCursor(SYSCUR_SELECT); }
		CoreExport int UndoStringID();
		};


class MoveCtrlApparatusCMode : public CommandMode {
	
	private:
		ChangeFGObject fgProc;
		SubControlSelectionProcessor mouseProc;
		MoveCtrlApparatus transProc;
		IObjParam *ip;

	public:
		MoveCtrlApparatusCMode( Control *c, IObjParam *i ) : 
			fgProc(c), transProc(c,i), mouseProc(&transProc,c,i) 
				{ ip = i; mouseProc.SetSupportTransformGizmo(TRUE); }
		
		int Class() { return MOVE_COMMAND; }
		int ID() { return CID_SUBOBJMOVE; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints=2; return &mouseProc; }
		ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
		BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
		void EnterMode() { ip->SetToolButtonState(MOVE_BUTTON,TRUE); }
		void ExitMode() { ip->SetToolButtonState(MOVE_BUTTON,FALSE); }
	};

class RotateCtrlApparatusCMode : public CommandMode {
	
	private:
		ChangeFGObject fgProc;
		SubControlSelectionProcessor mouseProc;
		RotateCtrlApparatus transProc;
		IObjParam *ip;

	public:
		RotateCtrlApparatusCMode( Control *c, IObjParam *i ) : 
			fgProc(c), transProc(c,i), mouseProc(&transProc,c,i) 
				{ ip = i; mouseProc.SetSupportTransformGizmo(TRUE); }
		
		int Class() { return ROTATE_COMMAND; }
		int ID() { return CID_SUBOBJROTATE; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints=2; return &mouseProc; }
		ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
		BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
		void EnterMode() { ip->SetToolButtonState(ROTATE_BUTTON,TRUE); }
		void ExitMode() { ip->SetToolButtonState(ROTATE_BUTTON,FALSE); }
	};

class UScaleCtrlApparatusCMode : public CommandMode {
	
	private:
		ChangeFGObject fgProc;
		SubControlSelectionProcessor mouseProc;
		ScaleCtrlApparatus transProc;
		IObjParam *ip;

	public:
		UScaleCtrlApparatusCMode( Control *c, IObjParam *i ) : 
			fgProc(c), transProc(c,i), mouseProc(&transProc,c,i) 
				{ ip = i; mouseProc.SetSupportTransformGizmo(TRUE); }
		
		int Class() { return USCALE_COMMAND; }
		int ID() { return CID_SUBOBJUSCALE; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints=2; return &mouseProc; }
		ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
		BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
		void EnterMode() { ip->SetToolButtonState(USCALE_BUTTON,TRUE); }
		void ExitMode() { ip->SetToolButtonState(USCALE_BUTTON,FALSE); }
	};

class NUScaleCtrlApparatusCMode : public CommandMode {
	
	private:
		ChangeFGObject fgProc;
		SubControlSelectionProcessor mouseProc;
		ScaleCtrlApparatus transProc;
		IObjParam *ip;

	public:
		NUScaleCtrlApparatusCMode( Control *c, IObjParam *i ) : 
			fgProc(c), transProc(c,i), mouseProc(&transProc,c,i) 
				{ ip = i; mouseProc.SetSupportTransformGizmo(TRUE); }
		
		int Class() { return SCALE_COMMAND; }
		int ID() { return CID_SUBOBJSCALE; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints=2; return &mouseProc; }
		ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
		BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
		void EnterMode() { ip->SetToolButtonState(NUSCALE_BUTTON,TRUE); }
		void ExitMode() { ip->SetToolButtonState(NUSCALE_BUTTON,FALSE); }
	};

class SquashCtrlApparatusCMode : public CommandMode {
	
	private:
		ChangeFGObject fgProc;
		SubControlSelectionProcessor mouseProc;
		ScaleCtrlApparatus transProc;
		IObjParam *ip;

	public:
		SquashCtrlApparatusCMode( Control *c, IObjParam *i ) : 
			fgProc(c), transProc(c,i), mouseProc(&transProc,c,i) 
				{ ip = i; mouseProc.SetSupportTransformGizmo(TRUE); }
		
		int Class() { return SQUASH_COMMAND; }
		int ID() { return CID_SUBOBJSQUASH; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints=2; return &mouseProc; }
		ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
		BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
		void EnterMode() { ip->SetToolButtonState(SQUASH_BUTTON,TRUE); }
		void ExitMode() { ip->SetToolButtonState(SQUASH_BUTTON,FALSE); }
	};

class SelectCtrlApparatusCMode : public CommandMode {
	
	private:
		ChangeFGObject fgProc;
		SubControlSelectionProcessor mouseProc;
		SelectCtrlApparatus transProc;
		IObjParam *ip;

	public:
		SelectCtrlApparatusCMode( Control *c, IObjParam *i ) :
			fgProc(c), transProc(c,i), mouseProc(NULL,c,i) 
				{ ip = i; }
		
		int Class() { return SELECT_COMMAND; }
		int ID() { return CID_SUBOBJSELECT; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints=2; return &mouseProc; }
		ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
		BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
		void EnterMode() { ip->SetToolButtonState(SELECT_BUTTON,TRUE); }
		void ExitMode() { ip->SetToolButtonState(SELECT_BUTTON,FALSE); }
	};



#define MOVE_INTERSECTION	1
#define MOVE_PROJECTION		2

float CoreExport GetPerspMouseSpeed();
void CoreExport SetPerspMouseSpeed(float speed);

void CoreExport SetMoveModeType(int moveType);
int CoreExport GetMoveModeType();

void CoreExport SetRotationIncrement(float inc);
float CoreExport GetRotationIncrement();

#endif __OBJMODE__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Osnapapi.h ===
/*****************************************************************************
 *<
	FILE: osnapapi.h

	DESCRIPTION:  Master include file for implementing osnaps

	CREATED BY: John Hutchinson		

	HISTORY: created 5/17/97

 *>	Copyright (c) 1994, All Rights Reserved.
 *****************************************************************************/

#ifndef _SNAPAPI_H
#define _SNAPAPI_H

#include "omanapi.h"
#include "osnap.h"
#include "osnapmk.h"
#include "osnaphit.h"

#endif //_SNAPAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Osnap.h ===
/**********************************************************************
 *<
	FILE: osnap.h

	DESCRIPTION:  Classes for Osnaps

	CREATED BY: John Hutchinson

	HISTORY: December 9, 1996
 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef _OSNAP_H_
#define _OSNAP_H_

#include "tab.h"
#define RESET 0
#define NEXT 1
#define ICON_WIDTH 32

#define HILITE_NORMAL	(1<<0)
#define HILITE_BOX		(1<<1)
#define HILITE_NODE		(1<<2)//Not implemented
#define HILITE_CROSSHAIR (1<<3)

#define OSNAP_STATE	_T("ObjectSnapPluginState")

//Some types
class Candidate
{
public:
	Candidate(){};
	Candidate(Point3* p, int s, int num=0, ...);
	void SetMeshPoint(int which, const Point3 p);
	~Candidate();
	Point3 *pt;
	int type;
	int count;
	Point3 *meshverts;
};

//typedef Tab<Point3> Point3Tab;
typedef Tab<Candidate *> CandidateTab;
typedef	void (*SnapCallback) (Object* pobj, IPoint2 *p) ;

class OsnapMarker; 
class HitMesh;
class IOsnapManager;

//The osnap class
//===========================================================================

class Osnap {
	friend class OsnapHit;
	friend class OsnapManager;

protected:
	BOOL *m_active;
	DllExport void _Snap(INode* inode, TimeValue t, ViewExp *vpt, IPoint2 *p, SnapInfo *snap);
	DllExport Point3 _ReEvaluate(TimeValue t, OsnapHit *hit);
	DllExport boolean IsActive();
	DllExport void SetActive(int index, boolean state);
	DllExport boolean GetActive(int index);

	GraphicsWindow *m_hitgw;

	//Point management.
	//Some osnaps may want to maintain a list of potential hit points. 
	//Note that the points should be passed in in modeling space
	DllExport void AddCandidate(Point3 *pt, int type = -1, int num = 0,...);
	DllExport Point3 *GetCandidatePoint(int index);
	DllExport void GetCandidateMesh(int index, HitMesh *m);
	DllExport int GetCandidateType(int index);
//	DllExport void AddCandidate(Point3 *pt);
	DllExport void ClearCandidates();
	DllExport int NumCandidates(){return point_candidates.Count();}
	virtual DllExport Point3 ReEvaluate(TimeValue t, OsnapHit *hit, Object* pobj);

	//Note: the following version uses an index into the candidate list
	DllExport BOOL CheckPotentialHit(int ptindex, Point2 cursor);
	//Note: the following version uses a remote matrix of points
	DllExport BOOL CheckPotentialHit(Point3 *p, int ptindex, Point2 cursor);
	int m_baseindex;//an index into the tool array

public:

	DllExport Osnap();//constructor
	DllExport virtual ~Osnap();
	DllExport void Init();

	virtual int numsubs(){return 1;}; //the number of subsnaps this guy has
	virtual DllExport TCHAR *Category();//JH 01/04/98 {return NULL;}
	virtual Class_ID ClassID() { return Class_ID( 0, 0); }
	virtual BOOL UseCallbacks(){return FALSE;}
	virtual int NumCallbacks(){return 0;}
	virtual DllExport BOOL GetSupportedObject(INode *iNode, TimeValue t, ObjectState *os);

	virtual TSTR *snapname(int index)=0; // the snaps name to be displayed in the UI
	virtual TSTR *tooltip(int index){return NULL;} // the snaps name to be displayed in the UI
	virtual boolean ValidInput(SClass_ID scid, Class_ID cid)=0;//the objects it supports 
	virtual OsnapMarker *GetMarker(int index)=0; // single object might contain subsnaps
	virtual WORD HiliteMode(){return HILITE_NORMAL;}
	// UI methods
	virtual boolean BeginUI(HWND hwnd){return TRUE;}
	virtual void EndUI(HWND hwnd){};
	virtual HBITMAP getTools()=0;
	virtual HBITMAP getMasks()=0;
	virtual void Snap(Object* pobj, IPoint2 *p, TimeValue t){};
	virtual BOOL HitTest(Object* pobj, IPoint2 *p, TimeValue t){return TRUE;}
	virtual SnapCallback GetSnapCallback( int sub){ return NULL;}
	virtual WORD AccelKey(int index)=0;


protected://data
	IOsnapManager *theman;
//	Point3Tab point_candidates; //this will hold the point candidates
  	CandidateTab point_candidates; //this will hold the point candidates

public://data
//	INode *m_inode;
//	ViewExp *m_vpt;

};






#endif // _OSNAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\partclib.h ===
#ifndef _PARTICLELIB_H_

#define _PARTICLELIB_H_

#define IMPORTING
#include "particle.h"
#undef IMPORTING

#endif // _PARTICLELIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Osnapdlg.h ===
/**********************************************************************
 *<
	FILE: OsnapDlg.h

	DESCRIPTION: Declares class for the Osnap Dialog

	CREATED BY:	John Hutchinson

	HISTORY: January 11  '97

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/


#ifndef __OSNAPDLG__
#define __OSNAPDLG__
#include "tabdlg.h"

// The dimensions of the vertical toolbar that gets constructed for the UI
#define CHECKBAR_WIDTH 225//230
#define CHECKBAR_HEIGHT 130//150//113
#define CHECKBAR_HOFFSET 5
#define CHECKBAR_VOFFSET 30

class OsnapDlg : public TabbedDialog {
	public:
		HWND	hSnapCat;
		static int curCat;
		OsnapManager *theMan;
		BOOL valid, spinDown, block;
		HWND hWnd;
		IVertToolbar *iCheckbar;
		int	DoDialog(int page);

		ISpinnerControl *iAbs[3], *iRel[3], *iDolly, *iRoll;
		
		static int winX, winY;

		OsnapDlg(HWND appWnd,HINSTANCE hInst);
		~OsnapDlg();

		void Invalidate();
		void Update();
		void Init(HWND hWnd);
		void ChangeCat(int cat);


		void WMCommand(int id, int notify, HWND hCtrl);
		void WMSize(int how);

	};


void ShowOsnapDlg(HWND hWnd,HINSTANCE hInst,int page=0);
void HideOsnapDlg();

class OsnapOffset {
public:
	OsnapOffset(HWND HWnd, HINSTANCE hInst);
	~OsnapOffset();

	void Init(HWND dWnd);
	void Update();
	void OnCommand(int id);
	void OnSpinnerChange(int id);
	
private:
	ISpinnerControl *iAbs[3], *iRel[3];
	Point3 refpoint, pAbs, pRel;
	OsnapManager *theman;
	HWND hWnd;

};

extern void OffsetOsnap(HWND hWnd, HINSTANCE hInst);
#endif //__OSNAPDLG__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Osnapmk.h ===
/**********************************************************************
 *<
	FILE: osnapmk.h

	DESCRIPTION:  A Class for an osnapmarker

	CREATED BY: John Hutchinson

	HISTORY: Feb 12, 1996
 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef _OSNAP_MARK_H_
#define _OSNAP_MARK_H_

class OsnapMarker 
{
private:
	int m_numpoints;
	IPoint3 *m_ppt;
	IPoint3 *m_pcache;
	IPoint3 m_cache_trans;
	int m_cache_size;
	int *m_edgevis;
	boolean IsCacheValid(IPoint3 trans, int size);
	void UpdateCache(IPoint3 trans, int size);

public:
	CoreExport OsnapMarker();
	CoreExport ~OsnapMarker();
	CoreExport OsnapMarker(int n, IPoint3 *ppt, int *pes);
	CoreExport OsnapMarker(const OsnapMarker& om);
	CoreExport OsnapMarker& operator=(const OsnapMarker& om);
	void display(IPoint3 xyz, int markersize, GraphicsWindow *gw);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\palutil.h ===
/*******************************************************************
 *
 *    DESCRIPTION: PALUTIL.H
 *
 *    AUTHOR: D.Silva
 *
 *    HISTORY:    
 *
 *******************************************************************/

#ifndef PALUTIL_H_DEFINED
#define PALUTIL_H_DEFINED

//-- 256 color dithering-----------------------------------------------------
// For packing colors into 256 color paletted representation.
// Create one with BMMNewColorPacker
class ColorPacker {
   public:
      virtual void EnableDither(BOOL onoff)=0;  // default: MAX default
      virtual void PropogateErrorBetweenLines(BOOL onoff)=0;  // default ON; 
      virtual void PackLine( BMM_Color_64* in, BYTE *out, int w)=0;
      virtual void PackLine( BMM_Color_48* in, BYTE *out, int w)=0;
      virtual void DeleteThis()=0;
   };

// Get a color packer.  When done, be sure to call its DeleteThis();
UtilExport ColorPacker *NewColorPacker(
   int w,            // width of bitmap to be packed
   BMM_Color_48 *pal,   // palette to use
   int npal,         // number of entries in the palette
   BYTE* remap=NULL, // optional remap done at last stage.
   BOOL dither = FALSE
   );

//---------------------------------------------------------------------
// Color quantizer, for doing true-color to paletted conversion
//
class Quantizer {
   public:
      virtual int AllocHistogram(void)=0;
      virtual int Partition(BMM_Color_48 *pal, int palsize, BMM_Color_64 *forceCol)=0;
      virtual void AddToHistogram(BMM_Color_64 *image, int npix)=0;  
      virtual void AddToHistogram(BMM_Color_48 *image, int npix)=0;  
      virtual void AddToHistogram(BMM_Color_24 *image, int npix)=0;  
      virtual void DeleteThis()=0;
   };

UtilExport Quantizer *NewQuantizer();

#endif // PALUTIL_H_DEFINED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Osnaphit.h ===
/**********************************************************************
 	FILE: osnaphit.h

	DESCRIPTION:  Defines the classes which are passed from the osnaps
					to the manager.

	CREATED BY: John Hutchinson
	HISTORY: December 9, 1996
	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#ifndef _OSNAPHIT_H_
#define _OSNAPHIT_H_

class Osnap;
class HitMesh;
class OsnapMarker;

class OsnapHit
{
	friend class OsnapManager;
	friend class Osnap;
	friend class TypedHit;
public:
	CoreExport OsnapHit(Point3 p3, Osnap* s, int sub, HitMesh *m);
	CoreExport OsnapHit(Point3 pt);
	CoreExport OsnapHit(const OsnapHit& h);
	virtual CoreExport OsnapHit& operator=(const OsnapHit& h);
	virtual CoreExport ~OsnapHit();
	virtual CoreExport OsnapHit* clone();

	void setscreendata(IPoint3 screen3, int len);

	//////////////////////////////////////////////////////////////////////
	// Display Methods
	//////////////////////////////////////////////////////////////////////
	CoreExport virtual boolean display(ViewExp *vpt, TimeValue t, Point3 color,  \
		int markersize, boolean markers = TRUE, boolean hilite = TRUE);
	CoreExport void erase(ViewExp *vpt, TimeValue t) const; // the hit can erase itself
	CoreExport void GetViewportRect(TimeValue t,ViewExp *vpt,Rect *rect, int marksize)const;

	//////////////////////////////////////////////////////////////////////
	// Accessor Methods
	//////////////////////////////////////////////////////////////////////
	CoreExport Point3 GetHitpoint(){return hitpoint;};
	CoreExport Point3 GetWorldHitpoint(){return worldpoint;};
	CoreExport IPoint3 GetHitscreen(){return m_hitscreen;};
	CoreExport int GetSubsnap(){return subsnap;}
	CoreExport POINT GetCursor(){return m_cursor;}
	INode *GetNode(){return node;}
	void Dump()const;

	//////////////////////////////////////////////////////////////////////
	// Operator Methods
	//////////////////////////////////////////////////////////////////////
	//define comparators so we can sort a list of these
	CoreExport BOOL operator<(OsnapHit& hit);
	CoreExport BOOL operator>(OsnapHit& hit);

public:
	void Update(TimeValue t);
	CoreExport Point3 ReEvaluate(TimeValue t);
	virtual bool IsWorldSpaceHit(){return false;}


private: //data
	Point3 hitpoint; // the hit location in object space
	Point3 worldpoint; // the hit location in world space
	IPoint3 m_hitscreen; // the hit location in screen space
	POINT m_cursor;//the position of the cursor when this guy was recorded
	int m_len; //The distace from the cursor
	int m_z_depth; //The depth in z space
	BOOL m_complete; //indicates whether the screendata has been set
	Osnap*  snap; //the snap which made this hit
	int subsnap; //the subsnap index that made this hit
	OsnapMarker *m_pmarker; //a pointer to this snaps marker

	INode* node;// the node which got hit
	HitMesh *hitmesh;//a mesh used to hilite the topolgy we hit

	ViewExp *m_vpt;//the viewport which was active

	BOOL m_invisible;//this guy won't display itself
};

//a class to hold a list of object space points for highlighting the geometry
class HitMesh 
{
private:
	int m_numverts;
	Point3 *m_pverts;
	static long m_cref;
public:
	CoreExport HitMesh();
	CoreExport ~HitMesh();
	CoreExport HitMesh(const HitMesh& h);
	CoreExport HitMesh(int n);
	Point3 operator[](int i){return m_pverts[i];}
	int getNumVerts(){return m_numverts;}
	void setNumVerts(int n){
		if(m_pverts != NULL)
			delete [] m_pverts;
		m_numverts = n;
		m_pverts = new Point3[n];
	}
	void setVert(int i, const Point3 &xyz){ m_pverts[i] = xyz; }	
	Point3& getVert(int i){return m_pverts[i];}
	Point3* getVertPtr(){return m_pverts;}
};


class TypedHit: public OsnapHit
{
public:
	TypedHit(Point3 pt);
	virtual boolean display(ViewExp *vpt, TimeValue t, Point3 color,  \
		int markersize, boolean markers = TRUE, boolean hilite = TRUE);
	virtual bool IsWorldSpaceHit(){return true;}
};
#endif //_OSNAPHIT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\patchcap.h ===
/**********************************************************************
 *<
	FILE: patchcap.h

	DESCRIPTION:  Patch Capping header file

	CREATED BY: Tom Hudson

	HISTORY: created 21 December, 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#ifndef __PATCHCAP_H__

#define __PATCHCAP_H__

// This uses the linked-list class templates
#include "linklist.h"

class PatchSeg {
	public:
		int vert;
		int vec1;
		int vec2;
		PatchSeg() {}
		PatchSeg(int v, int v1, int v2) { vert=v; vec1=v1; vec2=v2; }
	};

MakeLinkedList(PatchSeg);	// Creates PatchSegList
MakeLinkedList(PatchSegList);	// Creates PatchSegListList

MakeLinkedList(Patch);		// Creates PatchList
MakeLinkedList(PatchVert);	// Creates PatchVertList
MakeLinkedList(PatchVec);	// Creates PatchVecList

class PatchCapWork {
	public:
		PatchSegListList plist;
		PatchVertList newVerts;
		PatchVecList newVecs;
		PatchList newPatches;
		CoreExport void Dump(char *title = NULL);
	};

#endif // __PATCHCAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\patchlib.h ===
#ifndef _PATCHLIB_H_

#define _PATCHLIB_H_

//#define IMPORTING
#include "patch.h"
//#undef IMPORTING

#endif // _PATCHLIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\particle.h ===
/**********************************************************************
 *<
	FILE: particle.h

	DESCRIPTION: Particle system object

	CREATED BY: Rolf Berteig

	HISTORY: 10-18-95

 *> Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __PARTICLE__
#define __PARTICLE__

#include "meshlib.h"
#include "export.h"

class ParticleSys;

// Custom particle drawing callback
class CustomParticleDisplay {
	public:
		virtual BOOL DrawParticle(GraphicsWindow *gw,ParticleSys &parts,int i)=0;
	};

class ParticleSys {
	private:
		CustomParticleDisplay *draw;

		void DrawGW(GraphicsWindow *gw,DWORD flags,MarkerType type);

	public:
		Tab<Point3>	points;		// The particles themselves
		Tab<Point3> vels;		// Velocities of each particle (optional)
		Tab<TimeValue> ages;	// Age of each particle (optional)
		Tab<float> radius;
		Tab<float> tension;
		float size;				// World space radius of a particle


		// Draws the particle system into the GW
		DllExport void Render(GraphicsWindow *gw,MarkerType type=POINT_MRKR);
		
		// Hit tests the particle system. Returns TRUE if a particle is hit.
		DllExport BOOL HitTest(GraphicsWindow *gw, HitRegion *hr, 
			int abortOnHit=FALSE,MarkerType type=POINT_MRKR);

		// Gets bounding box
		DllExport Box3 BoundBox(Matrix3 *tm=NULL);

		// Sets all counts to 0
		DllExport void FreeAll();

		// Sets the size. Flags indicate if optional params should be allocated
		DllExport void SetCount(int c,DWORD flags);

		int Count() {return points.Count();}
		Point3& operator[](int i) {return points[i];}

		// Is particle i alive?
		BOOL Alive(int i) {return ages[i]>=0;}

		// Sets custom draw callback
		void SetCustomDraw(CustomParticleDisplay *d) {draw=d;}
	};

// Flags for SetCount()
#define PARTICLE_VELS	(1<<0)
#define PARTICLE_AGES	(1<<1)
#define PARTICLE_RADIUS	(1<<2)
#define PARTICLE_TENSION (1<<3)

class MetaParticle {
	public:
		DllExport int CreateMetas(ParticleSys parts,Mesh *mesh,float threshold,float res,float strength,int many=1);
};
#endif  // __PARTICLE__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\patch.h ===
/**********************************************************************
 *<
	FILE: patch.h

	DESCRIPTION: Main include file for bezier patches

	CREATED BY: Tom Hudson

	HISTORY: Created June 21, 1995
			 June 17, 1997 TH -- Added second texture mapping channel
			 12-10-98 Peter Watje added hide interior edge support and hidding patches
			 12-31-98 Peter Watje added hook patches, patch extrusion and bevels

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#ifndef _PATCH_H_

#define _PATCH_H_

#include "coreexp.h"
#include "meshlib.h"
#include <hitdata.h>
#include "maxtess.h"

// Uncomment the following to check for missed triangular patch 'aux' computation
//#define CHECK_TRI_PATCH_AUX

// Handy-dandy integer table class
typedef Tab<int> IntTab;

// Value for undefined patches and vertices
#define PATCH_UNDEFINED -1

// TH 5/17/99 -- Commented out MULTI_PROCESSING, it wasn't being used and was causing
// am obscure memory leak (Defect 180889)
//#define MULTI_PROCESSING	TRUE		// TRUE turns on mp vertex transformation

class HookPoint 
	{
public:
	int upperPoint, lowerPoint;
	int upperVec,lowerVec;
	int upperHookVec, lowerHookVec;
	int hookPoint;
	int upperPatch, lowerPatch, hookPatch;
	int hookEdge, upperEdge, lowerEdge;
	};

class ExtrudeData
{
public:
	int u,l,uvec,lvec;
//3-10-99 watje
	Point3 edge;
	Point3 bevelDir;
};

class ISave;
class ILoad;
class PatchMesh;

#define NEWPATCH

// PRVertex flags: contain clip flags, number of normals at the vertex
// and the number of normals that have already been rendered.
// fine PLANE_MASK	0x00003f00UL -- now in gfx.h
#define NORCT_MASK			0x000000ffUL
#define SPECIFIED_NORMAL	0x00004000UL
#define OUT_LEFT			0x00010000UL
#define OUT_RIGHT			0x00020000UL
#define OUT_TOP				0x00040000UL
#define OUT_BOTTOM			0x00080000UL
#define RECT_MASK			0x000f0000UL
#define RND_MASK			0xfff00000UL
#define RND_NOR0			0x00100000UL
#define RND_NOR(n)  		(RND_NOR0 << (n))

class PRVertex {
	public:
		PRVertex()	{ rFlags = 0; /*ern = NULL;*/ }
		CoreExport ~PRVertex();	

		DWORD		rFlags;     
		int			pos[3];	
	};					  

// Patch vector flags
#define PVEC_INTERIOR	(1<<0)

// Patch vectors

class PatchVec {
	public:
		Point3 p;			// Location
		int vert;			// Vertex which owns this vector
		int patches[2];		// Patches using this vector
		DWORD flags;
		int aux1;			// Used to track topo changes during editing (Edit Patch)
		int aux2;			// Used to track topo changes during editing (PatchMesh)
		CoreExport PatchVec();
		CoreExport PatchVec(PatchVec &from);
		void ResetData() { vert = patches[0] = patches[1] = PATCH_UNDEFINED; }
		CoreExport BOOL AddPatch(int index);
		CoreExport PatchVec& operator=(PatchVec& from);
		void Transform(Matrix3 &tm) { p = p * tm; }

		CoreExport IOResult Save(ISave* isave);
		CoreExport IOResult Load(ILoad* iload);
	};

// Patch vertex flags
#define PVERT_COPLANAR (1<<0)
#define PVERT_CORNER (0)
#define PVERT_TYPE_MASK 0xfffffffe
//watje 12-10-98
#define PVERT_HIDDEN		(1<<1)

// Patch vertex

class PatchVert {
	public:
		Point3 p;			// Location
		IntTab vectors;		// List of vectors attached to this vertex
		IntTab patches;		// List of patches using this vertex
		DWORD flags;
		int aux1;			// Used to track topo changes during editing (Edit Patch)
		int aux2;			// Used to track topo changes during editing (PatchMesh)
		CoreExport PatchVert();
		CoreExport PatchVert(PatchVert &from);
		~PatchVert() { ResetData(); }
		CoreExport PatchVert& operator=(PatchVert& from);
		void ResetData() { vectors.Delete(0,vectors.Count()); patches.Delete(0,patches.Count()); }
		CoreExport int FindVector(int index);
		CoreExport void AddVector(int index);
		CoreExport void DeleteVector(int index);
		CoreExport int FindPatch(int index);
		CoreExport void AddPatch(int index);
		CoreExport void DeletePatch(int index);
		void Transform(Matrix3 &tm) { p = p * tm; }

//watje  12-10-98
		CoreExport void SetHidden(BOOL sw = TRUE)
			{
			if(sw)
				flags |= PVERT_HIDDEN;
			else
				flags &= ~PVERT_HIDDEN;
			}
//watje  12-10-98
		BOOL IsHidden() { return (flags & PVERT_HIDDEN) ? TRUE : FALSE; }

		CoreExport IOResult Save(ISave* isave);
		CoreExport IOResult Load(ILoad* iload);
	};

class PatchEdge {
	public:
		int v1;		// Index of first vertex
		int vec12;	// Vector from v1 to v2
		int vec21;	// Vector from v2 to v1
		int v2;		// Index of second vertex
		int patch1;	// Index of first patch
		int patch2;	// Index of second patch
		int aux1;	// Used to track topo changes during editing (Edit Patch)
		int aux2;	// Used to track topo changes during editing (PatchMesh)
		CoreExport PatchEdge();
		CoreExport PatchEdge(PatchEdge &from);
		CoreExport PatchEdge(int v1, int vec12, int vec21, int v2, int p1, int p2, int aux1=-1, int aux2=-1);
		// Dump the patch edge structure via DebugPrints
		CoreExport void Dump();
	};

// Patch types

#define PATCH_UNDEF	0	// Undefined (watch out!)
#define PATCH_TRI	3	// Triangular patch
#define PATCH_QUAD	4	// Quadrilateral patch

// Patch Flags:
#define PATCH_AUTO			(1<<0)	// Interior verts computed automatically if set
#define PATCH_MANUAL		(0)		// Interior verts stored in 'interior' array
#define PATCH_INTERIOR_MASK 0xfffffffe
//watje 12-10-98
#define PATCH_HIDDEN		(1<<1)  //patch is hidden


// The mat ID is stored in the HIWORD of the patch flags
#define PATCH_MATID_SHIFT	16
#define PATCH_MATID_MASK	0xFFFF

class Patch {	
	public:
		int type;			// See types, above
		int	v[4];			// Can have three or four vertices
		int	vec[8];			// Can have six or eight vector points
		int	interior[4];	// Can have one or four interior vertices
		Point3 aux[9];		// Used for triangular patches only -- Degree 4 control points
		int	adjacent[4];	// Adjacent patches -- Can have three or four
		int	edge[4];		// Pointers into edge list -- Can have three or four
		DWORD	smGroup;	// Defaults to 1 -- All patches smoothed in a PatchMesh
		DWORD	flags;		// See flags, above
		int aux1;			// Used to track topo changes during editing (Edit Patch)
		int aux2;			// Used to track topo changes during editing (PatchMesh)

#ifdef CHECK_TRI_PATCH_AUX
		Point3 auxSource[9];
		CoreExport void CheckTriAux(PatchMesh *pMesh);
#endif //CHECK_TRI_PATCH_AUX

		CoreExport Patch();	// WARNING: This does not allocate arrays -- Use SetType(type) or Patch(type)
		CoreExport Patch(int type);
		CoreExport Patch(Patch& fromPatch);
		CoreExport ~Patch();
		CoreExport void Init();
		void	setVerts(int *vrt) { memcpy(v, vrt, type * sizeof(int)); }
		void	setVerts(int a, int b, int c)  { assert(type == PATCH_TRI); v[0]=a; v[1]=b; v[2]=c; }
		void	setVerts(int a, int b, int c, int d)  { assert(type == PATCH_QUAD); v[0]=a; v[1]=b; v[2]=c; v[3]=d; }
		void	setVecs(int ab, int ba, int bc, int cb, int ca, int ac) {
			assert(type == PATCH_TRI);
			vec[0]=ab; vec[1]=ba; vec[2]=bc; vec[3]=cb; vec[4]=ca; vec[5]=ac;
			}
		void	setVecs(int ab, int ba, int bc, int cb, int cd, int dc, int da, int ad) {
			assert(type == PATCH_QUAD);
			vec[0]=ab; vec[1]=ba; vec[2]=bc; vec[3]=cb; vec[4]=cd; vec[5]=dc; vec[6]=da, vec[7]=ad;
			}
		void	setInteriors(int a, int b, int c) {
			assert(type == PATCH_TRI);
			interior[0]=a; interior[1]=b; interior[2]=c;
			}
		void	setInteriors(int a, int b, int c, int d) {
			assert(type == PATCH_QUAD);
			interior[0]=a; interior[1]=b; interior[2]=c; interior[3]=d;
			}
		int		getVert(int index)	{ return v[index]; }
		int *	getAllVerts(void)	{ return v; }
		MtlID	getMatID() {return (int)((flags>>FACE_MATID_SHIFT)&FACE_MATID_MASK);}
		void    setMatID(MtlID id) {flags &= 0xFFFF; flags |= (DWORD)(id<<FACE_MATID_SHIFT);}
		CoreExport Point3 interp(PatchMesh *pMesh, float u, float v);			// Quadrilateral
		CoreExport Point3 interp(PatchMesh *pMesh, float u, float v, float w);	// Triangle
		CoreExport void ComputeAux(PatchMesh *pMesh, int index);
		CoreExport void ComputeAux(PatchMesh *pMesh);	// Do all degree-4 points
		CoreExport void computeInteriors(PatchMesh* pMesh);
		CoreExport void SetType(int type, BOOL init = FALSE);
		CoreExport Patch& operator=(Patch& from);
		CoreExport void SetAuto(BOOL sw = TRUE);
		BOOL IsAuto() { return (flags & PATCH_AUTO) ? TRUE : FALSE; }

//watje 12-10-98
		CoreExport void SetHidden(BOOL sw = TRUE);
//watje 12-10-98
		BOOL IsHidden() { return (flags & PATCH_HIDDEN) ? TRUE : FALSE; }


		// Dump the patch mesh structure via DebugPrints

		CoreExport void Dump();

		CoreExport IOResult Save(ISave* isave);
		CoreExport IOResult Load(ILoad* iload);
	};

// Separate class for patch texture verts
class TVPatch {	
	public:
		int	tv[4];			// Texture verts (always 4 here, even for tri patches)
		CoreExport TVPatch();
		CoreExport TVPatch(TVPatch& fromPatch);
		CoreExport void Init();
		CoreExport void setTVerts(int *vrt, int count);
		CoreExport void setTVerts(int a, int b, int c, int d = 0);
		int		getTVert(int index)	{ return tv[index]; }
		int *	getAllTVerts(void)	{ return tv; }
		CoreExport TVPatch& operator=(const TVPatch& from);

		CoreExport IOResult Save(ISave* isave);
		CoreExport IOResult Load(ILoad* iload);
	};


// Flag definitions
#define COMP_TRANSFORM	0x0001	// forces recalc of model->screen transform; else will attempt to use cache
#define COMP_IGN_RECT	0x0002	// forces all polys to be rendered; else only those intersecting the box will be
#define COMP_LIGHTING	0x0004	// forces re-lighting of all verts (as when a light moves); else only relight moved verts

#define COMP_ALL		0x00ff

// If this bit is set then the node being displayed by this mesh is selected.
// Certain display flags only activate when this bit is set.
#define COMP_OBJSELECTED	(1<<8)
#define COMP_OBJFROZEN		(1<<9)

typedef int (*INTRFUNC)();

CoreExport void setPatchIntrFunc(INTRFUNC fn);

// Special types for patch vertex hits -- Allows us to distinguish what they hit on a pick
#define PATCH_HIT_PATCH		0
#define PATCH_HIT_EDGE		1
#define PATCH_HIT_VERTEX	2
#define PATCH_HIT_VECTOR	3
#define PATCH_HIT_INTERIOR	4

class PatchSubHitRec {
	private:		
		PatchSubHitRec *next;
	public:
		DWORD	dist;
		PatchMesh *patch;
		int		index;
		int		type;

		PatchSubHitRec( DWORD dist, PatchMesh *patch, int index, int type, PatchSubHitRec *next ) 
			{ this->dist = dist; this->patch = patch; this->index = index; this->type = type; this->next = next; }

		PatchSubHitRec *Next() { return next; }		
	};

class SubPatchHitList {
	private:
		PatchSubHitRec *first;
	public:
		SubPatchHitList() { first = NULL; }
		~SubPatchHitList() {
			PatchSubHitRec *ptr = first, *fptr;
			while ( ptr ) {
				fptr = ptr;
				ptr = ptr->Next();
				delete fptr;
				}
			first = NULL;
			}	

		PatchSubHitRec *First() { return first; }
		void AddHit( DWORD dist, PatchMesh *patch, int index, int type ) {
			first = new PatchSubHitRec(dist,patch,index,type,first);
			}
	};


// Special storage class for hit records so we can know which object was hit
class PatchHitData : public HitData {
	public:
		PatchMesh *patch;
		int index;
		int type;
		PatchHitData(PatchMesh *patch, int index, int type)
			{ this->patch = patch; this->index = index; this->type = type; }
		~PatchHitData() {}
	};

// Flags for sub object hit test

// NOTE: these are the same bits used for object level.
#define SUBHIT_PATCH_SELONLY	(1<<0)
#define SUBHIT_PATCH_UNSELONLY	(1<<2)
#define SUBHIT_PATCH_ABORTONHIT	(1<<3)
#define SUBHIT_PATCH_SELSOLID	(1<<4)

#define SUBHIT_PATCH_VERTS		(1<<24)
#define SUBHIT_PATCH_VECS		(1<<25)
#define SUBHIT_PATCH_PATCHES	(1<<26)
#define SUBHIT_PATCH_EDGES		(1<<27)
#define SUBHIT_PATCH_TYPEMASK	(SUBHIT_PATCH_VERTS|SUBHIT_PATCH_VECS|SUBHIT_PATCH_EDGES|SUBHIT_PATCH_PATCHES)


// Display flags
#define DISP_VERTTICKS		(1<<0)

#define DISP_SELVERTS		(1<<10)
#define DISP_SELPATCHES		(1<<11)
#define DISP_SELEDGES		(1<<12)
#define DISP_SELPOLYS		(1<<13)

#define DISP_LATTICE		(1<<16)
#define DISP_VERTS			(1<<17)

// Selection level bits.
#define PATCH_OBJECT		(1<<0)
#define PATCH_VERTEX		(1<<1)
#define PATCH_PATCH			(1<<2)
#define PATCH_EDGE			(1<<3)

// Types for Subdivision, below:
#define SUBDIV_EDGES 0
#define SUBDIV_PATCHES 1

// PatchMesh flags

class PatchMesh {
	friend class Patch;

	private:
#if MULTI_PROCESSING
		static int		refCount;
		static HANDLE	xfmThread;
		static HANDLE	xfmMutex;
		static HANDLE	xfmStartEvent;
		static HANDLE	xfmEndEvent;
		friend DWORD WINAPI xfmFunc(LPVOID ptr);
#endif
		// derived data-- can be regenerated
		PRVertex 		*rVerts;		// <<< instance specific.
		GraphicsWindow 	*cacheGW;  		// identifies rVerts cache
		Box3			bdgBox;			// object space--depends on geom+topo
 
		// The number of interpolations this patch will use for mesh conversion
		int			meshSteps;
//3-18-99 watje to support render steps
		int			meshStepsRender;
		BOOL		showInterior;

		BOOL		adaptive;
		// GAP tessellation
		TessApprox	viewTess;	// tessellation control for the interactive renderer
		TessApprox	prodTess;	// tessellation control for the production renderer
		TessApprox	dispTess;	// displacment tessellation control for the production renderer
		BOOL		mViewTessNormals;	// use normals from the tesselator
		BOOL		mProdTessNormals;	// use normals from the tesselator
		BOOL		mViewTessWeld;	// Weld the mesh after tessellation
		BOOL		mProdTessWeld;	// Weld the mesh after tessellation

 		// Vertex and patch work arrays -- for snap code
		int			snapVCt;
		int			snapPCt;
		char		*snapV;
		char		*snapP;

		// -------------------------------------
		//
		DWORD  		flags;		  	// work flags- 

		int 		renderPatch( GraphicsWindow *gw, int index, BOOL force=FALSE);
		int 		renderEdge( GraphicsWindow *gw, int index, BOOL force=FALSE);
		void		checkRVertsAlloc(void);
		void		setCacheGW(GraphicsWindow *gw)	{ cacheGW = gw; }
		GraphicsWindow *getCacheGW(void)			{ return cacheGW; }

		void 		freeVerts();
		void 		freeTVerts(int channel=0);
		void 		freeVecs();
		void  		freePatches();
		void  		freeTVPatches(int channel=0);
		void  		freeEdges();
		void  		freeRVerts();
		void		freeSnapData();
		int			buildSnapData(GraphicsWindow *gw,int verts,int edges);

	public:
		// Topology
		int			numVerts;
		int			numVecs;
		int	 		numPatches;
		int			numEdges;
		Patch *		patches;
		PatchVec *	vecs;
		PatchEdge *	edges;
		Tab<HookPoint> hooks;

//watje 4-16-99 to handle hooks and changes in topology
		Tab<Point3> hookTopoMarkers;
		Tab<Point3> hookTopoMarkersA;
		Tab<Point3> hookTopoMarkersB;
		CoreExport int HookFixTopology() ;


		// Geometry
		PatchVert *	verts;

		// Texture Coord assignment 
		Tab<int> numTVerts;
		Tab<UVVert *> tVerts;
		Tab<TVPatch *> tvPatches;  	 

		// Material assignment
		MtlID		mtlIndex;     // object material

		// Selection
		BitArray	vertSel;  		// selected vertices
		BitArray	edgeSel;  		// selected edges
		BitArray	patchSel;  		// selected patches

		// If hit bezier vector, this is its info:
		int bezVecVert;

		// Display attribute flags
		DWORD		dispFlags;

		// Selection level
		DWORD		selLevel;

		// Mesh cache
		Mesh mesh;
		int cacheSteps;		// meshSteps used for the cache
		BOOL cacheAdaptive;	// adaptive switch used for cache
		BOOL meshValid;

		CoreExport PatchMesh();
		CoreExport PatchMesh(PatchMesh& fromPatch);

		CoreExport void Init();

		CoreExport ~PatchMesh();

		CoreExport PatchMesh& 		operator=(PatchMesh& fromPatchMesh);
		CoreExport PatchMesh& 		operator=(Mesh& fromMesh);

		// The following is similar to operator=, but just takes the major components,
		// not the display flags, selection level, etc.
		CoreExport void CopyPatchDataFrom(PatchMesh &fromPatchMesh);

		CoreExport BOOL	setNumVerts(int ct, BOOL keep = FALSE);
		int				getNumVerts(void)	{ return numVerts; }
		
		CoreExport BOOL	setNumVecs(int ct, BOOL keep = FALSE);
		int				getNumVecs(void)	{ return numVecs; }
		
		CoreExport BOOL	setNumPatches(int ct, BOOL keep = FALSE);
		int				getNumPatches(void)		{ return numPatches; }

		CoreExport BOOL	setNumEdges(int ct, BOOL keep = FALSE);
		int				getNumEdges(void)		{ return numEdges; }
		
		void		setVert(int i, const Point3 &xyz)	{ verts[i].p = xyz; }
		void		setVert(int i, float x, float y, float z)	{ verts[i].p.x=x; verts[i].p.y=y; verts[i].p.z=z; }
		void		setVec(int i, const Point3 &xyz)	{ vecs[i].p = xyz; }
		void		setVec(int i, float x, float y, float z)	{ vecs[i].p.x=x; vecs[i].p.y=y; vecs[i].p.z=z; }
		
		PatchVert &	getVert(int i)					{ return verts[i];  }
		PatchVert *	getVertPtr(int i)				{ return verts+i; }
		PatchVec &	getVec(int i)					{ return vecs[i];  }
		PatchVec *	getVecPtr(int i)				{ return vecs+i; }
		PRVertex &	getRVert(int i)					{ return rVerts[i]; }
		PRVertex *	getRVertPtr(int i)				{ return rVerts+i; }
		
		// Two versions of following methods, to cope with necessary change in map indexing between 2.5 and 3.
		// Old TV/VC methods are given with "TV" in the name.  For these methods, channel 0 is the original map
		// channel, 1, while any nonzero channel is vertex colors.  (No higher channels!)
		BOOL	setNumTVertsChannel(int mp, int ct, BOOL keep=FALSE) { return setNumMapVerts (mp?0:1, ct, keep); }
		BOOL setNumTVerts(int ct, BOOL keep=FALSE) { return setNumMapVerts (1, ct, keep); }
		int	getNumTVertsChannel(int mp) const { return numTVerts[mp?0:1]; }
		int getNumTVerts() const { return getNumMapVerts(1); }

		// New methods have "Map" in the name, and accept normal Object-level map indexing: 0 is VC channel, 1 or more
		// are map channels.
		CoreExport BOOL setNumMapVerts (int mp, int ct, BOOL keep = FALSE);
		int getNumMapVerts (int mp) const { return (mp<numTVerts.Count()) ? numTVerts[mp] : 0; }

		CoreExport UVVert *mapVerts (int mp) const;
		CoreExport TVPatch *mapPatches (int mp) const;

		// These are parallel to patches
		// These are called from setNumPatches() to maintain the same count.
		//
		// If they are NULL and keep = TRUE they stay NULL.
		// If they are NULL and keep = FALSE they are allocated (3D verts also init themselves from the main vert array)
		// If they are non-NULL and ct = 0 they are set to NULL (and freed)
		// Old version: nonzero = vc channel
		BOOL setNumTVPatchesChannel(int channel, int ct, BOOL keep=FALSE, int oldCt=0) { return setNumMapPatches (channel?0:1, ct, keep, oldCt); }
		BOOL setNumTVPatches(int ct, BOOL keep=FALSE, int oldCt=0) { return setNumMapPatches (1, ct, keep, oldCt); }
		// New version: 0 = vc channel
		CoreExport BOOL 	setNumMapPatches (int channel, int ct, BOOL keep=FALSE, int oldCt=0);

		void		setTVertChannel(int channel, int i, const UVVert &xyz)	{ tVerts[channel?0:1][i] = xyz; }
		void		setTVert(int i, const UVVert &xyz)	{ tVerts[1][i] = xyz; }
		void		setTVertChannel(int channel, int i, float x, float y, float z)	{ tVerts[channel?0:1][i].x=x; tVerts[channel?0:1][i].y=y; tVerts[channel?0:1][i].z=z; }
		void		setTVert(int i, float x, float y, float z)	{ tVerts[1][i].x=x; tVerts[1][i].y=y; tVerts[1][i].z=z; }
		void		setTVPatchChannel(int channel, int i, TVPatch &tvp)	{ tvPatches[channel?0:1][i] = tvp; }
		void		setTVPatch(int i, TVPatch &tvp)	{ tvPatches[1][i] = tvp; }
		UVVert &	getTVertChannel(int channel, int i)	{ return tVerts[channel?0:1][i];  }
		UVVert &	getTVert(int i)	{ return tVerts[1][i];  }
		UVVert *	getTVertPtrChannel(int channel, int i)	{ return tVerts[channel?0:1]+i; }
		UVVert *	getTVertPtr(int i)	{ return tVerts[1]+i; }
		TVPatch &	getTVPatchChannel(int channel, int i)	{ return tvPatches[channel?0:1][i];  }
		TVPatch &	getTVPatch(int i)	{ return tvPatches[1][i];  }

		// New map methods: for these, channel 0 is v.c. channel, and anything higher is a map channel.
		void setMapVert (int mp, int i, const UVVert &xyz) { tVerts[mp][i] = xyz; }
		void setMapVert (int mp, int i, float x, float y, float z) { tVerts[mp][i].x=x; tVerts[mp][i].y=y; tVerts[mp][i].z = z; }
		void setMapPatch (int mp, int i, const TVPatch &tvp) { tvPatches[mp][i] = tvp; }
		UVVert & getMapVert (int mp, int i) { return tVerts[mp][i]; }
		UVVert * getMapVertPtr (int mp, int i) { return tVerts[mp] + i; }
		TVPatch & getMapPatch (int mp, int i) { return tvPatches[mp][i];  }

		void		setMtlIndex(MtlID i)	{ mtlIndex = i; }
		MtlID		getMtlIndex(void) 		{ return mtlIndex; }
	    CoreExport MtlID		getPatchMtlIndex(int i);
		CoreExport void		setPatchMtlIndex(int i, MtlID id); 	

		// Automatically update all the adjacency info, etc.
		// Returns TRUE if patch mesh is valid, FALSE if it's not!
		CoreExport BOOL		buildLinkages();
		
		// Compute the interior bezier points for each patch in the mesh
		CoreExport void		computeInteriors();

		// Compute the degree-4 bezier points for each triangular patch in the mesh
		CoreExport void		computeAux();

		CoreExport void		render(GraphicsWindow *gw, Material *ma, RECT *rp, int compFlags, int numMat=1);
		CoreExport BOOL		select(GraphicsWindow *gw, Material *ma, HitRegion *hr, int abortOnHit=FALSE, int numMat=1);
		CoreExport void		snap(GraphicsWindow *gw, SnapInfo *snap, IPoint2 *p, Matrix3 &tm);
		CoreExport BOOL 	SubObjectHitTest(GraphicsWindow *gw, Material *ma, HitRegion *hr,
								DWORD flags, SubPatchHitList& hitList, int numMat=1 );

		CoreExport void		buildBoundingBox(void);
		CoreExport Box3		getBoundingBox(Matrix3 *tm=NULL); // RB: optional TM allows the box to be calculated in any space.
		                                              // NOTE: this will be slower becuase all the points must be transformed.
		CoreExport void		GetDeformBBox(Box3& box, Matrix3 *tm=NULL, BOOL useSel=FALSE);
		
		CoreExport void 	InvalidateGeomCache();
		CoreExport void		InvalidateMesh();
		CoreExport void 	FreeAll(); //DS
				
		// functions for use in data flow evaluation
		CoreExport void 	ShallowCopy(PatchMesh *amesh, unsigned long channels);
		CoreExport void 	DeepCopy(PatchMesh *amesh, unsigned long channels);
		CoreExport void		NewAndCopyChannels(unsigned long channels);
		CoreExport void 	FreeChannels( unsigned long channels, int zeroOthers=1);

		// Display flags
		void		SetDispFlag(DWORD f) { dispFlags |= f; }
		DWORD		GetDispFlag(DWORD f) { return dispFlags & f; }
		void		ClearDispFlag(DWORD f) { dispFlags &= ~f; }

		// Selection access
		BitArray& 	VertSel() { return vertSel;  }	
		BitArray& 	PatchSel() { return patchSel;  }	
		BitArray& 	EdgeSel() { return edgeSel;  }	

		// Constructs a vertex selection list based on the current selection level.
		CoreExport BitArray 	VertexTempSel();

		// Apply the coplanar constraints to the patch mesh
		// (Optionally only apply it to selected vertices)
		CoreExport void ApplyConstraints(BOOL selOnly = FALSE);

		// Create triangular or quadrilateral patch
		CoreExport BOOL MakeQuadPatch(int index, int va, int vab, int vba, int vb, int vbc, int vcb, int vc, int vcd, int vdc, int vd, int vda, int vad, int i1, int i2, int i3, int i4, DWORD sm);
		CoreExport BOOL MakeTriPatch(int index, int va, int vab, int vba, int vb, int vbc, int vcb, int vc, int vca, int vac, int i1, int i2, int i3, DWORD sm);

		// Get/Set mesh steps, adaptive switch
		CoreExport void SetMeshSteps(int steps);
		CoreExport int GetMeshSteps();
//3-18-99 watje to support render steps
		CoreExport void SetMeshStepsRender(int steps);
		CoreExport int GetMeshStepsRender();
		CoreExport void SetShowInterior(BOOL si);
		CoreExport BOOL GetShowInterior();


		CoreExport void SetAdaptive(BOOL sw);
		CoreExport BOOL GetAdaptive();

		CoreExport void SetViewTess(TessApprox tess);
		CoreExport TessApprox GetViewTess();
		CoreExport void SetProdTess(TessApprox tess);
		CoreExport TessApprox GetProdTess();
		CoreExport void SetDispTess(TessApprox tess);
		CoreExport TessApprox GetDispTess();
		CoreExport BOOL GetViewTessNormals();
		CoreExport void SetViewTessNormals(BOOL use);
		CoreExport BOOL GetProdTessNormals();
		CoreExport void SetProdTessNormals(BOOL use);
		CoreExport BOOL GetViewTessWeld();
		CoreExport void SetViewTessWeld(BOOL weld);
		CoreExport BOOL GetProdTessWeld();
		CoreExport void SetProdTessWeld(BOOL weld);

		// Find the edge index for a given vertex-vector-vector-vertex sequence
		int GetEdge(int v1, int v12, int v21, int v2, int p);

		// Apply mapping to the patch mesh
		CoreExport void setNumMaps (int ct, BOOL keep=TRUE);
		int getNumMaps () { return numTVerts.Count(); }
		BOOL getMapSupport (int mp) { return ((mp<tvPatches.Count()) && tvPatches[mp]) ? TRUE : FALSE; }
		int NumMapChannels () { return MAX_MESHMAPS; }
		CoreExport void ApplyUVWMap(int type,
			float utile, float vtile, float wtile,
			int uflip, int vflip, int wflip, int cap,
			const Matrix3 &tm,int channel=1);

		// Tag the points in the patch components to record our topology (This stores
		// identifying values in the various aux2 fields in the Patch)
		// This info can be used after topology-changing operations to remap information
		// tied to vertices, edges and patches.
		// Returns TRUE if tagged successfully
		CoreExport BOOL RecordTopologyTags();

		CoreExport void Transform(Matrix3 &tm);

		// Weld the vertices
		CoreExport BOOL Weld(float thresh, BOOL weldIdentical=FALSE, int startVert=0);

		// General-purpose deletion
		CoreExport void DeletePatchParts(BitArray &delVerts, BitArray &delPatches);

		// Subdivision
		CoreExport void Subdivide(int type, BOOL propagate);

		// Add patch to selected single-patch edges
		CoreExport void AddPatch(int type);

		// Hooks a vertex to a patch edge
		CoreExport int AddHook();
		//tries to add hook patch at the specified vert
		CoreExport int AddHook(int index);
		CoreExport int AddHook(int vertIndex, int segIndex) ;

		CoreExport int RemoveHook();
		//goes through and looks for invalid hooks and tries to fix them used when topology changes
		CoreExport int UpdateHooks();

		Tab<Point3> extrudeDeltas;
		Tab<ExtrudeData> extrudeData;
//creates initial extrude faces and temporary data used in move normal
		CoreExport void CreateExtrusion();
//computes the average normals of the selected faces
		CoreExport Point3 AverageNormals();
		CoreExport Point3 PatchNormal(int index);
		CoreExport void MoveNormal(float amount, BOOL useLocalNorms);

//creates temporary data used in Bevel
		BitArray bevelEdges;
		Tab<float> edgeDistances;
		CoreExport void CreateBevel();
		CoreExport void Bevel(float amount, int smoothStart, int smoothEnd);
//computes the bevel direction of patch based on which edges are open
		Point3 GetBevelDir(int patchVertID);

		// Attach a second PatchMesh, adjusting materials
		CoreExport void Attach(PatchMesh *attPatch, int mtlOffset);

		// Change the interior type of a patch or selected patches (index < 0)
		CoreExport void ChangePatchInterior(int index, int type);

		// Change the type of a vertex or selected vertices (index < 0)
		CoreExport void ChangeVertType(int index, int type);

		CoreExport BOOL SelVertsSameType();	// Are all selected vertices the same type?
		CoreExport BOOL SelPatchesSameType();	// Are all selected patches the same type?

		// Dump the patch mesh structure via DebugPrints
		CoreExport void Dump();
#ifdef CHECK_TRI_PATCH_AUX
		CoreExport void CheckTriAux();
#endif //CHECK_TRI_PATCH_AUX

		// Ready the mesh cache
		CoreExport void PrepareMesh();

		// Get the Mesh version
		CoreExport Mesh& GetMesh();

		CoreExport int IntersectRay(Ray& ray, float& at, Point3& norm);

		CoreExport IOResult Save(ISave* isave);
		CoreExport IOResult Load(ILoad* iload);

	};


#endif // _PATCH_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\plugapi.h ===
/*******************************************************************
 *
 *    DESCRIPTION: DLL Plugin API
 *
 *    AUTHOR: Dan Silva
 *
 *    HISTORY: 11/30/94 Started coding
 *
 *******************************************************************/

#include "maxtypes.h"

#ifndef PLUGAPI_H_DEFINED


#define PLUGAPI_H_DEFINED

// 3DSMAX Version number to be compared against that returned by DLL's
// LibVersion function to detect obsolete DLLs.
//#define VERSION_3DSMAX 100      // changed  4/ 9/96 -- DB
//#define VERSION_3DSMAX 110      // changed  7/17/96 -- DS
//#define VERSION_3DSMAX 111      // changed  9/24/96 -- DS
//#define VERSION_3DSMAX 120      // changed  9/30/96 -- DB
//#define VERSION_3DSMAX 200      // changed  10/30/96 -- DS


// MAX release number X 1000
//#define MAX_RELEASE  2000      // DDS 9/30/97  
//#define MAX_RELEASE  2500      // JMK 2/25/98  
//#define MAX_RELEASE  3000        // DDS 9/3/98  
#define MAX_RELEASE  3100        // CCJ 10/21/99  


// This is the max API number.  When a change in the API requires DLL's
// to be recompiled, increment this number and set MAX_SDK_REV to 0
// THis will make all DLL's with the former MAX_API_NUM unloadable.
//#define MAX_API_NUM     4	   // DDS 9/30/97
//#define MAX_API_NUM     5	   // DDS 10/06/97
//#define MAX_API_NUM     6	   // DDS 9/3/98
#define MAX_API_NUM     7	   // CCJ 5/14/99

// This denotes the revision of the SDK for a given API. Increment this
// when the SDK functionality changes in some significant way (for instance
// a new GetProperty() query  response is added), but the headers have 
// not been changed.
#define MAX_SDK_REV     0	  // DDS 9/20/97

// This value should be returned by the LibVersion() method for DLL's:
#define VERSION_3DSMAX ((MAX_RELEASE<<16)+(MAX_API_NUM<<8)+MAX_SDK_REV)
#ifdef DESIGN_VER
#define VERSION_DMAX ((MAX_RELEASE<<16)+(MAX_API_NUM<<8)+MAX_SDK_REV)
#endif

typedef enum {kAPP_NONE, kAPP_MAX, kAPP_VIZ} APPLICATION_ID;

//This method returns the ApplicationID, either VIZ or MAX. If a plugin
//is designed to work only in one product, then you could use this method
//in your IsPublic() call to switch between exposing the plug-in or not.
CoreExport APPLICATION_ID GetAppID();

// Macros for extracting parts of VERSION_3DSMAX
#define GET_MAX_RELEASE(x)  (((x)>>16)&0xffff)
#define GET_MAX_API_NUM(x)  (((x)>>8)&0xff)
#define GET_MAX_SDK_REV(x)  ((x)&0xff)
#define GET_MAX_SDK_NUMREV(x)  ((x)&0xffff) 



// Internal super classes, that plug-in developers need not know about
#define GEN_MODAPP_CLASS_ID 		0x00000b
#define MODAPP_CLASS_ID 			0x00000c
#define OBREF_MODAPP_CLASS_ID 		0x00000d
#define BASENODE_CLASS_ID			0x000001
#define GEN_DERIVOB_CLASS_ID 		0x000002
#define DERIVOB_CLASS_ID 			0x000003
#define WSM_DERIVOB_CLASS_ID 		0x000004
#define PARAMETER_BLOCK_CLASS_ID 	0x000008	
#define PARAMETER_BLOCK2_CLASS_ID 	0x000082	// <JBW> ParamBlocks Ed. 2
#define EASE_LIST_CLASS_ID			0x000009
#define AXIS_DISPLAY_CLASS_ID		0x00000e
#define MULT_LIST_CLASS_ID			0x00000f
#define NOTETRACK_CLASS_ID			0x0000ff
#define TREE_VIEW_CLASS_ID			0xffffff00
#define SCENE_CLASS_ID				0xfffffd00
#define THE_GRIDREF_CLASS_ID		0xfffffe00
#define VIEWREF_CLASS_ID			0xffffff01
#define BITMAPDAD_CLASS_ID			0xffffff02 // for drag/drop of bitmaps
#define PARTICLE_SYS_CLASS_ID		0xffffff03 // NOTE: this is for internal use only. Particle systems return GEOMOBJECT_CLASS_ID -- use IsParticleObject() to determine if an object is a particle system.
#define XREF_CLASS_ID				0xffffff04 // Object XRefs
#define AGGMAN_CLASS_ID				0xffffff05 // Object aggregation, VIZ
#define MAXSCRIPT_WRAPPER_CLASS_ID	0xffffff06 // JBW, 5/14/99, MAX object wrappers within MAXScript

//-------------------------------------------
// Deformable object psuedo-super-class
#define DEFORM_OBJ_CLASS_ID 		0x000005

//-------------------------------------------
// Mappable object psuedo-super-class
#define MAPPABLE_OBJ_CLASS_ID 		0x000006

//-------------------------------------------
// Shape psuedo-super-class
#define GENERIC_SHAPE_CLASS_ID		0x0000ab

//-------------------------------------------
// Super-classes that are plugable.
#define GEOMOBJECT_CLASS_ID			0x000010
#define CAMERA_CLASS_ID				0x000020
#define LIGHT_CLASS_ID				0x000030
#define SHAPE_CLASS_ID				0x000040
#define HELPER_CLASS_ID				0x000050
#define SYSTEM_CLASS_ID	 			0x000060 
#define REF_MAKER_CLASS_ID			0x000100 	
#define REF_TARGET_CLASS_ID	 		0x000200
#define OSM_CLASS_ID				0x000810
#define WSM_CLASS_ID				0x000820
#define WSM_OBJECT_CLASS_ID			0x000830
#define SCENE_IMPORT_CLASS_ID		0x000A10
#define SCENE_EXPORT_CLASS_ID		0x000A20
#define BMM_STORAGE_CLASS_ID		0x000B10
#define BMM_FILTER_CLASS_ID			0x000B20
#define BMM_IO_CLASS_ID				0x000B30
#define BMM_DITHER_CLASS_ID			0x000B40
#define BMM_COLORCUT_CLASS_ID		0x000B50
#define USERDATATYPE_CLASS_ID		0x000B60
#define MATERIAL_CLASS_ID			0x000C00    // Materials
#define TEXMAP_CLASS_ID				0x000C10    // Texture maps
#define UVGEN_CLASS_ID				0x0000C20   // UV Generator
#define XYZGEN_CLASS_ID				0x0000C30   // XYZ Generator
#define TEXOUTPUT_CLASS_ID			0x0000C40   // Texture output filter 
#define SOUNDOBJ_CLASS_ID			0x000D00
#define FLT_CLASS_ID				0x000E00
#define RENDERER_CLASS_ID			0x000F00
#define BEZFONT_LOADER_CLASS_ID		0x001000
#define ATMOSPHERIC_CLASS_ID		0x001010
#define UTILITY_CLASS_ID			0x001020	// Utility plug-ins
#define TRACKVIEW_UTILITY_CLASS_ID	0x001030
#define FRONTEND_CONTROL_CLASS_ID	0x001040
#define MOT_CAP_DEV_CLASS_ID		0x001060
#define MOT_CAP_DEVBINDING_CLASS_ID	0x001050
#define OSNAP_CLASS_ID				0x001070
#define TEXMAP_CONTAINER_CLASS_ID	0x001080    // Texture map container
#define RENDER_EFFECT_CLASS_ID      0x001090    // Render post-effects
#define FILTER_KERNEL_CLASS_ID      0x0010a0    // AA Filter kernel
#define SHADER_CLASS_ID				0x0010b0    // plugable shading into stdmtl
#define COLPICK_CLASS_ID		  	0x0010c0    // color picker
#define SHADOW_TYPE_CLASS_ID		0x0010d0    // shadow generators
//-- GUPSTART
#define GUP_CLASS_ID		  		0x0010e0    // Global Utility Plug-In
//-- GUPEND
#define LAYER_CLASS_ID				0x0010f0
#define SCHEMATICVIEW_UTILITY_CLASS_ID	0x001100
#define SAMPLER_CLASS_ID			0x001110
#define ASSOC_CLASS_ID				0x001120
#define GLOBAL_ASSOC_CLASS_ID		0x001130

// Super-class ID's of various controls
#define	CTRL_SHORT_CLASS_ID 	   	0x9001
#define	CTRL_INTEGER_CLASS_ID		0x9002
#define	CTRL_FLOAT_CLASS_ID			0x9003
#define	CTRL_POINT2_CLASS_ID	   	0x9004
#define	CTRL_POINT3_CLASS_ID	   	0x9005
#define	CTRL_POS_CLASS_ID		   	0x9006
#define	CTRL_QUAT_CLASS_ID			0x9007
#define	CTRL_MATRIX3_CLASS_ID		0x9008
#define	CTRL_COLOR_CLASS_ID     	0x9009	// float color
#define	CTRL_COLOR24_CLASS_ID   	0x900A   // 24 bit color
#define	CTRL_POSITION_CLASS_ID		0x900B
#define	CTRL_ROTATION_CLASS_ID		0x900C
#define	CTRL_SCALE_CLASS_ID			0x900D
#define CTRL_MORPH_CLASS_ID			0x900E
#define CTRL_USERTYPE_CLASS_ID		0x900F  // User defined type
#define CTRL_MASTERPOINT_CLASS_ID	0x9010	
#define MASTERBLOCK_SUPER_CLASS_ID	0x9011

#define PATH_CONTROL_CLASS_ID				0x2011
#define EULER_CONTROL_CLASS_ID				0x2012
#define EXPR_POS_CONTROL_CLASS_ID			0x2013
#define EXPR_P3_CONTROL_CLASS_ID			0x2014
#define EXPR_FLOAT_CONTROL_CLASS_ID			0x2015
#define EXPR_SCALE_CONTROL_CLASS_ID			0x2016
#define EXPR_ROT_CONTROL_CLASS_ID			0x2017
#define LOCAL_EULER_CONTROL_CLASS_ID		0x2018

#define FLOATNOISE_CONTROL_CLASS_ID		0x87a6df24
#define POSITIONNOISE_CONTROL_CLASS_ID	0x87a6df25
#define POINT3NOISE_CONTROL_CLASS_ID	0x87a6df26
#define ROTATIONNOISE_CONTROL_CLASS_ID	0x87a6df27
#define SCALENOISE_CONTROL_CLASS_ID		0x87a6df28
#define SURF_CONTROL_CLASSID			Class_ID(0xe8334011,0xaeb330c8)
#define LINKCTRL_CLASSID				Class_ID(0x873fe764,0xaabe8601)


// Class ID's of built-in classes. The value is the first ULONG of the 
// 8 byte Class ID: the second ULONG is 0 for all built-in classes.
// NOTE: Only built-in classes should have the second ULONG == 0.

//--------------------- subclasses of GEOMOBJECT_CLASS_ID:

// Built into CORE
#define TRIOBJ_CLASS_ID 	 	0x0009	  
#define EDITTRIOBJ_CLASS_ID	0xe44f10b3	// base triangle mesh
#define POLYOBJ_CLASS_ID		0x5d21369a	// polygon mesh
#define PATCHOBJ_CLASS_ID  		0x1030
#define NURBSOBJ_CLASS_ID		0x4135

// Primitives
#define BOXOBJ_CLASS_ID 		0x0010
#define SPHERE_CLASS_ID 		0x0011 
#define CYLINDER_CLASS_ID 		0x0012
#define CONE_CLASS_ID			0xa86c23dd
#define TORUS_CLASS_ID			0x0020
#define TUBE_CLASS_ID			0x7B21
#define HEDRA_CLASS_ID			0xf21c5e23
#define BOOLOBJ_CLASS_ID		0x387BB2BB
// Above used in obselete Boolean -- henceforth use following:
#define NEWBOOL_CLASS_ID Class_ID(0x51db4f2f,0x1c596b1a)

// Class ID for XRef object
#define XREFOBJ_CLASS_ID		0x92aab38c

// Class ID for XRef object
#define XREFOBJ_CLASS_ID		0x92aab38c

//Subclasses of object snaps.
#define GRID_OSNAP_CLASS_ID Class_ID(0x62f565d6, 0x110a1f97)


// The teapot is unique in that it uses both DWORDs in its class IDs
// Note that this is what 3rd party plug-ins SHOULD do.
#define TEAPOT_CLASS_ID1		0xACAD13D3
#define TEAPOT_CLASS_ID2		0xACAD26D9

#define PATCHGRID_CLASS_ID  	0x1070

// Particles
#define RAIN_CLASS_ID			0x9bd61aa0
#define SNOW_CLASS_ID			0x9bd61aa1

// Space Warp Objects
#define WAVEOBJ_CLASS_ID 		0x0013

// The basic lofter class
#define LOFTOBJ_CLASS_ID		0x1035
#define LOFT_DEFCURVE_CLASS_ID	0x1036

// Our implementation of the lofter
#define LOFT_GENERIC_CLASS_ID	0x10B0

#define TARGET_CLASS_ID  		0x1020  // should this be a helper?
#define MORPHOBJ_CLASS_ID		0x1021

// Subclasses of SHAPE_CLASS_ID
#define SPLINESHAPE_CLASS_ID 	0x00000a
#define LINEARSHAPE_CLASS_ID 	0x0000aa
#define SPLINE3D_CLASS_ID  		0x1040
#define NGON_CLASS_ID  			0x1050
#define DONUT_CLASS_ID  		0x1060
#define STAR_CLASS_ID			0x1995
#define RECTANGLE_CLASS_ID		0x1065
#define HELIX_CLASS_ID			0x1994
#define ELLIPSE_CLASS_ID		0x1097
#define CIRCLE_CLASS_ID			0x1999
#define TEXT_CLASS_ID			0x1993
#define ARC_CLASS_ID			0x1996

// subclasses of CAMERA_CLASS_ID:
#define SIMPLE_CAM_CLASS_ID  	0x1001
#define LOOKAT_CAM_CLASS_ID  	0x1002

// subclasses of LIGHT_CLASS_ID:
#define OMNI_LIGHT_CLASS_ID  	0x1011
#define SPOT_LIGHT_CLASS_ID  	0x1012
#define DIR_LIGHT_CLASS_ID  	0x1013
#define FSPOT_LIGHT_CLASS_ID  	0x1014
#define TDIR_LIGHT_CLASS_ID  	0x1015

// subclasses of HELPER_CLASS_ID
#define DUMMY_CLASS_ID 			0x876234
#define BONE_CLASS_ID 			0x8a63c0
#define TAPEHELP_CLASS_ID 		0x02011
#define GRIDHELP_CLASS_ID		0x02010
#define POINTHELP_CLASS_ID		0x02013
#define PROTHELP_CLASS_ID		0x02014

//subclasses of UVGEN_CLASS_ID
#define STDUV_CLASS_ID 			0x0000100

//subclasses of XYZGEN_CLASS_ID
#define STDXYZ_CLASS_ID 		0x0000100

//subclasses of TEXOUT_CLASS_ID
#define STDTEXOUT_CLASS_ID 		0x0000100

// subclasses of MATERIAL_CLASS_ID	
#define DMTL_CLASS_ID  			0x00000002	// Origninal Stdmtl
#define DMTL2_CLASS_ID  		0x00000003	// R2.5 stdmtl
#define CMTL_CLASS_ID 			0x0000100  // top-bottom material 
#define MULTI_CLASS_ID 			0x0000200  // multi material
#define DOUBLESIDED_CLASS_ID 	0x0000210  // double-sided mtl
#define MIXMAT_CLASS_ID 		0x0000250  // blend mtl
#define MATTE_CLASS_ID 			0x0000260  // Matte mtl

// subclasses of TEXMAP_CLASS_ID	
#define CHECKER_CLASS_ID 		0x0000200
#define MARBLE_CLASS_ID 		0x0000210
#define MASK_CLASS_ID 			0x0000220  // mask texture
#define MIX_CLASS_ID 			0x0000230
#define NOISE_CLASS_ID 			0x0000234
#define GRADIENT_CLASS_ID 		0x0000270
#define TINT_CLASS_ID 			0x0000224  // Tint texture
#define BMTEX_CLASS_ID 			0x0000240  // Bitmap texture
#define ACUBIC_CLASS_ID 		0x0000250  // Reflect/refract
#define MIRROR_CLASS_ID 		0x0000260  // Flat mirror
#define COMPOSITE_CLASS_ID 		0x0000280   // Composite texture
#define RGBMULT_CLASS_ID 		0x0000290   // RGB Multiply texture
#define FALLOFF_CLASS_ID 		0x00002A0   // Falloff texture
#define OUTPUT_CLASS_ID 		0x00002B0   // Output texture
#define PLATET_CLASS_ID 		0x00002C0   // Plate glass texture
#define VCOL_CLASS_ID 			0x0934851	// Vertex color map

// Subclasses of SHADER_CLASS_ID
#define STDSHADERS_CLASS_ID		0x00000035	// to 39 

// Subclasses of SHADOW_TYPE_CLASS_ID	
#define STD_SHADOW_MAP_CLASS_ID       0x0000100
#define STD_RAYTRACE_SHADOW_CLASS_ID  0x0000200
		
// subclasses of RENDERER_CLASS_ID		  
#define SREND_CLASS_ID 			0x000001 // default scan-line renderer

// subclasses of REF_MAKER_CLASS_ID			
#define MTL_LIB_CLASS_ID 		0x001111
#define MTLBASE_LIB_CLASS_ID 	0x003333
#define THE_SCENE_CLASS_ID   	0x002222
#define MEDIT_CLASS_ID 	 		0x000C80

// subclass of all classes
#define STANDIN_CLASS_ID   		0xffffffff  // subclass of all super classes



// Default sound object
#define DEF_SOUNDOBJ_CLASS_ID	0x0000001

// Default atmosphere
#define FOG_CLASS_ID 0x10000001

//------------------ Modifier sub classes --------
#define SKEWOSM_CLASS_ID			0x6f3cc2aa
#define BENDOSM_CLASS_ID 			0x00010
#define TAPEROSM_CLASS_ID 			0x00020
#define TWISTOSM_CLASS_ID 			0x00090

#define UVWMAPOSM_CLASS_ID			0xf72b1
#define SELECTOSM_CLASS_ID			0xf8611
#define MATERIALOSM_CLASS_ID		0xf8612
#define SMOOTHOSM_CLASS_ID			0xf8613
#define NORMALOSM_CLASS_ID			0xf8614
#define OPTIMIZEOSM_CLASS_ID		0xc4d31
#define AFFECTREGION_CLASS_ID		0xc4e32
#define SUB_EXTRUDE_CLASS_ID		0xc3a32
#define TESSELLATE_CLASS_ID			0xa3b26ff2
#define DELETE_CLASS_ID				0xf826ee01
#define MESHSELECT_CLASS_ID			0x73d8ff93
#define UVW_XFORM_CLASS_ID			0x5f32de12

#define EXTRUDEOSM_CLASS_ID 		0x000A0
#define SURFREVOSM_CLASS_ID 		0x000B0

#define DISPLACEOSM_CLASS_ID		0xc4d32
#define DISPLACE_OBJECT_CLASS_ID	0xe5240
#define DISPLACE_WSM_CLASS_ID		0xe5241

#define SINEWAVE_OBJECT_CLASS_ID 	0x00030
#define SINEWAVE_CLASS_ID 			0x00040
#define SINEWAVE_OMOD_CLASS_ID 		0x00045
#define LINWAVE_OBJECT_CLASS_ID 	0x00035
#define LINWAVE_CLASS_ID 			0x00042
#define LINWAVE_OMOD_CLASS_ID 		0x00047

#define GRAVITYOBJECT_CLASS_ID		0xe523c
#define GRAVITYMOD_CLASS_ID			0xe523d
#define WINDOBJECT_CLASS_ID			0xe523e
#define WINDMOD_CLASS_ID			0xe523f

#define DEFLECTOBJECT_CLASS_ID		0xe5242
#define DEFLECTMOD_CLASS_ID			0xe5243

#define BOMB_OBJECT_CLASS_ID 		0xf2e32
#define BOMB_CLASS_ID 				0xf2e42

// These are the FFD Modifier's class ID's
#define FFDNMOSSQUARE_CLASS_ID		Class_ID(0x8ab36cc5,0x82d7fe74)
#define FFDNMWSSQUARE_CLASS_ID		Class_ID(0x67ea40b3,0xfe7a30c4)
#define FFDNMWSSQUARE_MOD_CLASS_ID	Class_ID(0xd6636ea2,0x9aa42bf3)

#define FFDNMOSCYL_CLASS_ID			Class_ID(0x98f37a63,0x3ffe9bca)
#define FFDNMWSCYL_CLASS_ID			Class_ID(0xfa4700be,0xbbe85051)
#define FFDNMWSCYL_MOD_CLASS_ID		Class_ID(0xf1c630a3,0xaa8ff601)

#define FFD44_CLASS_ID				Class_ID(0x21325596, 0x2cd10bd8)
#define FFD33_CLASS_ID				Class_ID(0x21325596, 0x2cd10bd9)
#define FFD22_CLASS_ID				Class_ID(0x21325596, 0x2cd10bd0)

//JH Association context modifiers
//GEOM TO GEOM
#define ACMOD_GEOM_GEOM_BOOLADD_CID	0x4e0f483a
#define ACMOD_GEOM_GEOM_BOOLSUB_CID	0x61661a5c
#define ACMOD_GEOM_GEOM_BOOLINT_CID	0x2a4f3945
#define ACMOD_GEOM_GEOM_SIMPAGG_CID	0x40cb05ab

//SHAPE To GEOM
#define ACMOD_SHAPE_GEOM_HOLE_CID	0x366307b0
#define ACMOD_SHAPE_GEOM_INT_CID	0x782d8d50
#define ACMOD_SHAPE_GEOM_EMBOSS_CID	0x7a13397c
#define ACMOD_SHAPE_GEOM_REVEAL_CID	0x55ed658c

//JH Solids
#define GENERIC_AMSOLID_CLASS_ID	Class_ID(0x5bb661e8, 0xa2c27f02)


//------------------ Controller sub classes --------
#define LININTERP_FLOAT_CLASS_ID 			0x2001
#define LININTERP_POSITION_CLASS_ID 		0x2002
#define LININTERP_ROTATION_CLASS_ID 		0x2003
#define LININTERP_SCALE_CLASS_ID			0x2004
#define PRS_CONTROL_CLASS_ID				0x2005
#define LOOKAT_CONTROL_CLASS_ID				0x2006				

#define HYBRIDINTERP_FLOAT_CLASS_ID 		0x2007
#define HYBRIDINTERP_POSITION_CLASS_ID 		0x2008
#define HYBRIDINTERP_ROTATION_CLASS_ID 		0x2009
#define HYBRIDINTERP_POINT3_CLASS_ID		0x200A
#define HYBRIDINTERP_SCALE_CLASS_ID			0x2010
#define HYBRIDINTERP_COLOR_CLASS_ID			0x2011

#define TCBINTERP_FLOAT_CLASS_ID 			0x442311
#define TCBINTERP_POSITION_CLASS_ID 		0x442312
#define TCBINTERP_ROTATION_CLASS_ID 		0x442313
#define TCBINTERP_POINT3_CLASS_ID			0x442314
#define TCBINTERP_SCALE_CLASS_ID			0x442315

#define MASTERPOINTCONT_CLASS_ID			0xd9c20ff

//--------------------------------------------------

class ISave;
class ILoad;
class Interface;
class ShortcutTable;
typedef short BlockID;
class ParamBlockDesc2;
class IParamBlock2;
class IObjParam;
class Animatable;
class ParamMap2UserDlgProc;
class IParamMap2;

// System keeps a list of the DLL's found on startup.
// This is the interface to a single class
class ClassDesc {
	public:
		virtual					~ClassDesc() {}
		virtual int				IsPublic()=0;  // Show this in create branch?
		virtual void *			Create(BOOL loading=FALSE)=0;   // return a pointer to an instance of the class.
		virtual	int 			BeginCreate(Interface *i) {return 0;}
		virtual int 			EndCreate(Interface *i) {return 0;};
		virtual const TCHAR* 	ClassName()=0;
		virtual SClass_ID		SuperClassID()=0;
		virtual Class_ID		ClassID()=0;
		virtual const TCHAR* 	Category()=0;   // primitive/spline/loft/ etc
		virtual BOOL			OkToCreate(Interface *i) { return TRUE; }	// return FALSE to disable create button		
		virtual BOOL			HasClassParams() {return FALSE;}
		virtual void			EditClassParams(HWND hParent) {}
		virtual void			ResetClassParams(BOOL fileReset=FALSE) {}

        // These functions return keyboard shortcut tables that plug-ins can use
        virtual int             NumShortcutTables() { return 0; }
        virtual ShortcutTable*  GetShortcutTable(int i) { return NULL; }

		// Class IO
		virtual BOOL			NeedsToSave() { return FALSE; }
		virtual IOResult 		Save(ISave *isave) { return IO_OK; }
		virtual IOResult 		Load(ILoad *iload) { return IO_OK; }

		// bits of dword set indicate corrresponding rollup page is closed.
		// the value 0x7fffffff is returned by the default implementation so the
		// command panel can detect this method is not being overridden, and just leave 
		// the rollups as is.
		virtual DWORD			InitialRollupPageState() { return 0x7fffffff; }

		// ParamBlock2-related metadata interface, supplied & implemented in ClassDesc2 (see maxsdk\include\iparamb2.h)
		
		virtual const TCHAR*	InternalName() { return NULL; }
		virtual HINSTANCE		HInstance() { return NULL; }
		// access parameter block descriptors for this class
		virtual int				NumParamBlockDescs() { return 0; }
		virtual ParamBlockDesc2* GetParamBlockDesc(int i) { return NULL; }
		virtual ParamBlockDesc2* GetParamBlockDescByID(BlockID id) { return NULL; }
		virtual void			AddParamBlockDesc(ParamBlockDesc2* pbd) { }
		// automatic UI management
		virtual void			BeginEditParams(IObjParam *ip, ReferenceMaker* obj, ULONG flags, Animatable *prev) { }
		virtual void			EndEditParams(IObjParam *ip, ReferenceMaker* obj, ULONG flags, Animatable *prev) { }
		virtual void			InvalidateUI(ParamBlockDesc2* pbd) { }
		// automatic ParamBlock construction
		virtual void			MakeAutoParamBlocks(ReferenceMaker* owner) { }
		// access automatically-maintained ParamMaps, by simple index or by associated ParamBlockDesc
		virtual int				NumParamMaps() { return 0; }
		virtual IParamMap2*		GetParamMap(int i) { return NULL; }
		virtual IParamMap2*		GetParamMap(ParamBlockDesc2* pbd) { return NULL; }
		// maintain user dialog procs on automatically-maintained ParamMaps
		virtual void			SetUserDlgProc(ParamBlockDesc2* pbd, ParamMap2UserDlgProc* proc=NULL) { }
		virtual ParamMap2UserDlgProc* GetUserDlgProc(ParamBlockDesc2* pbd) { return NULL; }

		// Class can draw an image to represent itself graphically...
		virtual bool DrawRepresentation(COLORREF bkColor, HDC hDC, Rect &rect) { return FALSE; }

		// Generic expansion function
		virtual int Execute(int cmd, ULONG arg1=0, ULONG arg2=0, ULONG arg3=0) { return 0; } 
	};

// Create instance of the specified class
CoreExport void *CreateInstance(SClass_ID superID, Class_ID classID);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\pixelbuf.h ===
//-----------------------------------------------------------------------------
// --------------------
// File ....: pixelbuf.h
// --------------------
// Author...: Tom Hudson
// Date ....: Dec. 09, 1995
// Descr....: Pixel Buffer Classes
// Usage....: These templated classes let you set up a buffer for pixels that
//            will automatically clean itself up when it goes out of scope.
//
// History .: Dec. 09 1995 - Started file
//            
//-----------------------------------------------------------------------------

#ifndef __PIXBUF_H__

#define __PIXBUF_H__

// Handy-dandy pixel buffer classes:

template <class T> class PixelBufT {
private:
     T *buf;
     int width;
public:
     inline               PixelBufT(int width) { buf = (T *)calloc(width,sizeof(T)); this->width=width; };
     inline               ~PixelBufT() { if(buf) free(buf); };
     inline   T*          Ptr() { return buf; };
	 inline   T&          operator[](int i) { return buf[i]; }
           int            Fill(int start, int count, T color) {
                          int ix,jx=start+count;
                          if(jx >= width)
                             return 0;
                          for(ix=start; ix<jx; buf[ix++]=color);
                          return 1;
                          };
     };

typedef PixelBufT<UBYTE> PixelBuf8;
typedef PixelBufT<USHORT> PixelBuf16;
typedef PixelBufT<BMM_Color_24> PixelBuf24;
typedef PixelBufT<BMM_Color_32> PixelBuf32;
typedef PixelBufT<BMM_Color_48> PixelBuf48;
typedef PixelBufT<BMM_Color_64> PixelBuf64;

#endif // __PIXBUF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\patchobj.h ===
/**********************************************************************
 *<
	FILE: patchobj.h

	DESCRIPTION:  Defines Patch Mesh Object

	CREATED BY: Tom Hudson

	HISTORY: created 21 June 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#ifndef __PATCHOBJ__ 

#define __PATCHOBJ__

#include "Max.h"
#include "namesel.h"
#include "meshlib.h"
#include "patchlib.h"
#include "snap.h"
#include "istdplug.h"
#include "sbmtlapi.h"

extern CoreExport Class_ID patchObjectClassID;

extern HINSTANCE hInstance;

// Named selection set list types for PatchObject
#define NS_PO_VERT 0
#define NS_PO_EDGE 1
#define NS_PO_PATCH 2

// These are values for selLevel.
#define PO_OBJECT	0
#define PO_VERTEX	1
#define PO_EDGE		2
#define PO_PATCH	3

#define CID_EP_BIND	CID_USER + 203
#define CID_EP_EXTRUDE	CID_USER + 204
#define CID_EP_BEVEL	CID_USER + 205

// References
#define EP_MASTER_CONTROL_REF 0
#define EP_VERT_BASE_REF 1

class PatchObject;


class EP_BindMouseProc : public MouseCallBack {
	private:
		PatchObject *pobj;
		IObjParam *ip;
		IPoint2 om;
		BitArray knotList;
	
	protected:
		HCURSOR GetTransformCursor();
		BOOL HitAKnot(ViewExp *vpt, IPoint2 *p, int *vert);
		BOOL HitASegment(ViewExp *vpt, IPoint2 *p, int *Seg);

		BOOL HitTest( ViewExp *vpt, IPoint2 *p, int type, int flags, int subType );
		BOOL AnyHits( ViewExp *vpt ) { return vpt->NumSubObjHits(); }		

	public:
		EP_BindMouseProc(PatchObject* spl, IObjParam *i) { pobj=spl; ip=i; }
		int proc( 
			HWND hwnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m );
	};



class EP_BindCMode : public CommandMode {
	private:
		ChangeFGObject fgProc;
		EP_BindMouseProc eproc;
		PatchObject* pobj;
//		int type; // See above

	public:
		EP_BindCMode(PatchObject* spl, IObjParam *i) :
			fgProc((ReferenceTarget*)spl), eproc(spl,i) {pobj=spl;}

		int Class() { return MODIFY_COMMAND; }
		int ID() { return CID_EP_BIND; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints=2; return &eproc; }
		ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
		BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
		void EnterMode();
		void ExitMode();
//		void SetType(int type) { this->type = type; eproc.SetType(type); }
	};


class EP_ExtrudeMouseProc : public MouseCallBack {
private:
	MoveTransformer moveTrans;
	PatchObject *po;
	Interface *ip;
	IPoint2 om;
	Point3 ndir;
public:
	EP_ExtrudeMouseProc(PatchObject* o, IObjParam *i) : moveTrans(i) {po=o;ip=i;}
	int proc(HWND hwnd, int msg, int point, int flags, IPoint2 m);
};


class EP_ExtrudeSelectionProcessor : public GenModSelectionProcessor {
protected:
	HCURSOR GetTransformCursor();
public:
	EP_ExtrudeSelectionProcessor(EP_ExtrudeMouseProc *mc, PatchObject *o, IObjParam *i) 
		: GenModSelectionProcessor(mc,(BaseObject*) o,i) {}
};


class EP_ExtrudeCMode : public CommandMode {
private:
	ChangeFGObject fgProc;
	EP_ExtrudeSelectionProcessor mouseProc;
	EP_ExtrudeMouseProc eproc;
	PatchObject* po;

public:
	EP_ExtrudeCMode(PatchObject* o, IObjParam *i) :
		fgProc((ReferenceTarget *)o), mouseProc(&eproc,o,i), eproc(o,i) {po=o;}
	int Class() { return MODIFY_COMMAND; }
	int ID() { return CID_EP_EXTRUDE; }
	MouseCallBack *MouseProc(int *numPoints) { *numPoints=2; return &mouseProc; }
	ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
	BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
	void EnterMode();
	void ExitMode();
};




class EP_BevelMouseProc : public MouseCallBack {
private:
	MoveTransformer moveTrans;
	PatchObject *po;
	Interface *ip;
	IPoint2 om;
	
public:
	EP_BevelMouseProc(PatchObject* o, IObjParam *i) : moveTrans(i) {po=o;ip=i;}
	int proc(HWND hwnd, int msg, int point, int flags, IPoint2 m);
};


class EP_BevelSelectionProcessor : public GenModSelectionProcessor {
protected:
	HCURSOR GetTransformCursor();
public:
	EP_BevelSelectionProcessor(EP_BevelMouseProc *mc, PatchObject *o, IObjParam *i) 
		: GenModSelectionProcessor(mc,(BaseObject*) o,i) {}
};


class EP_BevelCMode : public CommandMode {
private:
	ChangeFGObject fgProc;
	EP_BevelSelectionProcessor mouseProc;
	EP_BevelMouseProc eproc;
	PatchObject* po;

public:
	EP_BevelCMode(PatchObject* o, IObjParam *i) :
		fgProc((ReferenceTarget *)o), mouseProc(&eproc,o,i), eproc(o,i) {po=o;}
	int Class() { return MODIFY_COMMAND; }
	int ID() { return CID_EP_BEVEL; }
	MouseCallBack *MouseProc(int *numPoints) { *numPoints=3; return &mouseProc; }
	ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
	BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
	void EnterMode();
	void ExitMode();
};





class POPickPatchAttach : 
		public PickModeCallback,
		public PickNodeCallback {
	public:		
		PatchObject *po;
		
		POPickPatchAttach() {po=NULL;}

		BOOL HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);
		BOOL Pick(IObjParam *ip,ViewExp *vpt);

		void EnterMode(IObjParam *ip);
		void ExitMode(IObjParam *ip);

		HCURSOR GetHitCursor(IObjParam *ip);

		BOOL Filter(INode *node);
		
		PickNodeCallback *GetFilter() {return this;}

		BOOL RightClick(IObjParam *ip,ViewExp *vpt)	{return TRUE;}
	};

// The Base Patch class
class PatchObject: public GeomObject, IPatchOps, IPatchSelect, IPatchSelectData, ISubMtlAPI, AttachMatDlgUser {
	friend class PatchObjectRestore;
	friend class POXFormProc;
	friend class POPickPatchAttach;
	public:
		static HWND hSelectPanel, hOpsPanel, hSurfPanel;
		static BOOL rsSel, rsOps, rsSurf;	// rollup states (FALSE = rolled up)
		static MoveModBoxCMode *moveMode;
		static RotateModBoxCMode *rotMode;
		static UScaleModBoxCMode *uscaleMode;
		static NUScaleModBoxCMode *nuscaleMode;
		static SquashModBoxCMode *squashMode;
		static SelectModBoxCMode *selectMode;
//watje command mode for the bind 		
		static EP_BindCMode *bindMode;
//watje command mode for the extrude 		
		static EP_ExtrudeCMode *extrudeMode;
		static EP_BevelCMode *bevelMode;

		// for the tessellation controls
		static BOOL settingViewportTess;  // are we doing viewport or renderer
		static BOOL settingDisp;  // are we doing viewport or renderer
		static ISpinnerControl *uSpin;
		static ISpinnerControl *vSpin;
		static ISpinnerControl *edgeSpin;
		static ISpinnerControl *angSpin;
		static ISpinnerControl *distSpin;
		static ISpinnerControl *mergeSpin;
		static ISpinnerControl *matSpin;
		// General rollup controls
		static ISpinnerControl *weldSpin;
		static ISpinnerControl *stepsSpin;
//3-18-99 watje to support render steps
		static ISpinnerControl *stepsRenderSpin;

		static POPickPatchAttach pickCB;
		static BOOL patchUIValid;
		static BOOL opsUIValid;
		static int attachMat;
		static BOOL condenseMat;

		// Load reference version
		int loadRefVersion;

		Interval geomValid;
		Interval topoValid;
		Interval texmapValid;
		Interval selectValid;
		DWORD validBits; // for the remaining constant channels
		void CopyValidity(PatchObject *fromOb, ChannelMask channels);

		//  inherited virtual methods for Reference-management
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message );

		static IObjParam *ip;		
		PatchMesh patch;

		MasterPointControl	*masterCont;		// Master track controller
		Tab<Control*> vertCont;
		Tab<Control*> vecCont;

		// Remembered info
		PatchMesh *rememberedPatch;	// NULL if using all selected patches
		int rememberedIndex;
		int rememberedData;

		// Editing stuff:
		BOOL doingHandles;

		BOOL showMesh;
		BOOL lockedHandles;
		BOOL propagate;

		BOOL inExtrude,inBevel;

		// Named selection sets:
		GenericNamedSelSetList vselSet;  // Vertex
		GenericNamedSelSetList eselSet;  // Edge
		GenericNamedSelSetList pselSet;  // Patch

		CoreExport PatchObject();
		CoreExport PatchObject(PatchObject &from);

		CoreExport PatchObjectInit();	// Constructor helper

		CoreExport ~PatchObject();

		CoreExport PatchObject &operator=(PatchObject &from);

		//  inherited virtual methods:

		// From BaseObject
		CoreExport int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt);
		CoreExport int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc);
		CoreExport int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
		CoreExport void Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt);
		CoreExport CreateMouseCallBack* GetCreateMouseCallBack();
		CoreExport RefTargetHandle Clone(RemapDir& remap = NoRemap());

		// From Object			 
		CoreExport Interval ObjectValidity(TimeValue t);
		CoreExport BOOL GetExtendedProperties(TimeValue t, TSTR &prop1Label, TSTR &prop1Data, TSTR &prop2Label, TSTR &prop2Data);
        CoreExport BOOL PolygonCount(TimeValue t, int& numFaces, int& numVerts);

		// get and set the validity interval for the nth channel
	   	CoreExport Interval ChannelValidity(TimeValue t, int nchan);
		CoreExport void SetChannelValidity(int i, Interval v);
		CoreExport void InvalidateChannels(ChannelMask channels);
		CoreExport void TopologyChanged(); // mjm - 5.6.99

		// Convert-to-type validity
		CoreExport Interval ConvertValidity(TimeValue t);

		// Deformable object procs	
		virtual int IsDeformable() { return 1; }  
		CoreExport int NumPoints();
		CoreExport Point3 GetPoint(int i);
		CoreExport void SetPoint(int i, const Point3& p);
		CoreExport BOOL IsPointSelected (int i);
		
		CoreExport void PointsWereChanged();
		CoreExport void GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm=NULL,BOOL useSel=FALSE );
		CoreExport void Deform(Deformer *defProc, int useSel);

		virtual BOOL IsParamSurface() {return TRUE;}
		CoreExport  Point3 GetSurfacePoint(TimeValue t, float u, float v,Interval &iv);

		// Mappable object procs
		virtual int IsMappable() { return 1; }
		virtual int NumMapChannels () { return patch.NumMapChannels (); }
		virtual int NumMapsUsed () { return patch.getNumMaps(); }
		virtual void ApplyUVWMap(int type, float utile, float vtile, float wtile,
			int uflip, int vflip, int wflip, int cap,const Matrix3 &tm,int channel=1) {
				patch.ApplyUVWMap(type,utile,vtile,wtile,uflip,vflip,wflip,cap,tm,channel); }

		CoreExport int CanConvertToType(Class_ID obtype);
		CoreExport Object* ConvertToType(TimeValue t, Class_ID obtype);
		CoreExport void GetCollapseTypes(Tab<Class_ID> &clist,Tab<TSTR*> &nlist);
		CoreExport void FreeChannels(ChannelMask chan);
		CoreExport Object *MakeShallowCopy(ChannelMask channels);
		CoreExport void ShallowCopy(Object* fromOb, ChannelMask channels);
		CoreExport void NewAndCopyChannels(ChannelMask channels);

		CoreExport DWORD GetSubselState();

		// From GeomObject
		CoreExport int IntersectRay(TimeValue t, Ray& ray, float& at, Point3& norm);
		CoreExport void GetWorldBoundBox(TimeValue t, INode *inode, ViewExp* vpt, Box3& box );
		CoreExport void GetLocalBoundBox(TimeValue t, INode *inode, ViewExp* vpt, Box3& box );
		CoreExport int IsInstanceDependent();	// Not view-dependent (yet)
		CoreExport Mesh* GetRenderMesh(TimeValue t, INode *inode, View& view, BOOL& needDelete);

		CoreExport PatchMesh& GetPatchMesh(TimeValue t);
		CoreExport Mesh& GetMesh(TimeValue t);

		// Animatable methods

		virtual void DeleteThis() { delete this; }
		virtual void FreeCaches() {patch.InvalidateGeomCache(); }
		virtual Class_ID ClassID() { return Class_ID(PATCHOBJ_CLASS_ID,0); }
		CoreExport BOOL IsSubClassOf(Class_ID classID);
		CoreExport virtual void GetClassName(TSTR& s);
		CoreExport void* GetInterface(ULONG id);
		// This is the name that will appear in the history browser.
		CoreExport virtual TCHAR *GetObjectName();

		// Controller stuff for animatable points
		int NumSubs()  { return 1; }	// Just tell it about the master point controller
		CoreExport Animatable* SubAnim(int i);
		CoreExport TSTR SubAnimName(int i);
		CoreExport BOOL AssignController(Animatable *control,int subAnim);
		int SubNumToRefNum(int subNum) {return subNum;}
		CoreExport BOOL SelectSubAnim(int subNum);
		CoreExport BOOL HasControllers(BOOL assertCheck=TRUE);

		// Reference methods
		CoreExport void RescaleWorldUnits(float f);
		int NumRefs() {return vertCont.Count() + vecCont.Count() + 1;}	// vert conts + vec conts + master
		CoreExport RefTargetHandle GetReference(int i);
		CoreExport void SetReference(int i, RefTargetHandle rtarg);
		CoreExport int RemapRefOnLoad(int iref);
		CoreExport void PlugControllersSel(TimeValue t);
		CoreExport void AllocVertContArray(int count);
		CoreExport void AllocVecContArray(int count);
		CoreExport void AllocContArrays(int vertCount, int vecCount);
		CoreExport void ReplaceVertContArray(Tab<Control *> &nc);
		CoreExport void ReplaceVecContArray(Tab<Control *> &nc);
		CoreExport void ReplaceContArrays(Tab<Control *> &vertnc, Tab<Control *> &vecnc);
		CoreExport BOOL PlugVertControl(TimeValue t,int i);
		CoreExport BOOL PlugVecControl(TimeValue t,int i);
		CoreExport void SetVertAnim(TimeValue t, int point, Point3 pt);
		CoreExport void SetVecAnim(TimeValue t, int point, Point3 pt);
		CoreExport void SetVertCont(int i, Control *c);
		CoreExport void SetVecCont(int i, Control *c);

		// IO
		CoreExport IOResult Save(ISave *isave);
		CoreExport IOResult Load(ILoad *iload);

		// PatchObject-specific methods
		CoreExport virtual void UpdatePatchMesh(TimeValue t);
		CoreExport void PrepareMesh(TimeValue t);
		CoreExport BOOL ShowLattice() { return patch.GetDispFlag(DISP_LATTICE) ? TRUE : FALSE; }
		CoreExport BOOL ShowVerts() { return patch.GetDispFlag(DISP_VERTS) ? TRUE : FALSE; }
		CoreExport void SetShowLattice(BOOL sw) { if(sw) patch.SetDispFlag(DISP_LATTICE); else patch.ClearDispFlag(DISP_LATTICE); }
		CoreExport void SetShowVerts(BOOL sw) { if(sw) patch.SetDispFlag(DISP_VERTS); else patch.ClearDispFlag(DISP_VERTS); }
		CoreExport void SetMeshSteps(int steps);
		CoreExport int GetMeshSteps();
//3-18-99 watje to support render steps
		CoreExport void SetMeshStepsRender(int steps);
		CoreExport int GetMeshStepsRender();
		CoreExport void SetShowInterior(BOOL si);
		CoreExport BOOL GetShowInterior();

		CoreExport void SetAdaptive(BOOL sw);
		CoreExport BOOL GetAdaptive();
		CoreExport void SetViewTess(TessApprox tess);
		CoreExport TessApprox GetViewTess();
		CoreExport void SetProdTess(TessApprox tess);
		CoreExport TessApprox GetProdTess();
		CoreExport void SetDispTess(TessApprox tess);
		CoreExport TessApprox GetDispTess();
		CoreExport BOOL GetViewTessNormals();
		CoreExport void SetViewTessNormals(BOOL use);
		CoreExport BOOL GetProdTessNormals();
		CoreExport void SetProdTessNormals(BOOL use);
		CoreExport BOOL GetViewTessWeld();
		CoreExport void SetViewTessWeld(BOOL weld);
		CoreExport BOOL GetProdTessWeld();
		CoreExport void SetProdTessWeld(BOOL weld);
		CoreExport void InvalidateMesh();

		// Editable patch stuff follows...
		CoreExport virtual void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
		CoreExport virtual void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		CoreExport int GetSubobjectLevel();
		CoreExport void SetSubobjectLevel(int level);
		CoreExport void ActivateSubobjSel(int level, XFormModes& modes );
		CoreExport int SubObjectIndex(HitRecord *hitRec);
		CoreExport void GetSubObjectTMs(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);
		CoreExport void GetSubObjectCenters(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);
		int NeedUseSubselButton() { return 0; }
		CoreExport void SelectSubComponent( HitRecord *hitRec, BOOL selected, BOOL all, BOOL invert );
		CoreExport void ClearSelection(int selLevel);
		CoreExport void SelectAll(int selLevel);
		CoreExport void InvertSelection(int selLevel);
		
		CoreExport void PatchSelChanged();
		CoreExport void InvalidateSurfaceUI();
		CoreExport void InvalidateOpsUI();

		CoreExport void ChangeRememberedPatch(int type);
		CoreExport void ChangeSelPatches(int type);
		CoreExport int RememberPatchThere(HWND hWnd, IPoint2 m);
		CoreExport void SetRememberedPatchType(int type);
		CoreExport void ChangeRememberedVert(int type);
		CoreExport void ChangeSelVerts(int type);
		CoreExport int RememberVertThere(HWND hWnd, IPoint2 m);
		CoreExport void SetRememberedVertType(int type);

		// Generic xform procedure.
		CoreExport void XFormVerts( POXFormProc *xproc, TimeValue t, Matrix3& partm, Matrix3& tmAxis );

		// Specialized xform for bezier handles
		CoreExport void XFormHandles( POXFormProc *xproc, TimeValue t, Matrix3& partm, Matrix3& tmAxis, int handleIndex );

		// Affine transform methods		
		CoreExport void Move( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin=FALSE );
		CoreExport void Rotate( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Quat& val, BOOL localOrigin=FALSE );
		CoreExport void Scale( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin=FALSE );

		// The following is called before the first Move(), Rotate() or Scale() call
		CoreExport void TransformStart(TimeValue t);

		// The following is called after the user has completed the Move, Rotate or Scale operation and
		// the undo object has been accepted.
		CoreExport void TransformFinish(TimeValue t);		

		// The following is called when the transform operation is cancelled by a right-click and the undo
		// has been cancelled.
		CoreExport void TransformCancel(TimeValue t);		

		CoreExport ObjectState Eval(TimeValue t);

		BOOL SupportsNamedSubSels() {return TRUE;}
		CoreExport void ActivateSubSelSet(TSTR &setName);
		CoreExport void NewSetFromCurSel(TSTR &setName);
		CoreExport void RemoveSubSelSet(TSTR &setName);
		CoreExport void SetupNamedSelDropDown();
		CoreExport int NumNamedSelSets();
		CoreExport TSTR GetNamedSelSetName(int i);
		CoreExport void SetNamedSelSetName(int i,TSTR &newName);
		CoreExport void NewSetByOperator(TSTR &newName,Tab<int> &sets,int op);
		CoreExport BOOL GetUniqueSetName(TSTR &name);
		CoreExport int SelectNamedSet();
		CoreExport void NSCopy();
		CoreExport void NSPaste();
		CoreExport GenericNamedSelSetList &GetSelSet();

		CoreExport void RefreshSelType();
		CoreExport void SetNumSelLabel();
		CoreExport void SetSelDlgEnables();
		CoreExport void SetOpsDlgEnables();
		CoreExport void SetSurfDlgEnables();

		// from AttachMatDlgUser
		int GetAttachMat() { return attachMat; }
		void SetAttachMat(int value) { attachMat = value; }
		BOOL GetCondenseMat() { return condenseMat; }
		void SetCondenseMat(BOOL sw) { condenseMat = sw; }

		CoreExport void DoAttach(INode *node, PatchMesh *attPatch, bool & canUndo);
		CoreExport void SetTessUI(HWND hDlg, TessApprox *tess);
		CoreExport void DoDeleteSelected();
		CoreExport void ResolveTopoChanges();
		CoreExport void DeletePatchParts(BitArray &delVerts, BitArray &delPatches);
		// Animated point stuff:
		CoreExport void CreateContArrays();
		CoreExport void SynchContArrays();
		// Materials
		CoreExport int GetSelMatIndex();
		CoreExport void SetSelMatIndex(int index);
		CoreExport void SelectByMat(int index,BOOL clear);
		// Smoothing
		CoreExport DWORD GetSelSmoothBits(DWORD &invalid);
		CoreExport DWORD GetUsedSmoothBits();
		CoreExport void SelectBySmoothGroup(DWORD bits,BOOL clear);
		CoreExport void SetSelSmoothBits(DWORD bits,DWORD which);
		// Subdivision / addition
		CoreExport void SetPropagate(BOOL sw);
		CoreExport BOOL GetPropagate();
		CoreExport void DoPatchAdd(int type);
		CoreExport void DoSubdivide(int level);
		CoreExport void DoPatchDetach(int copy, int reorient);
		// Welding
		CoreExport void DoVertWeld();
//watje
		//hide and unhide stuff
		CoreExport void DoHide(int type) ;
		CoreExport void DoUnHide();
		CoreExport void DoPatchHide();
		CoreExport void DoVertHide();
		CoreExport void DoEdgeHide();
//watje hook stuff
		CoreExport void DoAddHook(int vert1, int seg1) ;
		CoreExport void DoRemoveHook() ;
//watje bevel and extrusion stuff
		CoreExport void DoExtrude() ;
		CoreExport void BeginExtrude(TimeValue t); 	
		CoreExport void EndExtrude (TimeValue t, BOOL accept=TRUE);		
		CoreExport void Extrude( TimeValue t, float amount, BOOL useLocalNorm );

		
		CoreExport void DoBevel() ;
		CoreExport void BeginBevel(TimeValue t); 	
		CoreExport void EndBevel (TimeValue t, BOOL accept=TRUE);		
		CoreExport void Bevel( TimeValue t, float amount, BOOL smoothStart, BOOL smoothEnd );

		// patch select and operations interfaces, JBW 2/2/99
		CoreExport void StartCommandMode(patchCommandMode mode);
		CoreExport void ButtonOp(patchButtonOp opcode);

		CoreExport DWORD GetSelLevel();
		CoreExport void SetSelLevel(DWORD level);
		CoreExport void LocalDataChanged();

		CoreExport BitArray GetVertSel();
		CoreExport BitArray GetEdgeSel();
		CoreExport BitArray GetPatchSel();
		
		CoreExport void SetVertSel(BitArray &set, IPatchSelect *imod, TimeValue t);
		CoreExport void SetEdgeSel(BitArray &set, IPatchSelect *imod, TimeValue t);
		CoreExport void SetPatchSel(BitArray &set, IPatchSelect *imod, TimeValue t);

		CoreExport GenericNamedSelSetList& GetNamedVertSelList();
		CoreExport GenericNamedSelSetList& GetNamedEdgeSelList();
		CoreExport GenericNamedSelSetList& GetNamedPatchSelList();

		// ISubMtlAPI methods:
		CoreExport MtlID GetNextAvailMtlID(ModContext* mc);
		CoreExport BOOL HasFaceSelection(ModContext* mc);
		CoreExport void SetSelFaceMtlID(ModContext* mc, MtlID id, BOOL bResetUnsel = FALSE);
		CoreExport int GetSelFaceUniqueMtlID(ModContext* mc);
		CoreExport int GetSelFaceAnyMtlID(ModContext* mc);
		CoreExport int GetMaxMtlID(ModContext* mc);
};

CoreExport ClassDesc* GetPatchObjDescriptor();

// Helper classes used internally for undo operations

class POModRecord {
	public:
		virtual BOOL Restore(PatchObject *po, BOOL isUndo)=0;
		virtual BOOL Redo(PatchObject *po)=0;
		virtual DWORD Parts()=0;				// Flags of parts modified by this
	};

class PatchObjectRestore : public RestoreObj {
	public:
		POModRecord *rec;		// Modification record
		PatchObject	 *po;

		PatchObjectRestore(PatchObject *po, POModRecord *rec);
		~PatchObjectRestore();

		void Restore(int isUndo);
		void Redo();
		int Size() { return 1; }
		void EndHold() {po->ClearAFlag(A_HELD);}
		TSTR Description() { return TSTR(_T("PatchObject restore")); }
	};

#endif // __PATCHOBJ__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\plugin.h ===
#ifndef PLUGIN_H_DEFINED
#define PLUGIN_H_DEFINED

/*******************************************************************
 *
 *    DESCRIPTION: DLL Plugin classes
 *
 *    AUTHOR: Dan Silva
 *
 *    HISTORY: 11/30/94 Started coding
 *
 *******************************************************************/

typedef unsigned long ulong;

#include <plugapi.h>
//---------------------------------------------------------
// This is the interface to a DLL
// Each DLL may implement any number of classes. 
//
class DllDesc {
public:
	HINSTANCE		handle;
	TSTR fname;
    bool loaded;                         // if false, just basic info gleaned from Registry
	const TCHAR*	(*vDescription)();   // copy of this string can be stored in the DLL dir
	int				(*vNumClasses)();    // How many classes does this DLL implement?
    ClassDesc*		(*vClassDesc)(int i); // Hands back a ClassDesc for the ith class
	CoreExport	 	DllDesc(); 
	CoreExport void		 	Free() { FreeLibrary(handle); }
	CoreExport const TCHAR*	Description() { return (*vDescription)(); };
	CoreExport int 			NumberOfClasses() { return (*vNumClasses)(); };
	ClassDesc*		operator[](int i) { return (*vClassDesc)(i); };
	int operator==( const DllDesc& dd ) const { return 0; }

	TSTR tDescription;
	int tNumClasses;
	TSTR directory;
	};


/*-----------------------------------------------------------------
 We will build one big DllDir on startup.
 As we do this, we will build a set of lists, one for each SuperClass.
 For a given super class, we want to 
	(a) Enumerate all public subclasses 
	(b) Enumerate all subclasses
	(c) Find the subClass for a given subClass ID.

--------------------------------------------------------------*/

class ClassEntry {
	int dllNumber;  // index into the master Dll list
	int classNum;  	// index of the class within the DLL
	int isPublic;
	int useCount;  // used for enumerating classes in summary info
	Class_ID classID;
	TSTR name;
	TSTR category;
	ClassDesc *cd;
	bool loaded;
	
	// The following are use to store the last rollup state for a
	// given class. 'scroll' is the scroll amount of the command panel
	// and pageState is the open close state for up to 32 rollup pages. (when the bit is set that means the rollup page is closed)
	int scroll;
	DWORD pageState;
	
	public:
		CoreExport ClassEntry();
		CoreExport ClassEntry(const ClassEntry &ce);
		CoreExport ClassEntry(ClassDesc *cld, int dllN, int index, bool load);
		CoreExport ~ClassEntry();
		CoreExport void Set(ClassDesc *cld, int dllN, int index, bool load);
		int DllNumber() { return dllNumber; }
		int IsPublic() { return isPublic; }
		Class_ID ClassID() { return classID; }
		TSTR &ClassName() { return name; }
		TSTR &Category() { return category; }
		int GetScroll() {return scroll;}
		void SetScroll(int s) {scroll = s;}
		BOOL PageStateSet() {return pageState != 0x7fffffff;}  // test if pageState has been actually set, default initializes to 0x7fffffff
		BOOL GetPageState(int i) {return (pageState&(1<<i))?TRUE:FALSE;}
		void SetPageState(int i,BOOL state) {if (state) pageState |= (1<<i); else pageState &= ~(1<<i);}
		int UseCount() { return useCount; }
		void IncUseCount () { useCount++; }
	    void SetUseCount(int i) { useCount = i; }
		ClassDesc *CD() { return cd; }
		CoreExport int IsAccType(int accType);
		CoreExport ClassEntry& operator=( const ClassEntry &ce ); 
		int operator==( const ClassEntry &ce ) const { return 0; }
		bool IsLoaded() { return loaded; }
		int ClassNumber() { return classNum; }
		CoreExport ClassDesc *FullCD();
	};

// access type.
#define ACC_PUBLIC 1
#define ACC_PRIVATE 2
#define ACC_ALL (ACC_PUBLIC|ACC_PRIVATE)

typedef ClassEntry* PClassEntry;
typedef Tab<PClassEntry> SubClassTab;


//
// Class SClassUIInfo...
// Allows developer to provide some additional information on a superclass.
// Currently this includes a color, and a method which
// draws a representative image in a Windows DC.
// DrawRepresentation(...) can return false to indicate that no image was drawn.
// DrawRepresentation(...) should cache its image (if applicable) as the method
// is called repeatedly while drawing certain UI components (like the schematic
// view).
//

class SClassUIInfo
	{
	public:

	// A color associated with the superclass.  This is currently used to draw nodes
	// in the schematic view at extreme zoom-outs where it is impossible to draw
	// legible node names.
	CoreExport virtual COLORREF Color(SClass_ID superClassID) { return RGB(128, 128, 128); };

	// Draws an image which represents the superclass (usually an icon) in a rectangle
	// in a given Windows DC.  The implementation should attempt to draw the image as fast
	// as possible as this method is called repeatedly while drawing certain UI
	// components.  Return false if no image was drawn and a generic stand-in image will
	// be used.  The provided "bkColor" is the average background color of the surface on
	// which the image is being drawn.  It can be used, if desired, to antialias the image.
	CoreExport virtual bool DrawRepresentation(SClass_ID superClassID, COLORREF bkColor, HDC hDC, Rect &rect) { return false; }
	};

class SubClassList {
		int iEnum;
		ulong superID;
		SubClassTab subClList;
		SClassUIInfo *uiInfo;
    public:
		CoreExport ~SubClassList();
		SubClassList(ulong sid=0) { superID = sid; uiInfo = NULL; }
		ClassEntry& operator[](int i){ return(*subClList[i]);}
		CoreExport int FindClass(Class_ID subClassID);	  // Get a class by its class ID
		CoreExport int FindClass(const TCHAR *name);    // Get a class by its class name
		CoreExport void AddClass(ClassDesc *cld, int dllNum, int index, bool load); 
		CoreExport int  Count(int accType);
		ulong SuperID() { return superID; }
		int operator==(const SubClassList &sl) {return(0);}

		// Enumerate.
		CoreExport int GetFirst(int accType);	 // get first ClassDesc of accType
		CoreExport int GetNext(int accType);	 // get next ClassDesc of accType (NULL for End)

		int operator==( const SubClassList& lst ) const { return 0; }
		CoreExport int DeleteClass(ClassDesc *cld); 

		// Allows developer to provide some additional information on a superclass.
		// Currently this includes a descriptive string, a color, and a method which
		// draws a representative image in a Windows DC.
		CoreExport void SetUIInfo(SClassUIInfo *uiInfo);

		// Retrieves additional UI related information on a given superclass.  Returns
		// NULL if no superclass information was assigned.
		CoreExport SClassUIInfo *GetUIInfo();
		CoreExport void ReplaceClass(int idx, ClassDesc *cld, int dllNum, int index, bool load); 
	};


typedef SubClassList* PSubClassList;
typedef Tab<PSubClassList> ListOfClassLists;

/* ClassDirectory: A list of SubClassLists, one for each pluggable
   super class */
class ClassDirectory {
	ListOfClassLists cl;
	public:				  
		CoreExport ~ClassDirectory();
		CoreExport SubClassList* GetClassList(SClass_ID superClassID);	
		CoreExport ClassDesc* FindClass(SClass_ID superClassID, Class_ID subClassID);
		CoreExport ClassEntry *FindClassEntry(SClass_ID superClassID, Class_ID subClassID);
		SubClassList& operator[](int i){ return(*cl[i]);}
		CoreExport void AddSuperClass(SClass_ID superClassID);
		// returns 0 if class already exists
		// returns -1 if superclass was unknown
		// returns 1 if class added successfully
		CoreExport int  AddClass(ClassDesc *cdesc, int dllNum, int index, bool load);
		int Count() { return cl.Count(); }	
		CoreExport int DeleteClass(ClassDesc *cdesc);

		// Allows developer to provide some additional information on a superclass.
		// Currently this includes a descriptive string, a color, and a method which
		// draws a representative image in a Windows DC.
		// Function returns true if successful or false if the superclass was not found.
		CoreExport bool SetUIInfoForSClass(SClass_ID superClassID, SClassUIInfo *uiInfo);

		// Retrieves additional UI related information on a given superclass.  Returns
		// NULL if the superclass was not found or if no superclass information was
		// assigned.
		CoreExport SClassUIInfo *GetUIInfoForSClass(SClass_ID superClassID);
	};

/* DllDirectory: A list DllDescriptors, one for every DLL loaded 
   Also contains the ClassDirectory of all classes implemented in these
   DLL's */

typedef DllDesc *PDllDesc;

class DllDir {
	Tab<PDllDesc> dll;    // list of Descriptors for all the loaded DLL's
	ClassDirectory classDir; // All the classes implemented in these DLL's 
	int  AddDll(const DllDesc *dllDesc, bool late);
	public:
		CoreExport ~DllDir();
		CoreExport void UnloadAllDlls();
		int Count() { return dll.Count(); }
		DllDesc& operator[](int i) { return(*dll[i]); }
		CoreExport int LoadDllsFromDir(TCHAR *directory, TCHAR *  wildcard, HWND hwnd=NULL);
		ClassDirectory& ClassDir() { return classDir; }
		CoreExport bool LoadADll(TCHAR *, bool late);
	};


/* DataClassDesc: A ClassDesc for classes in plug-ins but described by
   Registry entries */

class DataClassDesc : public ClassDesc {
public:
	TSTR category;
	DWORD classIDA;
	DWORD classIDB;
	DWORD superClassID;
	TSTR className;
	DWORD isPublic;
	DWORD okToCreate;
	DWORD extCount;
	TSTR ext;
	TSTR shortDesc;
	TSTR longDesc;
	DWORD supportsOptions;
	DWORD capability;
	DWORD inputTypeA;	// For Modifiers
	DWORD inputTypeB;	// For Modifiers
	TSTR internalName;
	TCHAR* internalNamePtr;

	DataClassDesc() : internalNamePtr(NULL) {}
	~DataClassDesc();
	int IsPublic() { return isPublic; }
	void *Create(BOOL loading=FALSE) { return NULL; }
	int BeginCreate(Interface *i) { return 0; }
	int EndCreate(Interface *i) { return 0; }
	const TCHAR *ClassName() { return className; }
	SClass_ID SuperClassID() { return superClassID; }
	Class_ID ClassID() { return Class_ID(classIDA, classIDB); }
	const TCHAR *Category() { return category; }
	BOOL OkToCreate(Interface *i) { return okToCreate; }	
	BOOL HasClassParams() { return FALSE; }
	void EditClassParams(HWND hParent) {}
	void ResetClassParams(BOOL fileReset=FALSE) {}

    // These functions return keyboard shortcut tables that plug-ins can use
    int NumShortcutTables() { return 0; }
    ShortcutTable *GetShortcutTable(int i) { return NULL; }

	// Class IO
	BOOL NeedsToSave() { return FALSE; }
	IOResult Save(ISave *isave) { return IO_OK; }
	IOResult Load(ILoad *iload) { return IO_OK; }

	// bits of dword set indicate corrresponding rollup page is closed.
	// the value 0x7fffffff is returned by the default implementation so the
	// command panel can detect this method is not being overridden, and just leave 
	// the rollups as is.
	DWORD InitialRollupPageState() { return 0x7fffffff; }

	// ParamBlock2-related metadata interface, supplied & implemented in ClassDesc2 (see maxsdk\include\iparamb2.h)
	
	const TCHAR *InternalName() { return internalNamePtr; }
	HINSTANCE HInstance() { return NULL; }
	// access parameter block descriptors for this class
	int NumParamBlockDescs() { return 0; }
	ParamBlockDesc2 *GetParamBlockDesc(int i) { return NULL; }
	ParamBlockDesc2 *GetParamBlockDescByID(BlockID id) { return NULL; }
	void AddParamBlockDesc(ParamBlockDesc2* pbd) {}
	// automatic UI management
	void BeginEditParams(IObjParam *ip, ReferenceMaker* obj, ULONG flags, Animatable *prev) {}
	void EndEditParams(IObjParam *ip, ReferenceMaker* obj, ULONG flags, Animatable *prev) {}
	void InvalidateUI(ParamBlockDesc2* pbd) {}
	// automatic ParamBlock construction
	void MakeAutoParamBlocks(ReferenceMaker* owner) {}
	// access automatically-maintained ParamMaps, by simple index or by associated ParamBlockDesc
	int NumParamMaps() { return 0; }
	IParamMap2 *GetParamMap(int i) { return NULL; }
	IParamMap2 *GetParamMap(ParamBlockDesc2* pbd) { return NULL; }
	// maintain user dialog procs on automatically-maintained ParamMaps
	void SetUserDlgProc(ParamBlockDesc2* pbd, ParamMap2UserDlgProc* proc=NULL) {}
	ParamMap2UserDlgProc *GetUserDlgProc(ParamBlockDesc2* pbd) { return NULL; }

	// Class can draw an image to represent itself graphically...
	bool DrawRepresentation(COLORREF bkColor, HDC hDC, Rect &rect) { return FALSE; }
};


#endif // PLUGIN_H_DEFINED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\polyobj.h ===
/**********************************************************************
 *<
	FILE: polyobj.h

	DESCRIPTION:  Defines Polygon Mesh Object

	CREATED BY: Steve Anderson

	HISTORY: created June 1998

 *>	Copyright (c) 1998, All Rights Reserved.
 **********************************************************************/

#ifndef __POLYOBJ__ 

#define __POLYOBJ__

#include "meshlib.h"
#include "mnmath.h"
#include "snap.h"

#define POLY_MULTI_PROCESSING TRUE

extern CoreExport Class_ID polyObjectClassID;

class PolyObject: public GeomObject {
protected:
	Interval geomValid;
	Interval topoValid;
	Interval texmapValid;
	Interval selectValid;
	Interval vcolorValid;
	DWORD validBits; // for the remaining constant channels
	CoreExport void CopyValidity(PolyObject *fromOb, ChannelMask channels);
	//  inherited virtual methods for Reference-management
	CoreExport RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message );
public:
	MNMesh mm;

	CoreExport PolyObject();
	CoreExport ~PolyObject();

	//  inherited virtual methods:

	// From BaseObject
	CoreExport int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt);
	CoreExport int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
	CoreExport void Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt);
	CoreExport CreateMouseCallBack* GetCreateMouseCallBack() { return NULL; }
	CoreExport RefTargetHandle Clone(RemapDir& remap = NoRemap());

	// From Object			 
	CoreExport ObjectState Eval(TimeValue time);
	CoreExport Interval ObjectValidity(TimeValue t);
	CoreExport BOOL HasUVW();
	CoreExport BOOL HasUVW(int mapChannel);

	// get and set the validity interval for the nth channel
	CoreExport Interval ChannelValidity (int nchan);
	CoreExport Interval PartValidity (DWORD partIDs);
	CoreExport void SetChannelValidity (int i, Interval v);
	CoreExport void SetPartValidity (DWORD partIDs, Interval v);
	CoreExport void InvalidateChannels (ChannelMask channels);

	// Convert-to-type validity
	CoreExport Interval ConvertValidity(TimeValue t);

	// Deformable object procs	
	int IsDeformable() { return 1; }  
	CoreExport int NumPoints();
	CoreExport Point3 GetPoint(int i);
	CoreExport void SetPoint(int i, const Point3& p);
	CoreExport void PointsWereChanged();
	CoreExport void Deform (Deformer *defProc, int useSel=0);

	// Mappable object procs
	int IsMappable() { return 1; }
	CoreExport void ApplyUVWMap(int type, float utile, float vtile, float wtile,
		int uflip, int vflip, int wflip, int cap,const Matrix3 &tm,int channel=1);

	CoreExport void GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm=NULL,BOOL useSel=FALSE );

	CoreExport int CanConvertToType(Class_ID obtype);
	CoreExport Object* ConvertToType(TimeValue t, Class_ID obtype);
	CoreExport void FreeChannels(ChannelMask chan);
	CoreExport Object *MakeShallowCopy(ChannelMask channels);
	CoreExport void ShallowCopy(Object* fromOb, ChannelMask channels);
	CoreExport void NewAndCopyChannels(ChannelMask channels);

	CoreExport DWORD GetSubselState();
	CoreExport void SetSubSelState(DWORD s);

	CoreExport BOOL CheckObjectIntegrity();

	// From GeomObject
	CoreExport int IntersectRay(TimeValue t, Ray& ray, float& at, Point3& norm);
	CoreExport ObjectHandle CreateTriObjRep(TimeValue t);  // for rendering, also for deformation		
	CoreExport void GetWorldBoundBox(TimeValue t, INode *inode, ViewExp* vpt, Box3& box );
	CoreExport void GetLocalBoundBox(TimeValue t, INode *inode, ViewExp* vpt, Box3& box );
	CoreExport Mesh* GetRenderMesh(TimeValue t, INode *inode, View &view,  BOOL& needDelete);

	CoreExport void TopologyChanged();

	MNMesh& GetMesh() { return mm; }

	// Animatable methods

	void DeleteThis() { delete this; }
	void FreeCaches() {mm.InvalidateGeomCache(); }
	Class_ID ClassID() { return Class_ID(POLYOBJ_CLASS_ID,0); }
	void GetClassName(TSTR& s) { s = TSTR(_T("PolyMeshObject")); }
	void NotifyMe(Animatable *subAnim, int message) {}
	int IsKeyable() { return 0;}
	int Update(TimeValue t) { return 0; }
	//BOOL BypassTreeView() { return TRUE; }
	// This is the name that will appear in the history browser.
	TCHAR *GetObjectName() { return _T("PolyMesh"); }
	CoreExport void RescaleWorldUnits(float f);

	// IO
	CoreExport IOResult Save(ISave *isave);
	CoreExport IOResult Load(ILoad *iload);
};

// Regular PolyObject
CoreExport ClassDesc* GetPolyObjDescriptor();

// A new descriptor can be registered to replace the default
// tri object descriptor. This new descriptor will then
// be used to create tri objects.

CoreExport void RegisterEditPolyObjDesc(ClassDesc* desc);
CoreExport ClassDesc* GetEditPolyObjDesc(); // Returns default of none have been registered

// Use this instead of new PolyObject. It will use the registered descriptor
// if one is registered, otherwise you'll get a default poly-object.
CoreExport PolyObject *CreateNewPolyObject();


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\point4.h ===
/**********************************************************************
 *<
	FILE: point4.h

	DESCRIPTION: Class definitions for Point4

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef _POINT4_H 

#define _POINT4_H

#include "point3.h"

class DllExport Point4 {
public:
	float x,y,z,w;

	// Constructors
	Point4(){}
	Point4(float X, float Y, float Z, float W)  { x = X; y = Y; z = Z; w = W; }
	Point4(double X, double Y, double Z, double W) { x = (float)X; y = (float)Y; z = (float)Z; w = (float)W; }
	Point4(int X, int Y, int Z, int W) { x = (float)X; y = (float)Y; z = (float)Z; w = (float)W; }
	Point4(const Point3& a, float W=0.0f) { x = a.x; y = a.y; z = a.z; w = W; } 
	Point4(const Point4& a) { x = a.x; y = a.y; z = a.z; w = a.w; } 
	Point4(float af[4]) { x = af[0]; y = af[1]; z = af[2]; w = af[3]; }

    // Data members
    static const Point4 Origin;
    static const Point4 XAxis;
    static const Point4 YAxis;
    static const Point4 ZAxis;
    static const Point4 WAxis;

	// Access operators
	float& operator[](int i) { return (&x)[i]; }     
	const float& operator[](int i) const { return (&x)[i]; }  

	// Conversion function
	operator float*() { return(&x); }

	// Unary operators
	Point4 operator-() const { return(Point4(-x,-y,-z, -w)); } 
	Point4 operator+() const { return *this; } 

	// Assignment operators
	inline Point4& operator-=(const Point4&);
	inline Point4& operator+=(const Point4&);
	inline Point4& operator*=(float); 
	inline Point4& operator/=(float);
	inline Point4& operator*=(const Point4&);	// element-by-element multiply.
    inline Point4& Set(float X, float Y, float Z, float W);

	// Test for equality
	int operator==(const Point4& p) const { return ((p.x==x)&&(p.y==y)&&(p.z==z)&&(p.w==w)); }
	int operator!=(const Point4& p) const { return ((p.x!=x)||(p.y!=y)||(p.z!=z)||(p.w!=w)); }
    int Equals(const Point4& p, float epsilon = 1E-6f);

	// Binary operators
	inline  Point4 operator-(const Point4&) const;
	inline  Point4 operator+(const Point4&) const;
	inline  Point4 operator/(const Point4&) const;
	inline  Point4 operator*(const Point4&) const;   

	};

// Inlines:

inline Point4& Point4::operator-=(const Point4& a) {	
	x -= a.x;	y -= a.y;	z -= a.z; w -= a.w;
	return *this;
	}

inline Point4& Point4::operator+=(const Point4& a) {
	x += a.x;	y += a.y;	z += a.z; w += a.w;
	return *this;
	}

inline Point4& Point4::operator*=(float f) {
	x *= f;   y *= f;	z *= f; w *= f;
	return *this;
	}

inline Point4& Point4::operator/=(float f) { 
	if (f==0.0f) f = .000001f;
	x /= f;	y /= f;	z /= f;	 w /= f;
	return *this; 
	}

inline Point4& Point4::operator*=(const Point4& a) { 
	x *= a.x;	y *= a.y;	z *= a.z;	w *= a.w;
	return *this; 
	}

inline Point4& Point4::Set(float X, float Y, float Z, float W) {
    x = X;
    y = Y;
    z = Z;
    w = W;
    return *this;
    }

inline Point4 Point4::operator-(const Point4& b) const {
	return(Point4(x-b.x,y-b.y,z-b.z, w-b.w));
	}

inline Point4 Point4::operator+(const Point4& b) const {
	return(Point4(x+b.x,y+b.y,z+b.z, w+b.w));
	}

inline Point4 Point4::operator/(const Point4& b) const {
	return Point4(x/b.x,y/b.y,z/b.z,w/b.w);
	}

inline Point4 Point4::operator*(const Point4& b) const {  
	return Point4(x*b.x, y*b.y, z*b.z,w*b.w);	
	}

inline Point4 operator*(float f, const Point4& a) {
	return(Point4(a.x*f, a.y*f, a.z*f, a.w*f));
	}

inline Point4 operator*(const Point4& a, float f) {
	return(Point4(a.x*f, a.y*f, a.z*f, a.w*f));
	}

inline Point4 operator/(const Point4& a, float f) {
	return(Point4(a.x/f, a.y/f, a.z/f, a.w/f));
	}

inline Point4 operator+(const Point4& a, float f) {
	return(Point4(a.x+f, a.y+f, a.z+f, a.w+f));
	}

inline int Point4::Equals(const Point4& p, float epsilon) {
    return (fabs(p.x - x) <= epsilon && fabs(p.y - y) <= epsilon
            && fabs(p.z - z) <= epsilon && fabs(p.w - w) <= epsilon);
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\point3.h ===
/**********************************************************************
 *<
	FILE: point3.h

	DESCRIPTION: Class definitions for Point3

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef _POINT3_H 

#define _POINT3_H


#include "gfloat.h"

class DllExport Point3 {
public:
	float x,y,z;

	// Constructors
	Point3(){}
	Point3(float X, float Y, float Z)  { x = X; y = Y; z = Z;  }
	Point3(double X, double Y, double Z) { x = (float)X; y = (float)Y; z = (float)Z; }
	Point3(int X, int Y, int Z) { x = (float)X; y = (float)Y; z = (float)Z; }
	Point3(const Point3& a) { x = a.x; y = a.y; z = a.z; } 
	Point3(float af[3]) { x = af[0]; y = af[1]; z = af[2]; }

    // Data members
    static const Point3 Origin;
    static const Point3 XAxis;
    static const Point3 YAxis;
    static const Point3 ZAxis;

	// Access operators
	float& operator[](int i) { return (&x)[i]; }     
	const float& operator[](int i) const { return (&x)[i]; }  

	// Conversion function
	operator float*() { return(&x); }

	// Unary operators
	Point3 operator-() const { return(Point3(-x,-y,-z)); } 
	Point3 operator+() const { return *this; }
    
    // Property functions
    float Length() const;
    float FLength() const;
    float LengthSquared() const;
    int MaxComponent() const;
    int MinComponent() const;
    Point3 Normalize() const;     // more accurate than FNormalize()
    Point3 FNormalize() const;    // faster than Normalize()

	// Assignment operators
	inline Point3& operator-=(const Point3&);
	inline Point3& operator+=(const Point3&);
	inline Point3& operator*=(float); 
	inline Point3& operator/=(float);
	inline Point3& operator*=(const Point3&);	// element-by-element multiply.

    inline Point3& Set(float X, float Y, float Z);

	// Test for equality
	int operator==(const Point3& p) const { return ((p.x==x)&&(p.y==y)&&(p.z==z)); }
	int operator!=(const Point3& p) const { return ((p.x!=x)||(p.y!=y)||(p.z!=z)); }
    int Equals(const Point3& p, float epsilon = 1E-6f) const;

    // In-place normalize
    Point3& Unify();
    float LengthUnify();              // returns old Length

	// Binary operators
	inline  Point3 operator-(const Point3&) const;
	inline  Point3 operator+(const Point3&) const;
	inline  Point3 operator/(const Point3&) const;
	inline  Point3 operator*(const Point3&) const;   

	Point3 operator^(const Point3&) const;	// CROSS PRODUCT
	inline float operator%(const Point3&) const;	    // DOT PRODUCT
	};


inline float DllExport Length(const Point3&); 
inline float DllExport FLength(const Point3&); 
inline float DllExport LengthSquared(const Point3&); 
int DllExport MaxComponent(const Point3&);  // the component with the maximum abs value
int DllExport MinComponent(const Point3&);  // the component with the minimum abs value
Point3 DllExport Normalize(const Point3&);  // Accurate normalize
Point3 DllExport FNormalize(const Point3&); // Fast normalize 


// RB: moved this here from object.h
class Ray {
	public:
		Point3 p;   // point of origin
		Point3 dir; // unit vector
	};

 
// Inlines:

inline float Point3::Length() const {	
	return (float)sqrt(x*x+y*y+z*z);
	}

inline float Point3::FLength() const {	
	return Sqrt(x*x+y*y+z*z);
	}

inline float Point3::LengthSquared() const {	
	return (x*x+y*y+z*z);
	}

inline float Length(const Point3& v) {	
	return v.Length();
	}

inline float FLength(const Point3& v) {	
	return v.FLength();
	}

inline float LengthSquared(const Point3& v) {	
	return v.LengthSquared();
	}

inline Point3& Point3::operator-=(const Point3& a) {	
	x -= a.x;	y -= a.y;	z -= a.z;
	return *this;
	}

inline Point3& Point3::operator+=(const Point3& a) {
	x += a.x;	y += a.y;	z += a.z;
	return *this;
	}

inline Point3& Point3::operator*=(float f) {
	x *= f;   y *= f;	z *= f;
	return *this;
	}

inline Point3& Point3::operator/=(float f) { 
	x /= f;	y /= f;	z /= f;	
	return *this; 
	}

inline Point3& Point3::operator*=(const Point3& a) { 
	x *= a.x;	y *= a.y;	z *= a.z;	
	return *this; 
	}

inline Point3& Point3::Set(float X, float Y, float Z) {
    x = X;
    y = Y;
    z = Z;
    return *this;
    }

inline Point3 Point3::operator-(const Point3& b) const {
	return(Point3(x-b.x,y-b.y,z-b.z));
	}

inline Point3 Point3::operator+(const Point3& b) const {
	return(Point3(x+b.x,y+b.y,z+b.z));
	}

inline Point3 Point3::operator/(const Point3& b) const {
	return Point3(x/b.x,y/b.y,z/b.z);
	}

inline Point3 Point3::operator*(const Point3& b) const {  
	return Point3(x*b.x, y*b.y, z*b.z);	
	}

inline float Point3::operator%(const Point3& b) const {
    return (x*b.x + y*b.y + z*b.z);
    }

inline Point3 operator*(float f, const Point3& a) {
	return(Point3(a.x*f, a.y*f, a.z*f));
	}

inline Point3 operator*(const Point3& a, float f) {
	return(Point3(a.x*f, a.y*f, a.z*f));
	}

inline Point3 operator/(const Point3& a, float f) {
	return(Point3(a.x/f, a.y/f, a.z/f));
	}

inline Point3 operator+(const Point3& a, float f) {
	return(Point3(a.x+f, a.y+f, a.z+f));
	}

inline float DotProd(const Point3& a, const Point3& b) { 
	return(a.x*b.x+a.y*b.y+a.z*b.z);	
	}

Point3 DllExport CrossProd(const Point3& a, const Point3& b);	// CROSS PRODUCT


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\point2.h ===
/**********************************************************************
 *<
	FILE: point2.h

	DESCRIPTION: Class definition for Point2

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __POINT2__ 

#define __POINT2__

class ostream;

class DllExport Point2 {
public:
	float x,y;

	// Constructors
	Point2(){}
	Point2(float X, float Y)  { x = X; y = Y;  }
	Point2(double X, double Y)  { x = (float)X; y = (float)Y;  }
	Point2(const Point2& a) { x = a.x; y = a.y; } 
	Point2(float af[2]) { x = af[0]; y = af[1]; }

    // Data members
    static const Point2 Origin;
    static const Point2 XAxis;
    static const Point2 YAxis;

	// Access operators
	float& operator[](int i) { return (&x)[i]; }     
	const float& operator[](int i) const { return (&x)[i]; }  
	
	// Conversion function
	operator float*() { return(&x); }

	// Unary operators
	Point2 operator-() const { return(Point2(-x,-y)); } 
	Point2 operator+() const { return *this; }
    
    // Property functions
    float Length() const;
    int MaxComponent() const;
    int MinComponent() const;
    Point2 Normalize() const; // more accurate than *this/Length();

	// Assignment operators
	Point2& operator-=(const Point2&);
	Point2& operator+=(const Point2&);
	Point2& operator*=(float);
	Point2& operator/=(float);

    Point2& Set(float X, float Y);

	// Binary operators
	Point2 operator-(const Point2&) const;
	Point2 operator+(const Point2&) const;
	float DotProd(const Point2&) const;		// DOT PRODUCT
	float operator*(const Point2&) const;	// DOT PRODUCT

	// Relational operators
	int operator==(const Point2& p) const { return (x == p.x && y == p.y); }
	int operator!=(const Point2& p) const { return ( (x != p.x) || (y != p.y) ); }
    int Equals(const Point2& p, float epsilon = 1E-6f);
    
    // In-place normalize
    Point2& Unify();
    float LengthUnify();          // returns old Length
    };


inline float DllExport Length(const Point2&); 
int DllExport MaxComponent(const Point2&);  // the component with the maximum abs value
int DllExport MinComponent(const Point2&);  // the component with the minimum abs value
Point2 DllExport Normalize(const Point2&);  // more accurate than v/Length(v)
	 
Point2 DllExport operator*(float, const Point2&);	// multiply by scalar
Point2 DllExport operator*(const Point2&, float);	// multiply by scalar
Point2 DllExport operator/(const Point2&, float);	// divide by scalar

ostream DllExport &operator<<(ostream&, const Point2&);
	 
// Inlines:

inline float Length(const Point2& v) {	
	return (float)sqrt(v.x*v.x+v.y*v.y);
	}

inline float Point2::Length() const {	
	return (float)sqrt(x*x+y*y);
	}

inline Point2& Point2::operator-=(const Point2& a) {	
	x -= a.x;	y -= a.y;  
	return *this;
	}

inline Point2& Point2::operator+=(const Point2& a) {
	x += a.x;	y += a.y;  
	return *this;
	}

inline Point2& Point2::operator*=(float f) {
	x *= f;   y *= f;	
	return *this;
	}

inline Point2& Point2::operator/=(float f) { 
	x /= f;	y /= f;		
	return *this; 
	}

inline Point2& Point2::Set(float X, float Y) {
    x = X; y = Y;
    return *this;
    }

inline Point2 Point2::operator-(const Point2& b) const{
	return(Point2(x-b.x,y-b.y));
	}

inline Point2 Point2::operator+(const Point2& b) const {
	return(Point2(x+b.x,y+b.y));
	}

inline float Point2::DotProd(const Point2& b) const{
	return(x*b.x+y*b.y);
	}

inline float Point2::operator*(const Point2& b)const {
	return(x*b.x+y*b.y);
	}

inline Point2 operator*(float f, const Point2& a) {
	return(Point2(a.x*f, a.y*f));
	}

inline Point2 operator*(const Point2& a, float f) {
	return(Point2(a.x*f, a.y*f));
	}

inline Point2 operator/(const Point2& a, float f) {
	return(Point2(a.x/f, a.y/f));
	}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\PrintManager.h ===
// ****************************************************************************
//
// DESCRIPTION: Declaration of the Print Manager
// PATTERN    : Singleton
// CREATED BY : Michael Pittman
// HISTORY    : 12/21/1998
//
// ****************************************************************************
#pragma once

class PrintManager
{
private:
    static PrintManager* m_instance;    // Singleton instance
    HDC                  m_hdc;         // Device context of printer
    int                  m_ncopies;     // Number of copies to print
    bool                 m_landscape;   // Print in landscape?  

	PRINTDLG             m_pinfo;       // Printer info from PrintDlg
    PAGESETUPDLG         m_pgsetup;     // Page Setup info from PageSetupDlg
    DEVMODE              m_devmode;     // Device mode structure
    TCHAR                m_driver[128]; // Printer driver name
    TCHAR                m_device[33];  // Printer device name
    bool                 m_use_pgsetup; // User has chosen page setup

    PrintManager();

	bool SetupPrintFromDialog(HWND parent);
	bool SetupPrintExisting(void);
	bool SetupPrintDefault(void);

public:
	typedef enum { k_UseDefault, k_PromptUser, k_UseExisting } PrinterChoice;

    ~PrintManager();

	// Access to the singleton
    CoreExport static PrintManager* Instance(void);

	// Query methods
	CoreExport HDC GetPrinterDC(PrinterChoice getfrom = k_PromptUser);
    CoreExport HDC GetDefaultPrinterDC(void) { return GetPrinterDC(k_UseDefault); }
    CoreExport HDC GetExistingPrinterDC(void) { return GetPrinterDC(k_UseExisting); }
    CoreExport void ReleasePrinterDC(HDC hdc);
    CoreExport int NumberCopies(void) { return m_ncopies; }
    CoreExport bool DoLandscape(void) { return m_landscape; }

    // The standard print methods interface
    CoreExport bool OnPageSetup(HWND parent);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\ptrvec.h ===
/**********************************************************************
 *<
	FILE: ptrvec.h

	DESCRIPTION:  An variable length array of pointers

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __PTRVEC__H
#define __PTRVEC__H

class PtrVector {
	protected:
		int size;
		int nused;
		void** data;
		PtrVector() { size = nused = 0; data = NULL; }
		UtilExport ~PtrVector();
		UtilExport PtrVector(const PtrVector& v);
		UtilExport PtrVector&	operator=(const PtrVector& v);
	    UtilExport void append(void * ptr , int extra);
		UtilExport void insertAt(void * ptr , int at, int extra);
	    UtilExport void* remove(int i);
	    UtilExport void* removeLast();
		void* operator[](int i) const { return data[i]; }		
		void*& operator[](int i) { return data[i]; }		
	public:
		UtilExport void reshape(int i);  // sets capacity
		UtilExport void setLength(int i);  // sets length, capacity if necessary
		UtilExport void clear();	// deletes the ptr array, but not the objects
		void shrink() { reshape(nused); }
		int length() const { return nused; }
		int capacity() const { return size; }
	};

template <class T> class PtrVec: public PtrVector {
public:	
	PtrVec():PtrVector() {}
	T* operator[](int i) const { return (T*)PtrVector::operator[](i); }		
	T*& operator[](int i) { return (T*&)PtrVector::operator[](i); }				
	PtrVec<T>& operator=(const PtrVec<T>& v) { return (PtrVec<T>&)PtrVector::operator=(v); }
	void append(T *ptr, int extra = 10) { PtrVector::append(ptr,extra); }	
	void insertAt(T* ptr, int at, int extra=10) { PtrVector::insertAt(ptr,at,extra); }	 
	T* remove(int i) { return (T *)PtrVector::remove(i); }		
	T* removeLast() { return (T *)PtrVector::removeLast(); }		
	void deleteAll();  //  deletes all the objects		
	};

template <class T> 
void PtrVec<T>::deleteAll() {
	while (length()) {
		T* p = removeLast();
		delete p;
		}
	}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\props.h ===
/**********************************************************************
 *<
	FILE: props.h

	DESCRIPTION: Property ID definitions (for use  SetProperty and GetProperty)

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/


#ifndef __PROPS__H
#define __PROPS__H

#define PROP_NODE_BONE 	0x00000100
#define PROP_COLOR 		0x00000200
#define PROP_MASTER		0x00001000

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\polyshp.h ===
/**********************************************************************
 *<
	FILE: polyshp.h

	DESCRIPTION: Polyline shape methods

	CREATED BY: Tom Hudson

	HISTORY: Created 3 October 1995

 *> Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#ifndef __POLYSHP_H_

#define __POLYSHP_H_

#include "shphier.h"
#include "captypes.h"
#include "shpsels.h"	// Shape selection classes
#include "templt.h"

// Display flags
#define DISP_VERTTICKS		(1<<0)
//#define DISP_BEZHANDLES		(1<<1)
#define DISP_SELVERTS		(1<<10)
#define DISP_SELSEGMENTS	(1<<11)
#define DISP_SELPOLYS		(1<<13)

// Snap flags
#define PSHAPE_SNAP_IGNORELAST	(1<<0)
#define PSHAPE_SNAP_NOEDGES		(1<<1)

// Selection level bits.
#define SHAPE_OBJECT		(1<<0)
#define SHAPE_SPLINE		(1<<1)
#define SHAPE_SEGMENT		(1<<2)
#define SHAPE_VERTEX		(1<<3)

// Parameter types for shape interpolation (Must match interpolation types in object.h)
#define POLYSHP_INTERP_SIMPLE 0		// Parameter space based on segments
#define POLYSHP_INTERP_NORMALIZED 1	// Parameter space normalized to curve length

// Flags for sub object hit test

// NOTE: these are the same bits used for object level.
#define SUBHIT_SHAPE_SELONLY	(1<<0)
#define SUBHIT_SHAPE_UNSELONLY	(1<<2)
#define SUBHIT_SHAPE_ABORTONHIT	(1<<3)
#define SUBHIT_SHAPE_SELSOLID	(1<<4)

#define SUBHIT_SHAPE_VERTS		(1<<24)
#define SUBHIT_SHAPE_SEGMENTS	(1<<25)
#define SUBHIT_SHAPE_POLYS		(1<<26)
#define SUBHIT_SHAPE_TYPEMASK	(SUBHIT_SHAPE_VERTS|SUBHIT_SHAPE_SEGMENTS|SUBHIT_SHAPE_POLYS)

class Spline3D;

//--------------------------------------------------------------
// Capping classes, etc.

// CapVert flags
#define CAPVERT_VISEDGE (1<<0)

class CapVert {
	public:
		int vert;
		DWORD flags;
		float ang;
		CapVert *prev,*next;
		CapVert *smaller,*bigger;
		CapVert() { vert=0; flags = 0; ang = 0.0f; prev=next=smaller=bigger = NULL; }
	};

//--------------------------------------------------------------

// Predefined PolyPt flags
// Bits 0-7 are available to the user.  Bits 8-31 are reserved for internal use

// Use these to make capping more efficient
// If your class converts to a PolyLine, use them!
#define POLYPT_KNOT 		(1<<8)	// A control point
#define POLYPT_INTERPOLATED (1<<9)	// An interpolated point

// If you convert to a PolyLine, use this bit to control smoothing of the resulting shape
// If this bit is set, it means that any mesh generated will share smoothing across the edge
#define POLYPT_SMOOTH		(1<<10) // Point is part of a smooth transition

#define POLYPT_SEG_SELECTED	(1<<11)	// The segment that starts with this point is selected

// Used internally by capping code
#define POLYPT_BRIDGE		(1<<16)	// Span between two polygons
#define POLYPT_SPLICE		(1<<17)	// Point is endpoint of a bridge
#define POLYPT_VISEDGE		(1<<18)	// Segment should be visible on mesh
#define POLYPT_NO_SPLICE	(1<<19)	// Don't allow a bridge at this point
#define POLYPT_INVIS_EDGE	(1<<20)	// Force segment to be invisible on capping

// Flags2 field contains material IDs:
// The mat ID is stored in the HIWORD of the PolyPt flags2 field
#define POLYPT_MATID_SHIFT	16
#define POLYPT_MATID_MASK	0xFFFF

class PolyPt {
	public:
		Point3 p;
		DWORD flags;	// See above
		DWORD flags2;	// See above
		int aux;		// Auxiliary data attached to this point (usually mesh vertex number for capping)
		PolyPt() { p = Point3(0,0,0); flags = 0; flags2 = 0; aux = 0; }
		PolyPt(Point3 ip, DWORD f=0, int a=0, DWORD f2=0) { p = ip; flags = f; aux = a; flags2 = f2;}
		inline	MtlID	GetMatID() {return (int)((flags2>>POLYPT_MATID_SHIFT)&POLYPT_MATID_MASK);}
		inline	void    SetMatID(MtlID id) {flags2 &= 0xFFFF; flags2 |= (DWORD)(id<<POLYPT_MATID_SHIFT);}
	};

// PolyLine::Cap3DS / PolyShape::Make3DSCap options
#define CAP3DS_OPT_CLOSEST_BRIDGE (1<<0)	// Bridge polys at closest point

// PolyLine flags
#define POLYLINE_CLOSED			(1<<0)
#define POLYLINE_NO_SELF_INT	(1<<1)		// Ignore self-intersections (special!)

class PolyLine {
	public:
		int numPts;
		PolyPt *pts;
		DWORD flags;
		Box3 bdgBox;
		float cachedLength;
		float *lengths;		// Cached lengths for each point
		float *percents;	// Cached percentages for each point
		BOOL cacheValid;
		CoreExport PolyLine();
		CoreExport PolyLine(PolyLine& from);
		CoreExport ~PolyLine();
		CoreExport void Init();
		void Close() { flags |= POLYLINE_CLOSED; }
		CoreExport BOOL IsClosed();
		void Open() { flags &= ~POLYLINE_CLOSED; }
		CoreExport BOOL IsOpen();
		void SetNoSelfInt() { flags |= POLYLINE_NO_SELF_INT; }
		BOOL IsNoSelfInt() { return (flags & POLYLINE_NO_SELF_INT) ? TRUE : FALSE; }
		int Verts() { return numPts; }
		CoreExport int Segments();
		CoreExport BOOL SetNumPts(int count, BOOL keep = TRUE);
		CoreExport void Append(PolyPt& p);
		CoreExport void Insert(int where, PolyPt& p);
		CoreExport void Delete(int where);
		CoreExport void Reverse(BOOL keepZero=FALSE);
		CoreExport PolyLine& operator=(PolyLine& from);
		CoreExport PolyLine& operator=(Spline3D& from);
		CoreExport PolyPt& operator[](int index) { return pts[index]; }
		CoreExport void BuildBoundingBox(void);
		CoreExport void InvalidateGeomCache();
		CoreExport Box3 GetBoundingBox(Matrix3 *tm=NULL); // RB: optional TM allows the box to be calculated in any space.
		CoreExport void Render(GraphicsWindow *gw, Material *ma, RECT *rp, int compFlags, int numMat);
		CoreExport void Render(GraphicsWindow *gw, Material *ma, int numMat, BOOL colorSegs, BitArray &segsel);
		CoreExport BOOL Select(GraphicsWindow *gw, Material *ma, HitRegion *hr, int abortOnHit = FALSE);
		CoreExport void Snap(GraphicsWindow *gw, SnapInfo *snap, IPoint2 *p, Matrix3 &tm, DWORD flags);
		CoreExport void Transform(Matrix3 &tm);
		CoreExport void Dump(TCHAR *title = NULL);
		CoreExport void SpliceLine(int where, PolyLine &source, int splicePoint);
		CoreExport BOOL HitsSegment(Point2 p1, Point2 p2, BOOL findAll = FALSE, IntersectionCallback3D *cb = NULL);
		CoreExport int Cap3DS(CapVert *capverts, MeshCapInfo &capInfo, DWORD options = 0);
		CoreExport BOOL HitsPolyLine(PolyLine &line, BOOL findAll = FALSE, IntersectionCallback3D *cb = NULL);
		CoreExport BOOL SurroundsPoint(Point2 &point);
		CoreExport Point3 InterpPiece3D(int segment, float t);
		CoreExport Point3 InterpCurve3D(float u, int ptype=POLYSHP_INTERP_SIMPLE);
		CoreExport Point3 TangentPiece3D(int segment, float t);
		CoreExport Point3 TangentCurve3D(float u, int ptype=POLYSHP_INTERP_SIMPLE);
		CoreExport MtlID GetMatID(int segment);
		CoreExport float CurveLength();
		CoreExport BOOL IsClockWise();			// 2D!
		CoreExport BOOL	SelfIntersects(BOOL findAll = FALSE, IntersectionCallback3D *cb = NULL);		// 2D!
		CoreExport void GetSmoothingMap(IntTab &map);
		// IO
		CoreExport IOResult Save(ISave *isave);
		CoreExport IOResult Load(ILoad *iload);
	};

#define CAPFACE_AB	(1<<0)
#define CAPFACE_BC	(1<<1)
#define CAPFACE_CA	(1<<2)

class ShapeObject;

// Options for steps in MakePolyShape (>=0: Use fixed steps)
// NOTE: DO NOT change these defines -- They're also used by ShapeObject (object.h)
#define PSHAPE_BUILTIN_STEPS -2		// Use the shape's built-in steps/adaptive settings (default)
#define PSHAPE_ADAPTIVE_STEPS -1	// Force adaptive steps

class PolyShape {
	public:
		int numLines;
		PolyLine *lines;
		DWORD flags;
		Box3 bdgBox;

 		// Selection
		ShapeVSel	vertSel;  		// selected vertices
		ShapeSSel	segSel;  		// selected segments
		ShapePSel	polySel;  		// selected polygons

		// Selection level
		DWORD		selLevel;

		// Display attribute flags
		DWORD		dispFlags;

		// Capping caches
		MeshCapInfo morphCap;
		BOOL morphCapCacheValid;
		MeshCapInfo gridCap;
		BOOL gridCapCacheValid;
		PatchCapInfo patchCap;
		BOOL patchCapCacheValid;

		// Hierarchy cache
		ShapeHierarchy cachedHier;
		BOOL hierCacheValid;

		CoreExport PolyShape();
		CoreExport PolyShape(PolyShape& from);
		CoreExport ~PolyShape();
		CoreExport void Init();			// Used by constructors
		CoreExport void NewShape();		// Deletes all lines
		CoreExport BOOL SetNumLines(int count, BOOL keep = TRUE);
		CoreExport PolyLine* NewLine();
		CoreExport void Append(PolyLine &l);
		CoreExport void Insert(int where, PolyLine& l);
		CoreExport void Delete(int where);
		CoreExport PolyShape& operator=(PolyShape& from);
		CoreExport PolyShape& operator=(BezierShape& from);
		CoreExport void BuildBoundingBox(void);
		CoreExport void InvalidateGeomCache(BOOL unused);		// Also invalidates capping caches
		CoreExport void InvalidateCapCache();
		CoreExport Box3 GetBoundingBox(Matrix3 *tm=NULL); // RB: optional TM allows the box to be calculated in any space.
		CoreExport void GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm, BOOL useSel );
		CoreExport void Render(GraphicsWindow *gw, Material *ma, RECT *rp, int compFlags, int numMat);
		CoreExport BOOL Select(GraphicsWindow *gw, Material *ma, HitRegion *hr, int abortOnHit = FALSE);
		CoreExport void Snap(GraphicsWindow *gw, SnapInfo *snap, IPoint2 *p, Matrix3 &tm);
		CoreExport void Snap(GraphicsWindow *gw, SnapInfo *snap, IPoint2 *p, Matrix3 &tm, DWORD flags);
		CoreExport void Transform(Matrix3 &tm);
		CoreExport int MakeCap(TimeValue t, MeshCapInfo &capInfo, int capType);
		CoreExport int MakeCap(TimeValue t, PatchCapInfo &capInfo);
		CoreExport int Make3DSCap(MeshCapInfo &capInfo, DWORD options = 0);
		CoreExport int MakeGridCap(MeshCapInfo &capInfo);
		CoreExport void Dump(TCHAR *title = NULL);
		CoreExport void UpdateCachedHierarchy();
		CoreExport ShapeHierarchy &OrganizeCurves(TimeValue t, ShapeHierarchy *hier = NULL);
		CoreExport void UpdateSels();
		CoreExport void Reverse(int poly, BOOL keepZero=FALSE);
		CoreExport void Reverse(BitArray &reverse, BOOL keepZero=FALSE);
		CoreExport MtlID GetMatID(int poly, int piece);
		// Constructs a vertex selection list based on the current selection level.
		CoreExport BitArray	VertexTempSel(int poly);
		// functions for use in data flow evaluation
		CoreExport void ShallowCopy(PolyShape *ashape, unsigned long channels);
		CoreExport void DeepCopy(PolyShape *ashape, unsigned long channels);
		CoreExport void	NewAndCopyChannels(unsigned long channels);
		CoreExport void FreeChannels( unsigned long channels, int zeroOthers=1);
		// IO
		CoreExport IOResult Save(ISave *isave);
		CoreExport IOResult Load(ILoad *iload);

	};

#endif // __POLYSHP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\ref.h ===
/**********************************************************************
 *<
	FILE:  ref.h

	DESCRIPTION:  Defines Animatable, Reference Classes

	CREATED BY: Rolf Berteig & Dan Silva

	HISTORY: created 9 September 1994

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef _REF_H_
#define _REF_H_

/* This module implements a first run at the concept of references.
 * Some other stuff is in here to like time and intervals, but
 * these are implemented only to get the reference classes working.
 */
typedef void *ReferenceData;
typedef unsigned int TargetParam;

typedef unsigned long PartID;

// Bits for PartID


// OBJECT STATE: SUB-PARTS
// These are the 4 sub-channels object in the object state.
// Dont change these defines  
// (See CHANNELS.H for define of TOPO_CHANNEL, etc.)
#define PART_TOPO			TOPO_CHANNEL   
#define PART_GEOM			GEOM_CHANNEL   
#define PART_TEXMAP			TEXMAP_CHANNEL 
#define PART_MTL			MTL_CHANNEL    
#define PART_SELECT			SELECT_CHANNEL 
#define PART_SUBSEL_TYPE 	SUBSEL_TYPE_CHANNEL
#define PART_DISPLAY    	DISP_ATTRIB_CHANNEL
#define PART_VERTCOLOR		VERTCOLOR_CHANNEL
#define PART_GFX_DATA		GFX_DATA_CHANNEL
#define PART_DISP_APPROX	DISP_APPROX_CHANNEL

// These represent the TM and MTL parts of the object state
#define PART_TM_CHAN   		TM_CHANNEL
#define PART_MTL_CHAN		GLOBMTL_CHANNEL

#define PART_OBJECT_TYPE   	(1<<11)      
#define PART_TM  			(1<<12)		// node TM
#define PART_OBJ  			(PART_TOPO|PART_GEOM)

#define PART_ALL			(ALL_CHANNELS|PART_TM)

// Special part ID sent by visibility controllers when they change the hidden in viewport state. Sent with REFMSG_CHANGE message
#define PART_HIDESTATE		(1<<30)

// One of these is set as the PartID when notify dependents is
// called with REFMSG_FLAGDEPENDENTS
#define PART_PUT_IN_FG				(1<<0)
#define PART_SHOW_DEPENDENCIES		(1<<1)
#define PART_SHOWDEP_ON				(1<<2)

/* The message passed to notify and evaluate.
 */
typedef unsigned int RefMessage;

#define REFMSG_LOOPTEST 				0x00000010
#define REFMSG_TARGET_DELETED 			0x00000020
#define REFMSG_MODAPP_DELETING			0x00000021
#define REFMSG_EVAL  					0x00000030
#define REFMSG_RESET_ORIGIN 			0x00000040
#define REFMSG_CHANGE 					0x00000050
#define REFMSG_FLAGDEPENDENTS			0x00000070
#define REFMSG_TARGET_SELECTIONCHANGE	0x00000080
#define REFMSG_BEGIN_EDIT				0x00000090
#define REFMSG_END_EDIT					0x000000A0
#define REFMSG_DISABLE					0x000000B0
#define REFMSG_ENABLE					0x000000C0
#define REFMSG_TURNON					0x000000D0
#define REFMSG_TURNOFF					0x000000E0
#define REFMSG_LOOKAT_TARGET_DELETED  	0x000000F0 
#define REFMSG_INVALIDATE_IF_BG			0x000000F1
// turn on and off the a modifier display
#define REFMSG_MOD_DISPLAY_ON			0x000000F2
#define REFMSG_MOD_DISPLAY_OFF			0x000000F3

// Modifier uses this to tell Modapps to call their Eval() proc:
#define REFMSG_MOD_EVAL					0x000000F4

// Ask if its ok to change topology.  If any dependents have made 
//  topology-dependent mods, they should return REF_FAIL:
// a return of REF_SUCCEED means that the answer is YES
// a return of REF_FAIL means that the answer is NO
#define REFMSG_IS_OK_TO_CHANGE_TOPOLOGY	0x000000F5


// This main purpose of these notifications is to cause the tree
// view to update when one of these events takes place.

// Sent by a node when it has a child linked to it or unlinked from it.
#define REFMSG_NODE_LINK				0x000000F6

// Sent by a node when it's name has been changed.
#define REFMSG_NODE_NAMECHANGE			0x000000F7

// Sent by a node (or derived object) when the object it references changes.
#define REFMSG_OBREF_CHANGE				0x000000F8

// Sent by a derived object when a modifier is a added or deleted.
#define REFMSG_MODIFIER_ADDED			0x000000F9

// Sent when an animatable switches controllers for one of it's parameters.
#define REFMSG_CONTROLREF_CHANGE		0x000000FA

// A parameter block sends the message to it's client when it needs the anim
// name of the ith parameter.
// partID is set to a pointer to a GetParamName structure defined in iparamb.h
#define REFMSG_GET_PARAM_NAME			0x000000FB

// A parameter block sends this message to it's client when it needs to know
// the dimension type of the ith parameter.
// partID is set to a pointer to a GetParamDim structure  defined in iparamb.h
#define REFMSG_GET_PARAM_DIM			0x000000FC

// A controller can send this to it's client to get it's param dimension.
// It should set partID to a ParamDimension **
#define REFMSG_GET_CONTROL_DIM			0x000000FD

// This message is sent by a node when it's TM has changed because it was evaluated
// at a different time. Normally this isn't neccessary - anyone depending on the
// node's TM would have a validity interval that reflected the validity of the
// TM. The axis system doesn't store a validity interval (it probably should) so this
// message is needed for it.
#define REFMSG_TM_CHANGE 				0x000000FE

// A node sends this message when it's anim range changes.
#define REFMSG_RANGE_CHANGE				0x000000FF

// Sent to the tree view when an animatable's line height changes.
#define REFMSG_LINEHEIGHT_CHANGE		0x00000100

// A controller should send this message to the treeview when it becomes animated.
// If the user has the animated only filter on then the tree view will display this item.
#define REFMSG_BECOMING_ANIMATED		0x00000101

// This is intended mainly for the TrackView to tell it to re-generate
// view below the message sender's level.
#define REFMSG_SUBANIM_STRUCTURE_CHANGED 0x00000102

// A target has had a ref deleted: Mtl's use this to tell mtlLib, in case 
// the # of node refs has gone to zero.
#define REFMSG_REF_DELETED			0x00000103

// A target has had a ref Added: Mtl's use this to tell mtlLib, in case 
// the # of node refs has become non-zero.
#define REFMSG_REF_ADDED			0x00000104

// Sent by an object that provides branching in the history to notify that
// the structure of the branches changed.
#define REFMSG_BRANCHED_HISTORY_CHANGED	0x00000105

// The selection set sends this notification when it receives a REFMSG_CHANGE
// from an item in the selection set. The selection set doesn't propogate the
// REFMSG_CHANGE message.
#define REFMSG_NODEINSELSET_CHANGED	0x00000106

// Used to test dependencies
#define REFMSG_TEST_DEPENDENCY	0x00000107

// A Param block sends this to its client to ask if it should display
// a distinct "Parameters" level in the track view hierarchy. 
// A pointer to a boolan is passed in for PartID: set this to the desired answer.
// The default is NO -- in this case the message doesn't need
// to be responded to.
#define REFMSG_WANT_SHOWPARAMLEVEL 	0x00000108

// Theser are sent before and after a paste has been done: Sent as partID is 
// a pointer to a data structure containing three RefTargetHandle's: the ref maker,
// the old target,  and the new target. The message is sent to the ref maker initially.
#define REFMSG_BEFORE_PASTE 	0x00000109
#define REFMSG_NOTIFY_PASTE 	0x0000010A

// Sent when a UV Generator changes symmetry, so interactive texture display 
// updates.
#define REFMSG_UV_SYM_CHANGE    0x0000010B

// The first node that gets this message will fill in the
// TSTR which partID points to with its name and stop the
// message from propogating.
#define REFMSG_GET_NODE_NAME			0x0000010C

// Sent by the selection set whenever it has just deleted nodes
#define REFMSG_SEL_NODES_DELETED		0x0000010D

// Sent *before* a reference target is pasted. Sent by the target
// about to be replaced.
#define REFMSG_PRENOTIFY_PASTE 	0x0000010E

// Sent when a shape enters a state where it'll be changing a lot and it
// would be a good idea for anybody using it for mesh generation to suppress
// updates.
#define REFMSG_SHAPE_START_CHANGE	0x0000010F

// Sent to terminate the above state
#define REFMSG_SHAPE_END_CHANGE		0x00000110

// A texture map has been removed: tells medit to remove
// it from the viewport if it is active.
#define REFMSG_TEXMAP_REMOVED	0x00000111

// Sent by an unselected node to see if any selected nodes depend on it.
// The partID param points to a boolean. If a selected node receives this 
// message it should set the boolean to true and return REF_STOP.
#define REFMSG_FLAG_NODES_WITH_SEL_DEPENDENTS	0x00000112

// The following are sent by objects which contain shapes when the selection,
// position, or both change:
#define REFMSG_CONTAINED_SHAPE_POS_CHANGE 0x00000120
#define REFMSG_CONTAINED_SHAPE_SEL_CHANGE 0x00000121
#define REFMSG_CONTAINED_SHAPE_GENERAL_CHANGE 0x00000122

// When an object receives this message it should do what ever it needs
// to do (usually select the appropriate sub-object) to make the dependent
// object be the object returned from GetPipeBranch().
// The partID will point to an INode pointer that will be filled in by
// the first node to receive this message.
#define REFMSG_SELECT_BRANCH	0x00000130

// These messages are sent to dependents of the TM controllers for selected
// objects when the user begins and ends a mouse transformation in the
// viewports (move/rotate/scale).
#define REFMSG_MOUSE_CYCLE_STARTED		0x00000140
#define REFMSG_MOUSE_CYCLE_COMPLETED	0x00000150

// Sent by a node to other nodes (which depend on that node) when the
// user attempts to link another node to a node.
// The partID parameter contains a pointer to the new parent node.
#define REFMSG_CHECK_FOR_INVALID_BIND	0x00000161

// Sent when a cache is dumped in the pipeline. A REFMSG_CHANGE message
// used to be sent, however that was misleading since the object itself
// didn't change even though any old object pointer has become invalid.
// For example, if a path controller depends on a spline object and
// that object dumps some caches in the pipeline, the path controller
// hasn't actually changed.
#define REFMSG_OBJECT_CACHE_DUMPED	0x00000162

// Sent by Atmospheric or Effect when it makes or deletes a reference
// to a node.
#define REFMSG_SFX_CHANGE 		0x00000170

// Sent when updating object xrefs. PartID contains new material... when a
// node receives this message it will set its material to the new one.
// This message is for internal use only.
#define REFMSG_OBJXREF_UPDATEMAT	0x00000180

// Sent to build a list of nodes which use a particular XRef object.
// PartID points to a table of base node pointers
// This message is for internal use only.
#define REFMSG_OBJXREF_GETNODES		0x00000190

// Sent when objects are replaced from another scene (File->Replace).
// Other objects referencing the object that is replaced may want to
// perform some validity checking; this message is more specific than
// REFMSG_SUMANIM_STRUCTURE_CHANGED.
#define REFMSG_OBJECT_REPLACED		0x00000200

// Sent when nodes wireframe color is changed
#define REFMSG_NODE_WIRECOLOR_CHANGED 0x00000210

/* Message numbers above this value can be defined for use
 * by sub-classes, below are reserved.
 */
#define REFMSG_USER		0x00010000


/* Some return codes for references...
 * There would probably be a bunch of these.
 */
enum RefResult {
	REF_FAIL,
	REF_SUCCEED,
	REF_DONTCARE,
	REF_STOP,
	REF_INVALID	
	};


// Use this to disable ref counting on objects.
#define MakeFakeHandleClass( className, handleClassName ) 	\
	class className; typedef className* handleClassName		

MakeFakeHandleClass( ReferenceTarget, RefTargetHandle );
MakeFakeHandleClass( ReferenceMaker, RefMakerHandle );

// This replaces the .Valid() method of handles.

#define VALID(x) (x)

// If this super class is passed to NotifyDependents() all dependents will be notified
#define NOTIFY_ALL		0xfffffff0

// For remapping references during a Clone.
class RemapDir {
	public:
		virtual	RefTargetHandle FindMapping(RefTargetHandle from)=0;
		virtual void AddEntry(RefTargetHandle hfrom, RefTargetHandle hto)=0;
		virtual RefTargetHandle CloneRef(RefTargetHandle oldTarg);
		virtual void PatchPointer(RefTargetHandle* patchThis, RefTargetHandle oldTarg)=0;
		virtual void Backpatch()=0;
		virtual void Clear()=0;
		virtual void ClearBackpatch() {}
		virtual	void DeleteThis()=0;
	};


/* Reference list link-node
 */
class CoreExport RefListItem {
	
	public:
		RefMakerHandle  maker;
		RefListItem		*next;
		/* Constructors:
		 */		
		RefListItem( RefMakerHandle hmaker, RefListItem *list ) { 
			next = list;
			maker = hmaker;
			}
	};

class CoreExport RefList {
	public:
		RefListItem* first;								  
		RefList() { first = NULL;}
		RefListItem*  FirstItem() { return first; }
		RefResult DeleteItem(RefMakerHandle hmaker, int eval);
		RefResult AddItem(RefMakerHandle hmaker );
		void Cleanup();  // remove null entries
	};

class DeleteRefRestore;
class MakeRefRestore;
class ParamBlock;
class ISave;
class ILoad;
class DependentIterator;


// Possible return values for DependentEnumProc::proc()
#define DEP_ENUM_CONTINUE	0
#define DEP_ENUM_HALT		1
#define DEP_ENUM_SKIP		2	// this is the new value

class DependentEnumProc {
	public:
		virtual	int proc(ReferenceMaker *rmaker)=0;
	};

class SaveEnumProc {
	public:
		virtual	void proc(ReferenceMaker *rmaker)=0;
		virtual int terminate(ReferenceMaker *rmaker)=0; 
	};

CoreExport RemapDir& NoRemap();

// Here's a pointer to a RemapDir: you must delete it when done.
CoreExport RemapDir* NewRemapDir(); 

/* Everything can be a reference maker. We might want to keep this
 * class separate from Animatable just for clarity.
 */
class  ReferenceMaker : public Animatable {
	friend class DeleteRefRestore;
	friend class MakeRefRestore;
	friend class ReferenceTarget;
	friend class ParamBlock;
	friend class RootNode;
	friend class BaseNode;

	public:		
		// Constructor:
		ReferenceMaker() { ClearAFlag(A_EVALUATING); } 

		// Destructor:
		CoreExport ~ReferenceMaker(); 

		// This routine is used when cloning reference makers, to delete old 
		// reference and make a new one.
		CoreExport RefResult ReplaceReference(int which, RefTargetHandle newtarg, BOOL delOld=TRUE);
		
		// new format
		CoreExport RefResult MakeRefByID(Interval refInterval,int which,RefTargetHandle htarget);

		// Deletes all references from this RefMaker.
		CoreExport RefResult DeleteAllRefsFromMe();

		// Deletes all refs to this RefMaker/RefTarget.
		// also sends REFMSG_TARGET_DELETED to all dependents.
		virtual RefResult DeleteAllRefsToMe() { return REF_SUCCEED; }

		// Deletes all references to AND from this guy.
		CoreExport RefResult DeleteAllRefs();

		// This deletes all reference to and from, sends REFMSG_TARGET_DELETED 
		// messages, handles UNDO, and deletes the object.	
		CoreExport void DeleteMe();
						
		// Enumerator to search back in the dependency network.
		CoreExport virtual	int EnumDependents(DependentEnumProc* dep);

		CoreExport virtual IOResult Save(ISave *isave);
		CoreExport virtual IOResult Load(ILoad *iload);

	   	// Access of refs. -- These functions must be implemented
		// by ALL classes that make refs.
		CoreExport virtual	int NumRefs();
		CoreExport virtual RefTargetHandle GetReference(int i);
		CoreExport virtual void SetReference(int i, RefTargetHandle rtarg);

		// A maker can choose not to let TransferReferences() affect it. Note that plug-ins probably should not use this
		// it is used by certain system objects that have references.
		virtual BOOL CanTransferReference(int i) {return TRUE;}

		//-- default Save enumeration.
		CoreExport virtual void SaveEnum(SaveEnumProc& sep, BOOL isNodeCall=0);

		CoreExport virtual RefResult 
			NotifyDependents(Interval changeInt, PartID partID, 
				RefMessage message, SClass_ID sclass=NOTIFY_ALL,
				BOOL propagate=TRUE, RefTargetHandle hTarg=NULL );

		// Enumerate auxiliary files (e.g. bitmaps)
		// The default implementation just calls itself on all references.
		// Entities which actually need to load aux files must implement this,
		// possibly calling ReferenceMaker::EnumAuxFiles also to recurse.
		CoreExport virtual void EnumAuxFiles(NameEnumCallback& nameEnum, DWORD flags);

		CoreExport RefResult DeleteReference( int i);
		CoreExport int FindRef(RefTargetHandle rtarg);

		// When a reference target's last "real" reference is deleted
		// the target is deleted. Any leftover "non-real" reference makers
		// will receive a REFMSG_TARGET_DELETED notification.
		virtual BOOL IsRealDependency(ReferenceTarget *rtarg) {return TRUE;}

		// Implement this if you have added or deleted references and are loading
		// an old file that needs to have its references remapped.  
		virtual int RemapRefOnLoad(int iref) { return iref; }

		// This function differentiates things subclassed from ReferenceMaker from 
		// subclasses of ReferenceTarget.
		virtual BOOL IsRefTarget() { return FALSE; }

		// Rescale size of all world units in reference hierarchy. 
		// Must call  ClearAFlagInHierarchy(rm, A_WORK1) before doing this
		// on a reference hierarchy.
		CoreExport virtual void RescaleWorldUnits(float f);


	protected:
		void BlockEval() { SetAFlag(A_EVALUATING); }
		void UnblockEval() { ClearAFlag(A_EVALUATING); }		
		int Evaluating() { return TestAFlag(A_EVALUATING); }		
		
		CoreExport RefResult StdNotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
		   PartID partID, RefMessage message, BOOL propagate=TRUE);		

	private:
		

		// StdNotifyRefChanged calls this, which can change the partID to new value 
		// If it doesnt depend on the particular message& partID, it should return
		// REF_DONTCARE
	    virtual RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	         PartID& partID,  RefMessage message)=0;		
	
	};



/* Not everything is a reference target...
 */
class  ReferenceTarget : public ReferenceMaker {
	friend class DependentIterator;
	friend class DeleteRefRestore;
	friend class MakeRefRestore;
	//friend class Remap;
	
	public:
		ReferenceTarget() { ClearAFlag(A_LOCK_TARGET); } 

		// old format: will go away
		CoreExport RefResult MakeReference(Interval refInterval,RefMakerHandle hmaker,int whichRef=-1);

		CoreExport RefResult TestForLoop( Interval refInterval, RefMakerHandle hmaker);

	    CoreExport BOOL HasDependents();
	    CoreExport BOOL HasRealDependents();  // not counting tree view
		
		// Deletes all references to this refTarget.
		CoreExport RefResult DeleteAllRefsToMe();

		RefList& GetRefList() { return refs; }

		// This function is called when a targets last ref is deleted
		// Most subclasses will not need to override this. If you don't want to be
		// deleted when the last ref is deleted, plug in a noop.
		CoreExport virtual RefResult AutoDelete();

		// This is called after deleting a reference to a ref target,
		// in the case that the target was not deleted. If target needs
		// to know, it should override this method.
		virtual void RefDeleted() {}  
		virtual void RefDeletedUndoRedo() {}  // Called when reference is deleted because of and undo or a redo

		// This is called after making a reference-- If the
		// target needs to know it can override it.
		virtual void RefAdded(RefMakerHandle rm) {}  
		virtual void RefAddedUndoRedo(RefMakerHandle rm) {}   // Called when reference is added because of and undo or a redo

		// Transfer all the references from oldTarget to this 
		CoreExport RefResult TransferReferences(RefTargetHandle oldTarget, BOOL delOld=FALSE);

		// Enumerator to search back in the dependency network.
		CoreExport virtual	int EnumDependents(DependentEnumProc* dep);

		CoreExport virtual RefTargetHandle Clone(RemapDir &remap = NoRemap());

		// Checks if there are no references, and if object is deletable, deletes it.
		CoreExport RefResult MaybeAutoDelete();


		// This sends the REFMSG_FLAGDEPENDENTS message up the pipeline.
		// There are two reasons to flag dependents:
		// 1) To put the node in the FG plane. (PART_PUT_IN_FG)
		// 2) To set the node's mesh color to green to indicate it is a
		//    dependent. (PART_SHOW_DEPENDENCIES)
		//    If the PART_SHOWDEP_ON bit is set, the dependency display is
		//    turned on, otherwise it is turned off.
		void FlagDependents( TimeValue t, PartID which=PART_PUT_IN_FG ) 
			{ 
			NotifyDependents( 
				Interval(t,t), 
				which,
				REFMSG_FLAGDEPENDENTS );
			}	

		// This method is called to flag dependents into the FG. 
		// (Note that the above method is obsolete)
		// The default implementation just sends out the notification.
		// In particular, a slave controller could override this method
		// and call its masters version of this method.
		virtual void NotifyForeground(TimeValue t) 
			{NotifyDependents(Interval(t,t),PART_PUT_IN_FG,REFMSG_FLAGDEPENDENTS);}

		// To see if this reference target depends on something:
		// first call BeginDependencyTest()
		// then call NotifyDependents() on the thing with the REFMSG_TEST_DEPENDENCY
		// if EndDependencyTest() returns TRUE this target is dependent on the thing. 
		void BeginDependencyTest() {ClearAFlag(A_DEPENDENCY_TEST);}
		BOOL EndDependencyTest() {return TestAFlag(A_DEPENDENCY_TEST);}
			
		// Notify all dependent RefMakers concerened with the message 
		CoreExport virtual RefResult 
			NotifyDependents(Interval changeInt, PartID partID, 
				RefMessage message, SClass_ID sclass=NOTIFY_ALL,
				BOOL propagate=TRUE, RefTargetHandle hTarg=NULL);

		// This function differentiates things subclassed from ReferenceMaker from 
		// subclasses of ReferenceTarget.
		virtual BOOL IsRefTarget() { return TRUE; }
	private:		
		
		// This is the list of active references that refer to us.
		RefList	refs;
	};

class DependentIterator {
	ReferenceTarget *rt;
	RefListItem *next;
	public:
	DependentIterator(ReferenceTarget *rtarg) { rt = rtarg; next = rt->refs.first; }
	CoreExport ReferenceMaker *Next();
	void Reset() { next = rt->refs.first; }
	};

class DeletedRestore: public RestoreObj {
	RefMakerHandle anim, svanim;
	public:
		CoreExport DeletedRestore();
		CoreExport DeletedRestore(RefMakerHandle an);
		CoreExport ~DeletedRestore();
		CoreExport void Restore(int isUndo);
		CoreExport void Redo();
		CoreExport TSTR Description();
	};


class RefEnumProc {
	public:
	virtual void proc(ReferenceMaker *rm)=0;
	};

CoreExport void  EnumRefHierarchy(ReferenceMaker *rm, RefEnumProc &proc);
CoreExport ReferenceTarget *CloneRefHierarchy(ReferenceTarget *rm);


// This class lets you tap in to ALL reference messages in the entire
// system. Once registered, the NotifyRefChanged() method will be called
// once for every time NotifyRefChanged() is called on a regular
// ReferenceTarget effectively allowing you to wire tap the entire
// reference network.
//
// WARNING: This should be used with extreme care. NotifyRefChange()
// will be called MANY MANY times so it is important to do very little
// processing within this method. This most that should probably be 
// done is to set a dirty bit.
//
class GlobalReferenceMaker {
	public:
		virtual RefResult NotifyRefChanged(
			Interval iv, RefTargetHandle hTarg,
			PartID& partID, RefMessage msg)=0;		
	};
CoreExport void RegisterGlobalReference(GlobalReferenceMaker *maker);
CoreExport void UnRegisterGlobalReference(GlobalReferenceMaker *maker);

CoreExport void ClearAFlagInHierarchy(ReferenceMaker *rm, int flag);

// DependsOn -- returns true if there is a path of references from mkr to targ;
// (note: this returns TRUE if mkr==targ)
CoreExport BOOL DependsOn(RefMakerHandle mkr, RefMakerHandle targ);

// Function to find out if we are saving an old version .MAX file.  
// If this returns 0, then either (a) we are not in a save or 
// we are saving the current version. If it returns non-zero, it is
// the max release number being saved, multiplied by 1000. Thus, 
// when saving MAX R2 files, it will return 2000.  This function can
// be used in NumRefs() and GetRef() to make an objects references 
// appear as they did in the old Max version.

CoreExport DWORD GetSavingVersion(); 

// Function used internally to maintain the SavingVersion number, which should not be 
// called by plugins.
CoreExport DWORD SetSavingVersion(DWORD version); 


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\RefArrayBase.h ===
/**********************************************************************
 *<
 FILE: RefArrayBase.h

	DESCRIPTION:  A base class for implementing objects which need to maintain
	multiple arrays of references. This implementation makes the following assumptions:

	1) The arrays are implemented as Tab<RefTargetHandle>

	CREATED BY: John Hutchinson

	HISTORY: created 8/24/98

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#pragma once
#ifndef _REF_ARRAY_BASE
#define _REF_ARRAY_BASE

#include "object.h"
#include "Irefarray.h"

//SS 4/12/99: Now derives from ShapeObject; if your reference array only
// supports mesh geometry, override SuperClassID() and IsShapeObject().
class RefArrayBase : public ShapeObject, public IRefArray
{
public:
		CoreExport virtual int NumRefCols() const; // the size of arrays (the same size!)

protected:
		//From IRefArray
		CoreExport virtual int TotalRefs() const;

		CoreExport virtual IRefArray* Inner(){return NULL;} //Access to the containee
		CoreExport virtual const IRefArray* Inner() const{return NULL;} //Access to the containee
		CoreExport virtual int InnerArrays() const; //the number of arrays in any containee
		CoreExport virtual int Remap(int row, int col) const; //Converts to linear, inner index

		CoreExport virtual int ArrayOffset() const{return 0;} //The number of non-array references
		CoreExport virtual bool IsSubArrayIndex(int i) const {return i< ArrayOffset();}
		CoreExport virtual RefTargetHandle GetSubArrayReference(int i) {assert(0); return NULL;}
		CoreExport virtual void SetSubArrayReference(int i, RefTargetHandle rtarg) {assert(0);}

		//Local methods
		CoreExport int LinearIndex(int row, int col);

public:
		CoreExport RefArrayBase() : ShapeObject() {}

		//From Animatable
		CoreExport void * GetInterface(ULONG id)
		{
			if (id == I_REFARRAY)
				return static_cast<IRefArray *>(this);
			else
				return GeomObject::GetInterface(id);
		}

		//From ReferenceMaker
		CoreExport virtual	int NumRefs();
		CoreExport virtual RefTargetHandle GetReference(int i);
		CoreExport virtual void SetReference(int i, RefTargetHandle rtarg);

		//Referencemaker overloads
		CoreExport virtual RefTargetHandle GetReference(int row, int col);
		CoreExport virtual void SetReference(int row, int col, RefTargetHandle rtarg);
		CoreExport virtual RefResult MakeRefByID(Interval refInterval, int row, int col, RefTargetHandle rtarg);
		CoreExport virtual RefResult ReplaceReference(int row, int col, RefTargetHandle newtarg, BOOL delOld=TRUE);
		CoreExport virtual RefResult DeleteReference(int row, int col);
		CoreExport virtual BOOL CanTransferReference(int row, int col);
		CoreExport virtual bool FindRef(RefTargetHandle rtarg, int& row, int& col);
		CoreExport virtual void CloneRefs(ReferenceMaker *, RemapDir& remap);

};
#endif //_REF_ARRAY_BASE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\random.h ===
/**********************************************************************
 *<
        FILE: random.h

        DESCRIPTION: Pseudo-random number generator

        CREATED BY: Jeff Kowalski

        HISTORY: Created 11 February 1999

 *>     Copyright (c) 1999, All Rights Reserved.
 **********************************************************************/

#ifndef __RANDOM__H
#define __RANDOM__H

/*
 * This class defines a Pseudo-random number generator that precisely
 * matches the behavior of the MSVCRT 6.0 random routines.
 * That is to say, for equivalent calls to ::srand() and Random::srand(),
 * both ::rand() and Random::rand() will produce the same results.
 *
 * The benefit, however, in having this class is that each instantiation
 * is independent, permitting several uncoupled random number generators
 * to be present in the system at once.  Moreover, each instantiation
 * is automatically "pre-seeded", making calls to Random::srand unnecessary
 * in most uses.  Even arrays of Random items will operate independently.
 *
 * In addition to providing the analogues to the "stdlib" functions, this
 * class also provides two useful member functions which can be used
 * to get a random number bounded in either a float or int interval.
 */
class Random {
    private:
        long   m_seed;

    public:
        // The constructor will automatically initialize the seed
        UtilExport Random ();

        // Analogues of the random rountines from MSVCRT:
        UtilExport void    srand (unsigned int seed = 1); // akin to global ::srand
        UtilExport int     rand  ();                      // akin to global ::rand
        UtilExport static const int s_rand_max;           // akin to global RAND_MAX

        // Returns a random number in the half-open interval [min, max)
        //      such that r=get(max, min)  :=  min <= r < max
        // Note that max is the first arg, and min is the second, permitting
        // one to select, for example, an int in [0,5) = [0,4] with "get(5)"
        // With no arguments, Random::get() is equivalent to Random::rand()
        inline int   get  (int   max_exclusive = s_rand_max+1,
                           int   min_inclusive = 0) {
            return this->rand() %
                     (max_exclusive - min_inclusive) + min_inclusive;
        }

        // Returns a random number in the half-open interval [min, max)
        //      such that r=get(max, min)  :=  min <= r < max
        // Note that max is the first arg, and min is the second, permitting
        // one to select, for example, a float in [0.0, 5.0) with "getf(5)"
        // With no arguments, Random::getf() returns a float in [0.0, 1.0)
        inline float getf (float max_exclusive = 1.0f,
                           float min_inclusive = 0.0f) {
            return this->rand() / (s_rand_max+1.0f) *
                     (max_exclusive - min_inclusive) + min_inclusive;
        }
};

#endif // __RANDOM__H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\render.h ===
/**********************************************************************
 *<
	FILE: render.h

	DESCRIPTION:

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/


#ifndef __RENDER__H
#define __RENDER__H

#define FIELD_EVEN 0
#define FIELD_ODD 1

// Render Types   RB: I didn't want to include render.h in MAXAPI.H...
#ifndef _REND_TYPE_DEFINED
#define _REND_TYPE_DEFINED
enum RendType { 
	RENDTYPE_NORMAL,
	RENDTYPE_REGION,
	RENDTYPE_BLOWUP,
	RENDTYPE_SELECT,
	RENDTYPE_REGIONCROP
	};
#endif


class DefaultLight {
	public:
	LightState ls;
	Matrix3 tm;	
	};

class ViewParams {
	public:
		Matrix3 prevAffineTM; // world space to camera space transform 2 ticks previous 
		Matrix3 affineTM;  // world space to camera space transform
		int projType;      // PROJ_PERSPECTIVE or PROJ_PARALLEL
		float hither,yon;
		float distance; // to view plane
		// Parallel projection params
		float zoom;  // Zoom factor 
		// Perspective params
		float fov; 	// field of view
		float nearRange; // for fog effects
		float farRange;  // for fog effects
		// Generic expansion function
		virtual int Execute(int cmd, ULONG arg1=0, ULONG arg2=0, ULONG arg3=0) { return 0; } 
	};


// Common renderer parameters

class Atmospheric;

#ifdef DESIGN_VER
// Even if rendering to another device (i.e., Printer) is supported in the renderer,
// render to a preview window instead if it is supported. This goes in the extraFlags 
// field of RendParams.
#define RENDER_REDIRECT_TO_WINDOW     (1L << 1)
#endif

// These parameters are passed to the renderer when the renderer is opend.
class RendParams {
	public:
	RendType rendType;	 	// normal, region, blowup, selection

	BOOL isNetRender;  		// is this a render on a network slave?	
	BOOL fieldRender;
	int fieldOrder;    		// 0->even, 1-> odd
	TimeValue frameDur; 	// duration of one frame
	
	BOOL colorCheck;
	int vidCorrectMethod; 	// 0->FLAG, 1->SCALE_LUMA 2->SCALE_SAT
	int ntscPAL;  			// 0 ->NTSC,  1 ->PAL
	BOOL superBlack;		// impose superBlack minimum intensity?
	int sbThresh;			// value used for superBlack
	BOOL rendHidden;		// render hidden objects?
	BOOL force2Side;		// force two-sided rendering?
	BOOL inMtlEdit;	  		// rendering in the mtl editor?
	float mtlEditTile; 		// if in mtl editor, scale tiling by this value
	BOOL mtlEditAA;   		// if in mtl editor, antialias? 
	BOOL multiThread; 		// for testing only
	BOOL useEnvironAlpha;  	// use alpha from the environment map.
	BOOL dontAntialiasBG; 	// Don't antialias against background (for video games)		
	BOOL useDisplacement; 	// Apply displacment mapping		
	Texmap *envMap;			// The environment map, may be NULL
	Atmospheric *atmos; 	// The atmosphere effects, may be NULL.
	Effect *effect; 	    // The postprocessing effects, may be NULL.
	TimeValue firstFrame; 	// The first frame that will be rendered
	int scanBandHeight;		// height of a scan band (default scanline renderer)
	ULONG extraFlags;		// for expansion
	int width,height;		// image width,height.
	BOOL filterBG;			// filter background
	RendParams() { 
		rendType = RENDTYPE_NORMAL;
		isNetRender = FALSE;
		fieldRender = FALSE;
		fieldOrder =0;   
		frameDur=0; 
		colorCheck=0;
		vidCorrectMethod=0; 
		ntscPAL=0;
		superBlack=0;
		sbThresh=0;	
		rendHidden=0;
		force2Side=0;
		inMtlEdit=0;  
		mtlEditTile=0; 
		mtlEditAA=0;  
		multiThread=0; 
		useEnvironAlpha=0; 	
		dontAntialiasBG=0;
		useDisplacement=0;
		envMap=NULL;
		atmos=NULL; 
		effect=NULL; 
		firstFrame=0; 
		scanBandHeight=0;
		extraFlags=0;
		width=height=0;	
		filterBG = 0;
		}
	// Generic expansion function
	virtual int Execute(int cmd, ULONG arg1=0, ULONG arg2=0, ULONG arg3=0) { return 0; } 
	};						   

// These are passed to the renderer on every frame
class FrameRendParams {
	public:
	Color ambient;
	Color background;
	Color globalLightLevel;
	float frameDuration; // duration of one frame, in current frames
	float relSubFrameDuration;  // relative fraction of frameDuration used by subframe.

	// boundaries of the region for render region or crop (device coords).
	int regxmin,regxmax;
	int regymin,regymax;

	// parameters for render blowup.
	Point2 blowupCenter;
	Point2 blowupFactor;

	FrameRendParams() { frameDuration = 1.0f; relSubFrameDuration = 1.0f; }
	// Generic expansion function
	virtual int Execute(int cmd, ULONG arg1=0, ULONG arg2=0, ULONG arg3=0) { return 0; } 
	};

// Since this dialog is modless and non-interactive, as the user changes
// parameters in the dialog, the renderer does not need to update it's
// state. When the user is through, they may choose 'OK' or 'Cancel'.
//
// If the user OKs the dialog, AcceptParams() will be called, at which time the
// renderer can read the parameter out of the UI and modify its state.
// 
// If RejectParams() is called, typically the renderer will not have to do anything
// since it has not yet modify its state, but if for some reason it has, it
// should restore its state.
class RendParamDlg {
	public:
		virtual void AcceptParams()=0;
		virtual void RejectParams() {}
		virtual void DeleteThis()=0;		
	};

// Flag bits for DoMaterialBrowseDlg()
#define BROWSE_MATSONLY		(1<<0)
#define BROWSE_MAPSONLY		(1<<1)
#define BROWSE_INCNONE		(1<<2) 	// Include 'None' as an option
#define BROWSE_INSTANCEONLY	(1<<3) 	// Only allow instances, no copy
#define BROWSE_TO_MEDIT_SLOT (1<<4) // browsing to medit slot
 
// passed to SetPickMode. This is a callback that gets called as
// the user tries to pick objects in the scene.
class RendPickProc {
	public:
		// Called when the user picks something.
		// return TRUE to end the pick mode.
		virtual BOOL Pick(INode *node)=0;

		// Return TRUE if this is an acceptable hit, FALSE otherwise.
		virtual BOOL Filter(INode *node)=0;

		// These are called as the mode is entered and exited
		virtual void EnterMode() {}
		virtual void ExitMode() {}

		// Provides two cursor, 1 when over a pickable object and 1 when not.
		virtual HCURSOR GetDefCursor() {return NULL;}
		virtual HCURSOR GetHitCursor() {return NULL;}

		// Return TRUE to allow the user to pick more than one thing.
		// In this case the Pick method may be called more than once.
		virtual BOOL AllowMultiSelect() {return FALSE;}
	};


// This is the interface given to a renderer when it needs to display its parameters
// It is also given to atmospheric effects to display thier parameters.
class IRendParams {
	public:
		// The current position of the frame slider
		virtual TimeValue GetTime()=0;

		// Register a callback object that will get called every time the
		// user changes the frame slider.
		virtual void RegisterTimeChangeCallback(TimeChangeCallback *tc)=0;
		virtual void UnRegisterTimeChangeCallback(TimeChangeCallback *tc)=0;

		// Brings up the material browse dialog allowing the user to select a material.
		// newMat will be set to TRUE if the material is new OR cloned.
		// Cancel will be set to TRUE if the user cancels the dialog.
		// The material returned will be NULL if the user selects 'None'
		virtual MtlBase *DoMaterialBrowseDlg(HWND hParent,DWORD flags,BOOL &newMat,BOOL &cancel)=0;

		// Adds rollup pages to the render params dialog. Returns the window
		// handle of the dialog that makes up the page.
		virtual HWND AddRollupPage(HINSTANCE hInst, TCHAR *dlgTemplate, 
			DLGPROC dlgProc, TCHAR *title, LPARAM param=0,DWORD flags=0)=0;

		// Removes a rollup page and destroys it.
		virtual void DeleteRollupPage(HWND hRollup)=0;

		// When the user mouses down in dead area, the plug-in should pass
		// mouse messages to this function which will pass them on to the rollup.
		virtual void RollupMouseMessage(HWND hDlg, UINT message, 
					WPARAM wParam, LPARAM lParam)=0;

		// This will set the command mode to a standard pick mode.
		// The callback implements hit testing and a method that is
		// called when the user actually picks an item.
		virtual void SetPickMode(RendPickProc *proc)=0;
		
		// If a plug-in is finished editing its parameters it should not
		// leave the user in a pick mode. This will flush out any pick modes
		// in the command stack.
		virtual void EndPickMode()=0;
			
		// When a plugin has a Texmap, clicking on the button
		// associated with that map should cause this routine
		// to be called.
		virtual void PutMtlToMtlEditor(MtlBase *mb)=0;

		// This is for use only by the scanline renderer.
		virtual float GetMaxPixelSize() = 0;
		virtual int Execute(int cmd, ULONG arg1=0, ULONG arg2=0, ULONG arg3=0) { return 0; } 

		// JBW 12/1/98: get interface to rollup window interface
		virtual IRollupWindow* GetIRollup()=0;
	};


//----------------------------------------------------------------
// Render Instance flags
#define INST_HIDE	  		(1<<0) // instance is hidden
#define INST_CLIP			(1<<1) // clip instance: ray tracers should skip it 
#define INST_BLUR			(1<<2) // secondary motion blur instance 
#define INST_RCV_SHADOWS	(1<<3) // instance receives shadows
#define INST_TM_NEGPARITY	(1<<4) // mesh is inside-out: need to reverse normals on-the-fly


class RenderInstance {
	public:
		ULONG flags;
		Mtl *mtl;       		// from inode, for convenience
		float wireSize;         // Mtl wireframe size
		Mesh *mesh;				// result of GetRenderMesh call
		float vis;				// Object visibility
		int nodeID;				// unique within scene during render- corresponds to ShadeContext::NodeID()
		int objMotBlurFrame;  	// Object motion blur sub frame (= NO_MOTBLUR for non-blurred objects)
		int objBlurID;		    // Blur instances for an object share a objBlurID value.
		Matrix3 objToWorld;		// transforms object coords to world coords
		Matrix3 objToCam;		// transforms object coords to cam coords
		Matrix3 normalObjToCam; // for transforming surface normals from obj to camera space
		Matrix3 camToObj;    	// transforms camera coords to object coords
		Box3 obBox;				// Object space extents
		Point3 center;			// Bounding sphere center (camera coords)
		float radsq;			// square of bounding sphere's radius

		void SetFlag(ULONG f, BOOL b) { if (b) flags |= f; else flags &= ~f; }
		void SetFlag(ULONG f) {  flags |= f; }
		void ClearFlag(ULONG f) {  flags &= ~f; }
		BOOL TestFlag(ULONG f) { return flags&f?1:0; }
		BOOL Hidden() { return TestFlag(INST_HIDE); }
		BOOL IsClip() { return TestFlag(INST_CLIP); }

		virtual RenderInstance *Next()=0;	// next in list

		virtual Interval MeshValidity()=0;
		virtual int NumLights()=0;
		virtual LightDesc *Light(int n)=0; 

		virtual BOOL CastsShadowsFrom(const ObjLightDesc& lt)=0; // is lt shadowed by this instance?

		virtual INode *GetINode()=0;  						 // get INode for instance
		virtual Object *GetEvalObject()=0; 					 // evaluated object for instance
		virtual ULONG MtlRequirements(int mtlNum)=0;		 // node's mtl requirements
		virtual void MtlMapsRequired (BitArray & mapreq) { mapreq.SetSize(2); mapreq.Clear(0); mapreq.Set(1); }
		virtual Point3 GetFaceNormal(int faceNum)=0;         // geometric normal in camera coords
		virtual Point3 GetFaceVertNormal(int faceNum, int vertNum)=0;  // camera coords
		virtual void GetFaceVertNormals(int faceNum, Point3 n[3])=0;   // camera coords
		virtual Point3 GetCamVert(int vertnum)=0; 			 // coord for vertex in camera coords		
		virtual void GetObjVerts(int fnum, Point3 obp[3])=0; // vertices of face in object coords
		virtual void GetCamVerts(int fnum, Point3 cp[3])=0; // vertices of face in camera(view) coords
		// Generic expansion function
		virtual int Execute(int cmd, ULONG arg1=0, ULONG arg2=0, ULONG arg3=0) { return 0; } 
	};

//----------------------------------------------------------------


// Values returned from Progress()
#define RENDPROG_CONTINUE	1
#define RENDPROG_ABORT		0

// Values passed to SetCurField()
#define FIELD_FIRST		0
#define FIELD_SECOND	1
#define FIELD_NONE		-1

// A callback passed in to the renderer
class RendProgressCallback {
	public:
		virtual void SetTitle(const TCHAR *title)=0;
		virtual int Progress(int done, int total)=0;
		virtual void SetCurField(int which) {}
		virtual void SetSceneStats(int nlights, int nrayTraced, int nshadowed, int nobj, int nfaces) {}
	};




// RB: my version of a renderer...
class Renderer : public ReferenceTarget {
	public:
		// Reference/Animatable methods.
		// In addition, the renderer would need to implement ClassID() and DeleteThis()
		// Since a renderer will probably not itself have references, this implementation should do
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	         PartID& partID,  RefMessage message) {return REF_SUCCEED;}
		SClass_ID SuperClassID() {return RENDERER_CLASS_ID;}
		
		virtual int Open(
			INode *scene,     	// root node of scene to render
			INode *vnode,     	// view node (camera or light), or NULL
			ViewParams *viewPar,// view params for rendering ortho or user viewport
			RendParams &rp,  	// common renderer parameters
			HWND hwnd, 				// owner window, for messages
			DefaultLight* defaultLights=NULL, // Array of default lights if none in scene
			int numDefLights=0	// number of lights in defaultLights array
			)=0;
						
		//
		// Render a frame -- will use camera or view from open
		//
		virtual int Render(
			TimeValue t,   			// frame to render.
   			Bitmap *tobm, 			// optional target bitmap
			FrameRendParams &frp,	// Time dependent parameters
			HWND hwnd, 				// owner window
			RendProgressCallback *prog=NULL,
			ViewParams *viewPar=NULL  // override viewPar given on Open.
			)=0;
		virtual void Close(	HWND hwnd )=0;		

		// Adds rollup page(s) to renderer configure dialog
		// If prog==TRUE then the rollup page should just display the parameters
		// so the user has them for reference while rendering, they should not be editable.
		virtual RendParamDlg *CreateParamDialog(IRendParams *ir,BOOL prog=FALSE)=0;
		virtual void ResetParams()=0;
		virtual int	GetAAFilterSupport(){ return 0; } // point sample, no reconstruction filter

	};


class ShadowBuffer;
class ShadowQuadTree;

class RendContext {
	public:
		virtual int Progress(int done, int total) const { return 1; }
		virtual Color GlobalLightLevel() const = 0;
	};

struct SubRendParams {
	RendType rendType;	
	BOOL fieldRender;
	BOOL evenLines; // when field rendering
	BOOL doingMirror;
	BOOL doEnvMap;  // do environment maps?
	int devWidth, devHeight;
	float devAspect;
	int xorg, yorg;           // location on screen of upper left corner of output bitmap
	int xmin,xmax,ymin,ymax;  // area of screen being rendered
	virtual int Execute(int cmd, ULONG arg1=0, ULONG arg2=0, ULONG arg3=0) { return 0; } 
	};

// flags passed to RenderMapsContext::Render()
#define RENDMAP_SHOW_NODE  1  // *Dont* exclude this node from the render.


// A pointer to this data structure is passed to MtlBase::BuildMaps();
// when rendering reflection and refraction maps.
class RenderMapsContext { 
	public:
	    virtual INode *GetNode()=0;
		virtual int NodeRenderID()=0;
		virtual void GetCurrentViewParams(ViewParams &vp)=0;
		virtual void GetSubRendParams(SubRendParams &srp)=0;
		virtual int SubMtlIndex()=0;
		virtual void SetSubMtlIndex(int mindex)=0;
	    virtual void FindMtlPlane(float pl[4])=0;
		virtual void FindMtlScreenBox(Rect &sbox, Matrix3* viewTM=NULL, int mtlIndex=-1)=0;
		virtual Box3 CameraSpaceBoundingBox()=0;
		virtual Box3 ObjectSpaceBoundingBox()=0;
		virtual Matrix3 ObjectToWorldTM()=0;
		virtual RenderGlobalContext *GetGlobalContext() { return NULL; }
		// ClipPlanes is a pointer to an array of Point4's,  each of which
		// represents a clip plane.  nClip Planes is the number of planes (up to 6);
		// The planes are in View space.
		virtual	int Render(Bitmap *bm, ViewParams &vp, SubRendParams &srp, Point4 *clipPlanes=NULL, int nClipPlanes=0)=0; 
		virtual int Execute(int cmd, ULONG arg1=0, ULONG arg2=0, ULONG arg3=0) { return 0; } 
	};	




#define DONT_CLIP 1.0E38f

class SFXParamDlg {
	public:
		virtual Class_ID ClassID()=0;
		virtual void SetThing(ReferenceTarget *m)=0;
		virtual ReferenceTarget* GetThing()=0;
		virtual void SetTime(TimeValue t) { }		
		virtual void DeleteThis()=0;		
		virtual int Execute(int cmd, ULONG arg1=0, ULONG arg2=0, ULONG arg3=0) { return 0; } 
		virtual void InvalidateUI() { }	

	};


// Special Effect: Base class for Atmospherics, Effects, shaders
class SpecialFX: public ReferenceTarget {
	public:
		TSTR name;
		// This name will appear in the track view and the list of current atmospheric effects.
		virtual TSTR GetName() {return _T("");}		

		// Is effect active 
		virtual BOOL Active(TimeValue t) { 
			return !TestAFlag(A_ATMOS_DISABLED); 
			}

		// Called when the render steps to a new frame
		virtual	void Update(TimeValue t, Interval& valid) {}

		// Saves and loads name. These should be called at the start of
		// a plug-in's save and load methods.
		CoreExport IOResult Save(ISave *isave);
		CoreExport IOResult Load(ILoad *iload);

		// If an atmospheric has references to gizmos or other objects in the scene it can optionally 
		// provide access to the object list.
		virtual int NumGizmos() {return 0;}
		virtual INode *GetGizmo(int i) {return NULL;}
		virtual void DeleteGizmo(int i) {}
		virtual void AppendGizmo(INode *node) {}
		virtual BOOL OKGizmo(INode *node) { return FALSE; } // approve a node for possible use as gizmo
		virtual void EditGizmo(INode *node) {} // selects this gizmo & displays params for it if any
		virtual	void InsertGizmo(int i, INode *node) { assert(0); } // must be defined to use DeleteGizmoRestore

		// Animatable overides...
		CoreExport SvGraphNodeReference SvTraverseAnimGraph(IGraphObjectManager *gom, Animatable *owner, int id, DWORD flags);
	};


// Classes used for implementing UNDO in Atmosphere and Effects classes.
class AppendGizmoRestore: public RestoreObj {
	public:
		SpecialFX *fx;
		INode *node;
		AppendGizmoRestore(SpecialFX *f, INode *n) {	fx= f;	node = n;	}
		void Redo() {	fx->AppendGizmo(node);		}
		void Restore(int isUndo) {	fx->DeleteGizmo(fx->NumGizmos()-1);	} 
		TSTR Description() { return TSTR("AppendGizmoRestore"); }
	};

class DeleteGizmoRestore: public RestoreObj {
	public:
		SpecialFX *fx;
		INode *node;
		int num;
		DeleteGizmoRestore(SpecialFX *a, INode *n, int i) {	fx = a; node = n; num = i;	}
		void Redo() {	fx->DeleteGizmo(num);		}
		void Restore(int isUndo) {	fx->InsertGizmo(num,node);		} 
		TSTR Description() { return TSTR("DeleteGizmoRestore"); }
	};

//--- Atmospheric plug-in interfaces -----------------------------------------------


// Atmospheric plug-in base class

// Returned by an  Atmospheric when it is asked to put up its rollup page.
typedef SFXParamDlg AtmosParamDlg;

class Atmospheric : public SpecialFX {
	public:
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	         PartID& partID,  RefMessage message) {return REF_SUCCEED;}
		SClass_ID SuperClassID() {return ATMOSPHERIC_CLASS_ID;}
		
		// Saves and loads name. These should be called at the start of
		// a plug-in's save and load methods.
		IOResult Save(ISave *isave) { return SpecialFX::Save(isave); }
		IOResult Load(ILoad *iload) { return SpecialFX::Load(iload); }

		// Put up a modal dialog that lets the user edit the plug-ins parameters.
		virtual AtmosParamDlg *CreateParamDialog(IRendParams *ip) {return NULL;}
		// Implement this if you are using the ParamMap2 AUTO_UI system and the 
		// atmosphere has secondary dialogs that don't have the effect as their 'thing'.
		// Called once for each secondary dialog for you to install the correct thing.
		// Return TRUE if you process the dialog, false otherwise.
		virtual BOOL SetDlgThing(AtmosParamDlg* dlg) { return FALSE; }

		// This is the function that is called to apply the effect.
		virtual void Shade(ShadeContext& sc,const Point3& p0,const Point3& p1,Color& color, Color& trans, BOOL isBG=FALSE)=0;


	};

#define SFXBASE_CHUNK	0x39bf
#define SFXNAME_CHUNK	0x0100

// Chunk IDs saved by base class
#define ATMOSHPERICBASE_CHUNK	SFXBASE_CHUNK
#define ATMOSHPERICNAME_CHUNK	SFXNAME_CHUNK


//--------------------------------------------------------------------------
// Interface into the default scanline renderer, Class_ID(SREND_CLASS_ID,0)
//---------------------------------------------------------------------------
class FilterKernel;
class IScanRenderer: public Renderer {
	public:
	virtual void SetAntialias(BOOL b) = 0;
	virtual BOOL GetAntialias() = 0;
	virtual void SetFilter(BOOL b) = 0;
	virtual BOOL GetFilter() = 0;
	virtual void SetShadows(BOOL b) = 0;
	virtual BOOL GetShadows() = 0;
	virtual void SetMapping(BOOL b) = 0;
	virtual BOOL GetMapping() = 0;
	virtual void SetForceWire(BOOL b) = 0;
	virtual BOOL GetForceWire() = 0;
	virtual	void SetAutoReflect(BOOL b)=0;
	virtual	BOOL GetAutoReflect()=0;
	virtual void SetObjMotBlur(BOOL b) = 0;
	virtual BOOL GetObjMotBlur() = 0;
	virtual void SetVelMotBlur(BOOL b) = 0;
	virtual BOOL GetVelMotBlur() = 0;

	// Obsolete, use setfiltersz. pixel sz = 1.0 for all filtering
	virtual void SetPixelSize(float size) = 0;
	
	virtual void SetAutoReflLevels(int n) = 0;
	virtual void SetWireThickness(float t) = 0;
	virtual void SetObjBlurDuration(float dur) = 0;
	virtual void SetVelBlurDuration(float dur) = 0;
	virtual void SetNBlurFrames(int n) = 0;
	virtual void SetNBlurSamples(int n) = 0;
	virtual void SetMaxRayDepth(int n) = 0;
	virtual int GetMaxRayDepth() { return 7; }

	virtual void SetAntiAliasFilter( FilterKernel * pKernel ) = 0;
	virtual FilterKernel * GetAntiAliasFilter() = 0;
	virtual void SetAntiAliasFilterSz(float size) = 0;
	virtual float GetAntiAliasFilterSz() = 0;

	virtual void SetPixelSamplerEnable( BOOL on ) = 0;
	virtual BOOL GetPixelSamplerEnable() = 0;
};


// Render Post effects;

// Returned by an  effect when it is asked to put up its rollup page.
typedef SFXParamDlg EffectParamDlg;

class CheckAbortCallback {
	public:
	virtual BOOL Check()=0;  // returns TRUE if user has done something to cause an abort.
	virtual	BOOL Progress(int done, int total)=0;
	virtual void SetTitle(const TCHAR *title)=0;
	};

class Effect : public SpecialFX {
	public:
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	         PartID& partID,  RefMessage message) {return REF_SUCCEED;}
		SClass_ID SuperClassID() {return RENDER_EFFECT_CLASS_ID;}

		// Saves and loads name. These should be called at the start of
		// a plug-in's save and load methods.
		IOResult Save(ISave *isave) { return SpecialFX::Save(isave); }
		IOResult Load(ILoad *iload) { return SpecialFX::Load(iload); }

		// Put up a dialog that lets the user edit the plug-ins parameters.
		virtual EffectParamDlg *CreateParamDialog(IRendParams *ip) {return NULL;}
		// Implement this if you are using the ParamMap2 AUTO_UI system and the 
		// effect has secondary dialogs that don't have the effect as their 'thing'.
		// Called once for each secondary dialog for you to install the correct thing.
		// Return TRUE if you process the dialog, false otherwise.
		virtual BOOL SetDlgThing(EffectParamDlg* dlg) { return FALSE; }

		// What G-buffer channels does this Effect require in the output bitmap?
		virtual DWORD GBufferChannelsRequired(TimeValue t) { return 0; /*BMM_CHAN_NONE;*/ }

		// This is the function that is called to apply the effect.
		virtual void Apply(TimeValue t, Bitmap *bm, RenderGlobalContext *gc, CheckAbortCallback *cb )=0;

	};

// Chunk IDs saved by base class
#define EFFECTBASE_CHUNK	SFXBASE_CHUNK
#define EFFECTNAME_CHUNK	SFXNAME_CHUNK

////////////////////////////////////////////////////////////////////////
//
// Filter Kernel Plug-ins;
//
#define AREA_KERNEL_CLASS_ID			0x77912301
#define DEFAULT_KERNEL_CLASS_ID			AREA_KERNEL_CLASS_ID

// Returned by a kernel when it is asked to put up its rollup page.
typedef SFXParamDlg FilterKernelParamDlg;

class FilterKernel : public SpecialFX {
	public:
		RefResult NotifyRefChanged( Interval changeInt, 
									RefTargetHandle hTarget, 
							        PartID& partID, 
									RefMessage message ) { return REF_SUCCEED; }

		SClass_ID SuperClassID() { return FILTER_KERNEL_CLASS_ID; }
		
		// Saves and loads name. These should be called at the start of
		// a plug-in's save and load methods.
		IOResult Save(ISave *isave) { return SpecialFX::Save(isave); }
		IOResult Load(ILoad *iload) { return SpecialFX::Load(iload); }

		// Put up a dialog that lets the user edit the plug-ins parameters.
		virtual FilterKernelParamDlg *CreateParamDialog( IRendParams *ip ) {return NULL;}

		// filter kernel section
		// This is the function that is called to sample kernel values.
		virtual double KernelFn( double x, double y = 0.0 )=0;

		// integer number of pixels from center to filter 0 edge, must not truncate filter
		// x dimension for 2D filters
		virtual long GetKernelSupport()=0;
		// for 2d returns y support, for 1d returns 0
		virtual long GetKernelSupportY()=0;

		virtual bool Is2DKernel()=0;
		virtual bool IsVariableSz()=0;
		// 1-D filters ignore the y parameter
		virtual void SetKernelSz( double x, double y = 0.0 )=0;
		virtual void GetKernelSz( double& x, double& y )=0;

		// returning true will disable the built-in normalizer
		virtual bool IsNormalized(){ return FALSE; }

		// this is for possible future optimizations, not sure its needed
		virtual bool HasNegativeLobes()=0;

		virtual TCHAR* GetDefaultComment()=0;

		// there are 2 optional 0.0 ...1.0 parameters, for whatever
		virtual long GetNFilterParams(){ return 0; }
		virtual TCHAR * GetFilterParamName( long nParam ){ return _T(""); }
		virtual double GetFilterParamMax( long nParam ){ return 1.0; }
		virtual double GetFilterParam( long nParam ){ return 0.0; }
		virtual void SetFilterParam( long nParam, double val ){};
	};

// Chunk IDs saved by base class
#define FILTERKERNELBASE_CHUNK	0x39bf
#define FILTERKERNELNAME_CHUNK	0x0100


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\rtclick.h ===
/*********************************************************************
 *<
	FILE: rtclick.h

	DESCRIPTION: Right-click menu functionality

	CREATED BY:	Tom Hudson

	HISTORY: Created 14 June 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#ifndef __RTCLICK__
#define __RTCLICK__

const int kMaxMenuEntries = 1000;

class RightClickMenuManager;

class RightClickMenu {
	public:
		virtual void Init(RightClickMenuManager* manager, HWND hWnd, IPoint2 m)=0;
		virtual void Selected(UINT id)=0;
	};

typedef RightClickMenu* PRightClickMenu;
typedef Tab<PRightClickMenu> PRightClickMenuTab;

class RCMData {
	public:
		RightClickMenu *menu;
		UINT menuId;
		UINT managerId;
		RCMData() { menu = NULL; menuId = managerId = 0; };
		RCMData(RightClickMenu *menu, UINT menuId, UINT managerID);
	};

typedef Tab<RCMData> RCMDataTab;

class RightClickMenuManager {
	private:
        Stack<HMENU> menuStack;
        Tab<HMENU>   allSubMenus;
		HMENU theMenu;
		PRightClickMenuTab menuTab;
		RCMDataTab dataTab;
		int index;
		int limit;
		int startId;
	public:
		CoreExport void Register(RightClickMenu *menu);
		CoreExport void Unregister(RightClickMenu *menu);
		CoreExport void Init(HMENU menu, int startId, int limit, HWND hWnd, IPoint2 m);
        CoreExport void CleanUp();

		CoreExport int AddMenu(RightClickMenu *menu, UINT flags, UINT id, LPCTSTR data);
        CoreExport int BeginSubMenu(LPCTSTR name);
        CoreExport int EndSubMenu();

		CoreExport void Process(UINT id);
	};

#endif // __RTCLICK__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\quat.h ===
/**********************************************************************
 *<
	FILE: quat.h

	DESCRIPTION: Class definitions for Quat

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#ifndef _QUAT_H 

#define _QUAT_H 

#include "matrix3.h"

class ostream;
class Quat;

class AngAxis {
public:
	Point3 axis;
	float angle;        // This angle is left-handed!

	AngAxis() {}
	AngAxis(float x, float y, float z, float ang)
		{ axis.x = x; axis.y = y; axis.z = z; angle = ang; }
	AngAxis(const Point3& axis,float angle) {this->axis=axis;this->angle=angle;}	
	DllExport AngAxis(const Quat &q);
	AngAxis(const Matrix3& m);

	AngAxis& Set(float x, float y, float z, float ang)
		{axis.x = x; axis.y = y; axis.z = z; angle = ang; return *this; }
	AngAxis& Set(const Point3& ax, float ang)
		{axis = ax; angle = ang; return *this; }
	DllExport AngAxis& Set(const Quat& q);
	DllExport AngAxis& Set(const Matrix3& m);
    
	DllExport int GetNumRevs();
	DllExport void SetNumRevs(int num);
	};

class Quat {
public:
	float x,y,z,w;

	// Constructors
	Quat(): x(0.0f),y(0.0f),z(0.0f),w(1.0f) {}
	Quat(float X, float Y, float Z, float W)  { x = X; y = Y; z = Z; w = W; }
	Quat(double X, double Y, double Z, double W)  { 
		x = (float)X; y = (float)Y; z = (float)Z; w = (float)W; 
		}
	Quat(const Quat& a) { x = a.x; y = a.y; z = a.z; w = a.w; } 
	Quat(float af[4]) { x = af[0]; y = af[1]; z = af[2]; w = af[3]; }
	DllExport Quat(const Matrix3& mat);
	DllExport Quat(const AngAxis& aa);
	DllExport Quat(const Point3& V, float W);

	// Access operators
	float& operator[](int i) { return (&x)[i]; }     
	const float& operator[](int i) const { return (&x)[i]; }
    
	float Scalar() { return w; }
	Point3 Vector() { return Point3(x, y, z); }

	// Conversion function
	operator float*() { return(&x); }

	// Unary operators
	Quat operator-() const { return(Quat(-x,-y,-z,-w)); } 
	Quat operator+() const { return *this; }
    
    // Math functions
	DllExport Quat Inverse() const;
	DllExport Quat Conjugate() const;
	DllExport Quat LogN() const;
	DllExport Quat Exp() const;

	// Assignment operators
	DllExport Quat& operator-=(const Quat&);
	DllExport Quat& operator+=(const Quat&);
	DllExport Quat& operator*=(const Quat&);
	DllExport Quat& operator*=(float);
	DllExport Quat& operator/=(float);

	Quat& Set(float X, float Y, float Z, float W)
		{ x = X; y = Y; z = Z; w = W; return *this; }
	Quat& Set(double X, double Y, double Z, double W)
		{ x = (float)X; y = (float)Y; z = (float)Z; w = (float)W;
		return *this; }
	DllExport Quat& Set(const Matrix3& mat);
	DllExport Quat& Set(const AngAxis& aa);
	Quat& Set(const Point3& V, float W)
		{ x = V.x; y = V.y; z = V.z; w = W; return *this; } 
	DllExport Quat& SetEuler(float X, float Y, float Z);
	DllExport Quat& Invert();                 // in place

	DllExport Quat& MakeClosest(const Quat& qto);

	// Comparison
	DllExport int operator==(const Quat& a) const;
	DllExport int Equals(const Quat& a, float epsilon = 1E-6f) const;

	void Identity() { x = y = z = (float)0.0; w = (float) 1.0; }
	DllExport int IsIdentity() const;
	DllExport void Normalize();  // normalize
	DllExport void MakeMatrix(Matrix3 &mat) const;
	DllExport void GetEuler(float *X, float *Y, float *Z) const;

	// Binary operators
	DllExport Quat operator-(const Quat&) const;  //RB: Changed these to		// difference of two quaternions
	DllExport Quat operator+(const Quat&) const;  // duplicate * and /			// sum of two quaternions
	DllExport Quat operator*(const Quat&) const;  // product of two quaternions
	DllExport Quat operator/(const Quat&) const;  // ratio of two quaternions
	DllExport float operator%(const Quat&) const;   // dot product
	DllExport Quat Plus(const Quat&) const;       // what + should have done
	DllExport Quat Minus(const Quat&) const;      // what - should have done
    };

Quat DllExport operator*(float, const Quat&);	// multiply by scalar
Quat DllExport operator*(const Quat&, float);	// multiply by scalar
Quat DllExport operator/(const Quat&, float);	// divide by scalar
Quat DllExport Inverse(const Quat& q);  // Inverse of quaternion (1/q)
Quat DllExport Conjugate(const Quat& q); 
Quat DllExport LogN(const Quat& q);
Quat DllExport Exp(const Quat& q);
Quat DllExport Slerp(const Quat& p, const Quat& q, float t);
Quat DllExport LnDif(const Quat& p, const Quat& q);
Quat DllExport QCompA(const Quat& qprev,const Quat& q, const Quat& qnext);
Quat DllExport Squad(const Quat& p, const Quat& a, const Quat &b, const Quat& q, float t); 
Quat DllExport qorthog(const Quat& p, const Point3& axis);
Quat DllExport squadrev(
		float angle,	// angle of rotation 
		const Point3& axis,	// the axis of rotation 
		const Quat& p,		// start quaternion 
		const Quat& a, 		// start tangent quaternion 
		const Quat& b, 		// end tangent quaternion 
		const Quat& q,		// end quaternion 
		float t 		// parameter, in range [0.0,1.0] 
		);

void DllExport RotateMatrix(Matrix3& mat, const Quat& q);	  
void DllExport PreRotateMatrix(Matrix3& mat, const Quat& q);
Quat DllExport QFromAngAxis(float ang, const Point3& axis);
void DllExport AngAxisFromQ(const Quat& q, float *ang, Point3& axis);
float DllExport QangAxis(const Quat& p, const Quat& q, Point3& axis);
void DllExport DecomposeMatrix(const Matrix3& mat, Point3& p, Quat& q, Point3& s);
Quat DllExport TransformQuat(const Matrix3 &m, const Quat&q );
inline Quat IdentQuat() { return(Quat(0.0,0.0,0.0,1.0)); }

// Assumes Euler angles are of the form:
// RotateX(ang[0])
// RotateY(ang[1])
// RotateZ(ang[2])
//
void DllExport QuatToEuler(Quat &q, float *ang);
void DllExport EulerToQuat(float *ang, Quat &q);

ostream DllExport &operator<<(ostream&, const Quat&); 

#endif _QUAT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\sbmtlapi.h ===
/**********************************************************************
 *<
	FILE:			sbmtlapi.h

	DESCRIPTION:	Object Sub Material API

	CREATED BY:		Christer Janson

	HISTORY:		1-19-98

 *>	Copyright (c) 1998, All Rights Reserved.
 **********************************************************************/

// By deriving your object or modifier from this class you will support
// direct assignment of sub materials to selected faces/elements.
// For a reference implementation of this class, please refer to
// maxsdk\samples\pack1\triobjed.cpp

#ifndef __SBMTLAPI_H__
#define __SBMTLAPI_H__

class ISubMtlAPI {
public:
	// Return a material ID that is currently not used by the object.
	// If the current face selection share once single MtlID that is not
	// used by any other faces, you should use it.
	virtual MtlID	GetNextAvailMtlID(ModContext* mc) = 0;
	// Indicate if you are active in the modifier panel and have an 
	// active face selection
	virtual BOOL	HasFaceSelection(ModContext* mc) = 0;
	// Set the selected faces to the specified material ID.
	// If bResetUnsel is TRUE, then you should set the remaining
	// faces material ID's to 0
	virtual void	SetSelFaceMtlID(ModContext* mc, MtlID id, BOOL bResetUnsel = FALSE) = 0;
	// Return the material ID of the selected face(s).
	// If multiple faces are selected they should all have the same MtlID -
	// otherwise you should return -1.
	// If faces other than the selected share the same material ID, then 
	// you should return -1.
	virtual int		GetSelFaceUniqueMtlID(ModContext* mc) = 0;
	// Return the material ID of the selected face(s).
	// If multiple faces are selected they should all have the same MtlID,
	// otherwise you should return -1.
	virtual int		GetSelFaceAnyMtlID(ModContext* mc) = 0;
	// Return the highest MtlID on the object.
	virtual	int		GetMaxMtlID(ModContext* mc) = 0;
};

#endif //__SBMTLAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\samplers.h ===
/////////////////////////////////////////////////////////////////////////
//
//
//	Sampler Plug-Ins
//
//	Created 11/30/98	Kells Elmquist
//

#ifndef	SAMPLERS_H
#define SAMPLERS_H

// Default Sampler ClassId
#define R25_SAMPLER_CLASS_ID			0x25773211
#define DEFAULT_SAMPLER_CLASS_ID		R25_SAMPLER_CLASS_ID


typedef	ULONG	MASK[2];

class ShadeContext;

typedef SFXParamDlg SamplerParamDlg;

class SamplingCallback {
	public:
	virtual BOOL SampleAtOffset( Color &col, Color &trans, Point2& sample, float sampleScale )=0;
};

class StdMat2;

class Sampler : public SpecialFX {
	public:
		RefResult NotifyRefChanged( Interval changeInt, 
									RefTargetHandle hTarget, 
							        PartID& partID, 
									RefMessage message ) { return REF_SUCCEED; }

		SClass_ID SuperClassID() { return SAMPLER_CLASS_ID; }
		
		// Saves and loads name. These should be called at the start of
		// a plug-in's save and load methods.
		IOResult Save(ISave *isave) { return SpecialFX::Save(isave); }
		IOResult Load(ILoad *iload) { return SpecialFX::Load(iload); }

		// this samples a sequence for the area
		virtual void DoSamples( Color& c, Color& t, SamplingCallback* cb, 
								ShadeContext* sc, MASK mask=NULL )=0;
		
		// integer number of samples for current quality
		virtual int GetNSamples()=0;	//what return when adaptive? n for max quality.

		// This is the one default parameter
		// Quality is nominal, 0...1, 
		// 0 is one sample, high about .75, 1.0 shd be awesome
		// for adaptive samplers, this sets the maximum quality
		virtual void SetQuality( float value )=0;
		virtual float GetQuality()=0;
		// returns 0 on "unchangeable", otherwise n quality levels
		virtual int SupportsQualityLevels()=0;

		virtual void SetEnable( BOOL samplingOn )=0;
		virtual BOOL GetEnable()=0;

		virtual TCHAR* GetDefaultComment()=0;

		// Adaptive Sampling, non-reqd methods
		// there are various optional params, this defines which ones to show/enable
		virtual ULONG SupportsStdParams(){ return 0; }

		// this determines whether to cut down the texture sample size of each sample, 
		// or whether to always use 1 pixel texture sample size
		virtual void SetTextureSuperSampleOn( BOOL on ){}
		virtual BOOL GetTextureSuperSampleOn(){ return FALSE; }

		virtual void SetAdaptiveOn( BOOL on ){}
		virtual BOOL IsAdaptiveOn(){ return FALSE; }

		virtual void SetAdaptiveThreshold( float value ){}
		virtual float GetAdaptiveThreshold(){ return 0.0f; }

		// there are 2 optional 0.0...max parameters, for whatever
		virtual long GetNOptionalParams(){ return 0; }
		virtual TCHAR * GetOptionalParamName( long nParam ){ return _T(""); }
		virtual float GetOptionalParamMax( long nParam ){ return 1.0f; }
		virtual float GetOptionalParam( long nParam ){ return 0.0f; };
		virtual void SetOptionalParam( long nParam, float val ){};

		// Put up a modal pop-up dialog that allows editing the sampler extended
		virtual void ExecuteParamDialog(HWND hWndParent, StdMat2* mtl ){}

		// Implement this if you are using the ParamMap2 AUTO_UI system and the 
		// effect has secondary dialogs that don't have the sampler as their 'thing'.
		// Called once for each secondary dialog for you to install the correct thing.
		// Return TRUE if you process the dialog, false otherwise.
		virtual BOOL SetDlgThing(EffectParamDlg* dlg) { return FALSE; }
	};

// There are the standard parameters for samplers
#define	IS_ADAPTIVE					0x1		// adaptive in some way
#define	ADAPTIVE_CHECK_BOX			0x2		// enable adaptive check box
#define	ADAPTIVE_THRESHOLD			0x4		// enable adaptive threshold spinner
#define	SUPER_SAMPLE_TEX_CHECK_BOX	0x8		// enable texture subsampling check box
#define	ADVANCED_DLG_BUTTON			0x10	// enable advanced button
#define	OPTIONAL_PARAM_0			0x20	// enable optional spinner
#define	OPTIONAL_PARAM_1			0x40	// enable optional spinner

#define	R3_ADAPTIVE					(IS_ADAPTIVE+ADAPTIVE_CHECK_BOX+ADAPTIVE_THRESHOLD)		

// Chunk IDs saved by base class
#define SAMPLERBASE_CHUNK	0x39bf
#define SAMPLERNAME_CHUNK	0x0100
#define SAMPLER_VERS_CHUNK  0x0200



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\shadbuf.h ===
/**********************************************************************
 *<
	FILE: shadbuf.h : Shadow buffer renderer.

	DESCRIPTION:

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __SHADBUF__H
#define __SHADBUF__H

class ShadBufRenderer {
	public:
		// Compute a shadow Z buffer for the current scene from the viewpoint of the light.
		// NOTE: The computed shadow buffer has positive Z values as you go away from the light, which is
		//       the reverse of the MAX coord system.
		// Returns the number of objects that the shadow volume intersected. If this value is 0,
		//   the shadow buffer can be freed to save memory.
		virtual int Render(
			RendContext &rc, 
			RenderGlobalContext *RGC, 
			float *buf,         // preallocated (shadsize*shadsize)  floats 
			BOOL parallel,		// parallel or perspective projection
			int shadsize,      // size of the buffer (shadsize by shadsize pixels)
			float param,   	   // persp:field-of-view (radians) -- parallel : width in world coords
			float aspect,      // aspect ration of the buffer projection 
			float clipDist,    // don't consider objects farther than this from light
			ObjLightDesc *ltDesc, // descriptor for light that was passed in to CreateShadowGenerator
			Matrix3 worldToLight  // world to light transfor for light
			)=0;
		virtual	float Furthest()=0; // after render, this gives the farthest Z in the buffer
		virtual float Closest()=0;  // after render, this gives the closest Z in the buffer.
		virtual void DeleteThis()=0;
	};

CoreExport ShadBufRenderer *NewDefaultShadBufRenderer();

#endif __SHADBUF__H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\shaders.h ===
//////////////////////////////////////////////////////////////////////////////
//
//		Shader plug-ins
//
//		Created: 8/18/98 Kells Elmquist
//
#ifndef	SHADERS_H
#define SHADERS_H

#include "iparamb2.h"
#include "stdmat.h"

#define STD2_NMAX_TEXMAPS	24
#define		N_ID_CHANNELS	12		// number of ids in stdMat

class Shader;

#define OPACITY_PARAM	0

#define DEFAULT_SOFTEN	0.1f

/////////////////////////////////////////////////////////////////////////////
//
//	Shader param dialog
//
// Returned by a shader when it is asked to put up its rollup page.
class ShaderParamDlg : public ParamDlg {
	public:
		virtual Class_ID ClassID()=0;
		virtual void SetThing(ReferenceTarget *m)=0;
		virtual void SetThings( StdMat2* pMtl, Shader* pShader )=0;
		virtual ReferenceTarget* GetThing()=0;
		virtual Shader* GetShader()=0;
		virtual void SetTime(TimeValue t) {}		
		virtual void DeleteThis()=0;		
		virtual BOOL PanelProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam )=0; 
		virtual void LoadDialog( int draw )=0;
		virtual void UpdateDialog( ParamID paramId )=0;
		virtual HWND GetHWnd()=0;
		virtual int  FindSubTexFromHWND(HWND hw)=0;
		virtual void UpdateOpacity()=0;
		virtual void UpdateMapButtons()=0;
};
 
///////////////////////////////////sh flags //////////////////////////////////////
#define SELFILLUM_CLR_ON	(1<<16) // can be or'd w/ mtl, not sure it's necessary

// post mapping params for shader
class IllumParams {
public:
	ULONG mtlFlags;
	ULONG shFlags;
	Point3 N, V;
	Color channels[ STD2_NMAX_TEXMAPS ];

	float falloffOpac;		// textured opacity w/ stdfalloff (reg opac in channels)
	float kR;				// combined reflection.a * amt 
	ULONG hasComponents;	// bits for active components(e.g.currently has active refl map)
	ULONG stdParams;
	int*  stdIDToChannel;	// combined shader & mtl

	Color ambIllumOut, diffIllumOut, transIllumOut, selfIllumOut; // the diffuse clrs
	Color specIllumOut, reflIllumOut;	// the specular colors
	float diffIllumIntens; // used only by reflection dimming, intensity of diffIllum prior to color multiply
	float finalOpac; // for combining components
	Color finalC;	// final clr: combiner composites into this value.
	Color finalT;	// shader transp clr out

public:
	void ClearOutputs() { 
		finalC = finalT = ambIllumOut=diffIllumOut=transIllumOut=selfIllumOut=
		specIllumOut=reflIllumOut= Color( 0.0f, 0.0f, 0.0f ); 
		finalOpac = diffIllumIntens = 0.0f;
	}

};

/////////// Components defines
#define HAS_BUMPS				0x01L
#define HAS_REFLECT				0x02L
#define HAS_REFRACT				0x04L
#define HAS_OPACITY				0x08L
#define HAS_REFLECT_MAP			0x10L
#define HAS_REFRACT_MAP			0x20L


////////// Texture channel type flags
#define UNSUPPORTED_CHANNEL		0x01L
#define CLR_CHANNEL				0x02L
#define MONO_CHANNEL			0x04L
#define BUMP_CHANNEL			0x08L
#define REFL_CHANNEL			0x10L
#define REFR_CHANNEL			0x20L
#define DISP_CHANNEL			0x40L
#define ELIMINATE_CHANNEL		0x8000L

#define SKIP_CHANNELS	(UNSUPPORTED_CHANNEL+BUMP_CHANNEL+REFL_CHANNEL+REFR_CHANNEL)

/////////// Class Id upper half for loading the Pre 3.0 shaders
#define  DEFAULT_SHADER_CLASS_ID BLINNClassID 

#define  PHONGClassID (STDSHADERS_CLASS_ID+2)
#define  BLINNClassID (STDSHADERS_CLASS_ID+3)
#define  METALClassID (STDSHADERS_CLASS_ID+4)

class ParamBlockDescID;
class IParamBlock;

class BaseShader : public SpecialFX {
	public:
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	         PartID& partID,  RefMessage message) {return REF_SUCCEED;}

		SClass_ID SuperClassID() {return SHADER_CLASS_ID;}
		BOOL BypassPropertyLevel() { return TRUE; }  // want to promote shader props to material level

		virtual ULONG GetRequirements(int subMtlNum)=0;

		// Put up a dialog that lets the user edit the plug-ins parameters.
		virtual ShaderParamDlg* CreateParamDialog(	HWND hOldRollup, HWND hwMtlEdit, 
													IMtlParams *imp, 
													StdMat2* theMtl, 
													int rollupOpen )=0;

		virtual ShaderParamDlg* GetParamDlg()=0;
		virtual void SetParamDlg( ShaderParamDlg* newDlg )=0;

		// Saves and loads name. These should be called at the start of
		// a plug-in's save and load methods.
		IOResult Save(ISave *isave) { return SpecialFX::Save(isave); }
		IOResult Load(ILoad *iload) { return SpecialFX::Load(iload); }

		// std parameter support
		virtual ULONG SupportStdParams()=0;

		// this method only req'd for R2.5 shaders, to convert stdmtl1 paramblks to current
		virtual void ConvertParamBlk( ParamBlockDescID *descOld, int oldCount, IParamBlock *oldPB ){};

		// LOCAL vars of mtl for possible mapping prior to being given to back to illum
		virtual void GetIllumParams( ShadeContext &sc, IllumParams& ip )=0;

		// actual shader
		virtual void Illum(ShadeContext &sc, IllumParams &ip)=0;
		virtual void AffectReflection(ShadeContext &sc, IllumParams &ip, Color &rcol)=0;
		virtual void CombineComponents( ShadeContext &sc, IllumParams& ip )=0;

		// texture maps
		virtual long nTexChannelsSupported()=0;
		virtual TSTR GetTexChannelName( long nTextureChan )=0;
		virtual TSTR GetTexChannelInternalName( long nTextureChan ) { return GetTexChannelName(nTextureChan); }
		virtual long ChannelType( long nTextureChan )=0;
		// map StdMat Channel ID's to the channel number
		virtual long StdIDToChannel( long stdID )=0;

		virtual void Reset()=0;	//reset to default values

	};

// Chunk IDs saved by base class
#define SHADERBASE_CHUNK	0x39bf
#define SHADERNAME_CHUNK	0x0100


/////////////////////////////////////////////////////////////////////////////
//
//	Standard params for shaders
//
// combination of these is returned by Shader.SupportStdParams()
#define STD_PARAM_NONE			(0)
#define STD_PARAM_ALL			(0xffffffffL)
#define STD_PARAM_METAL			(1)
#define STD_PARAM_LOCKDS		(1<<1)
#define STD_PARAM_LOCKAD		(1<<2)
#define STD_PARAM_LOCKADTEX		(1<<3)
#define STD_PARAM_SELFILLUM		(1<<4)
#define STD_PARAM_SELFILLUM_CLR	(1<<5)
#define STD_PARAM_AMBIENT_CLR	(1<<6)
#define STD_PARAM_DIFFUSE_CLR	(1<<7)
#define STD_PARAM_SPECULAR_CLR	(1<<8)
#define STD_PARAM_FILTER_CLR	(1<<9)
#define STD_PARAM_GLOSSINESS	(1<<10)
#define STD_PARAM_SOFTEN_LEV	(1<<11)
#define STD_PARAM_SPECULAR_LEV	(1<<12)
#define STD_PARAM_DIFFUSE_LEV	(1<<13)
#define STD_PARAM_DIFFUSE_RHO	(1<<14)
#define STD_PARAM_ANISO			(1<<15)
#define STD_PARAM_ORIENTATION	(1<<16)
#define STD_PARAM_REFL_LEV		(1<<17)
#define STD_PARAM_SELFILLUM_CLR_ON		(1<<18)

#define STD_BASIC2_DLG			(1<<20)
#define STD_EXTRA_DLG			(1<<21)

// not including these 3 in yr param string disables the relevant params 
// in extra params dialog
#define STD_EXTRA_REFLECTION	(1<<22)
#define STD_EXTRA_REFRACTION	(1<<23)
#define STD_EXTRA_OPACITY		(1<<24)

#define STD_EXTRA	(STD_EXTRA_DLG \
					+STD_EXTRA_REFLECTION+STD_EXTRA_REFRACTION \
					+STD_EXTRA_OPACITY )

#define STD_BASIC	(0x00020ffeL | STD_BASIC2_DLG)
#define STD_BASIC_METAL	(0x00020fffL | STD_BASIC2_DLG)

#define STD_ANISO	(0x0002cffe)
#define STD_MULTILAYER	(0x0002fffe)
#define STD_ONB		(0x00023ffe)
#define STD_WARD	(0x00000bce)


///////////////////////////////////////////////////////////////////////////////

class Shader : public BaseShader {
	public:
	virtual void CopyStdParams( Shader* pFrom )=0;
	// these are the standard shader params
	virtual void SetLockDS(BOOL lock)=0;
	virtual BOOL GetLockDS()=0;
	virtual void SetLockAD(BOOL lock)=0;
	virtual BOOL GetLockAD()=0;
	virtual void SetLockADTex(BOOL lock)=0;
	virtual BOOL GetLockADTex()=0;

	virtual void SetSelfIllum(float v, TimeValue t)=0;		
	virtual void SetSelfIllumClrOn( BOOL on )=0;
	virtual void SetSelfIllumClr(Color c, TimeValue t)=0;		

	virtual void SetAmbientClr(Color c, TimeValue t)=0;		
	virtual void SetDiffuseClr(Color c, TimeValue t)=0;		
	virtual void SetSpecularClr(Color c, TimeValue t)=0;
	virtual void SetGlossiness(float v, TimeValue t)=0;		
	virtual void SetSpecularLevel(float v, TimeValue t)=0;		
	virtual void SetSoftenLevel(float v, TimeValue t)=0;
		
	virtual BOOL IsSelfIllumClrOn(int mtlNum, BOOL backFace)=0;
	virtual Color GetAmbientClr(int mtlNum, BOOL backFace)=0;		
    virtual Color GetDiffuseClr(int mtlNum, BOOL backFace)=0;		
	virtual Color GetSpecularClr(int mtlNum, BOOL backFace)=0;
	virtual Color GetSelfIllumClr(int mtlNum, BOOL backFace)=0;
	virtual float GetSelfIllum(int mtlNum, BOOL backFace)=0;
	virtual float GetGlossiness(int mtlNum, BOOL backFace)=0;	
	virtual float GetSpecularLevel(int mtlNum, BOOL backFace)=0;
	virtual float GetSoftenLevel(int mtlNum, BOOL backFace)=0;

	virtual BOOL IsSelfIllumClrOn()=0;
	virtual Color GetAmbientClr(TimeValue t)=0;		
	virtual Color GetDiffuseClr(TimeValue t)=0;		
	virtual Color GetSpecularClr(TimeValue t)=0;
	virtual float GetGlossiness( TimeValue t)=0;		
	virtual float GetSpecularLevel(TimeValue t)=0;
	virtual float GetSoftenLevel(TimeValue t)=0;
	virtual float GetSelfIllum(TimeValue t)=0;		
	virtual Color GetSelfIllumClr(TimeValue t)=0;		

	virtual float EvalHiliteCurve(float x){ return 0.0f; }
	virtual float EvalHiliteCurve2(float x, float y, int level = 0 ){ return 0.0f; }

};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\sceneapi.h ===
/**********************************************************************
 *<
	FILE: sceneapi.h

	DESCRIPTION: Scene interface

	CREATED BY:	Rolf Berteig

	HISTORY: Created 13 January 1995

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/


#ifndef __SCENEAPI__
#define __SCENEAPI__


class BaseObject;

class IScene {		
	public:
		virtual int EnumTree( ITreeEnumProc *proc )=0;
		virtual void FlagFGSelected( TimeValue t )=0;
		virtual void FlagFGAnimated( TimeValue t )=0;
		virtual void FlagFGDependent( TimeValue t, BaseObject *obj )=0;
	};


// The purpose of this callback is to call FlagForeground() for
// any nodes in the scene that are supposed to be in the foreground.
class ChangeForegroundCallback {
	public:
		virtual BOOL IsValid()=0;
		virtual void Invalidate()=0;
		virtual void Validate()=0;
		virtual void callback(TimeValue t,IScene *scene)=0;
	};

#endif // __SCENEAPI__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\shadgen.h ===
/**********************************************************************
 *<
FILE: shadgen.h : pluggable shadow generators.

	DESCRIPTION:

	CREATED BY: Dan Silva

	HISTORY: Created 10/27/98

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __SHADGEN__H

#define __SHADGEN__H

#define SHAD_PARALLEL       2
#define SHAD_OMNI           4

class ShadowGenerator;
class ParamBlockDescID;
class IParamBlock;

class ShadowParamDlg {
public:
	virtual void DeleteThis()=0;
	};

// This class carries the parameters for the shadow type, and puts up the parameter rollup.
class ShadowType: public ReferenceTarget {
	public:
		SClass_ID SuperClassID() { return SHADOW_TYPE_CLASS_ID;}
		virtual ShadowParamDlg *CreateShadowParamDlg(Interface *ip) { return NULL; }
		virtual ShadowGenerator* CreateShadowGenerator(LightObject *l,  ObjLightDesc *ld, ULONG flags)=0;
		virtual BOOL SupportStdMapInterface() { return FALSE; }

		BOOL BypassPropertyLevel() { return TRUE; }  // want to promote shadowtype props to light level

		// If the shadow generator can handle omni's directly, this should return true. If it does,
		// then when doing an Omni light, the SHAD_OMNI flag will be passed in to 
		// the CreateShadowGenerator call, and only one ShadowGenerator will be created
		// instead of the normal 6 (up,down,right,left,front,back).
		virtual BOOL CanDoOmni() { return FALSE; }

		// This method used for converting old files: only needs to be supported by default 
		// shadow map and ray trace shadows.
		virtual void ConvertParamBlk( ParamBlockDescID *descOld, int oldCount, IParamBlock *oldPB ) { }

		// This method valid iff SupportStdMapInterface returns TRUE
		virtual int MapSize(TimeValue t) { return 512; } 

		// This interface is solely for the default shadow map type ( Class_ID(STD_SHADOW_MAP_CLASS_ID,0) )
		virtual void SetMapRange(TimeValue t, float f) {}
		virtual float GetMapRange(TimeValue t, Interval& valid = Interval(0,0)) { return 0.0f; }
		virtual void SetMapSize(TimeValue t, int f) {}
		virtual int GetMapSize(TimeValue t, Interval& valid = Interval(0,0)) { return 0; }
		virtual void SetMapBias(TimeValue t, float f) {} 
		virtual float GetMapBias(TimeValue t, Interval& valid = Interval(0,0)) { return 0.0f; }
		virtual void SetAbsMapBias(TimeValue t, int a) {}
		virtual int GetAbsMapBias(TimeValue t, Interval& valid = Interval(0,0)) { return 0; }

		// This interface is solely for the default raytrace shadow type ( Class_ID(STD_RAYTRACE_SHADOW_CLASS_ID,0) )
		virtual float GetRayBias(TimeValue t, Interval &valid = Interval(0,0)) { return 0.0f; }
		virtual	void SetRayBias(TimeValue t, float f) {}
		virtual int GetMaxDepth(TimeValue t, Interval &valid = Interval(0,0)) { return 1; } 
		virtual void SetMaxDepth(TimeValue t, int f) {}

	};

// This class generates the shadows. It only exists during render, one per instance of the light.
class ShadowGenerator {
public:
	virtual int Update(
		TimeValue t,
		const RendContext& rendCntxt,   // Mostly for progress bar.
		RenderGlobalContext *rgc,       // Need to get at instance list.
		Matrix3& lightToWorld, // light to world space: not necessarly same as that of light
		float aspect,      // aspect
		float param,   	   // persp:field-of-view (radians) -- parallel : width in world coords
		float clipDist = DONT_CLIP  
		)=0;

	virtual int UpdateViewDepParams(const Matrix3& worldToCam)=0;

	virtual void FreeBuffer()=0;
	virtual void DeleteThis()=0; // call this to destroy the ShadowGenerator

	// Generic shadow sampling function
	// Implement this when ShadowType::SupportStdMapInterface() returns FALSE. 
	virtual float Sample(ShadeContext &sc, Point3 &norm, Color& color) { return 1.0f; }

	// Implement these methods when ShadowType::SupportStdMapInterface() returns TRUE. 
	// This interface allows illuminated atmospherics
	// Note: Sample should return a small NEGATIVE number ehen the sample falls outside of the shadow buffer, so
	//    the caller can know to take appropriate action.
	virtual	float Sample(ShadeContext &sc, float x, float y, float z, float xslope, float yslope) { return 1.0f; }
	virtual BOOL QuickSample(int x, int y, float z) { return 1; }
	virtual float FiltSample(int x, int y, float z, int level) { return 1.0f; }
	virtual float LineSample(int x1, int y1, float z1, int x2, int y2, float z2) { return 1.0f; }

	};


// This returns a new default shadow-map shadow generator
CoreExport ShadowType *NewDefaultShadowMapType();

// This returns a new default ray-trace shadow generator
CoreExport ShadowType *NewDefaultRayShadowType();


#endif __SHADGEN__H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\shphier.h ===
/**********************************************************************
 *<
	FILE: shphier.h

	DESCRIPTION:  Defines Shape Hierarchy Class

	CREATED BY: Tom Hudson

	HISTORY: created 30 December 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#ifndef __SHPHIER_H__ 

#define __SHPHIER_H__

// This class stores the hierarchy tree of a shape object, along with
// a bitarray with an entry for each polygon in the shape which indicates
// whether that polygon should be reversed in order to provide the proper
// clockwise/counterclockwise ordering for the nested shapes.

class ShapeHierarchy {
	public:
		GenericHierarchy hier;
		BitArray reverse;
		ShapeHierarchy() {}
		ShapeHierarchy(int polys) { New(polys); }
		void New(int polys = 0) { hier.New(); reverse.SetSize(polys); reverse.ClearAll(); }
		ShapeHierarchy &operator=(ShapeHierarchy &from) { hier=from.hier; reverse=from.reverse; return *this; }
	};

#endif // __SHPHIER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\shpsels.h ===
/**********************************************************************
 *<
	FILE: shpsels.h

	DESCRIPTION:  Defines Shape Selection utility objects

	CREATED BY: Tom Hudson

	HISTORY: created 31 October 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#ifndef __SHPSELS__ 

#define __SHPSELS__

class BezierShape;
class PolyShape;

class ShapeVSel {
	public:
	int polys;
	BitArray *sel;
	CoreExport ShapeVSel();
	CoreExport ShapeVSel(ShapeVSel& from);
	CoreExport ~ShapeVSel();
	CoreExport ShapeVSel& operator=(ShapeVSel& from);
	CoreExport BOOL operator==(ShapeVSel& s);
	CoreExport void Insert(int where,int count=0);
	CoreExport void Delete(int where);
	CoreExport void SetSize(ShapeVSel& selset, BOOL save=FALSE);
	CoreExport void SetSize(BezierShape& shape, BOOL save=FALSE);
	CoreExport void SetSize(PolyShape& shape, BOOL save=FALSE);
	CoreExport BitArray& operator[](int index);
	CoreExport void ClearAll();
	CoreExport void SetAll();
	CoreExport void Toggle();
	CoreExport void Empty();
	CoreExport BOOL IsCompatible(ShapeVSel& selset);
	CoreExport BOOL IsCompatible(BezierShape& shape);
	CoreExport BOOL IsCompatible(PolyShape& shape);
	CoreExport IOResult Save(ISave* isave);
	CoreExport IOResult Load(ILoad* iload);
	};

class ShapeSSel {
	public:
	int polys;
	BitArray *sel;
	CoreExport ShapeSSel();
	CoreExport ShapeSSel(ShapeSSel& from);
	CoreExport ~ShapeSSel();
	CoreExport ShapeSSel& operator=(ShapeSSel& from);
	CoreExport BOOL operator==(ShapeSSel& s);
	CoreExport void Insert(int where,int count=0);
	CoreExport void Delete(int where);
	CoreExport void SetSize(ShapeSSel& selset, BOOL save=FALSE);
	CoreExport void SetSize(BezierShape& shape, BOOL save=FALSE);
	CoreExport void SetSize(PolyShape& shape, BOOL save=FALSE);
	CoreExport BitArray& operator[](int index);
	CoreExport void ClearAll();
	CoreExport void SetAll();
	CoreExport void Toggle();
	CoreExport void Empty();
	CoreExport BOOL IsCompatible(ShapeSSel& selset);
	CoreExport BOOL IsCompatible(BezierShape& shape);
	CoreExport BOOL IsCompatible(PolyShape& shape);
	CoreExport IOResult Save(ISave* isave);
	CoreExport IOResult Load(ILoad* iload);
	};

class ShapePSel {
	public:
	int polys;
	BitArray sel;
	CoreExport ShapePSel();
	CoreExport ShapePSel(ShapePSel& from);
	CoreExport ~ShapePSel();
	CoreExport ShapePSel& operator=(ShapePSel& from);
	CoreExport BOOL operator==(ShapePSel& s);
	CoreExport void Insert(int where);
	CoreExport void Delete(int where);
	CoreExport void SetSize(ShapePSel& selset, BOOL save=FALSE);
	CoreExport void SetSize(BezierShape& shape, BOOL save=FALSE);
	CoreExport void SetSize(PolyShape& shape, BOOL save=FALSE);
	CoreExport void Set(int index);
	CoreExport void Set(int index, int value);
	CoreExport void Clear(int index);
	CoreExport int operator[](int index) const;
	CoreExport void ClearAll();
	CoreExport void SetAll();
	CoreExport void Toggle();
	CoreExport void Empty();
	CoreExport BOOL IsCompatible(ShapePSel& selset);
	CoreExport BOOL IsCompatible(BezierShape& shape);
	CoreExport BOOL IsCompatible(PolyShape& shape);
	CoreExport IOResult Save(ISave* isave);
	CoreExport IOResult Load(ILoad* iload);
	};


#endif __SHPSELS__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\shape.h ===
/**********************************************************************
 *<
	FILE: shape.h

	DESCRIPTION:  Defines Basic BezierShape Object

	CREATED BY: Tom Hudson

	HISTORY: created 23 February 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#ifndef __SHAPE__ 

#define __SHAPE__

#include "shphier.h"
#include "spline3d.h"
#include "shpsels.h"	// Shape selection classes

class BezierShape;

// Parameters for BezierShape::PerformTrimOrExtend
#define SHAPE_TRIM 0
#define SHAPE_EXTEND 1

//watje class contains the data for the bind points
class bindShape
{
public:
	int pointSplineIndex;      // spline that is to be bound
	int segSplineIndex;        // spline that contains the segment to bind to
	int seg;					// seg that the point is bound to
	Point3 bindPoint,segPoint;  // posiiton in space of the start seg point and the bind point
	BOOL isEnd;                 // is the bound point the end or beginning of the spline
};


class ShapeSubHitRec {
	private:		
		ShapeSubHitRec *next;
	public:
		DWORD	dist;
		BezierShape*	shape;
		int		poly;
		int		index;
		ShapeSubHitRec( DWORD dist, BezierShape *shape, int poly, int index, ShapeSubHitRec *next ) 
			{ this->dist = dist; this->shape = shape; this->poly = poly; this->index = index; this->next = next; }

		ShapeSubHitRec *Next() { return next; }		
	};

class SubShapeHitList {
	private:
		ShapeSubHitRec *first;
	public:
		SubShapeHitList() { first = NULL; }
		~SubShapeHitList() {
			ShapeSubHitRec *ptr = first, *fptr;
			while ( ptr ) {
				fptr = ptr;
				ptr = ptr->Next();
				delete fptr;
				}
			first = NULL;
			}	

		ShapeSubHitRec *First() { return first; }
		void AddHit( DWORD dist, BezierShape *shape, int poly, int index ) {
			first = new ShapeSubHitRec(dist,shape,poly,index,first);
			}
		int Count() {
			int count = 0;
			ShapeSubHitRec *ptr = first;
			while(ptr) {
				count++;
				ptr = ptr->Next();
				}
			return count;
			}
	};

// Special storage class for hit records so we can know which object was hit
class ShapeHitData : public HitData {
	public:
		BezierShape *shape;
		int poly;
		int index;
		ShapeHitData(BezierShape *shape, int poly, int index)
			{ this->shape = shape; this->poly = poly; this->index = index; }
		~ShapeHitData() {}
	};

// Display flags
#define DISP_VERTTICKS		(1<<0)
#define DISP_BEZHANDLES		(1<<1)
#define DISP_SELVERTS		(1<<10)
#define DISP_SELSEGMENTS	(1<<11)
#define DISP_SELPOLYS		(1<<13)
#define DISP_UNSELECTED		(1<<14)		// Used by loft -- Shape unselected
#define DISP_SELECTED		(1<<15)		// Used by loft -- Shape selected
#define DISP_ATSHAPELEVEL	(1<<16)		// Used by loft -- Shape at current level
#define DISP_VERT_NUMBERS	(1<<17)
#define DISP_VERT_NUMBERS_SELONLY	(1<<18)
#define DISP_SPLINES_ORTHOG (1<<25)     // Not display, but splines to be created orthog
// Selection level bits.
#define SHAPE_OBJECT		(1<<0)
#define SHAPE_SPLINE		(1<<1)
#define SHAPE_SEGMENT		(1<<2)
#define SHAPE_VERTEX		(1<<3)

// Flags for sub object hit test

// NOTE: these are the same bits used for object level.
#define SUBHIT_SHAPE_SELONLY	(1<<0)
#define SUBHIT_SHAPE_UNSELONLY	(1<<2)
#define SUBHIT_SHAPE_ABORTONHIT	(1<<3)
#define SUBHIT_SHAPE_SELSOLID	(1<<4)

#define SUBHIT_SHAPE_VERTS		(1<<24)
#define SUBHIT_SHAPE_SEGMENTS	(1<<25)
#define SUBHIT_SHAPE_POLYS		(1<<26)
#define SUBHIT_SHAPE_TYPEMASK	(SUBHIT_SHAPE_VERTS|SUBHIT_SHAPE_SEGMENTS|SUBHIT_SHAPE_POLYS)

// Callback used for retrieving other shapes in the current editing context
class ShapeContextCallback {
	public:
		virtual BezierShape *GetShapeContext(ModContext *context) = 0;
	};

class ShapeObject;

class BezierShapeTopology {
	public:
		BOOL ready;
		IntTab kcount;
		BitArray closed;
		BezierShapeTopology() { ready = FALSE; }
		CoreExport void Build(BezierShape &shape);
		CoreExport int operator==(const BezierShapeTopology& t);
		CoreExport IOResult Save(ISave *isave);
		CoreExport IOResult Load(ILoad *iload);
	};

class BezierShape {
 		Box3			bdgBox;			// object space--depends on geom+topo
		static int shapeCount;			// Number of shape objects in the system!
		PolyShape pShape;				// PolyShape cache
		int pShapeSteps;				// Number of steps in the cache
		BOOL pShapeOptimize;			// TRUE if cache is optimized
		BOOL pShapeCacheValid;			// TRUE if the cache is current
		int *vertBase;					// Cache giving vert start index for each spline
		int totalShapeVerts;			// Total number of verts in the shape (cached)
		int *knotBase;					// Cache giving knot start index for each spline
		int totalShapeKnots;			// Total number of knots in the shape (cached)
		BOOL topoCacheValid;			// TRUE if topology cache is valid
		BezierShapeTopology topology;	// Topology cache
	public:
		// Patch capping cache (mesh capping and hierarchy caches stored in PolyShape cache)
		PatchCapInfo patchCap;
		BOOL patchCapCacheValid;

		// The list of splines
		Spline3D **splines;
		int splineCount;

		int steps;						// Number of steps (-1 = adaptive)
		BOOL optimize;					// TRUE optimizes linear segments

		// Selection
		ShapeVSel	vertSel;  		// selected vertices
		ShapeSSel	segSel;  		// selected segments
		ShapePSel	polySel;  		// selected polygons

		// If hit bezier vector, this is its info:
		int bezVecPoly;
		int bezVecVert;

		// Selection level
		DWORD		selLevel;

		// Display attribute flags
		DWORD		dispFlags;

		CoreExport BezierShape();
		CoreExport BezierShape(BezierShape& fromShape);

		CoreExport void		Init();

		CoreExport ~BezierShape();

		CoreExport BezierShape& 		operator=(BezierShape& fromShape);
		CoreExport BezierShape& 		operator=(PolyShape& fromShape);
		
		CoreExport Point3	GetVert(int poly, int i);
		CoreExport void		SetVert(int poly, int i, const Point3 &xyz);
		
		CoreExport void		Render(GraphicsWindow *gw, Material *ma, RECT *rp, int compFlags, int numMat);
		CoreExport BOOL		Select(GraphicsWindow *gw, Material *ma, HitRegion *hr, int abortOnHit = FALSE);
		CoreExport void		Snap(GraphicsWindow *gw, SnapInfo *snap, IPoint2 *p, Matrix3 &tm);
		// See polyshp.h for snap flags
		CoreExport void		Snap(GraphicsWindow *gw, SnapInfo *snap, IPoint2 *p, Matrix3 &tm, DWORD flags);
		CoreExport BOOL 	SubObjectHitTest(GraphicsWindow *gw, Material *ma, HitRegion *hr,
								DWORD flags, SubShapeHitList& hitList );

		CoreExport void		BuildBoundingBox(void);
		CoreExport Box3		GetBoundingBox(Matrix3 *tm=NULL); // RB: optional TM allows the box to be calculated in any space.
				                                              // NOTE: this will be slower becuase all the points must be transformed.
		
		CoreExport void		InvalidateGeomCache();
		CoreExport void		InvalidateCapCache();
		CoreExport void		FreeAll(); //DS
				
		// functions for use in data flow evaluation
		CoreExport void 	ShallowCopy(BezierShape *ashape, unsigned long channels);
		CoreExport void 	DeepCopy(BezierShape *ashape, unsigned long channels);
		CoreExport void		NewAndCopyChannels(unsigned long channels);
		CoreExport void 	FreeChannels( unsigned long channels, int zeroOthers=1);

		// Display flags
		CoreExport void		SetDispFlag(DWORD f);
		CoreExport DWORD	GetDispFlag(DWORD f);
		CoreExport void		ClearDispFlag(DWORD f);

		// Constructs a vertex selection list based on the current selection level.
		CoreExport BitArray VertexTempSel(int poly);
		// Constructs a vertex selection list for all polys based on the current selection level
		// This is a bitarray with a bit for each vertex in each poly in the shape.  If
		// includeVecs is set, it will set the bits for vectors associated with selected knots.
		// Specify a poly number or -1 for all.  Can specify selection level optionally
		CoreExport BitArray	VertexTempSelAll(int poly = -1, BOOL includeVecs = FALSE, int level = 0, BOOL forceSel = FALSE);

		CoreExport IOResult Save(ISave* isave);
		CoreExport IOResult Load(ILoad* iload);

		// BezierShape-specific methods

		inline int SplineCount() { return splineCount; }
		CoreExport Spline3D* GetSpline(int index);
		CoreExport Spline3D* NewSpline(int itype = KTYPE_CORNER,int dtype = KTYPE_BEZIER,int ptype = PARM_UNIFORM);
		CoreExport Spline3D* AddSpline(Spline3D* spline);
		CoreExport int DeleteSpline(int index);
		CoreExport int InsertSpline(Spline3D* spline, int index);
		CoreExport void NewShape();
		CoreExport int GetNumVerts();
		CoreExport int GetNumSegs();
		CoreExport void GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm, BOOL useSel );
		CoreExport void UpdateSels();
		CoreExport void GetClosures(BitArray& array);
		CoreExport void SetClosures(BitArray& array);
		CoreExport float FindSegmentPoint(int poly, int segment, GraphicsWindow *gw, Material *ma, HitRegion *hr);
		CoreExport void Reverse(int poly, BOOL keepZero = FALSE);
		CoreExport void Reverse(BitArray &reverse, BOOL keepZero = FALSE);
		CoreExport ShapeHierarchy &OrganizeCurves(TimeValue t, ShapeHierarchy *hier = NULL);
		CoreExport void MakePolyShape(PolyShape &pshp, int steps = -1, BOOL optimize = FALSE);
		CoreExport void MakeFirst(int poly, int vertex);
		CoreExport void Transform(Matrix3 &tm);
		CoreExport BezierShape& operator+=(BezierShape& from);
		CoreExport void AddAndWeld(BezierShape &from, float weldThreshold);
		CoreExport void ReadyCachedPolyShape();
		CoreExport int MakeCap(TimeValue t, MeshCapInfo &capInfo, int capType);
		CoreExport int MakeCap(TimeValue t, PatchCapInfo &capInfo);
		CoreExport int ReadyPatchCap();
		
		// The following copies the shapes, selection sets and any caches from the source object.
		// It does NOT copy selection level info or display info.
		CoreExport void CopyShapeDataFrom(BezierShape &fromShape);

		// The following methods provide an easy way to derive a simple index for any
		// vert in any spline in the shape, and turn that index back into a poly/vert pair
		CoreExport void PrepVertBaseIndex();	// Used internally automatically
		CoreExport int GetVertIndex(int poly, int vert);
		CoreExport void GetPolyAndVert(int index, int &polyOut, int &vertOut);
		CoreExport int GetTotalVerts();	// Total number of verts in the shape

		// The following methods provide an easy way to derive a simple index for any
		// knot in any spline in the shape, and turn that index back into a poly/knot pair
		CoreExport void PrepKnotBaseIndex();	// Used internally automatically
		CoreExport int GetKnotIndex(int poly, int knot);
		CoreExport void GetPolyAndKnot(int index, int &polyOut, int &knotOut);
		CoreExport int GetTotalKnots();	// Total number of knots in the shape

		// The following functions delete the selected items, returning TRUE if any were
		// deleted, or FALSE if none were deleted.
		CoreExport BOOL DeleteSelVerts(int poly);	// For single poly
		CoreExport BOOL DeleteSelSegs(int poly);	// For single poly
		CoreExport BOOL DeleteSelectedVerts();	// For all polys
		CoreExport BOOL DeleteSelectedSegs();
		CoreExport BOOL DeleteSelectedPolys();

		// Copy the selected geometry (segments or polys), reversing if needed.
		// Returns TRUE if anything was copied
		CoreExport BOOL CloneSelectedParts(BOOL reverse=FALSE);

		// Tag the points in the spline components to record our topology (This stores
		// identifying values in the Spline3D's Knot::aux fields for each control point)
		// This info can be used after topology-changing operations to remap information
		// tied to control points.
		// Returns FALSE if > 32767 knots or polys (can't record that many)
		// 
		// MAXr3: Optional channel added.  0=aux2, 1=aux3
		CoreExport BOOL RecordTopologyTags(int channel=0);

		// Support for interpolating along the shape's splines
		CoreExport Point3 InterpCurve3D(int poly, float param, int ptype=PARAM_SIMPLE);
		CoreExport Point3 TangentCurve3D(int poly, float param, int ptype=PARAM_SIMPLE);
		CoreExport Point3 InterpPiece3D(int poly, int piece, float param, int ptype=PARAM_SIMPLE);
		CoreExport Point3 TangentPiece3D(int poly, int piece, float param, int ptype=PARAM_SIMPLE);
		CoreExport MtlID GetMatID(int poly, int piece);
		CoreExport float LengthOfCurve(int poly);

		// Get information on shape topology
		CoreExport void GetTopology(BezierShapeTopology &topo);

		// Perform a trim or extend
		CoreExport BOOL PerformTrimOrExtend(IObjParam *ip, ViewExp *vpt, ShapeHitData *hit, IPoint2 &m, ShapeContextCallback &cb, int trimType, int trimInfinite);

		CoreExport BOOL SelVertsSameType();	// Are all selected vertices the same type?
		CoreExport BOOL SelSegsSameType();	// Are all selected segments the same type?
		CoreExport BOOL SelSplinesSameType();	// Are all segments in selected splines the same type?

//watje 1-10-98 additonal changes

		Tab<bindShape> bindList;		//list of bind points
		CoreExport BindKnot(BOOL isEnd, int segIndex, int splineSegID, int splinePointID); // binds a knot to a seg ment
		CoreExport UnbindKnot(int splineID, BOOL isEnd);  //unbind a knot 
		CoreExport UpdateBindList();	//when topology changes this needs to be called to update the bind list
		CoreExport HideSelectedSegs();  // hide selected segs
		CoreExport HideSelectedVerts(); // hide segs attached to selected verts
		CoreExport HideSelectedSplines(); // hide segs attached to selected splines
		CoreExport UnhideSegs();          //unhide all segs

		CoreExport UnselectHiddenVerts();
		CoreExport UnselectHiddenSegs();
		CoreExport UnselectHiddenSplines();

	};

#endif // __SHAPE__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\simpmod.h ===
/**********************************************************************
 *<
	FILE: simpmod.h

	DESCRIPTION:  Simple modifier base class

	CREATED BY: Dan Silva & Rolf Berteig

	HISTORY: created 30 Jauary, 1995

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __SIMPMOD__
#define __SIMPMOD__


//--- SimpleMod -----------------------------------------------------------

class SimpleMod: public Modifier {
	public:	
		Control *tmControl;
		Control *posControl;
		IParamBlock *pblock;
				
		CoreExport static IObjParam *ip;
		static MoveModBoxCMode *moveMode;
		static RotateModBoxCMode *rotMode;
		static UScaleModBoxCMode *uscaleMode;
		static NUScaleModBoxCMode *nuscaleMode;
		static SquashModBoxCMode *squashMode;		
		static SimpleMod *editMod;
			
		CoreExport SimpleMod();
		CoreExport virtual ~SimpleMod();

		ChannelMask ChannelsUsed()  { return PART_GEOM|PART_TOPO|SELECT_CHANNEL|SUBSEL_TYPE_CHANNEL; }
		ChannelMask ChannelsChanged() { return PART_GEOM; }
		CoreExport void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);
		Class_ID InputType() {return defObjectClassID;}
		CoreExport Interval LocalValidity(TimeValue t);
		CoreExport Matrix3 CompMatrix(TimeValue t, ModContext& mc, Matrix3& ntm, 
			Interval& valid, BOOL needOffset);
		CoreExport void CompOffset( TimeValue t, Matrix3& offset, Matrix3& invoffset);

		// From BaseObject
		CoreExport int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc);
		CoreExport int Display(TimeValue t, INode* inode, ViewExp *vpt, int flagst, ModContext *mc);
		CoreExport void GetWorldBoundBox(TimeValue t,INode* inode, ViewExp *vpt, Box3& box, ModContext *mc);
		
		CoreExport void GetSubObjectCenters(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);
		CoreExport void GetSubObjectTMs(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);
		BOOL ChangeTopology() {return FALSE;}

		CoreExport IParamArray *GetParamBlock();
		CoreExport int GetParamBlockIndex(int id);

		// Affine transform methods
		CoreExport void Move( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin=FALSE );
		CoreExport void Rotate( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Quat& val, BOOL localOrigin=FALSE );
		CoreExport void Scale( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin=FALSE );
		
		int NumRefs() {return 3;}
		CoreExport RefTargetHandle GetReference(int i);
		CoreExport void SetReference(int i, RefTargetHandle rtarg);

		int NumSubs() {return 3;}
		CoreExport Animatable* SubAnim(int i);
		CoreExport TSTR SubAnimName(int i);
		CoreExport int SubNumToRefNum(int subNum);
		CoreExport BOOL AssignController(Animatable *control,int subAnim);

		CoreExport RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message);

		CreateMouseCallBack* GetCreateMouseCallBack() {return NULL;} 
		CoreExport void ActivateSubobjSel(int level, XFormModes& modes);

		// When clients are cloning themselves, they should call this 
		// method on the clone to copy SimpleMod's data.
		CoreExport void SimpleModClone(SimpleMod *smodSource);

		// Clients of simpmod probably want to override these. If they do
		// the should call these from within thier methods.
		CoreExport void BeginEditParams(IObjParam *ip, ULONG flags,Animatable *prev);
		CoreExport void EndEditParams(IObjParam *ip, ULONG flags,Animatable *next);

		// Clients of simpmod need to implement this method
		virtual Deformer& GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat)=0;
		virtual void InvalidateUI() {}
		virtual Interval GetValidity(TimeValue t) {return FOREVER;}
		virtual	ParamDimension *GetParameterDim(int pbIndex) {return defaultDim;}
		virtual TSTR GetParameterName(int pbIndex) {return TSTR(_T("Parameter"));}
		virtual BOOL GetModLimits(TimeValue t,float &zmin, float &zmax, int &axis) {return FALSE;}
	};


// This is the ref ID of the parameter block
#define SIMPMOD_PBLOCKREF	2

// ParamBlock2 specialization added JBW 2/9/99 (replaces a IParamBlock with IParamBlock2 block pointer)
class IParamBlock2;
class SimpleMod2 : public SimpleMod {
	public:
		IParamBlock2* pblock2;

		SimpleMod2() { pblock2 = NULL; }
		// From ref
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);		
		Animatable* SubAnim(int i);
	};

//--- SimpleWSMMod -----------------------------------------------------------

class SimpleWSMMod: public Modifier {	
	public:
		WSMObject  	*obRef;
		INode       *nodeRef;
		IParamBlock *pblock;
				
		CoreExport static IObjParam *ip;
		static SimpleWSMMod *editMod;
	
		CoreExport SimpleWSMMod();
		CoreExport virtual ~SimpleWSMMod();

		ChannelMask ChannelsUsed()  { return PART_GEOM|PART_TOPO; }
		ChannelMask ChannelsChanged() { return PART_GEOM; }
		CoreExport void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);
		Class_ID InputType() {return defObjectClassID;}
		CoreExport Interval LocalValidity(TimeValue t);		
		BOOL ChangeTopology() {return FALSE;}
		CreateMouseCallBack* GetCreateMouseCallBack() {return NULL;}

		int NumRefs() {return 3;}
		CoreExport RefTargetHandle GetReference(int i);
		CoreExport void SetReference(int i, RefTargetHandle rtarg);

		int NumSubs() {return 1;}
		CoreExport Animatable* SubAnim(int i);
		CoreExport TSTR SubAnimName(int i);

		CoreExport RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message);
		
		CoreExport IParamArray *GetParamBlock();
		CoreExport int GetParamBlockIndex(int id);

		// Evaluates the node reference and returns the WSM object.
		CoreExport WSMObject *GetWSMObject(TimeValue t);
				
		// When clients are cloning themselves, they should call this 
		// method on the clone to copy SimpleMod's data.
		CoreExport void SimpleWSMModClone(SimpleWSMMod *smodSource);

		// Clients of simpmod probably want to override these. If they do
		// the should call these from within thier methods.
		CoreExport void BeginEditParams(IObjParam *ip, ULONG flags,Animatable *prev);
		CoreExport void EndEditParams(IObjParam *ip, ULONG flags,Animatable *next);

		// Clients of simpmod need to implement this method
		virtual Deformer& GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat)=0;
		virtual void InvalidateUI() {}
		virtual Interval GetValidity(TimeValue t) {return FOREVER;}
		virtual	ParamDimension *GetParameterDim(int pbIndex) {return defaultDim;}
		virtual TSTR GetParameterName(int pbIndex) {return TSTR(_T("Parameter"));}
		virtual void InvalidateParamMap() {}

		// Schematic view Animatable overides...
		CoreExport SvGraphNodeReference SvTraverseAnimGraph(IGraphObjectManager *gom, Animatable *owner, int id, DWORD flags);
	};


#define SIMPWSMMOD_OBREF		0
#define SIMPWSMMOD_NODEREF		1
#define SIMPWSMMOD_PBLOCKREF	2

#define SIMPLEOSMTOWSM_CLASSID	Class_ID(0x3fa72be3,0xa5ee1bf9)

// Used by SimpleOSMToWSMObject to create WSMs out of OSMs
class SimpleOSMToWSMMod : public SimpleWSMMod {
	public:
		CoreExport SimpleOSMToWSMMod();
		CoreExport SimpleOSMToWSMMod(INode *node);

		void GetClassName(TSTR& s) {s=GetObjectName();}
		SClass_ID SuperClassID() {return WSM_CLASS_ID;}
		Class_ID ClassID() {return SIMPLEOSMTOWSM_CLASSID;} 
		void DeleteThis() {delete this;}
		CoreExport RefTargetHandle Clone(RemapDir& remap = NoRemap());
		CoreExport TCHAR *GetObjectName();

		CoreExport Deformer& GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat);		
		CoreExport Interval GetValidity(TimeValue t);		
	};

CoreExport ClassDesc* GetSimpleOSMToWSMModDesc();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\simpobj.h ===
/**********************************************************************
 *<
	FILE: SimpObj.h

	DESCRIPTION:  A base class for procedural objects that fit into
	              a standard form.

	CREATED BY: Rolf Berteig

	HISTORY: created 10/10/95

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __SIMPOBJ__
#define __SIMPOBJ__

// ParticleSys lib
#include "partclib.h"


class SimpleObject : public GeomObject {
	public:
		IParamBlock *pblock;
		Mesh mesh;
		Interval ivalid;

		BOOL suspendSnap;	// If TRUE, no snapping will occur
		
		static SimpleObject *editOb;

		CoreExport SimpleObject();
		CoreExport ~SimpleObject();
		
		CoreExport void UpdateMesh(TimeValue t);				
		CoreExport void GetBBox(TimeValue t, Matrix3& tm, Box3& box );		
		void MeshInvalid() {ivalid.SetEmpty();}
		
		// From BaseObject
		CoreExport void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
		CoreExport void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		CoreExport int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt);
		CoreExport void Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt);
		CoreExport int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);		
		CoreExport IParamArray *GetParamBlock();
		CoreExport int GetParamBlockIndex(int id);

		// From Object
		CoreExport ObjectState Eval(TimeValue time);
		void InitNodeName(TSTR& s) {s = GetObjectName();}
		CoreExport Interval ObjectValidity(TimeValue t);
		CoreExport int CanConvertToType(Class_ID obtype);
		CoreExport Object* ConvertToType(TimeValue t, Class_ID obtype);		
        CoreExport BOOL PolygonCount(TimeValue t, int& numFaces, int& numVerts);

		// From GeomObject
		CoreExport int IntersectRay(TimeValue t, Ray& ray, float& at, Point3& norm);		
		CoreExport void GetWorldBoundBox(TimeValue t, INode* inode, ViewExp* vpt, Box3& box );
		CoreExport void GetLocalBoundBox(TimeValue t, INode* inode, ViewExp* vpt, Box3& box );
		CoreExport void GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm, BOOL useSel );
		CoreExport Mesh* GetRenderMesh(TimeValue t, INode *inode, View &view, BOOL& needDelete);

		// Animatable methods
		CoreExport void FreeCaches(); 		
		void GetClassName(TSTR& s) {s = GetObjectName();}		
		int NumSubs() { return 1; }  
		Animatable* SubAnim(int i) { return pblock; }
		CoreExport TSTR SubAnimName(int i);

		// From ref
		int NumRefs() {return 1;}
		RefTargetHandle GetReference(int i) {return pblock;}
		void SetReference(int i, RefTargetHandle rtarg) {pblock=(IParamBlock*)rtarg;}		
		CoreExport RefResult NotifyRefChanged(Interval changeInt,RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message);
		

		// --- These must be implemented by the derived class ----------------
		virtual void BuildMesh(TimeValue t)=0;
		virtual BOOL OKtoDisplay(TimeValue t) {return TRUE;}
		virtual void InvalidateUI() {}
		virtual	ParamDimension *GetParameterDim(int pbIndex) {return defaultDim;}
		virtual TSTR GetParameterName(int pbIndex) {return TSTR(_T("Parameter"));}		
	};

// ParamBlock2 version added JBW 9/11/98

class IParamBlock2;
class SimpleObject2 : public SimpleObject {
	public:
		IParamBlock2* pblock2;
		// From ref
		RefTargetHandle GetReference(int i) {return pblock;}
		void SetReference(int i, RefTargetHandle rtarg) { pblock2 = (IParamBlock2*)rtarg; SimpleObject::SetReference(i, rtarg); }		
	};

class SimpleWSMObject : public WSMObject {
	public:
		IParamBlock *pblock;
		Mesh mesh;
		Interval ivalid;
		
		static SimpleWSMObject *editOb;

		CoreExport SimpleWSMObject();
		CoreExport ~SimpleWSMObject();
		
		CoreExport void UpdateMesh(TimeValue t);				
		CoreExport void GetBBox(TimeValue t, Matrix3& tm, Box3& box );		
		void MeshInvalid() {ivalid.SetEmpty();}
		
		// From BaseObject
		CoreExport void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
		CoreExport void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		CoreExport int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt);
		CoreExport void Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt);
		CoreExport int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);		
		CoreExport IParamArray *GetParamBlock();
		CoreExport int GetParamBlockIndex(int id);

		// From Object
		int DoOwnSelectHilite() {return TRUE;}
		CoreExport ObjectState Eval(TimeValue time);
		void InitNodeName(TSTR& s) {s = GetObjectName();}
		CoreExport Interval ObjectValidity(TimeValue t);		
		CoreExport void GetWorldBoundBox(TimeValue t, INode* inode, ViewExp* vpt, Box3& box );
		CoreExport void GetLocalBoundBox(TimeValue t, INode* inode, ViewExp* vpt, Box3& box );
		CoreExport void GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm, BOOL useSel );
		int IsRenderable() {return FALSE;}

		// Animatable methods
		CoreExport void FreeCaches(); 		
		void GetClassName(TSTR& s) {s = GetObjectName();}		
		int NumSubs() { return 1; }  
		Animatable* SubAnim(int i) { return pblock; }
		CoreExport TSTR SubAnimName(int i);

		// From ref
		int NumRefs() {return 1;}
		RefTargetHandle GetReference(int i) {return pblock;}
		void SetReference(int i, RefTargetHandle rtarg) {pblock=(IParamBlock*)rtarg;}		
		CoreExport RefResult NotifyRefChanged(Interval changeInt,RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message);
		

		// --- These must be implemented by the derived class ----------------
		virtual void BuildMesh(TimeValue t)=0;
		virtual BOOL OKtoDisplay(TimeValue t) {return TRUE;}
		virtual void InvalidateUI() {}
		virtual	ParamDimension *GetParameterDim(int pbIndex) {return defaultDim;}
		virtual TSTR GetParameterName(int pbIndex) {return TSTR(_T("Parameter"));}		
	};

class SimpleMod;
class IParamMap;

// Make a WSM out of an OSM
class SimpleOSMToWSMObject : public SimpleWSMObject {
	public:
		SimpleMod *mod;
		static IParamMap *pmapParam;

		CoreExport SimpleOSMToWSMObject();
		CoreExport SimpleOSMToWSMObject(SimpleMod *m);

		int NumRefs() {return 2;}
		CoreExport RefTargetHandle GetReference(int i);
		CoreExport void SetReference(int i, RefTargetHandle rtarg);
		CoreExport IOResult Load(ILoad *iload);

		int NumSubs() {return 2;}  
		CoreExport Animatable* SubAnim(int i);
		CoreExport TSTR SubAnimName(int i);

		CoreExport void BuildMesh(TimeValue t);
		CoreExport Modifier *CreateWSMMod(INode *node);

		CoreExport CreateMouseCallBack* GetCreateMouseCallBack();
		CoreExport void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
		CoreExport void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);

		CoreExport ParamDimension *GetParameterDim(int pbIndex) {return stdWorldDim;}
		CoreExport TSTR GetParameterName(int pbIndex);

		CoreExport Deformer &GetDecayDeformer(TimeValue t,Deformer &mdef,Point3 origin,Interval &iv);

		CoreExport SimpleOSMToWSMObject* SimpleOSMToWSMClone(SimpleOSMToWSMObject *from,RemapDir& remap);

		CoreExport void InvalidateUI();
	};

#define PB_OSMTOWSM_LENGTH	0
#define PB_OSMTOWSM_WIDTH	1
#define PB_OSMTOWSM_HEIGHT	2
#define PB_OSMTOWSM_DECAY	3


class SimpleParticle : public ParticleObject {
	public:
		IParamBlock *pblock;
		ParticleSys parts;
		TimeValue tvalid;
		BOOL valid;
		Tab<ForceField*> fields;		
		Tab<CollisionObject*> cobjs;
		Mesh mesh;
		Interval mvalid;
		MetaParticle metap;
		
		CoreExport static SimpleParticle *editOb;
		CoreExport static IObjParam *ip;

		CoreExport SimpleParticle();
		CoreExport ~SimpleParticle();
				
		CoreExport void Update(TimeValue t,INode *node=NULL);
		CoreExport void UpdateMesh(TimeValue t);
		CoreExport void GetBBox(TimeValue t, Matrix3& tm, Box3& box);		
		void MeshInvalid() {mvalid.SetEmpty();}
		void ParticleInvalid() {valid=FALSE;}

		// From BaseObject
		CoreExport void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
		CoreExport void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		CoreExport int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt);		
		CoreExport int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);		
		CoreExport IParamArray *GetParamBlock();
		CoreExport int GetParamBlockIndex(int id);

		// From Object
		int DoOwnSelectHilite() {return TRUE;}
		CoreExport ObjectState Eval(TimeValue time);
		void InitNodeName(TSTR& s) {s = GetObjectName();}
		CoreExport Interval ObjectValidity(TimeValue t);
		CoreExport int CanConvertToType(Class_ID obtype);
		CoreExport Object* ConvertToType(TimeValue t, Class_ID obtype);		
		CoreExport Object *MakeShallowCopy(ChannelMask channels);
		void WSStateInvalidate() {valid = FALSE;}
		BOOL IsWorldSpaceObject() {return TRUE;}

		// From GeomObject				
		CoreExport void GetWorldBoundBox(TimeValue t, INode* inode, ViewExp* vpt, Box3& box );
		CoreExport void GetLocalBoundBox(TimeValue t, INode* inode, ViewExp* vpt, Box3& box );
		CoreExport void GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm, BOOL useSel );

		// From ParticleObject
		CoreExport void ApplyForceField(ForceField *ff);
		CoreExport BOOL ApplyCollisionObject(CollisionObject *co);
		CoreExport TimeValue ParticleAge(TimeValue t, int i);		
		CoreExport void SetParticlePosition(TimeValue t, int i, Point3 pos);
		CoreExport void SetParticleVelocity(TimeValue t, int i, Point3 vel);
		CoreExport void SetParticleAge(TimeValue t, int i, TimeValue age);

		// Animatable methods		
		void GetClassName(TSTR& s) {s = GetObjectName();}		
		int NumSubs() {return 1;}  
		Animatable* SubAnim(int i) { return pblock; }
		CoreExport TSTR SubAnimName(int i);
		CoreExport void* GetInterface(ULONG id);

		// From ref
		int NumRefs() {return 1;}
		RefTargetHandle GetReference(int i) {return pblock;}
		void SetReference(int i, RefTargetHandle rtarg) {pblock=(IParamBlock*)rtarg;}		
		CoreExport RefResult NotifyRefChanged(Interval changeInt,RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message);
		

		// --- These must be implemented by the derived class ----------------
		virtual void UpdateParticles(TimeValue t,INode *node)=0;
		virtual void BuildEmitter(TimeValue t, Mesh& amesh)=0;
		virtual Interval GetValidity(TimeValue t)=0;
		virtual MarkerType GetMarkerType() {return POINT_MRKR;}
		virtual BOOL OKtoDisplay(TimeValue t) {return TRUE;}
		virtual BOOL EmitterVisible() {return TRUE;}
		virtual void InvalidateUI() {}
		virtual	ParamDimension *GetParameterDim(int pbIndex) {return defaultDim;}
		virtual TSTR GetParameterName(int pbIndex) {return TSTR(_T("Parameter"));}		
	};

class GenBoxObject: public SimpleObject {	
	public:
	virtual void SetParams(float width, float height, float length, int wsegs=1,int lsegs=1, 
		int hsegs=1, BOOL genUV=TRUE)=0; 
	};

class GenCylinder: public SimpleObject {	
	public:
	virtual void SetParams(float rad, float height, int segs, int sides, int capsegs=1, BOOL smooth=TRUE, 
		BOOL genUV=TRUE, BOOL sliceOn= FALSE, float slice1 = 0.0f, float slice2 = 0.0f)=0;
	};

class GenSphere: public SimpleObject {	
	public:
	virtual void SetParams(float rad, int segs, BOOL smooth=TRUE, BOOL genUV=TRUE,
		 float hemi=0.0f, BOOL squash=FALSE, BOOL recenter=FALSE)=0;
	};


#endif // __SIMPOBJ__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\soundobj.h ===
/**********************************************************************
 *<
	FILE:  soundobj.h

	DESCRIPTION:  Sound plug-in object base class

	CREATED BY:  Rolf Berteig

	HISTORY: created 2 July 1995

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef _SOUNDOBJ_H_
#define _SOUNDOBJ_H_

#include <vfw.h>


class SoundObj : public ReferenceTarget {
	public:
		virtual SClass_ID SuperClassID() {return SClass_ID(SOUNDOBJ_CLASS_ID);}		

		virtual BOOL Play(TimeValue tStart,TimeValue t0,TimeValue t1,TimeValue frameStep)=0;
		virtual void Scrub(TimeValue t0,TimeValue t1)=0;
		virtual TimeValue Stop()=0;
		virtual TimeValue GetTime()=0;
		virtual BOOL Playing()=0;
		virtual void SaveSound(PAVIFILE pfile,TimeValue t0,TimeValue t1)=0;
		virtual void SetMute(BOOL mute)=0;
		virtual BOOL IsMute()=0;
	};


CoreExport SoundObj *NewDefaultSoundObj();

#endif // _SOUNDOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\simpshp.h ===
/**********************************************************************
 *<
	FILE: simpshp.h

	DESCRIPTION:  Defines a simple shape object class to make
		procedural shape primitives easier to create

	CREATED BY: Tom Hudson

	HISTORY: created 30 October 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#ifndef __SIMPSHP_H__ 

#define __SIMPSHP_H__

class SimpleShape: public ShapeObject {			   
	public:
		IParamBlock *pblock;

		static IObjParam *ip;
		static HWND hGenParams;
		static BOOL dlgRenderable;
		static float dlgThickness;
		static BOOL dlgGenUVs;
		static ISpinnerControl *thickSpin;

		// Shape cache
		PolyShape shape;
		Interval ivalid;

		// Flag to suspend snapping -- Used during creation
		BOOL suspendSnap;

		CoreExport void UpdateShape(TimeValue t);

		static SimpleShape *editOb;

		CoreExport SimpleShape();
		CoreExport ~SimpleShape();

		void ShapeInvalid() { ivalid.SetEmpty(); }

		//  inherited virtual methods:

		// From BaseObject
		CoreExport int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt);
		CoreExport void Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt);
		CoreExport int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
		CoreExport virtual void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);
		CoreExport virtual void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		IParamArray *GetParamBlock() {return pblock;}
		CoreExport int GetParamBlockIndex(int id);

		// From Object
		CoreExport ObjectState Eval(TimeValue time);
		CoreExport Interval ObjectValidity(TimeValue t);
		CoreExport int CanConvertToType(Class_ID obtype);
		CoreExport Object* ConvertToType(TimeValue t, Class_ID obtype);
		CoreExport void BuildMesh(TimeValue t, Mesh &mesh);
				
		// From ShapeObject
		CoreExport ObjectHandle CreateTriObjRep(TimeValue t);  // for rendering, also for deformation		
		CoreExport void GetWorldBoundBox(TimeValue t, INode* inode, ViewExp* vpt, Box3& box );
		CoreExport void GetLocalBoundBox(TimeValue t, INode* inode, ViewExp* vxt, Box3& box );
		CoreExport void GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm, BOOL useSel );
		CoreExport int NumberOfVertices(TimeValue t, int curve);
		CoreExport int NumberOfCurves();
		CoreExport BOOL CurveClosed(TimeValue t, int curve);
		CoreExport ShapeHierarchy &OrganizeCurves(TimeValue t, ShapeHierarchy *hier=NULL);	// Ready for lofting, extrusion, etc.
		CoreExport void MakePolyShape(TimeValue t, PolyShape &shape, int steps = PSHAPE_BUILTIN_STEPS, BOOL optimize = FALSE);
		CoreExport int MakeCap(TimeValue t, MeshCapInfo &capInfo, int capType);	// Makes a cap out of the shape
		CoreExport int MakeCap(TimeValue t, PatchCapInfo &capInfo);

		int NumRefs() {return 1;}
		RefTargetHandle GetReference(int i) {return pblock;}
		void SetReference(int i, RefTargetHandle rtarg) {pblock=(IParamBlock*)rtarg;}		
		CoreExport RefResult NotifyRefChanged(Interval changeInt,RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message);

		CoreExport void ReadyGeneralParameters();
		CoreExport void SimpleShapeClone( SimpleShape *sshpSource );

 		int NumSubs() { return 1; }  
		Animatable* SubAnim(int i) { return pblock; }
		CoreExport TSTR SubAnimName(int i);		

		// Animatable methods
		void DeleteThis() { delete this; }
		CoreExport void FreeCaches(); 

		// IO
		CoreExport IOResult Save(ISave *isave);
		CoreExport IOResult Load(ILoad *iload);

		CoreExport void SetGenUVs(BOOL sw);
		CoreExport void SetRenderable(BOOL sw);
		CoreExport void SetThickness(float t);

		LRESULT CALLBACK TrackViewWinProc( HWND hwnd,  UINT message, 
	            WPARAM wParam,   LPARAM lParam ){return(0);}

		void GetClassName(TSTR& s) {s = GetObjectName();}
		void InitNodeName(TSTR& s) {s = GetObjectName();}

		// Clients of SimpleShape need to implement these methods:
	
		virtual Class_ID ClassID() = 0;
		virtual void BuildShape(TimeValue t,PolyShape& ashape) = 0;
		virtual RefTargetHandle Clone(RemapDir& remap = NoRemap()) = 0;
		virtual CreateMouseCallBack* GetCreateMouseCallBack() = 0;
		virtual BOOL ValidForDisplay(TimeValue t) = 0;
		virtual void InvalidateUI() {}
		virtual	ParamDimension *GetParameterDim(int pbIndex) {return defaultDim;}
		virtual TSTR GetParameterName(int pbIndex) {return TSTR(_T("Parameter"));}

		// Unlike SimpleSplines, you're probably procedural, so implementing these
		// is a must!
		virtual Point3 InterpCurve3D(TimeValue t, int curve, float param, int ptype=PARAM_SIMPLE) = 0;
		virtual Point3 TangentCurve3D(TimeValue t, int curve, float param, int ptype=PARAM_SIMPLE) = 0;
		virtual float LengthOfCurve(TimeValue t, int curve) = 0;
		
		// Here are some optional methods.
		// You should _really_ implement these, because they just do the bare-minimum job
		// (Chopping your curve up into manageable pieces makes things look better)
		virtual int NumberOfPieces(TimeValue t, int curve) { return 1; }
		virtual Point3 InterpPiece3D(TimeValue t, int curve, int piece, float param, int ptype=PARAM_SIMPLE) { return InterpCurve3D(t, curve, param, ptype); }
		virtual Point3 TangentPiece3D(TimeValue t, int curve, int piece, float param, int ptype=PARAM_SIMPLE) { return TangentCurve3D(t, curve, param, ptype); }

		CoreExport virtual MtlID GetMatID(TimeValue t, int curve, int piece);
	};				


#endif // __SIMPSHP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\simpspl.h ===
/**********************************************************************
 *<
	FILE: simpspl.h

	DESCRIPTION:  Defines a simple spline object class to make spline
		primitives easier to create

	CREATED BY: Tom Hudson

	HISTORY: created 3 October 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#ifndef __SIMPSPL_H__ 

#define __SIMPSPL_H__

// Interpolation parameter block indices
#define IPB_STEPS		0
#define IPB_OPTIMIZE	1
#define IPB_ADAPTIVE	2

// Parameter block reference indices
#define USERPBLOCK 0	// User's parameter block
#define IPBLOCK 1		// Interpolations parameter block

// Default interpolation settings
#define DEF_STEPS 6
#define DEF_OPTIMIZE TRUE
#define DEF_ADAPTIVE FALSE
#define DEF_RENDERABLE FALSE
#define DEF_THICKNESS 1.0f
#define DEF_GENUVS FALSE

// Special dialog handling
class SimpleSpline;

class SimpleSplineDlgProc : public ParamMapUserDlgProc {
	private:
		SimpleSpline *spl;
	public:
		SimpleSplineDlgProc(SimpleSpline *s) { spl = s; }
		CoreExport BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() { delete this; }
	};
						 
class SimpleSpline: public ShapeObject {			   
	private:
	public:
		IParamBlock *ipblock;	// Interpolation parameter block (handled by SimpleSpline)
		IParamBlock *pblock;	// User's parameter block

		static IParamMap *ipmapParam;
		static int dlgSteps;
		static BOOL dlgOptimize;
		static BOOL dlgAdaptive;
		static BOOL dlgRenderable;
		static float dlgThickness;
		static BOOL dlgGenUVs;
		static ISpinnerControl *thickSpin;

		// Spline cache
		BezierShape shape;
		Interval ivalid;

		// Flag to suspend snapping -- Used during creation
		BOOL suspendSnap;

		CoreExport void UpdateShape(TimeValue t);

		static SimpleSpline *editOb;

		CoreExport SimpleSpline();
		CoreExport ~SimpleSpline();

		void ShapeInvalid() { ivalid.SetEmpty(); }

		//  inherited virtual methods:

		// From BaseObject
		CoreExport int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt);
		CoreExport void Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt);
		CoreExport int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
		CoreExport virtual void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);
		CoreExport virtual void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		IParamArray *GetParamBlock() {return pblock;}
		CoreExport int GetParamBlockIndex(int id);

		// From Object
		CoreExport ObjectState Eval(TimeValue time);
		CoreExport Interval ObjectValidity(TimeValue t);
		CoreExport int CanConvertToType(Class_ID obtype);
		CoreExport Object* ConvertToType(TimeValue t, Class_ID obtype);
		CoreExport void GetCollapseTypes(Tab<Class_ID> &clist,Tab<TSTR*> &nlist);

		CoreExport void BuildMesh(TimeValue t, Mesh &mesh);
		
		// From ShapeObject
		CoreExport ObjectHandle CreateTriObjRep(TimeValue t);  // for rendering, also for deformation		
		CoreExport void GetWorldBoundBox(TimeValue t, INode* inode, ViewExp* vpt, Box3& box );
		CoreExport void GetLocalBoundBox(TimeValue t, INode* inode, ViewExp* vxt, Box3& box );
		CoreExport void GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm, BOOL useSel );
		CoreExport int NumberOfVertices(TimeValue t, int curve);
		CoreExport int NumberOfCurves();
		CoreExport BOOL CurveClosed(TimeValue t, int curve);
		CoreExport Point3 InterpCurve3D(TimeValue t, int curve, float param, int ptype=PARAM_SIMPLE);
		CoreExport Point3 TangentCurve3D(TimeValue t, int curve, float param, int ptype=PARAM_SIMPLE);
		CoreExport float LengthOfCurve(TimeValue t, int curve);
		CoreExport int NumberOfPieces(TimeValue t, int curve);
		CoreExport Point3 InterpPiece3D(TimeValue t, int curve, int piece, float param, int ptype=PARAM_SIMPLE);
		CoreExport Point3 TangentPiece3D(TimeValue t, int curve, int piece, float param, int ptype=PARAM_SIMPLE);
		CoreExport MtlID GetMatID(TimeValue t, int curve, int piece);
		BOOL CanMakeBezier() { return TRUE; }			// Return TRUE if can turn into a bezier representation
		CoreExport void MakeBezier(TimeValue t, BezierShape &shape);	// Create the bezier representation
		CoreExport ShapeHierarchy &OrganizeCurves(TimeValue t, ShapeHierarchy *hier=NULL);	// Ready for lofting, extrusion, etc.
		CoreExport void MakePolyShape(TimeValue t, PolyShape &shape, int steps = PSHAPE_BUILTIN_STEPS, BOOL optimize = FALSE);
		CoreExport int MakeCap(TimeValue t, MeshCapInfo &capInfo, int capType);	// Makes a cap out of the shape
		CoreExport int MakeCap(TimeValue t, PatchCapInfo &capInfo);

		int NumRefs() {return 2;}
		CoreExport RefTargetHandle GetReference(int i);
		CoreExport void SetReference(int i, RefTargetHandle rtarg);		
		CoreExport RefResult NotifyRefChanged(Interval changeInt,RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message);

		CoreExport void ReadyInterpParameterBlock();
		void UnReadyInterpParameterBlock() { ipblock = NULL; }

		CoreExport void SimpleSplineClone( SimpleSpline *ssplSource );

 		int NumSubs() { return 2; }  
		CoreExport Animatable* SubAnim(int i);
		CoreExport TSTR SubAnimName(int i);		

		// Animatable methods
		void DeleteThis() { delete this; }
		CoreExport void FreeCaches(); 

		// IO
		CoreExport IOResult Save(ISave *isave);
		CoreExport IOResult Load(ILoad *iload);

		CoreExport void SetGenUVs(BOOL sw);
		CoreExport void SetRenderable(BOOL sw);
		CoreExport void SetThickness(float t);

		LRESULT CALLBACK TrackViewWinProc( HWND hwnd,  UINT message, 
	            WPARAM wParam,   LPARAM lParam ){return(0);}

		void GetClassName(TSTR& s) {s = GetObjectName();}
		void InitNodeName(TSTR& s) {s = GetObjectName();}

		// Clients of SimpleSpline need to implement these methods:
	
		virtual Class_ID ClassID() = 0;
		virtual void BuildShape(TimeValue t,BezierShape& ashape) = 0;
		virtual RefTargetHandle Clone(RemapDir& remap = NoRemap()) = 0;
		virtual CreateMouseCallBack* GetCreateMouseCallBack() = 0;
		virtual BOOL ValidForDisplay(TimeValue t) = 0;
		virtual void InvalidateUI() {}
		virtual ParamDimension *GetParameterDim(int pbIndex) {return defaultDim;}
		virtual TSTR GetParameterName(int pbIndex) {return TSTR(_T("Parameter"));}
		virtual BOOL DisplayVertTicksDuringCreation() { return TRUE; }
	};				

#endif // __SIMPSPL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\SpaceArrayCallback.h ===
////////////////////////////////////////////////////////////////////////////////
// Module:	SpaceArrayCallback.H
// Purpose:	SpaceArrayCallback class definition
// Author:	Peter Sauerbrei
//	HISTORY:	- created January 1998
//				- changed object type to CloneType 01/28/98 (PJS)
//				- changed CloneType back to OTYPE 01/30/98 (PJS)
//				- added proc to act as callback 02/02/98 (PJS)
//				- added new context modes 02/17/98 (PJS)
//


#ifndef __SPACEARRAYCALLBACK_H
#define __SPACEARRAYCALLBACK_H

// include files
#include <limits.h>
#include <max.h>
#include <splshape.h>

// needed types
enum STYPE { SPACE_CENTER, SPACE_EDGE };
enum OTYPE { NODE_CPY, NODE_INST, NODE_REF };
enum CTYPE { CTXT_FREE, CTXT_CNTRCOUNT, CTXT_CNTRSPACE,
				CTXT_END, CTXT_ENDCOUNT, CTXT_ENDSPACE,
				CTXT_START, CTXT_STARTCOUNT, CTXT_STARTSPACE,
				CTXT_FULLSPACE, CTXT_FULLCOUNT, CTXT_ENDLOCK,
				CTXT_ENDLOCKCOUNT, CTXT_ENDLOCKSPACE, CTXT_STARTLOCK,
				CTXT_STARTLOCKCOUNT, CTXT_STARTLOCKSPACE,
				CTXT_FULLLOCKSPACE, CTXT_FULLLOCKCOUNT,};



////////////////////////////////////////////////////////////////////////////////
// SpaceArracyCallback
//
class SpaceArrayCallback
{
private:
	ShapeObject * path;
	float start, end, space;
	int count;
	OTYPE oType;
	bool follow;
	STYPE sType;
	CTYPE context;
	float width;
	char buffer[100];
	int countLimit;

public:
	SpaceArrayCallback() { path = NULL; start = end = space = 0.0f; count = 1; oType = NODE_CPY; sType = SPACE_CENTER; follow = false; 
							context = CTXT_FREE; width = 0.0f; countLimit = INT_MAX; }
	virtual ~SpaceArrayCallback() {}

	// methods
	virtual bool isModal(void) { return true; }
	virtual bool doPickPath(void) { return false; }
	virtual TCHAR * dialogTitle(void) { return _T(""); }
	virtual TCHAR * startMessage(void) { return _T(""); }
	virtual TCHAR * buttonText(void) { return _T("OK"); }
	virtual bool isSilent(void) { return false; }
	virtual bool doObjectType(void) { return true; }
	virtual void proc(void) {}
	
	// accessors
	ShapeObject * getPath(void)	{ return path; }
	void setPath(ShapeObject * p) { path = p; }
	void setPath(Point3 pt1, Point3 pt2) { path = new SplineShape;
					((SplineShape *)path)->shape.Init();
					((SplineShape *)path)->shape.NewSpline();
					Spline3D * spline = ((SplineShape *)path)->shape.GetSpline(0);
					spline->AddKnot(SplineKnot(KTYPE_CORNER, LTYPE_LINE, pt1, pt1, pt1));
					spline->AddKnot(SplineKnot(KTYPE_CORNER, LTYPE_LINE, pt2, pt2, pt2));
					spline->ComputeBezPoints();
	}
	void setPath(Spline3D *s) { path = new SplineShape;
					((SplineShape *)path)->shape.Init();
					((SplineShape *)path)->shape.AddSpline(s);
					s->ComputeBezPoints();
	}
	float getStart(void)	{ return start; }
	float getEnd(void)		{ return end; }
	float getSpace(void)	{ return space; }
	int getCount(void)		{ return count; }
	int getContext(void)	{ return context; }
	float getWidth(void) { return width; }
	void setStart(float f)	{ start = f; }
	void setEnd(float f)	{ end = f; }
	void setSpace(float f)	{ space = f; }
	void setCount(int n)	{ count = n > countLimit ? countLimit : n; }
	bool getFollow(void)	{ return follow; }
	void setFollow(bool t)	{ follow = t; }
  void setContext(CTYPE c)	{ context = c; }
	OTYPE getObjectCreationType(void)	{ return oType; }
	void setObjectCreationType(OTYPE t) { oType = t; }
	STYPE getSpacingType(void){ return sType; }
	void setSpacingType(STYPE s) { sType = s; }
	void setMessage(char * buf) { strcpy(buffer, buf); }
	void setWidth(float nWidth) { width = nWidth; }
	void setCountLimit(int limit) { countLimit = limit; }
	int getCountLimit(void) { return countLimit; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\SimpComp.h ===
/**********************************************************************
 *<
	FILE: simpcomp.h

	DESCRIPTION:  A sample composite/leaf pair.

	CREATED BY: John Hutchinson

	HISTORY: created 8/24/98

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#ifndef _COMP_OBJ
#define _COMP_OBJ

#define _CACHING

#include "compbase.h"
#include "iparamb.h"
#ifdef _CACHING
#include "shape.h"
#endif

class PickMember;
class MoveModBoxCMode;
class RotateModBoxCMode;
class UScaleModBoxCMode;
class NUScaleModBoxCMode;
class SquashModBoxCMode;
class SelectModBoxCMode;

extern TCHAR *GetString(int id);
extern HINSTANCE hInstance;

#define BEGIN_EDIT_SKIP_SO_REGISTRATION		(1<<7)

class SimpleComposite : public CompositeBase
{
	friend class SimpleCompositeIterator;
	friend class UiUpdateRestore;
	friend class OpSelectionRestore;
	friend class ToggleHiddenRestore;

	enum { kobjectarray, kcontrolarray };

	//object list (references that we make)
	Tab<Object*> m_objlist;
	//controller list
	Tab<RefTargetHandle> m_ctllist;

protected://JH 1/13/99 let derived classes get at this stuff
	NameTab m_opName;
	BitArray selbits;//bit array to store the selection state of the components
	BitArray hidebits;//array to store the hidden state
#define EXPAND_BITS 64 //the chunk size for resizing the bit array

	bool m_creating;
//	int iSelLevel; //JH 5/31/99 moving to base class
	CoreExport static SimpleComposite* editObj;

	Matrix3 m_AmbientTM;
	Interval ivalid;

#ifdef _CACHING
protected:
	Mesh meshcache;
	BezierShape bezcache;
	Interval meshvalid;
	Interval shapevalid;
#endif
	int mOpContentFlags; // a cached value; if flag is zero, it is not up-to-date
	enum
	{
		kFlagsValid = 1,
		kContainsBaseMesh = 2,
		kContainsBaseShape = 4,
		kContainsEvalMesh = 8,
		kContainsEvalShape = 16,
	};
	bool mContentUpdateInProgress;

	class CompositeDeleteKeyUser : public EventUser
	{
	private:
		Object* m_composite_obj;
	public:
		//local methods
		CompositeDeleteKeyUser(){m_composite_obj = NULL;}
		void SetObject(Object* o){m_composite_obj = o;}

		//from Eventuser
		void Notify();
	}
	m_delete_user;

public:	//Class variables
	//miscellaneous
	CoreExport static IObjParam *ip;			//Access to the interface
	CoreExport static HWND hParams1;			// the object level dialog
	CoreExport static HWND hParams2;			// the subobject dialog
	static PickMember pickCB;
	static bool BlockExtract;
	CoreExport static Class_ID m_classid;

	//subobject modes
	CoreExport static MoveModBoxCMode *moveMode;
	CoreExport static RotateModBoxCMode *rotMode;
	CoreExport static UScaleModBoxCMode *uscaleMode;
	CoreExport static NUScaleModBoxCMode *nuscaleMode;
	CoreExport static SquashModBoxCMode *squashMode;
	CoreExport static SelectModBoxCMode *selectMode;

public: //methods
	// Constructor/Destructor
	CoreExport SimpleComposite();
	CoreExport ~SimpleComposite();

	// From Animatable
	CoreExport virtual void DeleteThis(){delete this;}
	CoreExport virtual void BeginEditParams(IObjParam  *ip, ULONG flags, Animatable *prev);
	CoreExport virtual void EndEditParams(IObjParam *ip, ULONG flags, Animatable *next);
	CoreExport virtual Class_ID ClassID() { return m_classid; }
	CoreExport virtual void FreeCaches();
	CoreExport virtual void* GetInterface(ULONG id);
	CoreExport virtual void GetClassName(TSTR& s) { s = _T("SimpleComposite"); }


	// From ReferenceMaker
	CoreExport virtual RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
										PartID& partID, RefMessage message);
	CoreExport virtual IOResult Load(ILoad* iload);
	CoreExport virtual IOResult Save(ISave* isave);

	// From ReferenceTarget
	CoreExport virtual RefTargetHandle Clone(RemapDir& remap);

	// From BaseObject
	CoreExport virtual int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
	CoreExport virtual int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, 
									IPoint2 *p, ViewExp *vpt);
	CoreExport virtual void ActivateSubobjSel(int level, XFormModes& modes);
	CoreExport virtual CreateMouseCallBack* GetCreateMouseCallBack();
	CoreExport virtual TCHAR *GetObjectName();
	CoreExport virtual void SelectSubComponent(HitRecord *hitRec, BOOL selected, BOOL all, BOOL invert=FALSE);
	CoreExport virtual void ClearSelection(int selLevel);
	CoreExport virtual void Move( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin=FALSE);
	CoreExport virtual void Rotate( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Quat& val, BOOL localOrigin=FALSE);
	CoreExport virtual void Scale( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin=FALSE);
	CoreExport virtual void TransformStart(TimeValue t);
	CoreExport virtual int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, 
									IPoint2 *p, ViewExp *vpt, ModContext* mc);
	//4/12/99 JH
	CoreExport virtual void CloneSelSubComponents(TimeValue t); 
	CoreExport virtual void AcceptCloneSelSubComponents(TimeValue t);


	// From Object
	CoreExport virtual void InitNodeName(TSTR& s);
	CoreExport virtual Interval ObjectValidity(TimeValue t);
	CoreExport virtual int UsesWireColor(){return FALSE;}
	//CoreExport virtual int DoOwnSelectHilite(){return 0;}
	CoreExport virtual int NumPipeBranches();
	CoreExport virtual Object *GetPipeBranch(int i);
	CoreExport virtual INode *GetBranchINode(TimeValue t, INode *node, int i);
	CoreExport virtual int IsRenderable();
	CoreExport virtual BOOL IsShapeObject();

	// From IComponent
	CoreExport virtual void Add(TimeValue t, Object* obj, TSTR objname, Matrix3& oppTm, Matrix3& boolTm, Matrix3& parTM, Control* opCont = NULL);
	CoreExport virtual void Add(TimeValue t,INode *node,Matrix3& boolTm, bool delnode = true);
	CoreExport virtual void Remove(ComponentIterator& i);
	CoreExport virtual void DisposeTemporary();
	CoreExport virtual ComponentIterator * MakeIterator();
	CoreExport virtual ComponentIterator * MakeReverseIterator();
	CoreExport virtual Object* MakeLeaf(Object* o);
	CoreExport virtual bool IsLeaf() const { return false; }
	CoreExport virtual void SelectOp(int which, BOOL selected);
	CoreExport virtual void ClearSelection();
	CoreExport virtual int GetSubSelectionCount();

	// From IRefArray
	CoreExport virtual int NumRefRows() const; // the number of arrays I maintain including inner
	CoreExport virtual void EnlargeAndInitializeArrays(int newsize);
	CoreExport virtual const ReferenceArray& RefRow(int which) const;
	CoreExport virtual ReferenceArray& RefRow(int which);

	// From CompositeBase
	CoreExport virtual ObjectState EvalPipeObj(TimeValue t, Object* obj);
	CoreExport virtual void CombineComponentMeshes(TimeValue t, Mesh& m);
	CoreExport virtual void CombineComponentShapes(TimeValue t, BezierShape& Dest);
	CoreExport virtual void CombineRenderMeshes(TimeValue t, INode *inode, View& view, Mesh& m);
	CoreExport virtual bool HasOnlyShapeOperands(TimeValue t);

	//Local Methods
	CoreExport virtual void GetOpTM(TimeValue t,int which, Matrix3& tm, Interval *iv=NULL) const;
	CoreExport virtual void Invalidate();
	CoreExport virtual void HideOp(int which, BOOL hidden);
	CoreExport virtual bool IsSubObjSelected(int i);
	CoreExport virtual bool IsSubObjHidden(int i);
	CoreExport virtual void ExtractOperands(TimeValue t, INode* node, bool autodelete = true, bool justhide = false);
	CoreExport virtual void SetupUI2();
	CoreExport virtual void DoSubObjSelectionFromList();
	CoreExport virtual void CheckIfShapeIsRenderable(Object *obj){}
	CoreExport virtual void SetName(int i, TCHAR *n){ assert(m_opName.Count() > i); m_opName.SetName(i,n); }
	CoreExport virtual TSTR GetName(int i){ assert(m_opName.Count() > i  &&  m_opName[i]); return m_opName[i]; }

protected:
	CoreExport void Clone(SimpleComposite * newob, RemapDir & remap);
	CoreExport void DisableExtract(bool extract);
	CoreExport void ToggleHidden(const Tab<int>& opset);
	CoreExport void UpdateContentFlags(bool recalc = false);
	CoreExport void EnableDeleteKey(bool OnOff);
};

//FIXME JH
//Consider creating a new class GeomObjectWrapper which encapsulates
//the delegation of the geoobject methods

//SS 4/12/99: Now derives from ShapeObject; if you leaf will only
// reference mesh geometry, override SuperClassID() and IsShapeObject().
class SimpleLeaf : public ShapeObject, public IComponent
{
	friend class SimpleLeafClassDesc;

	static Class_ID m_classid;

protected:
	Object* m_obj;
	bool m_deleteMe;
private:

public:
	// Constructor/Destructor
	CoreExport SimpleLeaf() : ShapeObject(), m_obj(NULL), m_deleteMe(false)
		{}
	CoreExport SimpleLeaf(Object* o, bool dm = true);
	CoreExport ~SimpleLeaf();

	// Static methods for dynamic allocation
	CoreExport static SimpleLeaf* CreateSimpleLeaf(Object *ob, bool dm = true);
	CoreExport static void DeleteSimpleLeaf(SimpleLeaf* l);

	// From Animatable
	CoreExport void DeleteThis()
		{ delete this; }
	CoreExport SClass_ID SuperClassID();
	CoreExport void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
	CoreExport void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
	CoreExport Class_ID ClassID()
		{ return m_classid; }
	CoreExport virtual void FreeCaches();
	CoreExport virtual void* GetInterface(ULONG id);
	CoreExport virtual void GetClassName(TSTR& s)
		{ s = _T("SimpleLeaf"); }

	// From ReferenceMaker
	CoreExport int NumRefs()
		{ return 1; }
	CoreExport void SetReference(int i, RefTargetHandle rtarg)
		{ m_obj = (Object*) rtarg; }
	CoreExport RefTargetHandle GetReference(int i)
		{ return m_obj; }
	CoreExport RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
										PartID& partID, RefMessage message)
		{ return REF_SUCCEED; }
	CoreExport IOResult Load(ILoad* iload)
		{ return ShapeObject::Load(iload); }
	CoreExport IOResult Save(ISave* isave)
		{ return ShapeObject::Save(isave); }

	// From ReferenceTarget
	CoreExport virtual RefTargetHandle Clone(RemapDir& remap);
	
	// From BaseObject
	CoreExport TCHAR *GetObjectName();
	CoreExport CreateMouseCallBack* GetCreateMouseCallBack()
		{ return NULL; }
	CoreExport int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
	CoreExport int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt);
	CoreExport void Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt);
	CoreExport void GetWorldBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );
	CoreExport void GetLocalBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );
	// For sub-object selection
	CoreExport void Move( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin=FALSE);
	CoreExport void Rotate( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Quat& val, BOOL localOrigin);
	CoreExport void Scale( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin);
	CoreExport void TransformStart(TimeValue t);
	CoreExport int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc);
	CoreExport int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags, ModContext* mc);
	CoreExport int SubObjectIndex(HitRecord *hitRec);
	CoreExport void GetSubObjectCenters(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);
	CoreExport void GetSubObjectTMs(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);

	// From Object
	CoreExport void GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm = NULL, BOOL useSel = FALSE );
	CoreExport BOOL HasUVW();
	CoreExport void SetGenUVW(BOOL sw);
	CoreExport BOOL CanConvertToType(Class_ID obtype);
	CoreExport Object* ConvertToType(TimeValue t, Class_ID obtype);
	CoreExport void GetCollapseTypes(Tab<Class_ID> &clist, Tab<TSTR*> &nlist);
	CoreExport Class_ID PreferredCollapseType();
	CoreExport int IntersectRay(TimeValue t, Ray& ray, float& at, Point3& norm);
	CoreExport ObjectState Eval(TimeValue t);
	CoreExport BOOL IsShapeObject();
	CoreExport void InitNodeName(TSTR& s);
	CoreExport Interval ObjectValidity(TimeValue t);
	CoreExport int DoOwnSelectHilite();
	CoreExport int NumPipeBranches();
	CoreExport Object *GetPipeBranch(int i);
	CoreExport INode *GetBranchINode(TimeValue t,INode *node,int i);

	// From GeomObject
	CoreExport Mesh* GetRenderMesh(TimeValue t, INode *inode, View& view, BOOL& needDelete);
	
	// From ShapeObject
	CoreExport int NumberOfVertices(TimeValue t, int curve = -1);
	CoreExport int NumberOfCurves();
	CoreExport BOOL CurveClosed(TimeValue t, int curve);
	CoreExport Point3 InterpCurve3D(TimeValue t, int curve, float param, int ptype=PARAM_SIMPLE);
	CoreExport Point3 TangentCurve3D(TimeValue t, int curve, float param, int ptype=PARAM_SIMPLE);
	CoreExport float LengthOfCurve(TimeValue t, int curve);
	CoreExport int NumberOfPieces(TimeValue t, int curve);
	CoreExport Point3 InterpPiece3D(TimeValue t, int curve, int piece, float param, int ptype=PARAM_SIMPLE);
	CoreExport Point3 TangentPiece3D(TimeValue t, int curve, int piece, float param, int ptype=PARAM_SIMPLE);
	CoreExport MtlID GetMatID(TimeValue t, int curve, int piece);
	CoreExport BOOL CanMakeBezier();
	CoreExport void MakeBezier(TimeValue t, BezierShape &shape);
	CoreExport void MakePolyShape(TimeValue t, PolyShape &shape, int steps = PSHAPE_BUILTIN_STEPS, BOOL optimize = FALSE);
	CoreExport ShapeHierarchy &OrganizeCurves(TimeValue t, ShapeHierarchy *hier=NULL);
	CoreExport int MakeCap(TimeValue t, MeshCapInfo &capInfo, int capType);
	CoreExport int MakeCap(TimeValue t, PatchCapInfo &capInfo);
	CoreExport BOOL AttachShape(TimeValue t, INode *thisNode, INode *attachNode, BOOL weldEnds=FALSE, float weldThreshold=0.0f);

	
	// From IComponent
	CoreExport virtual void Add(TimeValue t, Object*, TSTR objname, Matrix3& oppTm, Matrix3& boolTm,  Matrix3& parTM, Control* opCont = NULL);
	CoreExport virtual void Add(TimeValue t,INode *node,Matrix3& boolTm, bool delnode = true);
	CoreExport virtual void Remove(ComponentIterator& i);
	CoreExport virtual void DisposeTemporary();
	CoreExport virtual ComponentIterator * MakeIterator();
	CoreExport virtual ComponentIterator * MakeReverseIterator()
		{ return MakeIterator(); }
	CoreExport virtual Object* MakeLeaf(Object* o);
	CoreExport virtual bool IsLeaf() const
		{ return true; }
	CoreExport virtual void SelectOp(int which, BOOL selected)
		{}
	CoreExport virtual void ClearSelection()
		{}
	CoreExport virtual int GetSubSelectionCount()
		{ return 0; }
};


class SimpleCompositeIterator: public CompositeIteratorBase
{
private:
	// mutable lets us call non-const methods on SimpleComposte from
	// const iterator methods (like GetReference... ooohh).
	mutable SimpleComposite* m_pcomp;

public:
	CoreExport static SimpleCompositeIterator * CreateSimpleCompositeIterator(SimpleComposite* it);

	CoreExport SimpleCompositeIterator(/*const*/ SimpleComposite* it);
	CoreExport virtual ~SimpleCompositeIterator();

	CoreExport virtual Object* GetComponentObject() const;
	CoreExport virtual INode* GetComponentINode(INode *node) const;
	CoreExport virtual void DisposeComponentINode(INode *node) const;
	CoreExport virtual Control* GetComponentControl() const;//This need not be released
	CoreExport virtual bool Selected() const;//is the corresponding component selected?
	CoreExport virtual bool Hidden() const;//is the corresponding component hidden?
	CoreExport virtual void DeleteThis();

protected:
	// CompositeIteratorBase methods.
	CoreExport virtual Object* GetCompositeObject();
	CoreExport virtual const Object* GetCompositeObject() const;

	CoreExport virtual bool ValidIndex(int which) const;
};

class SimpleCompositeReverseIterator: public SimpleCompositeIterator
{
public:
	CoreExport SimpleCompositeReverseIterator(SimpleComposite* it);
	CoreExport virtual ~SimpleCompositeReverseIterator() {}

	CoreExport virtual void First();
	CoreExport virtual void Next();
	CoreExport virtual bool IsDone();
};

class SimpleCompositeClassDesc : public ClassDesc
{
public:
	int 			IsPublic() {return 0;}
	void *			Create(BOOL loading = FALSE) {return new SimpleComposite();}
	const TCHAR *	ClassName();
	//SS 4/12/99: RefArrayBase now derives from ShapeObject
	SClass_ID		SuperClassID() {return SHAPE_CLASS_ID;}
	Class_ID		ClassID() {return SimpleComposite::m_classid;}
	const TCHAR* 	Category();
	void			ResetClassParams (BOOL fileReset);
	BOOL			OkToCreate(Interface *i);
	int				BeginCreate(Interface *i);
	int				EndCreate(Interface *i);

};

class SimpleLeafClassDesc : public ClassDesc
{
public:
	int 			IsPublic() {return 0;}
	void *			Create(BOOL loading = FALSE) {return new SimpleLeaf();}
	const TCHAR *	ClassName() { return _T("Simple Leaf"); }
	//SS 4/12/99: RefArrayBase now derives from ShapeObject
	SClass_ID		SuperClassID() {return SHAPE_CLASS_ID;}
	Class_ID		ClassID() {return SimpleLeaf::m_classid;}
	const TCHAR* 	Category() { return _T(""); }
	void			ResetClassParams (BOOL fileReset) {}
};

/*
Strategy for solving the ambient tm problem:
1. Enhance the DependentEnumProc to accept a return value of SKIP.
	This is pretty much required for this to work.
	4a. Define 3 constants and enhance ReferenceTarget::EnumDependents() to 
		support skipping (see my email).
	DONE
2. When an operand is deselected, all its children's selection bits are 
	cleared. There is no sense keeping these bits around, and they will
	confuse the enumerator.
	2a. This clearing must be done recursively, because the user can jump to
		the top of the mod stack in one step.
3. We implement the AmbientTmEnumerator to collect all the tms in the selected
	branch, then calculate the world space transform after enumeration is
	complete.
4. If looking at the operands of a block definition, extraction is disabled
	(should already be that way now).

// Here's how this is used: make this call from the link composite or leaf that
// wants to know its world space tm.
AmbientTmEnumerator getTM(this);
EnumDependents(getTM);
Matrix3 worldSpaceTMOfMe(1);
assert(getTM.TmIsValid());
if (getTM.TmIsValid())
	worldSpaceTMOfMe = getTM.AmbientTm();
*/


class AmbientTmEnumerator : public DependentEnumProc
{
private:
	// A stack of ptrs.
	Tab<ReferenceMaker*> mSelectedBranch;
	// A stack of tms.
	Tab<Matrix3> mTmStack;
	// initiating reference target
	ReferenceTarget * mInitiator;
	// A status so we know we ended where we should.
	bool reachedTheNode;

public:
	CoreExport AmbientTmEnumerator(ReferenceTarget * rtarg) : reachedTheNode(false) { mInitiator = rtarg; }

	CoreExport virtual int proc(ReferenceMaker* rmaker);
	CoreExport bool TmIsValid() { return reachedTheNode; }
	CoreExport Matrix3 AmbientTm()
	{
		Matrix3 tm(1);
		for (int i = 0; i < mTmStack.Count(); i++)
			tm = mTmStack[i] * tm;
		//FIXME: calculate the tm using the stack of ptrs here; Pete?
		return tm;
	}
};

class NodeEnum : public DependentEnumProc
{
private:
	// initiating reference target
	ReferenceTarget * mInitiator;

	INode * node;

	// A status so we know we ended where we should.
	bool reachedTheNode;

public:
	CoreExport NodeEnum(ReferenceTarget * rtarg) : reachedTheNode(false) { mInitiator = rtarg; }

	CoreExport virtual int proc(ReferenceMaker* rmaker);
	CoreExport bool NodeIsValid() { return reachedTheNode; }
	CoreExport INode * Node() { return node; }
};


#endif //_COMP_OBJ
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\snap.h ===
/**********************************************************************
 *<
	FILE: snap.h

	DESCRIPTION: Definitions for snap functionality

	CREATED BY: Tom Hudson

	HISTORY:

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#ifndef _SNAP_H_

#define _SNAP_H_

// Snap types used in Jaguar
#define SNAP_2D		1		// 2-D Snap
#define SNAP_25D	2		// 2 1/2-D Snap
#define SNAP_3D		3		// 3-D Snap

// Snap modes

#define SNAPMODE_RELATIVE	0
#define SNAPMODE_ABSOLUTE	1

// Snap flags

#define SNAP_IN_3D				(0)		// Snap to all points (looks dumb here, but code reads easier)
#define SNAP_IN_PLANE			(1<<0)	// Snap only to points in plane
#define SNAP_UNSEL_OBJS_ONLY	(1<<1)	// Ignore selected nodes
#define SNAP_SEL_OBJS_ONLY		(1<<2)	// Ignore unselected nodes
#define SNAP_UNSEL_SUBOBJ_ONLY	(1<<3)	// Ignore selected geometry
#define SNAP_SEL_SUBOBJ_ONLY	(1<<4)	// Ignore unselected geometry
#define SNAP_FORCE_3D_RESULT	(1<<5)	// Override user settings to force snap in 3D
#define SNAP_OFF_PLANE			(1<<6)  // snap Only to points off the plane
#define SNAP_TRANSPARENTLY		(1<<7)  //This suppresses any display in the views

#define SNAP_APPLY_CONSTRAINTS	(1<<8)  //
#define SNAP_PROJ_XAXIS			(1<<9)  //
#define SNAP_PROJ_YAXIS			(1<<10)  //
#define SNAP_PROJ_ZAXIS			(1<<11)  //

#define SNAP_XFORM_AXIS			(1<<12)  //informs the osnapmanager to invalidate the com axis
#define SNAP_BEGIN_SEQ			(1<<13)  //
#define SNAP_END_SEQ			(1<<14)  //

// Snap information	structure
typedef struct {
	// The snap settings for this operation
	int snapType;			// See above
	int strength;			// Maximum snap distance
	int vertPriority;		// Geometry vertex priority
	int edgePriority;		// Geometry edge priority
	int gIntPriority;		// Grid intersection priority
	int gLinePriority;		// Grid line priority
	DWORD flags;			// See above
	Matrix3 plane;			// Plane to use for snap computations
	// The best snap so far...
	Point3 bestWorld;		// Best snap point in world space
	Point2 bestScreen;		// Best snap point in screen space
	int bestDist;			// Best snap point distance
	int priority;			// Best point's priority
	} SnapInfo;

#endif // _SNAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\stack3.h ===
#ifndef _STACK3_H_ 

#define _STACK3_H_

#include "matrix3.h"

#define STACK_DEPTH		32		// default stack depth

class Matrix3Stack {
public:
	DllExport Matrix3Stack();
	DllExport Matrix3Stack(int depth);
	DllExport ~Matrix3Stack();

	BOOL		replace(const Matrix3 &m)
					{ stk[index] = m; return TRUE; }
	BOOL		push(const Matrix3 &m)
					{ stk[index++] = m; return index < maxDepth; }
	BOOL		dup(void)
					{ stk[index+1] = stk[index]; return ++index < maxDepth; }
	BOOL		concat(const Matrix3 &m)
					{ stk[index] = m * stk[index]; return TRUE; }
	Matrix3	&	get(void)
					{ return stk[index]; }
	Matrix3 &	pop(void)
					{ return stk[index--]; }
	BOOL		remove(void)
					{ return --index >= 0; }
	BOOL		reset(void)
					{ index = 0; stk[0].IdentityMatrix(); return TRUE; }

private:
	int			maxDepth;
	int			index;
	Matrix3 *	stk;
};

	
#endif // _STACK3_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\stack.h ===
/**********************************************************************
 *<
	FILE: stack.h

	DESCRIPTION: Simple stack using Tab.

	CREATED BY:	Rolf Berteig

	HISTORY: Created 22 November 1994

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __STACK__
#define __STACK__

template<class T> class Stack {
	private:
		Tab<T> s;		
	
	public:		
		// access the stack indexing from the top down.
		T& operator[](const int i) const { 
			assert(s.Count()-i>0);
			return s[s.Count()-i-1];
			}

		void Push( T *el ) { 
			s.Append( 1, el ); 			
			}

		void Pop( T *el ) { 
			assert( s.Count() );	
			*el = s[s.Count()-1];
			s.Delete( s.Count()-1, 1 );			
			}

		void Pop() { 
			assert( s.Count() );				
			s.Delete( s.Count()-1, 1 );			
			}

		void GetTop( T *el ) {
			assert( s.Count() );	
			*el = s[s.Count()-1];
			}

		void Clear() {
			s.Delete(0,s.Count());			
			}

		int Count() {
			return s.Count(); 
			}

		int Remove( int i ) {
			assert(i<s.Count());
			return s.Delete(s.Count()-1-i,1);
			}
	};

#endif // __STACK__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\splshape.h ===
/**********************************************************************
 *<
	FILE: splshape.h

	DESCRIPTION:  Defines a Spline Object Class

	CREATED BY: Tom Hudson

	HISTORY: created 23 February 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#ifndef __SPLSHAPE_H__ 

#define __SPLSHAPE_H__

#include "Max.h"
#include "shape.h"
#include "istdplug.h"
#include "sbmtlapi.h"

extern CoreExport Class_ID  splineShapeClassID; 

extern HINSTANCE hInstance;

// The boolean operations
#define BOOL_UNION 0
#define BOOL_SUBTRACTION 1
#define BOOL_INTERSECTION 2

// The mirror operations
#define MIRROR_HORIZONTAL 3
#define MIRROR_VERTICAL 4
#define MIRROR_BOTH 5

// Flags used for boolean polygons
#define POLYBOOL (1 << 0)
#define POLYOUTSIDE (1 << 1)
#define POLYINSIDE (1 << 2)

// References
#define ES_MASTER_CONTROL_REF 0
#define ES_VERT_BASE_REF 1

// These are values for selLevel.
#define SS_OBJECT	0
#define SS_VERTEX	1
#define SS_SEGMENT	2
#define SS_SPLINE	3

#define CID_OUTLINE		CID_USER + 201
#define CID_SEGBREAK	CID_USER + 202
#define CID_SEGREFINE	CID_USER + 203
#define CID_VERTCONNECT	CID_USER + 204
#define CID_VERTINSERT	CID_USER + 205
#define CID_BOOLEAN		CID_USER + 206
#define CID_CREATELINE	CID_USER + 207
#define CID_CROSSINSERT	CID_USER + 208
#define CID_FILLET		CID_USER + 209
#define CID_CHAMFER		CID_USER + 210
#define CID_TRIM		CID_USER + 211
#define CID_EXTEND		CID_USER + 212

//watje
#define CID_SPLINEBIND	CID_USER + 213
#define CID_REFINECONNECT	CID_USER + 214



// General-purpose shape point table -- Maintains point table for each of n polygons
class SplineShapePointTab {
	public:
		int polys;
		int *pUsed;	// Tells whether polygon is affected
		Point3Tab *ptab;
		IntTab *ktab;
		IntTab *ltab;
		SplineShapePointTab();
		~SplineShapePointTab();
		void Empty();
		void Zero();
		void MakeCompatible(BezierShape& shape, BOOL clear=TRUE);
		SplineShapePointTab& operator=(SplineShapePointTab& from);
		BOOL IsCompatible(BezierShape &shape);
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);
	};

class SplineShapeVertexDelta {
	public:
		SplineShapePointTab dtab;

		void SetSize(BezierShape& shape, BOOL load=TRUE);
		void Empty() { dtab.Empty(); }
		void Zero() { dtab.Zero(); }
		void SetPoint(int poly, int i, const Point3& p) { dtab.pUsed[poly] = 1; dtab.ptab[poly][i] = p; }
		void SetKType(int poly, int i, int k) { dtab.pUsed[poly] = 1; dtab.ktab[poly][i] = k; }
		void SetLType(int poly, int i, int l) { dtab.pUsed[poly] = 1; dtab.ltab[poly][i] = l; }
		void Move(int poly, int i, const Point3& p) { dtab.pUsed[poly] = 1; dtab.ptab[poly][i] += p; }
		void Apply(BezierShape& shape);
		void UnApply(BezierShape& shape);
		void ClearUsed(int poly) { dtab.pUsed[poly] = 0; }
		void SetUsed(int poly) { dtab.pUsed[poly] = 1; }
		int IsUsed(int poly) { return dtab.pUsed[poly] ? 1 : 0; }
		SplineShapeVertexDelta& operator=(SplineShapeVertexDelta& from) { dtab = from.dtab; return *this; }
		void ApplyHandlesAndZero(BezierShape &shape, int handlePoly, int handleVert);
		BOOL IsCompatible(BezierShape &shape) { return dtab.IsCompatible(shape); }
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);
	};

class NamedVertSelSetList {
	public:
		Tab<ShapeVSel*> sets;
		Tab<TSTR*>	   names;

		CoreExport ~NamedVertSelSetList();
		ShapeVSel &operator[](int i) {return *sets[i];}
		int Count() {return sets.Count();}
		CoreExport void AppendSet(ShapeVSel &nset,TSTR &name);
		CoreExport BOOL DeleteSet(TSTR &name);
		CoreExport void DeleteSet(int i);
		CoreExport IOResult Load(ILoad *iload);
		CoreExport IOResult Save(ISave *isave);
		CoreExport void SetSize(BezierShape& shape);
		CoreExport NamedVertSelSetList& operator=(NamedVertSelSetList& from);
		CoreExport void DeleteSetElements(ShapeVSel &set,int m=1);
		CoreExport int FindSet(TSTR &name);
		CoreExport BOOL RenameSet(TSTR &oldName, TSTR &newName);
	};

class NamedSegSelSetList {
	public:
		Tab<ShapeSSel*> sets;
		Tab<TSTR*>	   names;

		CoreExport ~NamedSegSelSetList();
		ShapeSSel &operator[](int i) {return *sets[i];}
		int Count() {return sets.Count();}
		CoreExport void AppendSet(ShapeSSel &nset,TSTR &name);
		CoreExport BOOL DeleteSet(TSTR &name);
		CoreExport void DeleteSet(int i);
		CoreExport IOResult Load(ILoad *iload);
		CoreExport IOResult Save(ISave *isave);
		CoreExport void SetSize(BezierShape& shape);
		CoreExport NamedSegSelSetList& operator=(NamedSegSelSetList& from);
		CoreExport void DeleteSetElements(ShapeSSel &set,int m=1);
		CoreExport int FindSet(TSTR &name);
		CoreExport BOOL RenameSet(TSTR &oldName, TSTR &newName);
	};

class NamedPolySelSetList {
	public:
		Tab<ShapePSel*> sets;
		Tab<TSTR*>	   names;

		CoreExport ~NamedPolySelSetList();
		ShapePSel &operator[](int i) {return *sets[i];}
		int Count() {return sets.Count();}
		CoreExport void AppendSet(ShapePSel &nset,TSTR &name);
		CoreExport BOOL DeleteSet(TSTR &name);
		CoreExport void DeleteSet(int i);
		CoreExport IOResult Load(ILoad *iload);
		CoreExport IOResult Save(ISave *isave);
		CoreExport void SetSize(BezierShape& shape);
		CoreExport NamedPolySelSetList& operator=(NamedPolySelSetList& from);
		CoreExport void DeleteSetElements(ShapePSel &set,int m=1);
		CoreExport int FindSet(TSTR &name);
		CoreExport BOOL RenameSet(TSTR &oldName, TSTR &newName);
	};

// Named selection set list types for SplineShape
#define NS_SS_VERT 0
#define NS_SS_SEG 1
#define NS_SS_POLY 2

class SSNamedSelSetList {
	public:
		int type;
		void *ptr;
		SSNamedSelSetList(int type, void *ptr) {this->type=type; this->ptr=ptr;}
		CoreExport int Count();
		CoreExport TSTR* Names(int i);
	};

class IntersectPt;	// Internal class

class SplineShape : public ShapeObject, ISplineOps, ISplineSelect, ISplineSelectData, ISubMtlAPI, AttachMatDlgUser {
	friend BOOL CALLBACK SplineGenDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam );
	friend BOOL CALLBACK SplineSelectDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam );
	friend BOOL CALLBACK SplineOpsDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam );
	friend BOOL CALLBACK SplineSurfDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam );
	friend class SSXFormProc;
	friend class SSOutlineCMode;
	friend class SSFilletCMode;
	friend class SSChamferCMode;
	friend class SSSegBreakCMode;
	friend class SSSegRefineCMode;
	friend class SSCrossInsertCMode;
	friend class SSVertConnectCMode;
	friend class SSVertInsertCMode;
	friend class SSCreateLineCMode;
	friend class SSBooleanCMode;
	friend class SSTrimCMode;
	friend class SSExtendCMode;
	friend class SSOutlineMouseProc;
	friend class SSFilletMouseProc;
	friend class SSChamferMouseProc;
	friend class SSSegBreakMouseProc;
	friend class SSSegRefineMouseProc;
	friend class SSCrossInsertMouseProc;
	friend class SSVertConnectMouseProc;
	friend class SSVertInsertMouseProc;
	friend class SSCreateLineMouseProc;
	friend class SSBooleanMouseProc;
	friend class SSTrimMouseProc;
	friend class SSExtendMouseProc;
	friend class SplineShapeRestore;
	friend class SSRightMenu;
	friend class SSMBackspaceUser;
	friend class SSIBackspaceUser;
	friend class SSPickSplineAttach;
	friend class SSAttachHitByName;
	friend class SplineShapeClassDesc;
//watje
	friend class SSBindMouseProc;
	friend class SSBindCMode;
	friend class SSRefineConnectMouseProc;
	friend class SSRefineConnectCMode;


	private:
		static HWND hGenPanel, hSelectPanel, hOpsPanel, hSurfPanel;
		static BOOL rsGen, rsSel, rsOps, rsSurf;	// rollup states (FALSE = rolled up)
		static MoveModBoxCMode *moveMode;
		static RotateModBoxCMode *rotMode;
		static UScaleModBoxCMode *uscaleMode;
		static NUScaleModBoxCMode *nuscaleMode;
		static SquashModBoxCMode *squashMode;
		static SelectModBoxCMode *selectMode;
		static SSOutlineCMode *outlineMode;
		static SSFilletCMode *filletMode;
		static SSChamferCMode *chamferMode;
		static SSSegBreakCMode *segBreakMode;
		static SSSegRefineCMode *segRefineMode;
		static SSCrossInsertCMode *crossInsertMode;
		static SSVertConnectCMode *vertConnectMode;
		static SSVertInsertCMode *vertInsertMode;
		static SSCreateLineCMode *createLineMode;
		static SSBooleanCMode *booleanMode;
		static SSTrimCMode *trimMode;
		static SSExtendCMode *extendMode;
		static ISpinnerControl *divSpin;
		static ISpinnerControl *outlineSpin;
		static ISpinnerControl *filletSpin;
		static ISpinnerControl *chamferSpin;
		static ISpinnerControl *weldSpin;
		static ISpinnerControl *crossSpin;
		static ISpinnerControl *stepsSpin;
		static ISpinnerControl *thickSpin;
		static ISpinnerControl *matSpin;

//2-1-99 watje
		static ISpinnerControl *selectAreaSpin;

		static ICustButton *iUnion;
		static ICustButton *iSubtraction;
		static ICustButton *iIntersection;
		static ICustButton *iMirrorHorizontal;
		static ICustButton *iMirrorVertical;
		static ICustButton *iMirrorBoth;
		static BOOL inOutline;
		static BOOL inFillet;
		static BOOL inChamfer;
		static BOOL inSegBreak;
		static int boolType;
		static int mirrorType;
		static SSPickSplineAttach pickCB;
		static BOOL segUIValid;
		static int attachMat;
		static BOOL condenseMat;

		Interval geomValid;
		Interval topoValid;
		Interval selectValid;
		DWORD validBits; // for the remaining constant channels
		void CopyValidity(SplineShape *fromOb, ChannelMask channels);

		// Remembered info
		BezierShape *rememberedShape;	// NULL if using all selected verts
		int rememberedPoly;
		int rememberedIndex;
		int rememberedData;

		// Vertex insertion information
		Spline3D *insertSpline;
		BezierShape *insertShape;
		int insertPoly;
		int insertVert;
		INode *insertNode;
		Matrix3 insertTM;	// Transform for the insert node

		// Create line data
		BezierShape *createShape;
		INode *createNode;
		Matrix3 createTM;	// Transform for the create node

		// Boolean info
		int boolPoly1;
		// Transform stuff
		BOOL doingHandles;
		int handlePoly;
		int handleVert;
		// Fillet and chamfer upper limit
		float FCLimit;
		// Load reference version
		int loadRefVersion;

	protected:
		//  inherited virtual methods for Reference-management
		CoreExport RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message );
		// Special flag -- If TRUE, overrides for vertex tick display
		BOOL drawTicks;
		BOOL generalUIDisplayed;

	public:
		static IObjParam *ip;		

		BezierShape		shape;

		// Local storage of steps value -- Retains steps value when shape is adaptive
		int steps;

		BOOL showVertNumbers;
		BOOL SVNSelectedOnly;

		NamedVertSelSetList vselSet;
		NamedSegSelSetList sselSet;
		NamedPolySelSetList pselSet;		

		MasterPointControl	*masterCont;		// Master track controller
		Tab<Control*> cont;

		CoreExport SplineShape();
		CoreExport SplineShape(SplineShape &from);

		CoreExport SplineShapeInit();	// Constructor helper

		CoreExport ~SplineShape();

		CoreExport SplineShape &operator=(SplineShape &from);

		//  inherited virtual methods:

		// From BaseObject
		CoreExport virtual int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt);
		CoreExport virtual int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc);
		CoreExport virtual void Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt);
		CoreExport virtual int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
		CoreExport virtual CreateMouseCallBack* GetCreateMouseCallBack();
		CoreExport virtual RefTargetHandle Clone(RemapDir& remap = NoRemap());

		// Specialized xform for bezier handles
		CoreExport void XFormHandles( SSXFormProc *xproc, TimeValue t, Matrix3& partm, Matrix3& tmAxis );

		// Generic xform procedure.
		CoreExport void XFormVerts( SSXFormProc *xproc, TimeValue t, Matrix3& partm, Matrix3& tmAxis );

		// Affine transform methods		
		CoreExport void Move( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin=FALSE );
		CoreExport void Rotate( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Quat& val, BOOL localOrigin=FALSE );
		CoreExport void Scale( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin=FALSE );
		
		// The following is called before the first Move(), Rotate() or Scale() call
		CoreExport void TransformStart(TimeValue t);

		// The following is called after the user has completed the Move, Rotate or Scale operation and
		// the undo object has been accepted.
		CoreExport void TransformFinish(TimeValue t);		

		// The following is called when the transform operation is cancelled by a right-click and the undo
		// has been cancelled.
		CoreExport void TransformCancel(TimeValue t);		

		// From Object			 
		CoreExport ObjectState Eval(TimeValue time);
		CoreExport Interval ObjectValidity(TimeValue t);
		CoreExport void MaybeEnlargeViewportRect(GraphicsWindow *gw, Rect &rect);

		// Named selection set support:
		BOOL SupportsNamedSubSels() {return TRUE;}
		CoreExport void ActivateSubSelSet(TSTR &setName);
		CoreExport void NewSetFromCurSel(TSTR &setName);
		CoreExport void RemoveSubSelSet(TSTR &setName);
		CoreExport void SetupNamedSelDropDown();
		CoreExport int NumNamedSelSets();
		CoreExport TSTR GetNamedSelSetName(int i);
		CoreExport void SetNamedSelSetName(int i,TSTR &newName);
		CoreExport void NewSetByOperator(TSTR &newName,Tab<int> &sets,int op);
		CoreExport BOOL GetUniqueSetName(TSTR &name);
		CoreExport int SelectNamedSet();
		CoreExport void NSCopy();
		CoreExport void NSPaste();
		CoreExport SSNamedSelSetList GetSelSet();

		// The validty interval of channels necessary to do a convert to type
		CoreExport Interval ConvertValidity(TimeValue t);

		// get and set the validity interval for the nth channel
	   	CoreExport Interval ChannelValidity(TimeValue t, int nchan);
		CoreExport void SetChannelValidity(int i, Interval v);
		CoreExport void InvalidateChannels(ChannelMask channels);

		// Deformable object procs	
		int IsDeformable() { return 1; }  
		CoreExport int NumPoints();
		CoreExport Point3 GetPoint(int i);
		CoreExport void SetPoint(int i, const Point3& p);
		CoreExport BOOL IsPointSelected (int i);
		
		CoreExport void PointsWereChanged();
		CoreExport void GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm=NULL,BOOL useSel=FALSE );
		CoreExport void Deform(Deformer *defProc, int useSel);

		CoreExport int CanConvertToType(Class_ID obtype);
		CoreExport Object* ConvertToType(TimeValue t, Class_ID obtype);
		CoreExport void GetCollapseTypes(Tab<Class_ID> &clist,Tab<TSTR*> &nlist);


		CoreExport void FreeChannels(ChannelMask chan);
		CoreExport Object *MakeShallowCopy(ChannelMask channels);
		CoreExport void ShallowCopy(Object* fromOb, ChannelMask channels);
		CoreExport void NewAndCopyChannels(ChannelMask channels);

		CoreExport DWORD GetSubselState();

		// From ShapeObject
		CoreExport ObjectHandle CreateTriObjRep(TimeValue t);  // for rendering, also for deformation		
		CoreExport void GetWorldBoundBox(TimeValue t, INode *inode, ViewExp* vpt, Box3& box );
		CoreExport void GetLocalBoundBox(TimeValue t, INode *inode, ViewExp* vpt, Box3& box );
		CoreExport int NumberOfVertices(TimeValue t, int curve);
		CoreExport int NumberOfCurves();
		CoreExport BOOL CurveClosed(TimeValue t, int curve);
		CoreExport Point3 InterpCurve3D(TimeValue t, int curve, float param, int ptype=PARAM_SIMPLE);
		CoreExport Point3 TangentCurve3D(TimeValue t, int curve, float param, int ptype=PARAM_SIMPLE);
		CoreExport float LengthOfCurve(TimeValue t, int curve);
		CoreExport int NumberOfPieces(TimeValue t, int curve);
		CoreExport Point3 InterpPiece3D(TimeValue t, int curve, int piece, float param, int ptype=PARAM_SIMPLE);
		CoreExport Point3 TangentPiece3D(TimeValue t, int curve, int piece, float param, int ptype=PARAM_SIMPLE);
		CoreExport MtlID GetMatID(TimeValue t, int curve, int piece);
		BOOL CanMakeBezier() { return TRUE; }
		CoreExport void MakeBezier(TimeValue t, BezierShape &shape);
		CoreExport ShapeHierarchy &OrganizeCurves(TimeValue t, ShapeHierarchy *hier = NULL);
		CoreExport void MakePolyShape(TimeValue t, PolyShape &shape, int steps = PSHAPE_BUILTIN_STEPS, BOOL optimize = FALSE);
		CoreExport int MakeCap(TimeValue t, MeshCapInfo &capInfo, int capType);
		CoreExport int MakeCap(TimeValue t, PatchCapInfo &capInfo);

		BezierShape& GetShape() { return shape; }

		// Animatable methods

		void DeleteThis() { delete this; }
		void FreeCaches() { shape.InvalidateGeomCache(); }
		virtual Class_ID ClassID() { return splineShapeClassID; }
		CoreExport virtual void GetClassName(TSTR& s);
		CoreExport void* GetInterface(ULONG id);
		// This is the name that will appear in the history browser.
		CoreExport virtual TCHAR *GetObjectName();

		// Controller stuff for animatable points
		CoreExport int NumSubs();
		CoreExport Animatable* SubAnim(int i);
		CoreExport TSTR SubAnimName(int i);
		CoreExport BOOL AssignController(Animatable *control,int subAnim);
		int SubNumToRefNum(int subNum) {return subNum;}
		CoreExport BOOL SelectSubAnim(int subNum);

		// Reference methods
		CoreExport void RescaleWorldUnits(float f);
		CoreExport int RemapRefOnLoad(int iref);
		int NumRefs() {return cont.Count() + 1;}
		CoreExport RefTargetHandle GetReference(int i);
		CoreExport void SetReference(int i, RefTargetHandle rtarg);
		CoreExport void CreateContArray();
		CoreExport void SynchContArray();
		CoreExport void AllocContArray(int count);
		CoreExport void ReplaceContArray(Tab<Control *> &nc);
		CoreExport void InsertPointConts(int index, int count);
		CoreExport void DeletePointConts(BitArray &set);
		CoreExport void ReversePointConts(int index, int count, BOOL keepFirst);
		CoreExport void NullPointConts(int index, int count);
		CoreExport void NullPolyPointConts(int poly);
		CoreExport void PlugControllersSel(TimeValue t);
		CoreExport BOOL PlugControl(TimeValue t,int i);
		CoreExport void SetPtCont(int i, Control *c);
		CoreExport void SetPointAnim(TimeValue t, int poly, int vert, Point3 pt);
		CoreExport BOOL CloneVertCont(int from, int to);

		// Editable spline stuff follows...
		CoreExport void SetRollupPage(IObjParam *ip, BOOL creating);
		CoreExport void RemoveRollupPage(IObjParam *ip);
		CoreExport virtual void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
		CoreExport virtual void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		CoreExport int GetSubobjectLevel();
		CoreExport void SetSubobjectLevel(int level);
		CoreExport void ActivateSubobjSel(int level, XFormModes& modes );
		int NeedUseSubselButton() { return 0; }
		CoreExport void SelectSubComponent( HitRecord *hitRec, BOOL selected, BOOL all, BOOL invert );
		CoreExport void ClearSelection(int level);		
		CoreExport void SelectAll(int level);
		CoreExport void InvertSelection(int level);
		CoreExport void GetSubObjectCenters(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);
		CoreExport void GetSubObjectTMs(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);
		CoreExport int SubObjectIndex(HitRecord *hitRec);
		CoreExport void MultiAttachObject(INodeTab &nodeTab);
		CoreExport void BeginOutlineMove(TimeValue t);
		CoreExport void BeginFilletMove(TimeValue t);
		CoreExport void BeginChamferMove(TimeValue t);
		CoreExport void OutlineMove( TimeValue t, float amount );
		CoreExport void FilletMove( TimeValue t, float amount );
		CoreExport void ChamferMove( TimeValue t, float amount );
		CoreExport void EndMoveModes(TimeValue t, BOOL accept=TRUE);	// End all Moves (below)
		CoreExport void EndOutlineMove(TimeValue t,BOOL accept=TRUE);
		CoreExport void EndFilletMove(TimeValue t,BOOL accept=TRUE);
		CoreExport void EndChamferMove(TimeValue t,BOOL accept=TRUE);
		CoreExport void StartOutlineMode();
		CoreExport void StartFilletMode();
		CoreExport void StartChamferMode();
		CoreExport void DoOutline();
		CoreExport void DoFillet();
		CoreExport void DoChamfer();
		CoreExport void StartSegBreakMode();
		CoreExport void DoSegBreak(ViewExp *vpt, BezierShape *shape, int poly, int seg, IPoint2 p);
		CoreExport void StartSegRefineMode();
		CoreExport void DoSegRefine(ViewExp *vpt, BezierShape *shape, int poly, int seg, IPoint2 p);
		CoreExport void StartCrossInsertMode();
		CoreExport void DoCrossInsert(ViewExp *vpt, BezierShape *shape, int poly1, int seg1, int poly2, int seg2, IPoint2 p);
		CoreExport void StartVertConnectMode();
		CoreExport void DoVertConnect(ViewExp *vpt, BezierShape *shape, int poly1, int vert1, int poly2, int vert2);
		CoreExport void StartVertInsertMode(int controlID);
		CoreExport int StartVertInsert(ViewExp *vpt, BezierShape *shape, int poly, int seg, int vert);
		CoreExport void EndVertInsert(BOOL acceptUndo);
		CoreExport void StartCreateLineMode();
		CoreExport BOOL StartCreateLine(BezierShape **shape);
		CoreExport void EndCreateLine();
		CoreExport BOOL BooleanStartUp();
		CoreExport void StartBooleanMode();
		CoreExport void DoBoolean(int poly2);
		CoreExport void StartTrimMode();
		CoreExport void StartExtendMode();
		CoreExport void HandleTrimExtend(ViewExp *vpt, ShapeHitData *hit, IPoint2 &m, int operation);

		// from AttachMatDlgUser
		CoreExport int GetAttachMat();
		CoreExport void SetAttachMat(int value);
		CoreExport BOOL GetCondenseMat();
		CoreExport void SetCondenseMat(BOOL sw);

		CoreExport int DoAttach(INode *node, bool & canUndo);
		CoreExport void DoVertBreak();
		CoreExport void DoVertWeld();
		CoreExport void DoMakeFirst();
		CoreExport void DoVertDelete();
		CoreExport void DoSegDelete();
		CoreExport void DoSegDetach(int sameShape, int copy, int reorient);
		CoreExport void DoSegDivide(int divisions);
		CoreExport void DoPolyClose();
		CoreExport void DoPolyDetach(int copy, int reorient);
		CoreExport void DoPolyMirror(int type, int copy);
		CoreExport void DoPolyDelete();
		CoreExport void DoPolyReverse();
		CoreExport void DoPolyExplode();
		CoreExport void DoExplodeToObjects();
		CoreExport void SetBoolOperation(int type) { boolType = type; }
		CoreExport void SetMirrorOperation(int type) { mirrorType = type; }
		CoreExport int GetBoolOperation() { return boolType; }
		CoreExport int GetMirrorOperation() { return mirrorType; }
		CoreExport int GetBoolCursorID();
		CoreExport int GetBoolMirrString(int type);
		CoreExport void SetBooleanButton();
		CoreExport void SetMirrorButton();
		CoreExport void ChangeSelVerts(int type);
		CoreExport void ChangeRememberedVert(int type);
		CoreExport int RememberVertThere(HWND hWnd, IPoint2 m);
		CoreExport void SetRememberedVertType(int type);
		CoreExport void ChangeSelSegs(int type);
		CoreExport void ChangeRememberedSeg(int type);
		CoreExport int RememberSegThere(HWND hWnd, IPoint2 m);
		CoreExport void SetRememberedSegType(int type);
		CoreExport void ChangeSelPolys(int type);
		CoreExport void ChangeRememberedPoly(int type);
		CoreExport int RememberPolyThere(HWND hWnd, IPoint2 m);
		CoreExport void SetRememberedPolyType(int type);

		CoreExport void SplineShapeClone( SplineShape *source );

		// The following methods do the job and update controllers, named selections, etc.
		CoreExport void DeleteSpline(int poly);
		CoreExport void InsertSpline(Spline3D *spline, int poly);
		CoreExport void Reverse(int poly, BOOL keepFirst = FALSE);
		CoreExport void DeleteKnot(int poly, int index);
		CoreExport void AddKnot(int poly, SplineKnot &k, int where = -1);
		CoreExport BOOL Append(int poly, Spline3D *spline, BOOL weldCoincidentFirstVertex=TRUE);
		CoreExport BOOL Prepend(int poly, Spline3D *spline, BOOL weldCoincidentLastVertex=TRUE);
		CoreExport void ReplaceSpline(int poly, Spline3D *spline);
		CoreExport BOOL DeleteSelVerts(int poly);
		CoreExport BOOL DeleteSelSegs(int poly);
		CoreExport void MakeFirst(int poly, int index);

		// Support for general parameters
		CoreExport void SetOptimize(BOOL sw);
		CoreExport void SetAdaptive(BOOL sw);
		CoreExport void SetSteps(int n);
		CoreExport void SetGenUVs(BOOL sw);
		CoreExport void SetRenderable(BOOL sw);
		CoreExport void SetThickness(float t);

		// Store current topology in the BezierShape
		CoreExport void RecordTopologyTags();

		// Re-match named selection sets, etc. with changed topology (Call RecordTopologyTags
		// before making the changes to the shape, then call this)
		CoreExport void ResolveTopoChanges(BezierShape *shape = NULL);

		CoreExport void RefreshSelType();
		CoreExport void UpdateSelectDisplay();
		CoreExport void SetSelDlgEnables();
		CoreExport void SetOpsDlgEnables();
		CoreExport void SetSurfDlgEnables();
		CoreExport void SelectionChanged();
		CoreExport BOOL MaybeSelectSingleSpline(BOOL makeUndo = FALSE);	// Returns TRUE if selected
		CoreExport void SetFCLimit();

		// Materials
		CoreExport int GetSelMatIndex();
		CoreExport void SetSelMatIndex(int index);
		CoreExport void SelectByMat(int index,BOOL clear);
		CoreExport void InvalidateSurfaceUI();

		// IO
		CoreExport IOResult Save(ISave *isave);
		CoreExport IOResult Load(ILoad *iload);

//watje
		
		BOOL showVerts;
		BOOL showSelected;
		BOOL smoothRefineConnect;
		BOOL closedRefineConnect;
		BOOL bindFirst, bindLast;

//2-1-99 watje
		BOOL rConnect;
		BOOL useAreaSelect;
		float areaSelect;

//2-21-99 watje 
		SplineKnot knotPoint1, knotPoint2;


		int startSegRC, startSegSplineRC;
		int startSplineRC;
		int endSegRC, endSegSplineRC;
		int endSplineRC;
		Tab<Point3> pointList;

		static SSBindCMode *bindMode;
		static SSRefineConnectCMode *refineConnectMode;
		CoreExport void StartBindMode();
		CoreExport void DoBind(int poly1, int vert1, int poly2, int vert2);
		CoreExport void DoUnBind();
		CoreExport void DoHide();
		CoreExport void DoUnhide();
		CoreExport void DoCycleVerts();

		CoreExport void StartRefineConnectMode();
		CoreExport void EndRefineConnectMode();
		CoreExport void DoRefineConnect(ViewExp *vpt, BezierShape *shape, int poly, int seg, IPoint2 p);

//2-1-99 watje
		CoreExport void DoVertFuse();


		// spline select and operations interfaces, JBW 2/1/99
		CoreExport void StartCommandMode(splineCommandMode mode);
		CoreExport void ButtonOp(splineButtonOp opcode);

		CoreExport DWORD GetSelLevel();
		CoreExport void SetSelLevel(DWORD level);
		CoreExport void LocalDataChanged();

		CoreExport BitArray GetVertSel();
		CoreExport BitArray GetSegmentSel();
		CoreExport BitArray GetSplineSel();
		
		CoreExport void SetVertSel(BitArray &set, ISplineSelect *imod, TimeValue t);
		CoreExport void SetSegmentSel(BitArray &set, ISplineSelect *imod, TimeValue t);
		CoreExport void SetSplineSel(BitArray &set, ISplineSelect *imod, TimeValue t);

		CoreExport GenericNamedSelSetList& GetNamedVertSelList();
		CoreExport GenericNamedSelSetList& GetNamedSegmentSelList();
		CoreExport GenericNamedSelSetList& GetNamedSplineSelList();

		// ISubMtlAPI methods:
		CoreExport MtlID GetNextAvailMtlID(ModContext* mc);
		CoreExport BOOL HasFaceSelection(ModContext* mc);
		CoreExport void SetSelFaceMtlID(ModContext* mc, MtlID id, BOOL bResetUnsel = FALSE);
		CoreExport int GetSelFaceUniqueMtlID(ModContext* mc);
		CoreExport int GetSelFaceAnyMtlID(ModContext* mc);
		CoreExport int GetMaxMtlID(ModContext* mc);
	};				

class SSPickSplineAttach : 
		public PickModeCallback,
		public PickNodeCallback {
	public:		
		SplineShape *ss;
		
		SSPickSplineAttach() {ss=NULL;}

		BOOL HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);
		BOOL Pick(IObjParam *ip,ViewExp *vpt);

		void EnterMode(IObjParam *ip);
		void ExitMode(IObjParam *ip);

		HCURSOR GetHitCursor(IObjParam *ip);

		BOOL Filter(INode *node);
		
		PickNodeCallback *GetFilter() {return this;}

		BOOL RightClick(IObjParam *ip,ViewExp *vpt)	{return TRUE;}
	};

class SSOutlineTransformer : public Transformer {
 	public:
 		CoreExport Point3 Eval(ViewExp *vpt);
		SSOutlineTransformer(IObjParam *i) : Transformer(i) {}
 		};	

class SSOutlineMouseProc : public MouseCallBack {
	private:
		SSOutlineTransformer outlineTrans;
		SplineShape *ss;
		IObjParam *ip;
		Point3 p0, p1;
		IPoint2 sp0;

	public:
		SSOutlineMouseProc(SplineShape* shp, IObjParam *i)
			: outlineTrans(i) {ss=shp;ip=i;}
		int proc( 
			HWND hwnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m );
	};

class SSOutlineSelectionProcessor : public GenModSelectionProcessor {
	protected:
		HCURSOR GetTransformCursor();
		
	public:
		SSOutlineSelectionProcessor(SSOutlineMouseProc *mc, SplineShape *s, IObjParam *i) 
			: GenModSelectionProcessor(mc,s,i) {}
	};


class SSOutlineCMode : public CommandMode {
	private:
		ChangeFGObject fgProc;
		SSOutlineSelectionProcessor mouseProc;
		SSOutlineMouseProc eproc;
		SplineShape* ss;

	public:
		SSOutlineCMode(SplineShape* ss, IObjParam *i) :
			fgProc(ss), mouseProc(&eproc,ss,i), eproc(ss,i) {this->ss=ss;}

		int Class() { return MODIFY_COMMAND; }
		int ID() { return CID_OUTLINE; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints=2; return &mouseProc; }
		ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
		BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
		void EnterMode();
		void ExitMode();
	};

/*-------------------------------------------------------------------*/

class SSFilletTransformer : public Transformer {
 	public:
 		CoreExport Point3 Eval(ViewExp *vpt);
		SSFilletTransformer(IObjParam *i) : Transformer(i) {}
 		};	

class SSFilletMouseProc : public MouseCallBack {
	private:
		SSFilletTransformer filletTrans;
		SplineShape *ss;
		IObjParam *ip;
		Point3 p0, p1;
		IPoint2 sp0;

	public:
		SSFilletMouseProc(SplineShape* shp, IObjParam *i)
			: filletTrans(i) {ss=shp;ip=i;}
		int proc( 
			HWND hwnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m );
	};

class SSFilletSelectionProcessor : public GenModSelectionProcessor {
	protected:
		HCURSOR GetTransformCursor();
		
	public:
		SSFilletSelectionProcessor(SSFilletMouseProc *mc, SplineShape *s, IObjParam *i) 
			: GenModSelectionProcessor(mc,s,i) {}
	};


class SSFilletCMode : public CommandMode {
	private:
		ChangeFGObject fgProc;
		SSFilletSelectionProcessor mouseProc;
		SSFilletMouseProc eproc;
		SplineShape* ss;

	public:
		SSFilletCMode(SplineShape* ss, IObjParam *i) :
			fgProc(ss), mouseProc(&eproc,ss,i), eproc(ss,i) {this->ss=ss;}

		int Class() { return MODIFY_COMMAND; }
		int ID() { return CID_OUTLINE; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints=2; return &mouseProc; }
		ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
		BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
		void EnterMode();
		void ExitMode();
	};

/*-------------------------------------------------------------------*/

class SSChamferTransformer : public Transformer {
 	public:
 		CoreExport Point3 Eval(ViewExp *vpt);
		SSChamferTransformer(IObjParam *i) : Transformer(i) {}
 		};	

class SSChamferMouseProc : public MouseCallBack {
	private:
		SSChamferTransformer chamferTrans;
		SplineShape *ss;
		IObjParam *ip;
		Point3 p0, p1;
		IPoint2 sp0;

	public:
		SSChamferMouseProc(SplineShape* shp, IObjParam *i)
			: chamferTrans(i) {ss=shp;ip=i;}
		int proc( 
			HWND hwnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m );
	};

class SSChamferSelectionProcessor : public GenModSelectionProcessor {
	protected:
		HCURSOR GetTransformCursor();
		
	public:
		SSChamferSelectionProcessor(SSChamferMouseProc *mc, SplineShape *s, IObjParam *i) 
			: GenModSelectionProcessor(mc,s,i) {}
	};


class SSChamferCMode : public CommandMode {
	private:
		ChangeFGObject fgProc;
		SSChamferSelectionProcessor mouseProc;
		SSChamferMouseProc eproc;
		SplineShape* ss;

	public:
		SSChamferCMode(SplineShape* ss, IObjParam *i) :
			fgProc(ss), mouseProc(&eproc,ss,i), eproc(ss,i) {this->ss=ss;}

		int Class() { return MODIFY_COMMAND; }
		int ID() { return CID_OUTLINE; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints=2; return &mouseProc; }
		ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
		BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
		void EnterMode();
		void ExitMode();
	};

/*-------------------------------------------------------------------*/

class SSSegBreakTransformer : public Transformer {
 	public:
 		CoreExport Point3 Eval(ViewExp *vpt);
		SSSegBreakTransformer(IObjParam *i) : Transformer(i) {}
 		};	

class SSSegBreakMouseProc : public MouseCallBack {
	private:
		SplineShape *ss;
		IObjParam *ip;
		IPoint2 om;

	protected:
		HCURSOR GetTransformCursor();
		BOOL HitTest( ViewExp *vpt, IPoint2 *p, int type, int flags );
		BOOL AnyHits( ViewExp *vpt ) { return vpt->NumSubObjHits(); }		

	public:
		SSSegBreakMouseProc(SplineShape* spl, IObjParam *i) { ss=spl; ip=i; }
		int proc( 
			HWND hwnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m );
//		int override(int mode) { return CLICK_DOWN_POINT; }
	};

class SSSegBreakCMode : public CommandMode {
	private:
		ChangeFGObject fgProc;
		SSSegBreakMouseProc eproc;
		SplineShape* ss;

	public:
		SSSegBreakCMode(SplineShape* spl, IObjParam *i) :
			fgProc(spl), eproc(spl,i) {ss=spl;}

		int Class() { return MODIFY_COMMAND; }
		int ID() { return CID_SEGBREAK; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints=1; return &eproc; }
		ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
		BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
		void EnterMode();
		void ExitMode();
	};

/*-------------------------------------------------------------------*/

#define REFINE_VERT 0
#define REFINE_SEG 1

class SSSegRefineMouseProc : public MouseCallBack {
	private:
		SplineShape *ss;
		IObjParam *ip;
		IPoint2 om;
		int type; // See above
	
	protected:
		HCURSOR GetTransformCursor();
		BOOL HitTest( ViewExp *vpt, IPoint2 *p, int type, int flags );
		BOOL AnyHits( ViewExp *vpt ) { return vpt->NumSubObjHits(); }		

	public:
		SSSegRefineMouseProc(SplineShape* spl, IObjParam *i) { ss=spl; ip=i; }
		int proc( 
			HWND hwnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m );
		void SetType(int type) { this->type = type; }
	};

class SSSegRefineCMode : public CommandMode {
	private:
		ChangeFGObject fgProc;
		SSSegRefineMouseProc eproc;
		SplineShape* ss;
		int type; // See above

	public:
		SSSegRefineCMode(SplineShape* spl, IObjParam *i) :
			fgProc(spl), eproc(spl,i) {ss=spl;}

		int Class() { return MODIFY_COMMAND; }
		int ID() { return CID_SEGREFINE; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints=1; return &eproc; }
		ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
		BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
		void EnterMode();
		void ExitMode();
		void SetType(int type) { this->type = type; eproc.SetType(type); }
	};

/*-------------------------------------------------------------------*/

class SSCrossInsertMouseProc : public MouseCallBack {
	private:
		SplineShape *ss;
		IObjParam *ip;
		IPoint2 om;
	
	protected:
		HCURSOR GetTransformCursor();
		BOOL HitTest( ViewExp *vpt, IPoint2 *p, int type, int flags );
		BOOL AnyHits( ViewExp *vpt ) { return vpt->NumSubObjHits(); }		

	public:
		SSCrossInsertMouseProc(SplineShape* spl, IObjParam *i) { ss=spl; ip=i; }
		int proc( 
			HWND hwnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m );
	};

class SSCrossInsertCMode : public CommandMode {
	private:
		ChangeFGObject fgProc;
		SSCrossInsertMouseProc eproc;
		SplineShape* ss;

	public:
		SSCrossInsertCMode(SplineShape* spl, IObjParam *i) :
			fgProc(spl), eproc(spl,i) {ss=spl;}

		int Class() { return MODIFY_COMMAND; }
		int ID() { return CID_CROSSINSERT; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints=1; return &eproc; }
		ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
		BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
		void EnterMode();
		void ExitMode();
	};

/*-------------------------------------------------------------------*/

class SSVertConnectMouseProc : public MouseCallBack {
	private:
		SplineShape *ss;
		IObjParam *ip;
		IPoint2 om;

	protected:
		HCURSOR GetTransformCursor();
		BOOL HitTest( ViewExp *vpt, IPoint2 *p, int type, int flags );
		BOOL AnyHits( ViewExp *vpt ) { return vpt->NumSubObjHits(); }		
		BOOL HitAnEndpoint(ViewExp *vpt, IPoint2 *p, BezierShape *shape, int poly, int vert,
			BezierShape **shapeOut, int *polyOut, int *vertOut);
	public:
		SSVertConnectMouseProc(SplineShape* spl, IObjParam *i) { ss=spl; ip=i; }
		int proc( 
			HWND hwnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m );
	};

class SSVertConnectCMode : public CommandMode {
	private:
		ChangeFGObject fgProc;
		SSVertConnectMouseProc eproc;
		SplineShape* ss;

	public:
		SSVertConnectCMode(SplineShape* spl, IObjParam *i) :
			fgProc(spl), eproc(spl,i) {ss=spl;}

		int Class() { return MODIFY_COMMAND; }
		int ID() { return CID_VERTCONNECT; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints=2; return &eproc; }
		ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
		BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
		void EnterMode();
		void ExitMode();
	};

/*-------------------------------------------------------------------*/

class SSVertInsertMouseProc : public MouseCallBack {
	private:
		SplineShape *ss;
		IObjParam *ip;
		IPoint2 om;

	protected:
		HCURSOR GetTransformCursor();
		BOOL HitTest( ViewExp *vpt, IPoint2 *p, int type, int flags, int hitType );
		BOOL AnyHits( ViewExp *vpt ) { return vpt->NumSubObjHits(); }		
		BOOL InsertWhere(ViewExp *vpt, IPoint2 *p, BezierShape **shapeOut, int *polyOut,int *segOut, int *vertOut);
	public:
		SSVertInsertMouseProc(SplineShape* spl, IObjParam *i) { ss=spl; ip=i; }
		int proc( 
			HWND hwnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m );
		int override(int mode) { return CLICK_DOWN_POINT; }
	};

class SSVertInsertCMode : public CommandMode {
	private:
		ChangeFGObject fgProc;
		SSVertInsertMouseProc eproc;
		SplineShape* ss;
		int control;	// ID of the resource button
	public:
		SSVertInsertCMode(SplineShape* spl, IObjParam *i) :
			fgProc(spl), eproc(spl,i) {ss=spl; control= -1;}

		int Class() { return MODIFY_COMMAND; }
		int ID() { return CID_VERTINSERT; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints=999999; return &eproc; }
		ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
		BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
		void EnterMode();
		void ExitMode();
		void SetControl(int id) { control = id; }
	};

/*-------------------------------------------------------------------*/

class SSCreateLineMouseProc : public MouseCallBack {
	private:
		SplineShape *ss;
		IObjParam *ip;
		IPoint2 om;

	protected:
		BOOL HitTest( ViewExp *vpt, IPoint2 *p, int type, int flags, int hitType );
		BOOL AnyHits( ViewExp *vpt ) { return vpt->NumSubObjHits(); }		
		BOOL InsertWhere(ViewExp *vpt, IPoint2 *p, BezierShape **shapeOut, int *polyOut, int *vertOut);
	public:
		SSCreateLineMouseProc(SplineShape* spl, IObjParam *i) { ss=spl; ip=i; }
		int proc( 
			HWND hwnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m );
		int override(int mode) { return CLICK_DOWN_POINT; }
	};

class SSCreateLineCMode : public CommandMode {
	private:
		ChangeFGObject fgProc;
		SSCreateLineMouseProc eproc;
		SplineShape* ss;

	public:
		SSCreateLineCMode(SplineShape* spl, IObjParam *i) :
			fgProc(spl), eproc(spl,i) {ss=spl;}

		int Class() { return MODIFY_COMMAND; }
		int ID() { return CID_CREATELINE; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints=999999; return &eproc; }
		ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
		BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
		void EnterMode();
		void ExitMode();
	};

/*-------------------------------------------------------------------*/

class SSBooleanMouseProc : public MouseCallBack {
	private:
		SplineShape *ss;
		IObjParam *ip;
		IPoint2 om;

	protected:
		HCURSOR GetTransformCursor();
		BOOL HitTest( ViewExp *vpt, IPoint2 *p, int type, int flags );
		BOOL AnyHits( ViewExp *vpt ) { return vpt->NumSubObjHits(); }		
	public:
		SSBooleanMouseProc(SplineShape* spl, IObjParam *i) { ss=spl; ip=i; }
		int proc( 
			HWND hwnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m );
		int override(int mode) { return CLICK_DOWN_POINT; }
	};

class SSBooleanCMode : public CommandMode {
	private:
		ChangeFGObject fgProc;
		SSBooleanMouseProc eproc;
		SplineShape* ss;

	public:
		SSBooleanCMode(SplineShape* spl, IObjParam *i) :
			fgProc(spl), eproc(spl,i) {ss=spl;}

		int Class() { return MODIFY_COMMAND; }
		int ID() { return CID_BOOLEAN; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints=9999; return &eproc; }
		ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
		BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
		void EnterMode();
		void ExitMode();
	};

/*-------------------------------------------------------------------*/

class SSTrimMouseProc : public MouseCallBack {
	private:
		SplineShape *ss;
		IObjParam *ip;
		IPoint2 om;

	protected:
		HCURSOR GetTransformCursor();
		BOOL HitTest( ViewExp *vpt, IPoint2 *p, int type, int flags );
		BOOL AnyHits( ViewExp *vpt ) { return vpt->NumSubObjHits(); }		
	public:
		SSTrimMouseProc(SplineShape* spl, IObjParam *i) { ss=spl; ip=i; }
		int proc( 
			HWND hwnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m );
		int override(int mode) { return CLICK_DOWN_POINT; }
	};

class SSTrimCMode : public CommandMode {
	private:
		ChangeFGObject fgProc;
		SSTrimMouseProc eproc;
		SplineShape* ss;

	public:
		SSTrimCMode(SplineShape* spl, IObjParam *i) :
			fgProc(spl), eproc(spl,i) {ss=spl;}

		int Class() { return MODIFY_COMMAND; }
		int ID() { return CID_TRIM; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints=9999; return &eproc; }
		ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
		BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
		void EnterMode();
		void ExitMode();
	};

/*-------------------------------------------------------------------*/

class SSExtendMouseProc : public MouseCallBack {
	private:
		SplineShape *ss;
		IObjParam *ip;
		IPoint2 om;

	protected:
		HCURSOR GetTransformCursor();
		BOOL HitTest( ViewExp *vpt, IPoint2 *p, int type, int flags );
		BOOL AnyHits( ViewExp *vpt ) { return vpt->NumSubObjHits(); }		
	public:
		SSExtendMouseProc(SplineShape* spl, IObjParam *i) { ss=spl; ip=i; }
		int proc( 
			HWND hwnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m );
		int override(int mode) { return CLICK_DOWN_POINT; }
	};

class SSExtendCMode : public CommandMode {
	private:
		ChangeFGObject fgProc;
		SSExtendMouseProc eproc;
		SplineShape* ss;

	public:
		SSExtendCMode(SplineShape* spl, IObjParam *i) :
			fgProc(spl), eproc(spl,i) {ss=spl;}

		int Class() { return MODIFY_COMMAND; }
		int ID() { return CID_EXTEND; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints=9999; return &eproc; }
		ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
		BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
		void EnterMode();
		void ExitMode();
	};


//watje
/*-------------------------------------------------------------------*/

class SSBindMouseProc : public MouseCallBack {
	private:
		SplineShape *ss;
		IObjParam *ip;
		IPoint2 om;

	protected:
		HCURSOR GetTransformCursor();
		BOOL HitTest( ViewExp *vpt, IPoint2 *p, int type, int flags );
		BOOL HitTestSeg( ViewExp *vpt, IPoint2 *p, int type, int flags );
		BOOL AnyHits( ViewExp *vpt ) { return vpt->NumSubObjHits(); }		
		BOOL HitAnEndpoint(ViewExp *vpt, IPoint2 *p, BezierShape *shape, int poly, int vert,
			BezierShape **shapeOut, int *polyOut, int *vertOut);
		BOOL HitASegment(ViewExp *vpt, IPoint2 *p, BezierShape *shape, int poly, int vert,
			BezierShape **shapeOut, int *polyOut, int *vertOut);

	public:
		SSBindMouseProc(SplineShape* spl, IObjParam *i) { ss=spl; ip=i; }
		int proc( 
			HWND hwnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m );
	};

class SSBindCMode : public CommandMode {
	private:
		ChangeFGObject fgProc;
		SSBindMouseProc eproc;
		SplineShape* ss;

	public:
		SSBindCMode(SplineShape* spl, IObjParam *i) :
			fgProc(spl), eproc(spl,i) {ss=spl;}

		int Class() { return MODIFY_COMMAND; }
		int ID() { return CID_VERTCONNECT; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints=2; return &eproc; }
		ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
		BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
		void EnterMode();
		void ExitMode();
	};



class SSRefineConnectMouseProc : public MouseCallBack {
	private:
		SplineShape *ss;
		IObjParam *ip;
		IPoint2 om;
		int type; // See above
	
	protected:
		HCURSOR GetTransformCursor();
		BOOL HitTest( ViewExp *vpt, IPoint2 *p, int type, int flags );
		BOOL AnyHits( ViewExp *vpt ) { return vpt->NumSubObjHits(); }		

	public:
		SSRefineConnectMouseProc(SplineShape* spl, IObjParam *i) { ss=spl; ip=i; }
		int proc( 
			HWND hwnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m );
		void SetType(int type) { this->type = type; }
	};

class SSRefineConnectCMode : public CommandMode {
	private:
		ChangeFGObject fgProc;
		SSRefineConnectMouseProc eproc;
		SplineShape* ss;
		int type; // See above

	public:
		SSRefineConnectCMode(SplineShape* spl, IObjParam *i) :
			fgProc(spl), eproc(spl,i) {ss=spl;}

		int Class() { return MODIFY_COMMAND; }
		int ID() { return CID_REFINECONNECT; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints=1; return &eproc; }
		ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
		BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
		void EnterMode();
		void ExitMode();
		void SetType(int type) { this->type = type; eproc.SetType(type); }
	};



CoreExport ClassDesc* GetSplineShapeDescriptor();
CoreExport int ApplyOffset(Interface *intf, INode *node, float amount);
CoreExport int MeasureOffset(Interface *intf, INode *node, Point3 *point, float *result);

#endif // __SPLSHAPE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\stdmat.h ===
/*******************************************************************
 *
 *    DESCRIPTION: Standard materials, textures, and fog: generic interface
 *
 *    AUTHOR:  Dan Silva
 *
 *    HISTORY:   Created 3/5/96
 *					Modified for shiva 2/1/99, Kells Elmquist
 *
 *******************************************************************/

#ifndef __STDMAT__H
#define __STDMAT__H

// Shade values
#define NSHADES 	4
#define SHADE_CONST 	0
#define SHADE_PHONG 	1	
#define SHADE_METAL 	2
#define SHADE_BLINN 	3

// Transparency types
#define TRANSP_SUBTRACTIVE     	0
#define TRANSP_ADDITIVE     	1
#define TRANSP_FILTER     		2

#define NTEXMAPS 12

// Old StdMtl Texture map indices, used by blinn, phong, constant, metal
#define ID_AM 0   // ambient
#define ID_DI 1   // diffuse
#define ID_SP 2   // specular
#define ID_SH 3   // shininesNs
#define ID_SS 4   // shininess strength
#define ID_SI 5   // self-illumination
#define ID_OP 6   // opacity
#define ID_FI 7   // filter color
#define ID_BU 8   // bump 
#define ID_RL 9   // reflection
#define ID_RR 10  // refraction 
#define ID_DP 11  // displacement 

class Shader;
class Sampler;

class StdMat: public Mtl {
	public:
		virtual void SetSoften(BOOL onoff)=0;
		virtual void SetFaceMap(BOOL onoff)=0;
		virtual void SetTwoSided(BOOL onoff)=0;
		virtual void SetWire(BOOL onoff)=0;
		virtual void SetWireUnits(BOOL onOff)=0;
		virtual void SetFalloffOut(BOOL onOff)=0;  // 1: out, 0: in
		virtual void SetTransparencyType(int type)=0;
		virtual void SetAmbient(Color c, TimeValue t)=0;		
		virtual void SetDiffuse(Color c, TimeValue t)=0;		
		virtual void SetSpecular(Color c, TimeValue t)=0;
		virtual void SetFilter(Color c, TimeValue t)=0;
		virtual void SetShininess(float v, TimeValue t)=0;		
		virtual void SetShinStr(float v, TimeValue t)=0;		
		virtual void SetSelfIllum(float v, TimeValue t)=0;		

		virtual void SetOpacity(float v, TimeValue t)=0;		
		virtual void SetOpacFalloff(float v, TimeValue t)=0;		
		virtual void SetWireSize(float s, TimeValue t)=0;
		virtual void SetIOR(float v, TimeValue t)=0;
		virtual void LockAmbDiffTex(BOOL onOff)=0;

		virtual BOOL SupportsShaders(){ return FALSE; }
		
		// >>>> Sampling
		virtual void SetSamplingOn( BOOL on )=0;	
		virtual BOOL GetSamplingOn()=0;	

		// Obsolete Calls, not used in StdMat2....see shaders.h
		virtual void SetShading(int s)=0;
		virtual int  GetShading()=0;

		// texmaps, these only work for translated ID's of map channels,
		// see stdMat2 for access to std ID channels translator
		virtual void EnableMap(int id, BOOL onoff)=0;
		virtual BOOL MapEnabled(int id)=0;
		virtual void SetTexmapAmt(int id, float amt, TimeValue t)=0;
		virtual float GetTexmapAmt(int id, TimeValue t)=0;

		virtual BOOL GetSoften()=0;
		virtual BOOL GetFaceMap()=0;
		virtual BOOL GetTwoSided()=0;
		virtual BOOL GetWire()=0;
		virtual BOOL GetWireUnits()=0;
		virtual BOOL GetFalloffOut()=0;  // 1: out, 0: in
		virtual int GetTransparencyType()=0;

		virtual Color GetAmbient(TimeValue t)=0;		
		virtual Color GetDiffuse(TimeValue t)=0;		
		virtual Color GetSpecular(TimeValue t)=0;
		virtual Color GetFilter(TimeValue t)=0;
		virtual float GetShininess( TimeValue t)=0;		
		virtual float GetShinStr(TimeValue t)=0;		
		virtual float GetSelfIllum(TimeValue t)=0;		
		virtual float GetOpacity( TimeValue t)=0;		
		virtual float GetOpacFalloff(TimeValue t)=0;		
		virtual float GetWireSize(TimeValue t)=0;
		virtual float GetIOR( TimeValue t)=0;
		virtual BOOL GetAmbDiffTexLock()=0;
	};

//////////////////////////////////////////////////////////////////////////////
//
//	This is the base class for all materials that support plug-in shaders
//
class StdMat2 : public StdMat {
public:
	BOOL SupportsShaders(){ return TRUE; }

	// Shader/Material UI synchronization
	virtual BOOL  KeyAtTime(int id,TimeValue t) = 0;
	virtual int   GetMapState( int indx ) = 0; //returns 0 = no map, 1 = disable, 2 = mapon
	virtual TSTR  GetMapName( int indx ) = 0;
	virtual void  SyncADTexLock( BOOL lockOn ) = 0;

	// Shaders
	virtual BOOL SwitchShader( Class_ID id )= 0;
	virtual Shader* GetShader()= 0;
	virtual BOOL IsFaceted()= 0;
	virtual void SetFaceted( BOOL on )= 0;

	// texture channels from stdmat id's
	virtual long StdIDToChannel( long id )=0;

	// Obsolete Calls from StdMat, not used in StdMat2, except stdmtl2 provides 
	// support for translators: old shaders return correct id, all others return blinn
	virtual void SetShading(int s){}
	virtual int GetShading(){ return -1; } 

	// Samplers
	virtual BOOL SwitchSampler( Class_ID id )=0;	
	virtual Sampler * GetPixelSampler(int mtlNum, BOOL backFace)=0;
	
	// these params extend the UI approximation set in stdMat
	virtual BOOL  GetSelfIllumColorOn(int mtlNum=0, BOOL backFace=FALSE)=0;
	virtual Color GetSelfIllumColor(int mtlNum, BOOL backFace)=0;
	virtual Color GetSelfIllumColor(TimeValue t)=0; 
	virtual void SetSelfIllumColorOn( BOOL on )=0;
	virtual void SetSelfIllumColor(Color c, TimeValue t)=0;		

};


// Mapping types for SetCoordMapping
#define UVMAP_EXPLICIT   0
#define UVMAP_SPHERE_ENV 1
#define UVMAP_CYL_ENV  	 2
#define UVMAP_SHRINK_ENV 3
#define UVMAP_SCREEN_ENV 4

class StdUVGen: public UVGen {
	public:
#ifdef DESIGN_VER
		void * m_geoInfo;				// FIXME: used in the GeoReferencing system in VIZ, needs to be in a better place tho
#endif

	BOOL IsStdUVGen() { return TRUE; }  // method inherited from UVGen

	virtual void SetCoordMapping(int)=0;
	virtual void SetUOffs(float f, TimeValue t)=0;
	virtual void SetVOffs(float f, TimeValue t)=0;
	virtual void SetUScl(float f,  TimeValue t)=0;
	virtual void SetVScl(float f,  TimeValue t)=0;
	virtual void SetAng(float f,   TimeValue t)=0; // angle in radians
	virtual void SetUAng(float f,   TimeValue t)=0; // angle in radians
	virtual void SetVAng(float f,   TimeValue t)=0; // angle in radians
	virtual void SetWAng(float f,   TimeValue t)=0; // angle in radians
	virtual void SetBlur(float f,  TimeValue t)=0;
	virtual void SetBlurOffs(float f,  TimeValue t)=0; 
	virtual void SetNoiseAmt(float f,  TimeValue t)=0; 
	virtual void SetNoiseSize(float f,  TimeValue t)=0; 
	virtual void SetNoiseLev(int i,  TimeValue t)=0; 
	virtual void SetNoisePhs(float f,  TimeValue t)=0; 
	virtual void SetTextureTiling(int tiling)=0;
	virtual void SetMapChannel(int i)=0;

	virtual int  GetCoordMapping(int)=0;
	virtual float GetUOffs( TimeValue t)=0;
	virtual float GetVOffs( TimeValue t)=0;
	virtual float GetUScl(  TimeValue t)=0;
	virtual float GetVScl(  TimeValue t)=0;
	virtual float GetAng(   TimeValue t)=0; // angle in radians
	virtual float GetUAng(   TimeValue t)=0; // angle in radians
	virtual float GetVAng(   TimeValue t)=0; // angle in radians
	virtual float GetWAng(   TimeValue t)=0; // angle in radians
	virtual float GetBlur(  TimeValue t)=0;
	virtual float GetBlurOffs(  TimeValue t)=0; 
	virtual float GetNoiseAmt(  TimeValue t)=0; 
	virtual float GetNoiseSize(  TimeValue t)=0; 
	virtual int GetNoiseLev( TimeValue t)=0; 
	virtual float GetNoisePhs(  TimeValue t)=0; 
	virtual int GetTextureTiling()=0;
	virtual int GetMapChannel()=0;

	};


// Values returned by GetCoordSystem, and passed into
// SetCoordSystem
#define XYZ_COORDS 0
#define UVW_COORDS 1
#define UVW2_COORDS 2
#define XYZ_WORLD_COORDS 3

class StdXYZGen: public XYZGen {
	public:

	BOOL IsStdXYZGen() { return TRUE; }
	virtual	void SetCoordSystem(int s)=0;
	virtual void SetBlur(float f,  TimeValue t)=0;
	virtual void SetBlurOffs(float f,  TimeValue t)=0; 
	virtual void SetOffs(int axis, float f, TimeValue t)=0;
	virtual void SetScl(int axis, float f, TimeValue t)=0;
	virtual void SetAng(int axis, float f, TimeValue t)=0;

	virtual	int GetCoordSystem()=0;
	virtual float GetBlur(TimeValue t)=0;
	virtual float GetBlurOffs(TimeValue t)=0; 
	virtual float GetOffs(int axis, TimeValue t)=0;
	virtual float GetScl(int axis, TimeValue t)=0;
	virtual float GetAng(int axis, TimeValue t)=0;

	virtual void SetMapChannel(int i)=0;
	virtual int GetMapChannel()=0;
	};

#define TEXOUT_XXXXX 		1
#define TEXOUT_INVERT		2
#define TEXOUT_CLAMP   		4
#define TEXOUT_ALPHA_RGB		8
#define TEXOUT_COLOR_MAP 		16
#define TEXOUT_COLOR_MAP_RGB	32

class StdTexoutGen: public TextureOutput {
	public:

	BOOL IsStdTexoutGen() { return TRUE; }
	virtual float GetOutputLevel(TimeValue t)=0;
	virtual BOOL GetInvert()=0;
	virtual BOOL GetClamp()=0;
	virtual BOOL GetAlphaFromRGB()=0;
	virtual float GetRGBAmt( TimeValue t)=0;
	virtual float GetRGBOff( TimeValue t)=0; 
	virtual float GetOutAmt( TimeValue t)=0;
	virtual float GetBumpAmt( TimeValue t)=0;
	virtual BOOL GetFlag(ULONG f)=0;

	virtual void SetOutputLevel(TimeValue t, float v)=0;
	virtual void SetInvert(BOOL onoff)=0;
	virtual void SetClamp(BOOL onoff)=0;
	virtual void SetAlphaFromRGB(BOOL onoff)=0;
	virtual void SetRGBAmt( float f, TimeValue t)=0;
	virtual void SetRGBOff(float f, TimeValue t)=0; 
	virtual void SetOutAmt(float f, TimeValue t)=0; 
	virtual void SetBumpAmt(float f, TimeValue t)=0; 
	virtual void SetFlag(ULONG f, ULONG val)=0;
};

// Image filtering types
#define FILTER_PYR     0
#define FILTER_SAT     1
#define FILTER_NADA	   2

// Alpha source types
#define ALPHA_FILE 	0
#define ALPHA_RGB	2
#define ALPHA_NONE	3

// End conditions:
#define END_LOOP     0
#define END_PINGPONG 1
#define END_HOLD     2

class BitmapTex: public Texmap {
	public:
	virtual void SetFilterType(int ft)=0;
	virtual void SetAlphaSource(int as)=0;  
	virtual void SetEndCondition(int endcond)=0;
	virtual void SetAlphaAsMono(BOOL onoff)=0;
	virtual	void SetAlphaAsRGB(BOOL onoff)=0;
	virtual void SetPremultAlpha(BOOL onoff)=0;
	virtual void SetMapName(TCHAR *name)=0;
	virtual void SetStartTime(TimeValue t)=0;
	virtual void SetPlaybackRate(float r)=0;

	virtual int GetFilterType()=0;
	virtual int GetAlphaSource()=0;
	virtual int GetEndCondition()=0;
	virtual BOOL GetAlphaAsMono(BOOL onoff)=0;
	virtual	BOOL GetAlphaAsRGB(BOOL onoff)=0;
	virtual	BOOL GetPremultAlpha(BOOL onoff)=0;
	virtual TCHAR *GetMapName()=0;
	virtual TimeValue GetStartTime()=0;
	virtual float GetPlaybackRate()=0;

	virtual StdUVGen* GetUVGen()=0;
	virtual TextureOutput* GetTexout()=0;

	virtual Bitmap *GetBitmap(TimeValue t) { return NULL; }
//watje pops up a bitmap loader dlg
	virtual BitmapLoadDlg(){ return 0; }
//watje forces the bitmap to reload and view to be redrawn
	virtual ReloadBitmapAndUpdate(){ return 0; }

	};

class MultiMtl: public Mtl {
	public:
	virtual void SetNumSubMtls(int n)=0;
	};

class Tex3D: public Texmap {
	public:
	virtual void ReadSXPData(TCHAR *name, void *sxpdata)=0;
	};

class MultiTex: public Texmap {
	public:
	virtual void SetNumSubTexmaps(int n) {}
	virtual void SetColor(int i, Color c, TimeValue t=0){}
	};

class GradTex: public MultiTex {
	public:
	virtual StdUVGen* GetUVGen()=0;
	virtual TextureOutput* GetTexout()=0;
	virtual void SetMidPoint(float m, TimeValue t=0) {}
	};


//===============================================================================
// StdCubic
//===============================================================================
class StdCubic: public Texmap {
	public:
	virtual void SetSize(int n, TimeValue t)=0;
	virtual void SetDoNth(BOOL onoff)=0;
	virtual void SetNth(int n)=0;
	virtual void SetApplyBlur(BOOL onoff)=0;
	virtual void SetBlur(float b, TimeValue t)=0;
	virtual void SetBlurOffset(float b, TimeValue t)=0;
	virtual int GetSize(TimeValue t)=0;
	virtual BOOL GetDoNth()=0;
	virtual int GetNth()=0;
	virtual BOOL GetApplyBlur()=0;
	virtual float GetBlur(TimeValue t)=0;
	virtual float GetBlurOffset(TimeValue t)=0;
	};

//===============================================================================
// StdMirror
//===============================================================================
class StdMirror: public Texmap {
	public:
	virtual void SetDoNth(BOOL onoff)=0;
	virtual void SetNth(int n)=0;
	virtual void SetApplyBlur(BOOL onoff)=0;
	virtual void SetBlur(float b, TimeValue t)=0;
	virtual BOOL GetDoNth()=0;
	virtual int GetNth()=0;
	virtual BOOL GetApplyBlur()=0;
	virtual float GetBlur(TimeValue t)=0;
	};

//===============================================================================
// StdFog
//===============================================================================

// Fallof Types
#define FALLOFF_TOP		0
#define FALLOFF_BOTTOM	1
#define FALLOFF_NONE	2

class StdFog : public Atmospheric {
	public:
	virtual void SetColor(Color c, TimeValue t)=0;
	virtual void SetUseMap(BOOL onoff)=0;
	virtual void SetUseOpac(BOOL onoff)=0;
	virtual void SetColorMap(Texmap *tex)=0;
	virtual void SetOpacMap(Texmap *tex)=0;
	virtual void SetFogBackground(BOOL onoff)=0;
	virtual void SetType(int type)=0;  // 0:Regular, 1:Layered
	virtual void SetNear(float v, TimeValue t)=0;
	virtual void SetFar(float v, TimeValue t)=0;
	virtual void SetTop(float v, TimeValue t)=0;
	virtual void SetBottom(float v, TimeValue t)=0;
	virtual void SetDensity(float v, TimeValue t)=0;
	virtual void SetFalloffType(int tv)=0;
	virtual void SetUseNoise(BOOL onoff)=0;
	virtual void SetNoiseScale(float v, TimeValue t)=0;
	virtual void SetNoiseAngle(float v, TimeValue t)=0;
	virtual void SetNoisePhase(float v, TimeValue t)=0;

	virtual Color GetColor(TimeValue t)=0;
	virtual BOOL GetUseMap()=0;
	virtual BOOL GetUseOpac()=0;
	virtual Texmap *GetColorMap()=0;
	virtual Texmap *GetOpacMap()=0;
	virtual BOOL GetFogBackground()=0;
	virtual int GetType()=0;  // 0:Regular, 1:Layered
	virtual float GetNear(TimeValue t)=0;
	virtual float GetFar(TimeValue t)=0;
	virtual float GetTop(TimeValue t)=0;
	virtual float GetBottom(TimeValue t)=0;
	virtual float GetDensity(TimeValue t)=0;
	virtual int GetFalloffType()=0;
	virtual BOOL GetUseNoise()=0;
	virtual float GetNoiseScale( TimeValue t)=0;
	virtual float GetNoiseAngle( TimeValue t)=0;
	virtual float GetNoisePhase( TimeValue t)=0;

	};


// Subclasses of Tex3D call this on loading to register themselves
// as being able to read sxpdata for sxpName.  (name includes ".SXP")
CoreExport void RegisterSXPReader(TCHAR *sxpName, Class_ID cid);

// When importing, this is called to get a "reader" for the sxp being loaded.
CoreExport Tex3D *GetSXPReaderClass(TCHAR *sxpName);

//==========================================================================
// Create new instances of the standard materials, textures, and atmosphere
//==========================================================================
CoreExport StdMat2 *NewDefaultStdMat();
CoreExport BitmapTex *NewDefaultBitmapTex();
CoreExport MultiMtl *NewDefaultMultiMtl();
CoreExport MultiTex *NewDefaultCompositeTex();
CoreExport MultiTex *NewDefaultMixTex();
CoreExport MultiTex *NewDefaultTintTex();
CoreExport GradTex *NewDefaultGradTex();
CoreExport StdCubic *NewDefaultStdCubic();
CoreExport StdMirror *NewDefaultStdMirror();
CoreExport StdFog *NewDefaultStdFog();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\spline3d.h ===
/**********************************************************************
 *<
	FILE: spline3d.cpp

	DESCRIPTION: General-purpose 3D spline class

	CREATED BY: Tom Hudson & Dan Silva

	HISTORY: created 2/23/95
		4/16/97 TH: Converted to use relative values for bezier vectors

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#ifndef __SPLINE3D_H__

#define __SPLINE3D_H__

#include "polyshp.h"	// Need this for PolyLine class

// Parameter types for shape interpolation (Must match types in object.h)
#define PARAM_SIMPLE 0		// Parameter space based on segments
#define PARAM_NORMALIZED 1	// Parameter space normalized to curve length

// Point flags for PolyShape representation
#define BEZ_SHAPE_KNOT			(1<<0)	// It's a knot point
#define BEZ_SHAPE_INTERPOLATED	(1<<1)	// It's an interpolated point between two knots

// Line types:
#define LTYPE_CURVE 0
#define LTYPE_LINE 1

// Compound line types
#define CURVE_CURVE (LTYPE_CURVE | (LTYPE_CURVE<<2))
#define LINE_CURVE (LTYPE_LINE | (LTYPE_CURVE<<2))
#define CURVE_LINE (LTYPE_CURVE | (LTYPE_LINE<<2))
#define LINE_LINE (LTYPE_LINE | (LTYPE_LINE<<2))

// Knot types
#define KTYPE_AUTO 0
#define KTYPE_CORNER 1
#define KTYPE_BEZIER 2
#define KTYPE_BEZIER_CORNER (KTYPE_BEZIER | KTYPE_CORNER)

// Parameter types
#define PARM_UNIFORM		0
#define PARM_ARCLENGTH		1
#define PARM_CENTRIPETAL	2
#define PARM_CUSTOM			3

// The drawPhase values
#define DRAW_IDLE 0
#define DRAW_INITIAL_MOUSE_DOWN 1
#define DRAW_FREEMOVE_POINT 2
#define DRAW_FREEMOVE_POINT_MOUSE_DOWN 3	// Inserting's initial click inside spline
#define DRAW_INITIAL_BEZ_ADJ 11
#define DRAW_DRAGGING_VECTOR 22

// Parameter types for shape interpolation (Must match interpolation types in object.h)
#define SPLINE_INTERP_SIMPLE 0		// Parameter space based on segments
#define SPLINE_INTERP_NORMALIZED 1	// Parameter space normalized to curve length

class Spline3D;
class SplineKnotAssy;
class SplineKnot;			  

//
// 'aux' fields in spline are available in 3 channels:
// 0: Used in capping process
// 1: Used to track topology changes in spline editing
// 2: Available to user
//

//watje
#define SEGMENT_VISIBLE	(1<<0)


// This class has the vertex-level point information for the Spline3D class
class SplinePoint {
	friend class Spline3D;
	friend class SplineKnotAssy;
	friend class SplineKnot;

	private:
		Point3 point;
		int aux[3];
	public:
		CoreExport SplinePoint();
		CoreExport SplinePoint(Point3 &p, int a1 = -1, int a2 = -1, int a3 = -1);
		CoreExport SplinePoint& operator=(SplinePoint &fromSP);
		inline Point3& GetPoint() { return point; }
		inline int GetAux(int index) { return aux[index]; }
		inline void SetPoint(const Point3 &p) { point = p; }
		inline void SetAux(int index, int a) { aux[index] = a; }
	};

// The mat ID is stored in the HIWORD of the knot flags
#define SPLINE_MATID_SHIFT	16
#define SPLINE_MATID_MASK	0xFFFF

// This class is used for the internal storage of spline knot assemblies
// in the Spline3D class
class SplineKnotAssy {
	friend class Spline3D;
	friend class SplineKnot;

	private:
		int ktype;			// Knot type
		int ltype;			// Line type
		float du;			// Parameter value
		SplinePoint inVec;	// The in vector
		SplinePoint knot;	// The knot
		SplinePoint outVec;	// The out vector
		DWORD flags;
	public:
		CoreExport SplineKnotAssy();
		CoreExport SplineKnotAssy(int k, int l, Point3 p, Point3 in, Point3 out, int a1= -1, int a2= -1, int a3= -1, int Ia1= -1, int Ia2= -1, int Ia3= -1, int Oa1= -1, int Oa2= -1, int Oa3= -1, DWORD f=0);
		CoreExport SplineKnotAssy(int k, int l, SplinePoint p, SplinePoint in, SplinePoint out, DWORD f=0);
		CoreExport SplineKnotAssy(SplineKnot &k);
		inline	int		Ktype() { return ktype; }
		inline	void	SetKtype(int t) { ktype=t; }
		inline	int		Ltype() { return ltype; }
		inline	void	SetLtype(int t) { ltype=t; }
		inline	Point3	Knot() { return knot.point; }
		inline	void	SetKnot(const Point3 &p) { knot.point=p; }
		inline	Point3	InVec() { return inVec.point; }
		inline	void	SetInVec(const Point3 &p) { inVec.point=p; }
		inline	Point3	OutVec() { return outVec.point; }
		inline	void	SetOutVec(const Point3 &p) { outVec.point=p; }
		inline	float	GetParm() { return du; }
		inline	void	SetParm(float p) { du = p; }
		inline	MtlID	GetMatID() {return (int)((flags>>SPLINE_MATID_SHIFT)&SPLINE_MATID_MASK);}
		inline	void    SetMatID(MtlID id) {flags &= 0xFFFF; flags |= (DWORD)(id<<SPLINE_MATID_SHIFT);}
		
		// The following methods allow access as if the in/knot/out components
		// are contained vertices.  index:0=inVec 1=knot 2=outVec  which: 0=aux1 1=aux2 2=aux3
		CoreExport int	GetAux(int index, int which);
		CoreExport void	SetAux(int index, int which, int value);
		CoreExport Point3 GetVert(int index);
		CoreExport void SetVert(int index, const Point3 &p);

		inline	SplinePoint GetKnot() { return knot; }
		inline	SplinePoint GetInVec() { return inVec; }
		inline	SplinePoint GetOutVec() { return outVec; }
		inline	void SetKnot(SplinePoint &sp) { knot = sp; }
		inline	void SetInVec(SplinePoint &sp) { inVec = sp; }
		inline	void SetOutVec(SplinePoint &sp) { outVec = sp; }


//watje		
		inline	BOOL	IsHidden() {return (flags&SEGMENT_VISIBLE);}
		inline	void    Hide() { flags |= (DWORD)(SEGMENT_VISIBLE);}
		inline	void    Unhide() { flags &= (DWORD)(~SEGMENT_VISIBLE);}

	};

// This class is used by plugins to get and set knot information in the Spline3D class.
// This is primarily here for backward-compatibility with versions prior to MAXr3

class SplineKnot {
	friend class Spline3D;
	friend class SplineKnotAssy;

	int ktype;
	int ltype;
	Point3 point;
	Point3 inVec;
	Point3 outVec;
	int aux;		// Used for capping
	int aux2;		// Used to track topo changes in spline editing
	int aux3;		// User aux field
	int inAux;
	int inAux2;
	int inAux3;
	int outAux;
	int outAux2;
	int outAux3;
	DWORD flags;
public:
	CoreExport SplineKnot();
	CoreExport SplineKnot(int k, int l, Point3 p, Point3 in, Point3 out, int a1= -1, int a2= -1, int a3= -1, int Ia1= -1, int Ia2= -1, int Ia3= -1, int Oa1= -1, int Oa2= -1, int Oa3= -1, DWORD f=0);
	CoreExport SplineKnot(SplineKnotAssy &k);
	inline	int		Ktype() { return ktype; }
	inline	void	SetKtype(int t) { ktype=t; }
	inline	int		Ltype() { return ltype; }
	inline	void	SetLtype(int t) { ltype=t; }
	inline	int		Aux() { return aux; }
	inline	void	SetAux(int a) { aux=a; }
	inline	int		Aux2() { return aux2; }
	inline	void	SetAux2(int a) { aux2=a; }
	inline	int		Aux3() { return aux3; }
	inline	void	SetAux3(int a) { aux3=a; }
	inline	int		InAux() { return inAux; }
	inline	void	SetInAux(int a) { inAux=a; }
	inline	int		InAux2() { return inAux2; }
	inline	void	SetInAux2(int a) { inAux2=a; }
	inline	int		InAux3() { return inAux3; }
	inline	void	SetInAux3(int a) { inAux3=a; }
	inline	int		OutAux() { return outAux; }
	inline	void	SetOutAux(int a) { outAux=a; }
	inline	int		OutAux2() { return outAux2; }
	inline	void	SetOutAux2(int a) { outAux2=a; }
	inline	int		OutAux3() { return outAux3; }
	inline	void	SetOutAux3(int a) { outAux3=a; }
	inline	Point3	Knot() { return point; }
	inline	void	SetKnot(Point3 p) { point=p; }
	inline	Point3	InVec() { return inVec; }
	inline	void	SetInVec(Point3 p) { inVec=p; }
	inline	Point3	OutVec() { return outVec; }
	inline	void	SetOutVec(Point3 p) { outVec=p; }
	inline	MtlID	GetMatID() {return (int)((flags>>SPLINE_MATID_SHIFT)&SPLINE_MATID_MASK);}
	inline	void    SetMatID(MtlID id) {flags &= 0xFFFF; flags |= (DWORD)(id<<SPLINE_MATID_SHIFT);}

//watje
	inline	BOOL	IsHidden() {return (flags&SEGMENT_VISIBLE);}
	inline	void    Hide() { flags |= (DWORD)(SEGMENT_VISIBLE);}
	inline	void    Unhide() { flags &= (DWORD)(~SEGMENT_VISIBLE);}

	};

// Private spline flags
#define SPLINE_CLOSED	(1<<0)
#define SPLINE_ORTHOG   (1<<1)

class Spline3D {
    friend class BezierShape;
    friend class SplineShape;
private:
	static	int			splineCount;	// Number of splines in the system
			int			parmType;		// Interpolation parameter type	(needed?)
			int			knotCount;		// Number of points in spline

			int			flags;			// Private flags
			int			iCur;			// Current editing point
			int			Interact(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3* mat, IObjParam *ip=NULL );	// Handle mouse interaction
			float		cachedLength;
			BOOL		cacheValid;
			SplineKnotAssy*	knots;		// Knot assembly array
			float *		lengths;	// Cached lengths
#ifdef DESIGN_VER
public:
#endif // break encapsulation to avoid changing the API
       // used by railings - which must be modified if use of percents is modified!
      float *		percents;	// Cached length percentages
#ifdef DESIGN_VER
private:
#endif
			int			drawPhase;		// Drawing phase
			int			editMode;		// 1 if editing, 0 otherwise

			// Creation settings
			int			initialType;	// Knot type at initial click
			int			dragType;		// Knot type at drag
			
			BOOL		selfInt;		// Cached self-intersection flag
			BOOL		siCacheValid;	// Self-intersection cache valid?
			Box3		bbox;			// Cached bounding box
			BOOL		bboxValid;		// Bounding box valid?
			BOOL		paramsValid;	// Knot parameter values valid?
			BOOL		bezPointsValid;	// Bezier points valid?
			BOOL		clockwise;		// Clockwise cache
			BOOL		cwCacheValid;	// Clockwise cache valid?
			PolyLine	polyLine;		// Polyline cache
			BOOL		plineOpt;
			int			plineSteps;
			BOOL		plineCacheValid;	// Polyline cache valid?
protected:
	CoreExport		void		Allocate(int count);
	CoreExport		void		ChordParams();							// Compute chord length params
	CoreExport		void		UniformParams();						// Compute uniform params
	CoreExport		void		CentripetalParams();					// Compute centripetal params
	CoreExport		void		LinearFwd(int i);
	CoreExport		void		LinearBack(int i);
	CoreExport		void		ContinFwd(int i);
	CoreExport		void		ContinBack(int i);
	CoreExport		void		HybridPoint(int i);
	CoreExport		void		CompCornerBezPoints(int n);
	CoreExport		void		CompAdjBesselBezPoints(int i);
	CoreExport		void		BesselStart(int i);
	CoreExport		void		BesselEnd(int i);
	CoreExport		void		NaturalFwd(int i);
	CoreExport		void		NaturalBack(int i);
public:

	CoreExport		Spline3D(int itype = KTYPE_CORNER,int dtype = KTYPE_BEZIER,int ptype = PARM_UNIFORM);		// Constructor	
	CoreExport		Spline3D(Spline3D& fromSpline);
	CoreExport		~Spline3D();	// Destructor
	CoreExport		Spline3D& 	operator=(Spline3D& fromSpline);
	CoreExport		Spline3D& 	operator=(PolyLine& fromLine);
	CoreExport		void		NewSpline();
	inline			int			ParmType() { return parmType; };
	inline			int			KnotCount() { return knotCount; }						// Point (knot) count
	inline			int			Flags() { return flags; }
	CoreExport		int			Segments();												// Segment count
	inline			int			Closed() { return (flags & SPLINE_CLOSED) ? 1:0; }		// Returns closed status
	CoreExport		int			ShiftKnot(int where,int direction);						// Shove array left or right 1,
																						// starting at given point
	CoreExport		int			AddKnot(SplineKnot &k,int where = -1);					// Add a knot to the spline
	CoreExport		void		SetKnot(int i, SplineKnot &k);
	CoreExport		SplineKnot	GetKnot(int i);

	CoreExport		int			DeleteKnot(int where);									// Delete the specified knot
	CoreExport		int			Create(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3* mat, IObjParam *ip=NULL);	// Create the spline
	CoreExport		int			StartInsert(ViewExp *vpt,int msg, int point, int flags, IPoint2 theP, Matrix3* mat, int where );	// Start an insertion operation on the spline
	CoreExport		int			SetParam(int index,float param);		// Set custom param value
	CoreExport		float		GetParam(int index);					// Get param value
	inline			int			GetKnotType(int index) { return knots[index].ktype; }
	CoreExport		int			SetKnotType(int index,int type);		// Set the knot type
	inline			int			GetLineType(int index) { return knots[index].ltype; }
	CoreExport		int			SetLineType(int index,int type);		// Set the line type
	virtual			void		CustomParams() { UniformParams(); }		// Replace this as needed
	CoreExport		void		CompParams();							// Compute param values
	CoreExport		void		ComputeBezPoints();
	CoreExport		void		FindSegAndParam(float u, int ptype, int &seg, float &param);	// Find segment and parameter for whole-curve parameter
	CoreExport		void		RefineCurve(float u, int ptype=SPLINE_INTERP_SIMPLE);
	CoreExport		void		RefineSegment(int segment, float t, int ptype=SPLINE_INTERP_SIMPLE);
	CoreExport		Point2		InterpBezier(IPoint2 *bez, float t);
	CoreExport		Point3		InterpBezier3D(int segment, float t, int ptype=SPLINE_INTERP_SIMPLE);
	CoreExport		Point3		InterpCurve3D(float u, int ptype=SPLINE_INTERP_SIMPLE);
	CoreExport		Point3		TangentBezier3D(int segment, float t, int ptype=SPLINE_INTERP_SIMPLE);
	CoreExport		Point3		TangentCurve3D(float u, int ptype=SPLINE_INTERP_SIMPLE);
	CoreExport		Point3		AverageTangent(int i);
	CoreExport		void		MakeBezCont(int i);
	CoreExport		void		RedistTangents(int i, Point3 d);
	CoreExport		void		FixAdjBezTangents(int i);
	CoreExport		void		DrawCurve(GraphicsWindow *gw, Material *mtl);
	inline			void		SetEditMode(int mode) { editMode = mode ? 1:0; }
	CoreExport		int			IsAuto(int i);
	CoreExport		int			IsBezierPt(int i);
	CoreExport		int			IsCorner(int i);
	CoreExport		Point3		GetDragVector(ViewExp *vpt,IPoint2 p,int i,Matrix3* mat);
	CoreExport		int			AppendPoint(ViewExp *vpt,const Point3& p, int where = -1);
	CoreExport		int			DrawPhase() { return drawPhase; }
	CoreExport		int			GetiCur() { return iCur; }
	CoreExport		void		GetBBox(TimeValue t,  Matrix3& tm, Box3& box);
	CoreExport		IPoint2		ProjectPoint(ViewExp *vpt, Point3 fp, Matrix3 *mat);
	CoreExport		Point3		UnProjectPoint(ViewExp *vpt, IPoint2 p, Matrix3 *mat);
	CoreExport		void		Snap(GraphicsWindow *gw, SnapInfo *snap, IPoint2 *p, Matrix3 &tm);
	CoreExport		IOResult 	Save(ISave *isave);
	CoreExport		IOResult	Load(ILoad *iload);
	CoreExport		int			SetClosed(int flag = 1);
	CoreExport		int			SetOpen();
	CoreExport		void		Dump(int where);
	CoreExport 		Point3		GetInVec(int i);
	CoreExport		void		SetInVec(int i, const Point3 &p);
	CoreExport		Point3		GetRelInVec(int i);
	CoreExport		void		SetRelInVec(int i, const Point3 &p);
	CoreExport		Point3		GetKnotPoint(int i);
	CoreExport		void		SetKnotPoint(int i, const Point3 &p);
	CoreExport		Point3		GetOutVec(int i);
	CoreExport		void		SetOutVec(int i, const Point3 &p);
	CoreExport		Point3		GetRelOutVec(int i);
	CoreExport		void		SetRelOutVec(int i, const Point3 &p);
	// The following methods return absolute coords for the bezier vertices
	CoreExport		Point3		GetVert(int i);
	CoreExport		void		SetVert(int i, const Point3& p);
	inline			int			Verts() { return knotCount*3; }
	// The following methods get/set the knot aux fields based on knot index
	// These are here for backward compatibility with MAXr2
	CoreExport		int			GetAux(int knot);
	CoreExport		void		SetAux(int knot, int value);
	CoreExport		int			GetAux2(int knot);
	CoreExport		void		SetAux2(int knot, int value);
	CoreExport		int			GetAux3(int knot);
	CoreExport		void		SetAux3(int knot, int value);
	// The following methods are new to MAXr3 and get/set aux fields for in/knot/out
	// knot: knot index
	// which: 0=aux1 1=aux2 2=aux3
	CoreExport		int			GetKnotAux(int knot, int which);
	CoreExport		void		SetKnotAux(int knot, int which, int value);
	CoreExport		int			GetInAux(int knot, int which);
	CoreExport		void		SetInAux(int knot, int which, int value);
	CoreExport		int			GetOutAux(int knot, int which);
	CoreExport		void		SetOutAux(int knot, int which, int value);
	// The following methods get/set the aux fields	based on bezier vertex index
	// i: bezier vertex index
	// which: 0=aux1 1=aux2 2=aux3
	CoreExport		int			GetVertAux(int i, int which);
	CoreExport		void		SetVertAux(int i, int which, int value);
	// The following methods get/set the material ID for a spline segment
	CoreExport		MtlID		GetMatID(int seg);
	CoreExport		void		SetMatID(int seg, MtlID id);

	CoreExport		float		SplineLength();
	CoreExport		float		SegmentLength(int seg);
	CoreExport		void		Transform(Matrix3 *tm);
	CoreExport		void		Reverse(BOOL keepZero = FALSE);
	CoreExport		BOOL		Append(Spline3D *spline, BOOL weldCoincidentFirstVertex=TRUE);	// Returns TRUE if first point auto-welded
	CoreExport		BOOL		Prepend(Spline3D *spline, BOOL weldCoincidentLastVertex=TRUE);	// Returns TRUE if last point auto-welded
	CoreExport		BOOL		IsClockWise();			// 2D!
	CoreExport		BOOL		SelfIntersects();		// 2D!
	CoreExport		BOOL		IntersectsSpline(Spline3D *spline);		// 2D!
	CoreExport		BOOL		SurroundsPoint(Point2 p);	// 2D!
	CoreExport		void		MakePolyLine(PolyLine &line, int steps = -1, BOOL optimize = FALSE);
	CoreExport		void		InvalidateGeomCache();
	CoreExport		void		GetSmoothingMap(IntTab &map);
	};

#endif // __SPLINE3D_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\strclass.h ===
/**********************************************************************
 *<
	FILE: strclass.h

	DESCRIPTION:

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __STRCLASS__H
#define __STRCLASS__H


//-----------------------------------------------------------------------
// CStr: Simple char string class
//-----------------------------------------------------------------------
class CStr {
	char *buf;
	public:
		UtilExport CStr(); 
		UtilExport CStr(const char *cs);
		UtilExport CStr(const wchar_t *wcstr);
		UtilExport CStr(const CStr& ws);
		UtilExport ~CStr(); 
		UtilExport char *data();
		UtilExport const char *data() const;
		UtilExport operator char *();

		// realloc to nchars (padding with blanks)
		UtilExport void Resize(int nchars);

		UtilExport int Length() const;
		int length() const { return Length(); }
		BOOL isNull() { return Length()==0?1:0; }

		UtilExport CStr & operator=(const CStr& cs);
		UtilExport CStr & operator=(const wchar_t *wcstr);
		UtilExport CStr & operator=(const char *cs);

		// Concatenation operators.
		UtilExport CStr operator+(const CStr& cs) const;
		UtilExport CStr& operator+=(const CStr& cs); 
		CStr& Append(const CStr& cs)  { return ((*this) += cs); }
		CStr& append(const CStr& cs)  { return ((*this) += cs); }
		UtilExport CStr& remove(int pos);	// remove all chars from pos to end
		UtilExport CStr& remove(int pos, int N);	// remove N chars from pos to end

		// Substring operator
		UtilExport CStr Substr(int start, int nchars) const;
		UtilExport char& operator[](int i);
		UtilExport const char& operator[](int i) const;

		// Char search:(return -1 if not found)
		UtilExport int first(char c) const;
		UtilExport int last(char c) const;

		// Comparison
		UtilExport int operator==(const CStr &cs) const;
		UtilExport int operator<(const CStr &cs) const;
		UtilExport int operator<=(const CStr &ws) const;
		UtilExport int operator>(const CStr &ws) const;
		UtilExport int operator>=(const CStr &ws) const;

		UtilExport void toUpper();
		UtilExport void toLower();

		UtilExport int printf(const char *format, ...);
	};


//-----------------------------------------------------------------------
// WStr: Simple Wide char string class
//-----------------------------------------------------------------------
class WStr {
	wchar_t *buf;
	public:
		UtilExport WStr();
		UtilExport WStr(const char *cs);
		UtilExport WStr(const wchar_t *wcstr);
		UtilExport WStr(const WStr& ws);
		UtilExport ~WStr();
		UtilExport 	wchar_t *data();
		UtilExport 	const wchar_t *data() const;
		UtilExport operator wchar_t *();

		// realloc to nchars (padding with blanks)
		UtilExport void Resize(int nchars);
		UtilExport int Length() const;
		int length() const { return Length(); }
		BOOL isNull() { return Length()==0?1:0; }

		UtilExport WStr & operator=(const WStr& ws);
		UtilExport WStr & operator=(const wchar_t *wcstr);
		UtilExport WStr & operator=(const char *cstr);

		// Concatenation operators.
		UtilExport WStr operator+(const WStr& ws) const; 
		UtilExport WStr & operator+=(const WStr& ws); 
		WStr& Append(const WStr& ws) { return ((*this) += ws); }
		WStr& append(const WStr& ws)  { return ((*this) += ws); }
		UtilExport WStr& remove(int pos);	// remove chars from pos to end
		UtilExport WStr& remove(int pos, int N);	// remove N chars from pos to end

		// Substring operator
		UtilExport WStr Substr(int start, int nchars) const;
		wchar_t& operator[](int i) {return buf[i];}
		const wchar_t& operator[](int i) const {return buf[i];}

		// Char search:(return -1 if not found)
		UtilExport int first(wchar_t c) const;
		UtilExport int last(wchar_t c) const;

		// Comparison
		UtilExport int operator==(const WStr &ws) const;
		UtilExport int operator<(const WStr &ws) const;
		UtilExport int operator<=(const WStr &ws) const;
		UtilExport int operator>(const WStr &ws) const;
		UtilExport int operator>=(const WStr &ws) const;

		UtilExport void toUpper();
		UtilExport void toLower();
		UtilExport int printf(const wchar_t *format, ...);
	};					



#ifdef _UNICODE
#define TSTR WStr
#else
#define TSTR CStr
#endif

//--FilterList----------------------------------------------------------------------
// A class whose sole purpose is for buildingup a  filter list to passing to
// GetSaveFileName and GetOpenFileName.  It automatically puts in the imbedded nulls
// and two terminating nulls.
//	 Example:
//
//	FilterList filterList;
//	filterList.Append( _T("Jaguar files(*.jag)"));
//	filterList.Append( _T("*.jag"));
//	ofn.lpstrFilter  = filterList;
//	GetSaveFileName(&ofn)
//----------------------------------------------------------------------------------

class FilterList {
    Tab<TCHAR> buf;
	public:
		UtilExport FilterList();
		UtilExport void Append(TCHAR *name);
		UtilExport operator TCHAR *(); 
	};


/*------------------------------------------------ 
	Split filename "name" into 
	p  path
	f  filename
	e  extension 
-------------------------------------------------*/

UtilExport void SplitFilename(TSTR& name,TSTR* p, TSTR* f, TSTR* e);

/*--------------------------------------------------
Split filename "name" into 
	p  path
	f  filename.ext
-------------------------------------------------*/

UtilExport void SplitPathFile(TSTR& name,TSTR* p, TSTR* f);


/*--------------------------------------------------
Check to see if s matches the pattern in ptrn
-------------------------------------------------*/

UtilExport BOOL MatchPattern(TSTR &s, TSTR &ptrn, BOOL ignoreCase=TRUE);


//-------------------------------------------------------------------------
// A Case Sensitive "smart" alphanumeric compare that sorts things so that
// numerical suffices come out in numerical order.
//-------------------------------------------------------------------------
UtilExport int MaxAlphaNumComp(TCHAR *a, TCHAR *b);


//-------------------------------------------------------------------------
// A Case Insensitive "smart" alphanumeric compare that sorts things so that
// numerical suffices come out in numerical order.
//-------------------------------------------------------------------------
UtilExport int MaxAlphaNumCompI(TCHAR *a, TCHAR *b);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\strbasic.h ===
/*******************************************************************
 *
 *    DESCRIPTION:      Basic string definitions header file
 *
 *    AUTHOR:           Tom Hudson
 *
 *    HISTORY:          File created 9/6/94
 *
 *******************************************************************/

#ifndef _STRBASICS_
#define _STRBASICS_

#define WIN95STUFF

// To set up Jaguar to use Unicode, define _UNICODE, and don't define _MBCS
// To set up Jaguar to use multi-byte character sets, define _MBCS and 
//              don't define _UNICODE
// To set up Jaguar to use single-byte ANSI character strings, don't define
//              either _UNICODE or _MBCS

// #define _UNICODE     // turn on Unicode support

#ifndef _MBCS
#define _MBCS   // if Unicode is off, turn on multi-byte character support
#endif


#ifdef _UNICODE

#ifdef _MBCS
#undef _MBCS    // can't have both Unicode and MBCS at once -- Unicode wins
#endif
#define UNICODE
#define STRCONST L
//#define RWSTR RWWString
//#define RWTOKENIZER RWWTokenizer
// Here's a macro to get a const char * from a RWWString object -- It
// temporarily constructs a RWCString object to hold the 1-byte wide
// character string output by the toAcsii() operator.  Don't store
// this pointer!  Copy it to a new allocation, because it might go
// away.
#define NARROW(s) ((const char *)((s).toAscii()))

#else

//#define RWSTR RWCString
//#define RWTOKENIZER RWCTokenizer
//#define NARROW(s) (s)

#endif

// Bring in the generic international text header file
#include <tchar.h>

#ifdef __cplusplus

// Bring in the Rogue Wave regular and wide string classes
// These classes will help us avoid problems in dealing with strings.
// Use the RWWString class to store all strings used in Jaguar -- The
// RWWString class allows unlimited length strings, so we will avoid
// the problems of string truncation or overwriting memory.
// NOTE: No RogueWave classes should be used in plugin API's !!
//#include <rw\cstring.h>
//#include <rw\wstring.h>
 
// Simple string class, can be used in plugin API's 
#endif // __cplusplus

#endif // _STRBASICS_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\SURF_API.H ===
/**********************************************************************
 *<
    FILE: surf_api.h

    DESCRIPTION:  Provides the SDK api for NURBS surfaces

    CREATED BY: Charlie Thaeler

    HISTORY: created 15 April, 1997

 *> Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/

#ifndef SURF_API_H
#define SURF_API_H
#include "point3.h"
#include "maxtess.h"


#define EDITABLE_SURF_CLASS_ID Class_ID(0x76a11646, 0x12a822fb)
#define FITPOINT_PLANE_CLASS_ID Class_ID(0x76a11646, 0xbadbeff)
#define EDITABLE_CVCURVE_CLASS_ID Class_ID(0x76a11646, 0x12a83145)
#define EDITABLE_FPCURVE_CLASS_ID Class_ID(0x76a11646, 0x12a92143)

#define NURBS_NAME_SIZE 80


typedef unsigned long NURBSId;  // NOTE: THESE ARE NOT PERSISTANT ACROSS SESSIONS
								//       and should NOT be saved to a file.


typedef Tab<NURBSId> NURBSIdTab;
typedef Tab<BOOL> BoolTab;

enum NURBSResult {
	kNOk,
	kNInvalidObject,
	kNInvalidId,
	kNInvalidParameter,
	kNBad
};

enum NURBSMirrorAxis {
	kMirrorX,
	kMirrorY,
	kMirrorZ,
	kMirrorXY,
	kMirrorXZ,
	kMirrorYZ
};

enum NURBSConstType {
	kNConstOnObject,
	kNConstOffset,
	kNConstNormal,
	kNConstTangent
};

enum NURBSKind {
	kNURBSPoint,
	kNURBSTexturePoint,
	kNURBSCV,
	kNURBSCurve,
	kNURBSSurface
};

enum NURBSParamaterization {
    kCentripetal,
	kUniform,
};

enum NURBSAutoParam {
	kNotAutomatic,
    kAutoCentripetal,
	kAutoUniform,
};

enum NURBSType {
	kNPoint,
	kNPointCPoint, // constrained points
	kNCurveCPoint,
	kNCurveCurveIntersectionPoint,
	kNSurfaceCPoint,
	kNCurveSurfaceIntersectionPoint,
	kNTexturePoint,

	kNCV,

	kNCVCurve,
	kNPointCurve,
	kNBlendCurve,
	kNOffsetCurve,
	kNXFormCurve,
	kNMirrorCurve,
	kNFilletCurve,
	kNChamferCurve,
	kNIsoCurve,
	kNProjectVectorCurve,
	kNProjectNormalCurve,
	kNSurfSurfIntersectionCurve,
	kNCurveOnSurface,
	kNPointCurveOnSurface,
	kNSurfaceNormalCurve,
	kNSurfaceEdgeCurve,

	kNCVSurface,
	kNPointSurface,
	kNBlendSurface,
	kNOffsetSurface,
	kNXFormSurface,
	kNMirrorSurface,
	kNRuledSurface,
	kNULoftSurface,
	kNExtrudeSurface,
	kNLatheSurface,
	kNUVLoftSurface,
	kNNBlendSurface,
	kN1RailSweepSurface,
	kN2RailSweepSurface,
	kNCapSurface,
	kNMultiCurveTrimSurface,
	kNFilletSurface
};


enum NURBSTessType {
	kNTessSurface,
	kNTessDisplacement,
	kNTessCurve
};

enum NURBSSubObjectLevel {
    kNTopLevel = 0,
    kNSurfaceCVLevel,
    kNSurfaceLevel,
    kNCurveCVLevel,
    kNPointLevel,
    kNCurveLevel,
    kNImportsLevel,
};



class NURBSSet;

typedef Tab<NURBSId> NURBSIdTab;

extern int FindIndex(NURBSIdTab ids, NURBSId id);

class NURBSObject {
	friend class NURBSSet;
protected:
	TCHAR mName[NURBS_NAME_SIZE];
	NURBSType mType;
	NURBSKind mKind;
	NURBSId mId;
	Object *mpObject;
	NURBSSet* mpNSet;
	BOOL mSelected;
	DllExport void Clean(NURBSIdTab ids);
public:
	DllExport NURBSObject(void);
	DllExport virtual ~NURBSObject(void);
	DllExport NURBSObject & operator=(const NURBSObject& pt);
	DllExport void SetName(TCHAR *name);
	DllExport TCHAR *GetName(void);
	DllExport NURBSType GetType();
	DllExport NURBSKind GetKind();
	DllExport NURBSId GetId();
	DllExport void SetId(NURBSId id);
	DllExport void SetNSet(NURBSSet *nset);
	DllExport void SetObject(Object *object);
	DllExport Object* GetMAXObject();
	DllExport NURBSSet* GetNSet();
	DllExport int GetIndex();
	DllExport BOOL IsSelected();
	DllExport void SetSelected(BOOL set);
};


class NURBSPoint : public NURBSObject {
protected:
	double mX, mY, mZ;
public:
	DllExport NURBSPoint();
	DllExport virtual Point3 GetPosition(TimeValue t);
	DllExport virtual void GetPosition(TimeValue t, float& x, float& y, float& z);
	DllExport virtual void GetPosition(TimeValue t, double& x, double& y, double& z);
};

class NURBSTexturePoint : public NURBSObject {
protected:
	double mX, mY;
    int    mUIndex, mVIndex;
public:
	DllExport NURBSTexturePoint();
	DllExport virtual Point2 GetPosition(TimeValue t);
	DllExport virtual void GetPosition(TimeValue t, float& x, float& y);
	DllExport virtual void GetPosition(TimeValue t, double& x, double& y);
	DllExport void SetPosition(TimeValue t, Point2 pt);
	DllExport void SetPosition(TimeValue t, float x, float y);
	DllExport void SetPosition(TimeValue t, double x, double y);

    DllExport void SetIndices(int uIndex, int vIndex);
};


class NURBSIndependentPoint : public NURBSPoint {
public:
	DllExport NURBSIndependentPoint(void);
	DllExport virtual ~NURBSIndependentPoint(void);
	DllExport NURBSIndependentPoint & operator=(const NURBSIndependentPoint& pt);
	DllExport BOOL operator==(const NURBSIndependentPoint& pt);
	DllExport BOOL operator!=(const NURBSIndependentPoint& pt);
	DllExport void SetPosition(TimeValue t, Point3 pt);
	DllExport void SetPosition(TimeValue t, float x, float y, float z);
	DllExport void SetPosition(TimeValue t, double x, double y, double z);

};


class NURBSControlVertex : public NURBSObject {
	double mX, mY, mZ;
	double mW;  // weight
public:
	DllExport NURBSControlVertex(void);
	DllExport virtual ~NURBSControlVertex(void);
	DllExport NURBSControlVertex & operator=(const NURBSControlVertex& cv);
	DllExport BOOL operator==(const NURBSControlVertex& cv);
	DllExport BOOL operator!=(const NURBSControlVertex& cv);
	DllExport void SetPosition(TimeValue t, Point3 pt);
	DllExport void SetPosition(TimeValue t, float x, float y, float z);
	DllExport void SetPosition(TimeValue t, double x, double y, double z);
	DllExport Point3 GetPosition(TimeValue t);
	DllExport void GetPosition(TimeValue t, float& x, float& y, float& z);
	DllExport void GetPosition(TimeValue t, double& x, double& y, double& z);
	DllExport void SetWeight(TimeValue t, float wt);
	DllExport void SetWeight(TimeValue t, double wt);
	DllExport void GetWeight(TimeValue t, float& wt);
	DllExport double GetWeight(TimeValue t);
	DllExport void GetWeight(TimeValue t, double& wt);
};


class NURBSPointConstPoint : public NURBSPoint {
	friend class NURBSSet;
protected:
	NURBSId mParentId;
	int mParentIndex;
	NURBSConstType mCType;
	Point3 mOffset;
	DllExport void Clean(NURBSIdTab ids);

public:
	DllExport NURBSPointConstPoint(void);
	DllExport virtual ~NURBSPointConstPoint(void);
	DllExport NURBSPointConstPoint & operator=(const NURBSPointConstPoint& pt);
	DllExport void SetParent(int index);
	DllExport void SetParentId(NURBSId id);
	DllExport int GetParent(void);
	DllExport NURBSId GetParentId(void);
	DllExport void SetPointType(NURBSConstType type);
	DllExport NURBSConstType GetPointType(void);
	DllExport void SetOffset(TimeValue t, Point3 pt);
	DllExport Point3 GetOffset(TimeValue t);
};

class NURBSCurveConstPoint : public NURBSPoint {
	friend class NURBSSet;
protected:
	NURBSId mParentId;
	int mParentIndex;
	NURBSConstType mCType;
	Point3 mOffset;
	float mNormal;
	float mUTangent;
	double mUParam;
    BOOL mTrimCurve;
    BOOL mFlipTrim;

	DllExport void Clean(NURBSIdTab ids);
public:
	DllExport NURBSCurveConstPoint(void);
	DllExport virtual ~NURBSCurveConstPoint(void);
	DllExport NURBSCurveConstPoint & operator=(const NURBSCurveConstPoint& pt);
	DllExport void SetParent(int index);
	DllExport void SetParentId(NURBSId id);
	DllExport int GetParent(void);
	DllExport NURBSId GetParentId(void);
	DllExport void SetPointType(NURBSConstType type);
	DllExport NURBSConstType GetPointType(void);
	DllExport void SetOffset(TimeValue t, Point3 pt);
	DllExport Point3 GetOffset(TimeValue t);
	DllExport void SetUParam(TimeValue t, double param);
	DllExport double GetUParam(TimeValue t);
	DllExport void SetNormal(TimeValue t, float dist);
	DllExport float GetNormal(TimeValue t);
	DllExport void SetUTangent(TimeValue t, float dist);
	DllExport float GetUTangent(TimeValue t);
    DllExport BOOL GetTrimCurve();
    DllExport void SetTrimCurve(BOOL trim);
    DllExport BOOL GetFlipTrim();
    DllExport void SetFlipTrim(BOOL flip);
};

class NURBSCurveCurveIntersectionPoint : public NURBSPoint {
	friend class NURBSSet;
protected:
	NURBSId mParentId[2];
	int mParentIndex[2];
    double mCurveParam[2];
    BOOL mTrimCurve[2];
    BOOL mFlipTrim[2];

	DllExport void Clean(NURBSIdTab ids);
public:
	DllExport NURBSCurveCurveIntersectionPoint(void);
	DllExport virtual ~NURBSCurveCurveIntersectionPoint(void);
	DllExport NURBSCurveCurveIntersectionPoint & operator=(const NURBSCurveCurveIntersectionPoint &pt);
    DllExport void SetCurveParam(int curveNum, double param);
    DllExport double GetCurveParam(int curveNum);
	DllExport void SetParent(int pnum, int index);
	DllExport void SetParentId(int pnum, NURBSId id);
	DllExport int GetParent(int pnum);
	DllExport NURBSId GetParentId(int pnum);

    DllExport BOOL GetTrimCurve(int pnum);
    DllExport void SetTrimCurve(int pnum, BOOL trim);
    DllExport BOOL GetFlipTrim(int pnum);
    DllExport void SetFlipTrim(int pnum, BOOL flip);
};

class NURBSSurfConstPoint : public NURBSPoint {
	friend class NURBSSet;
protected:
	NURBSId mParentId;
	int mParentIndex;
	NURBSConstType mCType;
	Point3 mOffset;
	float mNormal;
	float mUTangent;
	double mUParam;
	float mVTangent;
	double mVParam;
	DllExport void Clean(NURBSIdTab ids);
public:
	DllExport NURBSSurfConstPoint(void);
	DllExport virtual ~NURBSSurfConstPoint(void);
	DllExport NURBSSurfConstPoint & operator=(const NURBSSurfConstPoint& pt);
	DllExport void SetParent(int index);
	DllExport void SetParentId(NURBSId id);
	DllExport int GetParent(void);
	DllExport NURBSId GetParentId(void);
	DllExport void SetPointType(NURBSConstType type);
	DllExport NURBSConstType GetPointType(void);
	DllExport void SetUParam(TimeValue t, double param);
	DllExport double GetUParam(TimeValue t);
	DllExport void SetVParam(TimeValue t, double param);
	DllExport double GetVParam(TimeValue t);
	DllExport void SetOffset(TimeValue t, Point3 pt);
	DllExport Point3 GetOffset(TimeValue t);
	DllExport void SetNormal(TimeValue t, float dist);
	DllExport float GetNormal(TimeValue t);
	DllExport void SetUTangent(TimeValue t, float dist);
	DllExport float GetUTangent(TimeValue t);
	DllExport void SetVTangent(TimeValue t, float dist);
	DllExport float GetVTangent(TimeValue t);
};

class NURBSCurveSurfaceIntersectionPoint : public NURBSPoint {
	friend class NURBSSet;
protected:
	// parent 0 should be the surface parent 1 should be the curve
	NURBSId mParentId[2];
	int mParentIndex[2];
	double mSeed;
    BOOL mTrimCurve;
    BOOL mFlipTrim;

	DllExport void Clean(NURBSIdTab ids);
public:
	DllExport NURBSCurveSurfaceIntersectionPoint(void);
	DllExport virtual ~NURBSCurveSurfaceIntersectionPoint(void);
	DllExport NURBSCurveSurfaceIntersectionPoint & operator=(const NURBSCurveSurfaceIntersectionPoint &pt);
    DllExport void SetSeed(double seed);
    DllExport double GetSeed();
	DllExport void SetParent(int pnum, int index);
	DllExport void SetParentId(int pnum, NURBSId id);
	DllExport int GetParent(int pnum);
	DllExport NURBSId GetParentId(int pnum);

    DllExport BOOL GetTrimCurve();
    DllExport void SetTrimCurve(BOOL trim);
    DllExport BOOL GetFlipTrim();
    DllExport void SetFlipTrim(BOOL flip);
};





typedef Tab<NURBSControlVertex> NURBSCVTab;
typedef Tab<double> NURBSKnotTab;



enum NURBSTrimDirection // defines the side to Keep
{
    kNone = 0,
    kPositive = 1,
    kNegative = 2
};


class NURBSTrimPoint {
public:
    DllExport NURBSTrimPoint(double parameter, NURBSTrimDirection direction) :
        mParameter(parameter), mDirection(direction) {}
    DllExport double GetParameter() {return mParameter; }
    DllExport NURBSTrimDirection GetDirection() {return mDirection; }

private:
    double mParameter;
    NURBSTrimDirection mDirection;
};



class NURBSCurve : public NURBSObject {
protected:
	friend class NURBSCVCurve;
	friend class NURBSPointCurve;
	friend class NURBSBlendCurve;
	friend class NURBSOffsetCurve;
	friend class NURBSXFormCurve;
	friend class NURBSMirrorCurve;
	friend class NURBSFilletCurve;
	friend class NURBSChamferCurve;
	friend class NURBSIsoCurve;
	friend class NURBSSurfaceEdgeCurve;
	friend class NURBSProjectVectorCurve;
	friend class NURBSProjectNormalCurve;
	friend class NURBSSurfaceNormalCurve;
	friend class NURBSNBlendSurface;
	friend class NURBSRuledSurface;
	friend class NURBSULoftSurface;
	friend class NURBSUVLoftSurface;
	friend class NURBSExtrudeSurface;
	friend class NURBSLatheSurface;
	friend class NURBSCapSurface;
	friend class NURBS1RailSweepSurface;
	friend class NURBS2RailSweepSurface;
	friend class NURBSMultiCurveTrimSurface;

	int mMatID;

public:
	DllExport NURBSCurve(void);
	DllExport virtual ~NURBSCurve(void);
	DllExport NURBSCurve & operator=(const NURBSCurve& curve);
	DllExport BOOL IsClosed(void);

    DllExport int NumTrimPoints();
    DllExport NURBSTrimPoint GetTrimPoint(TimeValue t, int i);
    
	DllExport BOOL Evaluate(TimeValue t, double u, Point3& pt, Point3& tangent);
	DllExport void GetParameterRange(TimeValue t, double& uMin, double& uMax);
	DllExport BOOL GetNURBSData(TimeValue t,
								int& degree,
								int& numCVs,
								NURBSCVTab& cvs,
								int& numKnots,
								NURBSKnotTab& knots);
	DllExport int MatID();
	DllExport void MatID(int id);
};


class NURBSCVCurve : public NURBSCurve {
	friend class NURBSSet;
protected:
	NURBSControlVertex *mpCVs;
	double *mpKnots;
	BOOL mClosed;
	int mOrder;
	int mNumKnots;
	int mNumCVs;
	NURBSAutoParam mAutoParam;
public:
	DllExport NURBSCVCurve(void);
	DllExport virtual ~NURBSCVCurve(void);
	DllExport NURBSCVCurve & operator=(const NURBSCVCurve& curve);
	DllExport void Close(void);
	DllExport BOOL IsClosed(void);

	DllExport void SetOrder(int order);
	DllExport int GetOrder(void);
	DllExport void SetNumKnots(int num);         // data is NOT maintained
	DllExport int GetNumKnots(void);
	DllExport void SetNumCVs(int num);           // data is NOT maintained
	DllExport void GetNumCVs(int& num);
	DllExport int GetNumCVs(void);
	DllExport double GetKnot(int index);
	DllExport void SetKnot(int index, double value);
	DllExport NURBSControlVertex* GetCV(int index);
	DllExport void SetCV(int index, NURBSControlVertex &cv);
	DllExport void SetTransformMatrix(TimeValue t, SetXFormPacket& xPack);
	DllExport Matrix3 GetTransformMatrix(TimeValue t);
	DllExport NURBSAutoParam AutoParam();
	DllExport void AutoParam(TimeValue t, NURBSAutoParam param);
	DllExport void Reparameterize(TimeValue t, NURBSParamaterization param);

	DllExport void EndsOverlap(BOOL& overlap);
	DllExport void Refine(TimeValue t, double u); // looses animation
	DllExport void Insert(TimeValue t, double u);
};


class NURBSPointCurve : public NURBSCurve {
	friend class NURBSSet;
protected:
	NURBSIndependentPoint *mpPts;
	BOOL mClosed;
	int mNumPts;
public:
	DllExport NURBSPointCurve(void);
	DllExport virtual ~NURBSPointCurve(void);
	DllExport NURBSPointCurve & operator=(const NURBSPointCurve& curve);
	DllExport void Close(void);
	DllExport BOOL IsClosed(void);

	DllExport void SetNumPts(int num);       // data is NOT maintained
	DllExport int GetNumPts(void);
	DllExport void GetNumPts(int &num);
	DllExport NURBSIndependentPoint* GetPoint(int index);
	DllExport void SetPoint(int index, NURBSIndependentPoint &pt);
	DllExport void SetTransformMatrix(TimeValue t, SetXFormPacket& xPack);
	DllExport Matrix3 GetTransformMatrix(TimeValue t);
	DllExport void Refine(TimeValue t, double u); // looses animation
};


class NURBSBlendCurve : public NURBSCurve {
	friend class NURBSSet;
	NURBSId mParentId[2];
	int mParentIndex[2];
	BOOL mParentEnd[2];
	double mTension[2];
	DllExport void Clean(NURBSIdTab ids);
public:
	DllExport NURBSBlendCurve(void);
	DllExport virtual ~NURBSBlendCurve(void);
	DllExport NURBSBlendCurve & operator=(const NURBSBlendCurve& curve);
	DllExport void SetParent(int pnum, int index);
	DllExport void SetParentId(int pnum, NURBSId id);
	DllExport int GetParent(int pnum);
	DllExport NURBSId GetParentId(int pnum);
	DllExport void SetEnd(int pnum, BOOL end);
	DllExport BOOL GetEnd(int pnum);
	DllExport void SetTension(TimeValue t, int pnum, double ten);
	DllExport double GetTension(TimeValue t, int pnum);
};


class NURBSOffsetCurve : public NURBSCurve {
	friend class NURBSSet;
	NURBSId mParentId;
	int mParentIndex;
	double mDistance;
	DllExport void Clean(NURBSIdTab ids);
public:
	DllExport NURBSOffsetCurve(void);
	DllExport virtual ~NURBSOffsetCurve(void);
	DllExport NURBSOffsetCurve & operator=(const NURBSOffsetCurve& curve);
	DllExport void SetParent(int index);
	DllExport void SetParentId(NURBSId id);
	DllExport int GetParent(void);
	DllExport NURBSId GetParentId(void);
	DllExport void SetDistance(TimeValue t, double d);
	DllExport double GetDistance(TimeValue t);
};

class NURBSXFormCurve : public NURBSCurve {
	friend class NURBSSet;
	NURBSId mParentId;
	int mParentIndex;
	Matrix3 mXForm;
	DllExport void Clean(NURBSIdTab ids);
public:
	DllExport NURBSXFormCurve(void);
	DllExport virtual ~NURBSXFormCur