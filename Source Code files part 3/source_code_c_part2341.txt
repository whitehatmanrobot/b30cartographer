STATUS ProtocolStatus
    );


NTSTATUS
NTAPI
LsaDeregisterLogonProcess (
    IN HANDLE LsaHandle
    );

NTSTATUS
NTAPI
LsaConnectUntrusted (
    OUT PHANDLE LsaHandle
    );

#endif // _NTLSA_IFS_


////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Local Security Policy Administration API datatypes and defines         //
//                                                                        //
////////////////////////////////////////////////////////////////////////////

//
// Access types for the Policy object
//

#define POLICY_VIEW_LOCAL_INFORMATION              0x00000001L
#define POLICY_VIEW_AUDIT_INFORMATION              0x00000002L
#define POLICY_GET_PRIVATE_INFORMATION             0x00000004L
#define POLICY_TRUST_ADMIN                         0x00000008L
#define POLICY_CREATE_ACCOUNT                      0x00000010L
#define POLICY_CREATE_SECRET                       0x00000020L
#define POLICY_CREATE_PRIVILEGE                    0x00000040L
#define POLICY_SET_DEFAULT_QUOTA_LIMITS            0x00000080L
#define POLICY_SET_AUDIT_REQUIREMENTS              0x00000100L
#define POLICY_AUDIT_LOG_ADMIN                     0x00000200L
#define POLICY_SERVER_ADMIN                        0x00000400L
#define POLICY_LOOKUP_NAMES                        0x00000800L
#define POLICY_NOTIFICATION                        0x00001000L

#define POLICY_ALL_ACCESS     (STANDARD_RIGHTS_REQUIRED         |\
                               POLICY_VIEW_LOCAL_INFORMATION    |\
                               POLICY_VIEW_AUDIT_INFORMATION    |\
                               POLICY_GET_PRIVATE_INFORMATION   |\
                               POLICY_TRUST_ADMIN               |\
                               POLICY_CREATE_ACCOUNT            |\
                               POLICY_CREATE_SECRET             |\
                               POLICY_CREATE_PRIVILEGE          |\
                               POLICY_SET_DEFAULT_QUOTA_LIMITS  |\
                               POLICY_SET_AUDIT_REQUIREMENTS    |\
                               POLICY_AUDIT_LOG_ADMIN           |\
                               POLICY_SERVER_ADMIN              |\
                               POLICY_LOOKUP_NAMES)


#define POLICY_READ           (STANDARD_RIGHTS_READ             |\
                               POLICY_VIEW_AUDIT_INFORMATION    |\
                               POLICY_GET_PRIVATE_INFORMATION)

#define POLICY_WRITE          (STANDARD_RIGHTS_WRITE            |\
                               POLICY_TRUST_ADMIN               |\
                               POLICY_CREATE_ACCOUNT            |\
                               POLICY_CREATE_SECRET             |\
                               POLICY_CREATE_PRIVILEGE          |\
                               POLICY_SET_DEFAULT_QUOTA_LIMITS  |\
                               POLICY_SET_AUDIT_REQUIREMENTS    |\
                               POLICY_AUDIT_LOG_ADMIN           |\
                               POLICY_SERVER_ADMIN)

#define POLICY_EXECUTE        (STANDARD_RIGHTS_EXECUTE          |\
                               POLICY_VIEW_LOCAL_INFORMATION    |\
                               POLICY_LOOKUP_NAMES)


//
// Policy object specific data types.
//

//
// The following data type is used to identify a domain
//

typedef struct _LSA_TRUST_INFORMATION {

    LSA_UNICODE_STRING Name;
    PSID Sid;

} LSA_TRUST_INFORMATION, *PLSA_TRUST_INFORMATION;

// where members have the following usage:
//
//     Name - The name of the domain.
//
//     Sid - A pointer to the Sid of the Domain
//

//
// The following data type is used in name and SID lookup services to
// describe the domains referenced in the lookup operation.
//

typedef struct _LSA_REFERENCED_DOMAIN_LIST {

    ULONG Entries;
    PLSA_TRUST_INFORMATION Domains;

} LSA_REFERENCED_DOMAIN_LIST, *PLSA_REFERENCED_DOMAIN_LIST;

// where members have the following usage:
//
//     Entries - Is a count of the number of domains described in the
//         Domains array.
//
//     Domains - Is a pointer to an array of Entries LSA_TRUST_INFORMATION data
//         structures.
//


//
// The following data type is used in name to SID lookup services to describe
// the domains referenced in the lookup operation.
//

typedef struct _LSA_TRANSLATED_SID {

    SID_NAME_USE Use;
    ULONG RelativeId;
    LONG DomainIndex;

} LSA_TRANSLATED_SID, *PLSA_TRANSLATED_SID;

// where members have the following usage:
//
//     Use - identifies the use of the SID.  If this value is SidUnknown or
//         SidInvalid, then the remainder of the record is not set and
//         should be ignored.
//
//     RelativeId - Contains the relative ID of the translated SID.  The
//         remainder of the SID (the prefix) is obtained using the
//         DomainIndex field.
//
//     DomainIndex - Is the index of an entry in a related
//         LSA_REFERENCED_DOMAIN_LIST data structure describing the
//         domain in which the account was found.
//
//         If there is no corresponding reference domain for an entry, then
//         this field will contain a negative value.
//


//
// The following data type is used in SID to name lookup services to
// describe the domains referenced in the lookup operation.
//

typedef struct _LSA_TRANSLATED_NAME {

    SID_NAME_USE Use;
    LSA_UNICODE_STRING Name;
    LONG DomainIndex;

} LSA_TRANSLATED_NAME, *PLSA_TRANSLATED_NAME;

// where the members have the following usage:
//
//     Use - Identifies the use of the name.  If this value is SidUnknown
//         or SidInvalid, then the remainder of the record is not set and
//         should be ignored.  If this value is SidWellKnownGroup then the
//         Name field is invalid, but the DomainIndex field is not.
//
//     Name - Contains the isolated name of the translated SID.
//
//     DomainIndex - Is the index of an entry in a related
//         LSA_REFERENCED_DOMAIN_LIST data structure describing the domain
//         in which the account was found.
//
//         If there is no corresponding reference domain for an entry, then
//         this field will contain a negative value.
//


//
// The following data type is used to represent the role of the LSA
// server (primary or backup).
//

typedef enum _POLICY_LSA_SERVER_ROLE {

    PolicyServerRoleBackup = 2,
    PolicyServerRolePrimary

} POLICY_LSA_SERVER_ROLE, *PPOLICY_LSA_SERVER_ROLE;


//
// The following data type is used to represent the state of the LSA
// server (enabled or disabled).  Some operations may only be performed on
// an enabled LSA server.
//

typedef enum _POLICY_SERVER_ENABLE_STATE {

    PolicyServerEnabled = 2,
    PolicyServerDisabled

} POLICY_SERVER_ENABLE_STATE, *PPOLICY_SERVER_ENABLE_STATE;


//
// The following data type is used to specify the auditing options for
// an Audit Event Type.
//

typedef ULONG POLICY_AUDIT_EVENT_OPTIONS, *PPOLICY_AUDIT_EVENT_OPTIONS;

// where the following flags can be set:
//
//     POLICY_AUDIT_EVENT_UNCHANGED - Leave existing auditing options
//         unchanged for events of this type.  This flag is only used for
//         set operations.  If this flag is set, then all other flags
//         are ignored.
//
//     POLICY_AUDIT_EVENT_NONE - Cancel all auditing options for events
//         of this type.  If this flag is set, the success/failure flags
//         are ignored.
//
//     POLICY_AUDIT_EVENT_SUCCESS - When auditing is enabled, audit all
//         successful occurrences of events of the given type.
//
//     POLICY_AUDIT_EVENT_FAILURE - When auditing is enabled, audit all
//         unsuccessful occurrences of events of the given type.
//




//
// The following data type defines the classes of Policy Information
// that may be queried/set.
//

typedef enum _POLICY_INFORMATION_CLASS {

    PolicyAuditLogInformation = 1,
    PolicyAuditEventsInformation,
    PolicyPrimaryDomainInformation,
    PolicyPdAccountInformation,
    PolicyAccountDomainInformation,
    PolicyLsaServerRoleInformation,
    PolicyReplicaSourceInformation,
    PolicyDefaultQuotaInformation,
    PolicyModificationInformation,
    PolicyAuditFullSetInformation,
    PolicyAuditFullQueryInformation,
    PolicyDnsDomainInformation

} POLICY_INFORMATION_CLASS, *PPOLICY_INFORMATION_CLASS;


//
// The following data type corresponds to the PolicyAuditLogInformation
// information class.  It is used to represent information relating to
// the Audit Log.
//
// This structure may be used in both query and set operations.  However,
// when used in set operations, some fields are ignored.
//

typedef struct _POLICY_AUDIT_LOG_INFO {

    ULONG AuditLogPercentFull;
    ULONG MaximumLogSize;
    LARGE_INTEGER AuditRetentionPeriod;
    BOOLEAN AuditLogFullShutdownInProgress;
    LARGE_INTEGER TimeToShutdown;
    ULONG NextAuditRecordId;

} POLICY_AUDIT_LOG_INFO, *PPOLICY_AUDIT_LOG_INFO;

// where the members have the following usage:
//
//     AuditLogPercentFull - Indicates the percentage of the Audit Log
//         currently being used.
//
//     MaximumLogSize - Specifies the maximum size of the Audit Log in
//         kilobytes.
//
//     AuditRetentionPeriod - Indicates the length of time that Audit
//         Records are to be retained.  Audit Records are discardable
//         if their timestamp predates the current time minus the
//         retention period.
//
//     AuditLogFullShutdownInProgress - Indicates whether or not a system
//         shutdown is being initiated due to the security Audit Log becoming
//         full.  This condition will only occur if the system is configured
//         to shutdown when the log becomes full.
//
//         TRUE indicates that a shutdown is in progress
//         FALSE indicates that a shutdown is not in progress.
//
//         Once a shutdown has been initiated, this flag will be set to
//         TRUE.  If an administrator is able to currect the situation
//         before the shutdown becomes irreversible, then this flag will
//         be reset to false.
//
//         This field is ignored for set operations.
//
//     TimeToShutdown - If the AuditLogFullShutdownInProgress flag is set,
//         then this field contains the time left before the shutdown
//         becomes irreversible.
//
//         This field is ignored for set operations.
//


//
// The following data type corresponds to the PolicyAuditEventsInformation
// information class.  It is used to represent information relating to
// the audit requirements.
//

typedef struct _POLICY_AUDIT_EVENTS_INFO {

    BOOLEAN AuditingMode;
    PPOLICY_AUDIT_EVENT_OPTIONS EventAuditingOptions;
    ULONG MaximumAuditEventCount;

} POLICY_AUDIT_EVENTS_INFO, *PPOLICY_AUDIT_EVENTS_INFO;

// where the members have the following usage:
//
//     AuditingMode - A Boolean variable specifying the Auditing Mode value.
//         This value is interpreted as follows:
//
//         TRUE - Auditing is to be enabled (set operations) or is enabled
//             (query operations).  Audit Records will be generated according
//             to the Event Auditing Options in effect (see the
//             EventAuditingOptions field.
//
//         FALSE - Auditing is to be disabled (set operations) or is
//             disabled (query operations).  No Audit Records will be
//             generated.  Note that for set operations the Event Auditing
//             Options in effect will still be updated as specified by the
//             EventAuditingOptions field whether Auditing is enabled or
//             disabled.
//
//    EventAuditingOptions - Pointer to an array of Auditing Options
//        indexed by Audit Event Type.
//
//    MaximumAuditEventCount - Specifiesa count of the number of Audit
//        Event Types specified by the EventAuditingOptions parameter.  If
//        this count is less than the number of Audit Event Types supported
//        by the system, the Auditing Options for Event Types with IDs
//        higher than (MaximumAuditEventCount + 1) are left unchanged.
//


//
// The following structure corresponds to the PolicyAccountDomainInformation
// information class.
//

typedef struct _POLICY_ACCOUNT_DOMAIN_INFO {

    LSA_UNICODE_STRING DomainName;
    PSID DomainSid;

} POLICY_ACCOUNT_DOMAIN_INFO, *PPOLICY_ACCOUNT_DOMAIN_INFO;

// where the members have the following usage:
//
//     DomainName - Is the name of the domain
//
//     DomainSid - Is the Sid of the domain
//


//
// The following structure corresponds to the PolicyPrimaryDomainInformation
// information class.
//

typedef struct _POLICY_PRIMARY_DOMAIN_INFO {

    LSA_UNICODE_STRING Name;
    PSID Sid;

} POLICY_PRIMARY_DOMAIN_INFO, *PPOLICY_PRIMARY_DOMAIN_INFO;

// where the members have the following usage:
//
//     Name - Is the name of the domain
//
//     Sid - Is the Sid of the domain
//


//
// The following structure corresponds to the PolicyDnsDomainInformation
// information class
//

typedef struct _POLICY_DNS_DOMAIN_INFO
{
    LSA_UNICODE_STRING Name;
    LSA_UNICODE_STRING DnsDomainName;
    LSA_UNICODE_STRING DnsForestName;
    GUID DomainGuid;
    PSID Sid;

} POLICY_DNS_DOMAIN_INFO, *PPOLICY_DNS_DOMAIN_INFO;

// where the members have the following usage:
//
//      Name - Is the name of the Domain
//
//      DnsDomainName - Is the DNS name of the domain
//
//      DnsForestName - Is the DNS forest name of the domain
//
//      DomainGuid - Is the GUID of the domain
//
//      Sid - Is the Sid of the domain


//
// The following structure corresponds to the PolicyPdAccountInformation
// information class.  This structure may be used in Query operations
// only.
//

typedef struct _POLICY_PD_ACCOUNT_INFO {

    LSA_UNICODE_STRING Name;

} POLICY_PD_ACCOUNT_INFO, *PPOLICY_PD_ACCOUNT_INFO;

// where the members have the following usage:
//
//     Name - Is the name of an account in the domain that should be used
//         for authentication and name/ID lookup requests.
//


//
// The following structure corresponds to the PolicyLsaServerRoleInformation
// information class.
//

typedef struct _POLICY_LSA_SERVER_ROLE_INFO {

    POLICY_LSA_SERVER_ROLE LsaServerRole;

} POLICY_LSA_SERVER_ROLE_INFO, *PPOLICY_LSA_SERVER_ROLE_INFO;

// where the fields have the following usage:
//
// TBS
//


//
// The following structure corresponds to the PolicyReplicaSourceInformation
// information class.
//

typedef struct _POLICY_REPLICA_SOURCE_INFO {

    LSA_UNICODE_STRING ReplicaSource;
    LSA_UNICODE_STRING ReplicaAccountName;

} POLICY_REPLICA_SOURCE_INFO, *PPOLICY_REPLICA_SOURCE_INFO;


//
// The following structure corresponds to the PolicyDefaultQuotaInformation
// information class.
//

typedef struct _POLICY_DEFAULT_QUOTA_INFO {

    QUOTA_LIMITS QuotaLimits;

} POLICY_DEFAULT_QUOTA_INFO, *PPOLICY_DEFAULT_QUOTA_INFO;


//
// The following structure corresponds to the PolicyModificationInformation
// information class.
//

typedef struct _POLICY_MODIFICATION_INFO {

    LARGE_INTEGER ModifiedId;
    LARGE_INTEGER DatabaseCreationTime;

} POLICY_MODIFICATION_INFO, *PPOLICY_MODIFICATION_INFO;

// where the members have the following usage:
//
//     ModifiedId - Is a 64-bit unsigned integer that is incremented each
//         time anything in the LSA database is modified.  This value is
//         only modified on Primary Domain Controllers.
//
//     DatabaseCreationTime - Is the date/time that the LSA Database was
//         created.  On Backup Domain Controllers, this value is replicated
//         from the Primary Domain Controller.
//

//
// The following structure type corresponds to the PolicyAuditFullSetInformation
// Information Class.
//

typedef struct _POLICY_AUDIT_FULL_SET_INFO {

    BOOLEAN ShutDownOnFull;

} POLICY_AUDIT_FULL_SET_INFO, *PPOLICY_AUDIT_FULL_SET_INFO;

//
// The following structure type corresponds to the PolicyAuditFullQueryInformation
// Information Class.
//

typedef struct _POLICY_AUDIT_FULL_QUERY_INFO {

    BOOLEAN ShutDownOnFull;
    BOOLEAN LogIsFull;

} POLICY_AUDIT_FULL_QUERY_INFO, *PPOLICY_AUDIT_FULL_QUERY_INFO;

//
// The following data type defines the classes of Policy Information
// that may be queried/set that has domain wide effect.
//

typedef enum _POLICY_DOMAIN_INFORMATION_CLASS {

    PolicyDomainQualityOfServiceInformation = 1,
    PolicyDomainEfsInformation,
    PolicyDomainKerberosTicketInformation

} POLICY_DOMAIN_INFORMATION_CLASS, *PPOLICY_DOMAIN_INFORMATION_CLASS;


//
// QualityOfService information.  Corresponds to PolicyDomainQualityOfServiceInformation
//

#define POLICY_QOS_SCHANNEL_REQUIRED            0x00000001
#define POLICY_QOS_OUTBOUND_INTEGRITY           0x00000002
#define POLICY_QOS_OUTBOUND_CONFIDENTIALITY     0x00000004
#define POLICY_QOS_INBOUND_INTEGRITY            0x00000008
#define POLICY_QOS_INBOUND_CONFIDENTIALITY      0x00000010
#define POLICY_QOS_ALLOW_LOCAL_ROOT_CERT_STORE  0x00000020
#define POLICY_QOS_RAS_SERVER_ALLOWED           0x00000040
#define POLICY_QOS_DHCP_SERVER_ALLOWED          0x00000080

//
// Bits 0x00000100 through 0xFFFFFFFF are reserved for future use.
//
typedef struct _POLICY_DOMAIN_QUALITY_OF_SERVICE_INFO {

    ULONG QualityOfService;

} POLICY_DOMAIN_QUALITY_OF_SERVICE_INFO, *PPOLICY_DOMAIN_QUALITY_OF_SERVICE_INFO;
//
// where the members have the following usage:
//
//  QualityOfService - Determines what specific QOS actions a machine should take
//


//
// The following structure corresponds to the PolicyEfsInformation
// information class
//

typedef struct _POLICY_DOMAIN_EFS_INFO {

    ULONG   InfoLength;
    PUCHAR  EfsBlob;

} POLICY_DOMAIN_EFS_INFO, *PPOLICY_DOMAIN_EFS_INFO;

// where the members have the following usage:
//
//      InfoLength - Length of the EFS Information blob
//
//      EfsBlob - Efs blob data
//


//
// The following structure corresponds to the PolicyDomainKerberosTicketInformation
// information class

#define POLICY_KERBEROS_VALIDATE_CLIENT 0x00000080


typedef struct _POLICY_DOMAIN_KERBEROS_TICKET_INFO {

    ULONG AuthenticationOptions;
    LARGE_INTEGER MaxServiceTicketAge;
    LARGE_INTEGER MaxTicketAge;
    LARGE_INTEGER MaxRenewAge;
    LARGE_INTEGER MaxClockSkew;
    LARGE_INTEGER Reserved;
} POLICY_DOMAIN_KERBEROS_TICKET_INFO, *PPOLICY_DOMAIN_KERBEROS_TICKET_INFO;

//
// where the members have the following usage
//
//      AuthenticationOptions -- allowed ticket options (POLICY_KERBEROS_* flags )
//
//      MaxServiceTicketAge   -- Maximum lifetime for a service ticket
//
//      MaxTicketAge -- Maximum lifetime for the initial ticket
//
//      MaxRenewAge -- Maximum cumulative age a renewable ticket can be with
//                     requring authentication
//
//      MaxClockSkew -- Maximum tolerance for synchronization of computer clocks
//
//      Reserved   --  Reserved


//
// The following data type defines the classes of Policy Information / Policy Domain Information
// that may be used to request notification
//

typedef enum _POLICY_NOTIFICATION_INFORMATION_CLASS {

    PolicyNotifyAuditEventsInformation = 1,
    PolicyNotifyAccountDomainInformation,
    PolicyNotifyServerRoleInformation,
    PolicyNotifyDnsDomainInformation,
    PolicyNotifyDomainEfsInformation,
    PolicyNotifyDomainKerberosTicketInformation,
    PolicyNotifyMachineAccountPasswordInformation

} POLICY_NOTIFICATION_INFORMATION_CLASS, *PPOLICY_NOTIFICATION_INFORMATION_CLASS;


//
// LSA RPC Context Handle (Opaque form).  Note that a Context Handle is
// always a pointer type unlike regular handles.
//

typedef PVOID LSA_HANDLE, *PLSA_HANDLE;


//
// Trusted Domain Object specific data types
//

//
// This data type defines the following information classes that may be
// queried or set.
//

typedef enum _TRUSTED_INFORMATION_CLASS {

    TrustedDomainNameInformation = 1,
    TrustedControllersInformation,
    TrustedPosixOffsetInformation,
    TrustedPasswordInformation,
    TrustedDomainInformationBasic,
    TrustedDomainInformationEx,
    TrustedDomainAuthInformation,
    TrustedDomainFullInformation,
    TrustedDomainAuthInformationInternal,
    TrustedDomainFullInformationInternal

} TRUSTED_INFORMATION_CLASS, *PTRUSTED_INFORMATION_CLASS;

//
// The following data type corresponds to the TrustedDomainNameInformation
// information class.
//

typedef struct _TRUSTED_DOMAIN_NAME_INFO {

    LSA_UNICODE_STRING Name;

} TRUSTED_DOMAIN_NAME_INFO, *PTRUSTED_DOMAIN_NAME_INFO;

// where members have the following meaning:
//
// Name - The name of the Trusted Domain.
//

//
// The following data type corresponds to the TrustedControllersInformation
// information class.
//

typedef struct _TRUSTED_CONTROLLERS_INFO {

    ULONG Entries;
    PLSA_UNICODE_STRING Names;

} TRUSTED_CONTROLLERS_INFO, *PTRUSTED_CONTROLLERS_INFO;

// where members have the following meaning:
//
// Entries - Indicate how mamy entries there are in the Names array.
//
// Names - Pointer to an array of LSA_UNICODE_STRING structures containing the
//     names of domain controllers of the domain.  This information may not
//     be accurate and should be used only as a hint.  The order of this
//     list is considered significant and will be maintained.
//
//     By convention, the first name in this list is assumed to be the
//     Primary Domain Controller of the domain.  If the Primary Domain
//     Controller is not known, the first name should be set to the NULL
//     string.
//


//
// The following data type corresponds to the TrustedPosixOffsetInformation
// information class.
//

typedef struct _TRUSTED_POSIX_OFFSET_INFO {

    ULONG Offset;

} TRUSTED_POSIX_OFFSET_INFO, *PTRUSTED_POSIX_OFFSET_INFO;

// where members have the following meaning:
//
// Offset - Is an offset to use for the generation of Posix user and group
//     IDs from SIDs.  The Posix ID corresponding to any particular SID is
//     generated by adding the RID of that SID to the Offset of the SID's
//     corresponding TrustedDomain object.
//

//
// The following data type corresponds to the TrustedPasswordInformation
// information class.
//

typedef struct _TRUSTED_PASSWORD_INFO {
    LSA_UNICODE_STRING Password;
    LSA_UNICODE_STRING OldPassword;
} TRUSTED_PASSWORD_INFO, *PTRUSTED_PASSWORD_INFO;


typedef  LSA_TRUST_INFORMATION TRUSTED_DOMAIN_INFORMATION_BASIC;

typedef PLSA_TRUST_INFORMATION PTRUSTED_DOMAIN_INFORMATION_BASIC;

//
// Direction of the trust
//
#define TRUST_DIRECTION_DISABLED        0x00000000
#define TRUST_DIRECTION_INBOUND         0x00000001
#define TRUST_DIRECTION_OUTBOUND        0x00000002
#define TRUST_DIRECTION_BIDIRECTIONAL   (TRUST_DIRECTION_INBOUND | TRUST_DIRECTION_OUTBOUND)

#define TRUST_TYPE_DOWNLEVEL            0x00000001  // NT4 and before
#define TRUST_TYPE_UPLEVEL              0x00000002  // NT5
#define TRUST_TYPE_MIT                  0x00000003  // Trust with a MIT Kerberos realm
#define TRUST_TYPE_DCE                  0x00000004  // Trust with a DCE realm
// Levels 0x5 - 0x000FFFFF reserved for future use
// Provider specific trust levels are from 0x00100000 to 0xFFF00000

#define TRUST_ATTRIBUTE_NON_TRANSITIVE  0x00000001  // Disallow transitivity
#define TRUST_ATTRIBUTE_UPLEVEL_ONLY    0x00000002  // Trust link only valid
                                                    // for uplevel client
#define TRUST_ATTRIBUTE_TREE_PARENT     0x00400000  // Denotes that we are setting the trust
                                                    // to our parent in the org tree...
#define TRUST_ATTRIBUTE_TREE_ROOT       0x00800000  // Denotes that we are setting the trust
                                                    // to another tree root in a forest...
// Trust attributes 0x00000004 through 0x004FFFFF reserved for future use
// Trust attributes 0x00F00000 through 0x00400000 are reserved for internal use
// Trust attributes 0x01000000 through 0xFF000000 are reserved for user
// defined values
#define TRUST_ATTRIBUTES_VALID  0xFF02FFFF
#define TRUST_ATTRIBUTES_USER   0xFF000000


typedef struct _TRUSTED_DOMAIN_INFORMATION_EX {

    LSA_UNICODE_STRING Name;
    LSA_UNICODE_STRING FlatName;
    PSID  Sid;
    ULONG TrustDirection;
    ULONG TrustType;
    ULONG TrustAttributes;

} TRUSTED_DOMAIN_INFORMATION_EX, *PTRUSTED_DOMAIN_INFORMATION_EX;

//
// Type of authentication information
//
#define TRUST_AUTH_TYPE_NONE    0   // Ignore this entry
#define TRUST_AUTH_TYPE_NT4OWF  1   // NT4 OWF password
#define TRUST_AUTH_TYPE_CLEAR   2   // Cleartext password
#define TRUST_AUTH_TYPE_VERSION 3   // Cleartext password version number

typedef struct _LSA_AUTH_INFORMATION {

    LARGE_INTEGER LastUpdateTime;
    ULONG AuthType;
    ULONG AuthInfoLength;
    PUCHAR AuthInfo;
} LSA_AUTH_INFORMATION, *PLSA_AUTH_INFORMATION;

typedef struct _TRUSTED_DOMAIN_AUTH_INFORMATION {

    ULONG IncomingAuthInfos;
    PLSA_AUTH_INFORMATION   IncomingAuthenticationInformation;
    PLSA_AUTH_INFORMATION   IncomingPreviousAuthenticationInformation;
    ULONG OutgoingAuthInfos;
    PLSA_AUTH_INFORMATION   OutgoingAuthenticationInformation;
    PLSA_AUTH_INFORMATION   OutgoingPreviousAuthenticationInformation;

} TRUSTED_DOMAIN_AUTH_INFORMATION, *PTRUSTED_DOMAIN_AUTH_INFORMATION;

typedef struct _TRUSTED_DOMAIN_FULL_INFORMATION {

    TRUSTED_DOMAIN_INFORMATION_EX   Information;
    TRUSTED_POSIX_OFFSET_INFO       PosixOffset;
    TRUSTED_DOMAIN_AUTH_INFORMATION AuthInformation;

} TRUSTED_DOMAIN_FULL_INFORMATION, *PTRUSTED_DOMAIN_FULL_INFORMATION;



//
// LSA Enumeration Context
//

typedef ULONG LSA_ENUMERATION_HANDLE, *PLSA_ENUMERATION_HANDLE;

//
// LSA Enumeration Information
//

typedef struct _LSA_ENUMERATION_INFORMATION {

    PSID Sid;

} LSA_ENUMERATION_INFORMATION, *PLSA_ENUMERATION_INFORMATION;


////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Local Security Policy - Miscellaneous API function prototypes          //
//                                                                        //
////////////////////////////////////////////////////////////////////////////


NTSTATUS
NTAPI
LsaFreeMemory(
    IN PVOID Buffer
    );

NTSTATUS
NTAPI
LsaClose(
    IN LSA_HANDLE ObjectHandle
    );

NTSTATUS
NTAPI
LsaOpenPolicy(
    IN PLSA_UNICODE_STRING SystemName OPTIONAL,
    IN PLSA_OBJECT_ATTRIBUTES ObjectAttributes,
    IN ACCESS_MASK DesiredAccess,
    IN OUT PLSA_HANDLE PolicyHandle
    );

NTSTATUS
NTAPI
LsaQueryInformationPolicy(
    IN LSA_HANDLE PolicyHandle,
    IN POLICY_INFORMATION_CLASS InformationClass,
    OUT PVOID *Buffer
    );

NTSTATUS
NTAPI
LsaSetInformationPolicy(
    IN LSA_HANDLE PolicyHandle,
    IN POLICY_INFORMATION_CLASS InformationClass,
    IN PVOID Buffer
    );

NTSTATUS
NTAPI
LsaQueryDomainInformationPolicy(
    IN LSA_HANDLE PolicyHandle,
    IN POLICY_DOMAIN_INFORMATION_CLASS InformationClass,
    OUT PVOID *Buffer
    );

NTSTATUS
NTAPI
LsaSetDomainInformationPolicy(
    IN LSA_HANDLE PolicyHandle,
    IN POLICY_DOMAIN_INFORMATION_CLASS InformationClass,
    IN PVOID Buffer
    );


NTSTATUS
NTAPI
LsaRegisterPolicyChangeNotification(
    IN POLICY_NOTIFICATION_INFORMATION_CLASS InformationClass,
    IN HANDLE  NotificationEventHandle
    );

NTSTATUS
NTAPI
LsaUnregisterPolicyChangeNotification(
    IN POLICY_NOTIFICATION_INFORMATION_CLASS InformationClass,
    IN HANDLE  NotificationEventHandle
    );



NTSTATUS
NTAPI
LsaEnumerateTrustedDomains(
    IN LSA_HANDLE PolicyHandle,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    OUT PVOID *Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
    );


NTSTATUS
NTAPI
LsaLookupNames(
    IN LSA_HANDLE PolicyHandle,
    IN ULONG Count,
    IN PLSA_UNICODE_STRING Names,
    OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    OUT PLSA_TRANSLATED_SID *Sids
    );

NTSTATUS
NTAPI
LsaLookupSids(
    IN LSA_HANDLE PolicyHandle,
    IN ULONG Count,
    IN PSID *Sids,
    OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    OUT PLSA_TRANSLATED_NAME *Names
    );



#define SE_INTERACTIVE_LOGON_NAME           TEXT("SeInteractiveLogonRight")
#define SE_NETWORK_LOGON_NAME               TEXT("SeNetworkLogonRight")
#define SE_BATCH_LOGON_NAME                 TEXT("SeBatchLogonRight")
#define SE_SERVICE_LOGON_NAME               TEXT("SeServiceLogonRight")
#define SE_DENY_INTERACTIVE_LOGON_NAME      TEXT("SeDenyInteractiveLogonRight")
#define SE_DENY_NETWORK_LOGON_NAME          TEXT("SeDenyNetworkLogonRight")
#define SE_DENY_BATCH_LOGON_NAME            TEXT("SeDenyBatchLogonRight")
#define SE_DENY_SERVICE_LOGON_NAME          TEXT("SeDenyServiceLogonRight")

//
// This new API returns all the accounts with a certain privilege
//

NTSTATUS
NTAPI
LsaEnumerateAccountsWithUserRight(
    IN LSA_HANDLE PolicyHandle,
    IN OPTIONAL PLSA_UNICODE_STRING UserRights,
    OUT PVOID *EnumerationBuffer,
    OUT PULONG CountReturned
    );

//
// These new APIs differ by taking a SID instead of requiring the caller
// to open the account first and passing in an account handle
//

NTSTATUS
NTAPI
LsaEnumerateAccountRights(
    IN LSA_HANDLE PolicyHandle,
    IN PSID AccountSid,
    OUT PLSA_UNICODE_STRING *UserRights,
    OUT PULONG CountOfRights
    );

NTSTATUS
NTAPI
LsaAddAccountRights(
    IN LSA_HANDLE PolicyHandle,
    IN PSID AccountSid,
    IN PLSA_UNICODE_STRING UserRights,
    IN ULONG CountOfRights
    );

NTSTATUS
NTAPI
LsaRemoveAccountRights(
    IN LSA_HANDLE PolicyHandle,
    IN PSID AccountSid,
    IN BOOLEAN AllRights,
    IN PLSA_UNICODE_STRING UserRights,
    IN ULONG CountOfRights
    );


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Local Security Policy - Trusted Domain Object API function prototypes     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
LsaOpenTrustedDomainByName(
    IN LSA_HANDLE PolicyHandle,
    IN PLSA_UNICODE_STRING TrustedDomainName,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSA_HANDLE TrustedDomainHandle
    );


NTSTATUS
NTAPI
LsaQueryTrustedDomainInfo(
    IN LSA_HANDLE PolicyHandle,
    IN PSID TrustedDomainSid,
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    OUT PVOID *Buffer
    );

NTSTATUS
NTAPI
LsaSetTrustedDomainInformation(
    IN LSA_HANDLE PolicyHandle,
    IN PSID TrustedDomainSid,
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    IN PVOID Buffer
    );

NTSTATUS
NTAPI
LsaDeleteTrustedDomain(
    IN LSA_HANDLE PolicyHandle,
    IN PSID TrustedDomainSid
    );

NTSTATUS
NTAPI
LsaQueryTrustedDomainInfoByName(
    IN LSA_HANDLE PolicyHandle,
    IN PLSA_UNICODE_STRING TrustedDomainName,
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    OUT PVOID *Buffer
    );

NTSTATUS
NTAPI
LsaSetTrustedDomainInfoByName(
    IN LSA_HANDLE PolicyHandle,
    IN PLSA_UNICODE_STRING TrustedDomainName,
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    IN PVOID Buffer
    );

NTSTATUS
NTAPI
LsaEnumerateTrustedDomainsEx(
    IN LSA_HANDLE PolicyHandle,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    OUT PVOID *Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
    );

NTSTATUS
NTAPI
LsaCreateTrustedDomainEx(
    IN LSA_HANDLE PolicyHandle,
    IN PTRUSTED_DOMAIN_INFORMATION_EX TrustedDomainInformation,
    IN PTRUSTED_DOMAIN_AUTH_INFORMATION AuthenticationInformation,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSA_HANDLE TrustedDomainHandle
    );


//
// This API sets the workstation password (equivalent of setting/getting
// the SSI_SECRET_NAME secret)
//

NTSTATUS
NTAPI
LsaStorePrivateData(
    IN LSA_HANDLE PolicyHandle,
    IN PLSA_UNICODE_STRING KeyName,
    IN PLSA_UNICODE_STRING PrivateData
    );

NTSTATUS
NTAPI
LsaRetrievePrivateData(
    IN LSA_HANDLE PolicyHandle,
    IN PLSA_UNICODE_STRING KeyName,
    OUT PLSA_UNICODE_STRING * PrivateData
    );


ULONG
NTAPI
LsaNtStatusToWinError(
    NTSTATUS Status
    );

#if 0
NTSTATUS
NTAPI
LsaLookupNamesEx(
    IN LSA_HANDLE PolicyHandle,
    IN ULONG Count,
    IN PLSA_NAME_LOOKUP_EX Names,
    OUT PLSA_TRANSLATED_SID_EX *TranslatedSids,
    IN ULONG LookupOptions,
    IN OUT PULONG MappedCount
    );

NTSTATUS
NTAPI
LsaLookupSidsEx(
    IN LSA_HANDLE PolicyHandle,
    IN ULONG Count,
    IN PLSA_SID_LOOKUP_EX Sids,
    OUT PLSA_TRANSLATED_NAME_EX *TranslatedNames,
    IN ULONG LookupOptions,
    IN OUT PULONG MappedCount
    );
#endif

//
// Define a symbol so we can tell if ntifs.h has been included.
//

// begin_ntifs
#ifndef _NTLSA_IFS_
#define _NTLSA_IFS_
#endif
// end_ntifs


//
// SPNEGO package stuff
//

enum NEGOTIATE_MESSAGES {
    NegEnumPackagePrefixes = 0,
    NegGetCallerName = 1,
    NegCallPackageMax
} ;

#define NEGOTIATE_MAX_PREFIX    32

typedef struct _NEGOTIATE_PACKAGE_PREFIX {
    ULONG_PTR   PackageId ;
    PVOID       PackageDataA ;
    PVOID       PackageDataW ;
    ULONG_PTR   PrefixLen ;
    UCHAR       Prefix[ NEGOTIATE_MAX_PREFIX ];
} NEGOTIATE_PACKAGE_PREFIX, * PNEGOTIATE_PACKAGE_PREFIX ;

typedef struct _NEGOTIATE_PACKAGE_PREFIXES {
    ULONG       MessageType ;
    ULONG       PrefixCount ;
    ULONG       Offset ;        // Offset to array of _PREFIX above
} NEGOTIATE_PACKAGE_PREFIXES, *PNEGOTIATE_PACKAGE_PREFIXES ;

typedef struct _NEGOTIATE_CALLER_NAME_REQUEST {
    ULONG       MessageType ;
    LUID        LogonId ;
} NEGOTIATE_CALLER_NAME_REQUEST, *PNEGOTIATE_CALLER_NAME_REQUEST ;

typedef struct _NEGOTIATE_CALLER_NAME_RESPONSE {
    ULONG       MessageType ;
    PWSTR       CallerName ;
} NEGOTIATE_CALLER_NAME_RESPONSE, * PNEGOTIATE_CALLER_NAME_RESPONSE ;

#define NEGOTIATE_ALLOW_NTLM    0x10000000
#define NEGOTIATE_NEG_NTLM      0x20000000

#ifndef _NTDEF_
typedef LSA_UNICODE_STRING UNICODE_STRING, *PUNICODE_STRING;
typedef LSA_STRING STRING, *PSTRING ;
#endif

#ifndef _DOMAIN_PASSWORD_INFORMATION_DEFINED
#define _DOMAIN_PASSWORD_INFORMATION_DEFINED
typedef struct _DOMAIN_PASSWORD_INFORMATION {
    USHORT MinPasswordLength;
    USHORT PasswordHistoryLength;
    ULONG PasswordProperties;
#if defined(MIDL_PASS)
    OLD_LARGE_INTEGER MaxPasswordAge;
    OLD_LARGE_INTEGER MinPasswordAge;
#else
    LARGE_INTEGER MaxPasswordAge;
    LARGE_INTEGER MinPasswordAge;
#endif
} DOMAIN_PASSWORD_INFORMATION, *PDOMAIN_PASSWORD_INFORMATION;
#endif 


#ifndef _PASSWORD_NOTIFICATION_DEFINED
#define _PASSWORD_NOTIFICATION_DEFINED
typedef NTSTATUS (*PSAM_PASSWORD_NOTIFICATION_ROUTINE) (
    PUNICODE_STRING UserName,
    ULONG RelativeId,
    PUNICODE_STRING NewPassword
);

#define SAM_PASSWORD_CHANGE_NOTIFY_ROUTINE  "PasswordChangeNotify"

typedef BOOLEAN (*PSAM_INIT_NOTIFICATION_ROUTINE) (
);

#define SAM_INIT_NOTIFICATION_ROUTINE  "InitializeChangeNotify"


#define SAM_PASSWORD_FILTER_ROUTINE  "PasswordFilter"

typedef BOOLEAN (*PSAM_PASSWORD_FILTER_ROUTINE) (
    IN PUNICODE_STRING  AccountName,
    IN PUNICODE_STRING  FullName,
    IN PUNICODE_STRING Password,
    IN BOOLEAN SetOperation
    );
#endif // _PASSWORD_NOTIFICATION_DEFINED

/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Name of the MSV1_0 authentication package                           //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

#define MSV1_0_PACKAGE_NAME     "MICROSOFT_AUTHENTICATION_PACKAGE_V1_0"
#define MSV1_0_PACKAGE_NAMEW    L"MICROSOFT_AUTHENTICATION_PACKAGE_V1_0"
#define MSV1_0_PACKAGE_NAMEW_LENGTH sizeof(MSV1_0_PACKAGE_NAMEW) - sizeof(WCHAR)

//
// Location of MSV authentication package data
//
#define MSV1_0_SUBAUTHENTICATION_KEY "SYSTEM\\CurrentControlSet\\Control\\Lsa\\MSV1_0"
#define MSV1_0_SUBAUTHENTICATION_VALUE "Auth"


/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Widely used MSV1_0 data types                                       //
//                                                                     //
/////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//       LOGON      Related Data Structures
//
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// When a LsaLogonUser() call is dispatched to the MsV1_0 authentication
// package, the beginning of the AuthenticationInformation buffer is
// cast to a MSV1_0_LOGON_SUBMIT_TYPE to determine the type of logon
// being requested.  Similarly, upon return, the type of profile buffer
// can be determined by typecasting it to a MSV_1_0_PROFILE_BUFFER_TYPE.
//

//
//  MSV1.0 LsaLogonUser() submission message types.
//

typedef enum _MSV1_0_LOGON_SUBMIT_TYPE {
    MsV1_0InteractiveLogon = 2,
    MsV1_0Lm20Logon,
    MsV1_0NetworkLogon,
    MsV1_0SubAuthLogon,
    MsV1_0WorkstationUnlockLogon = 7
} MSV1_0_LOGON_SUBMIT_TYPE, *PMSV1_0_LOGON_SUBMIT_TYPE;


//
//  MSV1.0 LsaLogonUser() profile buffer types.
//

typedef enum _MSV1_0_PROFILE_BUFFER_TYPE {
    MsV1_0InteractiveProfile = 2,
    MsV1_0Lm20LogonProfile,
    MsV1_0SmartCardProfile
} MSV1_0_PROFILE_BUFFER_TYPE, *PMSV1_0_PROFILE_BUFFER_TYPE;






//
// MsV1_0InteractiveLogon
//
// The AuthenticationInformation buffer of an LsaLogonUser() call to
// perform an interactive logon contains the following data structure:
//

typedef struct _MSV1_0_INTERACTIVE_LOGON {
    MSV1_0_LOGON_SUBMIT_TYPE MessageType;
    UNICODE_STRING LogonDomainName;
    UNICODE_STRING UserName;
    UNICODE_STRING Password;
} MSV1_0_INTERACTIVE_LOGON, *PMSV1_0_INTERACTIVE_LOGON;

//
// Where:
//
//     MessageType - Contains the type of logon being requested.  This
//         field must be set to MsV1_0InteractiveLogon.
//
//     UserName - Is a string representing the user's account name.  The
//         name may be up to 255 characters long.  The name is treated case
//         insensitive.
//
//     Password - Is a string containing the user's cleartext password.
//         The password may be up to 255 characters long and contain any
//         UNICODE value.
//
//


//
// The ProfileBuffer returned upon a successful logon of this type
// contains the following data structure:
//

typedef struct _MSV1_0_INTERACTIVE_PROFILE {
    MSV1_0_PROFILE_BUFFER_TYPE MessageType;
    USHORT LogonCount;
    USHORT BadPasswordCount;
    LARGE_INTEGER LogonTime;
    LARGE_INTEGER LogoffTime;
    LARGE_INTEGER KickOffTime;
    LARGE_INTEGER PasswordLastSet;
    LARGE_INTEGER PasswordCanChange;
    LARGE_INTEGER PasswordMustChange;
    UNICODE_STRING LogonScript;
    UNICODE_STRING HomeDirectory;
    UNICODE_STRING FullName;
    UNICODE_STRING ProfilePath;
    UNICODE_STRING HomeDirectoryDrive;
    UNICODE_STRING LogonServer;
    ULONG UserFlags;
} MSV1_0_INTERACTIVE_PROFILE, *PMSV1_0_INTERACTIVE_PROFILE;

//
// where:
//
//     MessageType - Identifies the type of profile data being returned.
//         Contains the type of logon being requested.  This field must
//         be set to MsV1_0InteractiveProfile.
//
//     LogonCount - Number of times the user is currently logged on.
//
//     BadPasswordCount - Number of times a bad password was applied to
//         the account since last successful logon.
//
//     LogonTime - Time when user last logged on.  This is an absolute
//         format NT standard time value.
//
//     LogoffTime - Time when user should log off.  This is an absolute
//         format NT standard time value.
//
//     KickOffTime - Time when system should force user logoff.  This is
//         an absolute format NT standard time value.
//
//     PasswordLastChanged - Time and date the password was last
//         changed.  This is an absolute format NT standard time
//         value.
//
//     PasswordCanChange - Time and date when the user can change the
//         password.  This is an absolute format NT time value.  To
//         prevent a password from ever changing, set this field to a
//         date very far into the future.
//
//     PasswordMustChange - Time and date when the user must change the
//         password.  If the user can never change the password, this
//         field is undefined.  This is an absolute format NT time
//         value.
//
//     LogonScript - The (relative) path to the account's logon
//         script.
//
//     HomeDirectory - The home directory for the user.
//


//
// MsV1_0Lm20Logon and MsV1_0NetworkLogon
//
// The AuthenticationInformation buffer of an LsaLogonUser() call to
// perform an network logon contains the following data structure:
//
// MsV1_0NetworkLogon logon differs from MsV1_0Lm20Logon in that the
// ParameterControl field exists.
//

#define MSV1_0_CHALLENGE_LENGTH 8
#define MSV1_0_USER_SESSION_KEY_LENGTH 16
#define MSV1_0_LANMAN_SESSION_KEY_LENGTH 8



//
// Values for ParameterControl.
//

#define MSV1_0_CLEARTEXT_PASSWORD_ALLOWED    0x02
#define MSV1_0_UPDATE_LOGON_STATISTICS       0x04
#define MSV1_0_RETURN_USER_PARAMETERS        0x08
#define MSV1_0_DONT_TRY_GUEST_ACCOUNT        0x10
#define MSV1_0_ALLOW_SERVER_TRUST_ACCOUNT    0x20
#define MSV1_0_RETURN_PASSWORD_EXPIRY        0x40
// this next flag says that CaseInsensitiveChallengeResponse
//  (aka LmResponse) contains a client challenge in the first 8 bytes
#define MSV1_0_USE_CLIENT_CHALLENGE          0x80
#define MSV1_0_TRY_GUEST_ACCOUNT_ONLY        0x100
#define MSV1_0_RETURN_PROFILE_PATH           0x200
#define MSV1_0_TRY_SPECIFIED_DOMAIN_ONLY     0x400
#define MSV1_0_ALLOW_WORKSTATION_TRUST_ACCOUNT 0x800
#define MSV1_0_SUBAUTHENTICATION_DLL_EX      0x00100000

//
// The high order byte is a value indicating the SubAuthentication DLL.
//  Zero indicates no SubAuthentication DLL.
//
#define MSV1_0_SUBAUTHENTICATION_DLL         0xFF000000
#define MSV1_0_SUBAUTHENTICATION_DLL_SHIFT   24
#define MSV1_0_MNS_LOGON                     0x01000000

//
// This is the list of subauthentication dlls used in MS
//

#define MSV1_0_SUBAUTHENTICATION_DLL_RAS     2
#define MSV1_0_SUBAUTHENTICATION_DLL_IIS     132

typedef struct _MSV1_0_LM20_LOGON {
    MSV1_0_LOGON_SUBMIT_TYPE MessageType;
    UNICODE_STRING LogonDomainName;
    UNICODE_STRING UserName;
    UNICODE_STRING Workstation;
    UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH];
    STRING CaseSensitiveChallengeResponse;
    STRING CaseInsensitiveChallengeResponse;
    ULONG ParameterControl;
} MSV1_0_LM20_LOGON, * PMSV1_0_LM20_LOGON;



//
// NT 5.0 SubAuth dlls can use this struct
//

typedef struct _MSV1_0_SUBAUTH_LOGON{
    MSV1_0_LOGON_SUBMIT_TYPE MessageType;
    UNICODE_STRING LogonDomainName;
    UNICODE_STRING UserName;
    UNICODE_STRING Workstation;
    UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH];
    STRING AuthenticationInfo1;
    STRING AuthenticationInfo2;
    ULONG ParameterControl;
    ULONG SubAuthPackageId;
} MSV1_0_SUBAUTH_LOGON, * PMSV1_0_SUBAUTH_LOGON;


//
// Values for UserFlags.
//

#define LOGON_GUEST                 0x01
#define LOGON_NOENCRYPTION          0x02
#define LOGON_CACHED_ACCOUNT        0x04
#define LOGON_USED_LM_PASSWORD      0x08
#define LOGON_EXTRA_SIDS            0x20
#define LOGON_SUBAUTH_SESSION_KEY   0x40
#define LOGON_SERVER_TRUST_ACCOUNT  0x80
#define LOGON_NTLMV2_ENABLED        0x100       // says DC understands NTLMv2
#define LOGON_RESOURCE_GROUPS       0x200
#define LOGON_PROFILE_PATH_RETURNED 0x400

//
// The high order byte is reserved for return by SubAuthentication DLLs.
//

#define MSV1_0_SUBAUTHENTICATION_FLAGS 0xFF000000

// Values returned by the MSV1_0_MNS_LOGON SubAuthentication DLL
#define LOGON_GRACE_LOGON              0x01000000

typedef struct _MSV1_0_LM20_LOGON_PROFILE {
    MSV1_0_PROFILE_BUFFER_TYPE MessageType;
    LARGE_INTEGER KickOffTime;
    LARGE_INTEGER LogoffTime;
    ULONG UserFlags;
    UCHAR UserSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];
    UNICODE_STRING LogonDomainName;
    UCHAR LanmanSessionKey[MSV1_0_LANMAN_SESSION_KEY_LENGTH];
    UNICODE_STRING LogonServer;
    UNICODE_STRING UserParameters;
} MSV1_0_LM20_LOGON_PROFILE, * PMSV1_0_LM20_LOGON_PROFILE;


//
// Supplemental credentials structure used for passing credentials into
// MSV1_0 from other packages
//

#define MSV1_0_OWF_PASSWORD_LENGTH 16
#define MSV1_0_CRED_LM_PRESENT 0x1
#define MSV1_0_CRED_NT_PRESENT 0x2
#define MSV1_0_CRED_VERSION 0

typedef struct _MSV1_0_SUPPLEMENTAL_CREDENTIAL {
    ULONG Version;
    ULONG Flags;
    UCHAR LmPassword[MSV1_0_OWF_PASSWORD_LENGTH];
    UCHAR NtPassword[MSV1_0_OWF_PASSWORD_LENGTH];
} MSV1_0_SUPPLEMENTAL_CREDENTIAL, *PMSV1_0_SUPPLEMENTAL_CREDENTIAL;


//
// NTLM3 definitions.
//

#define MSV1_0_NTLM3_RESPONSE_LENGTH 16
#define MSV1_0_NTLM3_OWF_LENGTH 16

//
// this is the longest amount of time we'll allow challenge response
// pairs to be used. Note that this also has to allow for worst case clock skew
//
#define MSV1_0_MAX_NTLM3_LIFE 1800     // 30 minutes (in seconds)
#define MSV1_0_MAX_AVL_SIZE 64000

// this is an MSV1_0 private data structure, defining the layout of an NTLM3 response, as sent by a
//  client in the NtChallengeResponse field of the NETLOGON_NETWORK_INFO structure. If can be differentiated
//  from an old style NT response by its length. This is crude, but it needs to pass through servers and
//  the servers' DCs that do not understand NTLM3 but that are willing to pass longer responses.
typedef struct _MSV1_0_NTLM3_RESPONSE {
    UCHAR Response[MSV1_0_NTLM3_RESPONSE_LENGTH]; // hash of OWF of password with all the following fields
    UCHAR RespType;     // id number of response; current is 1
    UCHAR HiRespType;   // highest id number understood by client
    USHORT Flags;       // reserved; must be sent as zero at this version
    ULONG MsgWord;      // 32 bit message from client to server (for use by auth protocol)
    ULONGLONG TimeStamp;    // time stamp when client generated response -- NT system time, quad part
    UCHAR ChallengeFromClient[MSV1_0_CHALLENGE_LENGTH];
    ULONG AvPairsOff;   // offset to start of AvPairs (to allow future expansion)
    UCHAR Buffer[1];    // start of buffer with AV pairs (or future stuff -- so use the offset)
} MSV1_0_NTLM3_RESPONSE, *PMSV1_0_NTLM3_RESPONSE;

#define MSV1_0_NTLM3_INPUT_LENGTH (sizeof(MSV1_0_NTLM3_RESPONSE) - MSV1_0_NTLM3_RESPONSE_LENGTH)

typedef enum {
    MsvAvEOL,                 // end of list
    MsvAvNbComputerName,      // server's computer name -- NetBIOS
    MsvAvNbDomainName,        // server's domain name -- NetBIOS
    MsvAvDnsComputerName,     // server's computer name -- DNS
    MsvAvDnsDomainName        // server's domain name -- DNS
} MSV1_0_AVID;

typedef struct  _MSV1_0_AV_PAIR {
    USHORT AvId;
    USHORT AvLen;
    // Data is treated as byte array following structure
} MSV1_0_AV_PAIR, *PMSV1_0_AV_PAIR;



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//       CALL PACKAGE Related Data Structures                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


//
//  MSV1.0 LsaCallAuthenticationPackage() submission and response
//  message types.
//

typedef enum _MSV1_0_PROTOCOL_MESSAGE_TYPE {
    MsV1_0Lm20ChallengeRequest = 0,          // Both submission and response
    MsV1_0Lm20GetChallengeResponse,          // Both submission and response
    MsV1_0EnumerateUsers,                    // Both submission and response
    MsV1_0GetUserInfo,                       // Both submission and response
    MsV1_0ReLogonUsers,                      // Submission only
    MsV1_0ChangePassword,                    // Both submission and response
    MsV1_0ChangeCachedPassword,              // Both submission and response
    MsV1_0GenericPassthrough,                // Both submission and response
    MsV1_0CacheLogon,                        // Submission only, no response
    MsV1_0SubAuth,                           // Both submission and response
    MsV1_0DeriveCredential,                  // Both submission and response
    MsV1_0CacheLookup                        // Both submission and response
} MSV1_0_PROTOCOL_MESSAGE_TYPE, *PMSV1_0_PROTOCOL_MESSAGE_TYPE;


typedef struct _MSV1_0_CHANGEPASSWORD_REQUEST {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    UNICODE_STRING DomainName;
    UNICODE_STRING AccountName;
    UNICODE_STRING OldPassword;
    UNICODE_STRING NewPassword;
    BOOLEAN        Impersonating;
} MSV1_0_CHANGEPASSWORD_REQUEST, *PMSV1_0_CHANGEPASSWORD_REQUEST;

typedef struct _MSV1_0_CHANGEPASSWORD_RESPONSE {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    BOOLEAN PasswordInfoValid;
    DOMAIN_PASSWORD_INFORMATION DomainPasswordInfo;
} MSV1_0_CHANGEPASSWORD_RESPONSE, *PMSV1_0_CHANGEPASSWORD_RESPONSE;


//
// MsV1_0SubAuthInfo submit buffer and response - for submitting a buffer to a
// specified Subauthentication Package during an LsaCallAuthenticationPackage().
// If this Subauthentication is to be done locally, then package this message
// in LsaCallAuthenticationPackage(). If this SubAuthentication needs to be done
// on the domain controller, then call LsaCallauthenticationPackage with the
// message type being MsV1_0GenericPassThrough and the LogonData in this struct
// should be a PMSV1_0_SUBAUTH_REQUEST
//

typedef struct _MSV1_0_SUBAUTH_REQUEST{
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    ULONG SubAuthPackageId;
    ULONG SubAuthInfoLength;
    PUCHAR SubAuthSubmitBuffer;
} MSV1_0_SUBAUTH_REQUEST, *PMSV1_0_SUBAUTH_REQUEST;

typedef struct _MSV1_0_SUBAUTH_RESPONSE{
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    ULONG SubAuthInfoLength;
    PUCHAR SubAuthReturnBuffer;
} MSV1_0_SUBAUTH_RESPONSE, *PMSV1_0_SUBAUTH_RESPONSE;


//
// Credential Derivation types for MsV1_0DeriveCredential Submit DeriveCredType
//

//
// Derive Credential using SHA-1 and Request buffer DeriveCredSubmitBuffer of
// length DeriveCredInfoLength mixing bytes.
// Response buffer DeriveCredReturnBuffer will contain SHA-1 hash of size
// A_SHA_DIGEST_LEN (20)
//

#define MSV1_0_DERIVECRED_TYPE_SHA1     0

//
// MsV1_0DeriveCredential submit buffer and response - for submitting a buffer
// an call to LsaCallAuthenticationPackage().
//

typedef struct _MSV1_0_DERIVECRED_REQUEST {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    LUID LogonId;
    ULONG DeriveCredType;
    ULONG DeriveCredInfoLength;
    UCHAR DeriveCredSubmitBuffer[1];    // in-place array of length DeriveCredInfoLength
} MSV1_0_DERIVECRED_REQUEST, *PMSV1_0_DERIVECRED_REQUEST;

typedef struct _MSV1_0_DERIVECRED_RESPONSE {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    ULONG DeriveCredInfoLength;
    UCHAR DeriveCredReturnBuffer[1];    // in-place array of length DeriveCredInfoLength
} MSV1_0_DERIVECRED_RESPONSE, *PMSV1_0_DERIVECRED_RESPONSE;


// Revision of the Kerberos Protocol.  MS uses Version 5, Revision 6

#define KERBEROS_VERSION    5
#define KERBEROS_REVISION   6



// Encryption Types:
// These encryption types are supported by the default MS KERBSUPP DLL
// as crypto systems.  Values over 127 are local values, and may be changed
// without notice.

#define KERB_ETYPE_NULL             0
#define KERB_ETYPE_DES_CBC_CRC      1
#define KERB_ETYPE_DES_CBC_MD4      2
#define KERB_ETYPE_DES_CBC_MD5      3


#define KERB_ETYPE_RC4_MD4          -128
#define KERB_ETYPE_RC4_PLAIN2       -129
#define KERB_ETYPE_RC4_LM           -130
#define KERB_ETYPE_RC4_SHA          -131
#define KERB_ETYPE_DES_PLAIN        -132
#define KERB_ETYPE_RC4_HMAC_OLD     -133
#define KERB_ETYPE_RC4_PLAIN_OLD    -134
#define KERB_ETYPE_RC4_HMAC_OLD_EXP -135
#define KERB_ETYPE_RC4_PLAIN_OLD_EXP -136
#define KERB_ETYPE_RC4_PLAIN        -140
#define KERB_ETYPE_RC4_PLAIN_EXP    -141

//
// Pkinit encryption types
//


#define KERB_ETYPE_DSA_SHA1_CMS                             9
#define KERB_ETYPE_RSA_MD5_CMS                              10
#define KERB_ETYPE_RSA_SHA1_CMS                             11
#define KERB_ETYPE_RC2_CBC_ENV                              12
#define KERB_ETYPE_RSA_ENV                                  13
#define KERB_ETYPE_RSA_ES_OEAP_ENV                          14
#define KERB_ETYPE_DES_EDE3_CBC_ENV                         15


//
// Deprecated
//

#define KERB_ETYPE_DSA_SIGN                                8
#define KERB_ETYPE_RSA_PRIV                                9
#define KERB_ETYPE_RSA_PUB                                 10
#define KERB_ETYPE_RSA_PUB_MD5                             11
#define KERB_ETYPE_RSA_PUB_SHA1                            12
#define KERB_ETYPE_PKCS7_PUB                               13

//
// In use types
//

#define KERB_ETYPE_DES_CBC_MD5_NT                          20
#define KERB_ETYPE_RC4_HMAC_NT                             23
#define KERB_ETYPE_RC4_HMAC_NT_EXP                         24

// Checksum algorithms.
// These algorithms are keyed internally for our use.

#define KERB_CHECKSUM_NONE  0
#define KERB_CHECKSUM_CRC32         1
#define KERB_CHECKSUM_MD4           2
#define KERB_CHECKSUM_KRB_DES_MAC   4
#define KERB_CHECKSUM_MD5           7
#define KERB_CHECKSUM_MD5_DES       8


#define KERB_CHECKSUM_LM            -130
#define KERB_CHECKSUM_SHA1          -131
#define KERB_CHECKSUM_REAL_CRC32    -132
#define KERB_CHECKSUM_DES_MAC       -133
#define KERB_CHECKSUM_DES_MAC_MD5   -134
#define KERB_CHECKSUM_MD25          -135
#define KERB_CHECKSUM_RC4_MD5       -136
#define KERB_CHECKSUM_MD5_HMAC      -137                // used by netlogon
#define KERB_CHECKSUM_HMAC_MD5      -138                // used by Kerberos

#define AUTH_REQ_ALLOW_FORWARDABLE      0x00000001
#define AUTH_REQ_ALLOW_PROXIABLE        0x00000002
#define AUTH_REQ_ALLOW_POSTDATE         0x00000004
#define AUTH_REQ_ALLOW_RENEWABLE        0x00000008
#define AUTH_REQ_ALLOW_NOADDRESS        0x00000010
#define AUTH_REQ_ALLOW_ENC_TKT_IN_SKEY  0x00000020
#define AUTH_REQ_ALLOW_VALIDATE         0x00000040
#define AUTH_REQ_VALIDATE_CLIENT        0x00000080
#define AUTH_REQ_OK_AS_DELEGATE         0x00000100
#define AUTH_REQ_PREAUTH_REQUIRED       0x00000200
#define AUTH_REQ_TRANSITIVE_TRUST       0x00000400


#define AUTH_REQ_PER_USER_FLAGS         (AUTH_REQ_ALLOW_FORWARDABLE | \
                                         AUTH_REQ_ALLOW_PROXIABLE | \
                                         AUTH_REQ_ALLOW_POSTDATE | \
                                         AUTH_REQ_ALLOW_RENEWABLE | \
                                         AUTH_REQ_ALLOW_VALIDATE )
//
// Ticket Flags:
//

#define KERB_TICKET_FLAGS_reserved          0x80000000
#define KERB_TICKET_FLAGS_forwardable       0x40000000
#define KERB_TICKET_FLAGS_forwarded         0x20000000
#define KERB_TICKET_FLAGS_proxiable         0x10000000
#define KERB_TICKET_FLAGS_proxy             0x08000000
#define KERB_TICKET_FLAGS_may_postdate      0x04000000
#define KERB_TICKET_FLAGS_postdated         0x02000000
#define KERB_TICKET_FLAGS_invalid           0x01000000
#define KERB_TICKET_FLAGS_renewable         0x00800000
#define KERB_TICKET_FLAGS_initial           0x00400000
#define KERB_TICKET_FLAGS_pre_authent       0x00200000
#define KERB_TICKET_FLAGS_hw_authent        0x00100000
#define KERB_TICKET_FLAGS_ok_as_delegate    0x00040000
#define KERB_TICKET_FLAGS_name_canonicalize 0x00010000
#define KERB_TICKET_FLAGS_reserved1         0x00000001



#ifndef MICROSOFT_KERBEROS_NAME_A

#define MICROSOFT_KERBEROS_NAME_A   "Kerberos"
#define MICROSOFT_KERBEROS_NAME_W   L"Kerberos"
#ifdef WIN32_CHICAGO
#define MICROSOFT_KERBEROS_NAME MICROSOFT_KERBEROS_NAME_A
#else
#define MICROSOFT_KERBEROS_NAME MICROSOFT_KERBEROS_NAME_W
#endif // WIN32_CHICAGO
#endif // MICROSOFT_KERBEROS_NAME_A


/////////////////////////////////////////////////////////////////////////
//
// Quality of protection parameters for MakeSignature / EncryptMessage
//
/////////////////////////////////////////////////////////////////////////

//
// This flag indicates to EncryptMessage that the message is not to actually
// be encrypted, but a header/trailer are to be produced.
//

#define KERB_WRAP_NO_ENCRYPT 0x80000001

/////////////////////////////////////////////////////////////////////////
//
// LsaLogonUser parameters
//
/////////////////////////////////////////////////////////////////////////

typedef enum _KERB_LOGON_SUBMIT_TYPE {
    KerbInteractiveLogon = 2,
    KerbSmartCardLogon = 6,
    KerbWorkstationUnlockLogon = 7,
    KerbSmartCardUnlockLogon = 8,
    KerbProxyLogon = 9,
    KerbTicketLogon = 10,
    KerbTicketUnlockLogon = 11
} KERB_LOGON_SUBMIT_TYPE, *PKERB_LOGON_SUBMIT_TYPE;


typedef struct _KERB_INTERACTIVE_LOGON {
    KERB_LOGON_SUBMIT_TYPE MessageType;
    UNICODE_STRING LogonDomainName;
    UNICODE_STRING UserName;
    UNICODE_STRING Password;
} KERB_INTERACTIVE_LOGON, *PKERB_INTERACTIVE_LOGON;


typedef struct _KERB_INTERACTIVE_UNLOCK_LOGON {
    KERB_INTERACTIVE_LOGON Logon;
    LUID LogonId;
} KERB_INTERACTIVE_UNLOCK_LOGON, *PKERB_INTERACTIVE_UNLOCK_LOGON;

typedef struct _KERB_SMART_CARD_LOGON {
    KERB_LOGON_SUBMIT_TYPE MessageType;
    UNICODE_STRING Pin;
    ULONG CspDataLength;
    PUCHAR CspData;
} KERB_SMART_CARD_LOGON, *PKERB_SMART_CARD_LOGON;

typedef struct _KERB_SMART_CARD_UNLOCK_LOGON {
    KERB_SMART_CARD_LOGON Logon;
    LUID LogonId;
} KERB_SMART_CARD_UNLOCK_LOGON, *PKERB_SMART_CARD_UNLOCK_LOGON;

//
// Structure used for a ticket-only logon
//

typedef struct _KERB_TICKET_LOGON {
    KERB_LOGON_SUBMIT_TYPE MessageType;
    ULONG Flags;
    ULONG ServiceTicketLength;
    ULONG TicketGrantingTicketLength;
    PUCHAR ServiceTicket;               // REQUIRED: Service ticket "host"
    PUCHAR TicketGrantingTicket;        // OPTIONAL: User's encdoded in a KERB_CRED message, encrypted with session key from service ticket
} KERB_TICKET_LOGON, *PKERB_TICKET_LOGON;

//
// Flags for the ticket logon flags field
//

#define KERB_LOGON_FLAG_ALLOW_EXPIRED_TICKET 0x1

typedef struct _KERB_TICKET_UNLOCK_LOGON {
    KERB_TICKET_LOGON Logon;
    LUID LogonId;
} KERB_TICKET_UNLOCK_LOGON, *PKERB_TICKET_UNLOCK_LOGON;

//
// Use the same profile structure as MSV1_0
//
typedef enum _KERB_PROFILE_BUFFER_TYPE {
    KerbInteractiveProfile = 2,
    KerbSmartCardProfile = 4,
    KerbTicketProfile = 6
} KERB_PROFILE_BUFFER_TYPE, *PKERB_PROFILE_BUFFER_TYPE;


typedef struct _KERB_INTERACTIVE_PROFILE {
    KERB_PROFILE_BUFFER_TYPE MessageType;
    USHORT LogonCount;
    USHORT BadPasswordCount;
    LARGE_INTEGER LogonTime;
    LARGE_INTEGER LogoffTime;
    LARGE_INTEGER KickOffTime;
    LARGE_INTEGER PasswordLastSet;
    LARGE_INTEGER PasswordCanChange;
    LARGE_INTEGER PasswordMustChange;
    UNICODE_STRING LogonScript;
    UNICODE_STRING HomeDirectory;
    UNICODE_STRING FullName;
    UNICODE_STRING ProfilePath;
    UNICODE_STRING HomeDirectoryDrive;
    UNICODE_STRING LogonServer;
    ULONG UserFlags;
} KERB_INTERACTIVE_PROFILE, *PKERB_INTERACTIVE_PROFILE;


//
// For smart card, we return a smart card profile, which is an interactive
// profile plus a certificate
//

typedef struct _KERB_SMART_CARD_PROFILE {
    KERB_INTERACTIVE_PROFILE Profile;
    ULONG CertificateSize;
    PUCHAR CertificateData;
} KERB_SMART_CARD_PROFILE, *PKERB_SMART_CARD_PROFILE;


//
// For a ticket logon profile, we return the session key from the ticket
//


typedef struct KERB_CRYPTO_KEY {
    LONG KeyType;
    ULONG Length;
    PUCHAR Value;
} KERB_CRYPTO_KEY, *PKERB_CRYPTO_KEY;

typedef struct _KERB_TICKET_PROFILE {
    KERB_INTERACTIVE_PROFILE Profile;
    KERB_CRYPTO_KEY SessionKey;
} KERB_TICKET_PROFILE, *PKERB_TICKET_PROFILE;




typedef enum _KERB_PROTOCOL_MESSAGE_TYPE {
    KerbDebugRequestMessage = 0,
    KerbQueryTicketCacheMessage,
    KerbChangeMachinePasswordMessage,
    KerbVerifyPacMessage,
    KerbRetrieveTicketMessage,
    KerbUpdateAddressesMessage,
    KerbPurgeTicketCacheMessage,
    KerbChangePasswordMessage,
    KerbRetrieveEncodedTicketMessage,
    KerbDecryptDataMessage,
    KerbAddBindingCacheEntryMessage,
    KerbSetPasswordMessage
} KERB_PROTOCOL_MESSAGE_TYPE, *PKERB_PROTOCOL_MESSAGE_TYPE;


//
// Used both for retrieving tickets and for querying ticket cache
//

typedef struct _KERB_QUERY_TKT_CACHE_REQUEST {
    KERB_PROTOCOL_MESSAGE_TYPE MessageType;
    LUID LogonId;
} KERB_QUERY_TKT_CACHE_REQUEST, *PKERB_QUERY_TKT_CACHE_REQUEST;


typedef struct _KERB_TICKET_CACHE_INFO {
    UNICODE_STRING ServerName;
    UNICODE_STRING RealmName;
    LARGE_INTEGER StartTime;
    LARGE_INTEGER EndTime;
    LARGE_INTEGER RenewTime;
    LONG EncryptionType;
    ULONG TicketFlags;
} KERB_TICKET_CACHE_INFO, *PKERB_TICKET_CACHE_INFO;


typedef struct _KERB_QUERY_TKT_CACHE_RESPONSE {
    KERB_PROTOCOL_MESSAGE_TYPE MessageType;
    ULONG CountOfTickets;
    KERB_TICKET_CACHE_INFO Tickets[ANYSIZE_ARRAY];
} KERB_QUERY_TKT_CACHE_RESPONSE, *PKERB_QUERY_TKT_CACHE_RESPONSE;

//
// Types for retrieving encoded ticket from the cache
//

#ifndef __SECHANDLE_DEFINED__
typedef struct _SecHandle
{
    ULONG_PTR dwLower ;
    ULONG_PTR dwUpper ;
} SecHandle, * PSecHandle ;

#define __SECHANDLE_DEFINED__
#endif // __SECHANDLE_DEFINED__

typedef struct _KERB_RETRIEVE_TKT_REQUEST {
    KERB_PROTOCOL_MESSAGE_TYPE MessageType;
    LUID LogonId;
    UNICODE_STRING TargetName;
    ULONG TicketFlags;
    ULONG CacheOptions;
    LONG EncryptionType;
    SecHandle CredentialsHandle;
} KERB_RETRIEVE_TKT_REQUEST, *PKERB_RETRIEVE_TKT_REQUEST;

#define KERB_RETRIEVE_TICKET_DONT_USE_CACHE 0x1
#define KERB_RETRIEVE_TICKET_USE_CACHE_ONLY 0x2
#define KERB_RETRIEVE_TICKET_USE_CREDHANDLE 0x4

//
// Types for the information about a ticket
//

typedef struct _KERB_EXTERNAL_NAME {
    SHORT NameType;
    USHORT NameCount;
    UNICODE_STRING Names[ANYSIZE_ARRAY];
} KERB_EXTERNAL_NAME, *PKERB_EXTERNAL_NAME;



typedef struct _KERB_EXTERNAL_TICKET {
    PKERB_EXTERNAL_NAME ServiceName;
    PKERB_EXTERNAL_NAME TargetName;
    PKERB_EXTERNAL_NAME ClientName;
    UNICODE_STRING DomainName;
    UNICODE_STRING TargetDomainName;
    UNICODE_STRING AltTargetDomainName;
    KERB_CRYPTO_KEY SessionKey;
    ULONG TicketFlags;
    ULONG Flags;
    LARGE_INTEGER KeyExpirationTime;
    LARGE_INTEGER StartTime;
    LARGE_INTEGER EndTime;
    LARGE_INTEGER RenewUntil;
    LARGE_INTEGER TimeSkew;
    ULONG EncodedTicketSize;
    PUCHAR EncodedTicket;
} KERB_EXTERNAL_TICKET, *PKERB_EXTERNAL_TICKET;

typedef struct _KERB_RETRIEVE_TKT_RESPONSE {
    KERB_EXTERNAL_TICKET Ticket;
} KERB_RETRIEVE_TKT_RESPONSE, *PKERB_RETRIEVE_TKT_RESPONSE;

//
// Used to purge entries from the ticket cache
//

typedef struct _KERB_PURGE_TKT_CACHE_REQUEST {
    KERB_PROTOCOL_MESSAGE_TYPE MessageType;
    LUID LogonId;
    UNICODE_STRING ServerName;
    UNICODE_STRING RealmName;
} KERB_PURGE_TKT_CACHE_REQUEST, *PKERB_PURGE_TKT_CACHE_REQUEST;



//
// KerbChangePassword
//
// KerbChangePassword changes the password on the KDC account plus
//  the password cache and logon credentials if applicable.
//
//

typedef struct _KERB_CHANGEPASSWORD_REQUEST {
    KERB_PROTOCOL_MESSAGE_TYPE MessageType;
    UNICODE_STRING DomainName;
    UNICODE_STRING AccountName;
    UNICODE_STRING OldPassword;
    UNICODE_STRING NewPassword;
    BOOLEAN        Impersonating;
} KERB_CHANGEPASSWORD_REQUEST, *PKERB_CHANGEPASSWORD_REQUEST;

//
// KerbSetPassword
//
// KerbSetPassword changes the password on the KDC account plus
//  the password cache and logon credentials if applicable.
//
//



typedef struct _KERB_SETPASSWORD_REQUEST {
    KERB_PROTOCOL_MESSAGE_TYPE MessageType;
    LUID LogonId;
    SecHandle CredentialsHandle;
    ULONG Flags;
    UNICODE_STRING DomainName;
    UNICODE_STRING AccountName;
    UNICODE_STRING Password;
} KERB_SETPASSWORD_REQUEST, *PKERB_SETPASSWORD_REQUEST;

#define KERB_SETPASS_USE_LOGONID        1
#define KERB_SETPASS_USE_CREDHANDLE     2


typedef struct _KERB_DECRYPT_REQUEST {
    KERB_PROTOCOL_MESSAGE_TYPE MessageType;
    LUID LogonId;
    ULONG Flags;
    LONG CryptoType;
    LONG KeyUsage;
    KERB_CRYPTO_KEY Key;        // optional
    ULONG EncryptedDataSize;
    ULONG InitialVectorSize;
    PUCHAR InitialVector;
    PUCHAR EncryptedData;
} KERB_DECRYPT_REQUEST, *PKERB_DECRYPT_REQUEST;

//
// If set, use the primary key from the current logon session of the one provided in the LogonId field.
// Otherwise, use the Key in the KERB_DECRYPT_MESSAGE.

#define KERB_DECRYPT_FLAG_DEFAULT_KEY   0x00000001


typedef struct _KERB_DECRYPT_RESPONSE  {
        UCHAR DecryptedData[ANYSIZE_ARRAY];
} KERB_DECRYPT_RESPONSE, *PKERB_DECRYPT_RESPONSE;


//
// Request structure for adding a binding cache entry. TCB privilege
// is required for this operation.
//

typedef struct _KERB_ADD_BINDING_CACHE_ENTRY_REQUEST {
    KERB_PROTOCOL_MESSAGE_TYPE MessageType;
    UNICODE_STRING RealmName;
    UNICODE_STRING KdcAddress;
    ULONG AddressType;                  // from dsgetdc.h
} KERB_ADD_BINDING_CACHE_ENTRY_REQUEST, *PKERB_ADD_BINDING_CACHE_ENTRY_REQUEST;


#ifdef __cplusplus
}
#endif

#endif /* _NTSECAPI_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\include\unicode.h ===
#ifndef __ECM_UNICODE_H__
#define __ECM_UNICODE_H__

// necessary defns -- remove?
#include <rpc.h>
#include <rpcdce.h>
#include <wincrypt.h>

//#include "commctrl.h"
//#include "commdlg.h"
//#include "prsht.h"
//#include "shellapi.h"

#ifdef __cplusplus
extern "C" {
#endif


BOOL WINAPI FIsWinNT(void);
BOOL WINAPI FIsWinNT5(VOID);
BOOL WINAPI MkMBStrEx(PBYTE pbBuff, DWORD cbBuff, LPCWSTR wsz, int cchW, char ** pszMB, int *pcbConverted);
BOOL WINAPI MkMBStr(PBYTE pbBuff, DWORD cbBuff, LPCWSTR wsz, char ** pszMB);
void WINAPI FreeMBStr(PBYTE pbBuff, char * szMB);

LPWSTR WINAPI MkWStr(const char * szMB);
void WINAPI FreeWStr(LPWSTR wsz);


BOOL WINAPI wstr2guid(const WCHAR *pwszIn, GUID *pgOut);
BOOL WINAPI guid2wstr(const GUID *pgIn, WCHAR *pwszOut);

// The following is also needed for non-x86 due to a bug in advapi32 for
// CryptAcquireContextW.
BOOL WINAPI CryptAcquireContextU(
    HCRYPTPROV *phProv,
    LPCWSTR lpContainer,
    LPCWSTR lpProvider,
    DWORD dwProvType,
    DWORD dwFlags
    );

BOOL WINAPI CryptEnumProvidersU(
    DWORD dwIndex,
    DWORD *pdwReserved,
    DWORD dwFlags,
    DWORD *pdwProvType,
    LPWSTR pwszProvName,
    DWORD *pcbProvName
    );

// The following is also needed for non-x86 due to the fact that the
// A/W versions of the ListView_ functions do not exist.
// (these are implemented in ispu\common\unicode\commctrl.cpp)
#ifndef _XBOX
HTREEITEM WINAPI TreeView_InsertItemU(
    HWND hwndTV,
    LPTVINSERTSTRUCTW lpis
    );	

int WINAPI ListView_InsertItemU(
    HWND hwnd,
    const LPLVITEMW pitem
    );

void WINAPI ListView_SetItemTextU(
    HWND hwnd,
    int i,
    int iSubItem,
    LPCWSTR pszText
    );

int WINAPI ListView_InsertColumnU(
    HWND hwnd,
    int i,
    const LPLVCOLUMNW plvC);

BOOL WINAPI ListView_GetItemU(
    HWND hwnd,
    LPLVITEMW pitem
    );
#endif


LONG WINAPI RegOpenHKCUKeyExA(
    HKEY hKey,  // handle of open key
    LPCSTR lpSubKey,    // address of name of subkey to open
    DWORD ulOptions,    // reserved
    REGSAM samDesired,  // security access mask
    PHKEY phkResult     // address of handle of open key
    );

//
//  the following api's handle the problem with impersinating another user
//  and having the HKEY_CURRENT_USER opened to an incorrect user's SID.
//
LONG WINAPI RegCreateHKCUKeyExU (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD Reserved,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    );

LONG WINAPI RegCreateHKCUKeyExA (
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD Reserved,
    LPSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    );

LONG WINAPI RegOpenHKCUKeyExU(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
   );

LONG
WINAPI
RegOpenHKCU(
    HKEY *phKeyCurrentUser
    );

LONG
WINAPI
RegOpenHKCUEx(
    HKEY *phKeyCurrentUser,
    DWORD dwFlags
    );

// Normally, HKEY_USERS\CurrentSid is opened as the HKCU. However, if
// HKEY_USERS\CurrentSid doesn't exist, then, HKEY_USERS\.Default is
// opened.  Set the following flag to only open
// HKEY_USERS\.Default if the current user is the LocalSystem SID.
#define REG_HKCU_LOCAL_SYSTEM_ONLY_DEFAULT_FLAG     0x1

// Normally, HKEY_USERS\CurrentSid is opened as the HKCU. However, if
// HKEY_USERS\CurrentSid doesn't exist, then, HKEY_USERS\.Default is
// opened.  Set the following flag to always disable the opening of
// HKEY_USERS\.Default. If HKEY_USERS\CurrentSid doesn't exist, RegOpenHKCUEx
// returns ERROR_FILE_NOT_FOUND.
#define REG_HKCU_DISABLE_DEFAULT_FLAG               0x2

LONG
WINAPI
RegCloseHKCU(
    HKEY hKeyCurrentUser
    );

BOOL
WINAPI
GetUserTextualSidHKCU(
    IN      LPWSTR  wszTextualSid,
    IN  OUT LPDWORD pcchTextualSid
    );

//
// routine called by code that calls into the Cryptography service (ProtectedStorage)
// code that makes RPC calls into the service should call this function before
// making the RPC bind call.
//

BOOL
WaitForCryptService(
    VOID
    );


#if defined(_M_IX86) && !defined(CE_BUILD)



// Reg.cpp
LONG WINAPI RegCreateKeyExU (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD Reserved,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    );

LONG WINAPI RegDeleteKeyU(
    HKEY hKey,
    LPCWSTR lpSubKey
   );

LONG WINAPI RegEnumKeyExU (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
   );

LONG WINAPI RegEnumValueU (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );

LONG RegQueryValueExU(
    HKEY hKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );

LONG WINAPI RegSetValueExU (
    HKEY hKey,
    LPCWSTR lpValueName,
    DWORD Reserved,
    DWORD dwType,
    CONST BYTE* lpData,
    DWORD cbData
    );

LONG WINAPI RegDeleteValueU (
    HKEY hKey,
    LPCWSTR lpValueName
    );

LONG WINAPI RegQueryInfoKeyU (
    HKEY hKey,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    LPDWORD lpReserved,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcbMaxClassLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime
    );

LONG WINAPI RegOpenKeyExU(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
   );

LONG WINAPI RegConnectRegistryU (
    LPWSTR lpMachineName,
    HKEY hKey,
    PHKEY phkResult
    );

// File.cpp
HANDLE WINAPI CreateFileU (
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    );

BOOL
WINAPI
DeleteFileU(
    LPCWSTR lpFileName
    );

BOOL
WINAPI
CopyFileU(
          LPCWSTR lpwExistingFileName,
          LPCWSTR lpwNewFileName,
          BOOL bFailIfExists
          );

BOOL
WINAPI
MoveFileExU(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    DWORD dwFlags);

DWORD
WINAPI
GetFileAttributesU(
    LPCWSTR lpFileName
    );

BOOL
WINAPI
SetFileAttributesU(
    LPCWSTR lpFileName,
    DWORD dwFileAttributes
    );

DWORD
WINAPI
GetCurrentDirectoryU(
    DWORD nBufferLength,
    LPWSTR lpBuffer);

BOOL
WINAPI
CreateDirectoryU(
    LPCWSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );

UINT
WINAPI
GetWindowsDirectoryU(
    LPWSTR lpBuffer,
    UINT uSize
    );

UINT
WINAPI
GetTempFileNameU(
    IN LPCWSTR lpPathName,
    IN LPCWSTR lpPrefixString,
    IN UINT uUnique,
    OUT LPWSTR lpTempFileName
    );

HINSTANCE WINAPI LoadLibraryU(
    LPCWSTR lpLibFileName
    );

HINSTANCE WINAPI LoadLibraryExU(
    LPCWSTR lpLibFileName,
    HANDLE hFile,
    DWORD dwFlags
    );

DWORD
WINAPI
ExpandEnvironmentStringsU(
    LPCWSTR lpSrc,
    LPWSTR lpDst,
    DWORD nSize
    );


// capi.cpp
BOOL WINAPI CryptSignHashU(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCWSTR lpDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen
    );

BOOL WINAPI CryptVerifySignatureU(
    HCRYPTHASH hHash,
    CONST BYTE *pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCWSTR lpDescription,
    DWORD dwFlags
    );

BOOL WINAPI CryptSetProviderU(
    LPCWSTR lpProvName,
    DWORD dwProvType
    );

// Ole.cpp
RPC_STATUS RPC_ENTRY UuidToStringU(
    UUID *  Uuid,
    WCHAR * *  StringUuid
   );

// nt.cpp
BOOL WINAPI GetUserNameU(
    LPWSTR lpBuffer,
    LPDWORD nSize
   );

BOOL WINAPI GetComputerNameU(
    LPWSTR lpBuffer,
    LPDWORD nSize
    );

DWORD WINAPI GetModuleFileNameU(
    HMODULE hModule,
    LPWSTR lpFilename,
    DWORD nSize
   );

HMODULE WINAPI GetModuleHandleU(
    LPCWSTR lpModuleName    // address of module name to return handle for
   );

// user.cpp
int WINAPI LoadStringU(
    HINSTANCE hInstance,
    UINT uID,
    LPWSTR lpBuffer,
    int nBufferMax
   );

BOOL
WINAPI
InsertMenuU(
    HMENU       hMenu,
    UINT        uPosition,
    UINT        uFlags,
    UINT_PTR    uIDNewItem,
    LPCWSTR     lpNewItem
    );


DWORD WINAPI FormatMessageU(
    DWORD dwFlags,
    LPCVOID lpSource,
    DWORD dwMessageId,
    DWORD dwLanguageId,
    LPWSTR lpBuffer,
    DWORD nSize,
    va_list *Arguments
   );

#ifndef _XBOX
INT_PTR WINAPI PropertySheetU(
    LPPROPSHEETHEADERW  lppsph);

HPROPSHEETPAGE WINAPI CreatePropertySheetPageU(LPCPROPSHEETPAGEW    pPage);

UINT WINAPI     DragQueryFileU(
    HDROP   hDrop,
    UINT    iFile,
    LPWSTR  lpwszFile,
    UINT    cch);


BOOL WINAPI SetWindowTextU(
    HWND hWnd,
    LPCWSTR lpString
   );

int WINAPI GetWindowTextU(
    HWND hWnd,
    LPWSTR lpString,
    int nMaxCount
   );

int WINAPI DialogBoxParamU(
    HINSTANCE hInstance,
    LPCWSTR lpTemplateName,
    HWND hWndParent,
    DLGPROC lpDialogFunc,
    LPARAM dwInitParam
    );

int WINAPI DialogBoxU(
    HINSTANCE hInstance,
    LPCWSTR lpTemplateName,
    HWND hWndParent,
    DLGPROC lpDialogFunc
    );

UINT WINAPI GetDlgItemTextU(
    HWND hDlg,
    int nIDDlgItem,
    LPWSTR lpString,
    int nMaxCount
   );

BOOL WINAPI SetDlgItemTextU(
    HWND hDlg,
    int nIDDlgItem,
    LPCWSTR lpString
    );

int WINAPI MessageBoxU(
    HWND hWnd ,
    LPCWSTR lpText,
    LPCWSTR lpCaption,
    UINT uType
    );

int WINAPI LCMapStringU(
    LCID Locale,
    DWORD dwMapFlags,
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest
    );

int WINAPI GetDateFormatU(
    LCID Locale,
    DWORD dwFlags,
    CONST SYSTEMTIME *lpDate,
    LPCWSTR lpFormat,
    LPWSTR lpDateStr,
    int cchDate
    );

int WINAPI GetTimeFormatU(
    LCID Locale,
    DWORD dwFlags,
    CONST SYSTEMTIME *lpTime,
    LPCWSTR lpFormat,
    LPWSTR lpTimeStr,
    int cchTime
    );

BOOL WINAPI WinHelpU(
    HWND hWndMain,
    LPCWSTR lpszHelp,
    UINT uCommand,
    DWORD dwData
    );

LRESULT WINAPI SendMessageU(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam
    );

LONG WINAPI
SendDlgItemMessageU(
    HWND hDlg,
    int nIDDlgItem,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam
    );

LPWSTR
WINAPI
GetCommandLineU(void);

BOOL
WINAPI
IsBadStringPtrU(IN LPWSTR lpsz, UINT ucchMax);

void
WINAPI
OutputDebugStringU(IN LPWSTR lpwsz);

int
WINAPI
DrawTextU(
    HDC     hDC,
    LPCWSTR lpString,
    int     nCount,
    LPRECT  lpRect,
    UINT    uFormat
);

//
// NOTE the following fields in LPOPENFILENAMEW are NOT supported:
//      nFileOffset
//      nFileExtension
//      lpTemplateName
//
BOOL
WINAPI
GetSaveFileNameU(
    LPOPENFILENAMEW pOpenFileName
);

//
// NOTE the following fields in LPOPENFILENAMEW are NOT supported:
//      nFileOffset
//      nFileExtension
//      lpTemplateName
//
BOOL
WINAPI
GetOpenFileNameU(
    LPOPENFILENAMEW pOpenFileName
);
#endif

// event.cpp
HANDLE
WINAPI
CreateEventU(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCWSTR lpName);

HANDLE
WINAPI
RegisterEventSourceU(
                    LPCWSTR lpUNCServerName,
                    LPCWSTR lpSourceName);

HANDLE
WINAPI
OpenEventU(
           DWORD dwDesiredAccess,
           BOOL bInheritHandle,
           LPCWSTR lpName);

HANDLE
WINAPI
CreateMutexU(
    LPSECURITY_ATTRIBUTES lpMutexAttributes,
    BOOL bInitialOwner,
    LPCWSTR lpName);

HANDLE
WINAPI
OpenMutexU(
           DWORD dwDesiredAccess,
           BOOL bInheritHandle,
           LPCWSTR lpName);

HFONT
WINAPI
CreateFontIndirectU(CONST LOGFONTW *lplf);

#else

#define RegQueryValueExU        RegQueryValueExW
#define RegCreateKeyExU         RegCreateKeyExW
#define RegDeleteKeyU           RegDeleteKeyW
#define RegEnumKeyExU           RegEnumKeyExW
#define RegEnumValueU           RegEnumValueW
#define RegSetValueExU          RegSetValueExW
#define RegQueryInfoKeyU        RegQueryInfoKeyW
#define RegDeleteValueU         RegDeleteValueW

#ifndef _XBOX
__inline LONG WINAPI RegOpenKeyExU(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
   ) {  // compensate for incomplete error codes in WinCE registry apis
        LONG err = RegOpenKeyExW(hKey,lpSubKey, ulOptions,samDesired,phkResult);
        return (err == ERROR_INVALID_PARAMETER ? ERROR_FILE_NOT_FOUND : err);
     }
#else
#define RegOpenKeyExU           RegOpenKeyExW
#endif

#define RegConnectRegistryU     RegConnectRegistryW
#define ExpandEnvironmentStringsU ExpandEnvironmentStringsW

#define CreateFileU             CreateFileW
#define DeleteFileU             DeleteFileW
#define CopyFileU               CopyFileW
#define MoveFileExU             MoveFileExW
#define GetTempFileNameU        GetTempFileNameW
#define GetFileAttributesU      GetFileAttributesW
#define SetFileAttributesU      SetFileAttributesW
#define GetCurrentDirectoryU    GetCurrentDirectoryW
#define CreateDirectoryU        CreateDirectoryW
#define GetWindowsDirectoryU    GetWindowsDirectoryW
#define LoadLibraryU            LoadLibraryW
#define LoadLibraryExU          LoadLibraryExW

#define CryptSignHashU          CryptSignHashW
#define CryptVerifySignatureU   CryptVerifySignatureW
#define CryptSetProviderU       CryptSetProviderW
#ifdef CE_BUILD
#define CryptAcquireContextU    CryptAcquireContextW
#ifdef UNDER_CE
#define CryptEnumProvidersU     CryptEnumProvidersW
#endif
#endif

#define UuidToStringU           UuidToStringW

#define GetUserNameU            GetUserNameW
#define GetComputerNameU        GetComputerNameW
#define GetModuleFileNameU      GetModuleFileNameW
#define GetModuleHandleU        GetModuleHandleW

#define LoadStringU             LoadStringW
#define InsertMenuU             InsertMenuW
#define FormatMessageU          FormatMessageW
#define PropertySheetU          PropertySheetW
#define CreatePropertySheetPageU    CreatePropertySheetPageW
#define DragQueryFileU          DragQueryFileW
#define SetWindowTextU          SetWindowTextW
#define GetWindowTextU          GetWindowTextW
#define DialogBoxParamU         DialogBoxParamW
#define DialogBoxU              DialogBoxW
#define GetDlgItemTextU         GetDlgItemTextW
#define SetDlgItemTextU         SetDlgItemTextW
#define MessageBoxU     MessageBoxW
#define LCMapStringU            LCMapStringW
#define GetDateFormatU          GetDateFormatW
#define GetTimeFormatU          GetTimeFormatW
#define WinHelpU                WinHelpW
#define SendMessageU            SendMessageW
#define SendDlgItemMessageU     SendDlgItemMessageW
#define IsBadStringPtrU         IsBadStringPtrW
#define OutputDebugStringU      OutputDebugStringW
#define GetCommandLineU         GetCommandLineW
#define DrawTextU               DrawTextW
#define GetSaveFileNameU        GetSaveFileNameW
#define GetOpenFileNameU        GetOpenFileNameW

#define CreateEventU            CreateEventW
#define RegisterEventSourceU    RegisterEventSourceW
#define OpenEventU              OpenEventW
#define CreateMutexU            CreateMutexW
#define OpenMutexU              OpenMutexW

#define CreateFontIndirectU     CreateFontIndirectW

#endif // _M_IX86

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\pkiutil\asn1util.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       asn1util.cpp
//
//  Contents:   ASN.1 utility helper functions.
//
//  Functions:  Asn1UtilDecodeLength
//              Asn1UtilExtractContent
//              Asn1UtilIsPKCS7WithoutContentType
//              Asn1UtilAdjustEncodedLength
//              Asn1UtilExtractValues
//              Asn1UtilExtractPKCS7SignedDataContent
//              Asn1UtilExtractCertificateToBeSignedContent
//              Asn1UtilExtractCertificatePublicKeyInfo
//
//  History:    04-Dec-96    philh   created from kevinr's wincrmsg version
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

//+-------------------------------------------------------------------------
//  Get the number of contents octets in a BER encoding.
//
//  Parameters:
//          pcbContent - receives the number of contents octets if definite
//                       encoding, else CMSG_INDEFINITE_LENGTH
//          pbLength   - points to the first length octet
//          cbDER      - number of bytes remaining in the encoding
//
//  Returns:
//          success - the number of bytes in the length field, >0
//          failure - <0
//--------------------------------------------------------------------------
LONG
WINAPI
Asn1UtilDecodeLength(
    OUT DWORD   *pcbContent,
    IN const BYTE *pbLength,
    IN  DWORD   cbEncoded)
{
    long        i;
    BYTE        cbLength;
    const BYTE  *pb;

    if (cbEncoded < 1)
        goto TooLittleData;

    if (0x80 == *pbLength) {
        *pcbContent = CMSG_INDEFINITE_LENGTH;
        i = 1;
        goto CommonReturn;
    }

    // determine the number of length octets and contents octets
    if ((cbLength = *pbLength) & 0x80) {
        cbLength &= ~0x80;         // low 7 bits have number of bytes
        if (cbLength > 4)
            goto LengthTooLargeError;
        if (cbLength >= cbEncoded)
            goto TooLittleData;
        *pcbContent = 0;
        for (i=cbLength, pb=pbLength+1; i>0; i--, pb++)
            *pcbContent = (*pcbContent << 8) + (const DWORD)*pb;
        i = cbLength + 1;
    } else {
        *pcbContent = (DWORD)cbLength;
        i = 1;
    }

CommonReturn:
    return i;   // how many bytes there were in the length field

ErrorReturn:
    i = -1;
    goto CommonReturn;
TooLittleData:
    i = ASN1UTIL_INSUFFICIENT_DATA;
    goto CommonReturn;
TRACE_ERROR(LengthTooLargeError)
}


//+-------------------------------------------------------------------------
//  Point to the content octets in a BER-encoded blob.
//
//  Returns:
//          success - the number of bytes skipped, >=0
//          failure - <0
//
//  NB- If the blob is indefinite-length encoded, *pcbContent is set to
//  CMSG_INDEFINITE_LENGTH
//--------------------------------------------------------------------------
LONG
WINAPI
Asn1UtilExtractContent(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT DWORD *pcbContent,
    OUT const BYTE **ppbContent)
{
#define TAG_MASK 0x1f
    DWORD       cbIdentifier;
    DWORD       cbContent;
    LONG        cbLength;
    LONG        lHeader;
    const BYTE  *pb = pbEncoded;

    if (cbEncoded < 1)
        goto TooLittleData;

    // Skip over the identifier octet(s)
    if (TAG_MASK == (*pb++ & TAG_MASK)) {
        // high-tag-number form
        for (cbIdentifier=2; *pb++ & 0x80; cbIdentifier++)
            ;
    } else {
        // low-tag-number form
        cbIdentifier = 1;
    }

    if (0 > (cbLength = Asn1UtilDecodeLength( &cbContent, pb, cbEncoded-1))) {
        lHeader = cbLength;
        goto CommonReturn;
    }

    pb += cbLength;

    *pcbContent = cbContent;
    *ppbContent = pb;

    lHeader = cbLength + cbIdentifier;
CommonReturn:
    return lHeader;

TooLittleData:
    lHeader = ASN1UTIL_INSUFFICIENT_DATA;
    goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  Returns TRUE if we believe this is a Bob special that has ommitted the
//  PKCS #7 ContentType.
//
//  For PKCS #7: an Object Identifier tag (0x06) immediately follows the
//  identifier and length octets. For a Bob special: an integer tag (0x02)
//  follows the identifier and length octets.
//--------------------------------------------------------------------------
BOOL
WINAPI
Asn1UtilIsPKCS7WithoutContentType(
    IN const BYTE *pbDER,
    IN DWORD cbDER)
{
    DWORD cbContent;
    const BYTE *pbContent;

    if (0 < Asn1UtilExtractContent(pbDER, cbDER, &cbContent, &pbContent) &&
            (cbContent != CMSG_INDEFINITE_LENGTH) &&
            (pbContent < pbDER + cbDER) &&
            (0x02 == *pbContent))
        return TRUE;
    else
        return FALSE;
}

//+-------------------------------------------------------------------------
//  Decode the Asn1 length bytes to possibly downward adjust the length.
//
//  The returned length is always <= cbDER.
//--------------------------------------------------------------------------
DWORD
WINAPI
Asn1UtilAdjustEncodedLength(
    IN const BYTE *pbDER,
    IN DWORD cbDER
    )
{
    // Decode the header to get the real length. I've seen files with extra
    // stuff.

    LONG lLen;
    DWORD cbLen;
    DWORD cbContent;
    const BYTE *pbContent;
    lLen = Asn1UtilExtractContent(pbDER, cbDER, &cbContent, &pbContent);
    if ((lLen >= 0) && (cbContent != CMSG_INDEFINITE_LENGTH)) {
        cbLen = (DWORD)lLen + cbContent;
        if (cbLen < cbDER)
            cbDER = cbLen;
        // else if (cbLen > cbDER)
        //  DER length exceeds input file
    }
    // else
    //  Can't decode DER length
            
    return cbDER;
}

//+-------------------------------------------------------------------------
//  Extract one or more tagged values from the ASN.1 encoded byte array.
//
//  Either steps into the value's content octets (ASN1UTIL_STEP_INTO_VALUE_OP)
//  or steps over the value's tag, length and content octets 
//  (ASN1UTIL_STEP_OVER_VALUE_OP or ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP).
//
//  For tag matching, only supports single byte tags.  STEP_OVER values
//  must be definite-length encoded.
//
//  *pcValue is updated with the number of values successfully extracted.
//
//  Returns:
//      success - >= 0 => length of all values successfully extracted. For
//                        STEP_INTO, only the tag and length octets.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//                        LastError is updated with the error.
//
//  A non-NULL rgValueBlob[] is updated with the pointer to and length of the
//  tagged value or its content octets. For OPTIONAL_STEP_OVER, if tag isn't
//  found, pbData and cbData are set to 0.  If a STEP_INTO value is
//  indefinite-length encoded, cbData is set to CMSG_INDEFINITE_LENGTH.
//  If ASN1UTIL_DEFINITE_LENGTH_FLAG is set, then, all returned lengths
//  are definite-length, ie, CMSG_INDEFINITE_LENGTH is never returned.
//
//  If ASN1UTIL_RETURN_VALUE_BLOB_FLAG is set, pbData points to
//  the tag. cbData includes the tag, length and content octets.
//
//  If ASN1UTIL_RETURN_CONTENT_BLOB_FLAG is set, pbData points to the content
//  octets. cbData includes only the content octets.
//
//  If neither BLOB_FLAG is set, rgValueBlob[] isn't updated.
//--------------------------------------------------------------------------
LONG
WINAPI
Asn1UtilExtractValues(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwFlags,
    IN OUT DWORD *pcValue,
    IN const ASN1UTIL_EXTRACT_VALUE_PARA *rgValuePara,
    OUT OPTIONAL PCRYPT_DER_BLOB rgValueBlob
    )
{
    DWORD cValue = *pcValue;
    const BYTE *pb = pbEncoded;
    DWORD cb = cbEncoded;

    DWORD iValue;
    LONG lAllValues;

    for (iValue = 0; iValue < cValue; iValue++) {
        DWORD dwParaFlags = rgValuePara[iValue].dwFlags;
        DWORD dwOp = dwParaFlags & ASN1UTIL_MASK_VALUE_OP;
        const BYTE *pbParaTag = rgValuePara[iValue].rgbTag;
        BOOL fValueBlob = (dwParaFlags & (ASN1UTIL_RETURN_VALUE_BLOB_FLAG |
                ASN1UTIL_RETURN_CONTENT_BLOB_FLAG)) && rgValueBlob;

        LONG lTagLength;
        DWORD cbContent;
        const BYTE *pbContent;
        DWORD cbValue;

        if (0 == cb) {
            if (ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP != dwOp)
                goto TooLittleData;
            if (fValueBlob) {
                rgValueBlob[iValue].pbData = NULL;
                rgValueBlob[iValue].cbData = 0;
            }
            continue;
        }

        // Assumption: single byte tag for doing comparison
        if (pbParaTag) {
            // Check if the encoded tag matches one of the expected tags

            BYTE bEncodedTag;
            BYTE bParaTag;

            bEncodedTag = *pb;
            while ((bParaTag = *pbParaTag) && bParaTag != bEncodedTag)
                pbParaTag++;

            if (0 == bParaTag) {
                if (ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP != dwOp)
                    goto InvalidTag;
                if (fValueBlob) {
                    rgValueBlob[iValue].pbData = NULL;
                    rgValueBlob[iValue].cbData = 0;
                }
                continue;
            }
        }

        lTagLength = Asn1UtilExtractContent(
            pb,
            cb,
            &cbContent,
            &pbContent
            );
        if (0 >= lTagLength || (DWORD) lTagLength > cb)
            goto InvalidTagOrLength;

        if (CMSG_INDEFINITE_LENGTH == cbContent) {
            if (ASN1UTIL_STEP_INTO_VALUE_OP != dwOp)
                goto UnsupportedIndefiniteLength;
            else if (fValueBlob && (dwFlags & ASN1UTIL_DEFINITE_LENGTH_FLAG))
                goto NotAllowedIndefiniteLength;
            cbValue = CMSG_INDEFINITE_LENGTH;
        } else {
            cbValue = cbContent + lTagLength;
            if (cbValue > cb)
                goto TooLittleData;
        }

        if (fValueBlob) {
            if (dwParaFlags & ASN1UTIL_RETURN_CONTENT_BLOB_FLAG) {
                rgValueBlob[iValue].pbData = (BYTE *) pbContent;
                rgValueBlob[iValue].cbData = cbContent;
            } else if (dwParaFlags & ASN1UTIL_RETURN_VALUE_BLOB_FLAG) {
                rgValueBlob[iValue].pbData = (BYTE *) pb;
                rgValueBlob[iValue].cbData = cbValue;
            }
        }

        switch (dwOp) {
            case ASN1UTIL_STEP_INTO_VALUE_OP:
                pb += lTagLength;
                cb -= lTagLength;
                break;
            case ASN1UTIL_STEP_OVER_VALUE_OP:
            case ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP:
                pb += cbValue;
                cb -= cbValue;
                break;
            default:
                goto InvalidArg;

        }
    }

    lAllValues = (LONG)(pb - pbEncoded);
    assert((DWORD) lAllValues <= cbEncoded);

CommonReturn:
    *pcValue = iValue;
    return lAllValues;

ErrorReturn:
    lAllValues = -((LONG)(pb - pbEncoded)) - 1;
    goto CommonReturn;

SET_ERROR(TooLittleData, ERROR_INVALID_DATA)
SET_ERROR(InvalidTag, ERROR_INVALID_DATA)
SET_ERROR(InvalidTagOrLength, ERROR_INVALID_DATA)
SET_ERROR(InvalidArg, E_INVALIDARG)
SET_ERROR(UnsupportedIndefiniteLength, ERROR_INVALID_DATA)
SET_ERROR(NotAllowedIndefiniteLength, ERROR_INVALID_DATA)
}

static const BYTE rgbSeqTag[] = {ASN1UTIL_TAG_SEQ, 0};
static const BYTE rgbSetTag[] = {ASN1UTIL_TAG_SET, 0};
static const BYTE rgbOIDTag[] = {ASN1UTIL_TAG_OID, 0};
static const BYTE rgbIntegerTag[] = {ASN1UTIL_TAG_INTEGER, 0};
static const BYTE rgbBitStringTag[] = {ASN1UTIL_TAG_BITSTRING, 0};
static const BYTE rgbConstructedContext0Tag[] =
    {ASN1UTIL_TAG_CONSTRUCTED_CONTEXT_0, 0};

static const ASN1UTIL_EXTRACT_VALUE_PARA rgExtractSignedDataContentPara[] = {
    // 0 - ContentInfo ::= SEQUENCE {
    ASN1UTIL_STEP_INTO_VALUE_OP, rgbSeqTag,
    //   1 - contentType ContentType,
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_STEP_OVER_VALUE_OP, rgbOIDTag,
    //   2 - content  [0] EXPLICIT ANY -- OPTIONAL
    ASN1UTIL_STEP_INTO_VALUE_OP, rgbConstructedContext0Tag,
    //     3 - SignedData ::= SEQUENCE {
    ASN1UTIL_STEP_INTO_VALUE_OP, rgbSeqTag,
    //       4 - version             INTEGER,
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_STEP_OVER_VALUE_OP, rgbIntegerTag,
    //       5 - digestAlgorithms    DigestAlgorithmIdentifiers,
    ASN1UTIL_STEP_OVER_VALUE_OP, rgbSetTag,
    //       6 - ContentInfo ::= SEQUENCE {
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_STEP_INTO_VALUE_OP, rgbSeqTag,
    //       7 - contentType ContentType,
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_STEP_OVER_VALUE_OP, rgbOIDTag,
    //       8 - content  [0] EXPLICIT ANY -- OPTIONAL
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_STEP_INTO_VALUE_OP, rgbConstructedContext0Tag,
};

#define SIGNED_DATA_CONTENT_OUTER_OID_VALUE_INDEX   1
#define SIGNED_DATA_CONTENT_VERSION_VALUE_INDEX     4
#define SIGNED_DATA_CONTENT_INNER_OID_VALUE_INDEX   7
#define SIGNED_DATA_CONTENT_INFO_SEQ_VALUE_INDEX    6
#define SIGNED_DATA_CONTENT_CONTEXT_0_VALUE_INDEX   8
#define SIGNED_DATA_CONTENT_VALUE_COUNT             \
    (sizeof(rgExtractSignedDataContentPara) / \
        sizeof(rgExtractSignedDataContentPara[0]))

static const ASN1UTIL_EXTRACT_VALUE_PARA rgExtractCertSignedContent[] = {
    // 0 - SignedContent ::= SEQUENCE {
    ASN1UTIL_STEP_INTO_VALUE_OP, rgbSeqTag,
    //   1 - toBeSigned          NOCOPYANY,
    ASN1UTIL_RETURN_VALUE_BLOB_FLAG |
        ASN1UTIL_STEP_OVER_VALUE_OP, NULL,
    //   2 - algorithm           AlgorithmIdentifier,
    ASN1UTIL_STEP_OVER_VALUE_OP, rgbSeqTag,
    //   3 - signature           BITSTRING
    ASN1UTIL_STEP_OVER_VALUE_OP, rgbBitStringTag,
};

#define CERT_TO_BE_SIGNED_VALUE_INDEX               1
#define CERT_SIGNED_CONTENT_VALUE_COUNT             \
    (sizeof(rgExtractCertSignedContent) / \
        sizeof(rgExtractCertSignedContent[0]))

static const ASN1UTIL_EXTRACT_VALUE_PARA rgExtractCertPublicKeyInfo[] = {
    // 0 - SignedContent ::= SEQUENCE {
    ASN1UTIL_STEP_INTO_VALUE_OP, rgbSeqTag,
    //   1 - CertificateToBeSigned ::= SEQUENCE {
    ASN1UTIL_STEP_INTO_VALUE_OP, rgbSeqTag,
    //      2 - version                 [0] CertificateVersion DEFAULT v1,
    ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP, rgbConstructedContext0Tag,
    //      3 - serialNumber            CertificateSerialNumber,
    ASN1UTIL_STEP_OVER_VALUE_OP, rgbIntegerTag,
    //      4 - signature               AlgorithmIdentifier,
    ASN1UTIL_STEP_OVER_VALUE_OP, rgbSeqTag,
    //      5 - issuer                  NOCOPYANY, -- really Name
    ASN1UTIL_STEP_OVER_VALUE_OP, rgbSeqTag,
    //      6 - validity                Validity,
    ASN1UTIL_STEP_OVER_VALUE_OP, rgbSeqTag,
    //      7 - subject                 NOCOPYANY, -- really Name
    ASN1UTIL_STEP_OVER_VALUE_OP, rgbSeqTag,
    //      8 - subjectPublicKeyInfo    SubjectPublicKeyInfo,
    ASN1UTIL_RETURN_VALUE_BLOB_FLAG |
        ASN1UTIL_STEP_OVER_VALUE_OP, rgbSeqTag
};

#define CERT_PUBLIC_KEY_INFO_VALUE_INDEX    8
#define CERT_PUBLIC_KEY_INFO_VALUE_COUNT        \
    (sizeof(rgExtractCertPublicKeyInfo) / \
        sizeof(rgExtractCertPublicKeyInfo[0]))


// #define szOID_RSA_signedData    "1.2.840.113549.1.7.2"
static const BYTE rgbOIDSignedData[] =
    {0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x02};

static const CRYPT_DER_BLOB EncodedOIDSignedData = {
    sizeof(rgbOIDSignedData), (BYTE *) rgbOIDSignedData
};

#ifdef CMS_PKCS7

// #define szOID_RSA_Data    "1.2.840.113549.1.7.1"
static const BYTE rgbOIDData[] =
    {0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x01};

static const CRYPT_DER_BLOB EncodedOIDData = {
    sizeof(rgbOIDData), (BYTE *) rgbOIDData
};

#endif // CMS_PKCS7


// The encoded OID only includes the content octets. Excludes the tag and
// length octets.
static BOOL CompareEncodedOID(
    IN const CRYPT_DER_BLOB *pEncodedOID1,
    IN const CRYPT_DER_BLOB *pEncodedOID2
    )
{
    if (pEncodedOID1->cbData == pEncodedOID2->cbData &&
            0 == memcmp(pEncodedOID1->pbData, pEncodedOID2->pbData,
                    pEncodedOID1->cbData))
        return TRUE;
    else
        return FALSE;
}


//+-------------------------------------------------------------------------
//  Skips past PKCS7 ASN.1 encoded values to get to the SignedData content.
//
//  Checks that the outer ContentType has the SignedData OID and optionally
//  checks the inner SignedData content's ContentType.
//
//  Returns:
//      success - the number of bytes skipped, >=0
//      failure - <0
//
//  If the SignedData content is indefinite-length encoded,
//  *pcbContent is set to CMSG_INDEFINITE_LENGTH
//--------------------------------------------------------------------------
LONG
WINAPI
Asn1UtilExtractPKCS7SignedDataContent(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN OPTIONAL const CRYPT_DER_BLOB *pEncodedInnerOID,
    OUT DWORD *pcbContent,
    OUT const BYTE **ppbContent
    )
{
    LONG lSkipped;
    DWORD cValue;
    CRYPT_DER_BLOB rgValueBlob[SIGNED_DATA_CONTENT_VALUE_COUNT];

    DWORD cbContent;
    const BYTE *pbContent;
    DWORD cbSeq;
    const BYTE *pbSeq;

    cValue = SIGNED_DATA_CONTENT_VALUE_COUNT;
    if (0 >= (lSkipped = Asn1UtilExtractValues(
            pbEncoded,
            cbEncoded,
            0,                  // dwFlags
            &cValue,
            rgExtractSignedDataContentPara,
            rgValueBlob
            )))
        goto ExtractValuesError;

    pbContent = rgValueBlob[SIGNED_DATA_CONTENT_CONTEXT_0_VALUE_INDEX].pbData;
    cbContent = rgValueBlob[SIGNED_DATA_CONTENT_CONTEXT_0_VALUE_INDEX].cbData;

    // For definite-length encoded, check that the content wasn't
    // omitted.
    //
    // Note, for indefinite-length encoding, if the content was omitted,
    // we would have had a 0 tag instead of the CONTEXT_0 tag.
    cbSeq = rgValueBlob[SIGNED_DATA_CONTENT_INFO_SEQ_VALUE_INDEX].cbData;
    pbSeq = rgValueBlob[SIGNED_DATA_CONTENT_INFO_SEQ_VALUE_INDEX].pbData;
    if (CMSG_INDEFINITE_LENGTH != cbSeq && pbContent >= (pbSeq + cbSeq))
        goto NoSignedDataError;

#ifdef CMS_PKCS7
    // For V3 SignedData, non Data types are wrapped, encapsulated with a
    // OCTET string
    if (1 == rgValueBlob[SIGNED_DATA_CONTENT_VERSION_VALUE_INDEX].cbData &&
            CMSG_SIGNED_DATA_V3 <=
                *(rgValueBlob[SIGNED_DATA_CONTENT_VERSION_VALUE_INDEX].pbData)
                        &&
            !CompareEncodedOID(
                &rgValueBlob[SIGNED_DATA_CONTENT_INNER_OID_VALUE_INDEX],
                &EncodedOIDData)
                        &&
            0 != cbContent && ASN1UTIL_TAG_OCTETSTRING == *pbContent
            ) {
        LONG lTagLength;
        const BYTE *pbInner;
        DWORD cbInner;

        // Advance past the outer OCTET wrapper
        lTagLength = Asn1UtilExtractContent(
            pbContent,
            cbEncoded - lSkipped,
            &cbInner,
            &pbInner
            );
        if (0 < lTagLength) {
            lSkipped += lTagLength;
            cbContent = cbInner;
            pbContent = pbInner;
        }
    }
#endif

    if (CMSG_INDEFINITE_LENGTH == cbContent) {
        // Extract the pbContent and attempt to get its definite length

        LONG lTagLength;
        const BYTE *pbInner;
        DWORD cbInner;

        lTagLength = Asn1UtilExtractContent(
            pbContent,
            cbEncoded - lSkipped,
            &cbInner,
            &pbInner
            );
        if (0 < lTagLength && CMSG_INDEFINITE_LENGTH != cbInner)
            cbContent = cbInner + lTagLength;
    }

    // Verify that the outer ContentType is SignedData and the inner
    // ContentType is the specified type
    if (!CompareEncodedOID(
            &rgValueBlob[SIGNED_DATA_CONTENT_OUTER_OID_VALUE_INDEX],
            &EncodedOIDSignedData
            ))
        goto NotSignedDataContentType;
    if (pEncodedInnerOID && !CompareEncodedOID(
            &rgValueBlob[SIGNED_DATA_CONTENT_INNER_OID_VALUE_INDEX],
            pEncodedInnerOID
            ))
        goto UnexpectedInnerContentTypeError;

    *pcbContent = cbContent;
    *ppbContent = pbContent;

CommonReturn:
    return lSkipped;

ErrorReturn:
    if (0 <= lSkipped)
        lSkipped = -lSkipped - 1;
    *pcbContent = 0;
    *ppbContent = NULL;
    goto CommonReturn;

TRACE_ERROR(ExtractValuesError)
SET_ERROR(NoSignedDataError, ERROR_INVALID_DATA)
SET_ERROR(NotSignedDataContentType, ERROR_INVALID_DATA)
SET_ERROR(UnexpectedInnerContentTypeError, ERROR_INVALID_DATA)
}

//+-------------------------------------------------------------------------
//  Verifies this is a certificate ASN.1 encoded signed content.
//  Returns the pointer to and length of the ToBeSigned content.
//
//  Returns an error if the ToBeSigned content isn't definite length
//  encoded.
//--------------------------------------------------------------------------
BOOL
WINAPI
Asn1UtilExtractCertificateToBeSignedContent(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT DWORD *pcbContent,
    OUT const BYTE **ppbContent
    )
{
    BOOL fResult;
    DWORD cValue;
    CRYPT_DER_BLOB rgValueBlob[CERT_SIGNED_CONTENT_VALUE_COUNT];

    cValue = CERT_SIGNED_CONTENT_VALUE_COUNT;
    if (0 >= Asn1UtilExtractValues(
            pbEncoded,
            cbEncoded,
            ASN1UTIL_DEFINITE_LENGTH_FLAG,
            &cValue,
            rgExtractCertSignedContent,
            rgValueBlob
            ))
        goto ExtractValuesError;

    *ppbContent = rgValueBlob[CERT_TO_BE_SIGNED_VALUE_INDEX].pbData;
    *pcbContent = rgValueBlob[CERT_TO_BE_SIGNED_VALUE_INDEX].cbData;

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    *ppbContent = NULL;
    *pcbContent = 0;
    goto CommonReturn;

TRACE_ERROR(ExtractValuesError)
}

//+-------------------------------------------------------------------------
//  Returns the pointer to and length of the SubjectPublicKeyInfo value in
//  a signed and encoded X.509 certificate.
//
//  Returns an error if the value isn't definite length encoded.
//--------------------------------------------------------------------------
BOOL
WINAPI
Asn1UtilExtractCertificatePublicKeyInfo(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT DWORD *pcbPublicKeyInfo,
    OUT const BYTE **ppbPublicKeyInfo
    )
{
    BOOL fResult;
    DWORD cValue;
    CRYPT_DER_BLOB rgValueBlob[CERT_PUBLIC_KEY_INFO_VALUE_COUNT];

    cValue = CERT_PUBLIC_KEY_INFO_VALUE_COUNT;
    if (0 >= Asn1UtilExtractValues(
            pbEncoded,
            cbEncoded,
            ASN1UTIL_DEFINITE_LENGTH_FLAG,
            &cValue,
            rgExtractCertPublicKeyInfo,
            rgValueBlob
            ))
        goto ExtractValuesError;

    *ppbPublicKeyInfo = rgValueBlob[CERT_PUBLIC_KEY_INFO_VALUE_INDEX].pbData;
    *pcbPublicKeyInfo = rgValueBlob[CERT_PUBLIC_KEY_INFO_VALUE_INDEX].cbData;

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    *ppbPublicKeyInfo = NULL;
    *pcbPublicKeyInfo = 0;
    goto CommonReturn;

TRACE_ERROR(ExtractValuesError)
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\pkiutil\list.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:       list.cpp
//
//  Contents:   list helper functions.
//
//  History:    27-Nov-96   kevinr   created
//
//--------------------------------------------------------------------------

#include "global.hxx"



//--------------------------------------------------------------------------
//
//--------------------------------------------------------------------------
BOOL CList::InsertHead( CNode *pn)
{
    if (pn == NULL)
        return FALSE;

    pn->SetPrev( NULL);
    pn->SetNext( m_pnHead);
    if (m_pnHead)
        m_pnHead->SetPrev( pn);
    else
        m_pnTail = pn;              // list was empty
    m_pnHead = pn;
    m_cNode++;
    return TRUE;
};


//--------------------------------------------------------------------------
//
//--------------------------------------------------------------------------
BOOL CList::InsertTail( CNode *pn)
{
    if (pn == NULL)
        return FALSE;

    pn->SetPrev( m_pnTail);
    pn->SetNext( NULL);
    if (m_pnTail)
        m_pnTail->SetNext( pn);
    else
        m_pnHead = pn;              // list was empty
    m_pnTail = pn;
    m_cNode++;
    return TRUE;
};


//--------------------------------------------------------------------------
// Remove node from the list. Do not delete the node.
//--------------------------------------------------------------------------
BOOL CList::Remove( CNode *pn)
{
// BUGBUG should assert that pn is already in the list.

    if (pn == NULL)
        return FALSE;

    CNode *pnPrev = pn->Prev();
    CNode *pnNext = pn->Next();

    if (pnPrev)
        pnPrev->SetNext( pnNext);

    if (pnNext)
        pnNext->SetPrev( pnPrev);

    if (pn == m_pnHead)
        m_pnHead = pnNext;

    if (pn == m_pnTail)
        m_pnTail = pnPrev;

    m_cNode--;
    return TRUE;
};


//--------------------------------------------------------------------------
//
//--------------------------------------------------------------------------
CNode * CList::Nth( DWORD i)
{
    CNode *pn;

    if (i >= m_cNode)
        return NULL;

    for (pn = m_pnHead;
            (i>0) && pn;
            i--, pn=pn->Next())
        ;

    return pn;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\pkiutil\capi.cpp ===
#include "global.hxx"

#ifndef CE_BUILD

#ifndef _M_IX86
BOOL
WINAPI
UnicodeDllMain(
    HMODULE hInst,
    ULONG  ulReason,
    LPVOID lpReserved
    )
{
    return TRUE;
}

// Bug in CyptAcquireContextW
BOOL WINAPI CryptAcquireContextU(
    HCRYPTPROV *phProv,
    LPCWSTR lpContainer,
    LPCWSTR lpProvider,
    DWORD dwProvType,
    DWORD dwFlags) {

    BYTE rgb1[_MAX_PATH];
    BYTE rgb2[_MAX_PATH];
    char *  szContainer = NULL;
    char *  szProvider = NULL;
    BOOL    err;

    err = FALSE;
    if(
        MkMBStr(rgb1, _MAX_PATH, lpContainer, &szContainer)  &&
        MkMBStr(rgb2, _MAX_PATH, lpProvider, &szProvider)    ) {

        err = CryptAcquireContextA (
                phProv,
                szContainer,
                szProvider,
                dwProvType,
                dwFlags
               );
    }

    FreeMBStr(rgb1, szContainer);
    FreeMBStr(rgb2, szProvider);

    return(err);
}

#else

#ifdef LINK_REDIR
#define pfnAcquireContextW      CryptAcquireContextW
#define pfnSignHashW            CryptSignHashW
#define pfnVerifySignatureW     CryptVerifySignatureW
#define pfnSetProviderW         CryptSetProviderW
#else
static HINSTANCE                hCrypt                  = NULL;
static LPSTR                    pszCryptName            = "advapi32.dll";
static CRYPTACQUIRECONTEXTW     *pfnAcquireContextW     = NULL;
static CRYPTSIGNHASHW           *pfnSignHashW           = NULL;
static CRYPTVERIFYSIGNATUREW    *pfnVerifySignatureW    = NULL;
static CRYPTSETPROVIDERW        *pfnSetProviderW        = NULL;
#endif

BOOL
WINAPI
UnicodeDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved)
{
#ifndef LINK_REDIR
    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        hCrypt = LoadLibraryA(pszCryptName);

        pfnAcquireContextW = (CRYPTACQUIRECONTEXTW*)GetProcAddress(
                                    hCrypt,
                                    "CryptAcquireContextW");
        pfnSignHashW = (CRYPTSIGNHASHW*)GetProcAddress(
                                    hCrypt,
                                    "CryptSignHashW");
        pfnVerifySignatureW = (CRYPTVERIFYSIGNATUREW*)GetProcAddress(
                                    hCrypt,
                                    "CryptVerifySignatureW");
        pfnSetProviderW = (CRYPTSETPROVIDERW*)GetProcAddress(
                                    hCrypt,
                                    "CryptSetProviderW");
        break;

    case DLL_PROCESS_DETACH:
        FreeLibrary( hCrypt);
        pfnAcquireContextW  = NULL;
        pfnSignHashW        = NULL;
        pfnVerifySignatureW = NULL;
        pfnSetProviderW     = NULL;
        break;

    default:
        break;
    }
#endif

    return TRUE;
}


BOOL WINAPI CryptAcquireContextU(
    HCRYPTPROV *phProv,
    LPCWSTR lpContainer,
    LPCWSTR lpProvider,
    DWORD dwProvType,
    DWORD dwFlags) {

    BYTE rgb1[_MAX_PATH];
    BYTE rgb2[_MAX_PATH];
    char *  szContainer = NULL;
    char *  szProvider = NULL;
    LONG    err;

    /* Bug in CyptAcquireContextW
    if(FIsWinNT())
        return( pfnAcquireContextW (
            phProv,
            lpContainer,
            lpProvider,
            dwProvType,
            dwFlags
            ));
            */

    err = FALSE;
    if(
        MkMBStr(rgb1, _MAX_PATH, lpContainer, &szContainer)  &&
        MkMBStr(rgb2, _MAX_PATH, lpProvider, &szProvider)    )
        err = CryptAcquireContextA (
                phProv,
                szContainer,
                szProvider,
                dwProvType,
                dwFlags
               );

    FreeMBStr(rgb1, szContainer);
    FreeMBStr(rgb2, szProvider);

    return(err);
}

BOOL WINAPI CryptSignHashU(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCWSTR lpDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen) {

    BYTE rgb[_MAX_PATH];
    char *  szDescription;
    LONG    err;

    if(FIsWinNT())
        return(pfnSignHashW (
            hHash,
            dwKeySpec,
            lpDescription,
            dwFlags,
            pbSignature,
            pdwSigLen
            ));

    err = FALSE;
    if(MkMBStr(rgb, _MAX_PATH, lpDescription, &szDescription))
        err = CryptSignHashA (
                hHash,
                dwKeySpec,
                szDescription,
                dwFlags,
                pbSignature,
                pdwSigLen
            );

    FreeMBStr(rgb, szDescription);

    return(err);
}

BOOL WINAPI CryptVerifySignatureU(
    HCRYPTHASH hHash,
    CONST BYTE *pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCWSTR lpDescription,
    DWORD dwFlags) {

    BYTE rgb[_MAX_PATH];
    char *  szDescription;
    LONG    err;

    if(FIsWinNT())
        return(pfnVerifySignatureW (
            hHash,
            pbSignature,
            dwSigLen,
            hPubKey,
            lpDescription,
            dwFlags
            ));

    err = FALSE;
    if(MkMBStr(rgb, _MAX_PATH, lpDescription, &szDescription))
        err = CryptVerifySignatureA (
                hHash,
                pbSignature,
                dwSigLen,
                hPubKey,
                szDescription,
                dwFlags
             );

    FreeMBStr(rgb, szDescription);

    return(err);
}

BOOL WINAPI CryptSetProviderU(
    LPCWSTR lpProvName,
    DWORD dwProvType) {

    BYTE rgb[_MAX_PATH];
    char *  szProvName;
    LONG    err;

    if(FIsWinNT())
        return(pfnSetProviderW (
            lpProvName,
            dwProvType
            ));

    err = FALSE;
    if(MkMBStr(rgb, _MAX_PATH, lpProvName, &szProvName))
        err = CryptSetProviderA (
                szProvName,
                dwProvType
            );

    FreeMBStr(rgb, szProvName);

    return(err);
}

#endif
#endif // CE_BUILD

#ifndef UNDER_CE

// IN LINE CRYPT FUNCTION FOR BOTH ALPHA and X86

/*
 -      CryptEnumProvidersU
 -
 *      Purpose:
 *                Enumerate the providers.
 *
 *      Parameters:
 *                IN  dwIndex        - Index to the providers to enumerate
 *                IN  pdwReserved    - Reserved for future use
 *                IN  dwFlags        - Flags parameter
 *                OUT pdwProvType    - The type of the provider
 *                OUT pwszProvName    - Name of the enumerated provider
 *                IN OUT pcbProvName - Length of the enumerated provider
 *
 *      Returns:
 *               BOOL
 *               Use get extended error information use GetLastError
 */

#define PROVREG L"SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider"
#define PROVTYPEREG L"Type"

BOOL
WINAPI CryptEnumProvidersU(
                           IN DWORD dwIndex,
                           IN DWORD *pdwReserved,
                           IN DWORD dwFlags,
                           OUT DWORD *pdwProvType,
                           OUT LPWSTR pwszProvName,
                           IN OUT DWORD *pcbProvName
                           )
{
    HKEY        hRegKey = 0;
    HKEY        hProvRegKey = 0;
    LONG        err;
    DWORD       cbClass;
    FILETIME    ft;
    DWORD       dwKeyType;
    DWORD       cbProvType;
    DWORD       dw;
    DWORD       cSubKeys;
    DWORD       cbMaxKeyName;
    DWORD       cbMaxClass;
    DWORD       cValues;
    DWORD       cbMaxValName;
    DWORD       cbMaxValData;
    LPWSTR      pwszTmpProvName = NULL;
    DWORD       cbTmpProvName;
    BOOL        fRet = CRYPT_FAILED;

    if (NULL != pdwReserved)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    if (0 != dwFlags)
    {
        SetLastError((DWORD)NTE_BAD_FLAGS);
        goto Ret;
    }

    if (ERROR_SUCCESS != (err = RegOpenKeyExU(HKEY_LOCAL_MACHINE,
                                             PROVREG,
                                             0L, KEY_READ, &hRegKey)))
    {
	    SetLastError((DWORD) err);
        goto Ret;
    }

    if (ERROR_SUCCESS != (err = RegQueryInfoKey(hRegKey,
                                                NULL,
                                                &cbClass,
                                                NULL,
                                                &cSubKeys,
                                                &cbMaxKeyName,
                                                &cbMaxClass,
                                                &cValues,
                                                &cbMaxValName,
                                                &cbMaxValData,
                                                NULL,
                                                &ft)))
    {
	    SetLastError((DWORD) err);
        goto Ret;
    }
    cbMaxKeyName += sizeof(CHAR);

    if (NULL == (pwszTmpProvName = (LPWSTR) _alloca(cbMaxKeyName * sizeof(WCHAR))))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Ret;
    }

    if (ERROR_SUCCESS != (err = RegEnumKeyExU(hRegKey, dwIndex, pwszTmpProvName,
                                             &cbMaxKeyName, NULL,
                                             NULL, &cbClass, &ft)))
    {
        SetLastError((DWORD)err);
        goto Ret;
    }

    if (ERROR_SUCCESS != (err = RegOpenKeyExU(hRegKey,
                                             pwszTmpProvName,
                                             0L, KEY_READ, &hProvRegKey)))
    {
	    SetLastError((DWORD) err);
        goto Ret;
    }

    cbProvType = sizeof(dw);
    if (ERROR_SUCCESS != (err = RegQueryValueExU(hProvRegKey,
                                                PROVTYPEREG,
                                                NULL, &dwKeyType, (BYTE*)&dw,
                                                &cbProvType)))
    {
	    SetLastError((DWORD) NTE_PROV_TYPE_ENTRY_BAD);
        goto Ret;
    }
    *pdwProvType = dw;

    cbTmpProvName = (wcslen(pwszTmpProvName) + 1) * sizeof(WCHAR);

    if (NULL != pwszProvName)
    {
        if (*pcbProvName < cbTmpProvName)
        {
            *pcbProvName = cbTmpProvName;
            SetLastError(ERROR_MORE_DATA);
            goto Ret;
        }
        wcscpy(pwszProvName, pwszTmpProvName);
    }

    *pcbProvName = cbTmpProvName;

    fRet = CRYPT_SUCCEED;

Ret:
    if (hRegKey)
        RegCloseKey(hRegKey);
    if (hProvRegKey)
        RegCloseKey(hProvRegKey);
    return fRet;
}

#endif	// ndef UNDER_CE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\pkiutil\new.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       new.cpp
//
//  Contents:   new and delete operators.
//
//  History:    16-Jan-97   kevinr   created
//
//--------------------------------------------------------------------------

#include "global.hxx"


//--------------------------------------------------------------------------
//
//--------------------------------------------------------------------------
extern void * __cdecl operator new(
    IN size_t cb)
{
    void *pv;
    if (NULL == (pv = malloc(cb)))
        goto mallocError;
ErrorReturn:
    return pv;
SET_ERROR(mallocError,ERROR_NOT_ENOUGH_MEMORY)
}

void __cdecl operator delete(
    IN void *pv)
{
    if (pv)
        free(pv);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\pkiutil\ceutils.cpp ===
/*
	ceutils.cpp

	Collection of functions used by CAPI and not implemented on WinCE
*/
#include "global.hxx"

#ifdef UNDER_CE
LONG
APIENTRY
CERegCreateKeyExA (
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    IN DWORD Reserved,
    IN LPSTR lpClass,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PHKEY phkResult,
    OUT LPDWORD lpdwDisposition
    )
{
	LONG ret;
	LPWSTR pwszSubKey = MkWStr(lpSubKey);
	ret = RegCreateKeyExW(hKey,pwszSubKey,Reserved,
				NULL, dwOptions, samDesired, 
				lpSecurityAttributes,
				phkResult, lpdwDisposition);
	FreeWStr(pwszSubKey);
	return ret;
}

LONG
APIENTRY
CERegOpenKeyExA (
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    IN DWORD ulOptions,
    IN REGSAM samDesired,
    OUT PHKEY phkResult
    )
{
	LONG ret;
	LPWSTR pwszSubKey = MkWStr(lpSubKey);
	ret = RegOpenKeyExU(hKey, pwszSubKey, ulOptions, samDesired, phkResult);
	FreeWStr(pwszSubKey);
	return ret;
}

LONG
APIENTRY
CERegDeleteKeyA (
    IN HKEY hKey,
    IN LPCSTR lpSubKey
    )
{
	LONG ret;
	LPWSTR pwszSubKey = MkWStr(lpSubKey);
	ret = RegDeleteKeyW(hKey, pwszSubKey);
	FreeWStr(pwszSubKey);
	return ret;
}

LONG
APIENTRY
CERegSetValueExA (
    IN HKEY hKey,
    IN LPCSTR lpValueName,
    IN DWORD Reserved,
    IN DWORD dwType,
    IN CONST BYTE* lpData,
    IN DWORD cbData
    )
{
	LONG ret;
	LPWSTR pwszValueName = MkWStr(lpValueName);
	LPWSTR pwszValue = NULL;
	if (dwType == REG_SZ)
	{
		pwszValue = MkWStr((char *)lpData);
		lpData = (CONST BYTE *)pwszValue;
	}
	ret = RegSetValueExW(hKey, pwszValueName, Reserved, dwType, lpData, cbData);

	FreeWStr(pwszValueName);
	FreeWStr(pwszValue);
	return ret;
}

LONG RegEnumKeyA(  HKEY hKey,     // handle to key to query
  DWORD dwIndex, // index of subkey to query
  LPSTR lpName, // address of buffer for subkey name
  DWORD cbName   // size of subkey buffer
  )
{
	LPWSTR lpwszName = (LPWSTR) LocalAlloc(0,cbName*sizeof(WCHAR));
	FILETIME ft;
	char *pszConverted;
	LONG ret;
	ret = RegEnumKeyEx( hKey, dwIndex, lpwszName, &cbName, NULL, NULL, NULL, &ft);
	if (lpwszName)
	{
		if (ret == 0)
		{
			MkMBStr((PBYTE)lpName,cbName,lpwszName, &pszConverted);
			FreeMBStr((PBYTE)lpName, pszConverted);			
		}
	}
	return ret;
}

#endif //UNDER_CE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\pkiutil\filever.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1997
//
//  File:       filever.cpp
//
//  Contents:   Get file version
//
//  Functions:  I_CryptGetFileVersion
//
//  History:    22-Oct-97   philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include "crypthlp.h"
#include "unicode.h"
#include <dbgdef.h>

//+-------------------------------------------------------------------------
//  Get file version of the specified file
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptGetFileVersion(
    IN LPCWSTR pwszFilename,
    OUT DWORD *pdwFileVersionMS,    /* e.g. 0x00030075 = "3.75" */
    OUT DWORD *pdwFileVersionLS     /* e.g. 0x00000031 = "0.31" */
    )
{
    BOOL fResult;
    DWORD dwExceptionCode;
    BYTE rgb1[_MAX_PATH];
    LPSTR pszFilename = NULL;

    DWORD dwHandle = 0;
    DWORD cbInfo;
    void *pvInfo = NULL;
	VS_FIXEDFILEINFO *pFixedFileInfo = NULL;   // not allocated
	UINT ccFixedFileInfo = 0;

    if (!MkMBStr(rgb1, _MAX_PATH, pwszFilename, &pszFilename))
        goto OutOfMemory;

    // The following APIs are in DELAYLOAD'ed version.dll. If the DELAYLOAD
    // fails an exception is raised. 
    __try {
        if (0 == (cbInfo = GetFileVersionInfoSizeA(pszFilename, &dwHandle)))
            goto GetFileVersionInfoSizeError;

        if (NULL == (pvInfo = malloc(cbInfo)))
            goto OutOfMemory;

        if (!GetFileVersionInfoA(
                pszFilename,
                0,          // dwHandle, ignored
                cbInfo,
                pvInfo
                ))
            goto GetFileVersionInfoError;

        if (!VerQueryValueA(
                pvInfo,
                "\\",       // VS_FIXEDFILEINFO
                (void **) &pFixedFileInfo,
                &ccFixedFileInfo
                ))
            goto VerQueryValueError;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwExceptionCode = GetExceptionCode();
        goto GetFileVersionException;
    }

    *pdwFileVersionMS = pFixedFileInfo->dwFileVersionMS;
    *pdwFileVersionLS = pFixedFileInfo->dwFileVersionLS;

    fResult = TRUE;
CommonReturn:
    FreeMBStr(rgb1, pszFilename);
    if (pvInfo)
        free(pvInfo);
    return fResult;

ErrorReturn:
    *pdwFileVersionMS = 0;
    *pdwFileVersionLS = 0;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
TRACE_ERROR(GetFileVersionInfoSizeError)
TRACE_ERROR(GetFileVersionInfoError)
TRACE_ERROR(VerQueryValueError)
SET_ERROR_VAR(GetFileVersionException, dwExceptionCode)
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\pkiutil\pkiasn1.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1998
//
//  File:       pkiasn1.cpp
//
//  Contents:   PKI ASN.1 support functions.
//
//  Functions:  PkiAsn1Encode
//              PkiAsn1Decode
//              PkiAsn1SetEncodingRule
//              PkiAsn1GetEncodingRule
//
//              PkiAsn1ReverseBytes
//              PkiAsn1AllocAndReverseBytes
//              PkiAsn1GetOctetString
//              PkiAsn1SetHugeInteger
//              PkiAsn1FreeHugeInteger
//              PkiAsn1GetHugeInteger
//              PkiAsn1SetHugeUINT
//              PkiAsn1GetHugeUINT
//              PkiAsn1SetBitString
//              PkiAsn1GetBitString
//              PkiAsn1SetBitStringWithoutTrailingZeroes
//              PkiAsn1GetIA5String
//              PkiAsn1SetUnicodeConvertedToIA5String
//              PkiAsn1FreeUnicodeConvertedToIA5String
//              PkiAsn1GetIA5StringConvertedToUnicode
//              PkiAsn1GetBMPString
//              PkiAsn1SetAny
//              PkiAsn1GetAny
//              PkiAsn1EncodeInfoEx
//              PkiAsn1EncodeInfo
//              PkiAsn1DecodeAndAllocInfo
//              PkiAsn1AllocStructInfoEx
//              PkiAsn1DecodeAndAllocInfoEx
//
//              PkiAsn1ToObjectIdentifier
//              PkiAsn1FromObjectIdentifier
//              PkiAsn1ToUTCTime
//              PkiAsn1FromUTCTime
//              PkiAsn1ToGeneralizedTime
//              PkiAsn1FromGeneralizedTime
//              PkiAsn1ToChoiceOfTime
//              PkiAsn1FromChoiceOfTime
//
//  The Get functions decrement *plRemainExtra and advance
//  *ppbExtra. When *plRemainExtra becomes negative, the functions continue
//  with the length calculation but stop doing any copies.
//  The functions don't return an error for a negative *plRemainExtra.
//
//  According to the <draft-ietf-pkix-ipki-part1-04.txt> :
//      For UTCTime. Where YY is greater than 50, the year shall
//      be interpreted as 19YY. Where YY is less than or equal to
//      50, the year shall be interpreted as 20YY.
//
//  History:    23-Oct-98    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

// All the *pvInfo extra stuff needs to be aligned
#define INFO_LEN_ALIGN(Len)  ((Len + 7) & ~7)

#define MSASN1_SUPPORTS_NOCOPY  1


//
// UTCTime in X.509 certs are represented using a 2-digit year
// field (yuk! but true).
//
// According to IETF draft, YY years greater than this are
// to be interpreted as 19YY; YY years less than this are 20YY. Sigh.
//
#define MAGICYEAR               50

#define YEARFIRST               1951
#define YEARLAST                2050
#define YEARFIRSTGENERALIZED    2050

inline BOOL my_isdigit( char ch)
{
    return (ch >= '0') && (ch <= '9');
}

//+-------------------------------------------------------------------------
//  Asn1 Encode function. The encoded output is allocated and must be freed
//  by calling PkiAsn1FreeEncoded().
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Encode(
    IN ASN1encoding_t pEnc,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    )
{
    ASN1error_e Asn1Err;

    Asn1Err = ASN1_Encode(
        pEnc,
        pvAsn1Info,
        id,
        ASN1ENCODE_ALLOCATEBUFFER,
        NULL,                       // pbBuf
        0                           // cbBufSize
        );

    if (ASN1_SUCCEEDED(Asn1Err)) {
        Asn1Err = ASN1_SUCCESS;
        *ppbEncoded = pEnc->buf;
        *pcbEncoded = pEnc->len;
    } else {
        *ppbEncoded = NULL;
        *pcbEncoded = 0;
    }
    return Asn1Err;
}

//+-------------------------------------------------------------------------
//  Asn1 Encode function. The encoded output isn't allocated.
//
//  If pbEncoded is NULL, does a length only calculation.
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Encode2(
    IN ASN1encoding_t pEnc,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id,
    OUT OPTIONAL BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    ASN1error_e Asn1Err;
    DWORD cbEncoded;

    if (NULL == pbEncoded)
        cbEncoded = 0;
    else
        cbEncoded = *pcbEncoded;

    if (0 == cbEncoded) {
        // Length only calculation

        Asn1Err = ASN1_Encode(
            pEnc,
            pvAsn1Info,
            id,
            ASN1ENCODE_ALLOCATEBUFFER,
            NULL,                       // pbBuf
            0                           // cbBufSize
            );

        if (ASN1_SUCCEEDED(Asn1Err)) {
            if (pbEncoded)
                Asn1Err = ASN1_ERR_OVERFLOW;
            else
                Asn1Err = ASN1_SUCCESS;
            cbEncoded = pEnc->len;
            PkiAsn1FreeEncoded(pEnc, pEnc->buf);
        }
    } else {
        Asn1Err = ASN1_Encode(
            pEnc,
            pvAsn1Info,
            id,
            ASN1ENCODE_SETBUFFER,
            pbEncoded,
            cbEncoded
            );

        if (ASN1_SUCCEEDED(Asn1Err)) {
            Asn1Err = ASN1_SUCCESS;
            cbEncoded = pEnc->len;
        } else if (ASN1_ERR_OVERFLOW == Asn1Err) {
            // Re-do as length only calculation
            Asn1Err = PkiAsn1Encode2(
                pEnc,
                pvAsn1Info,
                id,
                NULL,   // pbEncoded
                &cbEncoded
                );
            if (ASN1_SUCCESS == Asn1Err)
                Asn1Err = ASN1_ERR_OVERFLOW;
        } else
            cbEncoded = 0;
    }

    *pcbEncoded = cbEncoded;
    return Asn1Err;
}

//+-------------------------------------------------------------------------
//  Asn1 Decode function. The allocated, decoded structure, **pvAsn1Info, must
//  be freed by calling PkiAsn1FreeDecoded().
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Decode(
    IN ASN1decoding_t pDec,
    OUT void **ppvAsn1Info,
    IN ASN1uint32_t id,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded
    )
{
    ASN1error_e Asn1Err;

    *ppvAsn1Info = NULL;
    Asn1Err = ASN1_Decode(
        pDec,
        ppvAsn1Info,
        id,
        ASN1DECODE_SETBUFFER,
        (BYTE *) pbEncoded,
        cbEncoded
        );
    if (ASN1_SUCCEEDED(Asn1Err))
        Asn1Err = ASN1_SUCCESS;
    else {
        if (ASN1_ERR_BADARGS == Asn1Err)
            Asn1Err = ASN1_ERR_EOD;
        *ppvAsn1Info = NULL;
    }
    return Asn1Err;
}

//+-------------------------------------------------------------------------
//  Asn1 Decode function. The allocated, decoded structure, **pvAsn1Info, must
//  be freed by calling PkiAsn1FreeDecoded().
//
//  For a successful decode, *ppbEncoded is advanced
//  past the decoded bytes and *pcbDecoded is decremented by the number
//  of decoded bytes.
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Decode2(
    IN ASN1decoding_t pDec,
    OUT void **ppvAsn1Info,
    IN ASN1uint32_t id,
    IN OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    ASN1error_e Asn1Err;

    *ppvAsn1Info = NULL;
    Asn1Err = ASN1_Decode(
        pDec,
        ppvAsn1Info,
        id,
        ASN1DECODE_SETBUFFER,
        *ppbEncoded,
        *pcbEncoded
        );
    if (ASN1_SUCCEEDED(Asn1Err)) {
        Asn1Err = ASN1_SUCCESS;
        *ppbEncoded += pDec->len;
        *pcbEncoded -= pDec->len;
    } else {
        if (ASN1_ERR_BADARGS == Asn1Err)
            Asn1Err = ASN1_ERR_EOD;
        *ppvAsn1Info = NULL;
    }
    return Asn1Err;
}


//+-------------------------------------------------------------------------
//  Asn1 Set/Get encoding rules functions
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1SetEncodingRule(
    IN ASN1encoding_t pEnc,
    IN ASN1encodingrule_e eRule
    )
{
    ASN1optionparam_s OptParam;

    OptParam.eOption = ASN1OPT_CHANGE_RULE;
    OptParam.eRule = eRule;

    return ASN1_SetEncoderOption(pEnc, &OptParam);
}

ASN1encodingrule_e
WINAPI
PkiAsn1GetEncodingRule(
    IN ASN1encoding_t pEnc
    )
{
    ASN1error_e Asn1Err;
    ASN1encodingrule_e eRule;
    ASN1optionparam_s OptParam;
    OptParam.eOption = ASN1OPT_GET_RULE;

    Asn1Err = ASN1_GetEncoderOption(pEnc, &OptParam);
    if (ASN1_SUCCEEDED(Asn1Err))
        eRule = OptParam.eRule;
    else
        eRule = ASN1_BER_RULE_DER;

    return eRule;
}


//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes in place
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1ReverseBytes(
			IN OUT PBYTE pbIn,
			IN DWORD cbIn
            )
{
    // reverse in place
    PBYTE	pbLo;
    PBYTE	pbHi;
    BYTE	bTmp;

    for (pbLo = pbIn, pbHi = pbIn + cbIn - 1; pbLo < pbHi; pbHi--, pbLo++) {
        bTmp = *pbHi;
        *pbHi = *pbLo;
        *pbLo = bTmp;
    }
}

//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes to a new buffer. PkiAsn1Free() must be
//  called to free allocated bytes.
//--------------------------------------------------------------------------
PBYTE
WINAPI
PkiAsn1AllocAndReverseBytes(
			IN PBYTE pbIn,
			IN DWORD cbIn
            )
{
    PBYTE	pbOut;
    PBYTE	pbSrc;
    PBYTE	pbDst;
    DWORD	cb;

    if (NULL == (pbOut = (PBYTE)PkiAsn1Alloc(cbIn)))
        return NULL;

    for (pbSrc = pbIn, pbDst = pbOut + cbIn - 1, cb = cbIn; cb > 0; cb--)
        *pbDst-- = *pbSrc++;
    return pbOut;
}


//+-------------------------------------------------------------------------
//  Get Octet String
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1GetOctetString(
        IN ASN1uint32_t Asn1Length,
        IN ASN1octet_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT PCRYPT_DATA_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
#ifndef MSASN1_SUPPORTS_NOCOPY
    dwFlags &= ~CRYPT_DECODE_NOCOPY_FLAG;
#endif
    if (dwFlags & CRYPT_DECODE_NOCOPY_FLAG) {
        if (*plRemainExtra >= 0) {
            pInfo->cbData = Asn1Length;
            pInfo->pbData = pAsn1Value;
        }
    } else {
        LONG lRemainExtra = *plRemainExtra;
        BYTE *pbExtra = *ppbExtra;
        LONG lAlignExtra;
        LONG lData;
    
        lData = (LONG) Asn1Length;
        lAlignExtra = INFO_LEN_ALIGN(lData);
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            if (lData > 0) {
                pInfo->pbData = pbExtra;
                pInfo->cbData = (DWORD) lData;
                memcpy(pbExtra, pAsn1Value, lData);
            } else
                memset(pInfo, 0, sizeof(*pInfo));
            pbExtra += lAlignExtra;
        }
        *plRemainExtra = lRemainExtra;
        *ppbExtra = pbExtra;
    }
}

//+-------------------------------------------------------------------------
//  Set/Free/Get HugeInteger
//
//  For PkiAsn1SetHugeInteger, PkiAsn1FreeHugeInteger must be called to free
//  the allocated Asn1Value.
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1SetHugeInteger(
        IN PCRYPT_INTEGER_BLOB pInfo,
        OUT ASN1uint32_t *pAsn1Length,
        OUT ASN1octet_t **ppAsn1Value
        )
{
    if (pInfo->cbData > 0) {
        if (NULL == (*ppAsn1Value = PkiAsn1AllocAndReverseBytes(
                pInfo->pbData, pInfo->cbData))) {
            *pAsn1Length = 0;
            return FALSE;
        }
    } else
        *ppAsn1Value = NULL;
    *pAsn1Length = pInfo->cbData;
    return TRUE;
}

void
WINAPI
PkiAsn1FreeHugeInteger(
        IN ASN1octet_t *pAsn1Value
        )
{
    // Only for BYTE reversal
    PkiAsn1Free(pAsn1Value);
}

void
WINAPI
PkiAsn1GetHugeInteger(
        IN ASN1uint32_t Asn1Length,
        IN ASN1octet_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT PCRYPT_INTEGER_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    // Since bytes need to be reversed, always need to do a copy (dwFlags = 0)
    PkiAsn1GetOctetString(Asn1Length, pAsn1Value, 0,
        pInfo, ppbExtra, plRemainExtra);
    if (*plRemainExtra >= 0 && pInfo->cbData > 0)
        PkiAsn1ReverseBytes(pInfo->pbData, pInfo->cbData);
}

//+-------------------------------------------------------------------------
//  Set/Free/Get Huge Unsigned Integer
//
//  Set inserts a leading 0x00 before reversing. Note, any extra leading
//  0x00's are removed by ASN1 before ASN.1 encoding.
//
//  Get removes a leading 0x00 if present, after reversing.
//
//  PkiAsn1FreeHugeUINT must be called to free the allocated Asn1Value.
//  PkiAsn1FreeHugeUINT has been #define'd to PkiAsn1FreeHugeInteger.
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1SetHugeUINT(
        IN PCRYPT_UINT_BLOB pInfo,
        OUT ASN1uint32_t *pAsn1Length,
        OUT ASN1octet_t **ppAsn1Value
        )
{
    BOOL fResult;
    DWORD cb = pInfo->cbData;
    BYTE *pb;
    DWORD i;

    if (cb > 0) {
        if (NULL == (pb = (BYTE *) PkiAsn1Alloc(cb + 1)))
            goto ErrorReturn;
        *pb = 0x00;
        for (i = 0; i < cb; i++)
            pb[1 + i] = pInfo->pbData[cb - 1 - i];
        cb++;
    } else
        pb = NULL;
    fResult = TRUE;
CommonReturn:
    *pAsn1Length = cb;
    *ppAsn1Value = pb;
    return fResult;
ErrorReturn:
    cb = 0;
    fResult = FALSE;
    goto CommonReturn;
}


void
WINAPI
PkiAsn1GetHugeUINT(
        IN ASN1uint32_t Asn1Length,
        IN ASN1octet_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT PCRYPT_UINT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    // Check for and advance past a leading 0x00.
    if (Asn1Length > 1 && *pAsn1Value == 0) {
        pAsn1Value++;
        Asn1Length--;
    }
    PkiAsn1GetHugeInteger(
        Asn1Length,
        pAsn1Value,
        dwFlags,
        pInfo,
        ppbExtra,
        plRemainExtra
        );
}

//+-------------------------------------------------------------------------
//  Set/Get BitString
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1SetBitString(
        IN PCRYPT_BIT_BLOB pInfo,
        OUT ASN1uint32_t *pAsn1BitLength,
        OUT ASN1octet_t **ppAsn1Value
        )
{
    if (pInfo->cbData) {
        *ppAsn1Value = pInfo->pbData;
        assert(pInfo->cUnusedBits <= 7);
        *pAsn1BitLength = pInfo->cbData * 8 - pInfo->cUnusedBits;
    } else {
        *ppAsn1Value = NULL;
        *pAsn1BitLength = 0;
    }
}

static const BYTE rgbUnusedAndMask[8] =
    {0xFF, 0xFE, 0xFC, 0xF8, 0xF0, 0xE0, 0xC0, 0x80};

void
WINAPI
PkiAsn1GetBitString(
        IN ASN1uint32_t Asn1BitLength,
        IN ASN1octet_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT PCRYPT_BIT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
#ifndef MSASN1_SUPPORTS_NOCOPY
    dwFlags &= ~CRYPT_DECODE_NOCOPY_FLAG;
#endif
    if (dwFlags & CRYPT_DECODE_NOCOPY_FLAG && 0 == (Asn1BitLength % 8)) {
        if (*plRemainExtra >= 0) {
            pInfo->cbData = Asn1BitLength / 8;
            pInfo->cUnusedBits = 0;
            pInfo->pbData = pAsn1Value;
        }
    } else {
        LONG lRemainExtra = *plRemainExtra;
        BYTE *pbExtra = *ppbExtra;
        LONG lAlignExtra;
        LONG lData;
        DWORD cUnusedBits;
    
        lData = (LONG) Asn1BitLength / 8;
        cUnusedBits = Asn1BitLength % 8;
        if (cUnusedBits) {
            cUnusedBits = 8 - cUnusedBits;
            lData++;
        }
        lAlignExtra = INFO_LEN_ALIGN(lData);
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            if (lData > 0) {
                pInfo->pbData = pbExtra;
                pInfo->cbData = (DWORD) lData;
                pInfo->cUnusedBits = cUnusedBits;
                memcpy(pbExtra, pAsn1Value, lData);
                if (cUnusedBits)
                    *(pbExtra + lData - 1) &= rgbUnusedAndMask[cUnusedBits];
            } else
                memset(pInfo, 0, sizeof(*pInfo));
            pbExtra += lAlignExtra;
        }
        *plRemainExtra = lRemainExtra;
        *ppbExtra = pbExtra;
    }
}

//+-------------------------------------------------------------------------
//  Set BitString Without Trailing Zeroes
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1SetBitStringWithoutTrailingZeroes(
        IN PCRYPT_BIT_BLOB pInfo,
        OUT ASN1uint32_t *pAsn1BitLength,
        OUT ASN1octet_t **ppAsn1Value
        )
{
    DWORD cbData;
    DWORD cUnusedBits;

    cbData = pInfo->cbData;
    cUnusedBits = pInfo->cUnusedBits;
    assert(cUnusedBits <= 7);

    if (cbData) {
        BYTE *pb;

        // Until we find a nonzero byte (starting with the last byte),
        // decrement cbData. For the last byte don't look at any unused bits.
        pb = pInfo->pbData + cbData - 1;
        if (0 == (*pb & rgbUnusedAndMask[cUnusedBits])) {
            cUnusedBits = 0;
            cbData--;
            pb--;

            for ( ; 0 < cbData && 0 == *pb; cbData--, pb--)
                ;
        }
    }

    if (cbData) {
        BYTE b;

        // Determine the number of unused bits in the last byte. Treat any
        // trailing zeroes as unused.
        b = *(pInfo->pbData + cbData - 1);
        assert(b);
        if (cUnusedBits)
            b = b >> cUnusedBits;
        
        for (; 7 > cUnusedBits && 0 == (b & 0x01); cUnusedBits++) {
            b = b >> 1;
        }
        assert(b & 0x01);
        assert(cUnusedBits <= 7);

        *ppAsn1Value = pInfo->pbData;
        *pAsn1BitLength = cbData * 8 - cUnusedBits;
    } else {
        *ppAsn1Value = NULL;
        *pAsn1BitLength = 0;
    }
}

//+-------------------------------------------------------------------------
//  Get IA5 String
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1GetIA5String(
        IN ASN1uint32_t Asn1Length,
        IN ASN1char_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT LPSTR *ppsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    LONG lData;

    lData = (LONG) Asn1Length;
    lAlignExtra = INFO_LEN_ALIGN(lData + 1);
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if (lData > 0)
            memcpy(pbExtra, pAsn1Value, lData);
        *(pbExtra + lData) = 0;
        *ppsz = (LPSTR) pbExtra;
        pbExtra += lAlignExtra;
    }
    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  Set/Free/Get Unicode mapped to IA5 String
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1SetUnicodeConvertedToIA5String(
        IN LPWSTR pwsz,
        OUT ASN1uint32_t *pAsn1Length,
        OUT ASN1char_t **ppAsn1Value
        )
{
    BOOL fResult;
    LPSTR psz = NULL;
    int cchUTF8;
    int cchWideChar;
    int i;

    cchWideChar = wcslen(pwsz);
    if (cchWideChar == 0) {
        *pAsn1Length = 0;
        *ppAsn1Value = 0;
        return TRUE;
    }
    // Check that the input string contains valid IA5 characters
    for (i = 0; i < cchWideChar; i++) {
        if (pwsz[i] > 0x7F) {
            SetLastError((DWORD) CRYPT_E_INVALID_IA5_STRING);
            *pAsn1Length = (unsigned int) i;
            goto InvalidIA5;
        }
    }

    cchUTF8 = WideCharToUTF8(
        pwsz,
        cchWideChar,
        NULL,       // lpUTF8Str
        0           // cchUTF8
        );

    if (cchUTF8 <= 0)
        goto ErrorReturn;
    if (NULL == (psz = (LPSTR) PkiAsn1Alloc(cchUTF8)))
        goto ErrorReturn;
    cchUTF8 = WideCharToUTF8(
        pwsz,
        cchWideChar,
        psz,
        cchUTF8
        );
    *ppAsn1Value = psz;
    *pAsn1Length = cchUTF8;
    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    *pAsn1Length = 0;
InvalidIA5:
    *ppAsn1Value = NULL;
    fResult = FALSE;
CommonReturn:
    return fResult;
}

void
WINAPI
PkiAsn1FreeUnicodeConvertedToIA5String(
        IN ASN1char_t *pAsn1Value
        )
{
    PkiAsn1Free(pAsn1Value);
}

void
WINAPI
PkiAsn1GetIA5StringConvertedToUnicode(
        IN ASN1uint32_t Asn1Length,
        IN ASN1char_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    LONG lData;
    int cchWideChar;

    cchWideChar = UTF8ToWideChar(
        (LPSTR) pAsn1Value,
        Asn1Length,
        NULL,                   // lpWideCharStr
        0                       // cchWideChar
        );
    if (cchWideChar > 0)
        lData = cchWideChar * sizeof(WCHAR);
    else
        lData = 0;
    lAlignExtra = INFO_LEN_ALIGN(lData + sizeof(WCHAR));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if (lData > 0)
            UTF8ToWideChar(pAsn1Value, Asn1Length,
                (LPWSTR) pbExtra, cchWideChar);
        memset(pbExtra + lData, 0, sizeof(WCHAR));
        *ppwsz = (LPWSTR) pbExtra;
        pbExtra += lAlignExtra;
    }
    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  Get BMP String
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1GetBMPString(
        IN ASN1uint32_t Asn1Length,
        IN ASN1char16_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    LONG lData;

    lData = (LONG) Asn1Length * sizeof(WCHAR);
    lAlignExtra = INFO_LEN_ALIGN(lData + sizeof(WCHAR));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if (lData > 0)
            memcpy(pbExtra, pAsn1Value, lData);
        memset(pbExtra + lData, 0, sizeof(WCHAR));
        *ppwsz = (LPWSTR) pbExtra;
        pbExtra += lAlignExtra;
    }
    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}


//+-------------------------------------------------------------------------
//  Set/Get "Any" DER BLOB
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1SetAny(
        IN PCRYPT_OBJID_BLOB pInfo,
        OUT ASN1open_t *pAsn1
        )
{
    memset(pAsn1, 0, sizeof(*pAsn1));
    pAsn1->encoded = pInfo->pbData;
    pAsn1->length = pInfo->cbData;
}

void
WINAPI
PkiAsn1GetAny(
        IN ASN1open_t *pAsn1,
        IN DWORD dwFlags,
        OUT PCRYPT_OBJID_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
#ifndef MSASN1_SUPPORTS_NOCOPY
    dwFlags &= ~CRYPT_DECODE_NOCOPY_FLAG;
#endif
    if (dwFlags & CRYPT_DECODE_NOCOPY_FLAG) {
        if (*plRemainExtra >= 0) {
            pInfo->cbData = pAsn1->length;
            pInfo->pbData = (BYTE *) pAsn1->encoded;
        }
    } else {
        LONG lRemainExtra = *plRemainExtra;
        BYTE *pbExtra = *ppbExtra;
        LONG lAlignExtra;
        LONG lData;
    
        lData = (LONG) pAsn1->length;
        lAlignExtra = INFO_LEN_ALIGN(lData);
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            if (lData > 0) {
                pInfo->pbData = pbExtra;
                pInfo->cbData = (DWORD) lData;
                memcpy(pbExtra, pAsn1->encoded, lData);
            } else
                memset(pInfo, 0, sizeof(*pInfo));
            pbExtra += lAlignExtra;
        }
        *plRemainExtra = lRemainExtra;
        *ppbExtra = pbExtra;
    }
}


//+-------------------------------------------------------------------------
//  Encode an ASN1 formatted info structure.
//
//  If CRYPT_ENCODE_ALLOC_FLAG is set, allocate memory for pbEncoded and
//  return *((BYTE **) pvEncoded) = pbAllocEncoded. Otherwise,
//  pvEncoded points to byte array to be updated.
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1EncodeInfoEx(
        IN ASN1encoding_t pEnc,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    ASN1error_e Asn1Err;
    DWORD cbEncoded;

    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG) {
        BYTE *pbEncoded;
        BYTE *pbAllocEncoded;
        PFN_CRYPT_ALLOC pfnAlloc;

        PkiAsn1SetEncodingRule(pEnc, ASN1_BER_RULE_DER);
        Asn1Err = PkiAsn1Encode(
            pEnc,
            pvAsn1Info,
            id,
            &pbEncoded,
            &cbEncoded
            );

        if (ASN1_SUCCESS != Asn1Err) {
            *((void **) pvEncoded) = NULL;
            goto Asn1EncodeError;
        }

        pfnAlloc = PkiGetEncodeAllocFunction(pEncodePara);
        if (NULL == (pbAllocEncoded = (BYTE *) pfnAlloc(cbEncoded))) {
            PkiAsn1FreeEncoded(pEnc, pbEncoded);
            *((void **) pvEncoded) = NULL;
            goto OutOfMemory;
        }
        memcpy(pbAllocEncoded, pbEncoded, cbEncoded);
        *((BYTE **) pvEncoded) = pbAllocEncoded;
        PkiAsn1FreeEncoded(pEnc, pbEncoded);
    } else {
        cbEncoded = *pcbEncoded;
        PkiAsn1SetEncodingRule(pEnc, ASN1_BER_RULE_DER);
        Asn1Err = PkiAsn1Encode2(
            pEnc,
            pvAsn1Info,
            id,
            (BYTE *) pvEncoded,
            &cbEncoded
            );

        if (ASN1_SUCCESS != Asn1Err) {
            if (ASN1_ERR_OVERFLOW == Asn1Err)
                goto LengthError;
            else
                goto Asn1EncodeError;
        }
    }

    fResult = TRUE;
CommonReturn:
    *pcbEncoded = cbEncoded;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
SET_ERROR(LengthError, ERROR_MORE_DATA)
SET_ERROR_VAR(Asn1EncodeError, PkiAsn1ErrToHr(Asn1Err))
}

//+-------------------------------------------------------------------------
//  Encode an ASN1 formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1EncodeInfo(
        IN ASN1encoding_t pEnc,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info,
        OUT OPTIONAL BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return PkiAsn1EncodeInfoEx(
        pEnc,
        id,
        pvAsn1Info,
        0,                  // dwFlags
        NULL,               // pEncodePara
        pbEncoded,
        pcbEncoded
        );
}


//+-------------------------------------------------------------------------
//  Decode into an allocated, ASN1 formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1DecodeAndAllocInfo(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT void **ppvAsn1Info
        )
{
    BOOL fResult;
    ASN1error_e Asn1Err;

    *ppvAsn1Info = NULL;
    if (ASN1_SUCCESS != (Asn1Err = PkiAsn1Decode(
            pDec,
            ppvAsn1Info,
            id,
            pbEncoded,
            cbEncoded
            )))
        goto Asn1DecodeError;
    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    *ppvAsn1Info = NULL;
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(Asn1DecodeError, PkiAsn1ErrToHr(Asn1Err))
}


//+-------------------------------------------------------------------------
//  Call the callback to convert the ASN1 structure into the 'C' structure.
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1AllocStructInfoEx(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    BOOL fResult;
    LONG lRemainExtra;
    DWORD cbStructInfo;

    if (NULL == pvStructInfo || (dwFlags & CRYPT_DECODE_ALLOC_FLAG)) {
        cbStructInfo = 0;
        lRemainExtra = 0;
    } else {
        cbStructInfo = *pcbStructInfo;
        lRemainExtra = (LONG) cbStructInfo;
    }

    if (!pfnDecodeExCallback(
            pvAsn1Info,
            dwFlags & ~CRYPT_DECODE_ALLOC_FLAG,
            pDecodePara,
            pvStructInfo,
            &lRemainExtra
            )) goto DecodeCallbackError;

    if (dwFlags & CRYPT_DECODE_ALLOC_FLAG) {
        void *pv;
        PFN_CRYPT_ALLOC pfnAlloc = PkiGetDecodeAllocFunction(pDecodePara);

        assert(0 > lRemainExtra);
        lRemainExtra = -lRemainExtra;
        cbStructInfo = (DWORD) lRemainExtra;

        if (NULL == (pv = pfnAlloc(cbStructInfo)))
            goto OutOfMemory;
        if (!pfnDecodeExCallback(
                pvAsn1Info,
                dwFlags & ~CRYPT_DECODE_ALLOC_FLAG,
                pDecodePara,
                pv,
                &lRemainExtra
                )) {
            PFN_CRYPT_FREE pfnFree = PkiGetDecodeFreeFunction(pDecodePara);
            pfnFree(pv);
            goto DecodeCallbackError;
        }
        *((void **) pvStructInfo) = pv;
        assert(0 <= lRemainExtra);
    }

    if (0 <= lRemainExtra) {
        cbStructInfo = cbStructInfo - (DWORD) lRemainExtra;
    } else {
        cbStructInfo = cbStructInfo + (DWORD) -lRemainExtra;
        if (pvStructInfo) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fResult = FALSE;
            goto CommonReturn;
        }
    }

    fResult = TRUE;
CommonReturn:
    *pcbStructInfo = cbStructInfo;
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_DECODE_ALLOC_FLAG)
        *((void **) pvStructInfo) = NULL;
    cbStructInfo = 0;
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(DecodeCallbackError)
TRACE_ERROR(OutOfMemory)
}

//+-------------------------------------------------------------------------
//  Decode the ASN1 formatted info structure and call the callback
//  function to convert the ASN1 structure to the 'C' structure.
//
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1DecodeAndAllocInfoEx(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    BOOL fResult;
    void *pvAsn1Info = NULL;

    if (!PkiAsn1DecodeAndAllocInfo(
            pDec,
            id,
            pbEncoded,
            cbEncoded,
            &pvAsn1Info
            )) goto Asn1DecodeError;

    fResult = PkiAsn1AllocStructInfoEx(
        pvAsn1Info,
        dwFlags,
        pDecodePara,
        pfnDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
CommonReturn:
    PkiAsn1FreeInfo(pDec, id, pvAsn1Info);
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_DECODE_ALLOC_FLAG)
        *((void **) pvStructInfo) = NULL;
    *pcbStructInfo = 0;
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(Asn1DecodeError)
}

//+-------------------------------------------------------------------------
//  Convert the ascii string ("1.2.9999") to ASN1's Object Identifier
//  represented as an array of unsigned longs.
//
//  Returns TRUE for a successful conversion. 
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1ToObjectIdentifier(
    IN LPCSTR pszObjId,
    IN OUT ASN1uint16_t *pCount,
    OUT ASN1uint32_t rgulValue[]
    )
{
    BOOL fResult = TRUE;
    unsigned short c = 0;
    LPSTR psz = (LPSTR) pszObjId;
    char    ch;

    if (psz) {
        ASN1uint16_t cMax = *pCount;
        ASN1uint32_t *pul = rgulValue;
        while ((ch = *psz) != '\0' && c++ < cMax) {
            *pul++ = (ASN1uint32_t)atol(psz);
            while (my_isdigit(ch = *psz++))
                ;
            if (ch != '.')
                break;
        }
        if (ch != '\0')
            fResult = FALSE;
    }
    *pCount = c;
    return fResult;
}

//+-------------------------------------------------------------------------
//  Convert from ASN1's Object Identifier represented as an array of
//  unsigned longs to an ascii string ("1.2.9999").
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1FromObjectIdentifier(
    IN ASN1uint16_t Count,
    IN ASN1uint32_t rgulValue[],
    OUT LPSTR pszObjId,
    IN OUT DWORD *pcbObjId
    )
{
    BOOL fResult = TRUE;
    LONG lRemain;

    if (pszObjId == NULL)
        *pcbObjId = 0;

    lRemain = (LONG) *pcbObjId;
    if (Count == 0) {
        if (--lRemain > 0)
            pszObjId++;
    } else {
        char rgch[36];
        LONG lData;
        ASN1uint32_t *pul = rgulValue;
        for (; Count > 0; Count--, pul++) {
            _ltoa(*pul, rgch, 10);
            lData = strlen(rgch);
            lRemain -= lData + 1;
            if (lRemain >= 0) {
                if (lData > 0) {
                    memcpy(pszObjId, rgch, lData);
                    pszObjId += lData;
                }
                *pszObjId++ = '.';
            }
        }
    }

    if (lRemain >= 0) {
        *(pszObjId -1) = '\0';
        *pcbObjId = *pcbObjId - (DWORD) lRemain;
    } else {
        *pcbObjId = *pcbObjId + (DWORD) -lRemain;
        if (pszObjId) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fResult = FALSE;
        }
    }

    return fResult;
}

//+-------------------------------------------------------------------------
//  Adjust FILETIME for timezone.
//
//  Returns FALSE iff conversion failed.
//--------------------------------------------------------------------------
static BOOL AdjustFileTime(
    IN OUT LPFILETIME pFileTime,
    IN ASN1int16_t mindiff,
    IN ASN1bool_t utc
    )
{
    if (utc || mindiff == 0)
        return TRUE;

    BOOL fResult;
    SYSTEMTIME stmDiff;
    FILETIME ftmDiff;
    short absmindiff;

    memset(&stmDiff, 0, sizeof(stmDiff));
    // Note: FILETIME is 100 nanoseconds interval since January 1, 1601
    stmDiff.wYear   = 1601;
    stmDiff.wMonth  = 1;
    stmDiff.wDay    = 1;

    absmindiff = mindiff > 0 ? mindiff : -mindiff;
    stmDiff.wHour = absmindiff / 60;
    stmDiff.wMinute = absmindiff % 60;
    if (stmDiff.wHour >= 24) {
        stmDiff.wDay += stmDiff.wHour / 24;
        stmDiff.wHour %= 24;
    }

    // Note, FILETIME is only 32 bit aligned. __int64 is 64 bit aligned.
    if ((fResult = SystemTimeToFileTime(&stmDiff, &ftmDiff))) {
        unsigned __int64 uTime;
        unsigned __int64 uDiff;

        memcpy(&uTime, pFileTime, sizeof(uTime));
        memcpy(&uDiff, &ftmDiff, sizeof(uDiff));

        if (mindiff > 0)
            uTime += uDiff;
        else
            uTime -= uDiff;

        memcpy(pFileTime, &uTime, sizeof(*pFileTime));
    }
    return fResult;
}

//+-------------------------------------------------------------------------
//  Convert FILETIME to ASN1's UTCTime.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1ToUTCTime(
    IN LPFILETIME pFileTime,
    OUT ASN1utctime_t *pAsn1Time
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;

    memset(pAsn1Time, 0, sizeof(*pAsn1Time));
    if (!FileTimeToSystemTime(pFileTime, &t))
        goto FileTimeToSystemTimeError;
    if (t.wYear < YEARFIRST || t.wYear > YEARLAST)
        goto YearRangeError;

    pAsn1Time->year   = (ASN1uint8_t) (t.wYear % 100);
    pAsn1Time->month  = (ASN1uint8_t) t.wMonth;
    pAsn1Time->day    = (ASN1uint8_t) t.wDay;
    pAsn1Time->hour   = (ASN1uint8_t) t.wHour;
    pAsn1Time->minute = (ASN1uint8_t) t.wMinute;
    pAsn1Time->second = (ASN1uint8_t) t.wSecond;
    pAsn1Time->universal = TRUE;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(FileTimeToSystemTimeError)
TRACE_ERROR(YearRangeError)
}

//+-------------------------------------------------------------------------
//  Convert from ASN1's UTCTime to FILETIME.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1FromUTCTime(
    IN ASN1utctime_t *pAsn1Time,
    OUT LPFILETIME pFileTime
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;
    memset(&t, 0, sizeof(t));

    t.wYear   = pAsn1Time->year > MAGICYEAR ?
                    (1900 + pAsn1Time->year) : (2000 + pAsn1Time->year);
    t.wMonth  = pAsn1Time->month;
    t.wDay    = pAsn1Time->day;
    t.wHour   = pAsn1Time->hour;
    t.wMinute = pAsn1Time->minute;
    t.wSecond = pAsn1Time->second;

    if (!SystemTimeToFileTime(&t, pFileTime))
        goto SystemTimeToFileTimeError;
    fRet = AdjustFileTime(
        pFileTime,
        pAsn1Time->diff,
        pAsn1Time->universal
        );
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(SystemTimeToFileTimeError)
}

//+-------------------------------------------------------------------------
//  Convert FILETIME to ASN1's GeneralizedTime.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1ToGeneralizedTime(
    IN LPFILETIME pFileTime,
    OUT ASN1generalizedtime_t *pAsn1Time
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;

    memset(pAsn1Time, 0, sizeof(*pAsn1Time));
    if (!FileTimeToSystemTime(pFileTime, &t))
        goto FileTimeToSystemTimeError;
    pAsn1Time->year   = t.wYear;
    pAsn1Time->month  = (ASN1uint8_t) t.wMonth;
    pAsn1Time->day    = (ASN1uint8_t) t.wDay;
    pAsn1Time->hour   = (ASN1uint8_t) t.wHour;
    pAsn1Time->minute = (ASN1uint8_t) t.wMinute;
    pAsn1Time->second = (ASN1uint8_t) t.wSecond;
    pAsn1Time->millisecond = t.wMilliseconds;
    pAsn1Time->universal    = TRUE;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(FileTimeToSystemTimeError)
}

//+-------------------------------------------------------------------------
//  Convert from ASN1's GeneralizedTime to FILETIME.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1FromGeneralizedTime(
    IN ASN1generalizedtime_t *pAsn1Time,
    OUT LPFILETIME pFileTime
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;
    memset(&t, 0, sizeof(t));

    t.wYear   = pAsn1Time->year;
    t.wMonth  = pAsn1Time->month;
    t.wDay    = pAsn1Time->day;
    t.wHour   = pAsn1Time->hour;
    t.wMinute = pAsn1Time->minute;
    t.wSecond = pAsn1Time->second;
    t.wMilliseconds = pAsn1Time->millisecond;

    if (!SystemTimeToFileTime(&t, pFileTime))
        goto SystemTimeToFileTimeError;
    fRet = AdjustFileTime(
        pFileTime,
        pAsn1Time->diff,
        pAsn1Time->universal
        );
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(SystemTimeToFileTimeError)
}


//+-------------------------------------------------------------------------
//  Convert FILETIME to ASN1's UTCTime or GeneralizedTime.
//
//  If 1950 < FILETIME < 2005, then UTCTime is chosen. Otherwise,
//  GeneralizedTime is chosen. GeneralizedTime values shall not include
//  fractional seconds.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1ToChoiceOfTime(
    IN LPFILETIME pFileTime,
    OUT WORD *pwChoice,
    OUT ASN1generalizedtime_t *pGeneralTime,
    OUT ASN1utctime_t *pUtcTime
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;

    if (!FileTimeToSystemTime(pFileTime, &t))
        goto FileTimeToSystemTimeError;
    if (t.wYear < YEARFIRST || t.wYear >= YEARFIRSTGENERALIZED) {
        *pwChoice = PKI_ASN1_GENERALIZED_TIME_CHOICE;
        memset(pGeneralTime, 0, sizeof(*pGeneralTime));
        pGeneralTime->year   = t.wYear;
        pGeneralTime->month  = (ASN1uint8_t) t.wMonth;
        pGeneralTime->day    = (ASN1uint8_t) t.wDay;
        pGeneralTime->hour   = (ASN1uint8_t) t.wHour;
        pGeneralTime->minute = (ASN1uint8_t) t.wMinute;
        pGeneralTime->second = (ASN1uint8_t) t.wSecond;
        pGeneralTime->universal    = TRUE;
    } else {
        *pwChoice = PKI_ASN1_UTC_TIME_CHOICE;
        memset(pUtcTime, 0, sizeof(*pUtcTime));
        pUtcTime->year = (ASN1uint8_t) (t.wYear % 100);
        pUtcTime->month  = (ASN1uint8_t) t.wMonth;
        pUtcTime->day    = (ASN1uint8_t) t.wDay;
        pUtcTime->hour   = (ASN1uint8_t) t.wHour;
        pUtcTime->minute = (ASN1uint8_t) t.wMinute;
        pUtcTime->second = (ASN1uint8_t) t.wSecond;
        pUtcTime->universal    = TRUE;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    *pwChoice = 0;
    memset(pGeneralTime, 0, sizeof(*pGeneralTime));
    memset(pUtcTime, 0, sizeof(*pUtcTime));
    goto CommonReturn;
TRACE_ERROR(FileTimeToSystemTimeError)
}


//+-------------------------------------------------------------------------
//  Convert from ASN1's UTCTime or GeneralizedTime to FILETIME.
//
//  Returns TRUE for a successful conversion.
//
//  Note, in asn1hdr.h, UTCTime has same typedef as GeneralizedTime.
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1FromChoiceOfTime(
    IN WORD wChoice,
    IN ASN1generalizedtime_t *pGeneralTime,
    IN ASN1utctime_t *pUtcTime,
    OUT LPFILETIME pFileTime
    )
{
    if (PKI_ASN1_UTC_TIME_CHOICE == wChoice) {
        return PkiAsn1FromUTCTime(pUtcTime, pFileTime);
    } else
        return PkiAsn1FromGeneralizedTime(pGeneralTime, pFileTime);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\pkiutil\pkialloc.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1998
//
//  File:       pkialloc.cpp
//
//  Contents:   PKI Allocation Functions
//
//  Functions:  PkiAlloc
//
//  History:    19-Jan-98    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

//+-------------------------------------------------------------------------
//  The following functions use the 'C' runtime's allocation functions
//  when DBG is defined.  Otherwise, use LocalAlloc, LocalReAlloc or
//  LocalFree Win32 APIs.
//--------------------------------------------------------------------------

// Calls malloc when DBG is defined. Otherwise, does a
// ZEROINIT LocalAlloc.
LPVOID
WINAPI
PkiAlloc(
    IN UINT cbBytes
    )
{
    LPVOID pv;
#if DBG
    if (NULL == (pv = malloc(cbBytes)))
#else
    if (NULL == (pv = (LPVOID) LocalAlloc(LPTR, cbBytes)))
#endif
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}

// Calls malloc and does a memory clear when DBG is defined.
// Otherwise, does a ZEROINIT LocalAlloc.
LPVOID
WINAPI
PkiZeroAlloc(
    IN UINT cbBytes
    )
{
    LPVOID pv;
#if DBG
    pv = malloc(cbBytes);
    if (pv == NULL)
        SetLastError((DWORD) E_OUTOFMEMORY);
    else
        memset(pv, 0, cbBytes);
#else
    // LPTR (OR includes ZEROINIT)
    pv = (LPVOID) LocalAlloc(LPTR, cbBytes);
    if (pv == NULL)
        SetLastError((DWORD) E_OUTOFMEMORY);
#endif
    return pv;
}

// Calls malloc when DBG is defined. Otherwise, does a
// LocalAlloc without ZEOINIT.
LPVOID
WINAPI
PkiNonzeroAlloc(
    IN UINT cbBytes
    )
{
    LPVOID pv;
#if DBG
    pv = malloc(cbBytes);
#else
    pv = (LPVOID) LocalAlloc(NONZEROLPTR, cbBytes);
#endif
    if (pv == NULL)
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}

LPVOID
WINAPI
PkiRealloc(
    IN LPVOID pvOrg,
    IN UINT cbBytes
    )
{
    LPVOID pv;
#if DBG
    if (NULL == (pv = pvOrg ? realloc(pvOrg, cbBytes) : malloc(cbBytes)))
#else
    if (NULL == (pv = pvOrg ?
            (LPVOID) LocalReAlloc((HLOCAL)pvOrg, cbBytes, LMEM_MOVEABLE) :
            (LPVOID) LocalAlloc(NONZEROLPTR, cbBytes)))
#endif
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}

VOID
WINAPI
PkiFree(
    IN LPVOID pv
    )
{
    if (pv)
#if DBG
        free(pv);
#else
        LocalFree((HLOCAL)pv);
#endif
}

//+-------------------------------------------------------------------------
//  The following functions always use LocalAlloc and LocalFree Win32 APIs.
//--------------------------------------------------------------------------
LPVOID
WINAPI
PkiDefaultCryptAlloc(
    IN UINT cbSize
    )
{
    LPVOID pv;
    if (NULL == (pv = (LPVOID) LocalAlloc(NONZEROLPTR, cbSize)))
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}

VOID
WINAPI
PkiDefaultCryptFree(
    IN LPVOID pv
    )
{
    if (pv)
        LocalFree((HLOCAL) pv);
}

//+-------------------------------------------------------------------------
//  The following data structure's pfnAlloc and pfnFree are set to
//  PkiNonzeroAlloc and PkiFree.
//--------------------------------------------------------------------------
CRYPT_ENCODE_PARA PkiEncodePara = {
    offsetof(CRYPT_ENCODE_PARA, pfnFree) + sizeof(PkiEncodePara.pfnFree),
    PkiNonzeroAlloc,
    PkiFree
};


//+-------------------------------------------------------------------------
//  If pfnAlloc isn't defined, returns PkiDefaultCryptAlloc
//--------------------------------------------------------------------------
PFN_CRYPT_ALLOC
WINAPI
PkiGetEncodeAllocFunction(
    IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara
    )
{
    if (pEncodePara &&
            pEncodePara->cbSize >= offsetof(CRYPT_ENCODE_PARA, pfnAlloc) +
                sizeof(pEncodePara->pfnAlloc) &&
            pEncodePara->pfnAlloc)
        return pEncodePara->pfnAlloc;
    else
        return PkiDefaultCryptAlloc;
}

//+-------------------------------------------------------------------------
//  If pfnFree isn't defined, returns PkiDefaultCryptFree
//--------------------------------------------------------------------------
PFN_CRYPT_FREE
WINAPI
PkiGetEncodeFreeFunction(
    IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara
    )
{
    if (pEncodePara &&
            pEncodePara->cbSize >= offsetof(CRYPT_ENCODE_PARA, pfnFree) +
                sizeof(pEncodePara->pfnFree) &&
            pEncodePara->pfnFree)
        return pEncodePara->pfnFree;
    else
        return PkiDefaultCryptFree;
}

//+-------------------------------------------------------------------------
//  The following data structure's pfnAlloc and pfnFree are set to
//  PkiNonzeroAlloc and PkiFree.
//--------------------------------------------------------------------------
CRYPT_DECODE_PARA PkiDecodePara = {
    offsetof(CRYPT_DECODE_PARA, pfnFree) + sizeof(PkiDecodePara.pfnFree),
    PkiNonzeroAlloc,
    PkiFree
};

//+-------------------------------------------------------------------------
//  If pfnAlloc isn't defined, returns PkiDefaultCryptAlloc
//--------------------------------------------------------------------------
PFN_CRYPT_ALLOC
WINAPI
PkiGetDecodeAllocFunction(
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara
    )
{
    if (pDecodePara &&
            pDecodePara->cbSize >= offsetof(CRYPT_DECODE_PARA, pfnAlloc) +
                sizeof(pDecodePara->pfnAlloc) &&
            pDecodePara->pfnAlloc)
        return pDecodePara->pfnAlloc;
    else
        return PkiDefaultCryptAlloc;
}

//+-------------------------------------------------------------------------
//  If pfnFree isn't defined, returns PkiDefaultCryptFree
//--------------------------------------------------------------------------
PFN_CRYPT_FREE
WINAPI
PkiGetDecodeFreeFunction(
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara
    )
{
    if (pDecodePara &&
            pDecodePara->cbSize >= offsetof(CRYPT_DECODE_PARA, pfnFree) +
                sizeof(pDecodePara->pfnFree) &&
            pDecodePara->pfnFree)
        return pDecodePara->pfnFree;
    else
        return PkiDefaultCryptFree;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\pkiutil\utf8.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1997
//
//  File:       utf8.cpp
//
//  Contents:   WideChar to/from UTF8 APIs
//
//  Functions:  WideCharToUTF8
//              UTF8ToWideChar
//
//  History:    19-Feb-97   philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>
#include "utf8.h"

//+-------------------------------------------------------------------------
//  Maps a wide-character (Unicode) string to a new UTF-8 encoded character
//  string.
//
//  The wide characters are mapped as follows:
//
//  Start   End     Bits    UTF-8 Characters
//  ------  ------  ----    --------------------------------
//  0x0000  0x007F  7       0x0xxxxxxx
//  0x0080  0x07FF  11      0x110xxxxx 0x10xxxxxx
//  0x0800  0xFFFF  16      0x1110xxxx 0x10xxxxxx 0x10xxxxxx
//
//  The parameter and return value semantics are the same as for the
//  Win32 API, WideCharToMultiByte.
//
//  Note, starting with NT 4.0, WideCharToMultiByte supports CP_UTF8. CP_UTF8
//  isn't supported on Win95.
//--------------------------------------------------------------------------
int
WINAPI
WideCharToUTF8(
    IN LPCWSTR lpWideCharStr,
    IN int cchWideChar,
    OUT LPSTR lpUTF8Str,
    IN int cchUTF8
    )
{
    int cchRemainUTF8;

    if (cchUTF8 < 0)
        goto InvalidParameter;
    cchRemainUTF8 = cchUTF8;

    if (cchWideChar < 0)
        cchWideChar = wcslen(lpWideCharStr) + 1;

    while (cchWideChar--) {
        WCHAR wch = *lpWideCharStr++;
        if (wch <= 0x7F) {
            // 7 bits
            cchRemainUTF8 -= 1;
            if (cchRemainUTF8 >= 0)
                *lpUTF8Str++ = (char) wch;
        } else if (wch <= 0x7FF) {
            // 11 bits
            cchRemainUTF8 -= 2;
            if (cchRemainUTF8 >= 0) {
                *lpUTF8Str++ = (char) (0xC0 | ((wch >> 6) & 0x1F));
                *lpUTF8Str++ = (char) (0x80 | (wch & 0x3F));
            }
        } else {
            // 16 bits
            cchRemainUTF8 -= 3;
            if (cchRemainUTF8 >= 0) {
                *lpUTF8Str++ = (char) (0xE0 | ((wch >> 12) & 0x0F));
                *lpUTF8Str++ = (char) (0x80 | ((wch >> 6) & 0x3F));
                *lpUTF8Str++ = (char) (0x80 | (wch & 0x3F));
            }
        }
    }

    if (cchRemainUTF8 >= 0)
        cchUTF8 = cchUTF8 - cchRemainUTF8;
    else if (cchUTF8 == 0)
        cchUTF8 = -cchRemainUTF8;
    else {
        cchUTF8 = 0;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
    }
    return cchUTF8;

InvalidParameter:
    SetLastError(ERROR_INVALID_PARAMETER);
    return 0;
}

//+-------------------------------------------------------------------------
//  Maps a UTF-8 encoded character string to a new wide-character (Unicode)
//  string.
// 
//  See CertWideCharToUTF8 for how the UTF-8 characters are mapped to wide
//  characters.
//
//  The parameter and return value semantics are the same as for the
//  Win32 API, MultiByteToWideChar.
//
//  If the UTF-8 characters don't contain the expected high order bits,
//  ERROR_INVALID_PARAMETER is set and 0 is returned.
//
//  Note, starting with NT 4.0, MultiByteToWideChar supports CP_UTF8. CP_UTF8
//  isn't supported on Win95.
//--------------------------------------------------------------------------
int
WINAPI
UTF8ToWideChar(
    IN LPCSTR lpUTF8Str,
    IN int cchUTF8,
    OUT LPWSTR lpWideCharStr,
    IN int cchWideChar
    )
{
    int cchRemainWideChar;

    if (cchWideChar < 0)
        goto InvalidParameter;
    cchRemainWideChar = cchWideChar;

    if (cchUTF8 < 0)
        cchUTF8 = strlen(lpUTF8Str) + 1;

    while (cchUTF8--) {
        char ch = *lpUTF8Str++;
        WCHAR wch;
        if (0 == (ch & 0x80))
            // 7 bits, 1 byte
            wch = (WCHAR) ch;
        else if (0xC0 == (ch & 0xE0)) {
            // 11 bits, 2 bytes
            char ch2;

            if (--cchUTF8 < 0)
                goto InvalidParameter;
            ch2 = *lpUTF8Str++;
            if (0x80 != (ch2 & 0xC0))
                goto InvalidParameter;
            wch = (((WCHAR) ch & 0x1F) << 6) | ((WCHAR) ch2 & 0x3F);
        } else if (0xE0 == (ch & 0xF0)) {
            // 16 bits, 3 bytes
            char ch2;
            char ch3;
            cchUTF8 -= 2;
            if (cchUTF8 < 0)
                goto InvalidParameter;
            ch2 = *lpUTF8Str++;
            ch3 = *lpUTF8Str++;
            if (0x80 != (ch2 & 0xC0) || 0x80 != (ch3 & 0xC0))
                goto InvalidParameter;
            wch = (((WCHAR) ch & 0x0F) << 12) | (((WCHAR) ch2 & 0x3F) << 6) |
                ((WCHAR) ch3 & 0x3F);
        } else
            goto InvalidParameter;

        if (--cchRemainWideChar >= 0)
            *lpWideCharStr++ = wch;
    }

    if (cchRemainWideChar >= 0)
        cchWideChar = cchWideChar - cchRemainWideChar;
    else if (cchWideChar == 0)
        cchWideChar = -cchRemainWideChar;
    else {
        cchWideChar = 0;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
    }
    return cchWideChar;

InvalidParameter:
    SetLastError(ERROR_INVALID_PARAMETER);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\pkiutil\reghkcu.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    reghkcu.c

Abstract:

    This module implements functionality to correctly access the pre-defined
    registry key HKEY_CURRENT_USER.

Author:

    Scott Field (sfield)    03-Jul-97

--*/

#include <windows.h>

typedef ULONG REGSAM;

#include "crtem.h"
#include "unicode.h"
#include "xdbg.h"

#define TEXTUAL_SID_LOCAL_SYSTEM    L"S-1-5-18"

BOOL
GetTextualSidHKCU(
    IN      PSID    pSid,           // binary Sid
    IN      LPWSTR  TextualSid,     // buffer for Textual representaion of Sid
    IN  OUT LPDWORD pcchTextualSid  // required/provided TextualSid buffersize
    );

BOOL
GetTokenUserSidHKCU(
    IN      HANDLE  hToken,     // token to query
    IN  OUT PSID    *ppUserSid  // resultant user sid
    );


static LONG GetStatus()
{
    DWORD dwErr = GetLastError();
    if (ERROR_SUCCESS == dwErr)
        return ERROR_INVALID_DATA;
    else
        return (LONG) dwErr;
}

LONG
WINAPI
RegOpenHKCU(
    HKEY *phKeyCurrentUser
    )
{
    return RegOpenHKCUEx(phKeyCurrentUser, 0);
}

#ifndef CE_BUILD
LONG
WINAPI
RegOpenHKCUEx(
    HKEY *phKeyCurrentUser,
    DWORD dwFlags
    )
{
    WCHAR wszFastBuffer[256];
    LPWSTR wszSlowBuffer = NULL;
    LPWSTR wszTextualSid;
    DWORD cchTextualSid;

    LONG lRet = ERROR_SUCCESS;

    *phKeyCurrentUser = NULL;

    //
    // Win95: just return HKEY_CURRENT_USER, as we don't have
    // multiple security contexts on that platform.
    //

    if(!FIsWinNT()) {
        *phKeyCurrentUser = HKEY_CURRENT_USER;
        return ERROR_SUCCESS;
    }

    //
    // WinNT: first, map the binary Sid associated with the
    // current security context to an textual Sid.
    //

    wszTextualSid = wszFastBuffer;
    cchTextualSid = sizeof(wszFastBuffer) / sizeof(WCHAR);

    if(!GetUserTextualSidHKCU(wszTextualSid, &cchTextualSid)) {
        if(GetLastError() != ERROR_INSUFFICIENT_BUFFER)
            return GetStatus();

        //
        // try again with larger buffer.
        //

        wszSlowBuffer = (LPWSTR)malloc(cchTextualSid * sizeof(WCHAR));
        if(wszSlowBuffer == NULL)
            return GetStatus();

        wszTextualSid = wszSlowBuffer;
        if(!GetUserTextualSidHKCU(wszTextualSid, &cchTextualSid)) {
            free(wszSlowBuffer);
            return GetStatus();
        }
    }

    //
    // next, try to open the registry key below HKEY_USERS
    // that corresponds to the textual Sid.
    //

    lRet = RegOpenKeyExW(
                    HKEY_USERS,
                    wszTextualSid,
                    0,      // dwOptions
                    MAXIMUM_ALLOWED,
                    phKeyCurrentUser
                    );

    if(lRet != ERROR_SUCCESS) {

        if (dwFlags & REG_HKCU_DISABLE_DEFAULT_FLAG)
            lRet = ERROR_FILE_NOT_FOUND;
        else if (0 == (dwFlags & REG_HKCU_LOCAL_SYSTEM_ONLY_DEFAULT_FLAG) ||
                0 == wcscmp(TEXTUAL_SID_LOCAL_SYSTEM, wszTextualSid)) {
            //
            // If that failed, fall back to HKEY_USERS\.Default.
            // Note: this is correct behavior with respect to the
            // rest of the system, eg, Local System security context
            // has no registry hive loaded by default
            //

            lRet = RegOpenKeyExW(
                            HKEY_USERS,
                            L".Default",
                            0,      // dwOptions
                            MAXIMUM_ALLOWED,
                            phKeyCurrentUser
                            );
        }
    }


    if(wszSlowBuffer)
        free(wszSlowBuffer);

    return lRet;
}
#else
LONG
WINAPI
RegOpenHKCUEx(
    HKEY *phKeyCurrentUser,
    DWORD dwFlags
    )
{
    //
    // WinCE: just return HKEY_CURRENT_USER, as we don't have
    // multiple security contexts on that platform.
    //

#ifndef _XBOX
    *phKeyCurrentUser = HKEY_CURRENT_USER;
#else
    ASSERT( !"RegOpenHKCUEx" );
#endif
    return ERROR_SUCCESS;
}
#endif // CE_BUILD


LONG
WINAPI
RegCloseHKCU(
    HKEY hKeyCurrentUser
    )
{
    LONG lRet = ERROR_SUCCESS;

#ifndef _XBOX
    if( hKeyCurrentUser != NULL && hKeyCurrentUser != HKEY_CURRENT_USER )
        lRet = RegCloseKey( hKeyCurrentUser );
#else
    ASSERT( !"RegCloseHKCU" );
#endif

    return lRet;
}


#ifndef CE_BUILD
BOOL
WINAPI
GetUserTextualSidHKCU(
    IN      LPWSTR  wszTextualSid,
    IN  OUT LPDWORD pcchTextualSid
    )
{
    HANDLE hToken;
    PSID pSidUser = NULL;
    BOOL fSuccess = FALSE;

    //
    // first, attempt to look at the thread token.  If none exists,
    // which is true if the thread is not impersonating, try the
    // process token.
    //

    if(!OpenThreadToken(
                GetCurrentThread(),
                TOKEN_QUERY,
                TRUE,
                &hToken
                ))
    {
        if(GetLastError() != ERROR_NO_TOKEN)
            return FALSE;

        if(!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
            return FALSE;
    }

    fSuccess = GetTokenUserSidHKCU(hToken, &pSidUser);

    CloseHandle(hToken);

    if(fSuccess) {

        //
        // obtain the textual representaion of the Sid
        //

        fSuccess = GetTextualSidHKCU(
                        pSidUser,       // user binary Sid
                        wszTextualSid,  // buffer for TextualSid
                        pcchTextualSid  // required/result buffer size in chars (including NULL)
                        );
    }

    if(pSidUser)
        free(pSidUser);

    return fSuccess;
}

BOOL
GetTextualSidHKCU(
    IN      PSID    pSid,           // binary Sid
    IN      LPWSTR  TextualSid,     // buffer for Textual representaion of Sid
    IN  OUT LPDWORD pcchTextualSid  // required/provided TextualSid buffersize
    )
{
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD dwSubAuthorities;
    DWORD dwCounter;
    DWORD cchSidSize;


    //
    // validate Sid validity
    //

    if(!IsValidSid(pSid))
        return FALSE;

    //
    // obtain SidIdentifierAuthority
    //

    psia = GetSidIdentifierAuthority(pSid);

    //
    // obtain sidsubauthority count
    //

    dwSubAuthorities = *GetSidSubAuthorityCount(pSid);

    //
    // compute buffer length in chars (conservative guess)
    // S-SID_REVISION- + identifierauthority- + subauthorities- + NULL
    //
    cchSidSize = (15 + 12 + (12 * dwSubAuthorities) + 1) ;

    //
    // check provided buffer length.
    // If not large enough, indicate proper size and setlasterror
    //
    if(*pcchTextualSid < cchSidSize) {
        *pcchTextualSid = cchSidSize;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    //
    // prepare S-SID_REVISION-
    //
    cchSidSize = wsprintfW(TextualSid, L"S-%lu-", SID_REVISION );

    //
    // prepare SidIdentifierAuthority
    //
    if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) ) {
        cchSidSize += wsprintfW(TextualSid + cchSidSize,
                    L"0x%02hx%02hx%02hx%02hx%02hx%02hx",
                    (USHORT)psia->Value[0],
                    (USHORT)psia->Value[1],
                    (USHORT)psia->Value[2],
                    (USHORT)psia->Value[3],
                    (USHORT)psia->Value[4],
                    (USHORT)psia->Value[5]);
    } else {
        cchSidSize += wsprintfW(TextualSid + cchSidSize,
                    L"%lu",
                    (ULONG)(psia->Value[5]      )   +
                    (ULONG)(psia->Value[4] <<  8)   +
                    (ULONG)(psia->Value[3] << 16)   +
                    (ULONG)(psia->Value[2] << 24)   );
    }

    //
    // loop through SidSubAuthorities
    //
    for (dwCounter = 0 ; dwCounter < dwSubAuthorities ; dwCounter++) {
        cchSidSize += wsprintfW(TextualSid + cchSidSize,
            L"-%lu", *GetSidSubAuthority(pSid, dwCounter) );
    }

    //
    // tell caller how many chars copied, including terminal NULL
    //

    *pcchTextualSid = cchSidSize + 1;

    return TRUE;
}

BOOL
GetTokenUserSidHKCU(
    IN      HANDLE  hToken,     // token to query
    IN  OUT PSID    *ppUserSid  // resultant user sid
    )
/*++

    This function queries the access token specified by the
    hToken parameter, and returns an allocated copy of the
    TokenUser information on success.

    The access token specified by hToken must be opened for
    TOKEN_QUERY access.

    On success, the return value is TRUE.  The caller is
    responsible for freeing the resultant UserSid via a call
    to free().

    On failure, the return value is FALSE.  The caller does
    not need to free any buffer.

--*/
{
    BYTE FastBuffer[256];
    LPBYTE SlowBuffer = NULL;
    PTOKEN_USER ptgUser;
    DWORD cbBuffer;
    BOOL fSuccess = FALSE;

    *ppUserSid = NULL;

    //
    // try querying based on a fast stack based buffer first.
    //

    ptgUser = (PTOKEN_USER)FastBuffer;
    cbBuffer = sizeof(FastBuffer);

    fSuccess = GetTokenInformation(
                    hToken,    // identifies access token
                    TokenUser, // TokenUser info type
                    ptgUser,   // retrieved info buffer
                    cbBuffer,  // size of buffer passed-in
                    &cbBuffer  // required buffer size
                    );

    if(!fSuccess) {

        if(GetLastError() == ERROR_INSUFFICIENT_BUFFER) {

            //
            // try again with the specified buffer size
            //

            SlowBuffer = (LPBYTE)malloc(cbBuffer);

            if(SlowBuffer != NULL) {
                ptgUser = (PTOKEN_USER)SlowBuffer;

                fSuccess = GetTokenInformation(
                                hToken,    // identifies access token
                                TokenUser, // TokenUser info type
                                ptgUser,   // retrieved info buffer
                                cbBuffer,  // size of buffer passed-in
                                &cbBuffer  // required buffer size
                                );
            }
        }
    }

    //
    // if we got the token info successfully, copy the
    // relevant element for the caller.
    //

    if(fSuccess) {

        DWORD cbSid;

        // reset to assume failure
        fSuccess = FALSE;

        cbSid = GetLengthSid(ptgUser->User.Sid);

        *ppUserSid = malloc( cbSid );

        if(*ppUserSid != NULL) {
            fSuccess = CopySid(cbSid, *ppUserSid, ptgUser->User.Sid);
        }
    }

    if(!fSuccess) {
        if(*ppUserSid) {
            free(*ppUserSid);
            *ppUserSid = NULL;
        }
    }

    if(SlowBuffer)
        free(SlowBuffer);

    return fSuccess;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\pkiutil\reg.cpp ===
#include "global.hxx"
#include "xwinreg.h"

//
// FIsWinNT: check OS type on x86.  On non-x86, assume WinNT
//
#ifdef UNDER_CE
BOOL WINAPI FIsWinNT(void) {
    return(FALSE);
}
#else 
#ifdef _M_IX86

BOOL WINAPI FIsWinNT(void) {

    static BOOL fIKnow = FALSE;
    static BOOL fIsWinNT = FALSE;

    OSVERSIONINFO osVer;

    if(fIKnow)
        return(fIsWinNT);

    memset(&osVer, 0, sizeof(OSVERSIONINFO));
    osVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if( GetVersionEx(&osVer) )
        fIsWinNT = (osVer.dwPlatformId == VER_PLATFORM_WIN32_NT);

    // even on an error, this is as good as it gets
    fIKnow = TRUE;

   return(fIsWinNT);
}

#else

BOOL WINAPI FIsWinNT(void) {
    return(TRUE);
}

#endif
#endif // UNDER_CE
BOOL
WINAPI
FIsWinNT5(
    VOID
    )
{
    return(TRUE);
}

// make MBCS from Unicode string
//
// Include parameters specifying the length of the input wide character
// string and return number of bytes converted. An input length of -1 indicates
// null terminated.
//
// This extended version was added to handle REG_MULTI_SZ which contains
// multiple null terminated strings.
BOOL WINAPI MkMBStrEx(PBYTE pbBuff, DWORD cbBuff, LPCWSTR wsz, int cchW,
    char ** pszMB, int *pcbConverted) {

    int   cbConverted;

    // sfield: don't bring in crt for assert.  you get free assert via
    // an exception if these are null
//    assert(pszMB != NULL);
    *pszMB = NULL;
//    assert(pcbConverted != NULL);
    *pcbConverted = 0;
    if(wsz == NULL)
        return(TRUE);

    // how long is the mb string
    cbConverted = WideCharToMultiByte(  0,
                                        0,
                                        wsz,
                                        cchW,
                                        NULL,
                                        0,
                                        NULL,
                                        NULL);
    if (cbConverted <= 0)
        return(FALSE);

    // get a buffer long enough
    if(pbBuff != NULL  &&  (DWORD) cbConverted <= cbBuff)
        *pszMB = (char *) pbBuff;
    else
        *pszMB = (char *) malloc(cbConverted);

    if(*pszMB == NULL) {
        SetLastError(ERROR_OUTOFMEMORY);
        return(FALSE);
    }

    // now convert to MB
    *pcbConverted = WideCharToMultiByte(0,
                        0,
                        wsz,
                        cchW,
                        *pszMB,
                        cbConverted,
                        NULL,
                        NULL);
    return(TRUE);
}

// make MBCS from Unicode string
BOOL WINAPI MkMBStr(PBYTE pbBuff, DWORD cbBuff, LPCWSTR wsz, char ** pszMB) {
    int cbConverted;
    return MkMBStrEx(pbBuff, cbBuff, wsz, -1, pszMB, &cbConverted);
}

void WINAPI FreeMBStr(PBYTE pbBuff, char * szMB) {

    if((szMB != NULL) &&  (pbBuff != (PBYTE)szMB))
        free(szMB);
}

// #endif      // _M_IX86

// make Unicode string from MBCS
LPWSTR WINAPI MkWStr(const char * szMB) {

    LPWSTR wsz = NULL;
    int   cbConverted;

    if(szMB == NULL)
        goto Ret;

    // how long is the unicode string
    if (0 >= (cbConverted = MultiByteToWideChar(  0,
                                        0,
                                        szMB,
                                        -1,
                                        NULL,
                                        0)))
        goto Ret;

    // get a buffer long enough
    wsz = (LPWSTR) malloc(cbConverted * sizeof(WCHAR));

    if(wsz == NULL) {
        SetLastError(ERROR_OUTOFMEMORY);
        goto Ret;
    }

    // now convert to MB
    MultiByteToWideChar(0,
                        0,
                        szMB,
                        -1,
                        wsz,
                        cbConverted);
Ret:
    return(wsz);
}

void WINAPI FreeWStr(LPWSTR wsz) {

    if(wsz != NULL)
        free(wsz);
}

#ifndef CE_BUILD
#ifdef _M_IX86

LONG WINAPI RegCreateKeyExU (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD Reserved,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    ) {

    BYTE rgb1[_MAX_PATH];
    BYTE rgb2[_MAX_PATH];
    char *  szSubKey = NULL;
    char *  szClass = NULL;
    LONG    err;

    if(FIsWinNT())
        return( RegCreateKeyExW (
            hKey,
            lpSubKey,
            Reserved,
            lpClass,
            dwOptions,
            samDesired,
            lpSecurityAttributes,
            phkResult,
            lpdwDisposition
            ));

    err = FALSE;
    if(
        MkMBStr(rgb1, _MAX_PATH, lpSubKey, &szSubKey)    &&
        MkMBStr(rgb2, _MAX_PATH, lpClass,  &szClass)     )
        err = RegCreateKeyExA (
               hKey,
               szSubKey,
               Reserved,
               szClass,
               dwOptions,
               samDesired,
               lpSecurityAttributes,
               phkResult,
               lpdwDisposition
               );

    FreeMBStr(rgb1, szSubKey);
    FreeMBStr(rgb2, szClass);

    return(err);
}

LONG WINAPI RegDeleteKeyU (
    HKEY hKey,
    LPCWSTR lpSubKey
    ) {

    BYTE rgb1[_MAX_PATH];
    char *  szSubKey = NULL;
    LONG    err;

    if(FIsWinNT())
        return( RegDeleteKeyW (
            hKey,
            lpSubKey
            ));

    err = FALSE;
    if(MkMBStr(rgb1, _MAX_PATH, lpSubKey, &szSubKey))
        err = RegDeleteKeyA (
               hKey,
               szSubKey
               );

    FreeMBStr(rgb1, szSubKey);

    return(err);
}

LONG WINAPI RegEnumKeyExU (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
   ) {

    char rgch[_MAX_PATH];
    char *  szKeyName;
    DWORD cbKeyName;

    char rgch1[_MAX_PATH];
    char *  szClassName;
    DWORD cbClassName;

    int     cchW;
    LONG    err;

    if(FIsWinNT())
        return( RegEnumKeyExW (
                hKey,
                dwIndex,
                lpName,
                lpcbName,
                lpReserved,
                lpClass,
                lpcbClass,
                lpftLastWriteTime
                ));

    szKeyName = rgch;
    cbKeyName = sizeof(rgch);
    szClassName = rgch1;
    cbClassName = sizeof(rgch1);

    err = RegEnumKeyExA (
        hKey,
        dwIndex,
        szKeyName,
        &cbKeyName,
        lpReserved,
        szClassName,
        &cbClassName,
        lpftLastWriteTime
        );
    if((err != ERROR_SUCCESS) && (err != ERROR_INSUFFICIENT_BUFFER))
        return err;
    err = ERROR_SUCCESS;

    cbKeyName++;                      // count the NULL terminator
    cbClassName++;                    // count the NULL terminator
    if ((sizeof(rgch) < cbKeyName) || (sizeof(rgch1) < cbClassName)) {
        szKeyName = (char *) malloc(cbKeyName);
        if(!szKeyName)
            return ERROR_OUTOFMEMORY;

        szClassName = (char *) malloc(cbClassName);
	if(!szClassName) {
	    free(szKeyName);
	    return ERROR_OUTOFMEMORY;
	}

        err = RegEnumKeyExA (
            hKey,
            dwIndex,
            szKeyName,
            &cbKeyName,
            lpReserved,
            szClassName,
            &cbClassName,
            lpftLastWriteTime
            );
        cbKeyName++;                    // count the NULL terminator
        cbClassName++;                  // count the NULL terminator
    }

    if(err == ERROR_SUCCESS) {
        cchW = MultiByteToWideChar(
                            0,                      // codepage
                            0,                      // dwFlags
                            szKeyName,
                            cbKeyName,
                            lpName,
                            *lpcbName);
        if(cchW == 0)
            err = GetLastError();
        else
            *lpcbName = cchW - 1; // does not include NULL
    }

    if(szKeyName != rgch)
        free(szKeyName);

    if(err == ERROR_SUCCESS) {

        //
        // it's legal for lpClass/lpcbClass to be NULL, so only copy if they are not NOT
        //

        if(lpClass != NULL) {
            // note: RegEnumKeyEx specifies that lpcbClass can only be NULL
            // if lpClass is NULL, so the correct behavior is to fault if
            // lpClass is non-null and lpcbClass is NULL; this behavior is
            // does happen here.
            //
            cchW = MultiByteToWideChar(
                            0,                      // codepage
                            0,                      // dwFlags
                            szClassName,
                            cbClassName,
                            lpClass,
                            *lpcbClass);
            if(cchW == 0)
                err = GetLastError();
        }

        if(lpcbClass != NULL)
            *lpcbClass = cbClassName - 1; // does not include NULL
    }

    if(szClassName != rgch1)
        free(szClassName);

    return err;
}

static LONG WINAPI ConvertRegValue (
    DWORD dwType,
    LPBYTE pbInData,
    DWORD cbInData,
    LPBYTE pbOutData,
    LPDWORD pcbOutData
    ) {

    LONG err = ERROR_SUCCESS;
    DWORD cbOrigOutData = *pcbOutData;

    if (0 == cbInData)
        *pcbOutData = 0;
    else if (REG_SZ == dwType || REG_EXPAND_SZ == dwType ||
            REG_MULTI_SZ == dwType) {
        int cchW;
        // First get length needed for wide characters
        cchW = MultiByteToWideChar(
                    0,                      // codepage
                    0,                      // dwFlags
                    (LPCSTR) pbInData,
                    cbInData,
                    NULL,                   // lpWideCharStr
                    0);                     // cchWideChar
        *pcbOutData = cchW * sizeof(WCHAR);
        if(cchW == 0)
            err = GetLastError();
        else if (pbOutData) {
            if (cbOrigOutData < *pcbOutData)
                err = ERROR_MORE_DATA;
            else
                // Convert to Unicode data
                MultiByteToWideChar(
                    0,                      // codepage
                    0,                      // dwFlags
                    (LPCSTR) pbInData,
                    cbInData,
                    (LPWSTR) pbOutData,
                    cchW);
        }
    } else {
        // Copy to output
        *pcbOutData = cbInData;
        if (pbOutData) {
            if (cbOrigOutData < cbInData)
                err = ERROR_MORE_DATA;
            else
                memcpy(pbOutData, pbInData, cbInData);
        }
    }

    return err;
}

#define MAX_REG_VALUE_DATA  256

LONG WINAPI RegEnumValueU (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpValueName,
    LPDWORD lpcchValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    ) {

    char rgch[_MAX_PATH];
    char *  szValueName;
    DWORD   cbValueName;
    DWORD   dwType;
    LONG    err;

    BYTE rgbData[MAX_REG_VALUE_DATA];
    BYTE *pbData;
    DWORD cbData;

    if(FIsWinNT())
        return( RegEnumValueW (
                hKey,
                dwIndex,
                lpValueName,
                lpcchValueName,
                lpReserved,
                lpType,
                lpData,
                lpcbData
                ));

    szValueName = rgch;
    cbValueName = sizeof(rgch);
    pbData = rgbData;
    cbData = sizeof(rgbData);
    err = RegEnumValueA (
        hKey,
        dwIndex,
        szValueName,
        &cbValueName,
        lpReserved,
        &dwType,
        pbData,
        &cbData
        );
    if (lpType)
        *lpType = dwType;
    if((err != ERROR_SUCCESS) && (err != ERROR_INSUFFICIENT_BUFFER) &&
            (err != ERROR_MORE_DATA))
        goto ErrorReturn;

    err = ERROR_SUCCESS;

    cbValueName++;                      // count the NULL terminator
    if (sizeof(rgch) < cbValueName || sizeof(rgbData) < cbData) {
        if (sizeof(rgch) < cbValueName) {
            szValueName = (char *) malloc( cbValueName);
            if(!szValueName) {
                err = ERROR_OUTOFMEMORY;
                goto ErrorReturn;
            }
        }
        if (sizeof(rgbData) < cbData) {
            pbData = (BYTE *) malloc(cbData);
            if(!pbData) {
                err = ERROR_OUTOFMEMORY;
                goto ErrorReturn;
            }
        }
        err = RegEnumValueA (
            hKey,
            dwIndex,
            szValueName,
            &cbValueName,
            lpReserved,
            lpType,
            pbData,
            &cbData
            );
        cbValueName++;                  // count the NULL terminator
    }

    if (err == ERROR_SUCCESS) {
        int     cchW;
        cchW = MultiByteToWideChar(
                            0,                      // codepage
                            0,                      // dwFlags
                            szValueName,
                            cbValueName,
                            lpValueName,
                            lpValueName ? *lpcchValueName : 0);
        if(cchW == 0)
            err = GetLastError();
        else
            *lpcchValueName = cchW - 1; // does not include NULL
    } else
        *lpcchValueName = 0;

    if (err == ERROR_SUCCESS)
        err = ConvertRegValue (
            dwType,
            pbData,
            cbData,
            lpData,
            lpcbData);
    else
        *lpcbData = 0;

CommonReturn:
    if(szValueName != rgch && szValueName)
        free(szValueName);
    if(pbData != rgbData && pbData)
        free(pbData);
    return err;
ErrorReturn:
    *lpcchValueName = 0;
    *lpcbData = 0;
    goto CommonReturn;
}


LONG RegDeleteValueU (
    HKEY hKey,
    LPCWSTR lpValueName
    ) {

    BYTE rgb[_MAX_PATH];
    char *  szValueName;
    LONG    err;

    if(FIsWinNT())
        return(RegDeleteValueW (
            hKey,
            lpValueName
            ));

    err = FALSE;
    if(MkMBStr(rgb, _MAX_PATH, lpValueName, &szValueName))
        err = RegDeleteValueA (
            hKey,
            szValueName
            );

    FreeMBStr(rgb, szValueName);

    return(err);
}

LONG RegQueryValueExU(
    HKEY hKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    ) {

    BYTE    rgb[_MAX_PATH];
    char *  szValueName = NULL;
    LONG    err;
    DWORD   dwType;

    BYTE rgbData[MAX_REG_VALUE_DATA];
    BYTE *pbData;
    DWORD cbData;

    if(FIsWinNT())
    return(RegQueryValueExW (
            hKey,
            lpValueName,
            lpReserved,
            lpType,
            lpData,
            lpcbData
            ));

    pbData = rgbData;
    cbData = sizeof(rgbData);

    if(MkMBStr(rgb, _MAX_PATH, lpValueName, &szValueName))
        err = RegQueryValueExA (
            hKey,
            szValueName,
            lpReserved,
            &dwType,
            pbData,
            &cbData
            );
    else {
        err = ERROR_OUTOFMEMORY;
        goto ErrorReturn;
    }


    if (lpType)
        *lpType = dwType;

    if((err != ERROR_SUCCESS) && (err != ERROR_INSUFFICIENT_BUFFER) &&
            (err != ERROR_MORE_DATA))
        goto ErrorReturn;
    err = ERROR_SUCCESS;

    if (sizeof(rgbData) < cbData) {
        pbData = (BYTE *) malloc(cbData);
        if(!pbData) {
            err = ERROR_OUTOFMEMORY;
            goto ErrorReturn;
        }
        err = RegQueryValueExA (
            hKey,
            szValueName,
            lpReserved,
            &dwType,
            pbData,
            &cbData
            );
    }

    if (err == ERROR_SUCCESS)
        err = ConvertRegValue (
            dwType,
            pbData,
            cbData,
            lpData,
            lpcbData);
    else
        *lpcbData = 0;

CommonReturn:
    FreeMBStr(rgb, szValueName);
    if(pbData != rgbData && pbData)
        free(pbData);
    return err;
ErrorReturn:
    *lpcbData = 0;
    goto CommonReturn;
}

LONG WINAPI RegSetValueExU (
    HKEY hKey,
    LPCWSTR lpValueName,
    DWORD Reserved,
    DWORD dwType,
    CONST BYTE* lpData,
    DWORD cbData
    ) {

    BYTE rgb1[_MAX_PATH];
    char *  szValueName;
    LONG    err;

    if(FIsWinNT())
        return(RegSetValueExW (
            hKey,
            lpValueName,
            Reserved,
            dwType,
            lpData,
            cbData
            ));

    err = ERROR_OUTOFMEMORY;
    if(MkMBStr(rgb1, _MAX_PATH, lpValueName, &szValueName))
    {
        // convert the data to ascii if necessary
        if (0 != cbData / sizeof(WCHAR) &&
                (REG_SZ == dwType || REG_EXPAND_SZ == dwType ||
                    REG_MULTI_SZ == dwType))
        {
            char *  szData;
            int cbConverted;

            if(MkMBStrEx(NULL, 0, (LPWSTR)lpData, cbData/sizeof(WCHAR),
                &szData, &cbConverted))
            {
                err = RegSetValueExA (
                    hKey,
                    szValueName,
                    Reserved,
                    dwType,
                    (BYTE*)szData,
                    cbConverted
                    );
                FreeMBStr(NULL, szData);
            }
        }
        else
        {
            err = RegSetValueExA (
                hKey,
                szValueName,
                Reserved,
                dwType,
                lpData,
                cbData
                );
        }
        FreeMBStr(rgb1, szValueName);
    }


    return(err);
}

LONG WINAPI RegQueryInfoKeyU (
    HKEY hKey,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    LPDWORD lpReserved,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcbMaxClassLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime
    ) {

    BYTE rgb[_MAX_PATH];
    char *  szClass;
    LONG    err;

    if(FIsWinNT())
        return( RegQueryInfoKeyW (
            hKey,
            lpClass,
            lpcbClass,
            lpReserved,
            lpcSubKeys,
            lpcbMaxSubKeyLen,
            lpcbMaxClassLen,
            lpcValues,
            lpcbMaxValueNameLen,
            lpcbMaxValueLen,
            lpcbSecurityDescriptor,
            lpftLastWriteTime
            ));

    err = FALSE;
    if(MkMBStr(rgb, _MAX_PATH, lpClass, &szClass))
        err =  RegQueryInfoKeyA (
            hKey,
            szClass,
            lpcbClass,
            lpReserved,
            lpcSubKeys,
            lpcbMaxSubKeyLen,
            lpcbMaxClassLen,
            lpcValues,
            lpcbMaxValueNameLen,
            lpcbMaxValueLen,
            lpcbSecurityDescriptor,
            lpftLastWriteTime
            );
    if (lpcbMaxValueLen)
        // Need to double for converting to unicode characters.
        *lpcbMaxValueLen = *lpcbMaxValueLen * 2;

    FreeMBStr(rgb, szClass);

    return(err);
}

LONG WINAPI RegOpenKeyExU(
    HKEY hKey,  // handle of open key
    LPCWSTR lpSubKey,   // address of name of subkey to open
    DWORD ulOptions,    // reserved
    REGSAM samDesired,  // security access mask
    PHKEY phkResult     // address of handle of open key
   ) {

    BYTE rgb1[_MAX_PATH];
    char *  szSubKey = NULL;
    LONG    err;

    if(FIsWinNT())
        return( RegOpenKeyExW(
            hKey,
            lpSubKey,
            ulOptions,
            samDesired,
            phkResult
            ));

    err = FALSE;
    if(MkMBStr(rgb1, _MAX_PATH, lpSubKey, &szSubKey) )
        err = RegOpenKeyExA(
            hKey,
            szSubKey,
            ulOptions,
            samDesired,
            phkResult);

    FreeMBStr(rgb1, szSubKey);

    return(err);
}

LONG WINAPI RegConnectRegistryU (
    LPWSTR lpMachineName,
    HKEY hKey,
    PHKEY phkResult
    ) {

    BYTE rgb1[_MAX_PATH];
    char *  szMachineName = NULL;
    LONG    err;

    if(FIsWinNT())
        return( RegConnectRegistryW(
            lpMachineName,
            hKey,
            phkResult
            ));

    err = FALSE;
    if(MkMBStr(rgb1, _MAX_PATH, lpMachineName, &szMachineName) )
        err = RegConnectRegistryA(
            szMachineName,
            hKey,
            phkResult);

    FreeMBStr(rgb1, szMachineName);

    return(err);
}


#endif      // _M_IX86
#endif 		// CE_BUILD


LONG WINAPI RegCreateHKCUKeyExU (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD Reserved,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    ) {

    if ((hKey != HKEY_CURRENT_USER) || !(FIsWinNT()))
    {
        return(RegCreateKeyExU(hKey, lpSubKey, Reserved, lpClass, dwOptions,
                               samDesired, lpSecurityAttributes, phkResult,
                               lpdwDisposition));
    }

    HKEY    hCurUser;
    LONG    err;

    if ((err = RegOpenHKCU(&hCurUser)) != ERROR_SUCCESS)
    {
        return(err);
    }

    err = RegCreateKeyExW(hCurUser, lpSubKey, Reserved, lpClass,  dwOptions,
                              samDesired, lpSecurityAttributes, phkResult,
                              lpdwDisposition);
    RegCloseHKCU(hCurUser);
    return(err);
}

#ifndef CE_BUILD
LONG WINAPI RegCreateHKCUKeyExA (
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD Reserved,
    LPSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    )
{
    if ((hKey != HKEY_CURRENT_USER) || !(FIsWinNT()))
    {
        return(RegCreateKeyExA(hKey, lpSubKey, Reserved, lpClass, dwOptions,
                               samDesired, lpSecurityAttributes, phkResult,
                               lpdwDisposition));
    }

    HKEY    hCurUser;
    LONG    err;

    if ((err = RegOpenHKCU(&hCurUser)) != ERROR_SUCCESS)
    {
        return(err);
    }

    err = RegCreateKeyExA(hCurUser, lpSubKey, Reserved, lpClass,  dwOptions,
                              samDesired, lpSecurityAttributes, phkResult,
                              lpdwDisposition);
    RegCloseHKCU(hCurUser);
    return(err);
}
#endif // CE_BUILD

LONG WINAPI RegOpenHKCUKeyExU(
    HKEY hKey,  // handle of open key
    LPCWSTR lpSubKey,   // address of name of subkey to open
    DWORD ulOptions,    // reserved
    REGSAM samDesired,  // security access mask
    PHKEY phkResult     // address of handle of open key
   ) {

    if ((hKey != HKEY_CURRENT_USER) || !(FIsWinNT()))
    {
        return(RegOpenKeyExU(hKey, lpSubKey, ulOptions,
                               samDesired, phkResult));
    }

    HKEY    hCurUser;
    LONG    err;

    if ((err = RegOpenHKCU(&hCurUser)) != ERROR_SUCCESS)
    {
        return(err);
    }


    err = RegOpenKeyExW(hCurUser, lpSubKey, ulOptions, samDesired, phkResult);

    RegCloseHKCU(hCurUser);

    return(err);
}

#ifndef CE_BUILD
LONG WINAPI RegOpenHKCUKeyExA(
    HKEY hKey,  // handle of open key
    LPCSTR lpSubKey,    // address of name of subkey to open
    DWORD ulOptions,    // reserved
    REGSAM samDesired,  // security access mask
    PHKEY phkResult     // address of handle of open key
   ) {

    if ((hKey != HKEY_CURRENT_USER) || !(FIsWinNT()))
    {
        return(RegOpenKeyExA(hKey, lpSubKey, ulOptions,
                               samDesired, phkResult));
    }

    HKEY    hCurUser;
    LONG    err;

    if ((err = RegOpenHKCU(&hCurUser)) != ERROR_SUCCESS)
    {
        return(err);
    }

    err = RegOpenKeyExA(hCurUser, lpSubKey, ulOptions, samDesired, phkResult);

    RegCloseHKCU(hCurUser);

    return(err);
}
#endif // CE_BUILD
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\rsabase\csprc.h ===
// 
// Used by resource.rc
//
#define IDS_RSA_SIG_DESCR       1
#define IDS_RSA_EXCH_DESCR      2
#define IDS_IMPORT_SIMPLE       3
#define IDS_SIGNING_E           4
#define IDS_CREATE_RSA_SIG      5
#define IDS_CREATE_RSA_EXCH     6
#define IDS_DSS_SIG_DESCR       7
#define IDS_DSS_EXCH_DESCR      8
#define IDS_CREATE_DSS_SIG      9
#define IDS_CREATE_DH_EXCH      10
#define IDS_IMPORT_E_PUB        11
#define IDS_MIGR                12
#define IDS_DELETE_SIG          13
#define IDS_DELETE_KEYX         14
#define IDS_DELETE_SIG_MIGR     15
#define IDS_DELETE_KEYX_MIGR    16
#define IDS_SIGNING_S           17
#define IDS_EXPORT_E_PRIV       18
#define IDS_EXPORT_S_PRIV       19
#define IDS_IMPORT_E_PRIV       20
#define IDS_IMPORT_S_PRIV       21

#define         IDS_CSP_RSA_SIG_DESCR               7501
#define         IDS_CSP_RSA_EXCH_DESCR              7502
#define         IDS_CSP_IMPORT_SIMPLE               7503
#define         IDS_CSP_SIGNING_E                   7504
#define         IDS_CSP_CREATE_RSA_SIG              7505
#define         IDS_CSP_CREATE_RSA_EXCH             7506
#define         IDS_CSP_DSS_SIG_DESCR               7507
#define         IDS_CSP_DSS_EXCH_DESCR              7508
#define         IDS_CSP_CREATE_DSS_SIG              7509
#define         IDS_CSP_CREATE_DH_EXCH              7510
#define         IDS_CSP_IMPORT_E_PUB                7511
#define         IDS_CSP_MIGR                        7512
#define         IDS_CSP_DELETE_SIG                  7513
#define         IDS_CSP_DELETE_KEYX                 7514
#define         IDS_CSP_DELETE_SIG_MIGR             7515
#define         IDS_CSP_DELETE_KEYX_MIGR            7516
#define         IDS_CSP_SIGNING_S                   7517
#define         IDS_CSP_EXPORT_E_PRIV               7518
#define         IDS_CSP_EXPORT_S_PRIV               7519
#define         IDS_CSP_IMPORT_E_PRIV               7520
#define         IDS_CSP_IMPORT_S_PRIV               7521
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\rsabase\contman.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : contman.h                                              //
//  DESCRIPTION   : include file                                           //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Mar 16 1998 jeffspel Created                                       //
//                                                                         //
//  Copyright (C) 1998 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef	__CONTMAN_H__
#define	__CONTMAN_H__

#ifdef __cplusplus
extern "C" {
#endif

// Display Strings
typedef struct _CSP_STRINGS_ {
    // RSA
    LPWSTR  pwszSignWExch;
    LPWSTR  pwszCreateRSASig;
    LPWSTR  pwszCreateRSAExch;
    LPWSTR  pwszRSASigDescr;
    LPWSTR  pwszRSAExchDescr;
    LPWSTR  pwszImportSimple;

    // DSS-DH
    LPWSTR  pwszCreateDSS;
    LPWSTR  pwszCreateDH;
    LPWSTR  pwszImportDHPub;
    LPWSTR  pwszDSSSigDescr;
    LPWSTR  pwszDHExchDescr;

    // BOTH
    LPWSTR  pwszSigning;
    LPWSTR  pwszMigrKeys;
    LPWSTR  pwszImportPrivSig;
    LPWSTR  pwszImportPrivExch;
    LPWSTR  pwszExportPrivSig;
    LPWSTR  pwszExportPrivExch;
    LPWSTR  pwszDeleteSig;
    LPWSTR  pwszDeleteMigrSig;
    LPWSTR  pwszDeleteExch;
    LPWSTR  pwszDeleteMigrExch;
} CSP_STRINGS, *PCSP_STRINGS;

#define SZLOCALMACHINECRYPTO "Software\\Microsoft\\Cryptography"
#define SZCRYPTOMACHINEGUID "MachineGuid"

#define KEY_CONTAINER_FILE_FORMAT_VER   2

#define STUFF_TO_GO_INTO_MIX    "Hj1diQ6kpUx7VC4m"

typedef struct _KEY_EXPORTABILITY_LENS_ {
    DWORD                   cbSigExportability;
    DWORD                   cbExchExportability;
} KEY_EXPORTABILITY_LENS, *PKEY_EXPORTABILITY_LENS;

typedef struct _KEY_CONTAINER_LENS_ {
    DWORD                   dwUIOnKey;
    DWORD                   cbName;
    DWORD                   cbSigPub;
    DWORD                   cbSigEncPriv;
    DWORD                   cbExchPub;
    DWORD                   cbExchEncPriv;
    DWORD                   cbRandom;			    // length of Random number seed
} KEY_CONTAINER_LENS, *PKEY_CONTAINER_LENS;

typedef struct _KEY_CONTAINER_INFO_ {
    DWORD                   dwVersion;
    KEY_CONTAINER_LENS      ContLens;
    BOOL                    fCryptSilent;
    BYTE                    *pbSigPub;
    BYTE                    *pbSigEncPriv;
    BOOL                    fSigExportable;
    BYTE                    *pbExchPub;
    BYTE                    *pbExchEncPriv;
    BOOL                    fExchExportable;
    BYTE                    *pbRandom;
    LPSTR                   pszUserName;
    WCHAR                   rgwszFileName[80];
    HANDLE                  hFind;                  // for enuming containers
    DWORD                   dwiRegEntry;            // for enuming containers
    DWORD                   cMaxRegEntry;           // for enuming containers
    DWORD                   cbRegEntry;             // for enuming containers
    CHAR                    *pchEnumRegEntries;     // for enuming containers
    BOOL                    fCryptFirst;            // for enuming containers
    BOOL                    fNoMoreFiles;           // for enuming containers
    DWORD                   cbOldMachKeyEntry;      // for enuming containers
    DWORD                   dwiOldMachKeyEntry;     // for enuming containers
    DWORD                   cMaxOldMachKeyEntry;    // for enuming containers
    CHAR                    *pchEnumOldMachKeyEntries; // for enuming containers
} KEY_CONTAINER_INFO, *PKEY_CONTAINER_INFO;

// define flag for leaving old keys in the registry if they are in the .Default
// hive but are user keys
#define LEAVE_OLD_KEYS          1
// define flag indicating that the thread cannot get the SACL info from the
// old registry key when migrating keys
#define PRIVILEDGE_FOR_SACL     2


//
//    Just tries to use DPAPI to make sure it works before creating a key
//    container.
//
DWORD TryDPAPI();

BOOL
MyCryptProtectData(
    IN              DATA_BLOB*      pDataIn,
    IN              LPCWSTR         szDataDescr,
    IN OPTIONAL     DATA_BLOB*      pOptionalEntropy,
    IN              PVOID           pvReserved,
    IN OPTIONAL     CRYPTPROTECT_PROMPTSTRUCT*  pPromptStruct,
    IN              DWORD           dwFlags,
    OUT             DATA_BLOB*      pDataOut            // out encr blob
    );

BOOL
MyCryptUnprotectData(
    IN              DATA_BLOB*      pDataIn,             // in encr blob
    OUT OPTIONAL    LPWSTR*         ppszDataDescr,       // out
    IN OPTIONAL     DATA_BLOB*      pOptionalEntropy,
    IN              PVOID           pvReserved,
    IN OPTIONAL     CRYPTPROTECT_PROMPTSTRUCT*  pPromptStruct,
    IN              DWORD           dwFlags,
    OUT             DATA_BLOB*      pDataOut
    );

void FreeEnumOldMachKeyEntries(
                               PKEY_CONTAINER_INFO pInfo
                               );

void FreeEnumRegEntries(
                       PKEY_CONTAINER_INFO pInfo
                       );

void FreeContainerInfo(
                       PKEY_CONTAINER_INFO pInfo
                       );

BOOL WINAPI FIsWinNT(void);

BOOL
IsLocalSystem(
              BOOL *pfIsLocalSystem
              );

BOOL
IsThreadLocalSystem(
                    BOOL *pfIsLocalSystem
                    );

BOOL
GetUserTextualSidA(
    LPSTR lpBuffer,
    LPDWORD nSize
    );

BOOL
GetUserTextualSidW(
    LPWSTR lpBuffer,
    LPDWORD nSize
    );

DWORD SetMachineGUID();

DWORD AddMachineGuidToContainerName(
                                    LPSTR pszContainer,
                                    LPWSTR pszNewContainer
                                    );

DWORD SetContainerUserName(
                           IN LPSTR pszUserName,
                           IN PKEY_CONTAINER_INFO pContInfo
                           );

DWORD ReadContainerInfo(
                        IN DWORD dwProvType,
                        IN LPSTR pszContainerName,
                        IN BOOL fMachineKeyset,
                        IN DWORD dwFlags,
                        OUT PKEY_CONTAINER_INFO pContInfo
                        );

DWORD WriteContainerInfo(
                         IN DWORD dwProvType,
                         IN LPWSTR pwszFileName,
                         IN BOOL fMachineKeyset,
                         IN PKEY_CONTAINER_INFO pContInfo
                         );

DWORD DeleteContainerInfo(
                          IN DWORD dwProvType,
                          IN LPSTR pszFileName,
                          IN BOOL fMachineKeyset
                          );

DWORD GetUniqueContainerName(
                             IN KEY_CONTAINER_INFO *pContInfo,
                             OUT BYTE *pbData,
                             OUT DWORD *pcbData
                             );

DWORD GetNextContainer(
    IN      DWORD   dwProvType,
    IN      BOOL    fMachineKeyset,
    IN      DWORD   dwFlags,
    OUT     LPSTR   pszNextContainer,
    IN OUT  DWORD   *pcbNextContainer,
    IN OUT  HANDLE  *phFind
    );

DWORD SetSecurityOnContainer(
                             IN LPCWSTR wszFileName,
                             IN DWORD dwProvType,
                             IN DWORD fMachineKeyset,
                             IN SECURITY_INFORMATION SecurityInformation, 
                             IN PSECURITY_DESCRIPTOR pSecurityDescriptor 
                             );

//+ ===========================================================================
//
//      The function adjusts the token priviledges so that SACL information
//      may be set on a key container.  If the token priviledges may be set
//      indicated by the pUser->dwOldKeyFlags having the PRIVILEDGE_FOR_SACL value set.
//      value set then the token privilege is adjusted before the security
//      descriptor is set on the container.  This is needed for the key
//      migration case when keys are being migrated from the registry to files.
//- ============================================================================
DWORD SetSecurityOnContainerWithTokenPriviledges(
                                          IN DWORD dwOldKeyFlags,
                                          IN LPCWSTR wszFileName,
                                          IN DWORD dwProvType,
                                          IN DWORD fMachineKeyset,
                                          IN SECURITY_INFORMATION SecurityInformation, 
                                          IN PSECURITY_DESCRIPTOR pSecurityDescriptor 
                                          );

DWORD GetSecurityOnContainer(
                             IN LPCWSTR wszFileName,
                             IN DWORD dwProvType,
                             IN DWORD fMachineKeyset,
                             IN SECURITY_INFORMATION RequestedInformation, 
                             OUT PSECURITY_DESCRIPTOR pSecurityDescriptor,
                             IN OUT DWORD *pcbSecurityDescriptor
                             );

BOOL IsEncryptionPermitted(
                           IN DWORD dwProvType,
                           OUT BOOL *pfInFrance
                           );

// Converts to UNICODE and uses RegOpenKeyExW
DWORD MyRegOpenKeyEx(IN HKEY hRegKey,
                     IN LPSTR pszKeyName,
                     IN DWORD dwReserved,
                     IN REGSAM SAMDesired,
                     OUT HKEY *phNewRegKey);

// Converts to UNICODE and uses RegDeleteKeyW
DWORD MyRegDeleteKey(IN HKEY hRegKey,
                     IN LPSTR pszKeyName);

DWORD AllocAndSetLocationBuff(
                              BOOL fMachineKeySet,
                              DWORD dwProvType,
                              CONST char *pszUserID,
                              HKEY *phTopRegKey,
                              TCHAR **ppszLocBuff,
                              BOOL fUserKeys,
                              BOOL *pfLeaveOldKeys
                              );

//
// Enumerates the old machine keys in the file system
// keys were in this location in Beta 2 and Beta 3 of NT5/Win2K
//
DWORD EnumOldMachineKeys(
                         IN DWORD dwProvType,
                         IN OUT PKEY_CONTAINER_INFO pContInfo
                         );

DWORD GetNextEnumedOldMachKeys(
                              IN PKEY_CONTAINER_INFO pContInfo,
                              IN BOOL fMachineKeyset,
                              IN DWORD dwProvType,
                              OUT BYTE *pbData,
                              OUT DWORD *pcbData
                              );

//
// Enumerates the keys in the registry into a list of entries
//
DWORD EnumRegKeys(
                  IN OUT PKEY_CONTAINER_INFO pContInfo,
                  IN BOOL fMachineKeySet,
                  IN DWORD dwProvType,
                  OUT BYTE *pbData,
                  IN OUT DWORD *pcbData
                  );

DWORD GetNextEnumedRegKeys(
                           IN PKEY_CONTAINER_INFO pContInfo,
                           IN BOOL fMachineKeySet,
                           IN DWORD dwProvType,
                           OUT BYTE *pbData,
                           OUT DWORD *pcbData
                           );

//+ ===========================================================================
//
//      The function adjusts the token priviledges so that SACL information
//      may be gotten and then opens the indicated registry key.  If the token
//      priviledges may be set then the reg key is opened anyway but the
//      flags field will not have the PRIVILEDGE_FOR_SACL value set.
//
//- ============================================================================
BOOL OpenRegKeyWithTokenPriviledges(
                                    IN HKEY hTopRegKey,
                                    IN LPSTR pszRegKey,
                                    OUT HKEY *phRegKey,
                                    OUT DWORD *pdwFlags
                                    );

BOOL LoadStrings();

void UnloadStrings();

typedef struct _EXPO_OFFLOAD_STRUCT {
        DWORD       dwVersion;
        HMODULE     hInst;
        FARPROC     pExpoFunc;
} EXPO_OFFLOAD_STRUCT, *PEXPO_OFFLOAD_STRUCT;

//
// Function : FreeOffloadInfo
//
// Description : The function takes a pointer to Offload Information as the
//               first parameter of the call.  The function frees the
//               information.
//
void FreeOffloadInfo(
                     IN OUT PEXPO_OFFLOAD_STRUCT pOffloadInfo
                     );

//
// Function : InitExpOffloadInfo
//
// Description : The function takes a pointer to Offload Information as the
//               first parameter of the call.  The function checks in the
//               registry to see if an offload module has been registered. 
//               If a module is registered then it loads the module
//               and gets the OffloadModExpo function pointer.
//
BOOL InitExpOffloadInfo(
                        IN OUT PEXPO_OFFLOAD_STRUCT *ppExpoOffloadInfo
                        );

//
// Function : ModularExpOffload
//
// Description : This function does the offloading of modular exponentiation.
//               The function takes a pointer to Offload Information as the
//               first parameter of the call.  If this pointer is not NULL
//               then the function will use this module and call the function.
//               The exponentiation with MOD function will implement
//               Y^X MOD P  where Y is the buffer pbBase, X is the buffer
//               pbExpo and P is the buffer pbModulus.  The length of the
//               buffer pbExpo is cbExpo and the length of pbBase and
//               pbModulus is cbModulus.  The resulting value is output
//               in the pbResult buffer and has length cbModulus.
//               The pReserved and dwFlags parameters are currently ignored.
//               If any of these functions fail then the function fails and
//               returns FALSE.  If successful then the function returns
//               TRUE.  If the function fails then most likely the caller
//               should fall back to using hard linked modular exponentiation.
//
BOOL ModularExpOffload(
                       IN PEXPO_OFFLOAD_STRUCT pOffloadInfo,
                       IN BYTE *pbBase,  
                       IN BYTE *pbExpo,
                       IN DWORD cbExpo,
                       IN BYTE *pbModulus,
                       IN DWORD cbModulus,
                       OUT BYTE *pbResult,
                       IN VOID *pReserved,
                       IN DWORD dwFlags
                       );

#ifdef USE_HW_RNG
#ifdef _M_IX86
// stuff for INTEL RNG usage

// 
// Function : GetRNGDriverHandle
//
// Description : Gets the handle to the INTEL RNG driver if available, then
//               checks if the chipset supports the hardware RNG.  If so
//               the previous driver handle is closed if necessary and the
//               new handle is assigned to the passed in parameter.
//
BOOL GetRNGDriverHandle(
                        IN OUT HANDLE *phDriver
                        );

// 
// Function : CheckIfRNGAvailable
//
// Description : Checks if the INTEL RNG driver is available, if so then
//               checks if the chipset supports the hardware RNG.
//
BOOL CheckIfRNGAvailable();

// 
// Function : HWRNGGenRandom
//
// Description : Uses the passed in handle to the INTEL RNG driver
//               to fill the buffer with random bits.  Actually uses
//               XOR to fill the buffer so that the passed in buffer
//               is also mixed in.
//
unsigned int
HWRNGGenRandom(
               IN HANDLE hRNGDriver,
               IN OUT BYTE *pbBuffer,
               IN DWORD dwLen
               );

#ifdef TEST_HW_RNG
// 
// Function : SetupHWRNGIfRegistered
//
// Description : Checks if there is a registry setting indicating the HW RNG
//               is to be used.  If the registry entry is there then it attempts
//               to get the HW RNG driver handle.
//
BOOL SetupHWRNGIfRegistered(
                            OUT HANDLE *phRNGDriver
                            );
#endif // TEST_HW_RNG

#endif // _M_IX86
#endif // USE_HW_RNG

#if DBG         // NOTE:  This section not compiled for retail builds

void CSPDebugOutputAcqCtxt(
                           IN BOOL fEnter,
                           IN BOOL fReturn,
                           IN HCRYPTPROV *phProv,
                           IN CHAR *pUserID,
                           IN DWORD dwFlags,
                           IN PVTableProvStruc pVTable
                           );

void CSPDebugOutputReleaseCtxt(
                               IN BOOL fEnter,
                               IN BOOL fReturn,
                               IN HCRYPTPROV hProv,
                               IN DWORD dwFlags
                               );

void CSPDebugOutputSetProvParam(
                                IN BOOL fEnter,
                                IN BOOL fReturn,
                                IN HCRYPTPROV hProv,
                                IN DWORD dwParam,
                                IN BYTE *pbData,
                                IN DWORD dwFlags
                                );

void CSPDebugOutputGetProvParam(
                                IN BOOL fEnter,
                                IN BOOL fReturn,
                                IN HCRYPTPROV hProv,
                                IN DWORD dwParam,
                                IN BYTE *pbData,
                                IN DWORD *pdwDataLen,
                                IN DWORD dwFlags
                                );

void CSPDebugOutputDeriveKey(
                             IN BOOL fEnter,
                             IN BOOL fReturn,
                             IN HCRYPTPROV hProv,
                             IN ALG_ID Algid,
                             IN HCRYPTHASH hHash,
                             IN DWORD dwFlags,
                             IN HCRYPTKEY *phKey
                             );

void CSPDebugOutputDestroyKey(
                              IN BOOL fEnter,
                              IN BOOL fReturn,
                              IN HCRYPTKEY hProv,
                              IN HCRYPTKEY hKey
                              );

void CSPDebugOutputGenKey(
                          IN BOOL fEnter,
                          IN BOOL fReturn,
                          IN HCRYPTKEY hProv,
                          IN ALG_ID Algid,
                          IN DWORD dwFlags,
                          IN HCRYPTKEY *phKey
                          );

void CSPDebugOutputGetKeyParam(
                               IN BOOL fEnter,
                               IN BOOL fReturn,
                               IN HCRYPTPROV hProv,
                               IN HCRYPTKEY hKey,
                               IN DWORD dwParam,
                               IN BYTE *pbData,
                               IN DWORD *pdwDataLen,
                               IN DWORD dwFlags
                               );

void CSPDebugOutputGetUserKey(
                              IN BOOL fEnter,
                              IN BOOL fReturn,
                              IN HCRYPTPROV hProv,
                              IN DWORD dwKeySpec,
                              IN HCRYPTKEY *phKey
                              );

void CSPDebugOutputSetKeyParam(
                               IN BOOL fEnter,
                               IN BOOL fReturn,
                               IN HCRYPTPROV hProv,
                               IN HCRYPTKEY hKey,
                               IN DWORD dwParam,
                               IN BYTE *pbData,
                               IN DWORD dwFlags
                               );

void CSPDebugOutputGenRandom(
                             IN BOOL fEnter,
                             IN BOOL fReturn,
                             IN HCRYPTPROV hProv,
                             IN DWORD dwLen,
                             IN BYTE *pbBuffer
                             );

void CSPDebugOutputExportKey(
                             IN BOOL fEnter,
                             IN BOOL fReturn,
                             IN HCRYPTPROV hProv,
                             IN HCRYPTKEY hKey,
                             IN HCRYPTKEY hExpKey,
                             IN DWORD dwBlobType,
                             IN DWORD dwFlags,
                             IN BYTE *pbData,
                             IN DWORD *pdwDataLen
                             );

void CSPDebugOutputImportKey(
                             IN BOOL fEnter,
                             IN BOOL fReturn,
                             IN HCRYPTPROV hProv,
                             IN BYTE *pbData,
                             IN DWORD dwDataLen,
                             IN HCRYPTKEY hImpKey,
                             IN DWORD dwFlags,
                             IN HCRYPTKEY *phKey
                             );

void CSPDebugOutputDuplicateKey(
                                IN BOOL fEnter,
                                IN BOOL fReturn,
                                IN HCRYPTPROV hProv,
                                IN HCRYPTKEY hKey,
                                IN DWORD *pdwReserved,
                                IN DWORD dwFlags,
                                IN HCRYPTKEY *phKey
                                );

void CSPDebugOutputGetHashParam(
                                IN BOOL fEnter,
                                IN BOOL fReturn,
                                IN HCRYPTPROV hProv,
                                IN HCRYPTHASH hHash,
                                IN DWORD dwParam,
                                IN BYTE *pbData,
                                IN DWORD *pdwDataLen,
                                IN DWORD dwFlags
                                );

void CSPDebugOutputSetHashParam(
                                IN BOOL fEnter,
                                IN BOOL fReturn,
                                IN HCRYPTPROV hProv,
                                IN HCRYPTHASH hHash,
                                IN DWORD dwParam,
                                IN BYTE *pbData,
                                IN DWORD dwFlags
                                );

void CSPDebugOutputEncrypt(
                           IN BOOL fEnter,
                           IN BOOL fReturn,
                           IN HCRYPTPROV hProv,
                           IN HCRYPTHASH hKey,
                           IN HCRYPTHASH hHash,
                           IN BOOL Final,
                           IN DWORD dwFlags,
                           IN BYTE *pbData,
                           IN DWORD *pdwDataLen,
                           IN DWORD dwBufLen
                           );

void CSPDebugOutputDecrypt(
                           IN BOOL fEnter,
                           IN BOOL fReturn,
                           IN HCRYPTPROV hProv,
                           IN HCRYPTHASH hKey,
                           IN HCRYPTHASH hHash,
                           IN BOOL Final,
                           IN DWORD dwFlags,
                           IN BYTE *pbData,
                           IN DWORD *pdwDataLen
                           );

void CSPDebugOutputSignHash(
                            IN BOOL fEnter,
                            IN BOOL fReturn,
                            IN HCRYPTPROV hProv,
                            IN HCRYPTHASH hHash,
                            IN DWORD dwKeySpec,
                            IN LPCWSTR pszDescription,
                            IN DWORD dwFlags,
                            IN BYTE *pbSignature,
                            IN DWORD *pdwSigLen
                            );

void CSPDebugOutputVerifySignature(
                                   IN BOOL fEnter,
                                   IN BOOL fReturn,
                                   IN HCRYPTPROV hProv,
                                   IN HCRYPTHASH hHash,
                                   IN BYTE *pbSignature,
                                   IN DWORD dwSigLen,
                                   IN HCRYPTKEY hPubKey,
                                   IN LPCWSTR pszDescription,
                                   IN DWORD dwFlags
                                   );

void CSPDebugOutputCreateHash(
                              IN BOOL fEnter,
                              IN BOOL fReturn,
                              IN HCRYPTPROV hProv,
                              IN ALG_ID Algid,
                              IN HCRYPTKEY hKey,
                              IN DWORD dwFlags,
                              IN HCRYPTHASH *phHash
                              );

void CSPDebugOutputDestroyHash(
                               IN BOOL fEnter,
                               IN BOOL fReturn,
                               IN HCRYPTPROV hProv,
                               IN HCRYPTHASH hHash
                               );

void CSPDebugOutputHashData(
                            IN BOOL fEnter,
                            IN BOOL fReturn,
                            IN HCRYPTPROV hProv,
                            IN HCRYPTHASH hHash,
                            IN BYTE *pbData,
                            IN DWORD dwDataLen,
                            IN DWORD dwFlags
                            );

void CSPDebugOutputHashSessionKey(
                                  IN BOOL fEnter,
                                  IN BOOL fReturn,
                                  IN HCRYPTPROV hProv,
                                  IN HCRYPTHASH hHash,
                                  IN HCRYPTKEY hKey,
                                  IN DWORD dwFlags
                                  );

void CSPDebugOutputDuplicateHash(
                                 IN BOOL fEnter,
                                 IN BOOL fReturn,
                                 IN HCRYPTPROV hProv,
                                 IN HCRYPTHASH hHash,
                                 IN DWORD *pdwReserved,
                                 IN DWORD dwFlags,
                                 IN HCRYPTHASH *phHash
                                 );

#endif // DBG -- NOTE:  This section not compiled for retail builds 

#ifdef __cplusplus
}
#endif

#endif // __CONTMAN_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\rsabase\contman.c ===
/*++

Copyright (c) 1997, 1998, 1999  Microsoft Corporation

Module Name:

    keyman.cpp

Abstract:

    This module contains routines to read and write data (key containers) from and to files.


Author:

    16 Mar 98 jeffspel

--*/

#include <precomp.h>
//#include <userenv.h>
#include <wincrypt.h>
#include <xwinreg.h>
#include <rpc.h>
//#include <shlobj.h>
#include "contman.h"
#include "msr_md5.h"
#include "des.h"
#include "modes.h"
#include "csprc.h"

#ifdef USE_HW_RNG
#ifdef _M_IX86

#include <winioctl.h>

// INTEL h files for on chip RNG
#include "deftypes.h"   //ISD typedefs and constants
#include "ioctldef.h"   //ISD ioctl definitions

#endif // _M_IX86
#endif // USE_HW_RNG

#if DBG         // NOTE:  This section not compiled for retail builds
DWORD   g_dwDebugCount = 0;
#endif // DBG

BYTE *g_pbStringBlock = NULL;
CSP_STRINGS g_Strings = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                         NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                         NULL, NULL, NULL, NULL, NULL};

typedef struct _OLD_KEY_CONTAINER_LENS_ {
    DWORD                   cbSigPub;
    DWORD                   cbSigEncPriv;
    DWORD                   cbExchPub;
    DWORD                   cbExchEncPriv;
} OLD_KEY_CONTAINER_LENS, *POLD_KEY_CONTAINER_LENS;

#define OLD_KEY_CONTAINER_FILE_FORMAT_VER   1

#define ContInfoAlloc(cb)       LocalAlloc(LMEM_ZEROINIT, cb)
#define ContInfoReAlloc(pb, cb) LocalReAlloc(pb, cb, LMEM_ZEROINIT | LMEM_MOVEABLE)
#define ContInfoFree(pb)        LocalFree(pb)

#define MACHINE_KEYS_DIR    L"MachineKeys"

// Location of the keys in the registry (minus the logon name)
// Length of the full location (including the logon name)
#define RSA_REG_KEY_LOC         "Software\\Microsoft\\Cryptography\\UserKeys"
#define RSA_REG_KEY_LOC_LEN     sizeof(RSA_REG_KEY_LOC)
#define RSA_MACH_REG_KEY_LOC        "Software\\Microsoft\\Cryptography\\MachineKeys"
#define RSA_MACH_REG_KEY_LOC_LEN    sizeof(RSA_MACH_REG_KEY_LOC)

#define DSS_REG_KEY_LOC		    "Software\\Microsoft\\Cryptography\\DSSUserKeys"
#define DSS_REG_KEY_LOC_LEN	    sizeof(DSS_REG_KEY_LOC)
#define DSS_MACH_REG_KEY_LOC        "Software\\Microsoft\\Cryptography\\DSSUserKeys"
#define DSS_MACH_REG_KEY_LOC_LEN    sizeof(DSS_MACH_REG_KEY_LOC)

#define MAX_DPAPI_RETRY_COUNT   5

BOOL
MyCryptProtectData(
    IN              DATA_BLOB*      pDataIn,
    IN              LPCWSTR         szDataDescr,
    IN OPTIONAL     DATA_BLOB*      pOptionalEntropy,
    IN              PVOID           pvReserved,
    IN OPTIONAL     CRYPTPROTECT_PROMPTSTRUCT*  pPromptStruct,
    IN              DWORD           dwFlags,
    OUT             DATA_BLOB*      pDataOut            // out encr blob
    )
{
    pDataOut->cbData = pDataIn->cbData;
    RtlCopyMemory( pDataOut->pbData, pDataIn->pbData, pDataIn->cbData );

    ASSERT( !"MyCryptProtectData" );
    return TRUE;
}

BOOL
MyCryptUnprotectData(
    IN              DATA_BLOB*      pDataIn,             // in encr blob
    OUT OPTIONAL    LPWSTR*         ppszDataDescr,       // out
    IN OPTIONAL     DATA_BLOB*      pOptionalEntropy,
    IN              PVOID           pvReserved,
    IN OPTIONAL     CRYPTPROTECT_PROMPTSTRUCT*  pPromptStruct,
    IN              DWORD           dwFlags,
    OUT             DATA_BLOB*      pDataOut
    )
{
    pDataOut->cbData = pDataIn->cbData;
    RtlCopyMemory( pDataOut->pbData, pDataIn->pbData, pDataIn->cbData );

    ASSERT( !"MyCryptUnprotectData" );
    return TRUE;
}

void FreeEnumOldMachKeyEntries(
                               PKEY_CONTAINER_INFO pInfo
                               )
{
    if (pInfo)
    {
        if (pInfo->pchEnumOldMachKeyEntries)
        {
            ContInfoFree(pInfo->pchEnumOldMachKeyEntries);
            pInfo->dwiOldMachKeyEntry = 0;
            pInfo->cMaxOldMachKeyEntry = 0;
            pInfo->cbOldMachKeyEntry = 0;
            pInfo->pchEnumOldMachKeyEntries = NULL;
        }
    }
}

void FreeEnumRegEntries(
                       PKEY_CONTAINER_INFO pInfo
                       )
{
    if (pInfo)
    {
        if (pInfo->pchEnumRegEntries)
        {
            ContInfoFree(pInfo->pchEnumRegEntries);
            pInfo->dwiRegEntry = 0;
            pInfo->cMaxRegEntry = 0;
            pInfo->cbRegEntry = 0;
            pInfo->pchEnumRegEntries = NULL;
        }
    }
}

void FreeContainerInfo(
                       PKEY_CONTAINER_INFO pInfo
                       )
{
    if (pInfo)
    {
        if (pInfo->pbSigPub)
        {
            ContInfoFree(pInfo->pbSigPub);
            pInfo->ContLens.cbSigPub = 0;
            pInfo->pbSigPub = NULL;
        }
        if (pInfo->pbSigEncPriv)
        {
            ZeroMemory(pInfo->pbSigEncPriv, pInfo->ContLens.cbSigEncPriv);
            ContInfoFree(pInfo->pbSigEncPriv);
            pInfo->ContLens.cbSigEncPriv = 0;
            pInfo->pbSigEncPriv = NULL;
        }
        if (pInfo->pbExchPub)
        {
            ContInfoFree(pInfo->pbExchPub);
            pInfo->ContLens.cbExchPub = 0;
            pInfo->pbExchPub = NULL;
        }
        if (pInfo->pbExchEncPriv)
        {
            ZeroMemory(pInfo->pbExchEncPriv, pInfo->ContLens.cbExchEncPriv);
            ContInfoFree(pInfo->pbExchEncPriv);
            pInfo->ContLens.cbExchEncPriv = 0;
            pInfo->pbExchEncPriv = NULL;
        }
        if (pInfo->pbRandom)
        {
            ContInfoFree(pInfo->pbRandom);
            pInfo->ContLens.cbRandom = 0;
            pInfo->pbRandom = NULL;
        }
        if (pInfo->pszUserName)
        {
            ContInfoFree(pInfo->pszUserName);
            pInfo->ContLens.cbName = 0;
            pInfo->pszUserName = NULL;
        }

        FreeEnumOldMachKeyEntries(pInfo);

        FreeEnumRegEntries(pInfo);

        if (pInfo->hFind)
            FindClose(pInfo->hFind);
    }
}

DWORD GetHashOfContainer(
                         LPCSTR pszContainer,
                         LPWSTR pszHash
                         )
{
    MD5_CTX     MD5;
    LPSTR       pszLowerContainer = NULL;
    DWORD       *pdw1;
    DWORD       *pdw2;
    DWORD       *pdw3;
    DWORD       *pdw4;
    DWORD       dwErr = 0;

    if (NULL == (pszLowerContainer =
        (LPSTR)ContInfoAlloc(strlen(pszContainer) + sizeof(CHAR))))
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }
    lstrcpy(pszLowerContainer, pszContainer);
    _strlwr(pszLowerContainer);

    MD5Init(&MD5);
    MD5Update(&MD5, pszLowerContainer, strlen(pszLowerContainer) + sizeof(CHAR));
    MD5Final(&MD5);

    pdw1 = (DWORD*)&MD5.digest[0];
    pdw2 = (DWORD*)&MD5.digest[4];
    pdw3 = (DWORD*)&MD5.digest[8];
    pdw4 = (DWORD*)&MD5.digest[12];
    wsprintfW(pszHash, L"%08hx%08hx%08hx%08hx", *pdw1, *pdw2, *pdw3, *pdw4);
Ret:
    if (pszLowerContainer)
        ContInfoFree(pszLowerContainer);
    return dwErr;
}

DWORD GetMachineGUID(
                     LPWSTR *ppwszUuid
                     )
{
#ifndef _XBOX
    HKEY    hRegKey = 0;
    UUID    Uuid;
    LPSTR   pszUuid = NULL;
    DWORD   cbUuid = sizeof(Uuid);
    DWORD   cch = 0;
    DWORD   dwErr = 0;

    // read the GUID from the Local Machine portion of the registry
    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, SZLOCALMACHINECRYPTO,
                                      0, KEY_READ, &hRegKey))
    {
        dwErr = (DWORD)NTE_FAIL;
        goto Ret;
    }
    if (ERROR_SUCCESS != RegQueryValueEx(hRegKey, SZCRYPTOMACHINEGUID,
                                         0, NULL, NULL,
                                         &cbUuid))
    {
        dwErr = (DWORD)NTE_FAIL;
        goto Ret;
    }
    if (NULL == (pszUuid = (LPSTR)ContInfoAlloc(cbUuid)))
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }
    if (ERROR_SUCCESS != RegQueryValueEx(hRegKey, SZCRYPTOMACHINEGUID,
                                         0, NULL, pszUuid,
                                         &cbUuid))
    {
        dwErr = (DWORD)NTE_FAIL;
        goto Ret;
    }

    // convert from ansi to unicode
    if (0 == (cch = MultiByteToWideChar(CP_ACP, 0,
                                        pszUuid,
                                        -1, NULL, cch)))
    {
        dwErr = GetLastError();
        goto Ret;
    }

    if (NULL == (*ppwszUuid = ContInfoAlloc((cch + 1) * sizeof(WCHAR))))
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    if (0 == (cch = MultiByteToWideChar(CP_ACP, 0,
                                        pszUuid,
                                        -1, *ppwszUuid, cch)))
    {
         dwErr = GetLastError();
         goto Ret;
    }
Ret:
    if (pszUuid)
        ContInfoFree(pszUuid);

    if (hRegKey)
        RegCloseKey(hRegKey);

    return dwErr;
#else
    DWORD   dwErr = 0;

    if (NULL == (*ppwszUuid = ContInfoAlloc((2) * sizeof(WCHAR))))
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }

    (*ppwszUuid)[0] = 'X';
    (*ppwszUuid)[1] = '\0';
    
    return dwErr;
#endif
}

DWORD SetMachineGUID()
{
#ifndef _XBOX
    HKEY    hRegKey = 0;
    UUID    Uuid;
    LPSTR   pszUuid = NULL;
    DWORD   cbUuid;
    HANDLE  hRPCRT4Dll = 0;
    FARPROC pUuidCreate = NULL;
    FARPROC pUuidToStringA = NULL;
    FARPROC pRpcStringFreeA = NULL;
    LPWSTR  pwszOldUuid = NULL;
    DWORD   dwResult;
    DWORD   dwErr = 0;

    if (0 == GetMachineGUID(&pwszOldUuid))
    {
        goto Ret;
    }

    if (NULL == (hRPCRT4Dll = LoadLibraryA("rpcrt4.dll")))
    {
        dwErr = (DWORD)NTE_FAIL;
        goto Ret;
    }

    if (NULL == (pUuidCreate = GetProcAddress(hRPCRT4Dll, "UuidCreate")))
    {
        dwErr = (DWORD)NTE_FAIL;
        goto Ret;
    }
    if (NULL == (pUuidToStringA = GetProcAddress(hRPCRT4Dll, "UuidToStringA")))
    {
        dwErr = (DWORD)NTE_FAIL;
        goto Ret;
    }
    if (NULL == (pRpcStringFreeA = GetProcAddress(hRPCRT4Dll, "RpcStringFreeA")))
    {
        dwErr = (DWORD)NTE_FAIL;
        goto Ret;
    }

    // read the GUID from the Local Machine portion of the registry
    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                        SZLOCALMACHINECRYPTO,
                                        0, NULL, REG_OPTION_NON_VOLATILE,
                                        KEY_WRITE, NULL, &hRegKey,
                                        &dwResult))
    {
        dwErr = (DWORD)NTE_FAIL;
        goto Ret;
    }

    if (ERROR_SUCCESS == RegQueryValueEx(hRegKey, SZCRYPTOMACHINEGUID,
                                         0, NULL, NULL,
                                         &cbUuid))
    {
        goto Ret;
    }

    pUuidCreate(&Uuid);

    if (RPC_S_OK != pUuidToStringA(&Uuid, &pszUuid))
    {
        dwErr = (DWORD)NTE_FAIL;
    }

    if (ERROR_SUCCESS != RegSetValueEx(hRegKey, SZCRYPTOMACHINEGUID,
                                       0, REG_SZ, (BYTE*)pszUuid,
                                       strlen(pszUuid) + 1))
    {
        dwErr = (DWORD)NTE_FAIL;
        goto Ret;
    }
Ret:
    if (pRpcStringFreeA && pszUuid)
        pRpcStringFreeA(&pszUuid); 
    if (hRPCRT4Dll)
        FreeLibrary(hRPCRT4Dll);
    if (pwszOldUuid)
        ContInfoFree(pwszOldUuid);
    if (hRegKey)
        RegCloseKey(hRegKey);
    return dwErr;
#else
    return 0;
#endif
}

DWORD AddMachineGuidToContainerName(
                                    LPSTR pszContainer,
                                    LPWSTR pwszNewContainer
                                    )
{
    WCHAR   rgwszHash[33];
    LPWSTR  pwszUuid = NULL;
    DWORD   dwErr = 0;

    memset(rgwszHash, 0, sizeof(rgwszHash));

    // get the stringized hash of the container name
    if (0 != (dwErr = GetHashOfContainer(pszContainer, rgwszHash)))
        goto Ret;

    // get the GUID of the machine
    if (0 != (dwErr = GetMachineGUID(&pwszUuid)))
        goto Ret;

    wcscpy(pwszNewContainer, rgwszHash);
    wcscat(pwszNewContainer, L"_");
    wcscat(pwszNewContainer, pwszUuid);
Ret:
    if (pwszUuid)
        ContInfoFree(pwszUuid); 
 
    return dwErr;
}

//
//    Just tries to use DPAPI to make sure it works before creating a key
//    container.
//
DWORD TryDPAPI()
{
    CRYPTPROTECT_PROMPTSTRUCT   PromptStruct;
    CRYPT_DATA_BLOB             DataIn;
    CRYPT_DATA_BLOB             DataOut;
    CRYPT_DATA_BLOB             ExtraEntropy;
    DWORD                       dwJunk = 0;
    DWORD                       dwErr = 0;

    memset(&PromptStruct, 0, sizeof(PromptStruct));
    memset(&DataIn, 0, sizeof(DataIn));
    memset(&DataOut, 0, sizeof(DataOut));

    PromptStruct.cbSize = sizeof(PromptStruct);

    DataIn.cbData = sizeof(DWORD);
    DataIn.pbData = (BYTE*)&dwJunk;
    ExtraEntropy.cbData = sizeof(STUFF_TO_GO_INTO_MIX);
    ExtraEntropy.pbData = STUFF_TO_GO_INTO_MIX;
    if (!MyCryptProtectData(&DataIn, L"Export Flag", &ExtraEntropy, NULL,
                            &PromptStruct, 0, &DataOut))
    {
        dwErr = (DWORD)NTE_BAD_KEYSET;
        goto Ret;
    }
Ret:
    if (DataOut.pbData)
        LocalFree(DataOut.pbData);
    return dwErr;
}

DWORD ProtectExportabilityFlag(
                               IN BOOL fExportable,
                               IN BOOL fMachineKeyset,
                               OUT BYTE **ppbProtectedExportability,
                               OUT DWORD *pcbProtectedExportability
                               )
{
    CRYPTPROTECT_PROMPTSTRUCT   PromptStruct;
    CRYPT_DATA_BLOB             DataIn;
    CRYPT_DATA_BLOB             DataOut;
    CRYPT_DATA_BLOB             ExtraEntropy;
    DWORD                       dwProtectFlags = 0;
    DWORD                       dwErr = 0;

    memset(&PromptStruct, 0, sizeof(PromptStruct));
    memset(&DataIn, 0, sizeof(DataIn));
    memset(&DataOut, 0, sizeof(DataOut));

    if (fMachineKeyset)
        dwProtectFlags = CRYPTPROTECT_LOCAL_MACHINE;

    PromptStruct.cbSize = sizeof(PromptStruct);

    DataIn.cbData = sizeof(BOOL);
    DataIn.pbData = (BYTE*)&fExportable;
    ExtraEntropy.cbData = sizeof(STUFF_TO_GO_INTO_MIX);
    ExtraEntropy.pbData = STUFF_TO_GO_INTO_MIX;
    if (!MyCryptProtectData(&DataIn, L"Export Flag", &ExtraEntropy, NULL,
                            &PromptStruct, dwProtectFlags, &DataOut))
    {
        dwErr = (DWORD)NTE_FAIL;
        goto Ret;
    }
    if (NULL == (*ppbProtectedExportability = ContInfoAlloc(DataOut.cbData)))
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }
    *pcbProtectedExportability = DataOut.cbData;
    memcpy(*ppbProtectedExportability, DataOut.pbData, DataOut.cbData);
Ret:
    if (DataOut.pbData)
        LocalFree(DataOut.pbData);
    return dwErr;
}

DWORD UnprotectExportabilityFlag(
                                 IN BOOL fMachineKeyset,
                                 IN BYTE *pbProtectedExportability,
                                 IN DWORD cbProtectedExportability,
                                 IN BOOL *pfExportable
                                 )
{
    CRYPTPROTECT_PROMPTSTRUCT   PromptStruct;
    CRYPT_DATA_BLOB             DataIn;
    CRYPT_DATA_BLOB             DataOut;
    CRYPT_DATA_BLOB             ExtraEntropy;
    DWORD                       dwProtectFlags = 0;
    DWORD                       dwErr = 0;

    memset(&PromptStruct, 0, sizeof(PromptStruct));
    memset(&DataIn, 0, sizeof(DataIn));
    memset(&DataOut, 0, sizeof(DataOut));
    memset(&ExtraEntropy, 0, sizeof(ExtraEntropy));

    if (fMachineKeyset)
        dwProtectFlags = CRYPTPROTECT_LOCAL_MACHINE;

    PromptStruct.cbSize = sizeof(PromptStruct);

    DataIn.cbData = cbProtectedExportability;
    DataIn.pbData = pbProtectedExportability;
    ExtraEntropy.cbData = sizeof(STUFF_TO_GO_INTO_MIX);
    ExtraEntropy.pbData = STUFF_TO_GO_INTO_MIX;
    if (!MyCryptUnprotectData(&DataIn, NULL, &ExtraEntropy, NULL,
                              &PromptStruct, dwProtectFlags, &DataOut))
    {
        dwErr = (DWORD)NTE_BAD_KEYSET;
        goto Ret;
    }
    if (sizeof(BOOL) != DataOut.cbData)
    {
        dwErr = (DWORD)NTE_BAD_KEYSET;
        goto Ret;
    }
    *pfExportable = *((BOOL*)DataOut.pbData);
Ret:
    // free the DataOut struct if necessary
    if (DataOut.pbData)
        LocalFree(DataOut.pbData);

    return dwErr;
}



BOOL
IsLocalSystem(
              BOOL *pfIsLocalSystem
              )
/*++

    This function determines if the user associated with the
    specified token is the Local System account.

--*/
{
    *pfIsLocalSystem = TRUE;
    
    return TRUE;
}

BOOL
IsThreadLocalSystem(
                    BOOL *pfIsLocalSystem
                    )
/*++

    This function determines if the user associated with the
    specified token is the Local System account.

--*/
{
    *pfIsLocalSystem = TRUE;
    
    return TRUE;
}

#define FAST_BUF_SIZE 256

BOOL
GetUserTextualSidA(
    LPSTR lpBuffer,
    LPDWORD nSize
    )
{
    if (*nSize < 2)
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }
    lpBuffer[0] = '1';
    lpBuffer[1] = '\0';
    *nSize = 2;
    
    return TRUE;
}

BOOL
GetUserTextualSidW(
    LPWSTR lpBuffer,
    LPDWORD nSize
    )
{
    if (*nSize < 2)
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }
    lpBuffer[0] = '1';
    lpBuffer[1] = '\0';
    *nSize = 2;

    return TRUE;
}

DWORD GetUserDirectory(
                       IN BOOL fMachineKeyset,
                       OUT LPWSTR pwszUser,
                       OUT DWORD *pcbUser
                       )
{
    DWORD   dwErr = 0;

    if (fMachineKeyset)
    {
        wcscpy(pwszUser, MACHINE_KEYS_DIR);
        *pcbUser = wcslen(pwszUser) + 1;
    }
    else
    {
        if (FIsWinNT())
        {
            if (!GetUserTextualSidW(pwszUser, pcbUser))
            {
                SetLastError((DWORD) NTE_BAD_KEYSET);
                goto Ret;
            }
        }
        else
        {
            dwErr = (DWORD)NTE_FAIL;
            goto Ret;
        }
    }
Ret:
    return dwErr;
}

#define WSZRSAPRODUCTSTRING  L"\\Microsoft\\Crypto\\RSA\\"
#define WSZDSSPRODUCTSTRING  L"\\Microsoft\\Crypto\\DSS\\"
#define PRODUCTSTRINGLEN    sizeof(WSZRSAPRODUCTSTRING) - sizeof(WCHAR)

DWORD
GetUserStorageArea(
    IN      DWORD dwProvType,
    IN      BOOL fMachineKeyset,
    IN      BOOL fOldWin2KMachineKeyPath,
    OUT     BOOL *pfIsLocalSystem,      // used if fMachineKeyset is FALSE, in this
                                        // case TRUE is returned if running as Local System
    IN  OUT LPWSTR *ppwszUserStorageArea
    )
{
    DWORD dwLastError = 0;

    *ppwszUserStorageArea = (LPWSTR)ContInfoAlloc(
                                    10 * sizeof(WCHAR)   // trailing slash and NULL
                                    );
    if (*ppwszUserStorageArea) {
        wcscpy(*ppwszUserStorageArea, L"T:\\Keys\\");
    }
    return dwLastError;
}

DWORD GetFilePath(
    IN      LPCWSTR  pwszUserStorageArea,
    IN      LPCWSTR  pwszFileName,
    IN OUT  LPWSTR   *ppwszFilePath
    )
{
    DWORD cbUserStorageArea;
    DWORD cbFileName;
    DWORD dwLastError = ERROR_SUCCESS;

    cbUserStorageArea = wcslen( pwszUserStorageArea ) * sizeof(WCHAR);

    cbFileName = wcslen( pwszFileName ) * sizeof(WCHAR);

    *ppwszFilePath = (LPWSTR)ContInfoAlloc( cbUserStorageArea + cbFileName + sizeof(WCHAR) );

    if( *ppwszFilePath == NULL )
    {
        dwLastError = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    CopyMemory(*ppwszFilePath, pwszUserStorageArea, cbUserStorageArea);
    CopyMemory((LPBYTE)*ppwszFilePath+cbUserStorageArea, pwszFileName, cbFileName + sizeof(WCHAR));
Ret:
    return dwLastError;
}

static DWORD rgdwCreateFileRetryMilliseconds[] =
    { 1, 10, 100, 500, 1000, 5000 };

#define MAX_CREATE_FILE_RETRY_COUNT     \
            (sizeof(rgdwCreateFileRetryMilliseconds) / \
                sizeof(rgdwCreateFileRetryMilliseconds[0]))

HANDLE MyCreateFile(
  IN BOOL fMachineKeyset,         // indicates if this is a machine keyset
  IN LPCWSTR wszFilePath,          // pointer to name of the file
  IN DWORD dwDesiredAccess,       // access (read-write) mode
  IN DWORD dwShareMode,           // share mode
  IN DWORD dwCreationDisposition,  // how to create
  IN DWORD dwAttribs  // file attributes
)
{
    HANDLE          hFile = INVALID_HANDLE_VALUE;
    LPSTR           szFilePath = NULL;
    DWORD           dwFilePath;

    dwFilePath = wcslen(wszFilePath)*2 + 2;
    szFilePath = _alloca( dwFilePath );
    if (0 == (dwFilePath = WideCharToMultiByte(CP_ACP, 0,
                                        wszFilePath,
                                        -1,
                                        szFilePath,
                                        dwFilePath,
                                        NULL,
                                        NULL)))
    {
        goto Ret;
    }

    hFile = CreateFileA(
                szFilePath,
                dwDesiredAccess,
                dwShareMode,
                NULL,
                dwCreationDisposition,
                dwAttribs,
                NULL
                );

Ret:

    return hFile;
}

DWORD OpenFileInStorageArea(
    IN      BOOL    fMachineKeyset,
    IN      DWORD   dwDesiredAccess,
    IN      LPCWSTR wszUserStorageArea,
    IN      LPCWSTR wszFileName,
    IN OUT  HANDLE  *phFile
    )
{
    LPWSTR wszFilePath = NULL;
    DWORD cbUserStorageArea;
    DWORD cbFileName;
    DWORD dwShareMode = 0;
    DWORD dwCreationDistribution = OPEN_EXISTING;
    DWORD dwRetryCount;
    DWORD dwAttribs = 0;
    DWORD dwLastError = ERROR_SUCCESS;

    *phFile = INVALID_HANDLE_VALUE;

    if( dwDesiredAccess & GENERIC_READ ) {
        dwShareMode |= FILE_SHARE_READ;
        dwCreationDistribution = OPEN_EXISTING;
    }

    if( dwDesiredAccess & GENERIC_WRITE ) {
        dwShareMode = 0;
        dwCreationDistribution = OPEN_ALWAYS;
        dwAttribs = FILE_ATTRIBUTE_SYSTEM;
    }

    if (0 != (dwLastError = GetFilePath(wszUserStorageArea, wszFileName,
                                        &wszFilePath)))
    {
        goto Ret;
    }

    dwRetryCount = 0;
    while (1)
    {
        *phFile = MyCreateFile(fMachineKeyset,
                               wszFilePath,
                               dwDesiredAccess,
                               dwShareMode,
                               dwCreationDistribution,
                               dwAttribs | FILE_FLAG_SEQUENTIAL_SCAN
                               );

        if( *phFile == INVALID_HANDLE_VALUE )
        {
            dwLastError = GetLastError();
            if (((ERROR_SHARING_VIOLATION == dwLastError) ||
                 (ERROR_ACCESS_DENIED == dwLastError)) &&
                (MAX_CREATE_FILE_RETRY_COUNT > dwRetryCount))
            {
                Sleep(rgdwCreateFileRetryMilliseconds[dwRetryCount]);
                dwRetryCount++;
            }
            else
            {
                goto Ret;
            }
        }
        else
        {
            break;
        }
    }
Ret:
    if(wszFilePath)
        ContInfoFree(wszFilePath);

    return dwLastError;
}

DWORD FindClosestFileInStorageArea(
    IN      LPCWSTR  pwszUserStorageArea,
    IN      LPCSTR   pszContainer,
    OUT     LPWSTR   pwszNewFileName,
    IN OUT  HANDLE  *phFile
    )
{
#ifndef _XBOX
    LPWSTR pwszFilePath = NULL;
    WCHAR  rgwszNewFileName[35];
    DWORD cbUserStorageArea;
    DWORD cbFileName;
    DWORD dwShareMode = 0;
    DWORD dwCreationDistribution = OPEN_EXISTING;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAW FindData;
    DWORD dwLastError = ERROR_SUCCESS;

    memset(&FindData, 0, sizeof(FindData));
    memset(rgwszNewFileName, 0, sizeof(rgwszNewFileName));

    *phFile = INVALID_HANDLE_VALUE;

    dwShareMode |= FILE_SHARE_READ;
    dwCreationDistribution = OPEN_EXISTING;

    // get the stringized hash of the container name
    if (0 != (dwLastError = GetHashOfContainer(pszContainer, rgwszNewFileName)))
    {
        goto Ret;
    }

    // ContInfoAlloc zeros memory so no need to set NULL terminator
    rgwszNewFileName[32] = '_';
    rgwszNewFileName[33] = '*';

    if (0 != (dwLastError = GetFilePath(pwszUserStorageArea, rgwszNewFileName,
                                        &pwszFilePath)))
    {
        goto Ret;
    }

    hFind = FindFirstFileExW(
                pwszFilePath,
                FindExInfoStandard,
                &FindData,
                FindExSearchNameMatch,
                NULL, 
                0
                );
    
    if( hFind == INVALID_HANDLE_VALUE )
    {
        dwLastError = NTE_BAD_KEYSET;
        goto Ret;
    }

    ContInfoFree(pwszFilePath);
    pwszFilePath = NULL;

    if (0 != (dwLastError = GetFilePath(pwszUserStorageArea, FindData.cFileName,
                                        &pwszFilePath)))
    {
        goto Ret;
    }

    *phFile = CreateFileW(
                pwszFilePath,
                GENERIC_READ,
                dwShareMode,
                NULL,
                dwCreationDistribution,
                FILE_FLAG_SEQUENTIAL_SCAN,
                NULL
                );

    if( *phFile == INVALID_HANDLE_VALUE )
    {
        dwLastError = NTE_BAD_KEYSET;
        goto Ret;
    }

    // allocate and copy in the real file name to be returned
    wcscpy(pwszNewFileName, FindData.cFileName);
Ret:
    if (hFind)
        FindClose(hFind);
    if(pwszFilePath)
        ContInfoFree(pwszFilePath);

    return dwLastError;
#else
    return NTE_BAD_KEYSET;
#endif
}

//
//  This function gets the determines if the user associated with the
//  specified token is the Local System account.
//
DWORD ZeroizeFile(
    IN      LPCWSTR  wszFilePath
    )
{
#ifndef _XBOX
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    BYTE    *pb = NULL;
    DWORD   cb;
    DWORD   dwBytesWritten = 0;
    DWORD   dwErr = ERROR_SUCCESS;

    if (INVALID_HANDLE_VALUE == (hFile = CreateFileW(wszFilePath,
                                                     GENERIC_WRITE,
                                                     0,
                                                     NULL,
                                                     OPEN_EXISTING,
                                                     FILE_ATTRIBUTE_SYSTEM,
                                                     NULL)))
    {
        dwErr = (DWORD)NTE_BAD_KEYSET;
        goto Ret;
    }

    if (0xFFFFFFFF == (cb = GetFileSize(hFile, NULL)))
    {
        dwErr = (DWORD)NTE_BAD_KEYSET;
        goto Ret;
    }

    if (NULL == (pb = ContInfoAlloc(cb)))
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    if (!WriteFile(hFile, pb, cb, &dwBytesWritten, NULL))
    {
        dwErr = (DWORD)NTE_BAD_KEYSET;
        goto Ret;
    }
    if (cb != dwBytesWritten)
    {
        dwErr = (DWORD)NTE_FAIL;
    }
Ret:
    if (pb)
        ContInfoFree(pb);

    if (INVALID_HANDLE_VALUE != hFile)
        CloseHandle(hFile);

    return dwErr;
#else
    return 0;
#endif
}

DWORD DeleteFileInStorageArea(
    IN      LPCWSTR  wszUserStorageArea,
    IN      LPCWSTR  wszFileName
    )
{
    LPWSTR wszFilePath = NULL;
    LPSTR szFilePath = NULL;
    DWORD dwFilePath;
    DWORD cbUserStorageArea;
    DWORD cbFileName;
    DWORD dwErr = ERROR_SUCCESS;

    cbUserStorageArea = wcslen( wszUserStorageArea ) * sizeof(WCHAR);
    cbFileName = wcslen( wszFileName ) * sizeof(WCHAR);

    wszFilePath = (LPWSTR)ContInfoAlloc( (cbUserStorageArea + cbFileName + 1) * sizeof(WCHAR) );

    if( wszFilePath == NULL )
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    CopyMemory(wszFilePath, wszUserStorageArea, cbUserStorageArea);
    CopyMemory((LPBYTE)wszFilePath + cbUserStorageArea, wszFileName,
               cbFileName + sizeof(WCHAR));

    // write a file of the same size with all zeros first
    if (ERROR_SUCCESS != (dwErr = ZeroizeFile(wszFilePath)))
        goto Ret;

    dwFilePath = cbUserStorageArea + cbFileName + 2;
    szFilePath = _alloca( dwFilePath );
    if (0 == (dwFilePath = WideCharToMultiByte(CP_ACP, 0,
                                        wszFilePath,
                                        -1,
                                        szFilePath,
                                        dwFilePath,
                                        NULL,
                                        NULL)))
    {
        dwErr = GetLastError();
        goto Ret;
    }
    
    if (!DeleteFileA(szFilePath))
    {
        dwErr = GetLastError();
        SetLastError((DWORD)NTE_BAD_KEYSET);
    }
Ret:
    if(wszFilePath)
        ContInfoFree(wszFilePath);
    return dwErr;
}


DWORD SetContainerUserName(
                           IN LPSTR pszUserName,
                           IN PKEY_CONTAINER_INFO pContInfo
                           )
{
    DWORD   dwErr = 0;

    if (NULL == (pContInfo->pszUserName =
        (LPSTR)ContInfoAlloc((strlen(pszUserName) + 1) * sizeof(CHAR))))
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    strcpy(pContInfo->pszUserName, pszUserName);
Ret:
    return dwErr;
}

DWORD NT5ToNT5Migration(
                        IN DWORD dwProvType,
                        IN BOOL fMachineKeyset,
                        IN LPSTR pszContainer,
                        IN LPWSTR pwszFilePath,
                        IN DWORD dwFlags,
                        OUT PKEY_CONTAINER_INFO pContInfo,
                        OUT HANDLE *phFile
                        )
{
#ifndef _XBOX
    LPWSTR  pwszOldFilePath = NULL;
    LPWSTR  pwszOldFullFilePath = NULL;
    LPWSTR  pwszNewFullFilePath = NULL;
    LPWSTR  pwszFileName = NULL;
    BOOL    fAllocedFileName = FALSE;
    BOOL    fIsLocalSystem;
    BOOL    fRetryWithHashedName = TRUE;
    DWORD   cch = 0;
    DWORD   dwErr = 0;

    // get the correct storage area (directory)
    if (0 != (dwErr = GetUserStorageArea(dwProvType,
                                         fMachineKeyset,
                                         TRUE,
                                         &fIsLocalSystem,
                                         &pwszOldFilePath)))
    {
        goto Ret;
    }

    // check if the length of the container name is the length of a new unique container,
    // then try with the container name which was passed in, if this fails
    // then try with the container name with the machine GUID appended
    if (69 == strlen(pszContainer))
    {
        // convert to UNICODE pszContainer -> pwszFileName
        if (0 == (cch = MultiByteToWideChar(CP_ACP, 0,
                                            pszContainer,
                                            -1, NULL, cch)))
        {
            dwErr = GetLastError();
            goto Ret;
        }

        if (NULL == (pwszFileName = ContInfoAlloc((cch + 1) * sizeof(WCHAR))))
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto Ret;
        }
        fAllocedFileName = TRUE;

        if (0 == (cch = MultiByteToWideChar(CP_ACP, 0,
                                            pszContainer,
                                            -1, pwszFileName, cch)))
        {
             dwErr = GetLastError();
             goto Ret;
        }

        if (ERROR_SUCCESS != OpenFileInStorageArea(fMachineKeyset,
                                                   GENERIC_READ,
                                                   pwszOldFilePath,
                                                   pwszFileName,
                                                   phFile))
        {
            ContInfoFree(pwszFileName);
            pwszFileName = NULL;
            fAllocedFileName = FALSE;
            fRetryWithHashedName = TRUE;
        }
        else
        {
            fRetryWithHashedName = FALSE;
        }
    }

    if (fRetryWithHashedName)
    {
        pwszFileName = pContInfo->rgwszFileName;
        if(ERROR_SUCCESS != (dwErr = OpenFileInStorageArea(fMachineKeyset,
                                                           GENERIC_READ,
                                                           pwszOldFilePath,
                                                           pwszFileName,
                                                           phFile)))
        {
            if ((ERROR_ACCESS_DENIED == dwErr) && (dwFlags & CRYPT_NEWKEYSET))
            {
                dwErr = (DWORD)NTE_EXISTS;
            }

            goto Ret;
        }
    }

    // found an old file so move it to the new directory
    CloseHandle(*phFile);
    *phFile = INVALID_HANDLE_VALUE;

    if (0 != (dwErr = GetFilePath(pwszOldFilePath, pwszFileName, &pwszOldFullFilePath)))
    {
        goto Ret;
    }
    if (0 != (dwErr = GetFilePath(pwszFilePath, pwszFileName, &pwszNewFullFilePath)))
    {
        goto Ret;
    }

    if (!MoveFileW(pwszOldFullFilePath, pwszNewFullFilePath))
    {
        dwErr = GetLastError();
        goto Ret;
    }

    if(ERROR_SUCCESS != (dwErr = OpenFileInStorageArea(fMachineKeyset,
                                              GENERIC_READ,
                                              pwszFilePath,
                                              pwszFileName,
                                              phFile)))
    {
        goto Ret;
    }
Ret:
    if (fAllocedFileName && (NULL != pwszFileName))
    {
        ContInfoFree(pwszFileName);
    }
    if (pwszOldFullFilePath)
        ContInfoFree(pwszOldFullFilePath);
    if (pwszNewFullFilePath)
        ContInfoFree(pwszNewFullFilePath);
    if (pwszOldFilePath)
        ContInfoFree(pwszOldFilePath);

    return dwErr;
#else
    return 0;
#endif
}

DWORD ReadContainerInfo(
                        IN DWORD dwProvType,
                        IN LPSTR pszContainerName,
                        IN BOOL fMachineKeyset,
                        IN DWORD dwFlags,
                        OUT PKEY_CONTAINER_INFO pContInfo
                        )
{
    HANDLE                  hMap = NULL;
    BYTE                    *pbFile = NULL;
    DWORD                   cbFile;
    DWORD                   cb;
    HANDLE                  hFile = INVALID_HANDLE_VALUE;
    KEY_EXPORTABILITY_LENS  Exportability;
    LPWSTR                  pwszFileName = NULL;
    LPWSTR                  pwszFilePath = NULL;
    WCHAR                   rgwszOtherMachineFileName[84];
    DWORD                   cbFileName;
    BOOL                    fGetUserNameFromFile = FALSE;
    BOOL                    fIsLocalSystem = FALSE;
    BOOL                    fRetryWithHashedName = TRUE;
    DWORD                   cch = 0;
    DWORD                   dwErrOpen = 0;
    DWORD                   dwErr = 0;

    memset(&Exportability, 0, sizeof(Exportability));

    // get the correct storage area (directory)
    if (0 != (dwErr = GetUserStorageArea(dwProvType, fMachineKeyset, FALSE,
                                         &fIsLocalSystem, &pwszFilePath)))
    {
        goto Ret;
    }

    // check if the length of the container name is the length of a new unique container,
    // then try with the container name which was passed in, if this fails
    // then try with the container name with the machine GUID appended
    if (69 == strlen(pszContainerName))
    {
        // convert to UNICODE pszContainerName -> pwszFileName
        if (0 == (cch = MultiByteToWideChar(CP_ACP, 0,
                                            pszContainerName,
                                            -1, NULL, cch)))
        {
            dwErr = GetLastError();
            goto Ret;
        }

        if (NULL == (pwszFileName = ContInfoAlloc((cch + 1) * sizeof(WCHAR))))
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto Ret;
        }

        if (0 == (cch = MultiByteToWideChar(CP_ACP, 0,
                                            pszContainerName,
                                            -1, pwszFileName, cch)))
        {
             dwErr = GetLastError();
             goto Ret;
        }

        if (ERROR_SUCCESS == OpenFileInStorageArea(fMachineKeyset,
                                                   GENERIC_READ,
                                                   pwszFilePath,
                                                   pwszFileName,
                                                   &hFile))
        {
            wcscpy(pContInfo->rgwszFileName, pwszFileName);

            // set the flag so the name of the key container will be retrieved from the file
            fGetUserNameFromFile = TRUE;
            fRetryWithHashedName = FALSE;
        }
    }

    if (fRetryWithHashedName)
    {
        if (0 != (dwErr = AddMachineGuidToContainerName(pszContainerName,
                                                        pContInfo->rgwszFileName)))
        {
            goto Ret;
        }
        if(ERROR_SUCCESS != (dwErrOpen = OpenFileInStorageArea(fMachineKeyset, GENERIC_READ,
                                                  pwszFilePath,
                                                  pContInfo->rgwszFileName,
                                                  &hFile)))
        {
            if ((ERROR_ACCESS_DENIED == dwErrOpen) && (dwFlags & CRYPT_NEWKEYSET))
            {
                dwErr = (DWORD)NTE_EXISTS;
                goto Ret;
            }

            if (fMachineKeyset || fIsLocalSystem)
            {
                if (0 != (dwErr = NT5ToNT5Migration(dwProvType,
                                                    fMachineKeyset,
                                                    pszContainerName,
                                                    pwszFilePath,
                                                    dwFlags,
                                                    pContInfo,
                                                    &hFile)))
                {
                    if (ERROR_ACCESS_DENIED == dwErr)
                    {
                        dwErr = (DWORD)NTE_EXISTS;
                    }
                    else
                    {
                        dwErr = (DWORD)NTE_BAD_KEYSET;
                    }
                    goto Ret;
                }
            }
            else
            {
                memset(rgwszOtherMachineFileName, 0, sizeof(rgwszOtherMachineFileName));
                // try to open any file from another machine with this container name
                if(ERROR_SUCCESS != FindClosestFileInStorageArea(pwszFilePath,
                                                             pszContainerName,
                                                             rgwszOtherMachineFileName,
                                                             &hFile))
                {
                    dwErr = (DWORD)NTE_BAD_KEYSET;
                    goto Ret;
                }
                else
                { 
                    wcscpy(pContInfo->rgwszFileName, rgwszOtherMachineFileName);
                }
            }
        }
    }

    if (dwFlags & CRYPT_NEWKEYSET)
    {
        dwErr = (DWORD)NTE_EXISTS;
        goto Ret;
    }

    if (0xFFFFFFFF == (cbFile = GetFileSize(hFile, NULL)))
    {
        dwErr = (DWORD)NTE_BAD_KEYSET;
        goto Ret;
    }
    if (sizeof(KEY_CONTAINER_LENS) > cbFile)
    {
        dwErr = (DWORD)NTE_BAD_KEYSET;
        goto Ret;
    }

    pbFile = _alloca( cbFile );
    
    if (!ReadFile(hFile,
                (LPVOID)pbFile,
                cbFile,
                &cbFile,
                NULL))
    {
        dwErr = (DWORD)NTE_BAD_KEYSET;
        goto Ret;
    }

    // get the length information out of the file
    memcpy(&pContInfo->dwVersion, pbFile, sizeof(DWORD));
    cb = sizeof(DWORD);
    if (KEY_CONTAINER_FILE_FORMAT_VER != pContInfo->dwVersion)
    {
        dwErr = (DWORD)NTE_BAD_KEYSET;
        goto Ret;
    }
    memcpy(&pContInfo->ContLens, pbFile + cb, sizeof(KEY_CONTAINER_LENS));
    cb += sizeof(KEY_CONTAINER_LENS);

    if (pContInfo->fCryptSilent && (0 != pContInfo->ContLens.dwUIOnKey))
    {
        dwErr = (DWORD)NTE_SILENT_CONTEXT;
        goto Ret;
    }

    // get the private key exportability stuff
    memcpy(&Exportability, pbFile + cb, sizeof(KEY_EXPORTABILITY_LENS)); 
    cb += sizeof(KEY_EXPORTABILITY_LENS);

    // get the user name
    if (NULL == (pContInfo->pszUserName =
        ContInfoAlloc(pContInfo->ContLens.cbName)))
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }
    memcpy(pContInfo->pszUserName, pbFile + cb, pContInfo->ContLens.cbName);
    cb += pContInfo->ContLens.cbName;

    // get the random seed
    if (NULL == (pContInfo->pbRandom =
        ContInfoAlloc(pContInfo->ContLens.cbRandom)))
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }
    memcpy(pContInfo->pbRandom, pbFile + cb, pContInfo->ContLens.cbRandom);
    cb += pContInfo->ContLens.cbRandom;

    // get the signature key info out of the file
    if (pContInfo->ContLens.cbSigPub && pContInfo->ContLens.cbSigEncPriv)
    {
        if (NULL == (pContInfo->pbSigPub =
            ContInfoAlloc(pContInfo->ContLens.cbSigPub)))
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto Ret;
        }
        memcpy(pContInfo->pbSigPub, pbFile + cb, pContInfo->ContLens.cbSigPub);
        cb += pContInfo->ContLens.cbSigPub;

        if (NULL == (pContInfo->pbSigEncPriv =
            ContInfoAlloc(pContInfo->ContLens.cbSigEncPriv)))
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto Ret;
        }
        memcpy(pContInfo->pbSigEncPriv, pbFile + cb,
               pContInfo->ContLens.cbSigEncPriv);
        cb += pContInfo->ContLens.cbSigEncPriv;

        // get the exportability info for the sig key
        if (0 != (dwErr = UnprotectExportabilityFlag(fMachineKeyset, pbFile + cb,
                                 Exportability.cbSigExportability,
                                 &pContInfo->fSigExportable)))
        {
            dwErr = (DWORD)NTE_BAD_KEYSET;
            goto Ret;
        }
        cb += Exportability.cbSigExportability;
    }

    // get the signature key info out of the file
    if (pContInfo->ContLens.cbExchPub && pContInfo->ContLens.cbExchEncPriv)
    {
        if (NULL == (pContInfo->pbExchPub =
            ContInfoAlloc(pContInfo->ContLens.cbExchPub)))
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto Ret;
        }
        memcpy(pContInfo->pbExchPub, pbFile + cb,
               pContInfo->ContLens.cbExchPub);
        cb += pContInfo->ContLens.cbExchPub;

        if (NULL == (pContInfo->pbExchEncPriv =
            ContInfoAlloc(pContInfo->ContLens.cbExchEncPriv)))
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto Ret;
        }
        memcpy(pContInfo->pbExchEncPriv, pbFile + cb,
               pContInfo->ContLens.cbExchEncPriv);
        cb += pContInfo->ContLens.cbExchEncPriv;

        // get the exportability info for the sig key
        if (0 != (dwErr = UnprotectExportabilityFlag(fMachineKeyset, pbFile + cb,
                                 Exportability.cbExchExportability,
                                 &pContInfo->fExchExportable)))
        {
            dwErr = (DWORD)NTE_BAD_KEYSET;
            goto Ret;
        }
        cb += Exportability.cbExchExportability;
    }
Ret:
    if (pwszFileName)
        ContInfoFree(pwszFileName);

    if (0 != dwErr)
    {
        if (pContInfo)
        {
            FreeContainerInfo(pContInfo);
        }
    }

    if (pwszFilePath)
        ContInfoFree(pwszFilePath);

    if(hMap)
        CloseHandle(hMap);

    if(INVALID_HANDLE_VALUE != hFile)
        CloseHandle(hFile);

    return dwErr;
}

DWORD WriteContainerInfo(
                         IN DWORD dwProvType,
                         IN LPWSTR pwszFileName,
                         IN BOOL fMachineKeyset,
                         IN PKEY_CONTAINER_INFO pContInfo
                         )
{
    BYTE                    *pbProtectedSigExportFlag = NULL;
    DWORD                   cbProtectedSigExportFlag;
    BYTE                    *pbProtectedExchExportFlag = NULL;
    DWORD                   cbProtectedExchExportFlag;
    KEY_EXPORTABILITY_LENS  ExportabilityLens;
    BYTE                    *pb = NULL;
    DWORD                   cb;
    LPWSTR                  pwszFilePath = NULL;
    HANDLE                  hFile = 0;
    DWORD                   dwBytesWritten;
    BOOL                    fIsLocalSystem = FALSE;
    DWORD                   dwErr = 0;

    memset(&ExportabilityLens, 0, sizeof(ExportabilityLens));

    // protect the signature exportability flag if necessary
    if (pContInfo->ContLens.cbSigPub && pContInfo->ContLens.cbSigEncPriv)
    {
        if (0 != (dwErr = ProtectExportabilityFlag(pContInfo->fSigExportable,
                                fMachineKeyset, &pbProtectedSigExportFlag,
                                &ExportabilityLens.cbSigExportability)))
        {
            goto Ret;
        }
    }
    
    // protect the key exchange exportability flag if necessary
    if (pContInfo->ContLens.cbExchPub && pContInfo->ContLens.cbExchEncPriv)
    {
        if (0 != (dwErr = ProtectExportabilityFlag(pContInfo->fExchExportable,
                                fMachineKeyset, &pbProtectedExchExportFlag,
                                &ExportabilityLens.cbExchExportability)))
        {
            goto Ret;
        }
    }

    pContInfo->ContLens.cbName = strlen(pContInfo->pszUserName) + sizeof(CHAR);
    
    // calculate the buffer length required for the container info
    cb = pContInfo->ContLens.cbSigPub + pContInfo->ContLens.cbSigEncPriv + 
         pContInfo->ContLens.cbExchPub + pContInfo->ContLens.cbExchEncPriv +
         ExportabilityLens.cbSigExportability +
         ExportabilityLens.cbExchExportability +
         pContInfo->ContLens.cbName +
         pContInfo->ContLens.cbRandom +
         sizeof(KEY_EXPORTABILITY_LENS) + sizeof(KEY_CONTAINER_INFO) +
         sizeof(DWORD);

    if (NULL == (pb = (BYTE*)ContInfoAlloc(cb)))
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    // copy the length information
    pContInfo->dwVersion = KEY_CONTAINER_FILE_FORMAT_VER;
    memcpy(pb, &pContInfo->dwVersion, sizeof(DWORD));
    cb = sizeof(DWORD);
    memcpy(pb + cb, &pContInfo->ContLens, sizeof(KEY_CONTAINER_LENS));
    cb += sizeof(KEY_CONTAINER_LENS);
    if (KEY_CONTAINER_FILE_FORMAT_VER != pContInfo->dwVersion)
    {
        dwErr = (DWORD)NTE_BAD_KEYSET;
        goto Ret;
    }

    memcpy(pb + cb, &ExportabilityLens, sizeof(KEY_EXPORTABILITY_LENS)); 
    cb += sizeof(KEY_EXPORTABILITY_LENS);

    // copy the name of the container to the file
    memcpy(pb + cb, pContInfo->pszUserName, pContInfo->ContLens.cbName);
    cb += pContInfo->ContLens.cbName;

    // copy the random seed to the file
    memcpy(pb + cb, pContInfo->pbRandom, pContInfo->ContLens.cbRandom);
    cb += pContInfo->ContLens.cbRandom;

    // copy the signature key info to the file
    if (pContInfo->ContLens.cbSigPub || pContInfo->ContLens.cbSigEncPriv)
    {
        memcpy(pb + cb, pContInfo->pbSigPub, pContInfo->ContLens.cbSigPub);
        cb += pContInfo->ContLens.cbSigPub;

        memcpy(pb + cb, pContInfo->pbSigEncPriv,
               pContInfo->ContLens.cbSigEncPriv);
        cb += pContInfo->ContLens.cbSigEncPriv;

        // write the exportability info for the sig key
        memcpy(pb + cb, pbProtectedSigExportFlag,
               ExportabilityLens.cbSigExportability);
        cb += ExportabilityLens.cbSigExportability;
    }

    // get the signature key info out of the file
    if (pContInfo->ContLens.cbExchPub || pContInfo->ContLens.cbExchEncPriv)
    {
        memcpy(pb + cb, pContInfo->pbExchPub, pContInfo->ContLens.cbExchPub);
        cb += pContInfo->ContLens.cbExchPub;

        memcpy(pb + cb, pContInfo->pbExchEncPriv,
               pContInfo->ContLens.cbExchEncPriv);
        cb += pContInfo->ContLens.cbExchEncPriv;

        // write the exportability info for the sig key
        memcpy(pb + cb, pbProtectedExchExportFlag,
               ExportabilityLens.cbExchExportability);
        cb += ExportabilityLens.cbExchExportability;
    }

    // get the correct storage area (directory)
    if (0 != (dwErr = GetUserStorageArea(dwProvType, fMachineKeyset, FALSE,
                                         &fIsLocalSystem, &pwszFilePath)))
    {
        goto Ret;
    }

    // open the file to write the information to
    if(ERROR_SUCCESS != OpenFileInStorageArea(fMachineKeyset, GENERIC_WRITE,
                                              pwszFilePath, pwszFileName,
                                              &hFile))
    {
        dwErr = (DWORD)NTE_FAIL;
        goto Ret;
    }

    if (!WriteFile(hFile, pb, cb, &dwBytesWritten, NULL))
    {
        dwErr = (DWORD)NTE_FAIL;
        goto Ret;
    }
    if (cb != dwBytesWritten)
    {
        dwErr = (DWORD)NTE_FAIL;
        goto Ret;
    }
Ret:
    if (pwszFilePath)
        ContInfoFree(pwszFilePath);
    if (pbProtectedSigExportFlag)
        ContInfoFree(pbProtectedSigExportFlag);
    if (pbProtectedExchExportFlag)
        ContInfoFree(pbProtectedExchExportFlag);
    if (pb)
        ContInfoFree(pb);

    if (hFile)
        CloseHandle(hFile);
    return dwErr;
}

DWORD DeleteKeyContainer(
                         IN LPWSTR pwszFilePath,
                         IN LPSTR pszContainer
                         )
{
    LPWSTR  pwszFileName = NULL;
    WCHAR   rgwchNewFileName[80];
    BOOL    fRetryWithHashedName = TRUE;
    DWORD   cch = 0;
    DWORD   dwErr = 0;

    memset(rgwchNewFileName, 0, sizeof(rgwchNewFileName));

    // first try with the container name which was passed in, if this fails
    if (69 == strlen(pszContainer))
    {
        // convert to UNICODE pszContainer -> pwszFileName
        if (0 == (cch = MultiByteToWideChar(CP_ACP, 0,
                                            pszContainer,
                                            -1, NULL, cch)))
        {
            dwErr = GetLastError();
            goto Ret;
        }

        if (NULL == (pwszFileName = ContInfoAlloc((cch + 1) * sizeof(WCHAR))))
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto Ret;
        }

        if (0 == (cch = MultiByteToWideChar(CP_ACP, 0,
                                            pszContainer,
                                            -1, pwszFileName, cch)))
        {
             dwErr = GetLastError();
             goto Ret;
        }

        if (0 == DeleteFileInStorageArea(pwszFilePath, pwszFileName))
        {
            fRetryWithHashedName = FALSE;
        }
    }

    // then try with hash of container name and the machine GUID appended
    if (fRetryWithHashedName)
    {
        if (0 != (dwErr = AddMachineGuidToContainerName(pszContainer,
                                                        rgwchNewFileName)))
        {
            goto Ret;
        }

        dwErr = DeleteFileInStorageArea(pwszFilePath, rgwchNewFileName);
    }
Ret:
    if (pwszFileName)
        ContInfoFree(pwszFileName);

    return dwErr;
}


DWORD DeleteContainerInfo(
                          IN DWORD dwProvType,
                          IN LPSTR pszContainer,
                          IN BOOL fMachineKeyset
                          )
{
    LPWSTR  pwszFilePath = NULL;
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    BOOL    fIsLocalSystem = FALSE;
    WCHAR   rgwchNewFileName[80];
    DWORD   dwErr = 0;

    // get the correct storage area (directory)
    if (0 != (dwErr = GetUserStorageArea(dwProvType, fMachineKeyset, FALSE,
                                         &fIsLocalSystem, &pwszFilePath)))
    {
        goto Ret;
    }

    if (0 != (dwErr = DeleteKeyContainer(pwszFilePath, pszContainer)))
    {
        // for migration of machine keys from system to All Users\App Data
        if (fMachineKeyset)
        {
            ContInfoFree(pwszFilePath);
            pwszFilePath = NULL;

            if (0 != (dwErr = GetUserStorageArea(dwProvType, fMachineKeyset, TRUE,
                                                 &fIsLocalSystem, &pwszFilePath)))
            {
                goto Ret;
            }

            if (0 != (dwErr = DeleteKeyContainer(pwszFilePath, pszContainer)))
            {
                goto Ret;
            }
        }
        else
        {
            goto Ret;
        }
    }

    // there may be other keys created with the same container name on
    // different machines and these also need to be deleted
    while (1)
    {
        memset(rgwchNewFileName, 0, sizeof(rgwchNewFileName));

        if (0 != FindClosestFileInStorageArea(pwszFilePath, pszContainer,
                                              rgwchNewFileName, &hFile))
        {
            break;
        }

        CloseHandle(hFile);
        hFile = INVALID_HANDLE_VALUE;

        dwErr = DeleteFileInStorageArea(pwszFilePath, rgwchNewFileName);
    }
    if (0 != dwErr)
    {
        dwErr = (DWORD)NTE_BAD_KEYSET;
        goto Ret;
    }

Ret:
    if(INVALID_HANDLE_VALUE != hFile)
        CloseHandle(hFile);

    if (pwszFilePath)
        ContInfoFree(pwszFilePath);
    return dwErr;
}

DWORD GetUniqueContainerName(
                             IN KEY_CONTAINER_INFO *pContInfo,
                             OUT BYTE *pbData,
                             OUT DWORD *pcbData
                             )
{
    LPSTR   pszUniqueContainer = NULL;
    DWORD   cch = 0;
    DWORD   dwErr = 0;

    if (0 == (cch = WideCharToMultiByte(CP_ACP, 0,
                                        pContInfo->rgwszFileName,
                                        -1,
                                        NULL,
                                        cch,
                                        NULL,
                                        NULL)))
    {
        dwErr = GetLastError();
        goto Ret;
    }

    if (NULL == (pszUniqueContainer = (LPSTR)ContInfoAlloc((cch + 1) * sizeof(WCHAR))))
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    if (0 == (cch = WideCharToMultiByte(CP_ACP, 0,
                                        pContInfo->rgwszFileName,
                                        -1,
                                        pszUniqueContainer,
                                        cch,
                                        NULL,
                                        NULL)))
    {
        dwErr = GetLastError();
        goto Ret;
    }

    if (pbData == NULL || *pcbData < (strlen(pszUniqueContainer) + 1))
    {
        *pcbData = strlen(pszUniqueContainer) + 1;

        if (pbData != NULL)
        {
            dwErr = ERROR_MORE_DATA;
        }
        goto Ret;
    }

    *pcbData = strlen(pszUniqueContainer) + 1;

    strcpy(pbData, pszUniqueContainer);
Ret:
    if (pszUniqueContainer)
        ContInfoFree(pszUniqueContainer);

    return dwErr;
}

//
// Function : MachineGuidInFilename
//
// Description : Check if the given Machine GUID is in the given filename.
//               Returns TRUE if it is FALSE if it is not.
//

BOOL MachineGuidInFilename(
                           LPWSTR pwszFileName,
                           LPWSTR pwszMachineGuid
                           )
{
    DWORD   cbFileName;
    BOOL    fRet = FALSE;

    cbFileName = wcslen(pwszFileName);

    // make sure the length of the filename is longer than the GUID
    if (cbFileName < (DWORD)wcslen(pwszMachineGuid))
        goto Ret;

    // compare the GUID with the last 36 characters of the file name
    if (0 == memcmp(pwszMachineGuid, &(pwszFileName[cbFileName - 36]),
                    36 * sizeof(WCHAR)))
        fRet = TRUE;
Ret:
    return fRet;
}

// Converts to UNICODE and uses RegOpenKeyExW
DWORD MyRegOpenKeyEx(IN HKEY hRegKey,
                     IN LPSTR pszKeyName,
                     IN DWORD dwReserved,
                     IN REGSAM SAMDesired,
                     OUT HKEY *phNewRegKey)
{
    WCHAR   rgwchFastBuff[(MAX_PATH + 1) * 2];
    LPWSTR  pwsz = NULL;
    BOOL    fAlloced = FALSE;
    DWORD   cch = 0;
    DWORD   dwErr = ERROR_SUCCESS;

    memset(rgwchFastBuff, 0, sizeof(rgwchFastBuff));

    // convert reg key name to unicode
    if (0 == (cch = MultiByteToWideChar(CP_ACP, 0,
                                        pszKeyName,
                                        -1, NULL, cch)))
    {
        dwErr = GetLastError();
        goto Ret;
    }

    if ((cch + 1) > ((MAX_PATH + 1) * 2))
    {
        if (NULL == (pwsz = ContInfoAlloc((cch + 1) * sizeof(WCHAR))))
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto Ret;
        }
        fAlloced = TRUE;
    }
    else
    {
        pwsz = rgwchFastBuff;
    }

    if (0 == (cch = MultiByteToWideChar(CP_ACP, 0,
                                        pszKeyName,
                                        -1, pwsz, cch)))
    {
        dwErr = GetLastError();
        goto Ret;
    }

    dwErr = RegOpenKeyExW(hRegKey,
                          pwsz,
                          dwReserved,
                          SAMDesired,
                          phNewRegKey);
Ret:
    if (fAlloced && pwsz)
    {
        ContInfoFree(pwsz);
    }

    return dwErr;
}

// Converts to UNICODE and uses RegDeleteKeyW
DWORD MyRegDeleteKey(IN HKEY hRegKey,
                     IN LPSTR pszKeyName)
{
    WCHAR   rgwchFastBuff[(MAX_PATH + 1) * 2];
    LPWSTR  pwsz = NULL;
    BOOL    fAlloced = FALSE;
    DWORD   cch = 0;
    DWORD   dwErr = ERROR_SUCCESS;

    memset(rgwchFastBuff, 0, sizeof(rgwchFastBuff));

    // convert reg key name to unicode
    if (0 == (cch = MultiByteToWideChar(CP_ACP, 0,
                                        pszKeyName,
                                        -1, NULL, cch)))
    {
        dwErr = GetLastError();
        goto Ret;
    }

    if ((cch + 1) > ((MAX_PATH + 1) * 2))
    {
        if (NULL == (pwsz = ContInfoAlloc((cch + 1) * sizeof(WCHAR))))
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto Ret;
        }
        fAlloced = TRUE;
    }
    else
    {
        pwsz = rgwchFastBuff;
    }

    if (0 == (cch = MultiByteToWideChar(CP_ACP, 0,
                                        pszKeyName,
                                        -1, pwsz, cch)))
    {
        dwErr = GetLastError();
        goto Ret;
    }

    dwErr = RegDeleteKeyW(hRegKey, pwsz);
Ret:
    if (fAlloced && pwsz)
    {
        ContInfoFree(pwsz);
    }

    return dwErr;
}

DWORD AllocAndSetLocationBuff(
                              BOOL fMachineKeySet,
                              DWORD dwProvType,
                              CONST char *pszUserID,
                              HKEY *phTopRegKey,
                              TCHAR **ppszLocBuff,
                              BOOL fUserKeys,
                              BOOL *pfLeaveOldKeys
                              )
{
    CHAR    szSID[MAX_PATH];
    DWORD   cbSID = MAX_PATH;
    DWORD   cbLocBuff = 0;
    DWORD   cbTmp = 0;
    CHAR    *pszTmp;
    BOOL    fIsThreadLocalSystem = FALSE;
    DWORD   i;
    DWORD   cbRet = 0;

    if (fMachineKeySet)
    {
        *phTopRegKey = HKEY_LOCAL_MACHINE;
        if ((PROV_RSA_FULL == dwProvType) ||
            (PROV_RSA_SCHANNEL == dwProvType))
        {
            cbTmp = RSA_MACH_REG_KEY_LOC_LEN;
            pszTmp = RSA_MACH_REG_KEY_LOC;
        }
        else if ((PROV_DSS == dwProvType) ||
                 (PROV_DSS_DH == dwProvType) ||
                 (PROV_DH_SCHANNEL == dwProvType))
        {
            cbTmp = DSS_MACH_REG_KEY_LOC_LEN;
            pszTmp = DSS_MACH_REG_KEY_LOC;
        }
        else
        {
            SetLastError((DWORD) NTE_FAIL);
            goto Ret;
        }
    }
    else
    {
        if ((PROV_RSA_FULL == dwProvType) ||
            (PROV_RSA_SCHANNEL == dwProvType))
        {
            cbTmp = RSA_REG_KEY_LOC_LEN;
            pszTmp = RSA_REG_KEY_LOC;
        }
        else if ((PROV_DSS == dwProvType) ||
                 (PROV_DSS_DH == dwProvType) ||
                 (PROV_DH_SCHANNEL == dwProvType))
        {
            cbTmp = DSS_REG_KEY_LOC_LEN;
            pszTmp = DSS_REG_KEY_LOC;
        }
        else
        {
            SetLastError((DWORD) NTE_FAIL);
            goto Ret;
        }

        if (FIsWinNT())
        {
            IsThreadLocalSystem(&fIsThreadLocalSystem);

            if (!GetUserTextualSidA(szSID, &cbSID))
            {
                SetLastError((DWORD) NTE_BAD_KEYSET);
                goto Ret;
            }

            // this checks to see if the key to the current user may be opened
            // TODO - this should be cleaned up
            if (!fMachineKeySet)
            {
                if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_USERS,
                                                  szSID,
                                                  0,      // dwOptions
                                                  KEY_READ,
                                                  phTopRegKey))
                {
                    //
                    // if that failed, try HKEY_USERS\.Default (for services on NT).
                    //
                    cbSID = strlen(".DEFAULT") + 1;
                    strcpy(szSID, ".DEFAULT");
                    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_USERS,
                                                      szSID,
                                                      0,        // dwOptions
                                                      KEY_READ,
                                                      phTopRegKey))
                    {
                        goto Ret;
                    }
                    *pfLeaveOldKeys = TRUE;
                }
            }
        }
        else
        {
            *phTopRegKey = HKEY_CURRENT_USER;
        }
    }

    if (!fUserKeys)
        cbLocBuff = strlen(pszUserID);
    cbLocBuff = cbLocBuff + cbTmp + 2;

    if (NULL == (*ppszLocBuff = (CHAR*)ContInfoAlloc(cbLocBuff)))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Ret;
    }

    // Copy the location of the key groups, append the userID to it
    memcpy(*ppszLocBuff, pszTmp, cbTmp);
    if (!fUserKeys)
    {
        (*ppszLocBuff)[cbTmp-1] = '\\';
        strcpy(&(*ppszLocBuff)[cbTmp], pszUserID);
    }

    cbRet = cbLocBuff;
Ret:
    return (cbRet);
}

//
// Enumerates the old machine keys in the file system
// keys were in this location in Beta 2 and Beta 3 of NT5/Win2K
//
DWORD EnumOldMachineKeys(
                         IN DWORD dwProvType,
                         IN OUT PKEY_CONTAINER_INFO pContInfo
                         )
{
#ifndef _XBOX
    HANDLE              hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAW    FindData;
    LPWSTR              pwszUserStorageArea = NULL;
    LPWSTR              pwszTmp = NULL;
    BOOL                fIsLocalSystem;
    DWORD               i;
    LPSTR               pszNextContainer;
    DWORD               cbNextContainer;
    LPSTR               pszTmpContainer;
    DWORD               cb;
    DWORD               dwErr = 0;

    // first check if the enumeration table is already set up
    if (NULL != pContInfo->pchEnumOldMachKeyEntries)
    {
        goto Ret;
    }

    memset(&FindData, 0, sizeof(FindData));

    if (0 != (dwErr = GetUserStorageArea(dwProvType, TRUE, TRUE,
                                         &fIsLocalSystem, &pwszUserStorageArea)))
    {
        dwErr = ERROR_NO_MORE_ITEMS;
        goto Ret;
    }

    // last character is backslash, so strip that off
    if (NULL == (pwszTmp = (LPWSTR)ContInfoAlloc((wcslen(pwszUserStorageArea) + 3) * sizeof(WCHAR))))
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }
    wcscpy(pwszTmp, pwszUserStorageArea);
    wcscat(pwszTmp, L"*");

    // figure out how many files are in the directroy
    
    if (INVALID_HANDLE_VALUE == (hFind = FindFirstFileExW(pwszTmp,
                                                FindExInfoStandard,
                                                &FindData,
                                                FindExSearchNameMatch,
                                                NULL, 
                                                0)))
    {
        dwErr = ERROR_NO_MORE_ITEMS;
        goto Ret;
    }

    // skip past . and ..
    if (!FindNextFileW(hFind, &FindData))
    {
        dwErr = ERROR_NO_MORE_ITEMS;
        goto Ret;
    }
    if (!FindNextFileW(hFind, &FindData))
    {
        dwErr = ERROR_NO_MORE_ITEMS;
        goto Ret;
    }

    for (i = 1; ; i++)
    {
        memset(&FindData, 0, sizeof(FindData));
        if (!FindNextFileW(hFind, &FindData))
        {
            if (ERROR_ACCESS_DENIED != (dwErr = GetLastError()))
            {
                break;
            }
            dwErr = 0;
        }
    }

    FindClose(hFind);
    hFind = INVALID_HANDLE_VALUE;

    pContInfo->cbOldMachKeyEntry = MAX_PATH + 1;
    pContInfo->dwiOldMachKeyEntry = 0;
    pContInfo->cMaxOldMachKeyEntry = i;

    // allocate space for the file names
    if (NULL == (pContInfo->pchEnumOldMachKeyEntries =
        ContInfoAlloc(i * (MAX_PATH + 1))))
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    // enumerate through getting file name from each
    memset(&FindData, 0, sizeof(FindData));
    if (INVALID_HANDLE_VALUE == (hFind = FindFirstFileExW(pwszTmp,
                                                FindExInfoStandard,
                                                &FindData,
                                                FindExSearchNameMatch,
                                                NULL, 
                                                0)))
    {
        dwErr = ERROR_NO_MORE_ITEMS;
        goto Ret;
    }

    // skip past . and ..
    if (!FindNextFileW(hFind, &FindData))
    {
        dwErr = ERROR_NO_MORE_ITEMS;
        goto Ret;
    }
    memset(&FindData, 0, sizeof(FindData));
    if (!FindNextFileW(hFind, &FindData))
    {
        dwErr = ERROR_NO_MORE_ITEMS;
        goto Ret;
    }

    pszNextContainer = pContInfo->pchEnumOldMachKeyEntries;

    for (i = 0; i < pContInfo->cMaxOldMachKeyEntry; i++)
    {
        cbNextContainer = MAX_PATH;

        // return the container name, in order to do that we need to open the
        // file and pull out the container name
        if (0 != (dwErr = ReadContainerNameFromFile(TRUE,
                                                    FindData.cFileName,
                                                    pwszUserStorageArea,
                                                    pszNextContainer,
                                                    &cbNextContainer)))
        {
            pszTmpContainer = pszNextContainer;
        }
        else
        {
            pszTmpContainer = pszNextContainer + MAX_PATH + 1;
        }

        memset(&FindData, 0, sizeof(FindData));
        if (!FindNextFileW(hFind, &FindData))
        {
            if (ERROR_ACCESS_DENIED != (dwErr = GetLastError()))
            {
                if (ERROR_NO_MORE_FILES == dwErr)
                {
                    dwErr = 0;
                }
                break;
            }
            dwErr = 0;
        }
        pszNextContainer = pszTmpContainer;
    }

Ret:
    if (pwszTmp)
        ContInfoFree(pwszTmp);
    if (pwszUserStorageArea)
        ContInfoFree(pwszUserStorageArea);
    if (INVALID_HANDLE_VALUE != hFind)
        FindClose(hFind);

    return dwErr;
#else
    ASSERT( !"EnumOldMachineKeys" );
    return 0;
#endif
}

DWORD GetNextEnumedOldMachKeys(
                              IN PKEY_CONTAINER_INFO pContInfo,
                              IN BOOL fMachineKeyset,
                              IN DWORD dwProvType,
                              OUT BYTE *pbData,
                              OUT DWORD *pcbData
                              )
{
    CHAR    *psz;
    DWORD   dwErr = 0;

    if (!fMachineKeyset)
    {
        goto Ret;
    }

    if ((NULL == pContInfo->pchEnumOldMachKeyEntries) ||
        (pContInfo->dwiOldMachKeyEntry >= pContInfo->cMaxOldMachKeyEntry))
    {
        dwErr = ERROR_NO_MORE_ITEMS;
        goto Ret;
    }

    if (NULL == pbData)
    {
        goto Ret;
    }

    if (*pcbData < pContInfo->cbRegEntry)
    {
        dwErr = ERROR_MORE_DATA;
        goto Ret;
    }

    psz = pContInfo->pchEnumOldMachKeyEntries + (pContInfo->dwiOldMachKeyEntry *
          pContInfo->cbOldMachKeyEntry);
    memcpy(pbData, psz, strlen(psz) + 1);
    pContInfo->dwiOldMachKeyEntry++;
Ret:
    if (fMachineKeyset)
        *pcbData = pContInfo->cbOldMachKeyEntry;

    return dwErr;
}

//
// Enumerates the keys in the registry into a list of entries
//
DWORD EnumRegKeys(
                  IN OUT PKEY_CONTAINER_INFO pContInfo,
                  IN BOOL fMachineKeySet,
                  IN DWORD dwProvType,
                  OUT BYTE *pbData,
                  IN OUT DWORD *pcbData
                  )
{
#ifndef _XBOX
    HKEY        hTopRegKey = 0;
    LPSTR       pszBuff = NULL;
    DWORD       cbBuff;
    BOOL        fLeaveOldKeys = FALSE;
    HKEY        hKey = 0;
    DWORD       cSubKeys;
    DWORD       cchMaxSubkey;
    DWORD       cchMaxClass;
    DWORD       cValues;
    DWORD       cchMaxValueName;
    DWORD       cbMaxValueData;
    DWORD       cbSecurityDesriptor;
    FILETIME    ftLastWriteTime;
    CHAR        *psz;
    DWORD       i;
    DWORD       dwErr = 0;

    // first check if the enumeration table is already set up
    if (NULL != pContInfo->pchEnumRegEntries)
    {
        goto Ret;
    }

    // get the path to the registry keys
    if (0 == (cbBuff = AllocAndSetLocationBuff(fMachineKeySet,
                                               dwProvType,
                                               pContInfo->pszUserName,
                                               &hTopRegKey,
                                               &pszBuff,
                                               TRUE,
                                               &fLeaveOldKeys)))
    {
        dwErr = GetLastError();
        goto Ret;
    }

    // open the reg key
    if ((dwErr = MyRegOpenKeyEx(hTopRegKey,
                                pszBuff,
                                0,
                                KEY_READ,
                                &hKey)) != ERROR_SUCCESS)
    {
        dwErr = ERROR_NO_MORE_ITEMS;
        goto Ret;
    }

    // find out info on old key containers
    if ((dwErr = RegQueryInfoKey(hKey,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &cSubKeys,
                                   &cchMaxSubkey,
                                   &cchMaxClass,
                                   &cValues,
                                   &cchMaxValueName,
                                   &cbMaxValueData,
                                   &cbSecurityDesriptor,
                                   &ftLastWriteTime
                                   )) != ERROR_SUCCESS)
    {
        goto Ret;
    }

    // if there are old keys then enumerate them into a table
    if (0 != cSubKeys)
    {
        pContInfo->cMaxRegEntry = cSubKeys;
        pContInfo->cbRegEntry = cchMaxSubkey + 1;

        if (NULL == (pContInfo->pchEnumRegEntries =
            ContInfoAlloc(pContInfo->cMaxRegEntry * pContInfo->cbRegEntry *
                          sizeof(CHAR))))
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto Ret;
        }

        for (i = 0; i < pContInfo->cMaxRegEntry; i++)
        {
            psz = pContInfo->pchEnumRegEntries + (i * pContInfo->cbRegEntry);
            if ((dwErr = RegEnumKey(hKey,
                                      i,
                                      psz,
                                      pContInfo->cbRegEntry)) != ERROR_SUCCESS)
            {
                goto Ret;
            }
        }

        if ((pbData == NULL) || (*pcbData < pContInfo->cbRegEntry))
        {
            *pcbData = pContInfo->cbRegEntry;

            if (pbData == NULL)
            {
                goto Ret;
            }
            dwErr = ERROR_MORE_DATA;
            goto Ret;
        }
    }
Ret:
    if (hTopRegKey && (HKEY_CURRENT_USER != hTopRegKey) &&
        (HKEY_LOCAL_MACHINE != hTopRegKey))
    {
        RegCloseKey(hTopRegKey);
    }

    if (pszBuff)
        ContInfoFree(pszBuff);
    if (hKey)
        RegCloseKey(hKey);

    return dwErr;
#else
    ASSERT( !"EnumRegKeys" );
    return 0;
#endif
}

DWORD GetNextEnumedRegKeys(
                           IN PKEY_CONTAINER_INFO pContInfo,
                           IN BOOL fMachineKeySet,
                           IN DWORD dwProvType,
                           OUT BYTE *pbData,
                           OUT DWORD *pcbData
                           )
{
    CHAR    *psz;
    DWORD   dwErr = 0;

    if ((NULL == pContInfo->pchEnumRegEntries) ||
        (pContInfo->dwiRegEntry >= pContInfo->cMaxRegEntry))
    {
        dwErr = ERROR_NO_MORE_ITEMS;
        goto Ret;
    }

    if (NULL == pbData)
    {
        goto Ret;
    }

    if (*pcbData < pContInfo->cbRegEntry)
    {
        dwErr = ERROR_MORE_DATA;
        goto Ret;
    }

    psz = pContInfo->pchEnumRegEntries + (pContInfo->dwiRegEntry *
          pContInfo->cbRegEntry);
    memcpy(pbData, psz, pContInfo->cbRegEntry);
    pContInfo->dwiRegEntry++;
Ret:
    *pcbData = pContInfo->cbRegEntry;

    return dwErr;
}


//+ ===========================================================================
//
//      The function adjusts the token priviledges so that SACL information
//      may be gotten and then opens the indicated registry key.  If the token
//      priviledges may be set then the reg key is opened anyway but the
//      flags field will not have the PRIVILEDGE_FOR_SACL value set.
//
//- ============================================================================
BOOL OpenRegKeyWithTokenPriviledges(
                                    IN HKEY hTopRegKey,
                                    IN LPSTR pszRegKey,
                                    OUT HKEY *phRegKey,
                                    OUT DWORD *pdwFlags
                                    )
{
#ifndef _XBOX
    TOKEN_PRIVILEGES    tp;
    TOKEN_PRIVILEGES    tpPrevious;
    DWORD               cbPrevious = sizeof(TOKEN_PRIVILEGES);
    LUID                luid;
    HANDLE              hToken = 0;
    HKEY                hRegKey = 0;
    BOOL                fStatus;
    BOOL                fImpersonating = FALSE;
    BOOL                fAdjusted = FALSE;
    DWORD               dwAccessFlags = 0;
    BOOL                fRet = FALSE;

    // check if there is a registry key to open
    if (ERROR_SUCCESS != MyRegOpenKeyEx(hTopRegKey, pszRegKey, 0,
                                        KEY_ALL_ACCESS, &hRegKey))
    {
        goto Ret;
    }
    RegCloseKey(hRegKey);
    hRegKey = 0;

    // check if there is a thread token
    if (FALSE == (fStatus = OpenThreadToken(GetCurrentThread(),
                                 MAXIMUM_ALLOWED, TRUE,
                                 &hToken)))
    {
        if (!ImpersonateSelf(SecurityImpersonation))
        {
            goto Ret;
        }
        fImpersonating = TRUE;
        // get the process token
        fStatus = OpenThreadToken(GetCurrentThread(),
                                  MAXIMUM_ALLOWED,
                                  TRUE,
                                  &hToken);
    }

    // set up the new priviledge state
    if (fStatus)
    {
        memset(&tp, 0, sizeof(tp));
        memset(&tpPrevious, 0, sizeof(tpPrevious));

        fStatus = LookupPrivilegeValueA(NULL,
                                        SE_SECURITY_NAME,
                                        &luid);
        if (fStatus)
        {
            //
            // first pass.  get current privilege setting
            //
            tp.PrivilegeCount           = 1;
            tp.Privileges[0].Luid       = luid;
            tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            // adjust privilege
            fStatus = AdjustTokenPrivileges(hToken,
                                  FALSE,
                                  &tp,
                                  sizeof(TOKEN_PRIVILEGES),
                                  &tpPrevious,
                                  &cbPrevious);

            if (fStatus && (ERROR_SUCCESS == GetLastError()))
            {
                fAdjusted = TRUE;
                *pdwFlags |= PRIVILEDGE_FOR_SACL;
                dwAccessFlags = ACCESS_SYSTEM_SECURITY;
            }
        }
    }

    // open the registry key
    if (ERROR_SUCCESS != MyRegOpenKeyEx(hTopRegKey,
                                        pszRegKey,
                                        0,
                                        KEY_ALL_ACCESS | dwAccessFlags,
                                        phRegKey))
    {
        goto Ret;
    }


    fRet = TRUE;
Ret:
    // now set the privilege back if necessary
    if (fAdjusted)
    {
        // adjust the priviledge and with the previous state
        fStatus = AdjustTokenPrivileges(hToken,
                                        FALSE,
                                        &tpPrevious,
                                        sizeof(TOKEN_PRIVILEGES),
                                        NULL,
                                        NULL);
    }

    if (hToken)
        CloseHandle(hToken);
    if (fImpersonating)
        RevertToSelf();
#endif
    ASSERT( !"OpenRegKeyWithTokenPriviledges" );
    return TRUE;
}

#define FRENCHCHECKKEY  "Software\\Microsoft\\Cryptography\\Defaults\\CheckInfo"
#define FRENCHCHECKVALUE  "Mask"

#define DH_PROV_ENABLED     1
#define RSA_PROV_ENABLED    2
#define DH_SCH_ENABLED      4
#define RSA_SCH_ENABLED     8

BOOL IsEncryptionPermitted(
                           IN DWORD dwProvType,
                           OUT BOOL *pfInFrance
                           )
/*++

Routine Description:

    This routine checks whether encryption is getting the system default
    LCID and checking whether the country code is CTRY_FRANCE.

Arguments:

    none


Return Value:

    TRUE - encryption is permitted
    FALSE - encryption is not permitted


--*/

{
#ifndef NO_FRANCE_CHECK
    LCID    DefaultLcid;
    CHAR    CountryCode[10];
    ULONG   CountryValue;
    HKEY    hKey = 0;
    DWORD   cb = sizeof(DWORD);
    DWORD   dw = 0;
    DWORD   dwType;
    BOOL    fRet = FALSE;

    *pfInFrance = FALSE;

    DefaultLcid = GetSystemDefaultLCID();

    //
    // Check if the default language is Standard French
    // or if the users's country is set to FRANCE
    //

    if (GetLocaleInfoA(DefaultLcid,LOCALE_ICOUNTRY,CountryCode,10) == 0)
    {
        goto Ret;
    }
    CountryValue = (ULONG) atol(CountryCode);
    if ((CountryValue == CTRY_FRANCE) || (LANGIDFROMLCID(DefaultLcid) == 0x40c))
    {
        // this is a check to see if a registry key to enable encryption is
        // available, do not remove, use or publicize this check without
        // thorough discussions with Microsoft Legal handling French Import
        // issues (tomalb and/or irar)
	    if (ERROR_SUCCESS != RegOpenKeyExA(HKEY_LOCAL_MACHINE,
		                                  FRENCHCHECKKEY,
		                                  0,		// dwOptions
		                                  KEY_READ,
		                                  &hKey))
        {
            hKey = 0;
            goto Ret;
        }

        // get the mask value from the registry indicating which crypto
        // services are to be allowed
	    if (ERROR_SUCCESS != RegQueryValueExA(hKey,
		                                  FRENCHCHECKVALUE,
		                                  NULL, &dwType,		// dwOptions
		                                  (BYTE*)&dw,
		                                  &cb))
        {
            goto Ret;
        }

        switch(dwProvType)
        {
            case PROV_RSA_FULL:
            case PROV_RSA_SIG:
            {
                if (dw & RSA_PROV_ENABLED)
                {
                    fRet = TRUE;
                }
                break;
            }

            case PROV_RSA_SCHANNEL:
            {
                if (dw & RSA_SCH_ENABLED)
                {
                    fRet = TRUE;
                }
                break;
            }

            case PROV_DSS:
            case PROV_DSS_DH:
            {
                if (dw & DH_PROV_ENABLED)
                {
                    fRet = TRUE;
                }
                break;
            }

            case PROV_DH_SCHANNEL:
            {
                if (dw & DH_SCH_ENABLED)
                {
                    fRet = TRUE;
                }
                break;
            }

            default:
                goto Ret;
        }
    }
    else
    {
        fRet = TRUE;
    }
Ret:
    if (hKey)
        RegCloseKey(hKey);
    return fRet;
#else
    *pfInFrance = FALSE;
    return TRUE;
#endif
}

//
// Function : FreeOffloadInfo
//
// Description : The function takes a pointer to Offload Information as the
//               first parameter of the call.  The function frees the
//               information.
//
void FreeOffloadInfo(
                     IN OUT PEXPO_OFFLOAD_STRUCT pOffloadInfo
                     )
{
    if (pOffloadInfo)
    {
#ifndef _XBOX
        if (pOffloadInfo->hInst)
            FreeLibrary(pOffloadInfo->hInst);
        ContInfoFree(pOffloadInfo);
#endif
    }
}

//
// Function : InitExpOffloadInfo
//
// Description : The function takes a pointer to Offload Information as the
//               first parameter of the call.  The function checks in the
//               registry to see if an offload module has been registered. 
//               If a module is registered then it loads the module
//               and gets the OffloadModExpo function pointer.
//
BOOL InitExpOffloadInfo(
                        IN OUT PEXPO_OFFLOAD_STRUCT *ppOffloadInfo
                        )
{
    *ppOffloadInfo = NULL;

    return TRUE;
}

//
// Function : ModularExpOffload
//
// Description : This function does the offloading of modular exponentiation.
//               The function takes a pointer to Offload Information as the
//               first parameter of the call.  If this pointer is not NULL
//               then the function will use this module and call the function.
//               The exponentiation with MOD function will implement
//               Y^X MOD P  where Y is the buffer pbBase, X is the buffer
//               pbExpo and P is the buffer pbModulus.  The length of the
//               buffer pbExpo is cbExpo and the length of pbBase and
//               pbModulus is cbModulus.  The resulting value is output
//               in the pbResult buffer and has length cbModulus.
//               The pReserved and dwFlags parameters are currently ignored.
//               If any of these functions fail then the function fails and
//               returns FALSE.  If successful then the function returns
//               TRUE.  If the function fails then most likely the caller
//               should fall back to using hard linked modular exponentiation.
//
BOOL ModularExpOffload(
                       IN PEXPO_OFFLOAD_STRUCT pOffloadInfo,
                       IN BYTE *pbBase,  
                       IN BYTE *pbExpo,
                       IN DWORD cbExpo,
                       IN BYTE *pbModulus,
                       IN DWORD cbModulus,
                       OUT BYTE *pbResult,
                       IN VOID *pReserved,
                       IN DWORD dwFlags
                       )
{
    DWORD   dwErr = 0;
    BOOL    fRet = FALSE;

    // wrap with try/except
    try
    {
        if (NULL == pOffloadInfo)
        {
            goto Ret;
        }

        // call the offload module
        if (!pOffloadInfo->pExpoFunc(pbBase, pbExpo, cbExpo, pbModulus,
                                     cbModulus, pbResult, pReserved, dwFlags))
        {
            goto Ret;
        }

        fRet = TRUE;
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        goto Ret;
    }
Ret:
    return fRet;
}

// 
// The following section of code is for the loading and unloading of
// unicode string resources from a resource DLL (csprc.dll).  This
// allows the resources to be localize even though the CSPs
// themselves are signed.
//

#define MAX_STRING_RSC_SIZE 512


#define GLOBAL_STRING_BUFFERSIZE 2000

BOOL LoadStrings()
{
    return TRUE;
}

void UnloadStrings()
{
    if(g_pbStringBlock)
    {
        ContInfoFree(g_pbStringBlock);
        g_pbStringBlock = NULL;
        memset(&g_Strings, 0, sizeof(g_Strings));
    }
}

#ifdef USE_HW_RNG
#ifdef _M_IX86

// stuff for INTEL RNG usage


// 
// Function : GetRNGDriverHandle
//
// Description : Gets the handle to the INTEL RNG driver if available, then
//               checks if the chipset supports the hardware RNG.  If so
//               the previous driver handle is closed if necessary and the
//               new handle is assigned to the passed in parameter.
//
BOOL GetRNGDriverHandle(
                        IN OUT HANDLE *phDriver
                        )
{
  	ISD_Capability  ISD_Cap;                //in/out for GetCapability
    DWORD           dwBytesReturned;
    char            szDeviceName[80] = "";  //Name of device
	HANDLE			hDriver = INVALID_HANDLE_VALUE; //Driver handle
    BOOLEAN         fReturnCode;            //Return code from IOCTL call
    BOOL            fRet = TRUE;

    memset(&ISD_Cap, 0, sizeof(ISD_Cap));

	wsprintf(szDeviceName,"\\\\.\\"DRIVER_NAME);
    if (INVALID_HANDLE_VALUE == (hDriver = 
        CreateFileA(szDeviceName, FILE_SHARE_READ | FILE_SHARE_WRITE 
                   | GENERIC_READ | GENERIC_WRITE, 0, NULL,
	               OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)))
    {
        SetLastError((DWORD) NTE_FAIL);
        goto Ret;
    }

    //Get RNG Enabled
    ISD_Cap.uiIndex = ISD_RNG_ENABLED;  //Set input member
    fReturnCode = DeviceIoControl(hDriver,
	            				  IOCTL_ISD_GetCapability,
				        		  &ISD_Cap, sizeof(ISD_Cap),
						          &ISD_Cap, sizeof(ISD_Cap),
						          &dwBytesReturned,
						          NULL);
	if(fReturnCode == FALSE || ISD_Cap.iStatus != ISD_EOK)  
    {
        SetLastError((DWORD) NTE_FAIL);
        goto Ret;
    }

    // close the previous handle if already there
    if (INVALID_HANDLE_VALUE != *phDriver)
    {
        CloseHandle(*phDriver);
    }

    *phDriver = hDriver;

    fRet = TRUE;
Ret:
    if ((FALSE == fRet) && (INVALID_HANDLE_VALUE != hDriver))
    {
        CloseHandle(hDriver);
    }

    return fRet;
}

// 
// Function : CheckIfRNGAvailable
//
// Description : Checks if the INTEL RNG driver is available, if so then
//               checks if the chipset supports the hardware RNG.
//
BOOL CheckIfRNGAvailable()
{
	HANDLE			hDriver = INVALID_HANDLE_VALUE; //Driver handle
    BOOL            fRet = TRUE;

    fRet = GetRNGDriverHandle(&hDriver);

    if (INVALID_HANDLE_VALUE != hDriver)
        CloseHandle(hDriver);

    return fRet;
}

// 
// Function : HWRNGGenRandom
//
// Description : Uses the passed in handle to the INTEL RNG driver
//               to fill the buffer with random bits.  Actually uses
//               XOR to fill the buffer so that the passed in buffer
//               is also mixed in.
//
unsigned int
HWRNGGenRandom(
               IN HANDLE hRNGDriver,
               IN OUT BYTE *pbBuffer,
               IN DWORD dwLen
               )
{
	ISD_RandomNumber    ISD_Random;             //in/out for GetRandomNumber
    DWORD               dwBytesReturned = 0;
    DWORD               i;
    DWORD               *pdw;
    BYTE                *pb;
    BYTE                *pbRand;
    BOOLEAN             fReturnCode;            //Return code from IOCTL call
    unsigned int        iRet = FALSE;

    memset(&ISD_Random, 0, sizeof(ISD_Random));

    for (i = 0; i < (dwLen / sizeof(DWORD)); i++)
    {
        pdw = (DWORD*)(pbBuffer + i * sizeof(DWORD));

        //No input needed in the ISD_Random structure for this operation,
        //so just send it in as is.
        fReturnCode = DeviceIoControl(hRNGDriver,
					                  IOCTL_ISD_GetRandomNumber,
					                  &ISD_Random, sizeof(ISD_Random),
					                  &ISD_Random, sizeof(ISD_Random),
					                  &dwBytesReturned,
					                  NULL);
        if (fReturnCode == 0 || ISD_Random.iStatus != ISD_EOK)  
        {
            //Error - ignore the data returned
            SetLastError((DWORD) NTE_FAIL);
            goto Ret;
        }

        *pdw = *pdw ^ ISD_Random.uiRandomNum;
    }

    pb = pbBuffer + i * sizeof(DWORD);
    fReturnCode = DeviceIoControl(hRNGDriver,
					              IOCTL_ISD_GetRandomNumber,
					              &ISD_Random, sizeof(ISD_Random),
					              &ISD_Random, sizeof(ISD_Random),
					              &dwBytesReturned,
					              NULL);
    if (fReturnCode == 0 || ISD_Random.iStatus != ISD_EOK)  
    {
        //Error - ignore the data returned
        SetLastError((DWORD) NTE_FAIL);
        goto Ret;
    }
    pbRand = (BYTE*)&ISD_Random.uiRandomNum;

    for (i = 0; i < (dwLen % sizeof(DWORD)); i++)
    {
        pb[i] = pb[i] ^ pbRand[i];
    }

    iRet = TRUE;
Ret:
    return iRet;
}

#ifdef TEST_HW_RNG
// 
// Function : SetupHWRNGIfRegistered
//
// Description : Checks if there is a registry setting indicating the HW RNG
//               is to be used.  If the registry entry is there then it attempts
//               to get the HW RNG driver handle.
//
BOOL SetupHWRNGIfRegistered(
                            OUT HANDLE *phRNGDriver
                            )
{
    HKEY    hRegKey = 0;
    BOOL    fRet = FALSE;

    // first check the registry entry to see if supposed to use HW RNG
	if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                      "Software\\Microsoft\\Cryptography\\UseHWRNG",
		                              0,		// dwOptions
		                              KEY_READ,
		                              &hRegKey))
    {
        // get the driver handle
        if (!GetRNGDriverHandle(phRNGDriver))
        {
            goto Ret;
        }
    }

    fRet = TRUE;
Ret:
    if (hRegKey)
    {
        RegCloseKey(hRegKey);
    }

    return fRet;
}
#endif // TEST_HW_RNG

#endif // _M_IX86
#endif // USE_HW_RNG

// SIG in file
#define SIG_RESOURCE_NAME   "#666"
// MAC in file
#define MAC_RESOURCE_NAME   "#667"

// The function MACs the given bytes.
void MACBytes(
              IN DESTable *pDESKeyTable,
              IN BYTE *pbData,
              IN DWORD cbData,
              IN OUT BYTE *pbTmp,
              IN OUT DWORD *pcbTmp,
              IN OUT BYTE *pbMAC,
              IN BOOL fFinal
              )
{
    DWORD   cb = cbData;
    DWORD   cbMACed = 0;

    while (cb)
    {
        if ((cb + *pcbTmp) < DES_BLOCKLEN)
        {
            memcpy(pbTmp + *pcbTmp, pbData + cbMACed, cb);
            *pcbTmp += cb;
            break;
        }
        else
        {
            memcpy(pbTmp + *pcbTmp, pbData + cbMACed, DES_BLOCKLEN - *pcbTmp);
            CBC(des, DES_BLOCKLEN, pbMAC, pbTmp, pDESKeyTable,
                ENCRYPT, pbMAC);
            cbMACed = cbMACed + (DES_BLOCKLEN - *pcbTmp);
            cb = cb - (DES_BLOCKLEN - *pcbTmp);
            *pcbTmp = 0;
        }
    }
}

#define CSP_TO_BE_MACED_CHUNK  4096

// Given hFile, reads the specified number of bytes (cbToBeMACed) from the file
// and MACs these bytes.  The function does this in chunks.
BOOL MACBytesOfFile(
                     IN HANDLE hFile,
                     IN DWORD cbToBeMACed,
                     IN DESTable *pDESKeyTable,
                     IN BYTE *pbTmp,
                     IN DWORD *pcbTmp,
                     IN BYTE *pbMAC,
                     IN BYTE fFinal
                     )
{
    BYTE    rgbChunk[CSP_TO_BE_MACED_CHUNK];
    DWORD   cbRemaining = cbToBeMACed;
    DWORD   cbToRead;
    DWORD   dwBytesRead;
    BOOL    fRet = FALSE;

    //
    // loop over the file for the specified number of bytes
    // updating the hash as we go.
    //

    while (cbRemaining > 0)
    {
        if (cbRemaining < CSP_TO_BE_MACED_CHUNK)
            cbToRead = cbRemaining;
        else
            cbToRead = CSP_TO_BE_MACED_CHUNK;

        if(!ReadFile(hFile, rgbChunk, cbToRead, &dwBytesRead, NULL))
            goto Ret;
        if (dwBytesRead != cbToRead)
            goto Ret;

        MACBytes(pDESKeyTable, rgbChunk, dwBytesRead, pbTmp, pcbTmp,
                 pbMAC, fFinal);
        cbRemaining -= cbToRead;
    }

    fRet = TRUE;
Ret:
    return fRet;
}

BYTE rgbMACDESKey[] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef};


#if DBG         // NOTE:  This section not compiled for retail builds

#define MAX_DEBUG_BUFFER 2048

BOOL CSPCheckIfShouldDisplayOutput()
{
    return TRUE;
}

// 
void CSPDebugOutput(
                    IN char *szOutString
                    )
{
/*
    DWORD dwWritten;

    if (NULL != g_hfLogFile)
    {
        WriteFile(
            g_hfLogFile,
            szOutString,
            lstrlen(szOutString),
            &dwWritten,
            NULL);
    }
*/
    //XDBGTRC("rsabase",szOutString);
    //OutputDebugStringA(szOutString);
}

void CSPDumpString(
                   LPSTR psz
                   )
{
    DWORD   i;
    CHAR    pszLine[MAX_PATH];

    memset(pszLine, 0, sizeof(pszLine));

    if (psz == NULL)
    {
        wsprintf(pszLine, "<null> buffer!!!\n");
        CSPDebugOutput(pszLine);
        goto Ret;
    }

    CSPDebugOutput(psz);
    CSPDebugOutput("\n");
Ret:
    return;
}

void CSPDumpAddress(
                    IN BYTE *pb,
                    IN OUT LPSTR psz
                    )
{
    CHAR        pszDigits[]="0123456789abcdef";
    DWORD       cch = 0;
    DWORD_PTR   pAddress = (DWORD_PTR)pb;

#if defined(_WIN64)

    psz[cch++] = pszDigits[(pAddress >> 0x3c) & 0x0f];
    psz[cch++] = pszDigits[(pAddress >> 0x38) & 0x0f];
    psz[cch++] = pszDigits[(pAddress >> 0x34) & 0x0f];
    psz[cch++] = pszDigits[(pAddress >> 0x30) & 0x0f];
    psz[cch++] = pszDigits[(pAddress >> 0x2c) & 0x0f];
    psz[cch++] = pszDigits[(pAddress >> 0x28) & 0x0f];
    psz[cch++] = pszDigits[(pAddress >> 0x24) & 0x0f];
    psz[cch++] = pszDigits[(pAddress >> 0x20) & 0x0f];

#endif

    psz[cch++] = pszDigits[(pAddress >> 0x1c) & 0x0f];
    psz[cch++] = pszDigits[(pAddress >> 0x18) & 0x0f];
    psz[cch++] = pszDigits[(pAddress >> 0x14) & 0x0f];
    psz[cch++] = pszDigits[(pAddress >> 0x10) & 0x0f];
    psz[cch++] = pszDigits[(pAddress >> 0x0c) & 0x0f];
    psz[cch++] = pszDigits[(pAddress >> 0x08) & 0x0f];
    psz[cch++] = pszDigits[(pAddress >> 0x04) & 0x0f];
    psz[cch++] = pszDigits[(pAddress) & 0x0f];

    psz[cch++] = ' ';
    psz[cch++] = 0x00;
}

void CSPDumpHexString(
                      IN BYTE *pb,
                      IN DWORD cb
                      )
{
    DWORD   i;
    CHAR    pszLine[MAX_PATH];
    CHAR    pszTmp[MAX_PATH];

    memset(pszLine, 0, sizeof(pszLine));

    if(cb == 0)
    {
        wsprintf(pszLine, "zero length buffer.\n");
        CSPDebugOutput(pszLine);
        goto Ret;
    }

    if((pb == NULL) && (cb != 0))
    {
        wsprintf(pszLine, "<null> buffer but length is %d!!!\n", cb);
        CSPDebugOutput(pszLine);
        goto Ret;
    }

    // cycle through the buffer displaying the data
    for(i = 0; i < cb; i++)
    {
        wsprintf(pszTmp, "0x%02X, ", pb[i]);
        strcat(pszLine, pszTmp);


        if ((0 == ((i + 1) % 8)) || ((i + 1) == cb))
        {
            strcat(pszLine, "\n");
            CSPDebugOutput(pszLine);
            if ((i + 1) != cb)
            {
                memset(pszLine, 0, sizeof(pszLine));
                CSPDebugOutput("    ");
            }
        }
    }
Ret:
    return;
}

void OutputDebugHeader(
                       IN LPSTR pszFunc
                       )
{
    SYSTEMTIME  stTime;
    DWORD       Level = 0;
    ULONG       ClientProcess;
    ULONG       ClientThread;
    char        szOutString[MAX_DEBUG_BUFFER];
    DWORD       cbOut;

    // Output the function being called
    cbOut = wsprintf(szOutString, "Header#: %d  ", g_dwDebugCount);
    CSPDebugOutput(szOutString);
    CSPDebugOutput(pszFunc);

    GetLocalTime(&stTime);

    cbOut = wsprintf(szOutString,
                     "[%2d/%2d %02d:%02d:%02d.%03d] %d.%d\n",
                     stTime.wMonth, stTime.wDay,
                     stTime.wHour, stTime.wMinute, stTime.wSecond, 
                     stTime.wMilliseconds,
                     1,
                     GetCurrentThreadId());

    CSPDebugOutput(szOutString);
}

void CSPDebugOutputFuncReturn(
                              IN BOOL fReturn
                              )
{
    CHAR    pszTmp[MAX_PATH];
    CHAR    pszTmp2[MAX_PATH];
    DWORD   cbOut;

    cbOut = wsprintf(pszTmp, "Header#: %d  ", g_dwDebugCount);
    CSPDebugOutput(pszTmp);

    memset(pszTmp, 0, sizeof(pszTmp));
    strcat(pszTmp, "Return Value - ");
    if (fReturn)
    {
        strcat(pszTmp, "SUCCEEDED\n");
    }
    else
    {
        wsprintf(pszTmp2, "FAILED with Last Error 0x%08X\n", GetLastError());
        strcat(pszTmp, pszTmp2);
    }
    CSPDebugOutput(pszTmp);

}

void CSPDebugOutputAcqCtxt(
                           IN BOOL fEnter,
                           IN BOOL fReturn,
                           IN HCRYPTPROV *phProv,
                           IN CHAR *pUserID,
                           IN DWORD dwFlags,
                           IN PVTableProvStruc pVTable
                           )
{
    if (CSPCheckIfShouldDisplayOutput())
    {
        if (fEnter)
        {
            OutputDebugHeader("AcquireContext ");
            // dump container name
            CSPDebugOutput("Container Name :\n    ");
            CSPDumpString(pUserID);
            // dump flags
            CSPDebugOutput("Flags          :\n    ");
            CSPDumpHexString((BYTE*)&dwFlags, sizeof(DWORD));
            // dump provider struct
            CSPDebugOutput("Prov Struct    :\n    ");
            CSPDumpHexString((BYTE*)pVTable, sizeof(VTableProvStruc));
            g_dwDebugCount++;
        }
        else
        {
            // dump hProv
            CSPDebugOutput("HCRYPTPROV*    :\n    ");
            CSPDumpHexString((BYTE*)phProv, sizeof(HCRYPTPROV));
            g_dwDebugCount--;
            CSPDebugOutputFuncReturn(fReturn);
        }
    }
}

void CSPDebugOutputReleaseCtxt(
                               IN BOOL fEnter,
                               IN BOOL fReturn,
                               IN HCRYPTPROV hProv,
                               IN DWORD dwFlags
                               )
{
    if (CSPCheckIfShouldDisplayOutput())
    {
        if (fEnter)
        {
            OutputDebugHeader("ReleaseContext ");
            // dump hProv
            CSPDebugOutput("HCRYPTPROV     :\n    ");
            CSPDumpHexString((BYTE*)&hProv, sizeof(HCRYPTPROV));
            // dump flags
            CSPDebugOutput("Flags          :\n    ");
            CSPDumpHexString((BYTE*)&dwFlags, sizeof(DWORD));
            g_dwDebugCount++;
        }
        else
        {
            g_dwDebugCount--;
            CSPDebugOutputFuncReturn(fReturn);
        }
    }
}

void CSPDebugOutputSetProvParam(
                                IN BOOL fEnter,
                                IN BOOL fReturn,
                                IN HCRYPTPROV hProv,
                                IN DWORD dwParam,
                                IN BYTE *pbData,
                                IN DWORD dwFlags
                                )
{
    if (CSPCheckIfShouldDisplayOutput())
    {
        if (fEnter)
        {
            OutputDebugHeader("SetProvParam ");
            // dump hProv
            CSPDebugOutput("HCRYPTPROV     :\n    ");
            CSPDumpHexString((BYTE*)&hProv, sizeof(HCRYPTPROV));
            // dump dwParam
            CSPDebugOutput("dwParam        :\n    ");
            CSPDumpHexString((BYTE*)&dwParam, sizeof(dwParam));
            // dump data pointer - don't have a length so can't do much
            CSPDebugOutput("pbData         : No length so no data display\n    ");
            // dump flags
            CSPDebugOutput("Flags          :\n    ");
            CSPDumpHexString((BYTE*)&dwFlags, sizeof(DWORD));
            g_dwDebugCount++;
        }
        else
        {
            g_dwDebugCount--;
            CSPDebugOutputFuncReturn(fReturn);
        }
    }
}

void CSPDebugOutputGetProvParam(
                                IN BOOL fEnter,
                                IN BOOL fReturn,
                                IN HCRYPTPROV hProv,
                                IN DWORD dwParam,
                                IN BYTE *pbData,
                                IN DWORD *pdwDataLen,
                                IN DWORD dwFlags
                                )
{
    if (CSPCheckIfShouldDisplayOutput())
    {
        if (fEnter)
        {
            OutputDebugHeader("GetProvParam ");
            // dump hProv
            CSPDebugOutput("HCRYPTPROV     :\n    ");
            CSPDumpHexString((BYTE*)&hProv, sizeof(HCRYPTPROV));
            // dump dwParam
            CSPDebugOutput("dwParam        :\n    ");
            CSPDumpHexString((BYTE*)&dwParam, sizeof(dwParam));
            // dump data pointer - output buffer so no dump
            CSPDebugOutput("pbData         : Output buffer\n    ");
            // dump pdwDataLen
            CSPDebugOutput("pdwDataLen     :\n    ");
            CSPDumpHexString((BYTE*)pdwDataLen, sizeof(DWORD));
            // dump flags
            CSPDebugOutput("Flags          :\n    ");
            CSPDumpHexString((BYTE*)&dwFlags, sizeof(DWORD));
            g_dwDebugCount++;
        }
        else
        {
            g_dwDebugCount--;
            CSPDebugOutputFuncReturn(fReturn);
        }
    }
}

void CSPDebugOutputDeriveKey(
                             IN BOOL fEnter,
                             IN BOOL fReturn,
                             IN HCRYPTPROV hProv,
                             IN ALG_ID Algid,
                             IN HCRYPTHASH hHash,
                             IN DWORD dwFlags,
                             IN HCRYPTKEY *phKey
                             )
{
    if (CSPCheckIfShouldDisplayOutput())
    {
        if (fEnter)
        {
            OutputDebugHeader("DeriveKey ");
            // dump hProv
            CSPDebugOutput("HCRYPTPROV     :\n    ");
            CSPDumpHexString((BYTE*)&hProv, sizeof(HCRYPTPROV));
            // dump Algid
            CSPDebugOutput("Algid          :\n    ");
            CSPDumpHexString((BYTE*)&Algid, sizeof(Algid));
            // dump hHash
            CSPDebugOutput("hHash          :\n    ");
            if (hHash)
            {
                CSPDumpHexString((BYTE*)&hHash, sizeof(HCRYPTPROV));
            }
            else
            {
                CSPDebugOutput("Zero Handle!!    ");
            }
            // dump flags
            CSPDebugOutput("Flags          :\n    ");
            CSPDumpHexString((BYTE*)&dwFlags, sizeof(DWORD));
            // dump phKey
            CSPDebugOutput("HCRYPTKEY *    :\n    ");
            g_dwDebugCount++;
        }
        else
        {
            CSPDumpHexString((BYTE*)phKey, sizeof(HCRYPTKEY));
            g_dwDebugCount--;
            CSPDebugOutputFuncReturn(fReturn);
        }
    }
}

void CSPDebugOutputDestroyKey(
                              IN BOOL fEnter,
                              IN BOOL fReturn,
                              IN HCRYPTKEY hProv,
                              IN HCRYPTKEY hKey
                              )
{
    if (CSPCheckIfShouldDisplayOutput())
    {
        if (fEnter)
        {
            OutputDebugHeader("DestroyKey ");
            // dump hProv
            CSPDebugOutput("HCRYPTPROV     :\n    ");
            CSPDumpHexString((BYTE*)&hProv, sizeof(HCRYPTPROV));
            // dump hKey
            CSPDebugOutput("HCRYPTKEY      :\n    ");
            CSPDumpHexString((BYTE*)&hKey, sizeof(HCRYPTKEY));
            g_dwDebugCount++;
        }
        else
        {
            g_dwDebugCount--;
            CSPDebugOutputFuncReturn(fReturn);
        }
    }
}

void CSPDebugOutputGenKey(
                          IN BOOL fEnter,
                          IN BOOL fReturn,
                          IN HCRYPTKEY hProv,
                          IN ALG_ID Algid,
                          IN DWORD dwFlags,
                          IN HCRYPTKEY *phKey
                          )
{
    if (CSPCheckIfShouldDisplayOutput())
    {
        if (fEnter)
        {
            OutputDebugHeader("GenKey ");
            // dump hProv
            CSPDebugOutput("HCRYPTPROV     :\n    ");
            CSPDumpHexString((BYTE*)&hProv, sizeof(HCRYPTPROV));
            // dump Algid
            CSPDebugOutput("Algid          :\n    ");
            CSPDumpHexString((BYTE*)&Algid, sizeof(Algid));
            // dump dwFlags
            CSPDebugOutput("dwFlags        :\n    ");
            CSPDumpHexString((BYTE*)&dwFlags, sizeof(DWORD));
            g_dwDebugCount++;
        }
        else
        {
            // dump phKey
            CSPDebugOutput("HCRYPTKEY*     :\n    ");
            CSPDumpHexString((BYTE*)phKey, sizeof(HCRYPTKEY));
            g_dwDebugCount--;
            CSPDebugOutputFuncReturn(fReturn);
        }
    }
}

void CSPDebugOutputGetKeyParam(
                               IN BOOL fEnter,
                               IN BOOL fReturn,
                               IN HCRYPTPROV hProv,
                               IN HCRYPTKEY hKey,
                               IN DWORD dwParam,
                               IN BYTE *pbData,
                               IN DWORD *pdwDataLen,
                               IN DWORD dwFlags
                               )
{
    if (CSPCheckIfShouldDisplayOutput())
    {
        if (fEnter)
        {
            OutputDebugHeader("GetKeyParam ");
            // dump hProv
            CSPDebugOutput("HCRYPTPROV     :\n    ");
            CSPDumpHexString((BYTE*)&hProv, sizeof(HCRYPTPROV));
            // dump hKey
            CSPDebugOutput("HCRYPTKEY      :\n    ");
            CSPDumpHexString((BYTE*)&hKey, sizeof(HCRYPTKEY));
            // dump dwParam
            CSPDebugOutput("dwParam        :\n    ");
            CSPDumpHexString((BYTE*)&dwParam, sizeof(dwParam));
            // dump data pointer - output buffer so no dump
            CSPDebugOutput("pbData         : Output buffer\n    ");
            // dump pdwDataLen
            CSPDebugOutput("pdwDataLen     :\n    ");
            CSPDumpHexString((BYTE*)pdwDataLen, sizeof(DWORD));
            // dump dwFlags
            CSPDebugOutput("dwFlags        :\n    ");
            CSPDumpHexString((BYTE*)&dwFlags, sizeof(DWORD));
            g_dwDebugCount++;
        }
        else
        {
            g_dwDebugCount--;
            CSPDebugOutputFuncReturn(fReturn);
        }
    }
}

void CSPDebugOutputGetUserKey(
                              IN BOOL fEnter,
                              IN BOOL fReturn,
                              IN HCRYPTPROV hProv,
                              IN DWORD dwKeySpec,
                              IN HCRYPTKEY *phKey
                              )
{
    if (CSPCheckIfShouldDisplayOutput())
    {
        if (fEnter)
        {
            OutputDebugHeader("GetUserKey ");
            // dump hProv
            CSPDebugOutput("HCRYPTPROV     :\n    ");
            CSPDumpHexString((BYTE*)&hProv, sizeof(HCRYPTPROV));
            // dump dwParam
            CSPDebugOutput("dwKeySpec      :\n    ");
            CSPDumpHexString((BYTE*)&dwKeySpec, sizeof(dwKeySpec));
            g_dwDebugCount++;
        }
        else
        {
            // dump hKey
            CSPDebugOutput("HCRYPTKEY*     :\n    ");
            CSPDumpHexString((BYTE*)phKey, sizeof(HCRYPTKEY));
            g_dwDebugCount--;
            CSPDebugOutputFuncReturn(fReturn);
        }
    }
}

void CSPDebugOutputSetKeyParam(
                               IN BOOL fEnter,
                               IN BOOL fReturn,
                               IN HCRYPTPROV hProv,
                               IN HCRYPTKEY hKey,
                               IN DWORD dwParam,
                               IN BYTE *pbData,
                               IN DWORD dwFlags
                               )
{
    if (CSPCheckIfShouldDisplayOutput())
    {
        if (fEnter)
        {
            OutputDebugHeader("SetKeyParam ");
            // dump hProv
            CSPDebugOutput("HCRYPTPROV     :\n    ");
            CSPDumpHexString((BYTE*)&hProv, sizeof(HCRYPTPROV));
            // dump hKey
            CSPDebugOutput("HCRYPTKEY      :\n    ");
            CSPDumpHexString((BYTE*)&hKey, sizeof(HCRYPTKEY));
            // dump dwParam
            CSPDebugOutput("dwParam        :\n    ");
            CSPDumpHexString((BYTE*)&dwParam, sizeof(dwParam));
            // dump data pointer - don't have a length so can't do much
            switch (dwParam)
            {
                case KP_IV:
                {
                    CSPDebugOutput("pbData         :\n    ");
                    CSPDumpHexString(pbData, 8);
                    break;
                }
                case KP_SCHANNEL_ALG:
                {
                    CSPDebugOutput("pbData         :\n    ");
                    CSPDumpHexString(pbData, sizeof(SCHANNEL_ALG));
                    break;
                }

                case KP_CLIENT_RANDOM:
                case KP_SERVER_RANDOM:
                case KP_CERTIFICATE:
                case KP_CLEAR_KEY:
                {
                    PCRYPT_DATA_BLOB    pDataBlob = (PCRYPT_DATA_BLOB)pbData;

                    CSPDebugOutput("pbData         :\n    ");
                    CSPDumpHexString(pDataBlob->pbData, pDataBlob->cbData);
                    break;
                }
                default:
                    CSPDebugOutput("pbData         : No length so no data display\n    ");
            }
            // dump dwFlags
            CSPDebugOutput("dwFlags        :\n    ");
            CSPDumpHexString((BYTE*)&dwFlags, sizeof(DWORD));
            g_dwDebugCount++;
        }
        else
        {
            g_dwDebugCount--;
            CSPDebugOutputFuncReturn(fReturn);
        }
    }
}

void CSPDebugOutputGenRandom(
                             IN BOOL fEnter,
                             IN BOOL fReturn,
                             IN HCRYPTPROV hProv,
                             IN DWORD dwLen,
                             IN BYTE *pbBuffer
                             )
{
    if (CSPCheckIfShouldDisplayOutput())
    {
        if (fEnter)
        {
            OutputDebugHeader("GenRandom ");
            // dump hProv
            CSPDebugOutput("HCRYPTPROV     :\n    ");
            CSPDumpHexString((BYTE*)&hProv, sizeof(HCRYPTPROV));
            // dump dwLen
            CSPDebugOutput("dwLen          :\n    ");
            CSPDumpHexString((BYTE*)&dwLen, sizeof(dwLen));
            // dump buffer
            CSPDebugOutput("pbBuffer       :\n    ");
            CSPDumpHexString(pbBuffer, dwLen);
            g_dwDebugCount++;
        }
        else
        {
            g_dwDebugCount--;
            CSPDebugOutputFuncReturn(fReturn);
        }
    }
}

void CSPDebugOutputExportKey(
                             IN BOOL fEnter,
                             IN BOOL fReturn,
                             IN HCRYPTPROV hProv,
                             IN HCRYPTKEY hKey,
                             IN HCRYPTKEY hExpKey,
                             IN DWORD dwBlobType,
                             IN DWORD dwFlags,
                             IN BYTE *pbData,
                             IN DWORD *pdwDataLen
                             )
{
    if (CSPCheckIfShouldDisplayOutput())
    {
        if (fEnter)
        {
            OutputDebugHeader("ExportKey ");
            // dump hProv
            CSPDebugOutput("HCRYPTPROV     :\n    ");
            CSPDumpHexString((BYTE*)&hProv, sizeof(HCRYPTPROV));
            // dump hKey
            CSPDebugOutput("HCRYPTKEY      :\n    ");
            CSPDumpHexString((BYTE*)&hKey, sizeof(HCRYPTKEY));
            // dump hExpKey
            CSPDebugOutput("HCRYPTKEY      :\n    ");
            CSPDumpHexString((BYTE*)&hExpKey, sizeof(HCRYPTKEY));
            // dump dwBlobType
            CSPDebugOutput("dwBlobType     :\n    ");
            CSPDumpHexString((BYTE*)&dwBlobType, sizeof(dwBlobType));
            // dump dwFlags
            CSPDebugOutput("dwFlags        :\n    ");
            CSPDumpHexString((BYTE*)&dwFlags, sizeof(dwFlags));
            g_dwDebugCount++;
        }
        else
        {
            if (pbData)
            {
                // dump pbData pointer
                CSPDebugOutput("pbData         : \n    ");
                CSPDumpHexString((BYTE*)pbData, *pdwDataLen);
                // dump pdwDataLen
                CSPDebugOutput("pdwDataLen     :\n    ");
                CSPDumpHexString((BYTE*)pdwDataLen, sizeof(DWORD));
            }
            else
            {
                // dump pbData pointer
                CSPDebugOutput("pbData         : NULL\n    ");
                // dump pdwDataLen
                CSPDebugOutput("pdwDataLen     :\n    ");
                CSPDumpHexString((BYTE*)pdwDataLen, sizeof(DWORD));
            }
            g_dwDebugCount--;
            CSPDebugOutputFuncReturn(fReturn);
        }
    }
}

void CSPDebugOutputImportKey(
                             IN BOOL fEnter,
                             IN BOOL fReturn,
                             IN HCRYPTPROV hProv,
                             IN BYTE *pbData,
                             IN DWORD dwDataLen,
                             IN HCRYPTKEY hImpKey,
                             IN DWORD dwFlags,
                             IN HCRYPTKEY *phKey
                             )
{
    if (CSPCheckIfShouldDisplayOutput())
    {
        if (fEnter)
        {
            OutputDebugHeader("ImportKey ");
            // dump hProv
            CSPDebugOutput("HCRYPTPROV     :\n    ");
            CSPDumpHexString((BYTE*)&hProv, sizeof(HCRYPTPROV));
            // dump pbData pointer
            CSPDebugOutput("pbData         :\n    ");
            CSPDumpHexString(pbData, dwDataLen);
            // dump dwDataLen
            CSPDebugOutput("dwDataLen      :\n    ");
            CSPDumpHexString((BYTE*)&dwDataLen, sizeof(DWORD));
            // dump hImpKey
            CSPDebugOutput("HCRYPTKEY      :\n    ");
            CSPDumpHexString((BYTE*)&hImpKey, sizeof(HCRYPTKEY));
            // dump dwFlags
            CSPDebugOutput("dwFlags        :\n    ");
            CSPDumpHexString((BYTE*)&dwFlags, sizeof(dwFlags));
            g_dwDebugCount++;
        }
        else
        {
            // dump phKey
            CSPDebugOutput("HCRYPTKEY*     :\n    ");
            CSPDumpHexString((BYTE*)phKey, sizeof(HCRYPTKEY));
            g_dwDebugCount--;
            CSPDebugOutputFuncReturn(fReturn);
        }
    }
}

void CSPDebugOutputDuplicateKey(
                                IN BOOL fEnter,
                                IN BOOL fReturn,
                                IN HCRYPTPROV hProv,
                                IN HCRYPTKEY hKey,
                                IN DWORD *pdwReserved,
                                IN DWORD dwFlags,
                                IN HCRYPTKEY *phKey
                                )
{
    if (CSPCheckIfShouldDisplayOutput())
    {
        if (fEnter)
        {
            OutputDebugHeader("DuplicateKey ");
            // dump hProv
            CSPDebugOutput("HCRYPTPROV     :\n    ");
            CSPDumpHexString((BYTE*)&hProv, sizeof(HCRYPTPROV));
            // dump hKey
            CSPDebugOutput("HCRYPTKEY      :\n    ");
            CSPDumpHexString((BYTE*)&hKey, sizeof(HCRYPTKEY));
            // dump pdwReserved
            CSPDebugOutput("pdwReserved    : Not used\n    ");
            // dump dwFlags
            CSPDebugOutput("dwFlags        :\n    ");
            CSPDumpHexString((BYTE*)&dwFlags, sizeof(DWORD));
            // dump phKey
            CSPDebugOutput("HCRYPTKEY*     :\n    ");
            CSPDumpHexString((BYTE*)phKey, sizeof(HCRYPTKEY));
            g_dwDebugCount++;
        }
        else
        {
            g_dwDebugCount--;
            CSPDebugOutputFuncReturn(fReturn);
        }
    }
}

void CSPDebugOutputGetHashParam(
                                IN BOOL fEnter,
                                IN BOOL fReturn,
                                IN HCRYPTPROV hProv,
                                IN HCRYPTHASH hHash,
                                IN DWORD dwParam,
                                IN BYTE *pbData,
                                IN DWORD *pdwDataLen,
                                IN DWORD dwFlags
                                )
{
    if (CSPCheckIfShouldDisplayOutput())
    {
        if (fEnter)
        {
            OutputDebugHeader("GetHashParam ");
            // dump hProv
            CSPDebugOutput("HCRYPTPROV     :\n    ");
            CSPDumpHexString((BYTE*)&hProv, sizeof(HCRYPTPROV));
            // dump hHash
            CSPDebugOutput("HCRYPTHASH     :\n    ");
            CSPDumpHexString((BYTE*)&hHash, sizeof(HCRYPTHASH));
            // dump dwParam
            CSPDebugOutput("dwParam        :\n    ");
            CSPDumpHexString((BYTE*)&dwParam, sizeof(DWORD));
            // dump pdwDataLen
            CSPDebugOutput("pdwDataLen     :\n    ");
            CSPDumpHexString((BYTE*)pdwDataLen, sizeof(DWORD));
            // dump dwFlags
            CSPDebugOutput("dwFlags        :\n    ");
            CSPDumpHexString((BYTE*)&dwFlags, sizeof(DWORD));
            g_dwDebugCount++;
        }
        else
        {
            if (fReturn)
            {
                if (pbData)
                {
                    CSPDebugOutput("pbData         :\n    ");
                    CSPDumpHexString((BYTE*)pbData, *pdwDataLen);
                }
                else
                {
                    CSPDebugOutput("pbData         : NULL\n    ");
                }
            }
            else
            {
                // dump data pointer - output buffer so no dump
                CSPDebugOutput("pbData         : Output buffer\n    ");
            }
            g_dwDebugCount--;
            CSPDebugOutputFuncReturn(fReturn);
        }
    }
}

void CSPDebugOutputSetHashParam(
                                IN BOOL fEnter,
                                IN BOOL fReturn,
                                IN HCRYPTPROV hProv,
                                IN HCRYPTHASH hHash,
                                IN DWORD dwParam,
                                IN BYTE *pbData,
                                IN DWORD dwFlags
                                )
{
    if (CSPCheckIfShouldDisplayOutput())
    {
        if (fEnter)
        {
            OutputDebugHeader("SetHashParam ");
            // dump hProv
            CSPDebugOutput("HCRYPTPROV     :\n    ");
            CSPDumpHexString((BYTE*)&hProv, sizeof(HCRYPTPROV));
            // dump hHash
            CSPDebugOutput("HCRYPTHASH     :\n    ");
            CSPDumpHexString((BYTE*)&hHash, sizeof(HCRYPTHASH));
            // dump dwParam
            CSPDebugOutput("dwParam        :\n    ");
            CSPDumpHexString((BYTE*)&dwParam, sizeof(DWORD));
            // dump data pointer - don't have a length so can't do much
            CSPDebugOutput("pbData         : No length so no data display\n    ");
            // dump dwFlags
            CSPDebugOutput("dwFlags        :\n    ");
            CSPDumpHexString((BYTE*)&dwFlags, sizeof(DWORD));
            g_dwDebugCount++;
        }
        else
        {
            g_dwDebugCount--;
            CSPDebugOutputFuncReturn(fReturn);
        }
    }
}

void CSPDebugOutputEncrypt(
                           IN BOOL fEnter,
                           IN BOOL fReturn,
                           IN HCRYPTPROV hProv,
                           IN HCRYPTHASH hKey,
                           IN HCRYPTHASH hHash,
                           IN BOOL Final,
                           IN DWORD dwFlags,
                           IN BYTE *pbData,
                           IN DWORD *pdwDataLen,
                           IN DWORD dwBufLen
                           )
{
    if (CSPCheckIfShouldDisplayOutput())
    {
        if (fEnter)
        {
            OutputDebugHeader("Encrypt ");
            // dump hProv
            CSPDebugOutput("HCRYPTPROV     :\n    ");
            CSPDumpHexString((BYTE*)&hProv, sizeof(HCRYPTPROV));
            // dump hKey
            CSPDebugOutput("HCRYPTKEY      :\n    ");
            CSPDumpHexString((BYTE*)&hKey, sizeof(HCRYPTKEY));
            // dump hHash
            CSPDebugOutput("HCRYPTHASH     :\n    ");
            CSPDumpHexString((BYTE*)&hHash, sizeof(HCRYPTHASH));
            // dump Final
            CSPDebugOutput("Final flag     :\n    ");
            CSPDumpHexString((BYTE*)&Final, sizeof(BOOL));
            // dump dwFlags
            CSPDebugOutput("dwFlags        :\n    ");
            CSPDumpHexString((BYTE*)&dwFlags, sizeof(DWORD));
            // dump data pointer
            if (NULL == pbData)
            {
                CSPDebugOutput("pbData         : NULL buffer \n");
            }
            else
            {
                CSPDebugOutput("pbData     :\n    ");
                CSPDumpHexString(pbData, *pdwDataLen);
            }
            // dump pdwDataLen
            CSPDebugOutput("pdwDataLen     :\n    ");
            CSPDumpHexString((BYTE*)pdwDataLen, sizeof(DWORD));
            // dump dwBufLen
            CSPDebugOutput("dwBufLen       :\n    ");
            CSPDumpHexString((BYTE*)&dwBufLen, sizeof(DWORD));
            g_dwDebugCount++;
        }
        else
        {
            g_dwDebugCount--;
            CSPDebugOutputFuncReturn(fReturn);
        }
    }
}

void CSPDebugOutputDecrypt(
                           IN BOOL fEnter,
                           IN BOOL fReturn,
                           IN HCRYPTPROV hProv,
                           IN HCRYPTHASH hKey,
                           IN HCRYPTHASH hHash,
                           IN BOOL Final,
                           IN DWORD dwFlags,
                           IN BYTE *pbData,
                           IN DWORD *pdwDataLen
                           )
{
    if (CSPCheckIfShouldDisplayOutput())
    {
        if (fEnter)
        {
            OutputDebugHeader("Decrypt ");
            // dump hProv
            CSPDebugOutput("HCRYPTPROV     :\n    ");
            CSPDumpHexString((BYTE*)&hProv, sizeof(HCRYPTPROV));
            // dump hKey
            CSPDebugOutput("HCRYPTKEY      :\n    ");
            CSPDumpHexString((BYTE*)&hKey, sizeof(HCRYPTKEY));
            // dump hHash
            CSPDebugOutput("HCRYPTHASH     :\n    ");
            CSPDumpHexString((BYTE*)&hHash, sizeof(HCRYPTHASH));
            // dump Final
            CSPDebugOutput("Final flag     :\n    ");
            CSPDumpHexString((BYTE*)&Final, sizeof(BOOL));
            // dump dwFlags
            CSPDebugOutput("dwFlags        :\n    ");
            CSPDumpHexString((BYTE*)&dwFlags, sizeof(DWORD));
            // dump data pointer
            if (NULL == pbData)
            {
                CSPDebugOutput("pbData         : NULL buffer \n");
            }
            else
            {
                CSPDebugOutput("pbData     :\n    ");
                CSPDumpHexString(pbData, *pdwDataLen);
            }
            // dump pdwDataLen
            CSPDebugOutput("pdwDataLen     :\n    ");
            CSPDumpHexString((BYTE*)pdwDataLen, sizeof(DWORD));
            g_dwDebugCount++;
        }
        else
        {
            g_dwDebugCount--;
            CSPDebugOutputFuncReturn(fReturn);
        }
    }
}

void CSPDebugOutputSignHash(
                            IN BOOL fEnter,
                            IN BOOL fReturn,
                            IN HCRYPTPROV hProv,
                            IN HCRYPTHASH hHash,
                            IN DWORD dwKeySpec,
                            IN LPCWSTR pszDescription,
                            IN DWORD dwFlags,
                            IN BYTE *pbSignature,
                            IN DWORD *pdwSigLen
                            )
{
    if (CSPCheckIfShouldDisplayOutput())
    {
        if (fEnter)
        {
            OutputDebugHeader("SignHash ");
            // dump hProv
            CSPDebugOutput("HCRYPTPROV     :\n    ");
            CSPDumpHexString((BYTE*)&hProv, sizeof(HCRYPTPROV));
            // dump hHash
            CSPDebugOutput("HCRYPTHASH     :\n    ");
            CSPDumpHexString((BYTE*)&hHash, sizeof(HCRYPTHASH));
            // dump dwKeySpec
            CSPDebugOutput("dwKeySpec      :\n    ");
            CSPDumpHexString((BYTE*)&dwKeySpec, sizeof(DWORD));
            // dump sDescription
            if (NULL == pszDescription)
            {
                CSPDebugOutput("sDescription   : NULL pointer\n    ");
            }
            else
            {
                CSPDebugOutput("sDescription   : non-NULL\n    ");
            }
            // dump dwFlags
            CSPDebugOutput("dwFlags        :\n    ");
            CSPDumpHexString((BYTE*)&dwFlags, sizeof(DWORD));
            // dump data pointer - output buffer so no use dumping
            CSPDebugOutput("pbData         : Output buffer \n");
            // dump pdwSigLen
            CSPDebugOutput("pdwSigLen      :\n    ");
            CSPDumpHexString((BYTE*)pdwSigLen, sizeof(DWORD));
            g_dwDebugCount++;
        }
        else
        {
            g_dwDebugCount--;
            CSPDebugOutputFuncReturn(fReturn);
        }
    }
}

void CSPDebugOutputVerifySignature(
                                   IN BOOL fEnter,
                                   IN BOOL fReturn,
                                   IN HCRYPTPROV hProv,
                                   IN HCRYPTHASH hHash,
                                   IN BYTE *pbSignature,
                                   IN DWORD dwSigLen,
                                   IN HCRYPTKEY hPubKey,
                                   IN LPCWSTR pszDescription,
                                   IN DWORD dwFlags
                                   )
{
    if (CSPCheckIfShouldDisplayOutput())
    {
        if (fEnter)
        {
            OutputDebugHeader("VerifySignature ");
            // dump hProv
            CSPDebugOutput("HCRYPTPROV     :\n    ");
            CSPDumpHexString((BYTE*)&hProv, sizeof(HCRYPTPROV));
            // dump hHash
            CSPDebugOutput("HCRYPTHASH     :\n    ");
            CSPDumpHexString((BYTE*)&hHash, sizeof(HCRYPTHASH));
            // dump signature pointer
            CSPDebugOutput("pbSignature    :\n");
            CSPDumpHexString(pbSignature, dwSigLen);
            // dump pdwSigLen
            CSPDebugOutput("dwSigLen       :\n    ");
            CSPDumpHexString((BYTE*)&dwSigLen, sizeof(DWORD));
            // dump hPubKey
            CSPDebugOutput("HCRYPTKEY      :\n    ");
            CSPDumpHexString((BYTE*)&hPubKey, sizeof(HCRYPTKEY));
            // dump sDescription
            if (NULL == pszDescription)
            {
                CSPDebugOutput("sDescription   : NULL pointer\n    ");
            }
            else
            {
                CSPDebugOutput("sDescription   : non-NULL\n    ");
            }
            // dump dwFlags
            CSPDebugOutput("dwFlags        :\n    ");
            CSPDumpHexString((BYTE*)&dwFlags, sizeof(DWORD));
            g_dwDebugCount++;
        }
        else
        {
            g_dwDebugCount--;
            CSPDebugOutputFuncReturn(fReturn);
        }
    }
}

void CSPDebugOutputCreateHash(
                              IN BOOL fEnter,
                              IN BOOL fReturn,
                              IN HCRYPTPROV hProv,
                              IN ALG_ID Algid,
                              IN HCRYPTKEY hKey,
                              IN DWORD dwFlags,
                              IN HCRYPTHASH *phHash
                              )
{
    if (CSPCheckIfShouldDisplayOutput())
    {
        if (fEnter)
        {
            OutputDebugHeader("CreateHash ");
            // dump hProv
            CSPDebugOutput("HCRYPTPROV     :\n    ");
            CSPDumpHexString((BYTE*)&hProv, sizeof(HCRYPTPROV));
            // dump Algid
            CSPDebugOutput("Algid          :\n    ");
            CSPDumpHexString((BYTE*)&Algid, sizeof(Algid));
            // dump hKey
            CSPDebugOutput("HCRYPTKEY      :\n    ");
            CSPDumpHexString((BYTE*)&hKey, sizeof(HCRYPTKEY));
            // dump dwFlags
            CSPDebugOutput("dwFlags        :\n    ");
            CSPDumpHexString((BYTE*)&dwFlags, sizeof(dwFlags));
            g_dwDebugCount++;
        }
        else
        {
            // dump phHash
            CSPDebugOutput("HCRYPTHASH*    :\n    ");
            CSPDumpHexString((BYTE*)phHash, sizeof(HCRYPTHASH));
            g_dwDebugCount--;
            CSPDebugOutputFuncReturn(fReturn);
        }
    }
}

void CSPDebugOutputDestroyHash(
                               IN BOOL fEnter,
                               IN BOOL fReturn,
                               IN HCRYPTPROV hProv,
                               IN HCRYPTHASH hHash
                               )
{
    if (CSPCheckIfShouldDisplayOutput())
    {
        if (fEnter)
        {
            OutputDebugHeader("DestroyHash ");
            // dump hProv
            CSPDebugOutput("HCRYPTPROV     :\n    ");
            CSPDumpHexString((BYTE*)&hProv, sizeof(HCRYPTPROV));
            // dump hHash
            CSPDebugOutput("HCRYPTHASH     :\n    ");
            CSPDumpHexString((BYTE*)&hHash, sizeof(HCRYPTHASH));
            g_dwDebugCount++;
        }
        else
        {
            g_dwDebugCount--;
            CSPDebugOutputFuncReturn(fReturn);
        }
    }
}

void CSPDebugOutputHashData(
                            IN BOOL fEnter,
                            IN BOOL fReturn,
                            IN HCRYPTPROV hProv,
                            IN HCRYPTHASH hHash,
                            IN BYTE *pbData,
                            IN DWORD dwDataLen,
                            IN DWORD dwFlags
                            )
{
    if (CSPCheckIfShouldDisplayOutput())
    {
        if (fEnter)
        {
            OutputDebugHeader("HashData ");
            // dump hProv
            CSPDebugOutput("HCRYPTPROV     :\n    ");
            CSPDumpHexString((BYTE*)&hProv, sizeof(HCRYPTPROV));
            // dump hHash
            CSPDebugOutput("HCRYPTHASH     :\n    ");
            CSPDumpHexString((BYTE*)&hHash, sizeof(HCRYPTHASH));
            // dump pbData
            CSPDebugOutput("pbData         :\n    ");
            CSPDumpHexString(pbData, dwDataLen);
            // dump dwDataLen
            CSPDebugOutput("dwDataLen      :\n    ");
            CSPDumpHexString((BYTE*)&dwDataLen, sizeof(dwDataLen));
            // dump dwFlags
            CSPDebugOutput("dwFlags        :\n    ");
            CSPDumpHexString((BYTE*)&dwFlags, sizeof(dwFlags));
            g_dwDebugCount++;
        }
        else
        {
            g_dwDebugCount--;
            CSPDebugOutputFuncReturn(fReturn);
        }
    }
}

void CSPDebugOutputHashSessionKey(
                                  IN BOOL fEnter,
                                  IN BOOL fReturn,
                                  IN HCRYPTPROV hProv,
                                  IN HCRYPTHASH hHash,
                                  IN HCRYPTKEY hKey,
                                  IN DWORD dwFlags
                                  )
{
    if (CSPCheckIfShouldDisplayOutput())
    {
        if (fEnter)
        {
            OutputDebugHeader("HashSessionKey ");
            // dump hProv
            CSPDebugOutput("HCRYPTPROV     :\n    ");
            CSPDumpHexString((BYTE*)&hProv, sizeof(HCRYPTPROV));
            // dump hHash
            CSPDebugOutput("HCRYPTHASH     :\n    ");
            CSPDumpHexString((BYTE*)&hHash, sizeof(HCRYPTHASH));
            // dump hHash
            CSPDebugOutput("HCRYPTKEY      :\n    ");
            CSPDumpHexString((BYTE*)&hKey, sizeof(HCRYPTKEY));
            // dump dwFlags
            CSPDebugOutput("dwFlags        :\n    ");
            CSPDumpHexString((BYTE*)&dwFlags, sizeof(dwFlags));
            g_dwDebugCount++;
        }
        else
        {
            g_dwDebugCount--;
            CSPDebugOutputFuncReturn(fReturn);
        }
    }
}

void CSPDebugOutputDuplicateHash(
                                 IN BOOL fEnter,
                                 IN BOOL fReturn,
                                 IN HCRYPTPROV hProv,
                                 IN HCRYPTHASH hHash,
                                 IN DWORD *pdwReserved,
                                 IN DWORD dwFlags,
                                 IN HCRYPTHASH *phHash
                                 )
{
    if (CSPCheckIfShouldDisplayOutput())
    {
        if (fEnter)
        {
            OutputDebugHeader("DuplicateHash ");
            // dump hProv
            CSPDebugOutput("HCRYPTPROV     :\n    ");
            CSPDumpHexString((BYTE*)&hProv, sizeof(HCRYPTPROV));
            // dump hHash
            CSPDebugOutput("HCRYPTHASH     :\n    ");
            CSPDumpHexString((BYTE*)&hHash, sizeof(HCRYPTHASH));
            // dump pdwReserved
            CSPDebugOutput("pdwReserved    : Reserved for future\n    ");
            // dump dwFlags
            CSPDebugOutput("dwFlags        :\n    ");
            CSPDumpHexString((BYTE*)&dwFlags, sizeof(dwFlags));
            // dump hHash
            CSPDebugOutput("HCRYPTHASH*    :\n    ");
            CSPDumpHexString((BYTE*)phHash, sizeof(HCRYPTHASH));
            g_dwDebugCount++;
        }
        else
        {
            g_dwDebugCount--;
            CSPDebugOutputFuncReturn(fReturn);
        }
    }
}

#endif // DBG -- NOTE:  This section not compiled for retail builds
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\rsabase\des3.c ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : des3.c                                                 //
//  DESCRIPTION   : Crypto CP interfaces:                                  //
//                  CPEncrypt                                              //
//                  CPDecrypt                                              //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Sep 13 1996 jeffspel Created                                       //
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

//#include <wtypes.h>
#include "precomp.h"
#include "nt_rsa.h"
#include "des3.h"

BYTE ParityTable[] = {0x00,0x01,0x01,0x02,0x01,0x02,0x02,0x03,
                      0x01,0x02,0x02,0x03,0x02,0x03,0x03,0x04};

// In des2key.c:
//
//	 Fill in the DES3Table structs with the decrypt and encrypt
//	 key expansions.
//
//	 Assumes that the second parameter points to 2 * DES_BLOCKLEN
//	 bytes of key.
//	 
//

void des2key(PDES3TABLE pDES3Table, PBYTE pbKey)
{
    deskey(&pDES3Table->keytab1, pbKey);
    deskey(&pDES3Table->keytab2, pbKey+DES_KEYSIZE);
    CopyMemory(&pDES3Table->keytab3, &pDES3Table->keytab1, DES_TABLESIZE);
}

// In des3key.c:
//
//   Fill in the DES3Table structs with the decrypt and encrypt
//   key expansions.
//	 
//   Assumes that the second parameter points to 3 * DES_BLOCKLEN
//   bytes of key.
//	 
//

void des3key(PDES3TABLE pDES3Table, PBYTE pbKey)
{
    deskey(&pDES3Table->keytab1, pbKey);
    deskey(&pDES3Table->keytab2, pbKey+DES_KEYSIZE);
    deskey(&pDES3Table->keytab3, pbKey+2*DES_KEYSIZE);
}

//
//	 Encrypt or decrypt with the key in DES3Table
//

void des3(PBYTE pbOut, PBYTE pbIn, void *pKey, int op)
{
    PDES3TABLE  pDES3Table = (PDES3TABLE)pKey;
    BYTE        rgbEnc1[DES_BLOCKLEN];
    BYTE        rgbEnc2[DES_BLOCKLEN];

    if (ENCRYPT == op)      // encrypt case
    {
        des(rgbEnc1, pbIn, &pDES3Table->keytab1, ENCRYPT);
        des(rgbEnc2, rgbEnc1, &pDES3Table->keytab2, DECRYPT);
        memset(rgbEnc1, 0xFF, DES_BLOCKLEN);
        des(pbOut, rgbEnc2, &pDES3Table->keytab3, ENCRYPT);
        memset(rgbEnc2, 0xFF, DES_BLOCKLEN);
    }
    else                    // decrypt case
    {
        des(rgbEnc1, pbIn, &pDES3Table->keytab3, DECRYPT);
        des(rgbEnc2, rgbEnc1, &pDES3Table->keytab2, ENCRYPT);
        memset(rgbEnc1, 0xFF, DES_BLOCKLEN);
        des(pbOut, rgbEnc2, &pDES3Table->keytab1, DECRYPT);
        memset(rgbEnc2, 0xFF, DES_BLOCKLEN);
    }
}

// 
// set the parity on the DES key to be odd
//

void desparity(PBYTE pbKey, DWORD cbKey)
{
    DWORD i;

    for (i=0;i<cbKey;i++)
    {
        if (!((ParityTable[pbKey[i]>>4] + ParityTable[pbKey[i]&0x0F]) % 2))
            pbKey[i] = pbKey[i] ^ 0x01;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\rsabase\manage.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : manage.h                                               //
//  DESCRIPTION   :                                                        //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Apr 19 1995 larrys  Cleanup                                        //
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef __MANAGE_H__
#define __MANAGE_H__

#ifdef __cplusplus
extern "C" {
#endif

void *NTLValidate(HCRYPTPROV hUID, HCRYPTKEY hKey, BYTE bTypeValue);
BOOL NTLMakeItem(HCRYPTKEY *phKey, BYTE bTypeValue, void *NewData);
void *NTLCheckList(HNTAG hThisThing, BYTE bTypeValue);
BOOL NTLDelete(HNTAG hItem);

#define _nt_malloc(cb)  LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, cb)
#define _nt_free(pv, _cbSizeToZero_)    LocalFree(pv)

#ifdef __cplusplus
}
#endif

#endif // __MANAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\rsabase\manage.c ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : manage.c                                               //
//  DESCRIPTION   : Misc list/memory management routines.                  //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//	Jan 25 1995 larrys  Changed from Nametag                               //
//      Feb 23 1995 larrys  Changed NTag_SetLastError to SetLastError      //
//      Apr 19 1995 larrys  Cleanup                                        //
//      Sep 11 1995 Jeffspel/ramas  Merge STT into default CSP             //
//      Oct 27 1995 rajeshk  RandSeed Stuff added hUID to PKCS2Encrypt     //
//      Nov  3 1995 larrys  Merge for NT checkin                           //
//      Nov 13 1995 larrys  Fixed memory leak                              //
//      Dec 11 1995 larrys  Added WIN95 password cache                     //
//      Dec 13 1995 larrys  Remove MTS stuff                               //
//      May 15 1996 larrys  Remove old cert stuff                          //
//      May 28 1996 larrys  Added Win95 registry install stuff             //
//      Jun 12 1996 larrys  Encrypted public keys                          //
//      Jun 26 1996 larrys  Put rsabase.sig into a resource for regsrv32   //
//      Sep 16 1996 mattt   Added Strong provider type in #define          //
//      Oct 14 1996 jeffspel Changed GenRandom to NewGenRandom             //
//      May 23 1997 jeffspel Added provider type checking                  //
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "resource.h"
#include "nt_rsa.h"
#include "randlib.h"
#include "protstor.h"
#include "ole2.h"
#include "swnt_pk.h"
#include "sgccheck.h"

#define	MAXITER		0xFFFF

#define RSAFULL_TYPE_STRING     "Type 001"
#define RSA_SCH_TYPE_STRING     "Type 012"

#define MS_RSA_TYPE     "RSA Full (Signature and Key Exchange)"
#define MS_RSA_SCH_TYPE "RSA SChannel"

#define PROVPATH        "SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider\\"
#define PROVPATH_LEN    sizeof(PROVPATH)

#define TYPEPATH        "SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider Types\\"
#define TYPEPATH_LEN    sizeof(TYPEPATH)

HINSTANCE hInstance;

BOOL WINAPI FIsWinNT(void);

#ifdef STRONG
CHAR szImagePath[] = "rsaenh.dll";
#define SIG_RESOURCE_NUM    2
#else
CHAR szImagePath[] = "rsabase.dll";
#define SIG_RESOURCE_NUM    1
#endif // STRONG

// MAC in file
#define MAC_RESOURCE_NUM    "#667"

#define KEYSIZE1024 0x88

struct _mskey {
    BSAFE_PUB_KEY    PUB;
    unsigned char pubmodulus[KEYSIZE1024];
} MSKEY = {
    {
	0x2bad85ae,
	0x883adacc,
	0xb32ebd68,
	0xa7ec8b06,
	0x58dbeb81,
    },
    {
	0x42, 0x34, 0xb7, 0xab, 0x45, 0x0f, 0x60, 0xcd,
	0x8f, 0x77, 0xb5, 0xd1, 0x79, 0x18, 0x34, 0xbe,
	0x66, 0xcb, 0x5c, 0x66, 0x4a, 0x9f, 0x03, 0x18,
	0x13, 0x36, 0x8e, 0x88, 0x21, 0x78, 0xb1, 0x94,
	0xa1, 0xd5, 0x8f, 0x8c, 0xa5, 0xd3, 0x9f, 0x86,
	0x43, 0x89, 0x05, 0xa0, 0xe3, 0xee, 0xe2, 0xd0,
	0xe5, 0x1d, 0x5f, 0xaf, 0xff, 0x85, 0x71, 0x7a,
	0x0a, 0xdb, 0x2e, 0xd8, 0xc3, 0x5f, 0x2f, 0xb1,
	0xf0, 0x53, 0x98, 0x3b, 0x44, 0xee, 0x7f, 0xc9,
	0x54, 0x26, 0xdb, 0xdd, 0xfe, 0x1f, 0xd0, 0xda,
	0x96, 0x89, 0xc8, 0x9e, 0x2b, 0x5d, 0x96, 0xd1,
	0xf7, 0x52, 0x14, 0x04, 0xfb, 0xf8, 0xee, 0x4d,
	0x92, 0xd1, 0xb6, 0x37, 0x6a, 0xe0, 0xaf, 0xde,
	0xc7, 0x41, 0x06, 0x7a, 0xe5, 0x6e, 0xb1, 0x8c,
	0x8f, 0x17, 0xf0, 0x63, 0x8d, 0xaf, 0x63, 0xfd,
	0x22, 0xc5, 0xad, 0x1a, 0xb1, 0xe4, 0x7a, 0x6b,
	0x1e, 0x0e, 0xea, 0x60, 0x56, 0xbd, 0x49, 0xd0,
    }
};



DWORD NTVersion(void)
{
    return 5;
}

BOOL SetCSPInfo(
                LPSTR pszProvider,
                LPSTR pszImagePath,
                BYTE *pbSig,
                DWORD cbSig,
                DWORD dwProvType,
                LPSTR pszType,
                LPSTR pszTypeName,
                BOOL fSigInFile,
                BOOL fMakeDefault
                )
{
#ifndef _XBOX
    DWORD   dwIgn;
    HKEY    hKey = 0;
    HKEY    hTypeKey = 0;
    DWORD   cbProv;
    BYTE    *pszProv = NULL;
    DWORD   cbTypePath;
    BYTE    *pszTypePath = NULL;
    DWORD   dwVal = 0;
    DWORD   err;
    BOOL    fRet = FALSE;

    cbProv = PROVPATH_LEN + strlen(pszProvider);
    if (NULL == (pszProv = (LPSTR)LocalAlloc(LMEM_ZEROINIT, cbProv)))
        goto Ret;

    strcpy(pszProv, PROVPATH);
    strcat(pszProv, pszProvider);

	//
	// Create or open in local machine for provider:
	//
    if (ERROR_SUCCESS != (err = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                               (const char *)pszProv,
                                               0L, "", REG_OPTION_NON_VOLATILE,
                                               KEY_ALL_ACCESS, NULL, &hKey,
                                               &dwIgn)))
        goto Ret;

	//
	// Set Image path to: scp.dll
	//
    if (ERROR_SUCCESS != (err = RegSetValueEx(hKey, "Image Path", 0L, REG_SZ,
	                                          pszImagePath,
                                              strlen(pszImagePath) + 1)))
        goto Ret;

	//
	// Set Type to: Type 003
	//
    if (ERROR_SUCCESS != (err = RegSetValueEx(hKey, "Type", 0L, REG_DWORD,
                                              (LPTSTR)&dwProvType,
                                              sizeof(DWORD))))
        goto Ret;

    if (fSigInFile)
    {
	    //
	    // Place signature in file value
	    //
        if (ERROR_SUCCESS != (err = RegSetValueEx(hKey, "SigInFile", 0L,
                                                  REG_DWORD, (LPTSTR)&dwVal,
                                                  sizeof(DWORD))))
            goto Ret;
    }
    else
    {
	    //
	    // Place signature
	    //
        if (ERROR_SUCCESS != (err = RegSetValueEx(hKey, "Signature", 0L,
                                                  REG_BINARY, pbSig, cbSig)))
            goto Ret;
    }

	//
	// Create or open in local machine for provider type:
	//

    cbTypePath = TYPEPATH_LEN + strlen(pszType) + 1;
    if (NULL == (pszTypePath = (LPSTR)LocalAlloc(LMEM_ZEROINIT, cbTypePath)))
        goto Ret;

    strcpy(pszTypePath, TYPEPATH);
    strcat(pszTypePath, pszType);

    if (ERROR_SUCCESS != (err = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                               (const char *) pszTypePath,
                                               0L, "", REG_OPTION_NON_VOLATILE,
                                               KEY_ALL_ACCESS, NULL, &hTypeKey,
                                               &dwIgn)))
        goto Ret;

    if ((REG_CREATED_NEW_KEY == dwIgn) || fMakeDefault)
    {
        if (ERROR_SUCCESS != (err = RegSetValueEx(hTypeKey, "Name", 0L,
                                                  REG_SZ, pszProvider,
                                                  strlen(pszProvider) + 1)))
            goto Ret;

        if (ERROR_SUCCESS != (err = RegSetValueEx(hTypeKey, "TypeName", 0L,
                                                  REG_SZ, pszTypeName,
                                                  strlen(pszTypeName) + 1)))
            goto Ret;
    }

    fRet = TRUE;
Ret:
    if (hKey)
        RegCloseKey(hKey);
    if (hTypeKey)
        RegCloseKey(hTypeKey);
    if (pszProv)
        LocalFree(pszProv);
    if (pszTypePath)
        LocalFree(pszTypePath);
    return fRet;
#else
    ASSERT( !"SetCSPInfo" );
    return TRUE;
#endif
}

BOOL LoadWin96Cache(PNTAGUserList pTmpUser);

void EncryptKey(BYTE *pdata, DWORD size, BYTE val);

void FreeNewKey(PNTAGKeyList pOldKey);

BOOL SelfMACCheck(
                  IN LPSTR pszImage
                  );


// See if a handle of the given type is in the list.
// If it is, return the item itself.

static void *
NTLFindItem(HNTAG hThisThing, BYTE bTypeValue)
{
    HTABLE *pTable;

    pTable = (HTABLE*)(hThisThing ^ HANDLE_MASK);

	if ((BYTE)pTable->dwType != bTypeValue)
		return NULL;

	return (void*)pTable->pItem;
}

// See if a handle of the given type is in the list.
// If it is, return the data that the item holds.
void *
NTLCheckList(HNTAG hThisThing, BYTE bTypeValue)
{
	return NTLFindItem(hThisThing, bTypeValue);
}

// Find & validate the passed list item against the user and type.

void *NTLValidate(HNTAG hItem, HCRYPTPROV hUID, BYTE bTypeValue)
{
	void		*pTmpVal;

	// check to see if the key is in the key list
	if ((pTmpVal = NTLCheckList (hItem, bTypeValue)) == NULL)
	{
		SetLastError((DWORD) NTE_FAIL);		// converted by caller
		return NULL;
	}

	// check to make sure there is a key value
	if ((bTypeValue == KEY_HANDLE) &&
	    (((PNTAGKeyList)pTmpVal)->pKeyValue == NULL))
	{
		ASSERT(((PNTAGKeyList)pTmpVal)->cbKeyLen == 0);
		SetLastError((DWORD) NTE_BAD_KEY);
		return NULL;
	}

	// make sure the UIDs are the same
	if (((PNTAGKeyList)pTmpVal)->hUID != hUID)
	{
		SetLastError((DWORD) NTE_BAD_UID);
		return NULL;
	}

	return pTmpVal;
}

// Make a new list item of the given type, and assign the data to it.

BOOL NTLMakeItem(HNTAG *phItem, BYTE bTypeValue, void *NewData)
{
	HTABLE   *NewMember;

	if ((NewMember = (HTABLE *)_nt_malloc(sizeof(HTABLE))) == NULL)
    {
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		return NTF_FAILED;
	}

	NewMember->pItem = NewData;
    NewMember->dwType = bTypeValue;
	
    *phItem = (HNTAG)((HNTAG)NewMember ^ HANDLE_MASK);
	return NTF_SUCCEED;
}

// Remove the handle.  Assumes that any memory used by the handle data has been freed.

BOOL NTLDelete(HNTAG hItem)
{
    HTABLE  *pTable;

    pTable = (HTABLE*)(hItem ^ HANDLE_MASK);

	_nt_free(pTable, sizeof(HTABLE));

	return NTF_SUCCEED;
}

/****************************************************************/
/* FreeUserRec frees the dynamically allocated memory for the	*/
/* appropriate fields of the UserRec structure.					*/
/*																*/
/* MTS: we assume that pUser has only one reference (no			*/
/* MTS: multiple logon's for the same user name).				*/
/****************************************************************/

void
FreeUserRec (PNTAGUserList pUser)
{
    if (pUser != NULL)
    {
        // No need to zero lengths, since entire struct is going away
        if (pUser->pExchPrivKey)
        {
            ZeroMemory( pUser->pExchPrivKey, pUser->ExchPrivLen );
            _nt_free (pUser->pExchPrivKey, 0);
        }

        if (pUser->pSigPrivKey)
        {
            ZeroMemory( pUser->pSigPrivKey, pUser->SigPrivLen );
            _nt_free (pUser->pSigPrivKey, 0);
        }

        if (pUser->pUser)
        {
            _nt_free(pUser->pUser, 0);
        }

        if (pUser->pCachePW)
        {
            ZeroMemory(pUser->pCachePW, STORAGE_RC4_KEYLEN);
            _nt_free(pUser->pCachePW, 0);
        }

        if (pUser->pPStore)
        {
            FreePSInfo(pUser->pPStore);
        }

        // free the SGC key info
#ifndef _XBOX
        SGCDeletePubKeyValues(&pUser->pbSGCKeyMod,
                              &pUser->cbSGCKeyMod,
                              &pUser->dwSGCKeyExpo);
#endif

        FreeContainerInfo(&pUser->ContInfo);

        FreeOffloadInfo(pUser->pOffloadInfo);

        DeleteCriticalSection(&pUser->CritSec);

        ZeroMemory(pUser, sizeof(NTAGUserList));
        _nt_free (pUser, 0);
    }
}

// RSA private key in PRIVATEKEYBLOB format 
static BYTE rgbRSAPriv[] =
{
0x52, 0x53, 0x41, 0x32, 0x48, 0x00, 0x00, 0x00,
0x00, 0x02, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00,
0x01, 0x00, 0x01, 0x00, 0xEF, 0x4C, 0x0D, 0x34,
0xCF, 0x44, 0x0F, 0xB1, 0x73, 0xAC, 0xD4, 0x9B,
0xBE, 0xCC, 0x2D, 0x11, 0x2A, 0x2B, 0xBD, 0x21,
0x04, 0x8E, 0xAC, 0xAD, 0xD5, 0xFC, 0xD2, 0x50,
0x14, 0x35, 0x1B, 0x43, 0x15, 0x62, 0x67, 0x8F,
0x5E, 0x00, 0xB9, 0x25, 0x1B, 0xE2, 0x4F, 0xBE,
0xA1, 0x50, 0xA1, 0x44, 0x3B, 0x17, 0xD8, 0x91,
0xF5, 0x28, 0xF9, 0xFA, 0xAE, 0xE7, 0xC0, 0xFD,
0xB9, 0xCD, 0x76, 0x4F, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0xE9, 0xBB, 0x38, 0x52,
0xD9, 0x0D, 0x56, 0xD7, 0x36, 0xBA, 0xDC, 0xE8,
0xB5, 0x57, 0x56, 0x13, 0x1A, 0x3A, 0x43, 0x30,
0xDE, 0x7D, 0x76, 0x6F, 0xBB, 0x71, 0x3B, 0x0A,
0x92, 0xBA, 0x60, 0x94, 0x00, 0x00, 0x00, 0x00,
0x17, 0x33, 0x3D, 0xB5, 0xEF, 0xD8, 0x2B, 0xDE,
0xCD, 0xA6, 0x6A, 0x94, 0x17, 0xC3, 0x57, 0xE9,
0x2E, 0x1C, 0x9F, 0x35, 0xDA, 0xA4, 0xBD, 0x02,
0x5B, 0x9D, 0xD1, 0x38, 0x4C, 0xF2, 0x19, 0x89,
0x00, 0x00, 0x00, 0x00, 0x89, 0x21, 0xCB, 0x3F,
0x0C, 0xA7, 0x71, 0xBC, 0xF6, 0xA1, 0x87, 0xDF,
0x00, 0x2D, 0x27, 0x64, 0x4A, 0xD4, 0x93, 0x9F,
0x58, 0x93, 0x4B, 0x83, 0x1E, 0xAB, 0xD8, 0x5D,
0xBC, 0x0E, 0x58, 0x03, 0x00, 0x00, 0x00, 0x00,
0xAB, 0x09, 0xD7, 0x21, 0xBA, 0x6F, 0x55, 0x08,
0x12, 0xEE, 0x5B, 0x47, 0x6B, 0x9F, 0x3F, 0xD3,
0xFC, 0xEA, 0xB5, 0x25, 0x19, 0xB7, 0x9E, 0xBD,
0xDF, 0x6F, 0x7F, 0x96, 0x00, 0x88, 0xC6, 0x7B,
0x00, 0x00, 0x00, 0x00, 0x95, 0x0B, 0x23, 0xC5,
0x72, 0x98, 0x9D, 0x49, 0x7A, 0x46, 0x4E, 0xE1,
0xE6, 0x2F, 0xC6, 0x63, 0x21, 0x8F, 0x66, 0xDC,
0x9B, 0xCC, 0xE2, 0x27, 0x03, 0x27, 0x85, 0xF0,
0x3A, 0x02, 0xFB, 0x40, 0x00, 0x00, 0x00, 0x00,
0x51, 0x74, 0xF6, 0xF2, 0x23, 0xEC, 0xA1, 0x76,
0x55, 0x58, 0x07, 0x71, 0xBF, 0x7F, 0x0A, 0x1E,
0x6B, 0x48, 0x48, 0xBB, 0x92, 0xB6, 0x2A, 0xB1,
0x07, 0xA4, 0x21, 0xD1, 0xC6, 0xCB, 0x5F, 0x40,
0xCE, 0xDD, 0xBA, 0xDB, 0xFC, 0x17, 0xFB, 0xA7,
0xBD, 0xE1, 0xF4, 0x63, 0xD8, 0x9E, 0x89, 0xE2,
0xDD, 0x7A, 0xEC, 0x11, 0xD6, 0xA9, 0x9C, 0xBA,
0xC7, 0x5E, 0x35, 0x96, 0xA6, 0x6F, 0x7F, 0x2C,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// RSA private key in PUBLICKEYBLOB format 
static BYTE rgbRSAPub[] =
{
0x52, 0x53, 0x41, 0x31, 0x48, 0x00, 0x00, 0x00,
0x00, 0x02, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00,
0x01, 0x00, 0x01, 0x00, 0xEF, 0x4C, 0x0D, 0x34,
0xCF, 0x44, 0x0F, 0xB1, 0x73, 0xAC, 0xD4, 0x9B,
0xBE, 0xCC, 0x2D, 0x11, 0x2A, 0x2B, 0xBD, 0x21,
0x04, 0x8E, 0xAC, 0xAD, 0xD5, 0xFC, 0xD2, 0x50,
0x14, 0x35, 0x1B, 0x43, 0x15, 0x62, 0x67, 0x8F,
0x5E, 0x00, 0xB9, 0x25, 0x1B, 0xE2, 0x4F, 0xBE,
0xA1, 0x50, 0xA1, 0x44, 0x3B, 0x17, 0xD8, 0x91,
0xF5, 0x28, 0xF9, 0xFA, 0xAE, 0xE7, 0xC0, 0xFD,
0xB9, 0xCD, 0x76, 0x4F, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00
};

// known result of an MD5 hash on the above buffer
static BYTE rgbKnownMD5[] =
{
0xb8, 0x2f, 0x6b, 0x11, 0x31, 0xc8, 0xec, 0xf4,
0xfe, 0x0b, 0xf0, 0x6d, 0x2a, 0xda, 0x3f, 0xc3
};

// known result of an SHA-1 hash on the above buffer
static BYTE rgbKnownSHA1[] =
{
0xe8, 0x96, 0x82, 0x85, 0xeb, 0xae, 0x01, 0x14,
0x73, 0xf9, 0x08, 0x45, 0xc0, 0x6a, 0x6d, 0x3e,
0x69, 0x80, 0x6a, 0x0c
};

// known key, plaintext, and ciphertext for RC4
static BYTE rgbRC4Key[] = {0x61, 0x8a, 0x63, 0xd2, 0xfb};
static BYTE rgbRC4KnownPlaintext[] = {0xDC, 0xEE, 0x4C, 0xF9, 0x2C};
static BYTE rgbRC4KnownCiphertext[] = {0xF1, 0x38, 0x29, 0xC9, 0xDE};

// IV for all block ciphers
BYTE rgbIV[] = {0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF};

// known key, plaintext, and ciphertext for RC2
BYTE rgbRC2Key[] = {0x59, 0x45, 0x9a, 0xf9, 0x27, 0x84, 0x74, 0xCA};
BYTE rgbRC2KnownPlaintext[] = {0xD5, 0x58, 0x75, 0x12, 0xCE, 0xEF, 0x77, 0x93};
BYTE rgbRC2KnownCiphertext[] = {0x7b, 0x98, 0xdf, 0x9d, 0xa2, 0xdc, 0x7b, 0x7a};
BYTE rgbRC2CBCCiphertext[] = {0x9d, 0x93, 0x8e, 0xf6, 0x7c, 0x01, 0x5e, 0xeb};

// known key, plaintext, and ciphertext for DES40 (CALG_CYLINK_MEK)
BYTE rgbDES40Key[] = {0x01, 0x23, 0x04, 0x67, 0x08, 0xab, 0x0d, 0xef};
BYTE rgbDES40KnownPlaintext[] = {0x4E, 0x6F, 0x77, 0x20, 0x69, 0x73, 0x20, 0x74};
BYTE rgbDES40KnownCiphertext[] = {0xac, 0x97, 0x4d, 0xd9, 0x02, 0x13, 0x88, 0x2c};
BYTE rgbDES40CBCCiphertext[] = {0x47, 0xdc, 0xf0, 0x13, 0x7f, 0xa5, 0xd6, 0x32};

// known key, plaintext, and ciphertext for DES
BYTE rgbDESKey[] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef};
BYTE rgbDESKnownPlaintext[] = {0x4E, 0x6F, 0x77, 0x20, 0x69, 0x73, 0x20, 0x74};
BYTE rgbDESKnownCiphertext[] = {0x3F, 0xA4, 0x0E, 0x8A, 0x98, 0x4D, 0x48, 0x15};
BYTE rgbDESCBCCiphertext[] = {0xE5, 0xC7, 0xCD, 0xDE, 0x87, 0x2B, 0xF2, 0x7C};

// known key, plaintext, and ciphertext for 3 key 3DES
BYTE rgb3DESKey[] =
{
0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01,
0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23
};
BYTE rgb3DESKnownPlaintext[] = {0x4E, 0x6F, 0x77, 0x20, 0x69, 0x73, 0x20, 0x74};
BYTE rgb3DESKnownCiphertext[] = {0x31, 0x4F, 0x83, 0x27, 0xFA, 0x7A, 0x09, 0xA8};
BYTE rgb3DESCBCCiphertext[] = {0xf3, 0xc0, 0xff, 0x02, 0x6c, 0x02, 0x30, 0x89};

// known key, plaintext, and ciphertext for 2 key 3DES
BYTE rgb3DES112Key[] =
{
0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01
};
BYTE rgb3DES112KnownPlaintext[] = {0x4E, 0x6F, 0x77, 0x20, 0x69, 0x73, 0x20, 0x74};
BYTE rgb3DES112KnownCiphertext[] = {0xb7, 0x83, 0x57, 0x79, 0xee, 0x26, 0xac, 0xb7};
BYTE rgb3DES112CBCCiphertext[] = {0x13, 0x4b, 0x98, 0xf8, 0xee, 0xb3, 0xf6, 0x07};

// **********************************************************************
// AlgorithmCheck performs known answer tests using the algorithms
// supported by the provider.
// **********************************************************************
BOOL AlgorithmCheck()
{
    BYTE        rgbMD5[MD5DIGESTLEN];
    BYTE        rgbSHA1[A_SHA_DIGEST_LEN]; 
    BOOL        fRet = FALSE;

    memset(rgbMD5, 0, sizeof(rgbMD5));
    memset(rgbSHA1, 0, sizeof(rgbSHA1));

    // check if RSA is working properly
    if (0 != EncryptAndDecryptWithRSAKey(rgbRSAPub, rgbRSAPriv, TRUE, TRUE))
    {
        goto Ret;
    }

    // check if RSA is working properly
    if (0 != EncryptAndDecryptWithRSAKey(rgbRSAPub, rgbRSAPriv, FALSE, TRUE))
    {
        goto Ret;
    }

#ifdef CSP_USE_MD5
    // known answer test with MD5 (this function is found in hash.c)
    if (!TestMD5("HashThis", 8, rgbMD5))
    {
        goto Ret;
    }
    if (memcmp(rgbMD5, rgbKnownMD5, sizeof(rgbMD5)))
    {
        goto Ret;
    }
#endif // CSP_USE_MD5

#ifdef CSP_USE_SHA1
    // known answer test with SHA-1  (this function is found in hash.c)
    if (!TestSHA1("HashThis", 8, rgbSHA1))
    {
        goto Ret;
    }
    if (memcmp(rgbSHA1, rgbKnownSHA1, sizeof(rgbSHA1)))
    {
        goto Ret;
    }
#endif // CSP_USE_SHA1

#ifdef CSP_USE_RC4
    // known answer test with RC4
    if (!TestSymmetricAlgorithm(CALG_RC4, rgbRC4Key, sizeof(rgbRC4Key),
                                rgbRC4KnownPlaintext,
                                sizeof(rgbRC4KnownPlaintext),
                                rgbRC4KnownCiphertext, NULL))
    {
        goto Ret;
    }
#endif // CSP_USE_RC4

#ifdef CSP_USE_RC2
    // known answer test with RC2 - ECB
    if (!TestSymmetricAlgorithm(CALG_RC2, rgbRC2Key, sizeof(rgbRC2Key),
                                rgbRC2KnownPlaintext,
                                sizeof(rgbRC2KnownPlaintext),
                                rgbRC2KnownCiphertext,
                                NULL))
    {
        goto Ret;
    }

    // known answer test with RC2 - CBC
    if (!TestSymmetricAlgorithm(CALG_RC2, rgbRC2Key, sizeof(rgbRC2Key),
                                rgbRC2KnownPlaintext,
                                sizeof(rgbRC2KnownPlaintext),
                                rgbRC2CBCCiphertext,
                                rgbIV))
    {
        goto Ret;
    }

#endif // CSP_USE_RC2

#ifdef CSP_USE_DES
    // known answer test with DES - ECB
    if (!TestSymmetricAlgorithm(CALG_DES, rgbDESKey, sizeof(rgbDESKey),
                                rgbDESKnownPlaintext,
                                sizeof(rgbDESKnownPlaintext),
                                rgbDESKnownCiphertext,
                                NULL))
    {
        goto Ret;
    }
    // known answer test with DES - CBC
    if (!TestSymmetricAlgorithm(CALG_DES, rgbDESKey, sizeof(rgbDESKey),
                                rgbDESKnownPlaintext,
                                sizeof(rgbDESKnownPlaintext),
                                rgbDESCBCCiphertext,
                                rgbIV))
    {
        goto Ret;
    }
#endif // CSP_USE_DES

#ifdef CSP_USE_3DES
    // known answer test with 3DES - ECB
    if (!TestSymmetricAlgorithm(CALG_3DES, rgb3DESKey, sizeof(rgb3DESKey),
                                rgb3DESKnownPlaintext,
                                sizeof(rgb3DESKnownPlaintext),
                                rgb3DESKnownCiphertext,
                                NULL))
    {
        goto Ret;
    }
    // known answer test with 3DES - CBC
    if (!TestSymmetricAlgorithm(CALG_3DES, rgb3DESKey, sizeof(rgb3DESKey),
                                rgb3DESKnownPlaintext,
                                sizeof(rgb3DESKnownPlaintext),
                                rgb3DESCBCCiphertext,
                                rgbIV))
    {
        goto Ret;
    }

    // known answer test with 3DES 112 - ECB
    if (!TestSymmetricAlgorithm(CALG_3DES_112, rgb3DES112Key,
                                sizeof(rgb3DES112Key),
                                rgb3DES112KnownPlaintext,
                                sizeof(rgb3DES112KnownPlaintext),
                                rgb3DES112KnownCiphertext,
                                NULL))
    {
        goto Ret;
    }
    if (!TestSymmetricAlgorithm(CALG_3DES_112, rgb3DES112Key,
                                sizeof(rgb3DES112Key),
                                rgb3DES112KnownPlaintext,
                                sizeof(rgb3DES112KnownPlaintext),
                                rgb3DES112CBCCiphertext,
                                rgbIV))
    {
        goto Ret;
    }
#endif // CSP_USE_3DES

    fRet = TRUE;
Ret:
    if (FALSE == fRet)
        SetLastError((DWORD)NTE_FAIL);
    return fRet;
}


BOOLEAN
DllInitialize(
    IN PVOID hmod,
    IN ULONG Reason,
    IN PCONTEXT Context
    )
{
#ifndef _XBOX
    hInstance = (HINSTANCE) hmod;

    if ( Reason == DLL_PROCESS_ATTACH )
    {
        DisableThreadLibraryCalls(hmod);

        // load strings from csprc.dll
        if (!LoadStrings())
            return FALSE;

        // do a start up check on all supported algorithms to make sure they
        // are working correctly
        if (!SelfMACCheck(szImagePath))
            return FALSE;

        // load library : DON'T FREE IT because it reloads leak
        LoadLibrary("ole32.dll");

        // do a start up check on all supported algorithms to make sure they
        // are working correctly
        if (!AlgorithmCheck())
            return FALSE;
    }
    else if ( Reason == DLL_PROCESS_DETACH )
    {
        // free the strings loaded from csprc.dll
        UnloadStrings();
    }
#endif
    return( TRUE );

}

CHAR sztype[] = "SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider Types\\Type 001";


DWORD
NT5RegisterServer(void)
{
    DWORD   dwErr = S_OK;

	//
	// install the default RSA provider
	// Type 001
	//
    if (!SetCSPInfo(
#ifdef STRONG
                    MS_ENHANCED_PROV,
#else
                    MS_DEF_PROV,
#endif // STRONG
                    szImagePath,
                    NULL,
                    0,
                    PROV_RSA_FULL,
                    RSAFULL_TYPE_STRING,
                    MS_RSA_TYPE,
                    TRUE,
#ifdef STRONG
                    FALSE
#else
                    FALSE
#endif // STRONG
                    ))
    {
        dwErr = E_UNEXPECTED;
        goto Ret;
    }

#ifdef STRONG
	//
	// install the RSA domestic provider (diff from enhanced because set as default)
	// Type 001
	//
    if (!SetCSPInfo(
                    MS_STRONG_PROV,
                    szImagePath,
                    NULL,
                    0,
                    PROV_RSA_FULL,
                    RSAFULL_TYPE_STRING,
                    MS_RSA_TYPE,
                    TRUE,
                    TRUE
                    ))
    {
        dwErr = E_UNEXPECTED;
        goto Ret;
    }
#endif // STRONG

	//
	// install the default RSA SChannel provider
	// Type 012
	//
    if (!SetCSPInfo(
                    MS_DEF_RSA_SCHANNEL_PROV,
                    szImagePath,
                    NULL,
                    0,
                    PROV_RSA_SCHANNEL,
                    RSA_SCH_TYPE_STRING,
                    MS_RSA_SCH_TYPE,
                    TRUE,
                    TRUE))
    {
        dwErr = E_UNEXPECTED;
        goto Ret;
    }
Ret:
    return dwErr;
}

DWORD
DllRegisterServer(void)
{
    DWORD dwErr = 0;

//    if (0 != (dwErr = SetMachineGUID()))
//        return dwErr;

    return NT5RegisterServer();
}

STDAPI DllUnregisterServer(void)
{
    return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\rsabase\mac.h ===
// Message Authentication Code structures

typedef struct _MACstate {
	DWORD		dwBufLen;
	HCRYPTKEY	hKey;
	BYTE		Feedback[CRYPT_BLKLEN];
	BYTE		Buffer[CRYPT_BLKLEN];
        BOOL            FinishFlag;
} MACstate;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\rsabase\ntagimp1.c ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ntagimp1.c                                             //
//  DESCRIPTION   : Contains routines for internal consumption             //
//                                                                         //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//  Jan 25 1995 larrys   Changed from Nametag                              //
//  Mar 23 1995 larrys   Added variable key length                         //
//  Jul  6 1995 larrys   Memory leak fix                                   //
//  Oct 27 1995 rajeshk  RandSeed Stuff                                    //
//  Nov  3 1995 larrys   Merge for NT checkin                              //
//  Dec 11 1995 larrys   Added WIN96 password cache                        //
//  Dec 13 1995 larrys   Removed MTS stuff                                 //
//  May 15 1996 larrys  Changed NTE_NO_MEMORY to ERROR_NOT_ENOUGHT...      //
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "nt_rsa.h"
#include "nt_blobs.h"
#include "winperf.h"

/*
#ifdef MTS						// Multi-Thread Safe
#ifndef STT
CRITICAL_SECTION	g_hRandLock;
#endif //STT
#endif

static unsigned char 	g_rgbStaticBits[A_SHA_DIGEST_LEN];
static DWORD 			g_dwRC4BytesUsed = RC4_REKEY_PARAM; 	// initially force rekey
static RC4_KEYSTRUCT 	g_rc4key;
static BOOL				g_fInitialized = FALSE;
*/

/*	Internal functions.  The following hash and sign routines are
	for use ONLY in internal consistency and protocol checks. */

void *IntBeginHash(void)
{
	MD5_CTX		*IntHash;

	if ((IntHash = (MD5_CTX *) _nt_malloc(sizeof(MD5_CTX))) == NULL)
		return NULL;

	MD5Init(IntHash);
	return (void *)IntHash;
}

void *IntUpdateHash(void *pHashCtx, BYTE *pData, DWORD dwDataLen)
{
	MD5Update((MD5_CTX *)pHashCtx, pData, dwDataLen);
	
	return pHashCtx;
}

void IntFinishHash(void *pHashCtx, BYTE *HashData)
{
	MD5Final((MD5_CTX *)pHashCtx);
	memcpy(HashData, ((MD5_CTX *)pHashCtx)->digest, NT_HASH_BYTES);
	_nt_free(pHashCtx, sizeof(MD5_CTX));
	
	return;
}

void memnuke(volatile BYTE *pData, DWORD dwLen)
{
	DWORD	i;

	for(i=0;i<dwLen;i++)
	{
	 	pData[i] = 0x00;
		pData[i] = 0xff;
		pData[i] = 0x00;
	}

	return;
}


/************************************************************************/
/* GenRandom generates a specified number of random bytes and places	*/
/* them into the specified buffer.										*/
/************************************************************************/
/*                                                                      */
/* Pseudocode logic flow:                                               */
/*                                                                      */
/* if (bits streamed > threshold)                                       */
/* {                                                                    */
/*  Gather_Bits()                                                       */
/*  SHAMix_Bits(User, Gathered, Static -> Static)                       */
/*  RC4Key(Static -> newRC4Key)                                         */
/*  SHABits(Static -> Static)      // hash after RC4 key generation     */
/*  SaveToRegistry(Static)                                              */
/* }                                                                    */
/* else                                                                 */
/* {                                                                    */
/*  SHAMix_Bits(User, Static -> Static)                                 */
/*  SaveToRegistry(Static)                                              */
/* }                                                                    */
/*                                                                      */
/* RC4(newRC4Key -> outbuf)                                             */
/* bits streamed += sizeof(outbuf)                                      */
/*                                                                      */
/************************************************************************/
/*

BOOL				// Keep as BOOL for the future
GenRandom (HCRYPTPROV hUID, BYTE *pbBuffer, size_t dwLength)
{
    DWORD           dwBytesThisPass;
    DWORD           dwFilledBytes = 0;
    PNTAGUserList   pTmpUser; // Rajesh added 10/27

    if (0 != hUID)
	{
	    if ((pTmpUser = (PNTAGUserList) NTLCheckList (hUID, USER_HANDLE)) == NULL)
	    {
	        SetLastError((DWORD) NTE_BAD_UID);
	        return NTF_FAILED;
	    }
		if (0 == pTmpUser->RandSeedLen)
		{
			pTmpUser->RandSeedLen = A_SHA_DIGEST_LEN;
			if ((pTmpUser->pbRandSeed = (BYTE *) _nt_malloc(A_SHA_DIGEST_LEN)) == NULL)
		    {
				SetLastError(ERROR_NOT_ENOUGH_MEMORY);
				return NTF_FAILED;
		    }
		}
	}

	// break request into chunks that we rekey between
	while(dwFilledBytes < dwLength)
	{
		dwBytesThisPass = dwLength - dwFilledBytes;

		RandomFillBuffer(pTmpUser->pbRandSeed,
                         pTmpUser->RandSeeLen,
                         pbBuffer + dwFilledBytes,
                         &dwBytesThisPass);
		dwFilledBytes += dwBytesThisPass;
	}

	return TRUE;
}


BOOL RandomFillBuffer(
                      IN OUT PBYTE pbRandSeed,
                      IN DWORD cbRandSeed,
                      BYTE *pbBuffer,
                      DWORD *pdwLength
                      )
{
	// Variables from loading and storing the registry...
	HKEY	phKeys;
	DWORD	cbDataLen;

	cbDataLen = A_SHA_DIGEST_LEN;

	if (g_dwRC4BytesUsed >= RC4_REKEY_PARAM)
	{
		// if we need to rekey

		RandContext		randContext;
		randContext.dwBitsFilled = 0;

		memcpy(g_rgbStaticBits, pbRandSeed, cbRandSeed);

		GatherRandomBits(&randContext);

		// Mix all bits
		{
			A_SHA_CTX SHACtx;
			A_SHAInit(&SHACtx); 

			// SHA the static bits 
			A_SHAUpdate(&SHACtx, g_rgbStaticBits, A_SHA_DIGEST_LEN);

			// SHA the gathered bits
			A_SHAUpdate(&SHACtx, randContext.rgbBitBuffer, randContext.dwBitsFilled);

			// SHA the user-supplied bits
			A_SHAUpdate(&SHACtx, pbBuffer, *pdwLength);

			// output back out to static bits
			A_SHAFinal(&SHACtx, g_rgbStaticBits);
		}

		// Create RC4 key
		g_dwRC4BytesUsed = 0;
		rc4_key(&g_rc4key, A_SHA_DIGEST_LEN, g_rgbStaticBits);

		// Mix RC4 key bits around
		{
			A_SHA_CTX SHACtx;
			A_SHAInit(&SHACtx); 

			// SHA the static bits 
			A_SHAUpdate(&SHACtx, g_rgbStaticBits, A_SHA_DIGEST_LEN);

			// output back out to static bits
			A_SHAFinal(&SHACtx, g_rgbStaticBits);
		}
				
	}
	else
	{
		// Use current RC4 key, but capture any user-supplied bits.

		// Mix input bits
		{
			A_SHA_CTX SHACtx;
			A_SHAInit(&SHACtx); 

			// SHA the static bits 
			A_SHAUpdate(&SHACtx, g_rgbStaticBits, A_SHA_DIGEST_LEN);

			// SHA the user-supplied bits
			A_SHAUpdate(&SHACtx, pbBuffer, *pdwLength);

			// output back out to static bits
			A_SHAFinal(&SHACtx, g_rgbStaticBits);
		}
		
	}

	memcpy(pbRandSeed, g_rgbStaticBits, cbRandSeed);
	
	// only use RC4_REKEY_PARAM bytes from each RC4 key 
	{
		DWORD dwMaxPossibleBytes = RC4_REKEY_PARAM - g_dwRC4BytesUsed;
		if (*pdwLength > dwMaxPossibleBytes)
			*pdwLength = dwMaxPossibleBytes;
	}

	memset(pbBuffer, 0, *pdwLength);
	rc4(&g_rc4key, *pdwLength, pbBuffer);

	g_dwRC4BytesUsed += *pdwLength;

	return TRUE;
}

void GatherRandomBits(RandContext *prandContext)
{
	DWORD 			dwTmp;
	WORD			wTmp;
	BYTE			bTmp;
	
	// ** indicates US DoD's specific recommendations for password generation 

	// proc id
	dwTmp = GetCurrentProcessId();	
	AppendRand(prandContext, &dwTmp, sizeof(dwTmp));
	
	// thread id
	dwTmp = GetCurrentThreadId();
	AppendRand(prandContext, &dwTmp, sizeof(dwTmp));

	// ** ticks since boot (system clock)
	dwTmp = GetTickCount();
	AppendRand(prandContext, &dwTmp, sizeof(dwTmp));

	// cursor position
	{
		POINT  			point;
		GetCursorPos(&point);
		bTmp = LOBYTE(point.x) ^ HIBYTE(point.x);
		AppendRand(prandContext, &bTmp, sizeof(BYTE));
		bTmp = LOBYTE(point.y) ^ HIBYTE(point.y);
		AppendRand(prandContext, &bTmp, sizeof(BYTE));
	}

	// ** system time, in ms, sec, min (date & time)
  	{
	  	SYSTEMTIME		sysTime;
		GetLocalTime(&sysTime);
		AppendRand(prandContext, &sysTime.wMilliseconds, sizeof(sysTime.wMilliseconds));
		bTmp = LOBYTE(sysTime.wSecond) ^ LOBYTE(sysTime.wMinute);
		AppendRand(prandContext, &bTmp, sizeof(BYTE));
	}
		
	// ** hi-res performance counter (system counters)
	{
		LARGE_INTEGER	liPerfCount;
		if (QueryPerformanceCounter(&liPerfCount))
		{
			bTmp = LOBYTE(LOWORD(liPerfCount.LowPart)) ^ LOBYTE(LOWORD(liPerfCount.HighPart));
			AppendRand(prandContext, &bTmp, sizeof(BYTE));
			bTmp = HIBYTE(LOWORD(liPerfCount.LowPart)) ^ LOBYTE(LOWORD(liPerfCount.HighPart));
			AppendRand(prandContext, &bTmp, sizeof(BYTE));
			bTmp = LOBYTE(HIWORD(liPerfCount.LowPart)) ^ LOBYTE(LOWORD(liPerfCount.HighPart));
			AppendRand(prandContext, &bTmp, sizeof(BYTE));
			bTmp = HIBYTE(HIWORD(liPerfCount.LowPart)) ^ LOBYTE(LOWORD(liPerfCount.HighPart));
			AppendRand(prandContext, &bTmp, sizeof(BYTE));
		}
	}

	// memory status
	{
		MEMORYSTATUS	mstMemStat;
		mstMemStat.dwLength = sizeof(MEMORYSTATUS);	// must-do
		GlobalMemoryStatus(&mstMemStat);
		wTmp = HIWORD(mstMemStat.dwAvailPhys); 		// low words seem to be always zero
		AppendRand(prandContext, &wTmp, sizeof(WORD));
		wTmp = HIWORD(mstMemStat.dwAvailPageFile);
		AppendRand(prandContext, &wTmp, sizeof(WORD));
		bTmp = LOBYTE(HIWORD(mstMemStat.dwAvailVirtual));
		AppendRand(prandContext, &bTmp, sizeof(BYTE));
	}
	
	// free disk clusters
	{	
		DWORD dwSectorsPerCluster, dwBytesPerSector, dwNumberOfFreeClusters, dwTotalNumberOfClusters;
	 	if (GetDiskFreeSpace(NULL, &dwSectorsPerCluster, &dwBytesPerSector,	&dwNumberOfFreeClusters, &dwTotalNumberOfClusters))
		{
			AppendRand(prandContext, &dwNumberOfFreeClusters, sizeof(dwNumberOfFreeClusters));
			AppendRand(prandContext, &dwTotalNumberOfClusters, sizeof(dwTotalNumberOfClusters));
			AppendRand(prandContext, &dwBytesPerSector, sizeof(dwBytesPerSector));
		}
	}

	// last messages' timestamp
	{
		LONG lTime;
		lTime = GetMessageTime();
		AppendRand(prandContext, &lTime, sizeof(lTime));
	}

	{
		// **SystemID
		DWORD dwSize = MAX_COMPUTERNAME_LENGTH + 1;
		char lpBuf [MAX_COMPUTERNAME_LENGTH + 1];
	
		if (GetComputerName(lpBuf, &dwSize))
		{
			// dwSize = len not including null termination
			AppendRand(prandContext, lpBuf, dwSize);
		}
		
		dwSize = MAX_COMPUTERNAME_LENGTH + 1;
   		
		// **UserID
		if (GetUserName(lpBuf, &dwSize))
		{
			// dwSize = len including null termination
			dwSize -= 1;
			AppendRand(prandContext, lpBuf, dwSize);
		}
   	}
}


void AppendRand(RandContext* prandContext, void* pv, DWORD dwSize)
{
	DWORD dwBitsLeft = (RAND_CTXT_LEN - prandContext->dwBitsFilled);

	if (dwBitsLeft > 0)
	{
		if (dwSize > dwBitsLeft)
			dwSize = dwBitsLeft;

		memcpy(prandContext->rgbBitBuffer + prandContext->dwBitsFilled, pv, dwSize);
		prandContext->dwBitsFilled += dwSize;
	}
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\rsabase\ntagum.c ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ntagum.c                                               //
//  DESCRIPTION   : Crypto CP interfaces:                                  //
//                  CPAcquireContext                                       //
//                  CPReleaseContext                                       //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//	Jan 25 1995 larrys  Changed from Nametag                               //
//      Feb 16 1995 larrys  Fix problem for 944 build                      //
//      Feb 23 1995 larrys  Changed NTag_SetLastError to SetLastError      //
//      Mar 23 1995 larrys  Added variable key length                      //
//      Apr 19 1995 larrys  Cleanup                                        //
//      May  9 1995 larrys  Removed warnings                               //
//      May 10 1995 larrys  added private api calls                        //
//      Jul 19 1995 larrys  Changed registry location                      //
//      Aug 09 1995 larrys  Changed error code                             //
//      Aug 31 1995 larrys  Fixed bug 27 CryptAcquireContext               //
//      Sep 12 1995 Jeffspel/ramas  Merged STT code into scp               //
//      Oct 02 1995 larrys  Fixed bug 27 return error NTE_BAD_KEYSET       //
//      Oct 13 1995 larrys  Added verify only context                      //
//      Oct 23 1995 larrys  Added GetProvParam stuff                       //
//      Nov  2 1995 larrys  Fixed bug 41                                   //
//      Oct 27 1995 rajeshk Added RandSeed stuff                           //
//      Nov  3 1995 larrys  Merged for NT checkin                          //
//      Nov  8 1995 larrys  Fixed SUR bug 10769                            //
//      Nov 13 1995 larrys  Fixed memory leak                              //
//      Nov 30 1995 larrys  Bug fix                                        //
//      Dec 11 1995 larrys  Added WIN96 password cache                     //
//      Dec 13 1995 larrys  Changed random number update                   //
//      Mar 01 1996 rajeshk Fixed the stomp bug                            //
//      May 15 1996 larrys  Added private key export                       //
//      May 28 1996 larrys  Fix bug in cache code                          //
//      Jun 11 1996 larrys  Added NT encryption of registry keys           //
//      Sep 13 1996 mattt   Varlen salt, 40-bit RC4 key storage, interop   //
//      Oct 14 1996 jeffspel Changed GenRandom to NewGenRandom             //
//      May 23 1997 jeffspel Added provider type checking                  //
//      Jun 18 1997 jeffspel Check if process is LocalSystem               //
//                                                                         //
//  Copyright (C) 1993, 1999 Microsoft Corporation   All Rights Reserved   //
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <xwinreg.h>
#include <stdio.h>
#include <stdlib.h>
#include "shacomm.h"
#include "nt_rsa.h"
#include "randlib.h"
#include "ntagum.h"
#include "protstor.h"
#include "ntagimp1.h"
#include "contman.h"
#include "swnt_pk.h"

extern void FreeUserRec(PNTAGUserList pUser);
extern CSP_STRINGS g_Strings;


#define NTAG_DEF_MACH_CONT_NAME "DefaultKeys"
#define NTAG_DEF_MACH_CONT_NAME_LEN sizeof(NTAG_DEF_MACH_CONT_NAME)

#define PSKEYS      "PSKEYS"

PNTAGKeyList MakeNewKey(
        ALG_ID      aiKeyAlg,
        DWORD       dwRights,
        DWORD       dwKeyLen,
        HCRYPTPROV  hUID,
        BYTE        *pbKeyData,
        BOOL        fUsePassedKeyBuffer
    );

void FreeNewKey(PNTAGKeyList pOldKey);

BOOL CPCreateHash(IN HCRYPTPROV hUID,
                  IN ALG_ID Algid,
                  IN HCRYPTKEY hKey,
                  IN DWORD dwFlags,
                  OUT HCRYPTHASH *phHash);

BOOL CPHashData(IN HCRYPTPROV hUID,
                IN HCRYPTHASH hHash,
                IN CONST BYTE *pbData,
                IN DWORD dwDataLen,
                IN DWORD dwFlags);

BOOL CPSetHashParam(IN HCRYPTPROV hUID,
                    IN HCRYPTHASH hHash,
                    IN DWORD dwParam,
                    IN BYTE *pbData,
                    IN DWORD dwFlags);

BOOL CPGetHashParam(IN HCRYPTPROV hUID,
                    IN HCRYPTHASH hHash,
                    IN DWORD dwParam,
                    IN BYTE *pbData,
                    IN DWORD *pwDataLen,
                    IN DWORD dwFlags);

BOOL CPDestroyHash(IN HCRYPTPROV hUID,
                   IN HCRYPTHASH hHash);


BOOL ReadRegValue(
                  HKEY hLoc,
                  char *pszName,
                  BYTE **ppbData,
                  DWORD *pcbLen,
                  BOOL fAlloc
                  )
{
    BOOL    fRet = NTF_FAILED;

    if (fAlloc)
    {
        *pcbLen = 0;
        *ppbData = NULL;

        // Need to get the size of the value first
        if (RegQueryValueEx(hLoc, pszName, 0, NULL, NULL,
	                        pcbLen) != ERROR_SUCCESS)
        {
            fRet = NTF_SUCCEED;
            goto Ret;
        }

        if (*pcbLen == 0)
        {
            fRet = NTF_SUCCEED;
            goto Ret;
        }

        if ((*ppbData = (BYTE *) _nt_malloc(*pcbLen)) == NULL)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }
    }

    // Now get the key
    if (RegQueryValueEx(hLoc, pszName, 0, NULL, (BYTE *) *ppbData,
	                    pcbLen) != ERROR_SUCCESS)
    {
        SetLastError((DWORD) NTE_SYS_ERR);
        goto Ret;
    }

    fRet = NTF_SUCCEED;
Ret:
    if (NTF_FAILED == fRet)
    {
        if (fAlloc)
        {
            if (*ppbData)
                _nt_free(*ppbData, *pcbLen);
            ppbData = NULL;
        }
    }
    return fRet;
}

void CheckForStorageType(
                         HKEY hRegKey,
                         DWORD *pdwProtStor
                         )
{
    BYTE    **ppb = (BYTE**)(&pdwProtStor);
    DWORD   cb = sizeof(DWORD);

    if (hRegKey)
    {
        if (!ReadRegValue(hRegKey, PSKEYS, ppb, &cb, FALSE))
        {
            *pdwProtStor = 0;
        }
        // BUGBUG - this is done because the value of PROTECTION_API_KEYS was
        // mistakenly also used in IE 5 on Win9x for a key format in the
        // registry where the public keys were not encrypted.
        if (PROTECTION_API_KEYS == *pdwProtStor)
        {
            *pdwProtStor = PROTECTED_STORAGE_KEYS;
        }
    }
    else
    {
        *pdwProtStor = PROTECTION_API_KEYS;
    }
}



BOOL OpenUserReg(
                 LPSTR pszUserName,
                 DWORD dwProvType,
                 DWORD dwFlags,
                 BOOL fUserKeys,
                 HKEY *phRegKey,
                 DWORD *pdwOldKeyFlags
                 )
{
    HKEY        hTopRegKey = 0;
    TCHAR       *pszLocbuf = NULL;
    DWORD       cbLocBuf;
    long        lsyserr;
    DWORD       dwResult;
    BOOL        fLeaveOldKeys = FALSE;
    BOOL        fStatus = FALSE;
    DWORD       fRet = FALSE;

    cbLocBuf = AllocAndSetLocationBuff(dwFlags & CRYPT_MACHINE_KEYSET,
                                       dwProvType,
                                       pszUserName,
                                       &hTopRegKey,
                                       &pszLocbuf,
                                       fUserKeys,
                                       &fLeaveOldKeys);

    if (!cbLocBuf)
    {
        goto Ret;
    }
    if (fLeaveOldKeys)
    {
        *pdwOldKeyFlags |= LEAVE_OLD_KEYS;
    }

    // try to open the old storage location
    fStatus = OpenRegKeyWithTokenPriviledges(hTopRegKey,
                                             pszLocbuf,
                                             phRegKey,
                                             pdwOldKeyFlags);

    if (dwFlags & CRYPT_NEWKEYSET)
    {
        if (fStatus)
        {
            RegCloseKey(*phRegKey);
            *phRegKey = 0;
            goto Ret;
        }
    }
    else
    {
        if (!fStatus)
        {
            goto Ret;
        }
    }

    fRet = TRUE;
Ret:
    if (hTopRegKey && (HKEY_CURRENT_USER != hTopRegKey) &&
        (HKEY_LOCAL_MACHINE != hTopRegKey))
    {
        RegCloseKey(hTopRegKey);
    }
    if (pszLocbuf)
        _nt_free(pszLocbuf, cbLocBuf);

    return fRet;
}

DWORD OpenUserKeyGroup(
                       PNTAGUserList pTmpUser,
                       LPSTR szUserName,
                       DWORD dwFlags,
                       BOOL fUserKeys
                       )
{
    BOOL        fMachineKeyset;
    DWORD       dwErr = 0;

    fMachineKeyset = dwFlags & CRYPT_MACHINE_KEYSET;

    dwErr = ReadContainerInfo(pTmpUser->dwProvType,
                              szUserName,
                              fMachineKeyset,
                              dwFlags,
                              &pTmpUser->ContInfo);

    if (CRYPT_NEWKEYSET & dwFlags)
    {
        if (NTE_BAD_KEYSET != dwErr)
        {
            if (0 == dwErr)
            {
                dwErr = (DWORD)NTE_EXISTS;
            }
            goto Ret;
        }
        else
        {
            // allocate space for the container/user name
            if (0 != (dwErr = SetContainerUserName(szUserName,
                                                   &pTmpUser->ContInfo)))
            {
                goto Ret;
            }

            if (!OpenUserReg(pTmpUser->ContInfo.pszUserName,
                             pTmpUser->dwProvType,dwFlags,
                             FALSE,
                             &pTmpUser->hKeys,
                             &pTmpUser->dwOldKeyFlags))
            {
                dwErr = NTE_EXISTS;
                goto Ret;
            }

            // no key set so create one
            if (0 == pTmpUser->hKeys)
            {
                // if the is for user key then make sure that Data Protection API
                // works so a container isn't created which can't be used to store keys
                if (!fMachineKeyset)
                {
                    if (0 != (dwErr = TryDPAPI()))
                    {
                        goto Ret;
                    }
                }

                pTmpUser->dwKeyStorageType = PROTECTION_API_KEYS;
                if (0 != (dwErr = WriteContainerInfo(pTmpUser->dwProvType,
                                 pTmpUser->ContInfo.rgwszFileName,
                                 fMachineKeyset,
                                 &pTmpUser->ContInfo)))
                {
                    goto Ret;
                }
            }
        }
    }
    else
    {
        if (0 == dwErr)
        {
            pTmpUser->dwKeyStorageType = PROTECTION_API_KEYS;
        }
        else
        {
            if (!OpenUserReg(szUserName,
                             pTmpUser->dwProvType,
                             dwFlags,
                             FALSE,
                             &pTmpUser->hKeys,
                             &pTmpUser->dwOldKeyFlags))
            {
                goto Ret;
            }

            // migrating keys need to set the user name
            if (0 != (dwErr = SetContainerUserName(szUserName,
                                                   &pTmpUser->ContInfo)))
            {
                goto Ret;
            }
            dwErr = 0;
        }
    }
Ret:
    return dwErr;
}

BOOL DeleteOldUserKeyGroup(
                           CONST char *pszUserID,
                           DWORD dwProvType,
                           DWORD dwFlags
                           )
{
    HKEY        hTopRegKey = 0;
    TCHAR       *locbuf = NULL;
    DWORD       dwLocBuffLen;
    long        lsyserr;
    HKEY        hRegKey = 0;
    BOOL        fProtStor;
    BOOL        fMachineKeySet = FALSE;
    DWORD       dwStorageType;
    BOOL        fLeaveOldKeys = FALSE;
    BOOL        fRet = NTF_FAILED;

    // Copy the location of the key groups, append the userID to it
    if (dwFlags & CRYPT_MACHINE_KEYSET)
        fMachineKeySet = TRUE;

    dwLocBuffLen = AllocAndSetLocationBuff(fMachineKeySet,
                                           dwProvType,
                                           pszUserID,
                                           &hTopRegKey,
                                           &locbuf,
                                           FALSE,
                                           &fLeaveOldKeys);
    if (!dwLocBuffLen)
        goto Ret;

    // open it for all access so we can save later, if necessary
    if (ERROR_SUCCESS != MyRegOpenKeyEx(hTopRegKey,
                                        locbuf,
                                        0,
                                        KEY_ALL_ACCESS,
                                        &hRegKey))
    {
        SetLastError((DWORD)NTE_BAD_KEYSET);
        goto Ret;
    }

    CheckForStorageType(hRegKey, &dwStorageType);

    if (PROTECTED_STORAGE_KEYS == dwStorageType)
    {
        if (!DeleteFromProtectedStorage(pszUserID, &g_Strings, hRegKey,
                                        fMachineKeySet))
        {
            goto Ret;
        }
    }

    lsyserr = MyRegDeleteKey(hTopRegKey, locbuf);

    if (lsyserr != ERROR_SUCCESS)
    {
        SetLastError((DWORD) NTE_BAD_KEYSET);
        goto Ret;
    }

    fRet = NTF_SUCCEED;
Ret:
    if (hTopRegKey && (HKEY_CURRENT_USER != hTopRegKey) &&
        (HKEY_LOCAL_MACHINE != hTopRegKey))
    {
        RegCloseKey(hTopRegKey);
    }
    if (hRegKey)
        RegCloseKey(hRegKey);
    if (locbuf)
        _nt_free(locbuf, dwLocBuffLen);
    return fRet;
}

BOOL DeleteUserKeyGroup(
                        LPSTR pszUserName,
                        DWORD dwProvType,
                        DWORD dwFlags
                        )
{
    BOOL    fRet = FALSE;

    if (0 != DeleteContainerInfo(dwProvType,
                                 pszUserName,
                                 dwFlags & CRYPT_MACHINE_KEYSET))
    {
        if (!DeleteOldUserKeyGroup(pszUserName, dwProvType, dwFlags))
            goto Ret;
    }
    fRet = TRUE;
Ret:
    return fRet;
}


// read the exportability flag for the private key from the registry
void ReadPrivateKeyExportability(IN PNTAGUserList pUser,
                                 IN BOOL fExchange)
{
    DWORD dwType;
    DWORD cb = 1;
    BYTE b;
    BOOL *pf;

    if (fExchange)
    {
        pf = &pUser->ContInfo.fExchExportable;
        if (ERROR_SUCCESS != RegQueryValueEx(pUser->hKeys, "EExport", NULL,
                                             &dwType, &b, &cb))
            return;
    }
    else
    {
        pf = &pUser->ContInfo.fSigExportable;
        if (ERROR_SUCCESS != RegQueryValueEx(pUser->hKeys, "SExport", NULL,
                                             &dwType, &b, &cb))
            return;
    }
	
    if ((sizeof(b) == cb) && (0x01 == b))
        *pf = TRUE;
}

BOOL ReadKey(
             HKEY hLoc,
             char *pszName,
             BYTE **ppbData,
             DWORD *pcbLen,
             PNTAGUserList pUser,
             HCRYPTKEY hKey,
             BOOL *pfPrivKey,
             BOOL fKeyExKey,
             BOOL fLastKey
             )
{
    DWORD                       dwTemp;
    BOOL                        rt;
    CHAR                        *pch;
    CRYPTPROTECT_PROMPTSTRUCT   PromptStruct;
    CRYPT_DATA_BLOB             DataIn;
    CRYPT_DATA_BLOB             DataOut;
    BOOL                        fRet = NTF_FAILED;

    memset(&DataIn, 0, sizeof(DataIn));
    memset(&DataOut, 0, sizeof(DataOut));
    memset(&PromptStruct, 0, sizeof(PromptStruct));

    if (NTF_SUCCEED != ReadRegValue(hLoc, pszName, ppbData, pcbLen, TRUE))
        goto Ret;

    if (*ppbData)
    {
        if ((REG_KEYS == pUser->dwKeyStorageType) && *pfPrivKey)
        {
            ReadPrivateKeyExportability(pUser, fKeyExKey);
        }

        if ((REG_KEYS == pUser->dwKeyStorageType) ||
            (PROTECTED_STORAGE_KEYS == pUser->dwKeyStorageType))
        {
            if (hKey != 0)
            {
                dwTemp = *pcbLen;
                rt = LocalDecrypt(pUser->hUID, hKey, 0, fLastKey, 0,
                                  *ppbData, &dwTemp, FALSE);
            }
        }

        pch = *ppbData;
        if ((strcmp(pszName, "RandSeed") != 0) &&
            (pch[0] != 'R' ||
             pch[1] != 'S' ||
             pch[2] != 'A'))
        {
            if (!*pfPrivKey)  // this may be a Win9x public key
            {
                *pfPrivKey = TRUE;
            }
            else
            {
                SetLastError((DWORD) NTE_KEYSET_ENTRY_BAD);
                goto Ret;
            }
        }
    }
    fRet = NTF_SUCCEED;
Ret:
    // free the DataOut struct if necessary
    if (DataOut.pbData)
        LocalFree(DataOut.pbData);

    return fRet;
}

//
// Routine : MigrateProtectedStorageKeys
//
// Description : Try and retrieve both the sig and exch private keys and
//               migrate them to the protection APIs and then delete the keys
//               from the protected storage.  The fSigPubKey and fExchPubKey
//               parameters indicate the public keys should be derived from
//               the private keys.
//

BOOL MigrateProtectedStorageKeys(
                                 IN PNTAGUserList pUser,
                                 IN LPWSTR szPrompt,
                                 IN BOOL fSigPubKey,
                                 IN BOOL fExchPubKey
                                 )
{
    BOOL    fMachineKeySet = FALSE;
    DWORD   dwFlags = 0;
    DWORD   dwSigFlags = 0;
    DWORD   dwExchFlags = 0;
    BOOL    fUIOnSigKey = FALSE;
    BOOL    fUIOnExchKey = FALSE;
    DWORD   dwErr = 0;
    BOOL    fRet = FALSE;

    __try
    {
        if (CRYPT_MACHINE_KEYSET & pUser->Rights)
        {
            fMachineKeySet = TRUE;
        }

        // NOTE - the appropriate exportable flag is set by
        // RestoreKeysetFromProtectedStorage
        if (pUser->ContInfo.ContLens.cbSigPub || fSigPubKey)
        {
            if (!RestoreKeysetFromProtectedStorage(pUser, szPrompt,
                    &pUser->pSigPrivKey, &pUser->SigPrivLen,
                    TRUE, fMachineKeySet,
                    &fUIOnSigKey))
            {
                goto Ret;
            }

            // check if the sig key is there and the public key is supposed to
            // be derived from it
            if (fSigPubKey)
            {
                if (!DerivePublicFromPrivate(pUser, TRUE))
                {
                    goto Ret;
                }
            }
        }

        // open the other key (sig or exch) and store
        if (pUser->ContInfo.ContLens.cbExchPub || fExchPubKey)
        {
            if (!RestoreKeysetFromProtectedStorage(pUser, szPrompt,
                    &pUser->pExchPrivKey, &pUser->ExchPrivLen,
                    FALSE, fMachineKeySet,
                    &fUIOnExchKey))
            {
                goto Ret;
            }

            // check if the sig key is there and the public key is supposed to
            // be derived from it
            if (fExchPubKey)
            {
                if (!DerivePublicFromPrivate(pUser, FALSE))
                {
                    goto Ret;
                }
            }
        }

        // set UI flags if necessary
        if (fUIOnSigKey)
        {
            dwSigFlags = CRYPT_USER_PROTECTED;
        }
        if (fUIOnExchKey)
        {
            dwExchFlags = CRYPT_USER_PROTECTED;
        }

        if ((NULL == pUser->pSigPrivKey) &&
            (NULL == pUser->pExchPrivKey))
        {
            pUser->dwKeyStorageType = PROTECTION_API_KEYS;
            if (0 != (dwErr = WriteContainerInfo(pUser->dwProvType,
                             pUser->ContInfo.rgwszFileName,
                             fMachineKeySet,
                             &pUser->ContInfo)))
            {
                goto Ret;
            }
        }
        else
        {
            // migrate the keys to the protection APIs
            if (pUser->pSigPrivKey)
            {
                if (!ProtectPrivKey(pUser, g_Strings.pwszMigrKeys,
                                    dwSigFlags, TRUE))
                {
                    goto Ret;
                }

                // delete the sig key from the protected storage
                DeleteKeyFromProtectedStorage(pUser, &g_Strings, AT_SIGNATURE,
                                              fMachineKeySet, TRUE);
            }
            if (pUser->pExchPrivKey)
            {
                if (!ProtectPrivKey(pUser, g_Strings.pwszMigrKeys,
                                    dwExchFlags, FALSE))
                {
                    goto Ret;
                }

                // delete the key exchange key from the protected storage
                DeleteKeyFromProtectedStorage(pUser, &g_Strings, AT_KEYEXCHANGE,
                                              fMachineKeySet, TRUE);
            }
        }

        pUser->dwKeyStorageType = PROTECTION_API_KEYS;

        RegCloseKey(pUser->hKeys);
        pUser->hKeys = 0;

        if (pUser->Rights & CRYPT_MACHINE_KEYSET)
            dwFlags = CRYPT_MACHINE_KEYSET;

        // delete the registry key
        if (!DeleteOldUserKeyGroup(pUser->ContInfo.pszUserName,
                                   pUser->dwProvType,
                                   dwFlags))
        {
            goto Ret;
        }

        fRet = TRUE;
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    return fRet;
}


//
// Routine : ProtectPrivKey
//
// Description : Encrypts the private key and persistently stores it.
//

BOOL ProtectPrivKey(
                    IN OUT PNTAGUserList pTmpUser,
                    IN LPWSTR szPrompt,
                    IN DWORD dwFlags,
                    IN BOOL fSigKey
                    )
{
    BYTE                        *pbKey;
    DWORD                       cbKey;
    BYTE                        **ppbEncKey;
    DWORD                       *pcbEncKey;
    BYTE                        *pbTmpEncKey = NULL;
    CRYPT_DATA_BLOB             DataIn;
    CRYPT_DATA_BLOB             DataOut;
    CRYPTPROTECT_PROMPTSTRUCT   PromptStruct;
    DWORD                       dwProtectFlags = 0;
    DWORD                       dwErr = 0;
    BOOL                        fRet = NTF_FAILED;

    memset(&DataIn, 0, sizeof(DataIn));
    memset(&DataOut, 0, sizeof(DataOut));
    memset(&PromptStruct, 0, sizeof(PromptStruct));

    // wrap with a try since there is a critical sections in here
    try
    {
        EnterCriticalSection(&pTmpUser->CritSec);

        if (fSigKey)
        {
            DataIn.cbData = pTmpUser->SigPrivLen;
            DataIn.pbData = pTmpUser->pSigPrivKey;
            ppbEncKey = &(pTmpUser->ContInfo.pbSigEncPriv);
            pcbEncKey = &(pTmpUser->ContInfo.ContLens.cbSigEncPriv);
        }
        else
        {
            DataIn.cbData = pTmpUser->ExchPrivLen;
            DataIn.pbData = pTmpUser->pExchPrivKey;
            ppbEncKey = &(pTmpUser->ContInfo.pbExchEncPriv);
            pcbEncKey = &(pTmpUser->ContInfo.ContLens.cbExchEncPriv);
        }

        //
        // Two checks (needed for FIPS) before offloading to the offload
        // module.
        //
        // First check is if the user protected flag was requested so
        // that UI is attached to the decryption of the key.
        //
        // Second check is if this is a user key or a machine key.
        //

        // protect the key with the data protection API
        PromptStruct.cbSize = sizeof(PromptStruct);
        if (CRYPT_USER_PROTECTED & dwFlags)
        {
            if (pTmpUser->ContInfo.fCryptSilent)
            {
                SetLastError((DWORD) NTE_SILENT_CONTEXT);
                goto Ret;
            }

            if (fSigKey)
            {
                pTmpUser->ContInfo.ContLens.dwUIOnKey |= AT_SIGNATURE;
            }
            else
            {
                pTmpUser->ContInfo.ContLens.dwUIOnKey |= AT_KEYEXCHANGE;
            }
            PromptStruct.dwPromptFlags = CRYPTPROTECT_PROMPT_ON_UNPROTECT |
                                         CRYPTPROTECT_PROMPT_ON_PROTECT;
        }
        if (szPrompt)
        {
            PromptStruct.hwndApp = pTmpUser->hWnd;
            if (pTmpUser->pwszPrompt)
                PromptStruct.szPrompt = pTmpUser->pwszPrompt;
            else
                PromptStruct.szPrompt = szPrompt;
        }
    
        // protect as machine data if necessary
        if (pTmpUser->Rights & CRYPT_MACHINE_KEYSET)
            dwProtectFlags = CRYPTPROTECT_LOCAL_MACHINE;

        if (!MyCryptProtectData(&DataIn, L"", NULL, NULL,
                                &PromptStruct, dwProtectFlags, &DataOut))
        {
            dwFlags = GetLastError();
            SetLastError((DWORD) NTE_FAIL);
            goto Ret;
        }
        if (NULL == (pbTmpEncKey = _nt_malloc(DataOut.cbData)))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }
        memcpy(pbTmpEncKey, DataOut.pbData, DataOut.cbData);
        if (*ppbEncKey)
        {
            _nt_free(*ppbEncKey, *pcbEncKey);
        }
        *pcbEncKey = DataOut.cbData;
        *ppbEncKey = pbTmpEncKey;

        // write out the key to the file
        if (0 != (dwErr = WriteContainerInfo(pTmpUser->dwProvType,
                             pTmpUser->ContInfo.rgwszFileName,
                             pTmpUser->Rights & CRYPT_MACHINE_KEYSET,
                             &pTmpUser->ContInfo)))
        {
            SetLastError(dwErr);
            goto Ret;
        }

        fRet = NTF_SUCCEED;
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    LeaveCriticalSection(&pTmpUser->CritSec);
    // free the DataOut struct if necessary
    if (DataOut.pbData)
        LocalFree(DataOut.pbData);

    return fRet;
}

//
// Routine : UnprotectPrivKey
//
// Description : Decrypts the private key.  If the fAlwaysDecrypt flag is set
//               then it checks if the private key is already in the buffer
//               and if so then it does not decrypt.
//

BOOL UnprotectPrivKey(
                      IN OUT PNTAGUserList pTmpUser,
                      IN LPWSTR szPrompt,
                      IN BOOL fSigKey,
                      IN BOOL fAlwaysDecrypt
                      )
{
    BYTE                        **ppbKey;
    DWORD                       *pcbKey;
    BYTE                        *pbEncKey;
    DWORD                       cbEncKey;
    BYTE                        *pbTmpKey = NULL;
    CRYPTPROTECT_PROMPTSTRUCT   PromptStruct;
    CRYPT_DATA_BLOB             DataIn;
    CRYPT_DATA_BLOB             DataOut;
    CHAR                        *pch;
    DWORD                       dwProtectFlags = 0;
    BOOL                        fInCritSec = FALSE;
    BOOL                        fRet = FALSE;

    memset(&DataOut, 0, sizeof(DataOut));

    if(!fAlwaysDecrypt)
    {
        //
        // avoid taking critical section if we aren't forced to cause
        // a re-decrypt (which is necessary when UI is forced).
        //

        if (fSigKey)
        {
            ppbKey = &(pTmpUser->pSigPrivKey);
        }
        else
        {
            ppbKey = &(pTmpUser->pExchPrivKey);
        }

        if(*ppbKey)
        {
            fRet = TRUE;
            goto Ret;
        }
    }

    // wrap with a try since there is a critical sections in here
    try
    {
        //
        // take critical section around reads and writes to the context
        // when it hasn't been initialized.  Also, the critical section is
        // taken when fAlwaysDecrypt is specified which prevents multiple
        // outstanding UI requests.
        //
        EnterCriticalSection(&pTmpUser->CritSec);
        fInCritSec = TRUE;

        if (fSigKey)
        {
            pcbKey = &(pTmpUser->SigPrivLen);
            ppbKey = &(pTmpUser->pSigPrivKey);
            pbEncKey = pTmpUser->ContInfo.pbSigEncPriv;
            cbEncKey = pTmpUser->ContInfo.ContLens.cbSigEncPriv;
        }
        else
        {
            pcbKey = &(pTmpUser->ExchPrivLen);
            ppbKey = &(pTmpUser->pExchPrivKey);
            pbEncKey = pTmpUser->ContInfo.pbExchEncPriv;
            cbEncKey = pTmpUser->ContInfo.ContLens.cbExchEncPriv;
        }

        if ((NULL == *ppbKey) || fAlwaysDecrypt)
        {
            memset(&DataIn, 0, sizeof(DataIn));
            memset(&PromptStruct, 0, sizeof(PromptStruct));

            if (pTmpUser->Rights & CRYPT_MACHINE_KEYSET)
                dwProtectFlags = CRYPTPROTECT_LOCAL_MACHINE;

            //  set up the prompt structure
            PromptStruct.cbSize = sizeof(PromptStruct);
            PromptStruct.hwndApp = pTmpUser->hWnd;
            PromptStruct.szPrompt = szPrompt;

            DataIn.cbData = cbEncKey;
            DataIn.pbData = pbEncKey;
            if (!MyCryptUnprotectData(&DataIn, NULL, NULL, NULL,
                                      &PromptStruct, dwProtectFlags, &DataOut))
            {
                SetLastError((DWORD)NTE_KEYSET_ENTRY_BAD);
                goto Ret;
            }

            pch = DataOut.pbData;
            if ((sizeof(DWORD) > DataOut.cbData) || pch[0] != 'R' ||
                pch[1] != 'S' || pch[2] != 'A')
            {
                SetLastError((DWORD) NTE_KEYSET_ENTRY_BAD);
                goto Ret;
            }

            if (NULL == *ppbKey)
            {
                if (NULL == (pbTmpKey = (BYTE*)_nt_malloc(DataOut.cbData)))
                {
                    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    goto Ret;
                }
                memcpy(pbTmpKey, DataOut.pbData, DataOut.cbData);

                // move the new key into the context
                if (*ppbKey)
                {
                    _nt_free(*ppbKey, *pcbKey);
                }
                *pcbKey = DataOut.cbData;
                *ppbKey = pbTmpKey;
            }
        }

        fRet = TRUE;
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fInCritSec)
    {
        LeaveCriticalSection(&pTmpUser->CritSec);
    }

    // free the DataOut struct if necessary
    if (DataOut.pbData)
    {
        ZeroMemory(DataOut.pbData, DataOut.cbData);
        LocalFree(DataOut.pbData);
    }

    return fRet;
}

BOOL LoadWin96Cache(
                    PNTAGUserList pTmpUser,
                    LPSTR szUserName,
                    DWORD dwFlags,
                    BOOL fLowerUserName
                    )
{
    HANDLE              handle = NULL;
    char                *szResource = NULL;
    char                *szLowerUserName = NULL;
    WORD                wcbRandom;
    DWORD               cbsize;
    FARPROC             CachePW;
    FARPROC             GetCachePW;
    BYTE                rgbRandom[STORAGE_RC4_KEYLEN];
    DWORD               rc;
    BOOL                fKey = FALSE;
    BYTE                HashData[MD5DIGESTLEN] = {0x70, 0xf2, 0x85, 0x1e, 
                                                  0x4e, 0x00, 0x00, 0x00,
                                                  0x00, 0x00, 0x00, 0x00,
                                                  0x00, 0x00, 0x00, 0x00};
    HCRYPTHASH          hHash;
    DWORD               dwDataLen = MD5DIGESTLEN;
    PNTAGHashList       pTmpHash;
    BOOL                fRet = FALSE;

#define PREFIX "crypt_"
#define CACHE "WNetCachePassword"
#define GET_CACHE "WNetGetCachedPassword"

    cbsize = strlen(szUserName) + strlen(PREFIX);

#ifndef _XBOX
    if (!FIsWinNT())
    {
        // Try to load MPR.DLL for WIN96 password cache
        if (NULL != (handle = LoadLibrary("MPR.DLL")))
        {
            if ((!(dwFlags & CRYPT_MACHINE_KEYSET)) &&
                (CachePW = GetProcAddress(handle, CACHE)) &&
                (GetCachePW = GetProcAddress(handle, GET_CACHE)))
            {
                if ((szResource = (char *) _nt_malloc(cbsize + 1)) == NULL)
                {
                    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    goto Ret;
                }

                strcpy(szResource, PREFIX);
                strcat(szResource, szUserName);

                wcbRandom = STORAGE_RC4_KEYLEN;
                if (((rc = GetCachePW(szResource, cbsize, rgbRandom, &wcbRandom, 6)) != NO_ERROR) ||
                     (wcbRandom != STORAGE_RC4_KEYLEN))
                {
                    if (rc == ERROR_NOT_SUPPORTED)
                    {
                        goto no_cache;
                    }

                    if (!FIPS186GenRandom(&pTmpUser->hRNGDriver,
                                           &pTmpUser->ContInfo.pbRandom,
                                           &pTmpUser->ContInfo.ContLens.cbRandom,
                                           rgbRandom, STORAGE_RC4_KEYLEN))
                    {
                        SetLastError((DWORD) NTE_FAIL);
                        goto Ret;
                    }

                    CachePW(szResource, cbsize, rgbRandom, STORAGE_RC4_KEYLEN, 6, 0);
                }

                fKey = TRUE;

                if ((pTmpUser->pCachePW=(char *)_nt_malloc(STORAGE_RC4_KEYLEN)) == NULL)
                {
                    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    goto Ret;
                }

                memcpy(pTmpUser->pCachePW, rgbRandom, STORAGE_RC4_KEYLEN);

            }
        }
    }
no_cache:
#endif // _XBOX

    if (!fKey)
    {
        if (RCRYPT_FAILED(CPCreateHash(pTmpUser->hUID,
                                       CALG_MD5,
                                       0,
                                       0,
                                       &hHash)))
        {
            SetLastError((DWORD) NTE_FAIL);
            goto Ret;
        }

        if (RCRYPT_FAILED(CPSetHashParam(pTmpUser->hUID,
                                         hHash,
                                         HP_HASHVAL,
                                         HashData,
                                         0)))
        {
            SetLastError((DWORD) NTE_FAIL);
            goto Ret;
        }

        if ((pTmpHash = (PNTAGHashList) NTLValidate(hHash, pTmpUser->hUID,
                                                    HASH_HANDLE)) == NULL)
        {
            SetLastError((DWORD) NTE_BAD_HASH);
            goto Ret;
        }

        pTmpHash->HashFlags &= ~HF_VALUE_SET;

        // make the user name lower case
        cbsize = lstrlen(szUserName) + sizeof(CHAR);
        if (NULL == (szLowerUserName = (char *) _nt_malloc(cbsize)))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }
        lstrcpy(szLowerUserName, szUserName);
        if (fLowerUserName)
            _strlwr(szLowerUserName);

        if (RCRYPT_FAILED(CPHashData(pTmpUser->hUID,
                                     hHash,
                                     szLowerUserName,
                                     lstrlen(szLowerUserName) + sizeof(CHAR),
                                     0)))
        {
            SetLastError((DWORD) NTE_FAIL);
            goto Ret;
        }

        if (RCRYPT_FAILED(CPGetHashParam(pTmpUser->hUID,
                                         hHash,
                                         HP_HASHVAL,
                                         HashData,
                                         &dwDataLen,
                                         0)))
        {
            SetLastError((DWORD) NTE_FAIL);
            goto Ret;
        }

        if (RCRYPT_FAILED(CPDestroyHash(pTmpUser->hUID,
                                        hHash)))
        {
            SetLastError((DWORD) NTE_FAIL);
            goto Ret;
        }

        if ((pTmpUser->pCachePW=(char *)_nt_malloc(STORAGE_RC4_KEYLEN)) == NULL)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        memcpy(pTmpUser->pCachePW, HashData, STORAGE_RC4_KEYLEN);

    }    

    fRet = TRUE;
Ret:
    if (szLowerUserName)
        _nt_free(szLowerUserName, cbsize);
    if (szResource)
        _nt_free(szResource, cbsize);
#ifndef _XBOX
    if (handle)
        FreeLibrary(handle);
#endif

    return fRet;

}

/*
 * Retrieve the security descriptor for a registry key
 */
BOOL GetRegKeySecDescr(
                       PNTAGUserList pUser,
                       HKEY hRegKey,
                       BYTE **ppbSecDescr,
                       DWORD *pcbSecDescr,
                       DWORD *pdwSecDescrFlags
                       )
{
    DWORD   cb = 0;
    DWORD   dwErr = 0;
    BOOL    fRet = FALSE;

    if (pUser->dwOldKeyFlags & PRIVILEDGE_FOR_SACL)
    {
        *pdwSecDescrFlags = SACL_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
                            DACL_SECURITY_INFORMATION;
    }
    else
    {
        *pdwSecDescrFlags = GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION;
    }

    // get the security descriptor for the hKey of the keyset
    if (ERROR_INSUFFICIENT_BUFFER !=
        (dwErr = RegGetKeySecurity(hRegKey,
                                     (SECURITY_INFORMATION)*pdwSecDescrFlags,
                                     &cb, &cb)))
    {
        SetLastError(dwErr);
        goto Ret;
    }

    if (NULL == (*ppbSecDescr = (BYTE*)_nt_malloc(cb)))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Ret;
    }

    if (dwErr = RegGetKeySecurity(hRegKey,
                                    (SECURITY_INFORMATION)*pdwSecDescrFlags,
                                    (PSECURITY_DESCRIPTOR)*ppbSecDescr,
                                    &cb))
    {
        SetLastError(dwErr);
        goto Ret;
    }

    *pcbSecDescr = cb;
    fRet = TRUE;
Ret:
    if ((FALSE == fRet) && *ppbSecDescr)
    {
        _nt_free(*ppbSecDescr, cb);
        *ppbSecDescr = NULL;
    }

    return fRet;
}

/*
 * Retrieve the keys from persistant storage
 *
 * NOTE: caller must have zeroed out pUser to allow for non-existent keys
 */
// MTS: Assumes the registry won't change between ReadKey calls.
BOOL RestoreUserKeys(
                     HKEY hKeys,
                     PNTAGUserList pUser,
                     char *User
                     )
{
    PNTAGKeyList        pTmpKey;
    HCRYPTKEY           hKey = 0;
    BYTE                rgbKeyBuffer[STORAGE_RC4_TOTALLEN];
    CRYPT_DATA_BLOB     sSaltData;
    DWORD               dwFlags = 0;
    BOOL                fMachineKeyset = FALSE;
    BYTE                *pbSecDescr = NULL;
    DWORD               cbSecDescr;
    DWORD               dwSecDescrFlags = 0;
    BOOL                fPrivKey;
    BOOL                fEPbk = FALSE;
    BOOL                fSPbk = FALSE;
    DWORD               dwErr = 0;
    BOOL                fRet = NTF_FAILED;


    if (pUser->pCachePW != NULL)
    {
        ZeroMemory(rgbKeyBuffer, STORAGE_RC4_TOTALLEN);
        CopyMemory(rgbKeyBuffer, pUser->pCachePW, STORAGE_RC4_KEYLEN);
        
        if ((pTmpKey = MakeNewKey(CALG_RC4, 0, STORAGE_RC4_KEYLEN, pUser->hUID,
                                  rgbKeyBuffer, FALSE)) != NULL)
        {
            if (NTLMakeItem(&hKey, KEY_HANDLE, (void *)pTmpKey) == NTF_FAILED)
            {
                FreeNewKey(pTmpKey);
                hKey = 0;
            }
        }

        // set zeroized salt for RSABase compatibility
        sSaltData.pbData = rgbKeyBuffer + STORAGE_RC4_KEYLEN;
        sSaltData.cbData = STORAGE_RC4_TOTALLEN - STORAGE_RC4_KEYLEN;
        if (!CPSetKeyParam(
                   pUser->hUID,
                   hKey,
                   KP_SALT_EX,
                   (PBYTE)&sSaltData,
                   0))
            goto Ret;
    }

    if (ReadKey(hKeys, "EPbK", &pUser->ContInfo.pbExchPub,
	            &pUser->ContInfo.ContLens.cbExchPub, pUser, hKey,
                &fEPbk, TRUE, FALSE) == NTF_FAILED)
    {
        goto Ret;
    }

    if (REG_KEYS == pUser->dwKeyStorageType)
    {
        fPrivKey = TRUE;
        if (ReadKey(hKeys, "EPvK", &pUser->pExchPrivKey,
	                &pUser->ExchPrivLen, pUser, hKey,
                    &fPrivKey, TRUE, FALSE) == NTF_FAILED)
        {
            goto Ret;			// error already set
        }

#ifndef BBN
        fPrivKey = TRUE;
        if (ReadKey(hKeys, "SPvK", &pUser->pSigPrivKey,
	                &pUser->SigPrivLen, pUser, hKey,
                    &fPrivKey, FALSE, FALSE) == NTF_FAILED)
        {
            goto Ret;			// error already set
        }
#endif
    }

    if (ReadKey(hKeys, "SPbK", &pUser->ContInfo.pbSigPub,
	            &pUser->ContInfo.ContLens.cbSigPub, pUser, hKey,
                &fSPbk, FALSE, TRUE) == NTF_FAILED)
    {
        goto Ret;			// error already set
    }

    // get the security descriptor for the old keyset
    GetRegKeySecDescr(pUser, hKeys, &pbSecDescr, &cbSecDescr, &dwSecDescrFlags);

    if (CRYPT_MACHINE_KEYSET & pUser->Rights)
    {
        fMachineKeyset = TRUE;
    }

    // if keys are in the protected storage then migrate them
    if (PROTECTED_STORAGE_KEYS == pUser->dwKeyStorageType)
    {
        // migrate the keys from the protected storage
        if (!MigrateProtectedStorageKeys(pUser,
                                         g_Strings.pwszMigrKeys,
                                         fSPbk,
                                         fEPbk))
        {
            goto Ret;
        }
    }
    else if (!(pUser->dwOldKeyFlags & LEAVE_OLD_KEYS))
    {
        if ((NULL == pUser->pSigPrivKey) &&
            (NULL == pUser->pExchPrivKey))
        {
            pUser->dwKeyStorageType = PROTECTION_API_KEYS;
            if (0 != (dwErr = WriteContainerInfo(pUser->dwProvType,
                             pUser->ContInfo.rgwszFileName,
                             fMachineKeyset,
                             &pUser->ContInfo)))
            {
                goto Ret;
            }
        }
        else
        {
            // migrate the keys to use protection APIs
            if (pUser->pSigPrivKey)
            {
                if (!ProtectPrivKey(pUser, NULL, 0, TRUE))
                    goto Ret;
            }
            if (pUser->pExchPrivKey)
            {
                if (!ProtectPrivKey(pUser, NULL, 0, FALSE))
                    goto Ret;
            }
        }

        RegCloseKey(pUser->hKeys);
        pUser->hKeys = 0;

        if (pUser->Rights & CRYPT_MACHINE_KEYSET)
            dwFlags = CRYPT_MACHINE_KEYSET;

        // delete the registry key
        if (!DeleteOldUserKeyGroup(pUser->ContInfo.pszUserName,
                                   pUser->dwProvType,
                                   dwFlags))
        {
            goto Ret;
        }
    }
    // not migrating the keys so just leave things as is and return success
    else
    {
        fRet = NTF_SUCCEED;
        goto Ret;
    }

    fRet = NTF_SUCCEED;
Ret:
    if (pbSecDescr)
        _nt_free(pbSecDescr, cbSecDescr);

    if (hKey != 0)
    {
        CPDestroyKey(pUser->hUID, hKey);
    }

    return fRet;
}

// This function is for a bug fix and trys to decrypt and re-encrypt the keyset
BOOL MixedCaseKeysetBugCheck(
                             HKEY hKeySetRegKey,
                             PNTAGUserList pTmpUser, 
                             char *szUserName1,
                             DWORD dwFlags
                             )
{
    char        *szUserName2 = NULL;
    char        *szKeyName1 = NULL;
    char        *szKeyName2 = NULL;
    DWORD       cbUserName = 0;
    DWORD       cbKeyName1;
    DWORD       cbKeyName2;
    FILETIME    ft;
    BOOL        fRet = FALSE;
    HKEY        hRegKey = 0;
    DWORD       i;
    DWORD       dwErr;
    DWORD       cSubKeys;
    DWORD       cchMaxClass;
    DWORD       cValues;
    DWORD       cchMaxValueName;
    DWORD       cbMaxValueData;
    DWORD       cbSecurityDesriptor;

    if (!OpenUserReg(szUserName1,
                     pTmpUser->dwProvType,
                     dwFlags,
                     TRUE,
                     &hRegKey,
                     &pTmpUser->dwOldKeyFlags))
    {
        SetLastError((DWORD)NTE_BAD_KEYSET);
        goto Ret;
    }

    cbUserName = lstrlen(szUserName1) + sizeof(char);
    if (NULL == (szUserName2 = _nt_malloc(cbUserName)))
        goto Ret;
    strcpy(szUserName2, szUserName1);
    _strlwr(szUserName2);

    if (ERROR_SUCCESS != RegQueryInfoKey(hRegKey,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &cSubKeys,
                                   &cbKeyName1,
                                   &cchMaxClass,
                                   &cValues,
                                   &cchMaxValueName,
                                   &cbMaxValueData,
                                   &cbSecurityDesriptor,
                                   &ft))
        goto Ret;

    if (NULL == (szKeyName1 = _nt_malloc(cbKeyName1 + 2)))
        goto Ret;
    if (NULL == (szKeyName2 = _nt_malloc(cbKeyName1 + 2)))
        goto Ret;

    for (i=0;i<cSubKeys;i++)
    {
        cbKeyName2 = cbKeyName1 + 2;
        if (ERROR_SUCCESS != RegEnumKeyEx(hRegKey,
                                          i,
                                          szKeyName1,
                                          &cbKeyName2,
                                          NULL,
                                          NULL,
                                          NULL,
                                          &ft))
        {
            dwErr = GetLastError();
            goto Ret;
        }

        lstrcpy(szKeyName2, szKeyName1);
        _strlwr(szKeyName1);
        if (0 == lstrcmp(szKeyName1, szUserName2))
        {
            _nt_free(pTmpUser->pCachePW, STORAGE_RC4_KEYLEN);
            pTmpUser->pCachePW = NULL;
            if (NTF_FAILED == LoadWin96Cache(pTmpUser,
                                             szKeyName2,
                                             dwFlags,
                                             FALSE))
            {
                goto Ret;
            }
            if (NTF_FAILED == RestoreUserKeys(hKeySetRegKey,
                                              pTmpUser,
                                              szKeyName2))
            {
                goto Ret;
            }
            break;
        }
    }

    fRet = TRUE;
Ret:
    if (hRegKey)
        RegCloseKey(hRegKey);
    if (szUserName2) 
        _nt_free(szUserName2, cbUserName);
    if (szKeyName1) 
        _nt_free(szKeyName1, cbKeyName1 + 2);
    if (szKeyName2) 
        _nt_free(szKeyName2, cbKeyName1 + 2);
    return fRet;
}

PNTAGUserList InitUser()
{
    PNTAGUserList pTmpUser = NULL;

    if (NULL != (pTmpUser = (PNTAGUserList) _nt_malloc(sizeof(NTAGUserList))))
    {
        InitializeCriticalSection(&pTmpUser->CritSec);
    }

    // initialize the mod expo offload information
    InitExpOffloadInfo(&pTmpUser->pOffloadInfo);

    pTmpUser->dwEnumalgs = 0xFFFFFFFF;
    pTmpUser->dwEnumalgsEx = 0xFFFFFFFF;
    pTmpUser->hRNGDriver = INVALID_HANDLE_VALUE;

    return pTmpUser;
}

/************************************************************************/
/* LogonUser validates a user and returns the package-specific info for */
/* that user.                                                           */
/************************************************************************/
BOOL NTagLogonUser (
                    char *pszUserID,
                    DWORD dwFlags,
                    void **UserInfo,
                    HCRYPTPROV *phUID,
                    DWORD dwProvType,
                    LPSTR pszProvName
                    )
{
    PNTAGUserList   pTmpUser = NULL;
    DWORD           dwUserLen = 0;
    char            *szUserName = NULL;
    DWORD           dwTemp;
    HKEY            hRegKey;
    BOOL            fProtStor;
    char            random[10];
    DWORD           dwErr = 0;
    BOOL            fInFrance = FALSE;
    BOOL            fRet = NTF_FAILED;

// load the resource strings if this is a static lib
#ifdef STATIC_BUILD
    if (!LoadStrings())
    {
        SetLastError((DWORD) NTE_FAIL);
        goto Ret;
    }
#endif // STATIC_BUILD

    SetMachineGUID();

    // Check for Invalid flags
    if (dwFlags & ~(CRYPT_NEWKEYSET|CRYPT_DELETEKEYSET|CRYPT_VERIFYCONTEXT|
                    CRYPT_MACHINE_KEYSET|CRYPT_SILENT))
    {
        SetLastError((DWORD) NTE_BAD_FLAGS);
        goto Ret;
    }

    if (((dwFlags & CRYPT_VERIFYCONTEXT) == CRYPT_VERIFYCONTEXT) &&
        (NULL != pszUserID) && (0x00 != *pszUserID))

    {
        SetLastError((DWORD) NTE_BAD_FLAGS);
        goto Ret;
    }

    // Check that user provided pointer is valid
    if (IsBadWritePtr(phUID, sizeof(HCRYPTPROV)))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    // If the user didn't supply a name, then we need to get it
    if (pszUserID != NULL && *pszUserID == '\0' ||
        (pszUserID == NULL &&
         ((dwFlags & CRYPT_VERIFYCONTEXT) != CRYPT_VERIFYCONTEXT)))
    {
        dwUserLen = MAXUIDLEN;

        if ((szUserName = (char *) _nt_malloc(dwUserLen)) == NULL)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }


        if (dwFlags & CRYPT_MACHINE_KEYSET)
        {
            strcpy(szUserName, NTAG_DEF_MACH_CONT_NAME);
            dwTemp = NTAG_DEF_MACH_CONT_NAME_LEN;
        }
        else
        {
            dwTemp = dwUserLen;

            dwTemp = sizeof("*Default*");
            memcpy(szUserName, "*Default*", dwTemp);
        }

    }
    else if (pszUserID != NULL)
    {
        dwUserLen = strlen(pszUserID) + sizeof(CHAR);
        if ((dwFlags & CRYPT_NEWKEYSET) && (dwUserLen > MAX_PATH + 1))
        {
            SetLastError((DWORD)NTE_BAD_KEYSET);
            goto Ret;
        }

        if ((szUserName = (char *) _nt_malloc(dwUserLen)) == NULL)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }
        strcpy(szUserName, pszUserID);
    }

    if (dwFlags & CRYPT_DELETEKEYSET)
    {
        if (!DeleteUserKeyGroup(szUserName, dwProvType,
                                dwFlags))
        {
            goto Ret;
        }
        fRet = NTF_SUCCEED;
        goto Ret;
    }

    // Zero to ensure valid fields for non-existent keys
    if (NULL == (pTmpUser = InitUser()))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Ret;
    }

#ifdef STRONG
    if (NULL != pszProvName)
    {
        if (0 == lstrcmp(pszProvName, MS_STRONG_PROV))
        {
            pTmpUser->fNewStrongCSP = TRUE;
        }
    }
#endif // STRONG

    pTmpUser->dwProvType = dwProvType;

    // check if local machine keys
    if ((dwFlags & CRYPT_SILENT) || (dwFlags & CRYPT_VERIFYCONTEXT))
    {
        pTmpUser->ContInfo.fCryptSilent = TRUE;
    }

#ifndef _XBOX
    if (((dwFlags & CRYPT_VERIFYCONTEXT) != CRYPT_VERIFYCONTEXT))
    {
        if (0 != (dwErr = OpenUserKeyGroup(pTmpUser, szUserName,
                                           dwFlags, FALSE)))
        {
            SetLastError(dwErr);
            goto Ret;
        }
    }
#endif

    // check if local machine keys
    if (dwFlags & CRYPT_MACHINE_KEYSET)
    {
        pTmpUser->Rights |= CRYPT_MACHINE_KEYSET;
    }

    IsLocalSystem(&pTmpUser->fIsLocalSystem);

    if (!NTLMakeItem(phUID, USER_HANDLE, (void *)pTmpUser))
    {
        goto Ret;
    }

    pTmpUser->hUID = *phUID;

    if (((dwFlags & CRYPT_VERIFYCONTEXT) != CRYPT_VERIFYCONTEXT) &&
        (PROTECTION_API_KEYS != pTmpUser->dwKeyStorageType) && 
        (!(CRYPT_NEWKEYSET & dwFlags)))
    {
        CheckForStorageType(pTmpUser->hKeys, &pTmpUser->dwKeyStorageType);

        if (PROTECTED_STORAGE_KEYS == pTmpUser->dwKeyStorageType)
        {
            // check for PStore availability and use it if its there
            if (NULL == (pTmpUser->pPStore =
                    (PSTORE_INFO*)_nt_malloc(sizeof(PSTORE_INFO))))
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }

            // check if PStore is available
            if (!CheckPStoreAvailability(pTmpUser->pPStore))
            {
                SetLastError((DWORD)NTE_FAIL);
                goto Ret;
            }

            if (!GetKeysetTypeAndSubType(pTmpUser))
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }
        }

        // migrate old keys
        if ((REG_KEYS == pTmpUser->dwKeyStorageType) ||
            (PROTECTED_STORAGE_KEYS == pTmpUser->dwKeyStorageType))
        {
            if (!LoadWin96Cache(pTmpUser,
                                pTmpUser->ContInfo.pszUserName,
                                dwFlags,
                                TRUE))
            {
                goto Ret;          // error already set
            }

            if (!RestoreUserKeys(pTmpUser->hKeys, pTmpUser, szUserName))
            {
                if (!MixedCaseKeysetBugCheck(pTmpUser->hKeys, pTmpUser,
                                             szUserName, dwFlags))
                {
                    SetLastError((DWORD)NTE_BAD_KEYSET);
                    goto Ret;
                }
            }
        }
        else
        {
            SetLastError((DWORD)NTE_BAD_KEYSET);
            goto Ret;
        }
    }

    //
    // If lang French disable encryption
    //
#ifndef STATIC_BUILD
    if (!IsEncryptionPermitted(pTmpUser->dwProvType, &fInFrance))
    {
        pTmpUser->Rights |= CRYPT_DISABLE_CRYPT;
    }
    if (fInFrance)
    {
        pTmpUser->Rights |= CRYPT_IN_FRANCE;
    }
#endif

    if (pTmpUser->ContInfo.ContLens.cbExchPub && pTmpUser->ContInfo.pbExchPub)
    {
        BSAFE_PUB_KEY *pPubKey = (BSAFE_PUB_KEY *)pTmpUser->ContInfo.pbExchPub;

        if (PROV_RSA_SCHANNEL == pTmpUser->dwProvType)
        {
#ifndef STRONG
            if ((pPubKey->bitlen / 8) > SGC_RSA_MAX_EXCH_MODLEN)
            {
                SetLastError((DWORD)NTE_BAD_KEYSET);
                goto Ret;
            }
#endif
        }
        else
        {
            if (pTmpUser->Rights & CRYPT_IN_FRANCE)
            {
                if ((pPubKey->bitlen / 8) > RSA_MAX_EXCH_FRENCH_MODLEN)
                {
                    SetLastError((DWORD)NTE_BAD_KEYSET);
                    goto Ret;
                }
            }
            else
            {
                if ((pPubKey->bitlen / 8) > RSA_MAX_EXCH_MODLEN)
                {
                    SetLastError((DWORD)NTE_BAD_KEYSET);
                    goto Ret;
                }
            }
        }
    }

#ifdef TEST_HW_RNG
    // checks if the HWRNG is to be used
    if (!SetupHWRNGIfRegistered(&pTmpUser->hRNGDriver))
    {
        SetLastError((DWORD)NTE_FAIL);
        goto Ret;
    }
#endif // 0

    if (!FIPS186GenRandom(&pTmpUser->hRNGDriver,
                          &pTmpUser->ContInfo.pbRandom,
                          &pTmpUser->ContInfo.ContLens.cbRandom,
                          random, sizeof(random)))
    {
        goto Ret;
    }

#ifdef STRONG
    if ((!pTmpUser->fNewStrongCSP) &&
        (ERROR_SUCCESS == RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                                        "Software\\Microsoft\\Cryptography\\DESHashSessionKeyBackward",
                                        0,
                                        KEY_READ,
                                        &hRegKey)))
    {
        pTmpUser->Rights |= CRYPT_DES_HASHKEY_BACKWARDS;
        RegCloseKey(hRegKey);
        hRegKey = 0;
    }
#endif // STRONG

    if (dwFlags & CRYPT_VERIFYCONTEXT)
    {
        pTmpUser->Rights |= CRYPT_VERIFYCONTEXT;
    }

    *UserInfo = pTmpUser;
    fRet = NTF_SUCCEED;
Ret:
    if (szUserName)
        _nt_free(szUserName, dwUserLen);
    if (NTF_SUCCEED != fRet)
    {
        dwErr = GetLastError();

        if (NULL != pTmpUser)
        {
            FreeUserRec(pTmpUser);
        }
        SetLastError(dwErr);
    }
    return fRet;
}

/************************************************************************/
/* LogoffUser removes a user from the user list.  The handle to that	*/
/* will therefore no longer be valid.					*/
/************************************************************************/
BOOL LogoffUser (void *UserInfo)
{
    PNTAGUserList	pTmpUser = (PNTAGUserList)UserInfo;
    HKEY                hKeys;

    hKeys = pTmpUser->hKeys;
    FreeUserRec(pTmpUser);

    if (RegCloseKey(hKeys) != ERROR_SUCCESS)
    {
	; // debug message, notify user somehow?
    }

    return NTF_SUCCEED;
}

/*
 -	CPAcquireContext
 -
 *	Purpose:
 *               The CPAcquireContext function is used to acquire a context
 *               handle to a cryptograghic service provider (CSP).
 *
 *
 *	Parameters:
 *               OUT phUID         -  Handle to a CSP
 *               IN  pUserID       -  Pointer to a string which is the
 *                                    identity of the logged on user
 *               IN  dwFlags       -  Flags values
 *               IN  pVTable       -  Pointer to table of function pointers
 *
 *	Returns:
 */
BOOL CPAcquireContext(OUT HCRYPTPROV *phUID,
                      IN  CHAR *pUserID,
                      IN DWORD dwFlags,
                      IN PVTableProvStruc pVTable)
{
    void            *UserData;
    PNTAGUserList   pTmpUser;
    DWORD           dwProvType = PROV_RSA_FULL;
    LPSTR           pszProvName = NULL;
    BOOL            fRet = NTF_FAILED;

#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputAcqCtxt(TRUE, FALSE, phUID, pUserID, dwFlags, pVTable);
#endif // DBG -- NOTE:  This section not compiled for retail builds 

    if (pVTable->Version >= 2)
        dwProvType = pVTable->dwProvType;

    if (pVTable->Version >= 3)
        pszProvName = pVTable->pszProvName;

    if (NTF_FAILED == NTagLogonUser(pUserID, dwFlags, &UserData,
                                    phUID, dwProvType, pszProvName))
    {
        goto Ret;
    }

    if (dwFlags & CRYPT_DELETEKEYSET)
    {
        fRet = NTF_SUCCEED;
        goto Ret;
    }

    pTmpUser = (PNTAGUserList) UserData;
    pTmpUser->hPrivuid = 0;

    fRet = NTF_SUCCEED;
Ret:
#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputAcqCtxt(FALSE, fRet, NULL, NULL, 0, NULL);
#endif // DBG -- NOTE:  This section not compiled for retail builds 

    return fRet;
}

/*
 -      CPReleaseContext
 -
 *      Purpose:
 *               The CPReleaseContext function is used to release a
 *               context created by CrytAcquireContext.
 *
 *     Parameters:
 *               IN  hUID          -  Handle to a CSP
 *               IN  dwFlags       -  Flags values
 *
 *	Returns:
 */
BOOL CPReleaseContext(IN HCRYPTPROV hUID,
                      IN DWORD dwFlags)
{
    void	*UserData = NULL;
    BOOL	f = NTF_FAILED;

#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputReleaseCtxt(TRUE, FALSE, hUID, dwFlags);
#endif // DBG -- NOTE:  This section not compiled for retail builds

    // check to see if this is a valid user handle
    // ## MTS: No user structure locking
    if ((UserData = NTLCheckList (hUID, USER_HANDLE)) == NULL)
    {
	    SetLastError((DWORD) NTE_BAD_UID);
	    goto Ret;
    }

    f = LogoffUser (UserData);
Ret:
    // Remove from internal list first so others
    // can't get to it, then logoff the current user
    if (UserData)
        NTLDelete(hUID);

    // Check for Invalid flags
    if (dwFlags != 0)
    {
	    SetLastError((DWORD) NTE_BAD_FLAGS);
        f = NTF_FAILED;
    }


#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputReleaseCtxt(FALSE, f, 0, 0);
#endif // DBG -- NOTE:  This section not compiled for retail builds 

    return f;

}


BOOL RemovePublicKeyExportability(IN PNTAGUserList pUser,
                                  IN BOOL fExchange)
{
    DWORD dwType;
    DWORD cb;
    BOOL fRet = FALSE;

    if (fExchange)
    {
        if (ERROR_SUCCESS == RegQueryValueEx(pUser->hKeys, "EExport", NULL,
                                             &dwType, NULL, &cb))
        {
            if (ERROR_SUCCESS != RegDeleteValue(pUser->hKeys, "EExport"))
            {
                goto Ret;
            }
        }
    }
    else
    {
        if (ERROR_SUCCESS == RegQueryValueEx(pUser->hKeys, "SExport", NULL,
                                             &dwType, NULL, &cb))
        {
            if (ERROR_SUCCESS != RegDeleteValue(pUser->hKeys, "SExport"))
            {
                goto Ret;
            }
        }
    }

    fRet = TRUE;

Ret:
    return fRet;
}

BOOL MakePublicKeyExportable(IN PNTAGUserList pUser,
                             IN BOOL fExchange)
{
    BYTE b = 0x01;
    BOOL fRet = FALSE;
	
    if (fExchange)
    {
        if (ERROR_SUCCESS != RegSetValueEx(pUser->hKeys, "EExport", 0,
                                           REG_BINARY, &b, sizeof(b)))
        {
            goto Ret;
        }
    }
    else
    {
        if (ERROR_SUCCESS != RegSetValueEx(pUser->hKeys, "SExport", 0,
                                           REG_BINARY, &b, sizeof(b)))
        {
            goto Ret;
        }
    }

    fRet = TRUE;

Ret:
    return fRet;
}

BOOL CheckPublicKeyExportability(IN PNTAGUserList pUser,
                                 IN BOOL fExchange)
{
    DWORD dwType;
    DWORD cb = 1;
    BYTE b;
    BOOL fRet = FALSE;

    if (fExchange)
    {
        if (ERROR_SUCCESS != RegQueryValueEx(pUser->hKeys, "EExport", NULL,
                                             &dwType, &b, &cb))
        {
            goto Ret;
        }
    }
    else
    {
        if (ERROR_SUCCESS != RegQueryValueEx(pUser->hKeys, "SExport", NULL,
                                             &dwType, &b, &cb))
        {
            goto Ret;
        }
    }
	
    if ((sizeof(b) != cb) || (0x01 != b))
    {
        goto Ret;
    }

    fRet = TRUE;

Ret:
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\rsabase\ntagimp1.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ntagimp1.h                                             //
//  DESCRIPTION   :                                                        //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Apr 19 1995 larrys  Cleanup                                        //
//      May  5 1995 larrys  Changed struct Hash_List_Defn                  //
//      May 10 1995 larrys  added private api calls                        //
//      Aug 15 1995 larrys  Moved CSP_USE_DES to sources file              //
//      Sep 12 1995 Jeffspel/ramas  Merged STT onto CSP                    //
//      Sep 25 1995 larrys  Changed MAXHASHLEN                             //
//      Oct 27 1995 rajeshk Added RandSeed stuff to UserList               //
//      Feb 29 1996 rajeshk Added HashFlags              				   //
//      Sep  4 1996 mattt	Changes to facilitate building STRONG algs	   //
//      Sep 16 1996 mattt   Added Domestic naming                          //
//      Apr 29 1997 jeffspel Protstor support and EnumAlgsEx support       //
//      May 23 1997 jeffspel Added provider type checking                  //
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef __NTAGIMP1_H__
#define __NTAGIMP1_H__

#ifdef __cplusplus
extern "C" {
#endif

#define PROV_SIG                MS_DEF_RSA_SIG_PROV

#ifndef STRONG
#define PROV_NAME               MS_DEF_PROV
#else   // STRONG                   
#define PROV_NAME               MS_ENHANCED_PROV
#endif  // STRONG

#define PROV_SCHANNEL           MS_DEF_RSA_SCHANNEL_PROV



#define CSP_USE_SHA
#define CSP_USE_RC4

// define which algorithms to include
#define CSP_USE_MD5
#ifndef _XBOX
#define CSP_USE_MD4
#define CSP_USE_MD2
#define CSP_USE_MAC
#define CSP_USE_RC2
#define CSP_USE_SSL3SHAMD5
#define CSP_USE_SSL3
#define CSP_USE_DES
#define CSP_USE_3DES
#endif

// handle definition types
#define USER_HANDLE                             0x0
#define HASH_HANDLE                             0x1
#define KEY_HANDLE                              0x2
#define SIGPUBKEY_HANDLE                        0x3
#define EXCHPUBKEY_HANDLE                       0x4

#ifdef _WIN64
#define     HANDLE_MASK     0xE35A172CD96214A0
#else
#define     HANDLE_MASK     0xE35A172C
#endif // _WIN64

typedef ULONG_PTR HNTAG;

typedef struct _htbl {
	void			*pItem;
	DWORD			dwType;
} HTABLE;

#define HNTAG_TO_HTYPE(hntag)   (BYTE)(((HTABLE*)((HNTAG)hntag ^ HANDLE_MASK))->dwType)

// maximum length for the hash
//                                              -- MD4 and MD5
#ifndef STT
#ifdef CSP_USE_SHA
#define MAXHASHLEN              A_SHA_DIGEST_LEN
#else
#define MAXHASHLEN              max(MD4DIGESTLEN, MD5DIGESTLEN)
#endif
#else
#define MAXHASHLEN              A_SHA_DIGEST_LEN        //max(MD4DIGESTLEN, MD5DIGESTLEN)
#endif //STT

#define MAX_BLOCKLEN            8

#define SSL3_MASTER_KEYSIZE     48
#define PCT1_MASTER_KEYSIZE     16
#define SSL2_MASTER_KEYSIZE     5

#define RSA_KEYSIZE_INC         8

#ifdef STRONG	

	// define the length of the RSA modulus in bytes
	#define GRAINSIZE       128
	#define RSAMODLEN       GRAINSIZE

    #define RSA_MAX_SIGN_MODLEN     2048    // 16384 bit
    #define RSA_MAX_EXCH_MODLEN     2048    // 16384 bit
    #define RSA_MIN_SIGN_MODLEN     48      // 384 bit
    #define RSA_MIN_EXCH_MODLEN     48      // 384 bit

    #define RSA_DEF_NEWSTRONG_SIGN_MODLEN   64
    #define RSA_DEF_NEWSTRONG_EXCH_MODLEN   64

    #define DEFAULT_SALT_NEWSTRONG_LENGTH 11    // salt length in bytes
    #define DEFAULT_SALT_LENGTH 0		// salt length in bytes

    #define MAX_KEY_SIZE        48      // largest key size (SSL3 masterkey)

    #define SSL2_MAX_MASTER_KEYSIZE     24

	#pragma message("Building STRONG CSP")
#else	// default

	// define the length of the RSA modulus in bytes
	#define GRAINSIZE       64
	#define RSAMODLEN       GRAINSIZE

    #define RSA_MAX_SIGN_MODLEN     2048    // 16384 bit
    #define RSA_MAX_EXCH_MODLEN     128     // 1024 bit
    #define RSA_MIN_SIGN_MODLEN     48      // 384 bit
    #define RSA_MIN_EXCH_MODLEN     48      // 384 bit

    #define DEFAULT_SALT_LENGTH 11		// salt length in bytes
    #define MAX_KEY_SIZE        48      // largest key size(SSL3 masterkey)

    #define SSL2_MAX_MASTER_KEYSIZE     5

	#pragma message("Building default CSP")
#endif 

// for non-STT builds
#define RSA_DEF_EXCH_MODLEN   RSAMODLEN
#define RSA_DEF_SIGN_MODLEN   RSAMODLEN

#define RC2_MIN_KEYSIZE     5
#define RC4_MIN_KEYSIZE     5

// effective key length defines for RC2
#define RC2_DEFAULT_EFFECTIVE_KEYLEN    40
#define RC2_SCHANNEL_DEFAULT_EFFECTIVE_KEYLEN    128
#define RC2_MIN_EFFECTIVE_KEYLEN        1
#ifdef STRONG
    // this is for the domestic provider which is backward compatible
    // with the international provider
    #define RC2_DEF_NEWSTRONG_KEYSIZE     5
    #define RC4_DEF_NEWSTRONG_KEYSIZE     5
    #define RC2_DEF_KEYSIZE     16
    #define RC4_DEF_KEYSIZE     16
    #define RC2_MAX_KEYSIZE     16
    #define RC4_MAX_KEYSIZE     16
    #define RC2_MAX_EFFECTIVE_KEYLEN        1024
#else
    #define RC2_DEF_KEYSIZE     5
    #define RC4_DEF_KEYSIZE     5
    #define RC2_MAX_KEYSIZE     7
    #define RC4_MAX_KEYSIZE     7

    #define RC2_MAX_EFFECTIVE_KEYLEN        56
#endif

// defines for France
#define RC2_MAX_FRENCH_KEYSIZE     5
#define RC4_MAX_FRENCH_KEYSIZE     5
#define RSA_MAX_EXCH_FRENCH_MODLEN     64      // 512 bit

// defines for SGC
#define SGC_RSA_MAX_EXCH_MODLEN     128      // 512 bit
#define SGC_RSA_DEF_EXCH_MODLEN     128

#define SGC_RC2_DEF_KEYSIZE         16
#define SGC_RC4_DEF_KEYSIZE         16
#define SGC_RC2_MAX_KEYSIZE         16
#define SGC_RC4_MAX_KEYSIZE         16

// check for the maximum hash length greater than the mod length
#if RSAMODLEN < MAXHASHLEN
#error  "RSAMODLEN must be greater than or equal to MAXHASHLEN"
#endif

#define     STORAGE_RC4_KEYLEN      5   // keys always stored under 40-bit RC4 key
#define     STORAGE_RC4_TOTALLEN    16  // 0-value salt fills rest

// types of key storage
#define REG_KEYS                    0 
#define PROTECTED_STORAGE_KEYS      1 
#define PROTECTION_API_KEYS         2

// structure to hold protected storage info
typedef struct _PStore_Info
{
    HINSTANCE   hInst;
    void        *pProv;
    GUID        SigType;
    GUID        SigSubtype;
    GUID        ExchType;
    GUID        ExchSubtype;
    LPWSTR      szPrompt;
    DWORD       cbPrompt;
} PSTORE_INFO;

// definition of a user list
typedef struct _UserList
{
    DWORD                           Rights;
    BOOL                            fNewStrongCSP;
    DWORD                           dwProvType;
    DWORD                           hPrivuid;
    HCRYPTPROV                      hUID;
    BOOL                            fIsLocalSystem;
    DWORD                           dwEnumalgs;
    DWORD                           dwEnumalgsEx;
    KEY_CONTAINER_INFO              ContInfo;
    DWORD                           ExchPrivLen;
    BYTE                            *pExchPrivKey;
    DWORD                           SigPrivLen;
    BYTE                            *pSigPrivKey;
    HKEY                            hKeys;		// AT NTag only
    size_t                          UserLen;
    BYTE                            *pCachePW;
    BYTE                            *pUser;
    HANDLE                          hWnd;
    DWORD                           dwKeyStorageType;
    PSTORE_INFO                     *pPStore;
    LPWSTR                          pwszPrompt;
    DWORD                           dwOldKeyFlags;
    BOOL                            dwSGCFlags;
    BYTE                            *pbSGCKeyMod;
    DWORD                           cbSGCKeyMod;
    DWORD                           dwSGCKeyExpo;
    HANDLE                          hRNGDriver;
    CHAR                            rgszMachineName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD                           cbMachineName;
    CRITICAL_SECTION                CritSec;   
    EXPO_OFFLOAD_STRUCT             *pOffloadInfo; // info for offloading modular expo
} NTAGUserList, *PNTAGUserList;


// UserList Rights flags (uses CRYPT_MACHINE_KEYSET and CRYPT_VERIFYCONTEXT)
#define CRYPT_DISABLE_CRYPT             0x1
#define CRYPT_IN_FRANCE                 0x2
#define CRYPT_DES_HASHKEY_BACKWARDS     0x4

#define CRYPT_BLKLEN    8               // Bytes in a crypt block
#define MAX_SALT_LEN    24


// definition of a key list
typedef struct _KeyList
{
    HCRYPTPROV      hUID;                   // must be first
    ALG_ID			Algid;
    DWORD			Rights;
    DWORD			cbKeyLen;
    BYTE			*pKeyValue;             // Actual Key
    DWORD			cbDataLen;
    BYTE			*pData;                 // Inflated Key or Multi-phase
    BYTE			IV[CRYPT_BLKLEN];       // Initialization vector
    BYTE			FeedBack[CRYPT_BLKLEN]; // Feedback register
    DWORD			InProgress;             // Flag to indicate encryption
    DWORD           cbSaltLen;              // Salt length
    BYTE			rgbSalt[MAX_SALT_LEN];  // Salt value
    DWORD			Padding;                // Padding values
    DWORD			Mode;                   // Mode of cipher
    DWORD			ModeBits;               // Number of bits to feedback
    DWORD			Permissions;            // Key permissions
    DWORD           EffectiveKeyLen;        // used by RC2
    BYTE            *pbParams;              // may be used in OAEP
    DWORD           cbParams;               // length of pbParams
#ifdef STT
    DWORD           cbInfo;
    BYTE            rgbInfo[MAXCCNLEN];
#endif
} NTAGKeyList, *PNTAGKeyList;

#define     HMAC_DEFAULT_STRING_LEN     64

// definition of a hash list
typedef struct Hash_List_Defn
{
    HCRYPTPROV      hUID;
    ALG_ID          Algid;
    DWORD           dwDataLen;
    void            *pHashData;
    HCRYPTKEY       hKey;
    DWORD           HashFlags;
    ALG_ID          HMACAlgid;
    DWORD           HMACState;
    BYTE            *pbHMACInner;
    DWORD           cbHMACInner;
    BYTE            *pbHMACOuter;
    DWORD           cbHMACOuter;
    DWORD           dwHashState;
} NTAGHashList, *PNTAGHashList;

#define     HMAC_STARTED    1
#define     HMAC_FINISHED   2

#define     DATA_IN_HASH    1

// Values of the HashFlags

#define HF_VALUE_SET	1

// Hash algorithm's internal state
// -- Placed into PNTAGHashList->pHashData

// for MD5
#define MD5_object      MD5_CTX

// for MD4
// see md4.h for MD4_object

// Stuff for weird SSL 3.0 signature format
#define SSL3_SHAMD5_LEN   (A_SHA_DIGEST_LEN + MD5DIGESTLEN)

// prototypes
void memnuke(volatile BYTE *data, DWORD len);

BOOL LocalCreateHash(
                     IN ALG_ID Algid,
                     OUT BYTE **ppbHashData,
                     OUT DWORD *pcbHashData
                     );

BOOL LocalHashData(
                   IN ALG_ID Algid,
                   IN OUT BYTE *pbHashData,
                   IN BYTE *pbData,
                   IN DWORD cbData
                   );

BOOL LocalEncrypt(IN HCRYPTPROV hUID,
                  IN HCRYPTKEY hKey,
                  IN HCRYPTHASH hHash,
                  IN BOOL Final,
                  IN DWORD dwFlags,
                  IN OUT BYTE *pbData,
                  IN OUT DWORD *pdwDataLen,
                  IN DWORD dwBufSize,
                  IN BOOL fIsExternal);

BOOL LocalDecrypt(IN HCRYPTPROV hUID,
                  IN HCRYPTKEY hKey,
                  IN HCRYPTHASH hHash,
                  IN BOOL Final,
                  IN DWORD dwFlags,
                  IN OUT BYTE *pbData,
                  IN OUT DWORD *pdwDataLen,
                  IN BOOL fIsExternal);

BOOL FIPS186GenRandom(
                      IN HANDLE *phRNGDriver,
                      IN BYTE **ppbContextSeed,
                      IN DWORD *pcbContextSeed,
                      IN OUT BYTE *pb,
                      IN DWORD cb
                      );
//
// Function : TestEncDec
//
// Description : This function expands the passed in key buffer for the appropriate
//               algorithm, and then either encryption or decryption is performed.
//               A comparison is then made to see if the ciphertext or plaintext
//               matches the expected value.
//               The function only uses ECB mode for block ciphers and the plaintext
//               buffer must be the same length as the ciphertext buffer.  The length
//               of the plaintext must be either the block length of the cipher if it
//               is a block cipher or less than MAX_BLOCKLEN if a stream cipher is
//               being used.
//
BOOL TestEncDec(
                IN ALG_ID Algid,
                IN BYTE *pbKey,
                IN DWORD cbKey,
                IN BYTE *pbPlaintext,
                IN DWORD cbPlaintext,
                IN BYTE *pbCiphertext,
                IN BYTE *pbIV,
                IN int iOperation
                );

//
// Function : TestSymmetricAlgorithm
//
// Description : This function expands the passed in key buffer for the appropriate algorithm,
//               encrypts the plaintext buffer with the same algorithm and key, and the
//               compares the passed in expected ciphertext with the calculated ciphertext
//               to make sure they are the same.  The opposite is then done with decryption.
//               The function only uses ECB mode for block ciphers and the plaintext
//               buffer must be the same length as the ciphertext buffer.  The length
//               of the plaintext must be either the block length of the cipher if it
//               is a block cipher or less than MAX_BLOCKLEN if a stream cipher is
//               being used.
//
BOOL TestSymmetricAlgorithm(
                            IN ALG_ID Algid,
                            IN BYTE *pbKey,
                            IN DWORD cbKey,
                            IN BYTE *pbPlaintext,
                            IN DWORD cbPlaintext,
                            IN BYTE *pbCiphertext,
                            IN BYTE *pbIV
                            );

#ifdef CSP_USE_MD5
//
// Function : TestMD5
//
// Description : This function hashes the passed in message with the MD5 hash
//               algorithm and returns the resulting hash value.
//
BOOL TestMD5(
             BYTE *pbMsg,
             DWORD cbMsg,
             BYTE *pbHash
             );
#endif // CSP_USE_MD5

#ifdef CSP_USE_SHA1
//
// Function : TestSHA1
//
// Description : This function hashes the passed in message with the SHA1 hash
//               algorithm and returns the resulting hash value.
//
BOOL TestSHA1(
              BYTE *pbMsg,
              DWORD cbMsg,
              BYTE *pbHash
              );
#endif // CSP_USE_SHA1

// These may later be changed to set/use NT's [GS]etLastErrorEx
// so make it easy to switch over..
#ifdef MTS
__declspec(thread)
#endif

#ifdef __cplusplus
}
#endif

#endif // __NTAGIMP1_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\rsabase\ntagum.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ntagum.h                                               //
//  DESCRIPTION   : include file                                           //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Feb 16 1995 larrys  Fix problem for 944 build                      //
//      May 23 1997 jeffspel Added provider type checking                  //
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////
#ifndef	__NTAGUM_H__
#define	__NTAGUM_H__

#ifdef __cplusplus
extern "C" {
#endif

// prototypes for the NameTag User Manager
BOOL WINAPI FIsWinNT(void);

BOOL NTagLogonUser (
                    char *pszUserID,
                    DWORD dwFlags,
                    void **UserInfo,
                    HCRYPTPROV *phUID,
                    DWORD dwProvType,
                    LPSTR pszProvName
                    );

BOOL LogoffUser (void *UserInfo);

BOOL ReadRegValue(
                  HKEY hLoc,
                  char *pszName,
                  BYTE **ppbData,
                  DWORD *pcbLen,
                  BOOL fAlloc
                  );

BOOL ReadKey(
             HKEY hLoc,
             char *pszName,
             BYTE **ppbData,
             DWORD *pcbLen,
             PNTAGUserList pUser,
             HCRYPTKEY hKey,
             BOOL *pfPrivKey,
             BOOL fKeyExKey,
             BOOL fLastKey
             );

BOOL SaveKey(
             HKEY hRegKey,
             CONST char *pszName,
             void *pbData,
             DWORD dwLen,
             PNTAGUserList pUser,
             BOOL fPrivKey,
             DWORD dwFlags,
             BOOL fExportable
             );

BOOL ProtectPrivKey(
                    IN OUT PNTAGUserList pTmpUser,
                    IN LPWSTR szPrompt,
                    IN DWORD dwFlags,
                    IN BOOL fSigKey
                    );

BOOL UnprotectPrivKey(
                      IN OUT PNTAGUserList pTmpUser,
                      IN LPWSTR szPrompt,
                      IN BOOL fSigKey,
                      IN BOOL fAlwaysDecrypt
                      );

BOOL RemovePublicKeyExportability(IN PNTAGUserList pUser,
                                  IN BOOL fExchange);

BOOL MakePublicKeyExportable(IN PNTAGUserList pUser,
                             IN BOOL fExchange);

BOOL CheckPublicKeyExportability(IN PNTAGUserList pUser,
                                 IN BOOL fExchange);

#ifdef __cplusplus
}
#endif


#endif // __NTAGUM_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\rsabase\nt_blobs.h ===
#ifndef	__NT_BLOBS_H__
#define	__NT_BLOBS_H__

/* nt_blobs.h
 *
 *	Structure definitions for the NameTag keyblob formats.
 *
 *	Note: the code assumes that all structures begin with the
 *	STD_PRELUDE macro and end with the STD_POSTLUDE macro.
 *	This allows the "fill in the blanks" code to work more efficiently.
 *
 *	NTStdHeader is the data that goes before the encrypted portion of
 *	the key blob.
 *
 *	!!!!!!!!!!!!!!!ALERT!!!!!!!!!!!!!!!!!!!!!!!!!
 *	Since these structs define a net packet, we always
 *	assume Intel byte order on these structures!!!!!
 *
 */

#ifdef __cplusplus
extern "C" {
#endif

#define CUR_BLOB_VERSION	2
#define NT_HASH_BYTES	MAXHASHLEN

typedef struct _SIMPLEBLOB {
	ALG_ID	aiEncAlg;
} NTSimpleBlob;

typedef struct _STKXB {
	DWORD	dwRights;
	DWORD	dwKeyLen;
	BYTE	abHashData[NT_HASH_BYTES];
} NTKeyXBlob ;

#ifdef __cplusplus
}
#endif

#endif // __NT_BLOBS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\rsabase\nt_rsa.h ===
#ifndef	__NT_RSA_H__
#define	__NT_RSA_H__

#include "md2.h"
#include "md4.h"
#include "msr_md5.h"
#include "sha.h"
#include "rc2.h"
#include "rc4.h"
#include "des.h"
#include "rsa.h"
#include "modes.h"

#define EMULATE_RC4
#define EMULATE_BSAFE
#define EMULATE_SHA1
#include "xcrypt.h"

/* nt_rsa.h
 *
 *	Stuff local to NameTag, but necessary for the RSA library.
 */

#ifdef __cplusplus
extern "C" {
#endif

// This structure keeps state for MD4 hashing.
typedef struct MD4stuff
{
	MDstruct			MD;		// MD4's state
	BOOL				FinishFlag;
	DWORD				BufLen;
	BYTE				Buf[MD4BLOCKSIZE];// staging buffer
} MD4_object;

typedef struct MD2stuff
{
	MD2_CTX                         MD;		// MD2's state
	BOOL				FinishFlag;
} MD2_object;

#define MD2DIGESTLEN    16

#ifdef __cplusplus
}
#endif

#endif // __NT_RSA_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\rsabase\nt_key.c ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : nt_key.c                                               //
//  DESCRIPTION   : Crypto CP interfaces:                                  //
//                  CPGenKey                                               //
//                  CPDeriveKey                                            //
//                  CPExportKey                                            //
//                  CPImportKey                                            //
//                  CPDestroyKey                                           //
//                  CPGetUserKey                                           //
//                  CPSetKeyParam                                          //
//                  CPGetKeyParam                                          //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//  Jan 25 1995 larrys  Changed from Nametag                               //
//  Feb 16 1995 larrys  Fix problem for 944 build                          //
//  Feb 21 1995 larrys  Added SPECIAL_KEY                                  //
//  Feb 23 1995 larrys  Changed NTag_SetLastError to SetLastError          //
//  Mar 08 1995 larrys  Fixed a few problems                               //
//  Mar 23 1995 larrys  Added variable key length                          //
//  Apr  7 1995 larrys  Removed CryptConfigure                             //
//  Apr 17 1995 larrys  Added 1024 key gen                                 //
//  Apr 19 1995 larrys  Changed CRYPT_EXCH_PUB to AT_KEYEXCHANGE           //
//  May 10 1995 larrys  added private api calls                            //
//  May 17 1995 larrys  added key data for DES test                        //
//  Jul 20 1995 larrys  Changed export of PUBLICKEYBLOB                    //
//  Jul 21 1995 larrys  Fixed Export of AUTHENTICATEDBLOB                  //
//  Aug 03 1995 larrys  Allow CryptG(S)etKeyParam for Public keys &        //
//                      Removed CPTranslate                                //
//  Aug 10 1995 larrys  Fixed a few problems in CryptGetKeyParam           //
//  Aug 11 1995 larrys  Return no key for CryptGetUserKey                  //
//  Aug 14 1995 larrys  Removed key exchange stuff                         //
//  Aug 17 1995 larrys  Removed a error                                    //
//  Aug 18 1995 larrys  Changed NTE_BAD_LEN to ERROR_MORE_DATA             //
//  Aug 30 1995 larrys  Removed RETURNASHVALUE from CryptGetHashValue      //
//  Aug 31 1995 larrys  Fixed CryptExportKey if pbData == NULL             //
//  Sep 05 1995 larrys  Fixed bug # 30                                     //
//  Sep 05 1995 larrys  Fixed bug # 31                                     //
//  Sep 11 1995 larrys  Fixed bug # 34                                     //
//  Sep 12 1995 larrys  Removed 2 DWORDS from exported keys                //
//  Sep 14 1995 Jeffspel/ramas  Merged STT onto CSP                        //
//  Sep 18 1995 larrys  Changed def KP_PERMISSIONS to 0xffffffff           //
//  Oct 02 1995 larrys  Fixed bug 43 return error for importkey on hPubkey //
//  Oct 03 1995 larrys  Fixed bug 37 call InflateKey from SetKeyParam      //
//  Oct 03 1995 larrys  Fixed bug 36, removed OFB from SetKeyParam         //
//  Oct 03 1995 larrys  Fixed bug 38, check key type in SetKeyParam        //
//  Oct 13 1995 larrys  Added CPG/setProv/HashParam                        //
//  Oct 13 1995 larrys  Added code for CryptSetHashValue                   //
//  Oct 16 1995 larrys  Changes for CryptGetHashParam                      //
//  Oct 23 1995 larrys  Added code for GetProvParam PP_CONTAINER           //
//  Oct 27 1995 rajeshk RandSeed Stuff added hUID to PKCS2Encrypt+ others  //
//  Nov  3 1995 larrys  Merge changes for NT checkin                       //
//  Nov  9 1995 larrys  Bug fix 10686                                      //
//  Nov 30 1995 larrys  Bug fix                                            //
//  Dec 11 1995 larrys  Added WIN96 password cache                         //
//  Feb 29 1996 rajeshk Added Check for SetHashParam for HASHVALUE         //
//  May 15 1996 larrys  Added private key export                           //
//  May 28 1996 larrys  Fix bug 88                                         //
//  Jun  6 1996 a-johnb Added support for SSL 3.0 signatures               //
//  Aug 28 1996 mattt   Changed enum to calculate size from #defined sizes //
//  Sep 13 1996 mattt   Compat w/RSABase 88-bit 0 salt, FIsLegalKey()      //
//  Sep 16 1996 mattt   Added KP_KEYLEN ability                            //
//  Sep 16 1996 jeffspel Added triple DES functionality                    //
//  Oct 14 1996 jeffspel Changed GenRandoms to NewGenRandoms               //
//  Apr 29 1997 jeffspel Key storage ability GetProvParam, PStore support  //
//  Apr 29 1997 jeffspel Added EnumAlgsEx tp GetProvParam                  //
//  May 23 1997 jeffspel Added provider type checking                      //
//  Jul 15 1997 jeffspel Added ability to decrypt with large RC2 keys      //
//  Jul 28 1997 jeffspel Added ability to delete a persisted key           //
//  Sep 09 1997 jeffspel Added PP_KEYSET_TYPE to CPGetProvParam            //
//  Sep 12 1997 jeffspel Added Opaque blob support                         //
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "nt_rsa.h"
#include "nt_blobs.h"
#include "swnt_pk.h"
#include "mac.h"
#include "ntagimp1.h"
#include "tripldes.h"
#include "ntagum.h"
#include "randlib.h"
#ifdef CSP_USE_SSL3
#include "ssl3.h"
#endif
#include "protstor.h"
#include "sgccheck.h"

extern CSP_STRINGS g_Strings;

#define     SUPPORTED_PROTOCOLS     \
            CRYPT_FLAG_PCT1 | CRYPT_FLAG_SSL2 | CRYPT_FLAG_SSL3 | CRYPT_FLAG_TLS1

#define SSL3SHAMD5LEN   (MD5DIGESTLEN+A_SHA_DIGEST_LEN)*8

#define UnsupportedSymKey(pKey) ((CALG_RC4 != pKey->Algid) && \
                                 (CALG_RC2 != pKey->Algid) && \
                                 (CALG_DES != pKey->Algid) && \
                                 (CALG_3DES != pKey->Algid) && \
                                 (CALG_3DES_112 != pKey->Algid))

typedef struct enumalgs {
    ALG_ID    aiAlgid;
    DWORD     dwBitLen;
    DWORD     dwNameLen;
    CHAR      szName[20];
} ENUMALGS;

typedef struct enumalgsex {
    ALG_ID    aiAlgid;
    DWORD     dwDefault;
    DWORD     dwMin;
    DWORD     dwMax;
    DWORD     dwProtocols;
    DWORD     dwNameLen;
    CHAR      szName[20];
    DWORD     dwLongNameLen;
    CHAR      szLongName[40];
} ENUMALGSEX;

const ENUMALGS EnumSig[] =
{
// ALGID            BitLen                              NameLen  szName
#ifdef CSP_USE_SHA
   CALG_SHA,        A_SHA_DIGEST_LEN*8,                 6,     "SHA-1",
#endif

#ifdef CSP_USE_MD2
   CALG_MD2,        MD2DIGESTLEN*8,                     4,     "MD2",
#endif

#ifdef CSP_USE_MD4
   CALG_MD4,        MD4DIGESTLEN*8,                     4,     "MD4",
#endif

#ifdef CSP_USE_MD5
   CALG_MD5,        MD5DIGESTLEN*8,                     4,     "MD5",
#endif

   CALG_SSL3_SHAMD5,SSL3SHAMD5LEN,                      12,    "SSL3 SHAMD5",

   CALG_RSA_SIGN,   RSA_DEF_SIGN_MODLEN*8,              9,     "RSA_SIGN",

   0,               0,                                  0,     0
};

const ENUMALGS EnumFull[] =
{
// ALGID            BitLen                              NameLen  szName
#ifdef CSP_USE_RC2
   CALG_RC2,        RC2_DEF_KEYSIZE*8,                  4,     "RC2",
#endif

#ifdef CSP_USE_RC4
   CALG_RC4,        RC4_DEF_KEYSIZE*8,                  4,     "RC4",
#endif

#ifdef CSP_USE_DES
   CALG_DES,        (DES_KEYSIZE-1)*8,                  4,     "DES",
#endif

#ifdef STRONG
#ifdef CSP_USE_3DES
   CALG_3DES_112,   (DES2_KEYSIZE-2)*8,                 13,    "3DES TWO KEY",

   CALG_3DES,       (DES3_KEYSIZE-3)*8,                 5,     "3DES",
#endif
#endif // STRONG

#ifdef CSP_USE_SHA
   CALG_SHA,        A_SHA_DIGEST_LEN*8,                 6,     "SHA-1",
#endif

#ifdef CSP_USE_MD2
   CALG_MD2,        MD2DIGESTLEN*8,                     4,     "MD2",
#endif

#ifdef CSP_USE_MD4
   CALG_MD4,        MD4DIGESTLEN*8,                     4,     "MD4",
#endif

#ifdef CSP_USE_MD5
   CALG_MD5,        MD5DIGESTLEN*8,                     4,     "MD5",
#endif

   CALG_SSL3_SHAMD5,SSL3SHAMD5LEN,                      12,    "SSL3 SHAMD5",

#ifdef CSP_USE_MAC
   CALG_MAC,        64,                                 4,     "MAC",
#endif

   CALG_RSA_SIGN,   RSA_DEF_SIGN_MODLEN*8,              9,     "RSA_SIGN",

   CALG_RSA_KEYX,   RSA_DEF_EXCH_MODLEN*8,              9,     "RSA_KEYX",

   CALG_HMAC,       0,                                  5,     "HMAC",

   0,               0,                                  0,     0

};

const ENUMALGS EnumFullFrance[] =
{
// ALGID            BitLen                              NameLen  szName
#ifdef CSP_USE_RC2
   CALG_RC2,        RC2_DEF_KEYSIZE*8,                  4,     "RC2",
#endif

#ifdef CSP_USE_RC4
   CALG_RC4,        RC4_DEF_KEYSIZE*8,                  4,     "RC4",
#endif

#ifdef CSP_USE_SHA
   CALG_SHA,        A_SHA_DIGEST_LEN*8,                 6,     "SHA-1",
#endif

#ifdef CSP_USE_MD2
   CALG_MD2,        MD2DIGESTLEN*8,                     4,     "MD2",
#endif

#ifdef CSP_USE_MD4
   CALG_MD4,        MD4DIGESTLEN*8,                     4,     "MD4",
#endif

#ifdef CSP_USE_MD5
   CALG_MD5,        MD5DIGESTLEN*8,                     4,     "MD5",
#endif

   CALG_SSL3_SHAMD5,SSL3SHAMD5LEN,                      12,    "SSL3 SHAMD5",

#ifdef CSP_USE_MAC
   CALG_MAC,        64,                                 4,     "MAC",
#endif

   CALG_RSA_SIGN,   RSA_DEF_SIGN_MODLEN*8,              9,     "RSA_SIGN",

   CALG_RSA_KEYX,   RSA_DEF_EXCH_MODLEN*8,              9,     "RSA_KEYX",

   CALG_HMAC,       0,                                  5,     "HMAC",

   0,               0,                                  0,     0

};

#ifdef STRONG
const ENUMALGS EnumFullNewStrong[] =
{
// ALGID            BitLen                              NameLen  szName
#ifdef CSP_USE_RC2
   CALG_RC2,        RC2_DEF_NEWSTRONG_KEYSIZE*8,        4,     "RC2",
#endif

#ifdef CSP_USE_RC4
   CALG_RC4,        RC4_DEF_NEWSTRONG_KEYSIZE*8,        4,     "RC4",
#endif

#ifdef CSP_USE_DES
   CALG_DES,        (DES_KEYSIZE-1)*8,                  4,     "DES",
#endif

#ifdef CSP_USE_3DES
   CALG_3DES_112,   (DES2_KEYSIZE-2)*8,                 13,    "3DES TWO KEY",

   CALG_3DES,       (DES3_KEYSIZE-3)*8,                 5,     "3DES",
#endif

#ifdef CSP_USE_SHA
   CALG_SHA,        A_SHA_DIGEST_LEN*8,                 6,     "SHA-1",
#endif

#ifdef CSP_USE_MD2
   CALG_MD2,        MD2DIGESTLEN*8,                     4,     "MD2",
#endif

#ifdef CSP_USE_MD4
   CALG_MD4,        MD4DIGESTLEN*8,                     4,     "MD4",
#endif

#ifdef CSP_USE_MD5
   CALG_MD5,        MD5DIGESTLEN*8,                     4,     "MD5",
#endif

   CALG_SSL3_SHAMD5,SSL3SHAMD5LEN,                      12,    "SSL3 SHAMD5",

#ifdef CSP_USE_MAC
   CALG_MAC,        64,                                 4,     "MAC",
#endif

   CALG_RSA_SIGN,   RSA_DEF_NEWSTRONG_SIGN_MODLEN*8,    9,     "RSA_SIGN",

   CALG_RSA_KEYX,   RSA_DEF_NEWSTRONG_EXCH_MODLEN*8,    9,     "RSA_KEYX",

   CALG_HMAC,       0,                                  5,     "HMAC",

   0,               0,                                  0,     0

};
#endif // STRONG

const ENUMALGS EnumSch[] =
{
// ALGID            BitLen                              NameLen  szName
#ifdef CSP_USE_RC2
   CALG_RC2,        RC2_DEF_KEYSIZE*8,                  4,     "RC2",
#endif

#ifdef CSP_USE_RC4
   CALG_RC4,        RC4_DEF_KEYSIZE*8,                  4,     "RC4",
#endif

#ifdef CSP_USE_DES
   CALG_DES,        (DES_KEYSIZE-1)*8,                  4,     "DES",
#endif

#ifdef STRONG
#ifdef CSP_USE_3DES
   CALG_3DES_112,   (DES2_KEYSIZE-2)*8,                 13,    "3DES TWO KEY",

   CALG_3DES,       (DES3_KEYSIZE-3)*8,                 5,     "3DES",
#endif
#endif // STRONG

#ifdef CSP_USE_SHA
   CALG_SHA,        A_SHA_DIGEST_LEN*8,                 6,     "SHA-1",
#endif

#ifdef CSP_USE_MD5
   CALG_MD5,        MD5DIGESTLEN*8,                     4,     "MD5",
#endif

   CALG_SSL3_SHAMD5,SSL3SHAMD5LEN,                      12,    "SSL3 SHAMD5",

#ifdef CSP_USE_MAC
   CALG_MAC,        64,                                 4,     "MAC",
#endif

   CALG_RSA_SIGN,   RSA_DEF_EXCH_MODLEN*8,              9,     "RSA_SIGN",

   CALG_RSA_KEYX,   RSA_DEF_EXCH_MODLEN*8,              9,     "RSA_KEYX",

   CALG_HMAC,       0,                                  5,     "HMAC",

   0,               0,                                  0,     0

};

const ENUMALGS EnumSchSGC[] =
{
// ALGID            BitLen                              NameLen  szName
#ifdef CSP_USE_RC2
   CALG_RC2,        SGC_RC2_DEF_KEYSIZE*8,              4,     "RC2",
#endif

#ifdef CSP_USE_RC4
   CALG_RC4,        SGC_RC4_DEF_KEYSIZE*8,              4,     "RC4",
#endif

#ifdef CSP_USE_DES
   CALG_DES,        (DES_KEYSIZE-1)*8,                  4,     "DES",
#endif

#ifdef CSP_USE_3DES
   CALG_3DES_112,   (DES2_KEYSIZE-2)*8,                 13,    "3DES TWO KEY",

   CALG_3DES,       (DES3_KEYSIZE-3)*8,                 5,     "3DES",
#endif

#ifdef CSP_USE_SHA
   CALG_SHA,        A_SHA_DIGEST_LEN*8,                 6,     "SHA-1",
#endif

#ifdef CSP_USE_MD5
   CALG_MD5,        MD5DIGESTLEN*8,                     4,     "MD5",
#endif

   CALG_SSL3_SHAMD5,SSL3SHAMD5LEN,                      12,    "SSL3 SHAMD5",

#ifdef CSP_USE_MAC
   CALG_MAC,        64,                                 4,     "MAC",
#endif

   CALG_RSA_SIGN,   SGC_RSA_DEF_EXCH_MODLEN*8,          9,     "RSA_SIGN",

   CALG_RSA_KEYX,   SGC_RSA_DEF_EXCH_MODLEN*8,          9,     "RSA_KEYX",

   CALG_HMAC,       0,                                  5,     "HMAC",

   0,               0,                                  0,     0

};

const ENUMALGSEX EnumExSig[] =
{
// ALGID            Default         Min             Max             Protocols            
//                  NameLen  szName     LongNameLen LongName
#ifdef CSP_USE_SHA
   CALG_SHA,        A_SHA_DIGEST_LEN*8, A_SHA_DIGEST_LEN*8, A_SHA_DIGEST_LEN*8, CRYPT_FLAG_SIGNING,
                    6,     "SHA-1",     30, "Secure Hash Algorithm (SHA-1)",
#endif

#ifdef CSP_USE_MD2
   CALG_MD2,        MD2DIGESTLEN*8, MD2DIGESTLEN*8, MD2DIGESTLEN*8, CRYPT_FLAG_SIGNING,
                    4,     "MD2",       23, "Message Digest 2 (MD2)",
#endif

#ifdef CSP_USE_MD4
   CALG_MD4,        MD4DIGESTLEN*8, MD4DIGESTLEN*8, MD4DIGESTLEN*8, CRYPT_FLAG_SIGNING,
                    4,     "MD4",       23, "Message Digest 4 (MD4)",
#endif

#ifdef CSP_USE_MD5
   CALG_MD5,        MD5DIGESTLEN*8, MD5DIGESTLEN*8, MD5DIGESTLEN*8, CRYPT_FLAG_SIGNING,
                    4,     "MD5",       23, "Message Digest 5 (MD5)",
#endif

   CALG_SSL3_SHAMD5,SSL3SHAMD5LEN,  SSL3SHAMD5LEN,  SSL3SHAMD5LEN,  0,
                    12,     "SSL3 SHAMD5", 12,     "SSL3 SHAMD5",

   CALG_RSA_SIGN,   RSA_DEF_SIGN_MODLEN*8, RSA_MIN_SIGN_MODLEN*8, RSA_MAX_SIGN_MODLEN*8, CRYPT_FLAG_SIGNING,
                    9,     "RSA_SIGN",  14, "RSA Signature",

   0,               0,              0,              0,              0,
                    0,     0,           0,  0

};

const ENUMALGSEX EnumExFull[] =
{
// ALGID            Default         Min             Max             Protocols            
//                  NameLen  szName     LongNameLen LongName
#ifdef CSP_USE_RC2
   CALG_RC2,        RC2_DEF_KEYSIZE*8,  RC2_MIN_KEYSIZE*8,  RC2_MAX_KEYSIZE*8,  0,
                    4,      "RC2",      24, "RSA Data Security's RC2",
#endif

#ifdef CSP_USE_RC4
   CALG_RC4,        RC4_DEF_KEYSIZE*8,  RC4_MIN_KEYSIZE*8,  RC4_MAX_KEYSIZE*8,  0,
                    4,     "RC4",       24, "RSA Data Security's RC4",
#endif

#ifdef CSP_USE_DES
   CALG_DES,        56,             56,             56,             0,
                    4,     "DES",       31, "Data Encryption Standard (DES)",
#endif

#ifdef STRONG
#ifdef CSP_USE_3DES
   CALG_3DES_112,   112,            112,            112,            0,
                    13,    "3DES TWO KEY", 19, "Two Key Triple DES",

   CALG_3DES,       168,            168,            168,            0,
                    5,     "3DES",      21, "Three Key Triple DES",
#endif
#endif // STRONG

#ifdef CSP_USE_SHA
   CALG_SHA,        A_SHA_DIGEST_LEN*8, A_SHA_DIGEST_LEN*8, A_SHA_DIGEST_LEN*8, CRYPT_FLAG_SIGNING,
                    6,     "SHA-1",     30, "Secure Hash Algorithm (SHA-1)",
#endif

#ifdef CSP_USE_MD2
   CALG_MD2,        MD2DIGESTLEN*8, MD2DIGESTLEN*8, MD2DIGESTLEN*8, CRYPT_FLAG_SIGNING,
                    4,     "MD2",       23, "Message Digest 2 (MD2)",
#endif

#ifdef CSP_USE_MD4
   CALG_MD4,        MD4DIGESTLEN*8, MD4DIGESTLEN*8, MD4DIGESTLEN*8, CRYPT_FLAG_SIGNING,
                    4,     "MD4",       23, "Message Digest 4 (MD4)",
#endif

#ifdef CSP_USE_MD5
   CALG_MD5,        MD5DIGESTLEN*8, MD5DIGESTLEN*8, MD5DIGESTLEN*8, CRYPT_FLAG_SIGNING,
                    4,     "MD5",       23, "Message Digest 5 (MD5)",
#endif

   CALG_SSL3_SHAMD5,SSL3SHAMD5LEN,  SSL3SHAMD5LEN,  SSL3SHAMD5LEN,  0,
                    12,     "SSL3 SHAMD5", 12,     "SSL3 SHAMD5",

#ifdef CSP_USE_MAC
   CALG_MAC,        0,              0,              0,              0,
                    4,     "MAC",       28, "Message Authentication Code",
#endif

   CALG_RSA_SIGN,   RSA_DEF_SIGN_MODLEN*8, RSA_MIN_SIGN_MODLEN*8, RSA_MAX_SIGN_MODLEN*8,
   CRYPT_FLAG_IPSEC | CRYPT_FLAG_SIGNING,
   9,     "RSA_SIGN",  14, "RSA Signature",

   CALG_RSA_KEYX,   RSA_DEF_EXCH_MODLEN*8, RSA_MIN_EXCH_MODLEN*8, RSA_MAX_EXCH_MODLEN*8,
   CRYPT_FLAG_IPSEC | CRYPT_FLAG_SIGNING,
   9,     "RSA_KEYX",  17, "RSA Key Exchange",

   CALG_HMAC,       0,              0,              0,              0,
                    5,     "HMAC",      18, "Hugo's MAC (HMAC)",

   0,               0,              0,              0,              0,
                    0,     0,           0,  0
};

#ifdef STRONG
const ENUMALGSEX EnumExFullNewStrong[] =
{
// ALGID            Default         Min             Max             Protocols            
//                  NameLen  szName     LongNameLen LongName
#ifdef CSP_USE_RC2
   CALG_RC2,        RC2_DEF_NEWSTRONG_KEYSIZE*8,  RC2_MIN_KEYSIZE*8,  RC2_MAX_KEYSIZE*8,  0,
                    4,      "RC2",      24, "RSA Data Security's RC2",
#endif

#ifdef CSP_USE_RC4
   CALG_RC4,        RC4_DEF_NEWSTRONG_KEYSIZE*8,  RC4_MIN_KEYSIZE*8,  RC4_MAX_KEYSIZE*8,  0,
                    4,     "RC4",       24, "RSA Data Security's RC4",
#endif

#ifdef CSP_USE_DES
   CALG_DES,        56,             56,             56,             0,
                    4,     "DES",       31, "Data Encryption Standard (DES)",
#endif

#ifdef CSP_USE_3DES
   CALG_3DES_112,   112,            112,            112,            0,
                    13,    "3DES TWO KEY", 19, "Two Key Triple DES",

   CALG_3DES,       168,            168,            168,            0,
                    5,     "3DES",      21, "Three Key Triple DES",
#endif

#ifdef CSP_USE_SHA
   CALG_SHA,        A_SHA_DIGEST_LEN*8, A_SHA_DIGEST_LEN*8, A_SHA_DIGEST_LEN*8, CRYPT_FLAG_SIGNING,
                    6,     "SHA-1",     30, "Secure Hash Algorithm (SHA-1)",
#endif

#ifdef CSP_USE_MD2
   CALG_MD2,        MD2DIGESTLEN*8, MD2DIGESTLEN*8, MD2DIGESTLEN*8, CRYPT_FLAG_SIGNING,
                    4,     "MD2",       23, "Message Digest 2 (MD2)",
#endif

#ifdef CSP_USE_MD4
   CALG_MD4,        MD4DIGESTLEN*8, MD4DIGESTLEN*8, MD4DIGESTLEN*8, CRYPT_FLAG_SIGNING,
                    4,     "MD4",       23, "Message Digest 4 (MD4)",
#endif

#ifdef CSP_USE_MD5
   CALG_MD5,        MD5DIGESTLEN*8, MD5DIGESTLEN*8, MD5DIGESTLEN*8, CRYPT_FLAG_SIGNING,
                    4,     "MD5",       23, "Message Digest 5 (MD5)",
#endif

   CALG_SSL3_SHAMD5,SSL3SHAMD5LEN,  SSL3SHAMD5LEN,  SSL3SHAMD5LEN,  0,
                    12,     "SSL3 SHAMD5", 12,     "SSL3 SHAMD5",

#ifdef CSP_USE_MAC
   CALG_MAC,        0,              0,              0,              0,
                    4,     "MAC",       28, "Message Authentication Code",
#endif

   CALG_RSA_SIGN,   RSA_DEF_NEWSTRONG_SIGN_MODLEN*8, RSA_MIN_SIGN_MODLEN*8, RSA_MAX_SIGN_MODLEN*8,
   CRYPT_FLAG_IPSEC | CRYPT_FLAG_SIGNING,
   9,     "RSA_SIGN",  14, "RSA Signature",

   CALG_RSA_KEYX,   RSA_DEF_NEWSTRONG_EXCH_MODLEN*8, RSA_MIN_EXCH_MODLEN*8, RSA_MAX_EXCH_MODLEN*8,
   CRYPT_FLAG_IPSEC | CRYPT_FLAG_SIGNING,
   9,     "RSA_KEYX",  17, "RSA Key Exchange",

   CALG_HMAC,       0,              0,              0,              0,
                    5,     "HMAC",      18, "Hugo's MAC (HMAC)",

   0,               0,              0,              0,              0,
                    0,     0,           0,  0
};
#endif // STRONG

const ENUMALGSEX EnumExFullFrance[] =
{
// ALGID            Default         Min             Max             Protocols            
//                  NameLen  szName     LongNameLen LongName
#ifdef CSP_USE_RC2
   CALG_RC2,        RC2_DEF_KEYSIZE*8,  RC2_MIN_KEYSIZE*8,  RC2_MAX_FRENCH_KEYSIZE*8,  0,
                    4,      "RC2",      24, "RSA Data Security's RC2",
#endif

#ifdef CSP_USE_RC4
   CALG_RC4,        RC4_DEF_KEYSIZE*8,  RC4_MIN_KEYSIZE*8,  RC4_MAX_FRENCH_KEYSIZE*8,  0,
                    4,     "RC4",       24, "RSA Data Security's RC4",
#endif

#ifdef CSP_USE_SHA
   CALG_SHA,        A_SHA_DIGEST_LEN*8, A_SHA_DIGEST_LEN*8, A_SHA_DIGEST_LEN*8, CRYPT_FLAG_SIGNING,
                    6,     "SHA-1",     30, "Secure Hash Algorithm (SHA-1)",
#endif

#ifdef CSP_USE_MD2
   CALG_MD2,        MD2DIGESTLEN*8, MD2DIGESTLEN*8, MD2DIGESTLEN*8, CRYPT_FLAG_SIGNING,
                    4,     "MD2",       23, "Message Digest 2 (MD2)",
#endif

#ifdef CSP_USE_MD4
   CALG_MD4,        MD4DIGESTLEN*8, MD4DIGESTLEN*8, MD4DIGESTLEN*8, CRYPT_FLAG_SIGNING,
                    4,     "MD4",       23, "Message Digest 4 (MD4)",
#endif

#ifdef CSP_USE_MD5
   CALG_MD5,        MD5DIGESTLEN*8, MD5DIGESTLEN*8, MD5DIGESTLEN*8, CRYPT_FLAG_SIGNING,
                    4,     "MD5",       23, "Message Digest 5 (MD5)",
#endif

   CALG_SSL3_SHAMD5,SSL3SHAMD5LEN,  SSL3SHAMD5LEN,  SSL3SHAMD5LEN,  0,
                    12,     "SSL3 SHAMD5", 12,     "SSL3 SHAMD5",

#ifdef CSP_USE_MAC
   CALG_MAC,        0,              0,              0,              0,
                    4,     "MAC",       28, "Message Authentication Code",
#endif

   CALG_RSA_SIGN,   RSA_DEF_SIGN_MODLEN*8, RSA_MIN_SIGN_MODLEN*8, RSA_MAX_SIGN_MODLEN*8,
   CRYPT_FLAG_IPSEC | CRYPT_FLAG_SIGNING,
   9,     "RSA_SIGN",  14, "RSA Signature",

   CALG_RSA_KEYX,   RSA_DEF_EXCH_MODLEN*8, RSA_MIN_EXCH_MODLEN*8, RSA_MAX_EXCH_FRENCH_MODLEN*8,
   CRYPT_FLAG_IPSEC | CRYPT_FLAG_SIGNING,
   9,     "RSA_KEYX",  17, "RSA Key Exchange",

   CALG_HMAC,       0,              0,              0,              0,
                    5,     "HMAC",      18, "Hugo's MAC (HMAC)",

   0,               0,              0,              0,              0,
                    0,     0,           0,  0
};

const ENUMALGSEX EnumExSch[] =
{
// ALGID            Default         Min             Max             Protocols            
//                  NameLen  szName     LongNameLen LongName
#ifdef CSP_USE_RC2
   CALG_RC2,        RC2_DEF_KEYSIZE*8,  RC2_MIN_KEYSIZE*8,  RC2_MAX_KEYSIZE*8,  SUPPORTED_PROTOCOLS,
                    4,      "RC2",      24, "RSA Data Security's RC2",
#endif

#ifdef CSP_USE_RC4
   CALG_RC4,        RC4_DEF_KEYSIZE*8,  RC4_MIN_KEYSIZE*8,  RC4_MAX_KEYSIZE*8,  SUPPORTED_PROTOCOLS,
                    4,     "RC4",       24, "RSA Data Security's RC4",
#endif

#ifdef CSP_USE_DES
   CALG_DES,        56,             56,             56,             SUPPORTED_PROTOCOLS,
                    4,     "DES",       31, "Data Encryption Standard (DES)",
#endif

#ifdef STRONG
#ifdef CSP_USE_3DES
   CALG_3DES_112,   112,            112,            112,            SUPPORTED_PROTOCOLS,
                    13,    "3DES TWO KEY", 19, "Two Key Triple DES",

   CALG_3DES,       168,            168,            168,            SUPPORTED_PROTOCOLS,
                    5,     "3DES",      21, "Three Key Triple DES",
#endif
#endif // STRONG

#ifdef CSP_USE_SHA
   CALG_SHA,        A_SHA_DIGEST_LEN*8, A_SHA_DIGEST_LEN*8, A_SHA_DIGEST_LEN*8,
        SUPPORTED_PROTOCOLS | CRYPT_FLAG_SIGNING,
                    6,     "SHA-1",     30, "Secure Hash Algorithm (SHA-1)",
#endif

#ifdef CSP_USE_MD5
   CALG_MD5,        MD5DIGESTLEN*8, MD5DIGESTLEN*8, MD5DIGESTLEN*8,
   SUPPORTED_PROTOCOLS | CRYPT_FLAG_SIGNING,
                    4,     "MD5",       23, "Message Digest 5 (MD5)",
#endif

   CALG_SSL3_SHAMD5,SSL3SHAMD5LEN,  SSL3SHAMD5LEN,  SSL3SHAMD5LEN,  0,
                    12,     "SSL3 SHAMD5", 12,     "SSL3 SHAMD5",

#ifdef CSP_USE_MAC
   CALG_MAC,        0,              0,              0,              0,
                    4,     "MAC",       28, "Message Authentication Code",
#endif

   CALG_RSA_SIGN,   RSA_DEF_EXCH_MODLEN*8, RSA_MIN_EXCH_MODLEN*8, RSA_MAX_EXCH_MODLEN*8,
   SUPPORTED_PROTOCOLS | CRYPT_FLAG_SIGNING,
                    9,     "RSA_SIGN",  14, "RSA Signature",

   CALG_RSA_KEYX,   RSA_DEF_EXCH_MODLEN*8, RSA_MIN_EXCH_MODLEN*8, RSA_MAX_EXCH_MODLEN*8,
   SUPPORTED_PROTOCOLS | CRYPT_FLAG_SIGNING,
                    9,     "RSA_KEYX",  17, "RSA Key Exchange",

   CALG_HMAC,       0,              0,              0,              0,
                    5,     "HMAC",      18, "Hugo's MAC (HMAC)",

   0,               0,              0,              0,              0,
                    0,     0,           0,  0
};

const ENUMALGSEX EnumExSchFrance[] =
{
// ALGID            Default         Min             Max             Protocols            
//                  NameLen  szName     LongNameLen LongName
#ifdef CSP_USE_RC2
   CALG_RC2,        RC2_DEF_KEYSIZE*8,  RC2_MIN_KEYSIZE*8,  RC2_MAX_FRENCH_KEYSIZE*8,  SUPPORTED_PROTOCOLS,
                    4,      "RC2",      24, "RSA Data Security's RC2",
#endif

#ifdef CSP_USE_RC4
   CALG_RC4,        RC4_DEF_KEYSIZE*8,  RC4_MIN_KEYSIZE*8,  RC4_MAX_FRENCH_KEYSIZE*8,  SUPPORTED_PROTOCOLS,
                    4,     "RC4",       24, "RSA Data Security's RC4",
#endif

#ifdef CSP_USE_SHA
   CALG_SHA,        A_SHA_DIGEST_LEN*8, A_SHA_DIGEST_LEN*8, A_SHA_DIGEST_LEN*8, SUPPORTED_PROTOCOLS | CRYPT_FLAG_SIGNING,
                    6,     "SHA-1",     30, "Secure Hash Algorithm (SHA-1)",
#endif

#ifdef CSP_USE_MD5
   CALG_MD5,        MD5DIGESTLEN*8, MD5DIGESTLEN*8, MD5DIGESTLEN*8, SUPPORTED_PROTOCOLS | CRYPT_FLAG_SIGNING,
                    4,     "MD5",       23, "Message Digest 5 (MD5)",
#endif

   CALG_SSL3_SHAMD5,SSL3SHAMD5LEN,  SSL3SHAMD5LEN,  SSL3SHAMD5LEN,  0,
                    12,     "SSL3 SHAMD5", 12,     "SSL3 SHAMD5",

#ifdef CSP_USE_MAC
   CALG_MAC,        0,              0,              0,              0,
                    4,     "MAC",       28, "Message Authentication Code",
#endif

   CALG_RSA_SIGN,   RSA_DEF_EXCH_MODLEN*8, RSA_MIN_EXCH_MODLEN*8, RSA_MAX_EXCH_FRENCH_MODLEN*8, SUPPORTED_PROTOCOLS | CRYPT_FLAG_SIGNING,
                    9,     "RSA_SIGN",  14, "RSA Signature",

   CALG_RSA_KEYX,   RSA_DEF_EXCH_MODLEN*8, RSA_MIN_EXCH_MODLEN*8, RSA_MAX_EXCH_FRENCH_MODLEN*8, SUPPORTED_PROTOCOLS | CRYPT_FLAG_SIGNING,
                    9,     "RSA_KEYX",  17, "RSA Key Exchange",

   CALG_HMAC,       0,              0,              0,              0,
                    5,     "HMAC",      18, "Hugo's MAC (HMAC)",

   0,               0,              0,              0,              0,
                    0,     0,           0,  0
};

const ENUMALGSEX EnumExSchSGC[] =
{
// ALGID            Default         Min             Max             Protocols            
//                  NameLen  szName     LongNameLen LongName
#ifdef CSP_USE_RC2
   CALG_RC2,        SGC_RC2_DEF_KEYSIZE*8,  RC2_MIN_KEYSIZE*8,  SGC_RC2_MAX_KEYSIZE*8,  SUPPORTED_PROTOCOLS,
                    4,      "RC2",      24, "RSA Data Security's RC2",
#endif

#ifdef CSP_USE_RC4
   CALG_RC4,        SGC_RC4_DEF_KEYSIZE*8,  RC4_MIN_KEYSIZE*8,  SGC_RC4_MAX_KEYSIZE*8,  SUPPORTED_PROTOCOLS,
                    4,     "RC4",       24, "RSA Data Security's RC4",
#endif

#ifdef CSP_USE_DES
   CALG_DES,        56,             56,             56,             SUPPORTED_PROTOCOLS,
                    4,     "DES",       31, "Data Encryption Standard (DES)",
#endif

#ifdef CSP_USE_3DES
   CALG_3DES_112,   112,            112,            112,            SUPPORTED_PROTOCOLS,
                    13,    "3DES TWO KEY", 19, "Two Key Triple DES",

   CALG_3DES,       168,            168,            168,            SUPPORTED_PROTOCOLS,
                    5,     "3DES",      21, "Three Key Triple DES",
#endif

#ifdef CSP_USE_SHA
   CALG_SHA,        A_SHA_DIGEST_LEN*8, A_SHA_DIGEST_LEN*8, A_SHA_DIGEST_LEN*8,
   SUPPORTED_PROTOCOLS | CRYPT_FLAG_SIGNING,
                    6,     "SHA-1",     30, "Secure Hash Algorithm (SHA-1)",
#endif

#ifdef CSP_USE_MD5
   CALG_MD5,        MD5DIGESTLEN*8, MD5DIGESTLEN*8, MD5DIGESTLEN*8,
   SUPPORTED_PROTOCOLS | CRYPT_FLAG_SIGNING,
                    4,     "MD5",       23, "Message Digest 5 (MD5)",
#endif

   CALG_SSL3_SHAMD5,SSL3SHAMD5LEN,  SSL3SHAMD5LEN,  SSL3SHAMD5LEN, 0,
                    12,     "SSL3 SHAMD5", 12,     "SSL3 SHAMD5",

#ifdef CSP_USE_MAC
   CALG_MAC,        0,              0,              0,              0,
                    4,     "MAC",       28, "Message Authentication Code",
#endif

   CALG_RSA_SIGN,   SGC_RSA_DEF_EXCH_MODLEN*8, RSA_MIN_EXCH_MODLEN*8, SGC_RSA_MAX_EXCH_MODLEN*8,
   SUPPORTED_PROTOCOLS | CRYPT_FLAG_SIGNING,
                    9,     "RSA_SIGN",  14, "RSA Signature",

   CALG_RSA_KEYX,   SGC_RSA_DEF_EXCH_MODLEN*8, RSA_MIN_EXCH_MODLEN*8, SGC_RSA_MAX_EXCH_MODLEN*8,
   SUPPORTED_PROTOCOLS | CRYPT_FLAG_SIGNING,
                    9,     "RSA_KEYX",  17, "RSA Key Exchange",

   CALG_HMAC,       0,              0,              0,              0,
                    5,     "HMAC",      18, "Hugo's MAC (HMAC)",

   0,               0,              0,              0,              0,
                    0,     0,           0,  0
};

#define NTAG_REG_KEY_LOC    "Software\\Microsoft\\Cryptography\\UserKeys"
#define NTAG_MACH_REG_KEY_LOC   "Software\\Microsoft\\Cryptography\\MachineKeys"

BOOL CPInflateKey(
                  IN PNTAGKeyList pTmpKey
                  );

BOOL CopyKey(
             IN PNTAGKeyList pOldKey,
             OUT PNTAGKeyList *ppNewKey);

BOOL SymEncrypt(
                IN PNTAGKeyList pKey,
                IN BOOL fFinal,
                IN OUT BYTE *pbData,
                IN OUT DWORD *pcbData,
                IN DWORD cbBuf
                );

BOOL SymDecrypt(
                IN PNTAGKeyList pKey,
                IN PNTAGHashList pHash,
                IN BOOL fFinal,
                IN OUT BYTE *pbData,
                IN OUT DWORD *pcbData
                );

BOOL BlockEncrypt(void EncFun(BYTE *In, BYTE *Out, void *key, int op),
                  PNTAGKeyList pKey,
                  int BlockLen,
                  BOOL Final,
                  BYTE  *pbData,
                  DWORD *pdwDataLen,
                  DWORD dwBufLen);

static BYTE rgbSymmetricKeyWrapIV[8] = {0x4a, 0xdd, 0xa2, 0x2c, 0x79, 0xe8, 0x21, 0x05};


//
// Set the permissions on the key
//
void SetInitialKeyPermissions(
                              PNTAGKeyList pKey
                              )
{
    if (CRYPT_EXPORTABLE == pKey->Rights)
    {
        pKey->Permissions |= CRYPT_EXPORT;
    }

    // UNDONE - set the appopropriate permission with the appropriate algorithm
    pKey->Permissions |= CRYPT_ENCRYPT | CRYPT_DECRYPT| CRYPT_READ |
                         CRYPT_WRITE | CRYPT_MAC;
}

/* MakeNewKey
 *
 *  Helper routine for ImportKey, GenKey
 *
 *  Allocate a new key record, fill in the data and copy in the key
 *  bytes.
 */
PNTAGKeyList MakeNewKey(
        ALG_ID      aiKeyAlg,
        DWORD       dwRights,
        DWORD       dwKeyLen,
        HCRYPTPROV  hUID,
        BYTE        *pbKeyData,
        BOOL        fUsePassedKeyBuffer
    )
{
    PNTAGKeyList    pKey = NULL;
    BSAFE_PUB_KEY   *pPubKey;
    BOOL            fSuccess = FALSE;

    // allocate space for the key record
    if ((pKey = (PNTAGKeyList)_nt_malloc(sizeof(NTAGKeyList))) == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Ret;
    }

    if (!fUsePassedKeyBuffer)
    {
        if ((pKey->pKeyValue = (BYTE *)_nt_malloc((size_t)dwKeyLen)) == NULL)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }
    }

    pKey->Algid = aiKeyAlg;
    pKey->Rights = dwRights;
    pKey->cbDataLen = 0;
    pKey->pData = NULL;
    pKey->hUID = hUID;
    memset(pKey->IV, 0, CRYPT_BLKLEN);
    memset(pKey->FeedBack, 0, CRYPT_BLKLEN);
    pKey->InProgress = FALSE;

    pKey->cbSaltLen = 0;

    pKey->Padding = PKCS5_PADDING;
    pKey->Mode = CRYPT_MODE_CBC;
    pKey->ModeBits = 0;

    SetInitialKeyPermissions(pKey);

    // for RC2 set a default effective key length
    if (CALG_RC2 == aiKeyAlg)
    {
        pKey->EffectiveKeyLen = RC2_DEFAULT_EFFECTIVE_KEYLEN;
    }

    pKey->cbKeyLen = dwKeyLen;
    if (pbKeyData != NULL)
    {
        if (fUsePassedKeyBuffer)
        {
            pKey->pKeyValue = pbKeyData;
        }
        else
        {
            memcpy (pKey->pKeyValue, pbKeyData, (size_t)dwKeyLen);
        }
    }

    pPubKey = (BSAFE_PUB_KEY *) pKey->pKeyValue;
    fSuccess = TRUE;
Ret:
    if (FALSE == fSuccess)
    {
        _nt_free (pKey, sizeof(NTAGKeyList));
        pKey = NULL;
    }
    return pKey;
}

/* FreeNewKey
 *
 *      Use for cleanup on abort of key build operations.
 *
 */

void FreeNewKey(PNTAGKeyList pOldKey)
{
    if (pOldKey->pKeyValue)
        _nt_free(pOldKey->pKeyValue, pOldKey->cbKeyLen);
    if (pOldKey->pData)
        _nt_free(pOldKey->pData, pOldKey->cbDataLen);
    _nt_free(pOldKey, sizeof(NTAGKeyList));
}

/* FIsLegalSGCKeySize
 *
 *      Check that the length of the key is SGC legal (essentially
 *      complies with export).
 *
 */

BOOL FIsLegalSGCKeySize(
                        IN ALG_ID Algid,
                        IN DWORD cbKey,
                        IN BOOL fRC2BigKeyOK,
                        IN BOOL fGenKey,
                        OUT BOOL *pfPubKey
                        )
{
    BOOL    fRet = FALSE;

    *pfPubKey = FALSE;

    switch (Algid)
    {
#ifdef CSP_USE_RC4
        case CALG_RC4:
        {
            // legality check
            if (fGenKey || (cbKey < RC4_MIN_KEYSIZE) ||
                (cbKey > SGC_RC4_MAX_KEYSIZE))
            {
                goto Ret;
            }
            break;
        }
#endif

#ifdef CSP_USE_RC2
        case CALG_RC2:
        {
            if (!fRC2BigKeyOK)
            {
                if (fGenKey || (cbKey < RC2_MIN_KEYSIZE) ||
                    (cbKey > SGC_RC2_MAX_KEYSIZE))
                {
                    goto Ret;
                }
            }
            break;
        }
#endif

#ifdef CSP_USE_DES
        case CALG_DES:
        {
            if (fGenKey || (cbKey > DES_KEYSIZE))
                goto Ret;
            break;
        }
#endif

#ifdef CSP_USE_3DES
        case CALG_3DES_112:
        {
            if (fGenKey || (cbKey > DES2_KEYSIZE))
                goto Ret;
            break;
        }
        case CALG_3DES:
        {
            if (fGenKey || (cbKey > DES3_KEYSIZE))
                goto Ret;
            break;
        }
#endif

#ifdef CSP_USE_SSL3
        case CALG_SSL3_MASTER:
        case CALG_TLS1_MASTER:
        {
            if (cbKey != SSL3_MASTER_KEYSIZE)
                goto Ret;
            break;
        }

        case CALG_PCT1_MASTER:
        {
            if (cbKey != PCT1_MASTER_KEYSIZE)
                goto Ret;
            break;
        }

        case CALG_SSL2_MASTER:
        {
            if (cbKey > SSL2_MAX_MASTER_KEYSIZE)
                goto Ret;
            break;
        }

        case CALG_SCHANNEL_MAC_KEY:
        {
            break;
        }
#endif

        case CALG_RSA_KEYX:
            if ((cbKey > SGC_RSA_MAX_EXCH_MODLEN) ||
                (cbKey < RSA_MIN_EXCH_MODLEN))
            {
                SetLastError((DWORD) NTE_BAD_FLAGS);
                goto Ret;
            }
            *pfPubKey = TRUE;
            break;

        default:
            SetLastError((DWORD) NTE_BAD_ALGID);
            goto Ret;
            break;
    }

    fRet = TRUE;
Ret:
    // not of regulation size
    if (FALSE == fRet)
        SetLastError((DWORD)NTE_BAD_FLAGS);
    return fRet;
}

/* FIsLegalFrenchKeySize
 *
 *      Check that the length of the key is legal (essentially
 *      complies with export).
 *
 */

BOOL FIsLegalFrenchKeySize(
                           IN ALG_ID Algid,
                           IN DWORD cbKey,
                           IN BOOL fRC2BigKeyOK,
                           IN DWORD dwFlags,
                           OUT BOOL *pfPubKey
                           )
{
    BOOL    fRet = FALSE;

    *pfPubKey = FALSE;

    switch (Algid)
    {
#ifdef CSP_USE_RC4
        case CALG_RC4:
        {
            // legality check
            if ((cbKey < RC4_MIN_KEYSIZE) ||
                (cbKey > RC4_MAX_FRENCH_KEYSIZE))
            {
                goto Ret;
            }
            break;
        }
#endif

#ifdef CSP_USE_RC2
        case CALG_RC2:
        {
            if (!fRC2BigKeyOK)
            {
                if ((cbKey < RC2_MIN_KEYSIZE) ||
                    (cbKey > RC2_MAX_FRENCH_KEYSIZE))
                {
                    goto Ret;
                }
            }
            break;
        }
#endif

#ifdef CSP_USE_SSL3
        case CALG_SSL3_MASTER:
        {
            if (cbKey != SSL3_MASTER_KEYSIZE)
                goto Ret;
            break;
        }

        case CALG_SSL2_MASTER:
        {
            if (cbKey > SSL2_MAX_MASTER_KEYSIZE)
                goto Ret;
            break;
        }

        case CALG_SCHANNEL_MAC_KEY:
        {
            break;
        }
#endif

        case CALG_RSA_SIGN:
            if ((cbKey > RSA_MAX_SIGN_MODLEN) ||
                (cbKey < RSA_MIN_SIGN_MODLEN))
            {
                SetLastError((DWORD) NTE_BAD_FLAGS);
                goto Ret;
            }
            *pfPubKey = TRUE;
            break;
        case CALG_RSA_KEYX:
            if ((cbKey > RSA_MAX_EXCH_FRENCH_MODLEN) ||
                (cbKey < RSA_MIN_EXCH_MODLEN))
            {
                SetLastError((DWORD) NTE_BAD_FLAGS);
                goto Ret;
            }
            *pfPubKey = TRUE;
            break;

        default:
            SetLastError((DWORD) NTE_BAD_ALGID);
            goto Ret;
            break;
    }

    fRet = TRUE;
Ret:
    // not of regulation size
    if (FALSE == fRet)
        SetLastError((DWORD)NTE_BAD_FLAGS);
    return fRet;
}

/* FIsLegalKeySize
 *
 *      Check that the length of the key is legal (essentially
 *      complies with export).
 *
 */

BOOL FIsLegalKeySize(
                     IN ALG_ID Algid,
                     IN DWORD cbKey,
                     IN BOOL fRC2BigKeyOK,
                     IN DWORD dwFlags,
                     OUT BOOL *pfPubKey
                     )
{
    BOOL    fRet = FALSE;

    *pfPubKey = FALSE;

    switch (Algid)
    {
#ifdef CSP_USE_RC4
        case CALG_RC4:
        {
            // legality check
            if ((cbKey < RC4_MIN_KEYSIZE) ||
                (cbKey > RC4_MAX_KEYSIZE))
            {
                goto Ret;
            }
            break;
        }
#endif

#ifdef CSP_USE_RC2
        case CALG_RC2:
        {
            if (!fRC2BigKeyOK)
            {
                if ((cbKey < RC2_MIN_KEYSIZE) ||
                    (cbKey > RC2_MAX_KEYSIZE))
                {
                    goto Ret;
                }
            }
            break;
        }
#endif

#ifdef CSP_USE_DES
        case CALG_DES:
        {
            if (cbKey > DES_KEYSIZE)
                goto Ret;
            break;
        }
#endif

#ifdef STRONG
#ifdef CSP_USE_3DES
        case CALG_3DES_112:
        {
            if (cbKey > DES2_KEYSIZE)
                goto Ret;
            break;
        }
        case CALG_3DES:
        {
            if (cbKey > DES3_KEYSIZE)
                goto Ret;
            break;
        }
#endif
#endif // STRONG

#ifdef CSP_USE_SSL3
        case CALG_SSL3_MASTER:
        case CALG_TLS1_MASTER:
        {
            if (cbKey != SSL3_MASTER_KEYSIZE)
                goto Ret;
            break;
        }

        case CALG_PCT1_MASTER:
        {
            if (cbKey != PCT1_MASTER_KEYSIZE)
                goto Ret;
            break;
        }

        case CALG_SSL2_MASTER:
        {
            if (cbKey > SSL2_MAX_MASTER_KEYSIZE)
                goto Ret;
            break;
        }

        case CALG_SCHANNEL_MAC_KEY:
        {
            break;
        }

#endif

        case CALG_RSA_SIGN:
            if ((cbKey > RSA_MAX_SIGN_MODLEN) ||
                (cbKey < RSA_MIN_SIGN_MODLEN))
            {
                SetLastError((DWORD) NTE_BAD_FLAGS);
                goto Ret;
            }
            *pfPubKey = TRUE;
            break;
        case CALG_RSA_KEYX:
            if (dwFlags & CRYPT_SGCKEY)
            {
                if (cbKey > SGC_RSA_MAX_EXCH_MODLEN)
                {
                    SetLastError((DWORD) NTE_BAD_FLAGS);
                    goto Ret;
                }
            }
            else
            {
                if ((cbKey > RSA_MAX_EXCH_MODLEN) ||
                    (cbKey < RSA_MIN_EXCH_MODLEN))
                {
                    SetLastError((DWORD) NTE_BAD_FLAGS);
                    goto Ret;
                }
            }
            *pfPubKey = TRUE;
            break;

        default:
            SetLastError((DWORD) NTE_BAD_ALGID);
            goto Ret;
            break;
    }

    fRet = TRUE;
Ret:
    // not of regulation size
    if (FALSE == fRet)
        SetLastError((DWORD)NTE_BAD_FLAGS);
    return fRet;
}

/* FIsLegalKey
 *
 *      Check that the length of the key is legal (essentially
 *      complies with export).
 *
 */

BOOL FIsLegalKey(
                 IN PNTAGUserList pTmpUser,
                 IN PNTAGKeyList pKey,
                 IN BOOL fRC2BigKeyOK
                 )
{
    BOOL    fPubKey;
    BOOL    fRet = FALSE;

    if (pKey == NULL)
    {
        SetLastError((DWORD)NTE_FAIL);
        goto Ret;
    }

    // check if the provider is an SChannel provider and if so if the
    // SGC flag is set then use the FIsLegalSGCKeySize function
    if ((PROV_RSA_SCHANNEL == pTmpUser->dwProvType) &&
        (0 != pTmpUser->dwSGCFlags))
    {
        if (!FIsLegalSGCKeySize(pKey->Algid, pKey->cbKeyLen,
                                fRC2BigKeyOK, FALSE, &fPubKey))
        {
            goto Ret;
        }
    }
    else
    {
        // if in France then different key sizes may apply
        if (pTmpUser->Rights & CRYPT_IN_FRANCE)
        {
            // 4th parameter, dwFlags, is used for SGC Exch keys so just
            // pass zero in this case
            if (!FIsLegalFrenchKeySize(pKey->Algid, pKey->cbKeyLen,
                                       fRC2BigKeyOK, 0, &fPubKey))
            {
                goto Ret;
            }
        }
        else
        {
            // 4th parameter, dwFlags, is used for SGC Exch keys so just
            // pass zero in this case
            if (!FIsLegalKeySize(pKey->Algid, pKey->cbKeyLen,
                                 fRC2BigKeyOK, 0, &fPubKey))
            {
                goto Ret;
            }
        }
    }

    fRet = TRUE;
Ret:
    return fRet;
}

BOOL MakeKeyRSABaseCompatible(
                            HCRYPTPROV hUID,
                            HCRYPTKEY  hKey)
{
    CRYPT_DATA_BLOB sSaltData;
    BYTE            rgbZeroSalt[11];

    ZeroMemory(rgbZeroSalt, 11);

    sSaltData.pbData = rgbZeroSalt;
    sSaltData.cbData = sizeof(rgbZeroSalt);
    if (!CPSetKeyParam(
               hUID,
               hKey,
               KP_SALT_EX,
               (PBYTE)&sSaltData,
               0))
        return FALSE;

    return TRUE;
}

typedef struct {
    DWORD       magic;                  /* Should always be RSA2 */
    DWORD       bitlen;                 // bit size of key
    DWORD       pubexp;                 // public exponent
} EXPORT_PRV_KEY, FAR *PEXPORT_PRV_KEY;

/* GetLengthOfPrivateKeyForExport
 *
 *      Get the length of the private key
 *      blob from the public key.
 *
 */

void GetLengthOfPrivateKeyForExport(
                                    IN BSAFE_PUB_KEY *pPubKey,
                                    IN DWORD PubKeyLen,
                                    OUT PDWORD pcbBlob
                                    )
{
    DWORD           cbHalfModLen;

    cbHalfModLen = (pPubKey->bitlen + 15) / 16;
    *pcbBlob = sizeof(EXPORT_PRV_KEY) + 9 * cbHalfModLen;
}

/* PreparePrivateKeyForExport
 *
 *      Massage the key from the registry
 *      into an exportable format.
 *
 */

BOOL PreparePrivateKeyForExport(
                                IN BSAFE_PRV_KEY *pPrvKey,
                                IN DWORD PrvKeyLen,
                                OUT PBYTE pbBlob,
                                IN OUT PDWORD pcbBlob
                                )
{
    PEXPORT_PRV_KEY pExportKey;
    DWORD           cbHalfModLen;
    DWORD           cbBlobLen;
    DWORD           cbTmpLen;
    DWORD           cbHalfTmpLen;
    PBYTE           pbIn;
    PBYTE           pbOut;

    cbHalfModLen = (pPrvKey->bitlen + 15) / 16;
    cbBlobLen = sizeof(EXPORT_PRV_KEY) + 9 * cbHalfModLen;

    // figure out the number of overflow bytes which are in the private
    // key structure
    cbTmpLen = (sizeof(DWORD) * 2) - (((pPrvKey->bitlen + 7) / 8) % (sizeof(DWORD) * 2));
    if ((sizeof(DWORD) * 2) != cbTmpLen)
        cbTmpLen += sizeof(DWORD) * 2;
    cbHalfTmpLen = cbTmpLen / 2;

    if (NULL == pbBlob)
    {
        *pcbBlob = cbBlobLen;
        return TRUE;
    }

    if (*pcbBlob < cbBlobLen)
    {
        *pcbBlob = cbBlobLen;
        return FALSE;
    }
    else
    {
        // take most of the header info
        pExportKey = (PEXPORT_PRV_KEY)pbBlob;
        pExportKey->magic = pPrvKey->magic;
        pExportKey->bitlen = pPrvKey->bitlen;
        pExportKey->pubexp = pPrvKey->pubexp;

        pbIn = (PBYTE)pPrvKey + sizeof(BSAFE_PRV_KEY);
        pbOut = pbBlob + sizeof(EXPORT_PRV_KEY);

        // copy all the private key info
        CopyMemory(pbOut, pbIn, pExportKey->bitlen / 8);
        pbIn += pExportKey->bitlen / 8 + cbTmpLen;
        pbOut += pExportKey->bitlen / 8;
        CopyMemory(pbOut, pbIn, cbHalfModLen);
        pbIn += cbHalfModLen + cbHalfTmpLen;
        pbOut += cbHalfModLen;
        CopyMemory(pbOut, pbIn, cbHalfModLen);
        pbIn += cbHalfModLen + cbHalfTmpLen;
        pbOut += cbHalfModLen;
        CopyMemory(pbOut, pbIn, cbHalfModLen);
        pbIn += cbHalfModLen + cbHalfTmpLen;
        pbOut += cbHalfModLen;
        CopyMemory(pbOut, pbIn, cbHalfModLen);
        pbIn += cbHalfModLen + cbHalfTmpLen;
        pbOut += cbHalfModLen;
        CopyMemory(pbOut, pbIn, cbHalfModLen);
        pbIn += cbHalfModLen + cbHalfTmpLen;
        pbOut += cbHalfModLen;
        CopyMemory(pbOut, pbIn, pExportKey->bitlen / 8);
    }
    *pcbBlob = cbBlobLen;

    return TRUE;
}

/* PreparePrivateKeyForImport
 *
 *      Massage the incoming into a form acceptable for
 *      the registry.
 *
 */

BOOL PreparePrivateKeyForImport(
                                IN PBYTE pbBlob,
                                IN DWORD cbBlob,
                                OUT BSAFE_PRV_KEY *pPrvKey,
                                IN OUT PDWORD pPrvKeyLen,
                                OUT BSAFE_PUB_KEY *pPubKey,
                                IN OUT PDWORD pPubKeyLen
                                )
{
    PEXPORT_PRV_KEY pExportKey = (PEXPORT_PRV_KEY)pbBlob;
    DWORD           cbHalfModLen;
    DWORD           cbPub;
    DWORD           cbPrv;
    PBYTE           pbIn;
    PBYTE           pbOut;
    DWORD           cbTmpLen;
    DWORD           cbHalfTmpLen;

    if (RSA2 != pExportKey->magic)
        return FALSE;

    // figure out the number of overflow bytes which are in the private
    // key structure
    cbTmpLen = (sizeof(DWORD) * 2) - (((pExportKey->bitlen + 7) / 8) % (sizeof(DWORD) * 2));
    if ((sizeof(DWORD) * 2) != cbTmpLen)
        cbTmpLen += sizeof(DWORD) * 2;
    cbHalfTmpLen = cbTmpLen / 2;
    cbHalfModLen = (pExportKey->bitlen + 15) / 16;

    cbPub = sizeof(BSAFE_PUB_KEY) + (pExportKey->bitlen / 8) + cbTmpLen;
    cbPrv = sizeof(BSAFE_PRV_KEY) + (cbHalfModLen + cbHalfTmpLen) * 10;
    if ((NULL == pPrvKey) || (NULL == pPubKey))
    {
        *pPubKeyLen = cbPub;
        *pPrvKeyLen = cbPrv;
        return TRUE;
    }

    if ((*pPubKeyLen < cbPub) || (*pPrvKeyLen < cbPrv))
    {
        *pPubKeyLen = cbPub;
        *pPrvKeyLen = cbPrv;
        return FALSE;
    }
    else
    {
        // form the public key
        ZeroMemory(pPubKey, *pPubKeyLen);
        pPubKey->magic = RSA1;
        pPubKey->bitlen = pExportKey->bitlen;
        pPubKey->keylen = (pExportKey->bitlen / 8) + cbTmpLen;
        pPubKey->datalen = (pExportKey->bitlen+7)/8 - 1;
        pPubKey->pubexp = pExportKey->pubexp;

        pbIn = pbBlob + sizeof(EXPORT_PRV_KEY);
        pbOut = (PBYTE)pPubKey + sizeof(BSAFE_PUB_KEY);

        CopyMemory(pbOut, pbIn, pExportKey->bitlen / 8);

        // form the private key
        ZeroMemory(pPrvKey, *pPrvKeyLen);
        pPrvKey->magic = pExportKey->magic;
        pPrvKey->keylen = pPubKey->keylen;
        pPrvKey->bitlen = pExportKey->bitlen;
        pPrvKey->datalen = pPubKey->datalen;
        pPrvKey->pubexp = pExportKey->pubexp;

        pbOut = (PBYTE)pPrvKey + sizeof(BSAFE_PRV_KEY);

        CopyMemory(pbOut, pbIn, pExportKey->bitlen / 8);
        pbOut += pExportKey->bitlen / 8 + cbTmpLen;
        pbIn += pExportKey->bitlen / 8;
        CopyMemory(pbOut, pbIn, cbHalfModLen);
        pbOut += cbHalfModLen + cbHalfTmpLen;
        pbIn += cbHalfModLen;
        CopyMemory(pbOut, pbIn, cbHalfModLen);
        pbOut += cbHalfModLen + cbHalfTmpLen;
        pbIn += cbHalfModLen;
        CopyMemory(pbOut, pbIn, cbHalfModLen);
        pbOut += cbHalfModLen + cbHalfTmpLen;
        pbIn += cbHalfModLen;
        CopyMemory(pbOut, pbIn, cbHalfModLen);
        pbOut += cbHalfModLen + cbHalfTmpLen;
        pbIn += cbHalfModLen;
        CopyMemory(pbOut, pbIn, cbHalfModLen);
        pbOut += cbHalfModLen + cbHalfTmpLen;
        pbIn += cbHalfModLen;
        CopyMemory(pbOut, pbIn, pExportKey->bitlen / 8);
    }
    *pPubKeyLen = cbPub;
    *pPrvKeyLen = cbPrv;

    return TRUE;
}

BOOL ValidKeyAlgid(
                   PNTAGUserList pTmpUser,
                   ALG_ID Algid
                   )
{
    BOOL    fRet = FALSE;

    switch(pTmpUser->dwProvType)
    {
        case PROV_RSA_FULL:
            if ((CALG_SSL3_MASTER == Algid) || (CALG_PCT1_MASTER == Algid))
                goto Ret;
            break;

        case PROV_RSA_SIG:
            if (CALG_RSA_SIGN != Algid)
                goto Ret;
            break;

#ifdef CSP_USE_SSL3
        case PROV_RSA_SCHANNEL:
            if (CALG_RSA_SIGN == Algid)
                goto Ret;
            break;
#endif

        default:
            goto Ret;
    }

    fRet = TRUE;
Ret:
    return fRet;
}

/*
 -  GetSGCDefaultKeyLength
 -
 *  Purpose:
 *                Returns the default key size in pcbKey.
 *
 *  Parameters:
 *               IN      Algid   -  For the key to be created
 *               OUT     pcbKey  -  Size of the key in bytes to generate
 *               OUT     pfPubKey-  TRUE if the Algid is a pub key
 *
 *  Returns:  TRUE on success, FALSE on failure.
 */
BOOL GetSGCDefaultKeyLength(
                            IN ALG_ID Algid,
                            OUT DWORD *pcbKey,
                            OUT BOOL *pfPubKey
                            )
{
    BOOL    fRet = FALSE;

    *pfPubKey = FALSE;

    // determine which crypt algorithm is to be used
    switch (Algid)
    {
#ifdef CSP_USE_SSL3
        case CALG_SSL3_MASTER:
        case CALG_TLS1_MASTER:
            *pcbKey = SSL3_MASTER_KEYSIZE;
            break;
        case CALG_PCT1_MASTER:
            *pcbKey = PCT1_MASTER_KEYSIZE;
            break;
        case CALG_SSL2_MASTER:
            *pcbKey = SSL2_MASTER_KEYSIZE;
            break;
#endif

        case CALG_RSA_KEYX:
            *pcbKey = SGC_RSA_DEF_EXCH_MODLEN;
            *pfPubKey = TRUE;
            break;

        default:
            SetLastError((DWORD) NTE_BAD_ALGID);
            goto Ret;
            break;
    }

    fRet = TRUE;
Ret:
    return fRet;
}

/*
 -  GetDefaultKeyLength
 -
 *  Purpose:
 *                Returns the default key size in pcbKey.
 *
 *  Parameters:
 *               IN      pTmpUser-  The context info
 *               IN      Algid   -  For the key to be created
 *               OUT     pcbKey  -  Size of the key in bytes to generate
 *               OUT     pfPubKey-  TRUE if the Algid is a pub key
 *
 *  Returns:  TRUE on success, FALSE on failure.
 */
BOOL GetDefaultKeyLength(
                         IN PNTAGUserList pTmpUser,
                         IN ALG_ID Algid,
                         OUT DWORD *pcbKey,
                         OUT BOOL *pfPubKey
                         )
{
    BOOL    fRet = FALSE;

    *pfPubKey = FALSE;

    // determine which crypt algorithm is to be used
    switch (Algid)
    {
#ifdef CSP_USE_RC2
        case CALG_RC2:
#ifdef STRONG
            if (pTmpUser->fNewStrongCSP)
            {
                *pcbKey = RC2_DEF_NEWSTRONG_KEYSIZE;
            }
            else
            {
                *pcbKey = RC2_DEF_KEYSIZE;
            }
#else
            *pcbKey = RC2_DEF_KEYSIZE;
#endif // STRONG
            break;
#endif // CSP_USE_RC2

#ifdef CSP_USE_RC4
        case CALG_RC4:
#ifdef STRONG
            if (pTmpUser->fNewStrongCSP)
            {
                *pcbKey = RC4_DEF_NEWSTRONG_KEYSIZE;
            }
            else
            {
                *pcbKey = RC4_DEF_KEYSIZE;
            }
#else
            *pcbKey = RC4_DEF_KEYSIZE;
#endif // STRONG
            break;
#endif

#ifdef CSP_USE_DES
        case CALG_DES:
            *pcbKey = DES_KEYSIZE;
            break;
#endif

#ifdef STRONG
#ifdef CSP_USE_3DES
        case CALG_3DES_112:
            *pcbKey = DES2_KEYSIZE;
            break;

        case CALG_3DES:
            *pcbKey = DES3_KEYSIZE;
            break;
#endif
#endif // STRONG

#ifdef CSP_USE_SSL3
        case CALG_SSL3_MASTER:
        case CALG_TLS1_MASTER:
            *pcbKey = SSL3_MASTER_KEYSIZE;
            break;
        case CALG_PCT1_MASTER:
            *pcbKey = PCT1_MASTER_KEYSIZE;
            break;
        case CALG_SSL2_MASTER:
            *pcbKey = SSL2_MASTER_KEYSIZE;
            break;
#endif

        case CALG_RSA_KEYX:
#ifdef STRONG
            if (pTmpUser->fNewStrongCSP)
            {
                *pcbKey = RSA_DEF_NEWSTRONG_EXCH_MODLEN;
            }
            else
#endif
            {
                *pcbKey = RSA_DEF_EXCH_MODLEN;
            }
            *pfPubKey = TRUE;
            break;
        case CALG_RSA_SIGN:
#ifdef STRONG
            if (pTmpUser->fNewStrongCSP)
            {
                *pcbKey = RSA_DEF_NEWSTRONG_SIGN_MODLEN;
            }
            else
#endif
            {
                *pcbKey = RSA_DEF_SIGN_MODLEN;
            }
            *pfPubKey = TRUE;
            break;

        default:
            SetLastError((DWORD) NTE_BAD_ALGID);
            goto Ret;
            break;
    }

    fRet = TRUE;
Ret:
    return fRet;
}

/*
 -  CheckKeyLength
 -
 *  Purpose:
 *                Checks the settable key length and if it is OK then
 *                returns that as the size of key to use (pcbKey).  If
 *                no key length is in dwFlags then the default key size
 *                is returned (pcbKey).  If a settable key size is
 *                specified but is not legal then a failure occurs.
 *
 *  Parameters:
 *               IN      Algid   -  For the key to be created
 *               IN      dwFlags -  Flag value with possible key size
 *               OUT     pcbKey  -  Size of the key in bytes to generate
 *               OUT     pfPubKey-  TRUE if the Algid is a pub key
 *
 *  Returns:  TRUE on success, FALSE on failure.
 */
BOOL CheckKeyLength(
                    IN PNTAGUserList pTmpUser,
                    IN ALG_ID Algid,
                    IN DWORD dwFlags,
                    OUT DWORD *pcbKey,
                    OUT BOOL *pfPubKey
                    )
{
    DWORD   cBits;
    DWORD   cbKey;
    BOOL    fRet = FALSE;

    cBits = dwFlags >> 16;
    if (cBits)
    {
        // settable key sizes must be divisible by 8 (by bytes)
        if (0 != (cBits % 8))
        {
            SetLastError((DWORD) NTE_BAD_FLAGS);
            goto Ret;
        }

        // check if requested size is legal
        cbKey = cBits / 8;
        if ((PROV_RSA_SCHANNEL == pTmpUser->dwProvType) &&
            (0 != pTmpUser->dwSGCFlags))
        {
            if (!FIsLegalSGCKeySize(Algid, cbKey,
                                    FALSE, TRUE, pfPubKey))
            {
                goto Ret;
            }
        }
        else
        {
            // if in France then different key sizes may apply
            if (pTmpUser->Rights & CRYPT_IN_FRANCE)
            {
                // 4th parameter, dwFlags, is used for SGC Exch keys so just
                // pass zero in this case
                if (!FIsLegalFrenchKeySize(Algid, cbKey,
                                           FALSE, dwFlags, pfPubKey))
                {
                    goto Ret;
                }
            }
            else
            {
                if (!FIsLegalKeySize(Algid, cbKey,
                                     FALSE, dwFlags, pfPubKey))
                {
                    goto Ret;
                }
            }
        }
        *pcbKey = cbKey;
    }
    else
    {
        if ((PROV_RSA_SCHANNEL == pTmpUser->dwProvType) &&
            (0 != pTmpUser->dwSGCFlags))
        {
            if (!GetSGCDefaultKeyLength(Algid, pcbKey, pfPubKey))
                goto Ret;
        }
        else
        {
            if (!GetDefaultKeyLength(pTmpUser, Algid, pcbKey, pfPubKey))
                goto Ret;
        }
    }

    fRet = TRUE;
Ret:
    return fRet;
}

/*
 -  CheckSGCSimpleForExport
 -
 *  Purpose:
 *                Check if the SGC key values in the context against the
 *                passed in values to see if an simple blob export with
 *                this key is allowed.
 *
 *
 *  Parameters:
 *               IN      hUID    -  Handle to a CSP
 *               IN      Algid   -  Algorithm identifier
 *               IN      dwFlags -  Flags values
 *               OUT     phKey   -  Handle to a generated key
 *
 *  Returns:
 */
BOOL CheckSGCSimpleForExport(
                             IN PNTAGUserList pTmpUser,
                             IN BSAFE_PUB_KEY *pBsafePubKey
                             )
{
    BYTE    *pb;
    BOOL    fRet = FALSE;

    pb = ((BYTE*)pBsafePubKey) + sizeof(BSAFE_PUB_KEY);
    if (((pBsafePubKey->bitlen / 8) != pTmpUser->cbSGCKeyMod) ||
        (pBsafePubKey->pubexp != pTmpUser->dwSGCKeyExpo) ||
        (0 != memcmp(pb, pTmpUser->pbSGCKeyMod, pTmpUser->cbSGCKeyMod)))
    {
        fRet = FALSE;
        goto Ret;
    }

    fRet = TRUE;
Ret:
    return fRet;
}

/*
 -  CPGenKey
 -
 *  Purpose:
 *                Generate cryptographic keys
 *
 *
 *  Parameters:
 *               IN      hUID    -  Handle to a CSP
 *               IN      Algid   -  Algorithm identifier
 *               IN      dwFlags -  Flags values
 *               OUT     phKey   -  Handle to a generated key
 *
 *  Returns:
 */
BOOL CPGenKey(IN HCRYPTPROV hUID,
              IN ALG_ID Algid,
              IN DWORD dwFlags,
              OUT HCRYPTKEY * phKey)
{
    PNTAGUserList   pTmpUser;
    PNTAGKeyList    pTmpKey = NULL;
    DWORD           dwRights = 0;
    BYTE            rgbRandom[MAX_KEY_SIZE];
    int             localAlgid;
    DWORD           cbKey;
    BOOL            fPubKey = FALSE;
    BOOL            fRet = NTF_FAILED;

#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputGenKey(TRUE, FALSE, hUID, Algid, dwFlags, phKey);
#endif // DBG -- NOTE:  This section not compiled for retail builds

    if ((dwFlags & ~(CRYPT_EXPORTABLE | CRYPT_USER_PROTECTED |
                     CRYPT_CREATE_SALT | CRYPT_NO_SALT |
                     KEY_LENGTH_MASK | CRYPT_SGCKEY)) != 0)
    {
        SetLastError((DWORD) NTE_BAD_FLAGS);
        goto Ret;
    }

    switch (Algid)
    {
        case AT_KEYEXCHANGE:
            localAlgid = CALG_RSA_KEYX;
            break;

        case AT_SIGNATURE:
            localAlgid = CALG_RSA_SIGN;
            break;

        default:
            localAlgid = Algid;
            break;
    }

    if ((pTmpUser = (PNTAGUserList) NTLCheckList (hUID, USER_HANDLE)) == NULL)
    {
        SetLastError((DWORD) NTE_BAD_UID);
        goto Ret;
    }

    if (!ValidKeyAlgid(pTmpUser, localAlgid))
    {
        SetLastError((DWORD)NTE_BAD_ALGID);
        goto Ret;
    }

    // check if the size of the key is set in the dwFlags parameter
    if (!CheckKeyLength(pTmpUser, localAlgid, dwFlags, &cbKey, &fPubKey))
        goto Ret;

    if (fPubKey)
    {
        if(NTF_SUCCEED != ReGenKey(hUID, dwFlags,
                                   (localAlgid == CALG_RSA_KEYX) ?
                                          NTPK_USE_EXCH : NTPK_USE_SIG,
                                   phKey,
                                   cbKey * 8))
        {
            goto Ret;
        }
    }
    else
    {
        // generate the random key
        if (!FIPS186GenRandom(&pTmpUser->hRNGDriver,
                          &pTmpUser->ContInfo.pbRandom,
                          &pTmpUser->ContInfo.ContLens.cbRandom,
                          rgbRandom, cbKey))
        {
            SetLastError((DWORD) NTE_FAIL);
            goto Ret;
        }

#ifdef CSP_USE_DES
        if ((CALG_DES == localAlgid) || (CALG_3DES_112 == localAlgid) ||
            (CALG_3DES == localAlgid))
        {
            if (dwFlags & CRYPT_CREATE_SALT)
            {
                SetLastError((DWORD) NTE_BAD_FLAGS);
                goto Ret;
            }
            desparityonkey(rgbRandom, cbKey);
        }
#endif
#ifdef CSP_USE_SSL3
        else if (CALG_SSL3_MASTER == localAlgid)
        {
            // set the first byte to 0x03 and the second to 0x00
            rgbRandom[0] = 0x03;
            rgbRandom[1] = 0x00;
        }
        else if (CALG_TLS1_MASTER == localAlgid)
        {
            // set the first byte to 0x03 and the second to 0x01
            rgbRandom[0] = 0x03;
            rgbRandom[1] = 0x01;
        }
#endif
        // check if the key is CRYPT_EXPORTABLE
        if (dwFlags & CRYPT_EXPORTABLE)
            dwRights = CRYPT_EXPORTABLE;

        if ((pTmpKey = MakeNewKey(localAlgid,
                                  dwRights,
                                  cbKey,
                                  hUID,
                                  rgbRandom,
                                  FALSE)) == NULL)
        {
            goto Ret;          // error already set
        }

        if (dwFlags & CRYPT_CREATE_SALT)
        {
#ifdef STRONG
            if (pTmpUser->fNewStrongCSP)
            {
                pTmpKey->cbSaltLen = DEFAULT_SALT_NEWSTRONG_LENGTH;
            }
            else
            {
                pTmpKey->cbSaltLen = DEFAULT_SALT_LENGTH;
            }
#else
            pTmpKey->cbSaltLen = DEFAULT_SALT_LENGTH;
#endif // STRONG

            if (!FIPS186GenRandom(&pTmpUser->hRNGDriver,
                              &pTmpUser->ContInfo.pbRandom,
                              &pTmpUser->ContInfo.ContLens.cbRandom,
                              pTmpKey->rgbSalt, pTmpKey->cbSaltLen))
            {
                SetLastError((DWORD) NTE_FAIL);
                goto Ret;
            }
        }

        if (NTLMakeItem(phKey, KEY_HANDLE, (void *)pTmpKey) == NTF_FAILED)
        {
            goto Ret;          // error already set
        }

        // if 40bit key + no mention of salt, set zeroized salt for RSABase compatibility
        if ((5 == cbKey) && (!(dwFlags & CRYPT_NO_SALT)) &&
            (!(dwFlags & CRYPT_CREATE_SALT)) &&
            (CALG_SSL3_MASTER != Algid) && (CALG_TLS1_MASTER != Algid) &&
            (CALG_PCT1_MASTER != Algid) && (CALG_SSL2_MASTER != Algid))
        {
            if (!MakeKeyRSABaseCompatible(hUID, *phKey))
            {
                goto Ret;
            }
        }
    }

    fRet = NTF_SUCCEED;
Ret:
#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputGenKey(FALSE, fRet, 0, 0, 0, phKey);
#endif // DBG -- NOTE:  This section not compiled for retail builds

    if (FALSE == fRet)
    {
        if (pTmpKey)
            FreeNewKey(pTmpKey);
    }

    return fRet;
}


/*
 -  CPDeriveKey
 -
 *  Purpose:
 *                Derive cryptographic keys from base data
 *
 *
 *  Parameters:
 *               IN      hUID       -  Handle to a CSP
 *               IN      Algid      -  Algorithm identifier
 *               IN      hBaseData  -  Handle to hash of base data
 *               IN      dwFlags    -  Flags values
 *               OUT     phKey      -  Handle to a generated key
 *
 *  Returns:
 */
BOOL CPDeriveKey(IN HCRYPTPROV hUID,
                 IN ALG_ID Algid,
                 IN HCRYPTHASH hBaseData,
                 IN DWORD dwFlags,
                 OUT HCRYPTKEY * phKey)
{
    PNTAGUserList   pTmpUser = NULL;
    PNTAGKeyList    pTmpKey = NULL;
    DWORD           dwRights = 0;
    BYTE            rgbRandom[32];
    BYTE            rgbBaseVal[NT_HASH_BYTES * 2];
    HCRYPTHASH      h1 = 0;
    HCRYPTHASH      h2 = 0;
    BYTE            rgbBuff1[64];
    BYTE            rgbBuff2[64];
    BYTE            rgbHash1[NT_HASH_BYTES];
    BYTE            rgbHash2[NT_HASH_BYTES];
    DWORD           cb1;
    DWORD           cb2;
    DWORD           i;
    PNTAGHashList   pTmpHash;
    DWORD           temp;
    BOOL            fPubKey = FALSE;
    DWORD           cbKey;
    BOOL            fRet = NTF_FAILED;

#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputDeriveKey(TRUE, FALSE, hUID, Algid, hBaseData, dwFlags, phKey);
#endif // DBG -- NOTE:  This section not compiled for retail builds

    if ((dwFlags & ~(CRYPT_EXPORTABLE | CRYPT_USER_PROTECTED |
             CRYPT_CREATE_SALT | CRYPT_NO_SALT | CRYPT_SERVER |
             KEY_LENGTH_MASK)) != 0)
    {
        SetLastError((DWORD) NTE_BAD_FLAGS);
        goto Ret;
    }

    if ((pTmpUser = (PNTAGUserList) NTLCheckList (hUID, USER_HANDLE)) == NULL)
    {
        SetLastError((DWORD) NTE_BAD_UID);
        goto Ret;
    }

    if (!ValidKeyAlgid(pTmpUser, Algid))
    {
        SetLastError((DWORD)NTE_BAD_ALGID);
        goto Ret;
    }

    if (NULL == (pTmpHash = (PNTAGHashList) NTLValidate(hBaseData, hUID,
                                                        HASH_HANDLE)))
    {
        // NTLValidate doesn't know what error to set
        // so it set NTE_FAIL -- fix it up.
        if (GetLastError() == NTE_FAIL)
        {
            SetLastError((DWORD) NTE_BAD_HASH);
        }
        goto Ret;
    }

#ifdef CSP_USE_SSL3
    // if the hash is for secure channel usage then go to that derive function
    if (CALG_SCHANNEL_MASTER_HASH == pTmpHash->Algid)
    {
        if (!SecureChannelDeriveKey(pTmpUser, pTmpHash, Algid, dwFlags, phKey))
        {
            goto Ret;
        }
        else
        {
            fRet = NTF_SUCCEED;
            goto Ret;
        }
    }
#endif // CSP_USE_SSL3

    // check if the size of the key is set in the dwFlags parameter
    if (!CheckKeyLength(pTmpUser, Algid, dwFlags, &cbKey, &fPubKey))
    {
        goto Ret;
    }

    if (fPubKey)
    {
        SetLastError((DWORD) NTE_BAD_ALGID);
        goto Ret;
    }

    if (pTmpHash->HashFlags & HF_VALUE_SET)
    {
        SetLastError((DWORD) NTE_BAD_HASH);
        goto Ret;
    }

    memset(rgbBaseVal, 0, NT_HASH_BYTES);

    temp = NT_HASH_BYTES;
    if (!CPGetHashParam(hUID, hBaseData, HP_HASHVAL, rgbBaseVal, &temp, 0))
    {
        goto Ret;
    }

#ifdef CSP_USE_3DES
    if (CALG_3DES == Algid)
    {
        // the hash value is not long enough so we must expand it
        if (!CPCreateHash(hUID, pTmpHash->Algid, 0, 0, &h1))
        {
            goto Ret;
        }
        if (!CPCreateHash(hUID, pTmpHash->Algid, 0, 0, &h2))
        {
            goto Ret;
        }

        // set up the two buffers to be hashed
        memset(rgbBuff1, 0x36, sizeof(rgbBuff1));
        memset(rgbBuff2, 0x5C, sizeof(rgbBuff2));
        for (i=0;i<temp;i++)
        {
            rgbBuff1[i] ^= rgbBaseVal[i];
            rgbBuff2[i] ^= rgbBaseVal[i];
        }

        // hash the two buffers
        if (!CPHashData(hUID, h1, rgbBuff1, sizeof(rgbBuff1), 0))
        {
            goto Ret;
        }
        if (!CPHashData(hUID, h2, rgbBuff2, sizeof(rgbBuff2), 0))
        {
            goto Ret;
        }

        // finish the hashes and copy them into BaseVal
        memset(rgbHash1, 0, sizeof(rgbHash1));
        cb1 = sizeof(rgbHash1);
        if (!CPGetHashParam(hUID, h1, HP_HASHVAL, rgbHash1, &cb1, 0))
        {
            goto Ret;
        }
        memcpy(rgbBaseVal, rgbHash1, cb1);

        memset(rgbHash2, 0, sizeof(rgbHash2));
        cb2 = sizeof(rgbHash2);
        if (!CPGetHashParam(hUID, h2, HP_HASHVAL, rgbHash2, &cb2, 0))
        {
            goto Ret;
        }
        memcpy(rgbBaseVal + cb1, rgbHash2, cb2);
    }
#endif

    memcpy(rgbRandom, rgbBaseVal, cbKey);

    // check if the key is CRYPT_EXPORTABLE
    if (dwFlags & CRYPT_EXPORTABLE)
        dwRights = CRYPT_EXPORTABLE;

    if (NULL == (pTmpKey = MakeNewKey(Algid,
                                      dwRights,
                                      cbKey,
                                      hUID,
                                      rgbRandom,
                                      FALSE)))
    {
        goto Ret;
    }

    if (dwFlags & CRYPT_CREATE_SALT)
    {
#ifdef STRONG
        if (pTmpUser->fNewStrongCSP)
        {
            pTmpKey->cbSaltLen = DEFAULT_SALT_NEWSTRONG_LENGTH;
        }
        else
        {
            pTmpKey->cbSaltLen = DEFAULT_SALT_LENGTH;
        }
#else
        pTmpKey->cbSaltLen = DEFAULT_SALT_LENGTH;
#endif // STRONG

        memcpy(pTmpKey->rgbSalt, rgbBaseVal+cbKey, pTmpKey->cbSaltLen);
    }

    if (NTLMakeItem(phKey, KEY_HANDLE, (void *)pTmpKey) == NTF_FAILED)
    {
        goto Ret;          // error already set
    }

    // if 40bit key + no mention of salt, set zeroized salt for RSABase compatibility
    if ((5 == cbKey) && (!(dwFlags & CRYPT_NO_SALT)) &&
        (!(dwFlags & CRYPT_CREATE_SALT)) )
    {
        if (!MakeKeyRSABaseCompatible(hUID, *phKey))
        {
            goto Ret;
        }
    }

    fRet = NTF_SUCCEED;
Ret:
#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputDeriveKey(FALSE, fRet, 0, 0, 0, 0, phKey);
#endif // DBG -- NOTE:  This section not compiled for retail builds

    if ((NTF_SUCCEED != fRet) && pTmpKey)
        FreeNewKey(pTmpKey);
    if (pTmpUser && h1)
        CPDestroyHash(hUID, h1);
    if (pTmpUser && h2)
        CPDestroyHash(hUID, h2);

    return fRet;
}

BOOL MyGetComputerName(IN PNTAGUserList pUser)
{
    BOOL    fRet = FALSE;
    int i;
    pUser->cbMachineName = sizeof(pUser->rgszMachineName);
    for (i=0; i<(int)pUser->cbMachineName; ++i)
    {
        pUser->rgszMachineName[i] = 'X';
    }
    if (i > 0)
    {
        pUser->rgszMachineName[i-1] = '\0';
    }
    fRet = TRUE;
    return fRet;
}

// RC4 is used so both encryption and decryption are done with this
// function
DWORD EncryptOpaqueBlob(
                        PNTAGUserList pUser,
                        BYTE *pbData,
                        DWORD cbData
                        )
{
    BYTE            rgbStart[] = {0x3A, 0x18, 0x97, 0xC2,
                                  0x44, 0x0B, 0x1E, 0x49};
    A_SHA_CTX       SHACtxt;
    BYTE            rgbHash[A_SHA_DIGEST_LEN];
    RC4_KEYSTRUCT   KeyStruct;
    DWORD           dwErr = 0;

    memset(&SHACtxt, 0, sizeof(SHACtxt));
    memset(rgbHash, 0, sizeof(rgbHash));
    memset(&KeyStruct, 0, sizeof(KeyStruct));
    
    if (!MyGetComputerName(pUser))
    {
        dwErr = GetLastError();
        goto Ret;
    }

    A_SHAInit(&SHACtxt);
    A_SHAUpdate(&SHACtxt, rgbStart, sizeof(rgbStart));
    A_SHAUpdate(&SHACtxt, pUser->rgszMachineName, strlen(pUser->rgszMachineName));
    A_SHAFinal(&SHACtxt, rgbHash);

    rc4_key(&KeyStruct, 16, rgbHash);

    rc4(&KeyStruct, cbData, pbData);
Ret:
    return dwErr;
}

BOOL ExportOpaqueBlob(
                      PNTAGUserList pUser,
                      PNTAGKeyList pKey,
                      DWORD dwFlags,
                      BYTE *pbData,
                      DWORD *pcbData
                      )
{
    DWORD           cb;
    DWORD           cbIndex;
    PNTAGKeyList    pTmpKey;
    BYTE            *pbSalt;
    BOOL            fRet = FALSE;

    // make sure the key is a symmetric key
    if ((CALG_RSA_SIGN == pKey->Algid) || (CALG_RSA_KEYX == pKey->Algid))
    {
        SetLastError((DWORD)NTE_BAD_KEY);
        goto Ret;
    }

    // calculate the length of the blob
    cb = sizeof(BLOBHEADER) + sizeof(NTAGKeyList) + pKey->cbKeyLen +
         pKey->cbDataLen + pKey->cbSaltLen;

    if (pbData == NULL || *pcbData < cb)
    {
        if (pbData == NULL)
        {
            fRet = TRUE;
            goto Ret;
        }
        SetLastError(ERROR_MORE_DATA);
        goto Ret;
    }

    // set up the blob
    pTmpKey = (PNTAGKeyList)((BYTE*)pbData + sizeof(BLOBHEADER));
    memcpy(pTmpKey, pKey, sizeof(NTAGKeyList));

    pTmpKey->hUID = 0;
    cbIndex = sizeof(NTAGKeyList) + sizeof(BLOBHEADER);
    pTmpKey->pKeyValue = pbData + cbIndex;
    memcpy(pTmpKey->pKeyValue, pKey->pKeyValue, pTmpKey->cbKeyLen);
    cbIndex += pTmpKey->cbKeyLen;

    pTmpKey->pData = pbData + cbIndex;
    memcpy(pTmpKey->pData, pKey->pData, pTmpKey->cbDataLen);
    cbIndex += pTmpKey->cbDataLen;

    pbSalt = pbData + cbIndex;
    memcpy(pbSalt, pKey->rgbSalt, pTmpKey->cbSaltLen);
    cbIndex += pTmpKey->cbSaltLen;

    // encrypt the blob
    if (0 != EncryptOpaqueBlob(pUser,
                               pbData + sizeof(BLOBHEADER),
                               cb - sizeof(BLOBHEADER)))
    {
        SetLastError((DWORD)NTE_FAIL);
        goto Ret;
    }

    fRet = TRUE;
Ret:
    *pcbData = cb;
    return fRet;
}

/*
 -  GetRC4KeyForSymWrap
 -
 *  Purpose:
 *            RC4 or more precisely stream ciphers are not supported by the CMS spec
 *            on symmetric key wrapping so we had to do something proprietary since
 *            we want to support RC4 for applications other than SMIME
 *
 *
 *  Parameters:
 *               IN  pTmpUser   - Pointer to the context
 *               IN  pbSalt     - Pointer to the 8 byte salt buffer
 *               IN  pKey       - Pointer to the orignial key
 *               OUT ppNewKey   - Pointer to a pointer to the new key
 */
DWORD GetRC4KeyForSymWrap(
                          IN PNTAGUserList pTmpUser,
                          IN BYTE *pbSalt,
                          IN PNTAGKeyList pKey,
                          OUT PNTAGKeyList *ppNewKey
                          )
{
    BYTE            rgbSalt[MAX_SALT_LEN];
    DWORD           dwErr = 0;

    // duplicate the key
    if (!CopyKey(pKey, ppNewKey))
    {
        dwErr = GetLastError();
        goto Ret;
    }

    // set the value as salt + current salt
    (*ppNewKey)->cbSaltLen += 8;
    memcpy((*ppNewKey)->rgbSalt + ((*ppNewKey)->cbSaltLen - 8), pbSalt, 8);
    if (!CPInflateKey(*ppNewKey))
    {
        dwErr = GetLastError();
    }
Ret:
    return dwErr;
}

/*
 -  GetSymmetricKeyChecksum
 -
 *  Purpose:
 *                Calculates the checksum for a symmetric key which is to be
 *                wrapped with another symmetric key.  This should meet the
 *                CMS specification
 *
 *
 *  Parameters:
 *               IN  pKey       - Pointer to the key
 *               OUT pbChecksum - Pointer to the 8 byte checksum
 */
void GetSymmetricKeyChecksum(
                             IN BYTE *pbKey,
                             IN DWORD cbKey,
                             OUT BYTE *pbChecksum
                             )
{
    A_SHA_CTX   SHACtx;
    BYTE        rgb[A_SHA_DIGEST_LEN];

    A_SHAInit(&SHACtx);
    A_SHAUpdate(&SHACtx, pbKey, cbKey);
    A_SHAFinal(&SHACtx, rgb);

    memcpy(pbChecksum, rgb, 8);
}

/*
 -  WrapSymKey
 -
 *  Purpose:
 *          Wrap a symmetric key with another symmetric key.  This should
 *          meet the CMS specification for symmetric key wrapping.
 *
 *  Parameters:
 *               IN  pTmpUser   - Pointer to the user context
 *               IN  pKey       - Pointer to the key to be wrapped
 *               IN  pWrapKey   - Pointer to the key to be used for wrapping
 *               IN OUT pbBlob  - Pointer to the resulting blob (may be NULL
 *                                to get the length)
 *               IN OUT pcbBlob - Pointer to the length of the blob buffer
 */
DWORD WrapSymKey(
                 IN PNTAGUserList pTmpUser,
                 IN PNTAGKeyList pKey,
                 IN PNTAGKeyList pWrapKey,
                 IN OUT BYTE *pbBlob,
                 IN OUT DWORD *pcbBlob
                 )
{
    DWORD           cb = 0;
    DWORD           cbIndex = 0;
    DWORD           cbPad = 0;
    BLOBHEADER      *pBlobHdr;
    ALG_ID          *pAlgid;
    BYTE            rgbTmp1[49]; // 1 length + 8 padding + 8 checksum + 8 IV + 24 max key
    BYTE            rgbTmp2[49]; // 1 length + 8 padding + 8 checksum + 8 IV + 24 max key
    BYTE            rgbIV[8];
    PNTAGKeyList    pLocalWrapKey = NULL;
    BOOL            fAlloc = FALSE;
    DWORD           i;
    DWORD           dwErr = 0;

    memset(rgbTmp1, 0, sizeof(rgbTmp1));
    memset(rgbTmp2, 0, sizeof(rgbTmp2));
    memset(rgbIV, 0, sizeof(rgbIV));

    // both keys must be supported symmetric keys
    if (UnsupportedSymKey(pKey) || UnsupportedSymKey(pWrapKey))
    {
        dwErr = (DWORD)NTE_BAD_KEY;
        goto Ret;
    }

    if ((!FIsLegalKey(pTmpUser, pKey, FALSE)) ||
        (!FIsLegalKey(pTmpUser, pWrapKey, FALSE)))
    {
        dwErr = (DWORD) NTE_BAD_KEY;
        goto Ret;
    }

    // Check if we should do an auto-inflate
    if (pWrapKey->pData == NULL)
    {
        if (!CPInflateKey(pWrapKey))
        {
            dwErr = GetLastError();
            goto Ret;
        }
    }

    // calculate how long the encrypted data is going to be,
    // 1 byte for length, up to 8 bytes for pad and 8 bytes
    // for the checksum and 8 bytes for the IV
    if ((CALG_RC4 == pKey->Algid) || (CALG_RC2 == pKey->Algid)) // variable key lengths
    {
        cbPad = 8 - ((pKey->cbKeyLen + 1) % 8);
        cb += pKey->cbKeyLen + 9 + cbPad + 8;
        
        // place the length in the buffer
        rgbTmp1[0] = (BYTE)pKey->cbKeyLen;
        cbIndex += 1;
    }
    // calculate how long the encrypted data is going to be,
    // up to 8 bytes for salt and 8 bytes for the checksum and 8 bytes
    // for the IV
    else
    {
        cb += pKey->cbKeyLen + 16;
    }

    // check if just looking for a length
    if (NULL == pbBlob)
    {
        cbIndex = cb;
        dwErr = 0;
        goto Ret;
    }
    else if (*pcbBlob < (cb + sizeof(BLOBHEADER) + sizeof(ALG_ID)))
    {
        cbIndex = cb;
        dwErr = ERROR_MORE_DATA;
        goto Ret;
    }

    // copy the key data
    memcpy(rgbTmp1 + cbIndex, pKey->pKeyValue, pKey->cbKeyLen);
    cbIndex += pKey->cbKeyLen;

    // generate random pad
    if (cbPad)
    {
        if (!FIPS186GenRandom(&pTmpUser->hRNGDriver,
                              &pTmpUser->ContInfo.pbRandom,
                              &pTmpUser->ContInfo.ContLens.cbRandom,
                              rgbTmp1 + cbIndex, cbPad))
        {
            dwErr = GetLastError();
            goto Ret;
        }
        cbIndex += cbPad;
    }

    // get the checksum
    GetSymmetricKeyChecksum(rgbTmp1,
                            cbIndex,
                            rgbTmp1 + cbIndex);
    cbIndex += 8;

    if (!FIPS186GenRandom(&pTmpUser->hRNGDriver,
                          &pTmpUser->ContInfo.pbRandom,
                          &pTmpUser->ContInfo.ContLens.cbRandom,
                          rgbIV, 8))
    {
        dwErr = GetLastError();
        goto Ret;
    }

    // set the IV if the algorithm is not RC4
    if (CALG_RC4 != pWrapKey->Algid)
    {
        memcpy(pWrapKey->IV, rgbIV, 8);
        pWrapKey->InProgress = FALSE;
        pLocalWrapKey = pWrapKey;
    }
    else
    {
        // RC4 or more precisely stream ciphers are not supported by the CMS spec
        // on symmetric key wrapping so we had to do something proprietary since
        // we want to support RC4 for applications other than SMIME
        if (0 != (dwErr = GetRC4KeyForSymWrap(pTmpUser,
                                              rgbIV,
                                              pWrapKey,
                                              &pLocalWrapKey)))
        {
            goto Ret;
        }
        fAlloc = TRUE;
    }

    // encrypt the key blob data
    if (!SymEncrypt(pLocalWrapKey, FALSE, rgbTmp1,
                    &cbIndex, cbIndex))
    {
        dwErr = GetLastError();
        goto Ret;
    }

    // concatenate the initial ciphertext with the IV
    memcpy(rgbTmp2, rgbIV, 8);
    memcpy(rgbTmp2 + 8, rgbTmp1, cbIndex);
    cbIndex += 8;

    // byte reverse the ciphertext + IV buffer
    for (i = 0; i < cbIndex; i++)
    {
        rgbTmp1[i] = rgbTmp2[cbIndex - (i + 1)];
    }

    // encrypt the key blob data again with the hardcoded IV
    if (CALG_RC4 != pWrapKey->Algid)
    {
        memcpy(pWrapKey->IV, rgbSymmetricKeyWrapIV, 8);
        pWrapKey->InProgress = FALSE;
    }
    else
    {
        if (fAlloc && pLocalWrapKey)
        {
            FreeNewKey(pLocalWrapKey);
            pLocalWrapKey = NULL;
            fAlloc = FALSE;
        }

        // RC4 or more precisely stream ciphers are not supported by the CMS spec
        // on symmetric key wrapping so we had to do something proprietary since
        // we want to support RC4 for applications other than SMIME
        if (0 != (dwErr = GetRC4KeyForSymWrap(pTmpUser,
                                              rgbSymmetricKeyWrapIV,
                                              pWrapKey,
                                              &pLocalWrapKey)))
        {
            goto Ret;
        }
        fAlloc = TRUE;
    }

    if (!SymEncrypt(pLocalWrapKey, FALSE, rgbTmp1,
                    &cbIndex, cbIndex))
    {
        dwErr = GetLastError();
        goto Ret;
    }

    // set the header info
    pBlobHdr = (BLOBHEADER*)pbBlob;
    pBlobHdr->aiKeyAlg = pKey->Algid;

    pAlgid = (ALG_ID*)(pbBlob + sizeof(BLOBHEADER));
    *pAlgid = pWrapKey->Algid;

    memcpy(pbBlob + sizeof(BLOBHEADER) + sizeof(ALG_ID),
           rgbTmp1, cbIndex);
Ret:
    if (fAlloc && pLocalWrapKey)
    {
        FreeNewKey(pLocalWrapKey);
    }

    memset(rgbTmp1, 0, sizeof(rgbTmp1));
    memset(rgbTmp2, 0, sizeof(rgbTmp2));
    memset(rgbIV, 0, sizeof(rgbIV));

    *pcbBlob = cbIndex + sizeof(BLOBHEADER) + sizeof(ALG_ID);

    return dwErr;
}

/*
 -  UnWrapSymKey
 -
 *  Purpose:
 *          Unwrap a symmetric key with another symmetric key.  This should
 *          meet the CMS specification for symmetric key wrapping.
 *
 *  Parameters:
 *               IN  pTmpUser   - Pointer to the user context
 *               IN  pWrapKey   - Pointer to the key to be used for unwrapping
 *               IN  pbBlob     - Pointer to the blob to be unwrapped
 *               IN  cbBlob     - The length of the blob buffer
 *               OUT phKey      - Handle to the unwrapped key
 */
DWORD UnWrapSymKey(
                   IN HCRYPTPROV hUID,
                   IN PNTAGUserList pTmpUser,
                   IN PNTAGKeyList pWrapKey,
                   IN BYTE *pbBlob,
                   IN DWORD cbBlob,
                   IN DWORD dwFlags,
                   OUT HCRYPTKEY *phKey
                   )
{
    DWORD           cb = 0;
    DWORD           cbIndex = 0;
    DWORD           cbKey = 0;
    BYTE            rgbChecksum[8];
    BLOBHEADER      *pBlobHdr = (BLOBHEADER*)pbBlob;
    ALG_ID          *pAlgid;
    BYTE            rgbTmp1[49];  // 1 length + 8 padding + 8 checksum + 8 IV + 24 max key
    BYTE            rgbTmp2[49];  // 1 length + 8 padding + 8 checksum + 8 IV + 24 max key
    DWORD           dwRights = 0;
    PNTAGKeyList    pTmpKey = NULL;
    PNTAGKeyList    pLocalWrapKey = NULL;
    BOOL            fAlloc = FALSE;
    DWORD           i;
    BOOL            fPubKey;
    DWORD           dwErr = 0;

    memset(rgbTmp1, 0, sizeof(rgbTmp1));
    memset(rgbTmp2, 0, sizeof(rgbTmp2));

    cb = cbBlob - (sizeof(BLOBHEADER) + sizeof(ALG_ID));
    if ((sizeof(rgbTmp1) < cb) || (0 != (cb % 8)))
    {
        dwErr = (DWORD)NTE_BAD_DATA;
        goto Ret;
    }

    // both keys must be supported symmetric keys
    if (UnsupportedSymKey(pWrapKey) || UnsupportedSymKey(pWrapKey))
    {
        dwErr = (DWORD)NTE_BAD_KEY;
        goto Ret;
    }

    if (!FIsLegalKey(pTmpUser, pWrapKey, FALSE))
    {
        dwErr = (DWORD) NTE_BAD_KEY;
        goto Ret;
    }

    // check the wrapping key ALG_ID
    pAlgid = (ALG_ID*)(pbBlob + sizeof(BLOBHEADER));
    if (pWrapKey->Algid != *pAlgid)
    {
        dwErr = (DWORD) NTE_BAD_KEY;
        goto Ret;
    }

    // Check if we should do an auto-inflate
    if (pWrapKey->pData == NULL)
    {
        if (!CPInflateKey(pWrapKey))
        {
            dwErr = GetLastError();
            goto Ret;
        }
    }

    // set the hardcoded IV
    if (CALG_RC4 != pWrapKey->Algid)
    {
        memcpy(pWrapKey->IV, rgbSymmetricKeyWrapIV, 8);
        pWrapKey->InProgress = FALSE;
        pLocalWrapKey = pWrapKey;
    }
    else
    {
        // RC4 or more precisely stream ciphers are not supported by the CMS spec
        // on symmetric key wrapping so we had to do something proprietary since
        // we want to support RC4 for applications other than SMIME
        if (0 != (dwErr = GetRC4KeyForSymWrap(pTmpUser,
                                              rgbSymmetricKeyWrapIV,
                                              pWrapKey,
                                              &pLocalWrapKey)))
        {
            goto Ret;
        }
        fAlloc = TRUE;
    }

    memcpy(rgbTmp1, pbBlob + sizeof(BLOBHEADER) + sizeof(ALG_ID), cb);

    // decrypt the key blob data
    if (!SymDecrypt(pLocalWrapKey, 0, FALSE, rgbTmp1, &cb))
    {
        dwErr = GetLastError();
        goto Ret;
    }

    // byte reverse the plaintext + IV buffer
    for (i = 0; i < cb; i++)
    {
        rgbTmp2[i] = rgbTmp1[cb - (i + 1)];
    }

    // set the IV if the algorithm is not RC4
    cb -= 8;
    if (CALG_RC4 != pWrapKey->Algid)
    {
        memcpy(pWrapKey->IV, rgbTmp2, 8);
        pWrapKey->InProgress = FALSE;
    }
    else
    {
        if (fAlloc && pLocalWrapKey)
        {
            FreeNewKey(pLocalWrapKey);
            pLocalWrapKey = NULL;
            fAlloc = FALSE;
        }

        // RC4 or more precisely stream ciphers are not supported by the CMS spec
        // on symmetric key wrapping so we had to do something proprietary since
        // we want to support RC4 for applications other than SMIME
        if (0 != (dwErr = GetRC4KeyForSymWrap(pTmpUser,
                                              rgbTmp2,
                                              pWrapKey,
                                              &pLocalWrapKey)))
        {
            goto Ret;
        }
        fAlloc = TRUE;
    }

    // decrypt the key blob data again
    if (!SymDecrypt(pLocalWrapKey, 0, FALSE, rgbTmp2 + 8, &cb))
    {
        dwErr = GetLastError();
        goto Ret;
    }

    // check the length of the key
    if ((CALG_RC4 == pBlobHdr->aiKeyAlg) || (CALG_RC2 == pBlobHdr->aiKeyAlg)) // variable key lengths
    {
        cbKey = (DWORD)rgbTmp2[8];
        cbIndex += 1;
    }
    else
    {
        if (!GetDefaultKeyLength(pTmpUser,
                                 pBlobHdr->aiKeyAlg,
                                 &cbKey,
                                 &fPubKey))
        {
            dwErr = (DWORD)NTE_BAD_ALGID;
            goto Ret;
        }

    }

    // get the checksum and make sure it matches
    cb -= 8;
    GetSymmetricKeyChecksum(rgbTmp2 + 8, cb, rgbChecksum);
    if (memcmp(rgbChecksum, rgbTmp2 + 8 + cb, sizeof(rgbChecksum)))
    {
        dwErr = (DWORD)NTE_BAD_DATA;
        goto Ret;
    }

    // check if the key is to be exportable
    if (dwFlags & CRYPT_EXPORTABLE)
        dwRights = CRYPT_EXPORTABLE;

    if ((pTmpKey = MakeNewKey(pBlobHdr->aiKeyAlg,
                              dwRights,
                              cbKey,
                              hUID,
                              rgbTmp2 + cbIndex + 8,
                              FALSE)) == NULL)
    {
        dwErr = GetLastError();
        goto Ret;
    }

    // check keylength...
    if (!FIsLegalKey(pTmpUser, pTmpKey, TRUE))
    {
        dwErr = GetLastError();
        goto Ret;
    }

    if (NTLMakeItem(phKey, KEY_HANDLE, (void *)pTmpKey) == NTF_FAILED)
    {
        dwErr = GetLastError();
        goto Ret;          // error already set
    }

    // if 40 bit key + no mention of salt, set zeroized salt for RSABase compatibility
    if ((5 == pTmpKey->cbKeyLen) && (!(dwFlags & CRYPT_NO_SALT)))
    {
        if (!MakeKeyRSABaseCompatible(hUID, *phKey))
        {
            dwErr = GetLastError();
            goto Ret;
        }
    }
Ret:
    if (fAlloc && pLocalWrapKey)
    {
        FreeNewKey(pLocalWrapKey);
    }

    memset(rgbTmp1, 0, sizeof(rgbTmp1));
    memset(rgbTmp2, 0, sizeof(rgbTmp2));

    if ((0 != dwErr) && pTmpKey)
        FreeNewKey(pTmpKey);

    return dwErr;
}

/*
 -  CPExportKey
 -
 *  Purpose:
 *                Export cryptographic keys out of a CSP in a secure manner
 *
 *
 *  Parameters:
 *               IN  hUID       - Handle to the CSP user
 *               IN  hKey       - Handle to the key to export
 *               IN  hPubKey    - Handle to the exchange public key value of
 *                                the destination user
 *               IN  dwBlobType - Type of key blob to be exported
 *               IN  dwFlags -    Flags values
 *               OUT pbData -     Key blob data
 *               OUT pdwDataLen - Length of key blob in bytes
 *
 *  Returns:
 */
BOOL CPExportKey(IN HCRYPTPROV hUID,
                 IN HCRYPTKEY hKey,
                 IN HCRYPTKEY hPubKey,
                 IN DWORD dwBlobType,
                 IN DWORD dwFlags,
                 OUT BYTE *pbData,
                 OUT DWORD *pdwDataLen)
{
    // miscellaneous variables
    DWORD           dwLen;
    NTSimpleBlob    *pSimpleHeader;
    BLOBHEADER      *pPreHeader;
    BLOBHEADER      shScratch;
    RSAPUBKEY       *pExpPubKey;
    BSAFE_PUB_KEY   *pBsafePubKey;
    BSAFE_PUB_KEY   *pPublicKey;
    DWORD           PubKeyLen;
    BSAFE_PRV_KEY   *pPrvKey = NULL;
    DWORD           PrvKeyLen = 0;
    BSAFE_PUB_KEY   *pTmpPubKey;
    BSAFE_PRV_KEY   *pTmpPrvKey;
    DWORD           cbPrivateBlob = 0;
    PBYTE           pbPrivateBlob = NULL;
    LPSTR           pszRegValue;
    DWORD           cb = 0;
    BOOL            fExportable = FALSE;
    DWORD           dwErr = 0;
    BOOL            fRet = NTF_FAILED;

    // temporary variables for pointing to user and key records
    PNTAGKeyList        pTmpKey;
    PNTAGKeyList        pPubKey;
    PNTAGUserList       pTmpUser;

#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputExportKey(TRUE, FALSE, hUID, hKey, hPubKey, dwBlobType,
                            dwFlags, pbData, pdwDataLen);
#endif // DBG -- NOTE:  This section not compiled for retail builds

    if (0 != (dwFlags & ~(CRYPT_SSL2_FALLBACK | CRYPT_DESTROYKEY | CRYPT_OAEP)))
    {
        SetLastError((DWORD) NTE_BAD_FLAGS);
        goto Ret;
    }

    if (pdwDataLen == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    if (((PUBLICKEYBLOB == dwBlobType) || (OPAQUEKEYBLOB == dwBlobType)) &&
        (0 != hPubKey))
    {
        SetLastError((DWORD) NTE_BAD_PUBLIC_KEY);
        goto Ret;
    }

    // check the user identification
    if ((pTmpUser = (PNTAGUserList) NTLCheckList (hUID, USER_HANDLE)) == NULL)
    {
        SetLastError((DWORD) NTE_BAD_UID);
        goto Ret;
    }

    // check if the user is just looking for a length.  If so,
    // use a scratchpad to construct a pseudoblob.

    if ((pbData != NULL) && (*pdwDataLen > sizeof(BLOBHEADER)))
        pPreHeader = (BLOBHEADER *)pbData;
    else
        pPreHeader = &shScratch;

    pPreHeader->bType = (BYTE)(dwBlobType & 0xff);
    pPreHeader->bVersion = CUR_BLOB_VERSION;
    pPreHeader->reserved = 0;

    pTmpKey = (PNTAGKeyList)NTLValidate((HNTAG)hKey, hUID,
                        HNTAG_TO_HTYPE(hKey));

    if (pTmpKey == NULL)
    {
        SetLastError((DWORD) NTE_BAD_KEY);
        goto Ret;
    }

    if (dwBlobType != PUBLICKEYBLOB &&
        ((pTmpKey->Rights & CRYPT_EXPORTABLE) != CRYPT_EXPORTABLE))
    {
        SetLastError((DWORD) NTE_BAD_KEY_STATE);
        goto Ret;
    }

    pPreHeader->aiKeyAlg = pTmpKey->Algid;

    switch(dwBlobType)
    {
        case PUBLICKEYBLOB:
        {
            if ((HNTAG_TO_HTYPE(hKey) != SIGPUBKEY_HANDLE) &&
                (HNTAG_TO_HTYPE(hKey) != EXCHPUBKEY_HANDLE))
            {
                SetLastError((DWORD) NTE_BAD_KEY);
                goto Ret;
            }

            pBsafePubKey = (BSAFE_PUB_KEY *) pTmpKey->pKeyValue;

            if (pBsafePubKey == NULL)
            {
                SetLastError((DWORD) NTE_NO_KEY);
                goto Ret;
            }

            //
            // Subtract off 2 extra DWORD needed by RSA code
            //
            dwLen = sizeof(BLOBHEADER) + sizeof(RSAPUBKEY) +
                    ((pBsafePubKey->bitlen + 7) / 8);

            // Check user buffer size
            if (pbData == NULL || *pdwDataLen < dwLen)
            {
                *pdwDataLen = dwLen;
                if (pbData == NULL)
                {
                    fRet = NTF_SUCCEED;
                    goto Ret;
                }
                SetLastError(ERROR_MORE_DATA);
                goto Ret;
            }

            pExpPubKey = (RSAPUBKEY *) (pbData + sizeof(BLOBHEADER));
            pExpPubKey->magic = pBsafePubKey->magic;
            pExpPubKey->bitlen = pBsafePubKey->bitlen;
            pExpPubKey->pubexp = pBsafePubKey->pubexp;

            memcpy((BYTE *) pbData + sizeof(BLOBHEADER) + sizeof(RSAPUBKEY),
                   (BYTE *) pBsafePubKey + sizeof(BSAFE_PUB_KEY),
                   ((pBsafePubKey->bitlen + 7) / 8));

            break;
        }

        case PRIVATEKEYBLOB:
        {
            DWORD   dwBlockLen = 0;
            BOOL    fSigKey;
            LPWSTR  szPrompt;

            cb = sizeof(DWORD);
            if (HNTAG_TO_HTYPE(hKey) == SIGPUBKEY_HANDLE)
            {
                fSigKey = TRUE;
                szPrompt = g_Strings.pwszExportPrivSig;
                pPublicKey = (BSAFE_PUB_KEY*)pTmpUser->ContInfo.pbSigPub;
                PubKeyLen = pTmpUser->ContInfo.ContLens.cbSigPub;
            }
            else if (HNTAG_TO_HTYPE(hKey) == EXCHPUBKEY_HANDLE)
            {
                fSigKey = FALSE;
                szPrompt = g_Strings.pwszExportPrivExch;
                pPublicKey = (BSAFE_PUB_KEY*)pTmpUser->ContInfo.pbExchPub;
                PubKeyLen = pTmpUser->ContInfo.ContLens.cbExchPub;
            }
            else
            {
                SetLastError((DWORD) NTE_BAD_KEY);
                goto Ret;
            }

            // make sure the public key is available and appropriate
            if ((pPublicKey == NULL) ||
                (PubKeyLen != pTmpKey->cbKeyLen) ||
                memcmp((PBYTE)pPublicKey, pTmpKey->pKeyValue, PubKeyLen))
            {
                SetLastError((DWORD) NTE_BAD_KEY);
                goto Ret;
            }

            GetLengthOfPrivateKeyForExport(pPublicKey, PubKeyLen, &cbPrivateBlob);

            if (hPubKey)
            {
                if (!CPGetKeyParam(hUID, hPubKey, KP_BLOCKLEN,
                                   (PBYTE)&dwBlockLen, &cb, 0))
                {
                    SetLastError((DWORD) NTE_BAD_KEY);
                    goto Ret;
                }

                // convert to byte count
                dwBlockLen /= 8;
            }

            // Check user buffer size
            if (pbData == NULL)
            {
                *pdwDataLen = sizeof(BLOBHEADER) + cbPrivateBlob + dwBlockLen;
                fRet = NTF_SUCCEED;
                goto Ret;
            }
            else if (*pdwDataLen < (sizeof(BLOBHEADER) + cbPrivateBlob + dwBlockLen))
            {
                *pdwDataLen = sizeof(BLOBHEADER) + cbPrivateBlob + dwBlockLen;
                SetLastError(ERROR_MORE_DATA);
                goto Ret;
            }

            // if the context being used is a Verify context then the key is not in
            // persisted storage and therefore is in memory
            if (!(pTmpUser->Rights & CRYPT_VERIFYCONTEXT))
            {
                // always read the private key from storage when exporting
                if (!UnprotectPrivKey(pTmpUser, szPrompt, fSigKey, TRUE))
                {
                    SetLastError((DWORD) NTE_BAD_KEYSET);
                    goto Ret;
                }
            }

            if (fSigKey)
            {
	            PrvKeyLen = pTmpUser->SigPrivLen;
	            pPrvKey = (BSAFE_PRV_KEY*)pTmpUser->pSigPrivKey;
                fExportable = pTmpUser->ContInfo.fSigExportable;
            }
            else
            {
	            PrvKeyLen = pTmpUser->ExchPrivLen;
	            pPrvKey = (BSAFE_PRV_KEY*)pTmpUser->pExchPrivKey;
                fExportable = pTmpUser->ContInfo.fExchExportable;
            }

            if (pPrvKey == NULL)
            {
                SetLastError((DWORD) NTE_NO_KEY);
                goto Ret;
            }

            if (!fExportable)
            {
                SetLastError((DWORD) NTE_BAD_KEY);
                goto Ret;
            }

            if (!PreparePrivateKeyForExport(pPrvKey, PrvKeyLen, NULL, &cbPrivateBlob))
            {
                SetLastError((DWORD) NTE_BAD_KEY);
                goto Ret;
            }

            // allocate memory for the private key blob
            cb = cbPrivateBlob + dwBlockLen;
            if (NULL == (pbPrivateBlob = _nt_malloc(cb)))
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }

            if (!PreparePrivateKeyForExport(pPrvKey, PrvKeyLen, pbPrivateBlob, &cbPrivateBlob))
            {
                SetLastError((DWORD) NTE_BAD_KEY);
                goto Ret;
            }

            if (hPubKey)
            {
                if (!LocalEncrypt(hUID, hPubKey, 0, TRUE, 0, pbPrivateBlob,
                                  &cbPrivateBlob, cb, FALSE))
                {
                    goto Ret;
                }
            }

            dwLen = sizeof(BLOBHEADER) + cbPrivateBlob;

            CopyMemory(pbData + sizeof(BLOBHEADER), pbPrivateBlob, cbPrivateBlob);
            break;
        }

        case SIMPLEBLOB:
        {

            if (HNTAG_TO_HTYPE(hKey) != KEY_HANDLE)
            {
                SetLastError((DWORD) NTE_BAD_KEY);
                goto Ret;
            }

            if (0 == hPubKey)
            {
                SetLastError((DWORD) NTE_NO_KEY);
                goto Ret;
            }

            if (!FIsLegalKey(pTmpUser, pTmpKey, FALSE))
            {
                SetLastError((DWORD) NTE_BAD_KEY);
                goto Ret;
            }

#ifdef CSP_USE_SSL3
            // if the SSL2_FALLBACK flag is set then make sure the key
            // is an SSL2 master key
            if (CRYPT_SSL2_FALLBACK & dwFlags)
            {
                if (CALG_SSL2_MASTER != pTmpKey->Algid)
                {
                    SetLastError((DWORD) NTE_BAD_KEY);
                    goto Ret;
                }
            }
#endif

            if ((pPubKey = (PNTAGKeyList) NTLValidate((HNTAG)hPubKey,
                                                hUID,
                                                EXCHPUBKEY_HANDLE)) == NULL)
            {
                SetLastError((DWORD) NTE_BAD_KEY);
                goto Ret;
            }

            pBsafePubKey = (BSAFE_PUB_KEY *) pPubKey->pKeyValue;

            if (pBsafePubKey == NULL)
            {
                SetLastError((DWORD) NTE_NO_KEY);
                goto Ret;
            }

            //
            // Subtract off 8 bytes for 2 extra DWORD needed by RSA code
            //
            dwLen = sizeof(BLOBHEADER) + sizeof(NTSimpleBlob) +
            (pBsafePubKey->bitlen + 7) / 8;

            if (pbData == NULL || *pdwDataLen < dwLen)
            {
                *pdwDataLen = dwLen;    // set what we need
                if (pbData == NULL)
                {
                    fRet = NTF_SUCCEED;
                    goto Ret;
                }
                SetLastError(ERROR_MORE_DATA);
                goto Ret;
            }

            pSimpleHeader = (NTSimpleBlob *) (pbData + sizeof(BLOBHEADER));
            pSimpleHeader->aiEncAlg = CALG_RSA_KEYX;

            // if this is the schannel provider and we are a verify context and
            // the SGC flags are set and the key is large then make sure the
            // key is the same as the SGC key
            if ((PROV_RSA_SCHANNEL == pTmpUser->dwProvType) &&
                (0 != pTmpUser->dwSGCFlags) &&
                (pTmpUser->Rights & CRYPT_VERIFYCONTEXT) &&
                (pBsafePubKey->bitlen > 1024))
            {
                if (!CheckSGCSimpleForExport(pTmpUser, pBsafePubKey))
                {
                    SetLastError((DWORD)NTE_BAD_KEY);
                    goto Ret;
                }
            }

            // perform the RSA encryption.
            if (!RSAEncrypt(pTmpUser, pBsafePubKey, pTmpKey->pKeyValue,
                            pTmpKey->cbKeyLen, pTmpKey->pbParams, pTmpKey->cbParams,
                            dwFlags,
                            pbData + sizeof(BLOBHEADER) + sizeof(NTSimpleBlob)))
            {
                goto Ret;
            }
            break;
        }

        case OPAQUEKEYBLOB:
        {
            dwLen = *pdwDataLen;
            if (!ExportOpaqueBlob(pTmpUser, pTmpKey, dwFlags, pbData, &dwLen))
            {
                goto Ret;
            }

            // if the destroy key flag is set then destroy the key
            if (CRYPT_DESTROYKEY & dwFlags)
            {
                if (!CPDestroyKey(hUID, hKey))
                {
                    goto Ret;
                }
            }

            break;
        }

        case SYMMETRICWRAPKEYBLOB:
        {
            // get a pointer to the symmetric key to wrap with (the variable
            // name pPubKey is a misnomer)
            if (NULL == (pPubKey = (PNTAGKeyList)NTLValidate((HNTAG)hPubKey,
                                                      hUID,
                                                      HNTAG_TO_HTYPE(hKey))))
            {
                SetLastError((DWORD) NTE_BAD_KEY);
                goto Ret;
            }

            if (0 != (dwErr = WrapSymKey(pTmpUser, pTmpKey, pPubKey,
                                         pbData, pdwDataLen)))
            {
                SetLastError(dwErr);
                goto Ret;
            }
			dwLen = *pdwDataLen;

            break;
        }

        default:
            SetLastError((DWORD) NTE_BAD_TYPE);
            goto Ret;

    }

    // set the size of the key blob
    *pdwDataLen = dwLen;
    fRet = NTF_SUCCEED;
Ret:
#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputExportKey(FALSE, fRet, 0, 0, 0, 0, 0, pbData, pdwDataLen);
#endif // DBG -- NOTE:  This section not compiled for retail builds

    if (pbPrivateBlob)
        _nt_free(pbPrivateBlob, cb);

    return fRet;
}

BOOL ImportOpaqueBlob(
                      HCRYPTPROV hUID,
                      PNTAGUserList pUser,
                      DWORD dwFlags,
                      CONST BYTE *pbData,
                      DWORD cbData,
                      HCRYPTKEY *phKey
                      )
{
    PNTAGKeyList    pTmpKey = NULL;
    BYTE            *pbDecrypted = NULL;
    DWORD           cb;
    BYTE            *pb;
    BYTE            *pbTmp;
    BOOL            fRet = FALSE;

    *phKey = 0;

    // allocate a temporary key structure
    if (NULL == (pTmpKey = (PNTAGKeyList)_nt_malloc(sizeof(NTAGKeyList))))
        goto Ret;
    if (NULL == (pbDecrypted = (BYTE*)_nt_malloc(cbData - sizeof(BLOBHEADER))))
        goto Ret;

    // copy the blob to a temporary key structure
    memcpy(pbDecrypted, pbData + sizeof(BLOBHEADER),
           cbData - sizeof(BLOBHEADER));

    // decrypt the blob
    if (0 != EncryptOpaqueBlob(pUser, pbDecrypted, cbData - sizeof(BLOBHEADER)))
    {
        SetLastError((DWORD)NTE_FAIL);
        goto Ret;
    }

    memcpy(pTmpKey, pbDecrypted, sizeof(NTAGKeyList));
    pTmpKey->hUID = hUID;
    
    // allocate for the key value, the salt and the key data
    pTmpKey->pKeyValue = NULL;
    pTmpKey->pData = NULL;
    cb = sizeof(NTAGKeyList);
    if (pTmpKey->cbKeyLen)
    {
        if (NULL == (pbTmp = (BYTE*)_nt_malloc(pTmpKey->cbKeyLen)))
            goto Ret;
        pb = (BYTE*)pbDecrypted + cb;
        memcpy(pbTmp, pb, pTmpKey->cbKeyLen);
        pTmpKey->pKeyValue = pbTmp;
    }
    cb += pTmpKey->cbKeyLen;

    if (pTmpKey->cbDataLen)
    {
        if (NULL == (pbTmp = (BYTE*)_nt_malloc(pTmpKey->cbDataLen)))
            goto Ret;
        pb = (BYTE*)pbDecrypted + cb;
        memcpy(pbTmp, pb, pTmpKey->cbDataLen);
        pTmpKey->pData = pbTmp;
    }
    cb += pTmpKey->cbDataLen;
    
    if (pTmpKey->cbSaltLen)
    {
        pb = (BYTE*)pbDecrypted + cb;
        memcpy(pTmpKey->rgbSalt, pb, pTmpKey->cbSaltLen);
    }

    if (NTF_FAILED == NTLMakeItem(phKey, KEY_HANDLE, (void *)pTmpKey))
        goto Ret;          // error already set

    fRet = TRUE;
Ret:
    if (pbDecrypted)
        _nt_free(pbDecrypted, cbData - sizeof(BLOBHEADER));
    if ((fRet == FALSE) && pTmpKey)
    {
        FreeNewKey(pTmpKey);
    }
    return fRet;
}


/*
 -  CPImportKey
 -
 *  Purpose:
 *                Import cryptographic keys
 *
 *
 *  Parameters:
 *               IN  hUID      -  Handle to the CSP user
 *               IN  pbData    -  Key blob data
 *               IN  dwDataLen -  Length of the key blob data
 *               IN  hPubKey   -  Handle to the exchange public key value of
 *                                the destination user
 *               IN  dwFlags   -  Flags values
 *               OUT phKey     -  Pointer to the handle to the key which was
 *                                Imported
 *
 *  Returns:
 */
BOOL CPImportKey(IN HCRYPTPROV hUID,
                 IN CONST BYTE *pbData,
                 IN DWORD dwDataLen,
                 IN HCRYPTKEY hPubKey,
                 IN DWORD dwFlags,
                 OUT HCRYPTKEY *phKey)
{
    // miscellaneous variables
    DWORD               KeyBufLen;
    CONST BYTE          *pbEncPortion;
    BLOBHEADER          *ThisStdHeader = (BLOBHEADER *)pbData;
    BSAFE_PRV_KEY       *pBsafePrvKey = NULL;
    DWORD               cbBsafePrvKey = 0;
    BYTE                *pKeyBuf = NULL;
    DWORD               dwRights = 0;
    DWORD               cbTmpLen;

    // temporary variables for pointing to user and key records
    PNTAGUserList       pTmpUser;
    PNTAGKeyList        pTmpKey = NULL;
    LPWSTR              szPrompt;
    BLOBHEADER          *pPublic;
    RSAPUBKEY           *pImpPubKey;
    BSAFE_PUB_KEY       *pBsafePubKey;

    PBYTE               pbData2 = NULL;
    DWORD               cb;
    DWORD               *pcbPub;
    BYTE                **ppbPub;
    DWORD               *pcbPrv;
    BYTE                **ppbPrv;
    BOOL                *pfExportable;
    BOOL                fExch;
    PEXPORT_PRV_KEY     pExportKey;
    BOOL                fPubKey = FALSE;

    NTSimpleBlob        *ThisSB;

    PNTAGKeyList        pExPubKey = NULL;
    BOOL                fInCritSec = FALSE;

    BYTE                *pbParams = NULL;
    DWORD               cbParams = 0;
    DWORD               dwErr;

    BOOL                fRet = NTF_FAILED;

#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputImportKey(TRUE, FALSE, hUID, (BYTE*)pbData, dwDataLen,
                            hPubKey, dwFlags, phKey);
#endif // DBG -- NOTE:  This section not compiled for retail builds

    // Validate user pointer
//    count = *phKey;

    if ((dwFlags & ~(CRYPT_USER_PROTECTED | CRYPT_EXPORTABLE |
                     CRYPT_NO_SALT | CRYPT_SGCKEY | CRYPT_OAEP)) != 0)
    {
        SetLastError((DWORD) NTE_BAD_FLAGS);
        goto Ret;
    }

    if ((PUBLICKEYBLOB == ThisStdHeader->bType) && (0 != hPubKey))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    // check the user identification
    if ((pTmpUser = (PNTAGUserList) NTLCheckList ((HNTAG)hUID,
                                                  USER_HANDLE)) == NULL)
    {
        SetLastError((DWORD) NTE_BAD_UID);
        goto Ret;
    }

    if (ThisStdHeader->bVersion != CUR_BLOB_VERSION)
    {
        SetLastError((DWORD) NTE_BAD_VER);
        goto Ret;
    }

    // Handy pointer for decrypting the blob...
    pbEncPortion = pbData + sizeof(BLOBHEADER) + sizeof(NTSimpleBlob);

    // determine which key blob is being imported
    switch (ThisStdHeader->bType)
    {
        case PUBLICKEYBLOB:
        {
            pPublic = (BLOBHEADER *) pbData;
            pImpPubKey = (RSAPUBKEY *)(pbData+sizeof(BLOBHEADER));

            if ((pPublic->aiKeyAlg != CALG_RSA_KEYX) &&
                 (pPublic->aiKeyAlg != CALG_RSA_SIGN))
            {
                SetLastError((DWORD) NTE_BAD_DATA);
                goto Ret;
            }

            cbTmpLen = (sizeof(DWORD) * 2) -
                       (((pImpPubKey->bitlen + 7) / 8) % (sizeof(DWORD) * 2));
            if ((sizeof(DWORD) * 2) != cbTmpLen)
                cbTmpLen += sizeof(DWORD) * 2;
            if ((pTmpKey = MakeNewKey(pPublic->aiKeyAlg,
                                      0,
                                      sizeof(BSAFE_PUB_KEY) +
                                      (pImpPubKey->bitlen / 8) + cbTmpLen,
                                      hUID,
                                      0,
                                      FALSE))==NULL)
            {
                goto Ret;
            }

            pBsafePubKey = (BSAFE_PUB_KEY *) pTmpKey->pKeyValue;
            pBsafePubKey->magic = pImpPubKey->magic;
            pBsafePubKey->keylen = (pImpPubKey->bitlen / 8) + cbTmpLen;
            pBsafePubKey->bitlen = pImpPubKey->bitlen;
            pBsafePubKey->datalen = (pImpPubKey->bitlen+7)/8 - 1;
            pBsafePubKey->pubexp = pImpPubKey->pubexp;

            memset((BYTE *) pBsafePubKey + sizeof(BSAFE_PUB_KEY),
                   '\0', pBsafePubKey->keylen);

            memcpy((BYTE *) pBsafePubKey + sizeof(BSAFE_PUB_KEY),
                   (BYTE *) pPublic + sizeof(BLOBHEADER) + sizeof(RSAPUBKEY),
                   (pImpPubKey->bitlen+7)/8);

            if (NTLMakeItem(phKey,
                            (BYTE) (pPublic->aiKeyAlg == CALG_RSA_KEYX ?
                            EXCHPUBKEY_HANDLE : SIGPUBKEY_HANDLE),
                            (void *)pTmpKey) == NTF_FAILED)
            {
                goto Ret;
            }
            break;
        }

        case PRIVATEKEYBLOB:
        {
            // wrap with a try since there is a critical sections in here
            try
            {
                EnterCriticalSection(&pTmpUser->CritSec);
                fInCritSec = TRUE;

                pPublic = (BLOBHEADER *) pbData;

                cb = dwDataLen - sizeof(BLOBHEADER);
                if (NULL == (pbData2 = _nt_malloc(cb)))
                {
                    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    goto Ret;
                }
                CopyMemory(pbData2, pbData + sizeof(BLOBHEADER), cb);
                if (hPubKey)
                {
                    if (!LocalDecrypt(hUID, hPubKey, 0, TRUE, 0,
                                      pbData2, &cb, FALSE))
                    {
                        goto Ret;
                    }
                }

                if (pPublic->aiKeyAlg == CALG_RSA_KEYX)
                {
                    if (PROV_RSA_SIG == pTmpUser->dwProvType)
                    {
                        SetLastError((DWORD)NTE_BAD_DATA);
                        goto Ret;
                    }
                    pcbPub = &pTmpUser->ContInfo.ContLens.cbExchPub;
                    ppbPub = &pTmpUser->ContInfo.pbExchPub;
                    pcbPrv = &pTmpUser->ExchPrivLen;
                    ppbPrv = &pTmpUser->pExchPrivKey;
                    pfExportable = &pTmpUser->ContInfo.fExchExportable;
                    fExch = TRUE;
                    szPrompt = g_Strings.pwszImportPrivExch;
                }
                else if (pPublic->aiKeyAlg == CALG_RSA_SIGN)
                {
                    if (PROV_RSA_SCHANNEL == pTmpUser->dwProvType)
                    {
                        SetLastError((DWORD)NTE_BAD_DATA);
                        goto Ret;
                    }
                    pcbPub = &pTmpUser->ContInfo.ContLens.cbSigPub;
                    ppbPub = &pTmpUser->ContInfo.pbSigPub;
                    pcbPrv = &pTmpUser->SigPrivLen;
                    ppbPrv = &pTmpUser->pSigPrivKey;
                    fExch = FALSE;
                    pfExportable = &pTmpUser->ContInfo.fSigExportable;
                    szPrompt = g_Strings.pwszImportPrivSig;
                }
                else
                {
                    SetLastError((DWORD) NTE_BAD_DATA);
                    goto Ret;
                }

                // check the length of the key exchange key
                pExportKey = (PEXPORT_PRV_KEY)pbData2;

                // check if the provider is an SChannel provider and if so if the
                // SGC flag is set then use the FIsLegalSGCKeySize function
                if ((PROV_RSA_SCHANNEL == pTmpUser->dwProvType) &&
                    (!(pTmpUser->Rights & CRYPT_VERIFYCONTEXT)) &&  // make sure this is server side
                    (0 != pTmpUser->dwSGCFlags))
                {
                    if (!FIsLegalSGCKeySize(pPublic->aiKeyAlg,
                                            pExportKey->bitlen / 8,
                                            FALSE, FALSE, &fPubKey))
                    {
                        SetLastError((DWORD) NTE_BAD_DATA);
                        goto Ret;
                    }
                }
                else
                {
                    if (!FIsLegalKeySize(pPublic->aiKeyAlg,
                                         pExportKey->bitlen / 8,
                                         FALSE, dwFlags, &fPubKey))
                    {
                        SetLastError((DWORD) NTE_BAD_DATA);
                        goto Ret;
                    }
                }

                if (!fPubKey)
                {
                    SetLastError((DWORD) NTE_BAD_DATA);
                    goto Ret;
                }

                if (*ppbPub)
                {
                    ASSERT(*pcbPub);
                    ASSERT(*pcbPrv);
                    ASSERT(*ppbPrv);

                    _nt_free (*ppbPub, *pcbPub);
                    *ppbPub = NULL;
                    *pcbPub = 0;

                    _nt_free (*ppbPrv, *pcbPrv);
                    *ppbPrv = NULL;
                    *pcbPrv = 0;
                }

                if (!PreparePrivateKeyForImport(pbData2, cb, NULL, pcbPrv, NULL, pcbPub))
                {
                    SetLastError((DWORD) NTE_BAD_DATA);
                    goto Ret;
                }

                if (NULL == (*ppbPub = _nt_malloc(*pcbPub)))
                {
                    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    goto Ret;
                }
                if (NULL == (*ppbPrv = _nt_malloc(*pcbPrv)))
                {
                    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    goto Ret;
                }

                if (!PreparePrivateKeyForImport(pbData2, cb, (LPBSAFE_PRV_KEY)*ppbPrv,
                                                pcbPrv, (LPBSAFE_PUB_KEY)*ppbPub, pcbPub))
                {
                    SetLastError((DWORD) NTE_BAD_DATA);
                    goto Ret;
                }

                if (dwFlags & CRYPT_EXPORTABLE)
                    *pfExportable = TRUE;
                else
                    *pfExportable = FALSE;

                // test the RSA key to make sure it works
                if (0 != (dwErr = EncryptAndDecryptWithRSAKey(*ppbPub,
                                                              *ppbPrv,
                                                              TRUE,
                                                              FALSE)))
                {
                    SetLastError((DWORD)NTE_BAD_DATA);
                    goto Ret;
                }

                if (0 != (dwErr = EncryptAndDecryptWithRSAKey(*ppbPub,
                                                              *ppbPrv,
                                                              FALSE,
                                                              FALSE)))
                {
                    SetLastError((DWORD)NTE_BAD_DATA);
                    goto Ret;
                }

                // if the context being used is a Verify Context then the key is not
                // persisted to storage
                if (!(pTmpUser->Rights & CRYPT_VERIFYCONTEXT))
                {
                    // write the new keys to the user storage file
                    if (!ProtectPrivKey(pTmpUser, szPrompt, dwFlags, (!fExch)))
                    {
                        goto Ret;          // error already set
                    }
                }

                if (NTF_FAILED == CPGetUserKey(
                                        hUID,
                                        (fExch ? AT_KEYEXCHANGE : AT_SIGNATURE),
                                        phKey))
                {
                    goto Ret;
                }
            }
            except ( EXCEPTION_EXECUTE_HANDLER )
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                goto Ret;
            }
        break;
        }

        case SIMPLEBLOB:
        {
            ThisSB = (NTSimpleBlob *) (pbData + sizeof(BLOBHEADER));

            if (!ValidKeyAlgid(pTmpUser, ThisStdHeader->aiKeyAlg))
            {
                SetLastError((DWORD) NTE_BAD_TYPE);
                goto Ret;
            }

            if (ThisSB->aiEncAlg != CALG_RSA_KEYX)
            {
                SetLastError((DWORD) NTE_BAD_ALGID);
                goto Ret;
            }

            // if the import key handle is not zero make sure it is the
            if (hPubKey)
            {
                if ((pExPubKey = (PNTAGKeyList) NTLValidate((HNTAG)hPubKey,
                                  hUID, HNTAG_TO_HTYPE((HNTAG)hPubKey))) == NULL)
                {
                    // NTLValidate doesn't know what error to set
                    // so it set NTE_FAIL -- fix it up.
                    if (GetLastError() == NTE_FAIL)
                        SetLastError((DWORD) NTE_BAD_KEY);

                    goto Ret;
                }

                if ((pTmpUser->ContInfo.ContLens.cbExchPub != pExPubKey->cbKeyLen)||
                    memcmp((PBYTE)pExPubKey->pKeyValue, pTmpUser->ContInfo.pbExchPub,
                           pExPubKey->cbKeyLen))
                {
                    SetLastError((DWORD) NTE_BAD_KEY);
                    goto Ret;
                }

                pbParams = pExPubKey->pbParams;
                cbParams = pExPubKey->cbParams;
            }

            // check if the provider is an SChannel provider and if so if the
            // SGC flag is set then use the FIsLegalSGCKeySize function
            pBsafePubKey = (BSAFE_PUB_KEY *)pTmpUser->ContInfo.pbExchPub;
            if (NULL == pBsafePubKey)
            {
                SetLastError((DWORD)NTE_NO_KEY);
                goto Ret;
            }
            if ((PROV_RSA_SCHANNEL == pTmpUser->dwProvType) &&
                (!(pTmpUser->Rights & CRYPT_VERIFYCONTEXT)) &&  // make sure this is server side
                (0 != pTmpUser->dwSGCFlags))
            {
                if (!FIsLegalSGCKeySize(CALG_RSA_KEYX,
                                        pBsafePubKey->bitlen / 8,
                                        FALSE, FALSE, &fPubKey))
                {
                    SetLastError((DWORD) NTE_BAD_DATA);
                    goto Ret;
                }
            }
            else
            {
                if (!FIsLegalKeySize(CALG_RSA_KEYX,
                                     pBsafePubKey->bitlen / 8,
                                     FALSE, 0, &fPubKey))
                {
                    SetLastError((DWORD) NTE_BAD_DATA);
                    goto Ret;
                }
            }

            // get the key to use
            if (!UnprotectPrivKey(pTmpUser, g_Strings.pwszImportSimple,
                                  FALSE, FALSE))
            {
                SetLastError((DWORD)NTE_NO_KEY);
                goto Ret;
            }
            pBsafePrvKey = (BSAFE_PRV_KEY *) pTmpUser->pExchPrivKey;

            if(NULL == pBsafePrvKey)
            {
                SetLastError((DWORD)NTE_NO_KEY);
                goto Ret;
            }

            // perform the RSA decryption
            if (!RSADecrypt(pTmpUser, pBsafePrvKey,
                            (char *)pbData + sizeof(BLOBHEADER) +
                                    sizeof(NTSimpleBlob),
                            sizeof(BLOBHEADER) + sizeof(NTSimpleBlob),
                            pbParams, cbParams, dwFlags,
                            &pKeyBuf,
                            &KeyBufLen))
            {
                goto Ret;
            }

            // check if the key is CRYPT_EXPORTABLE
            if (dwFlags & CRYPT_EXPORTABLE)
                dwRights = CRYPT_EXPORTABLE;

#ifdef CSP_USE_SSL3
            // if SSL3 or TLS1 master key then check the version
            if (CALG_SSL3_MASTER == ThisStdHeader->aiKeyAlg || 
                CALG_TLS1_MASTER == ThisStdHeader->aiKeyAlg)
            {
                if (MAKEWORD(pKeyBuf[1], pKeyBuf[0]) < 0x300)
                {
                    SetLastError((DWORD)NTE_BAD_DATA);
                    goto Ret;
                }
            }
#endif // CSP_USE_SSL3

            if ((pTmpKey = MakeNewKey(ThisStdHeader->aiKeyAlg,
                                      dwRights,
                                      KeyBufLen,
                                      hUID,
                                      pKeyBuf,
                                      TRUE)) == NULL)
            {
                goto Ret;
            }
            pKeyBuf = NULL;

            // check keylength...
            if (!FIsLegalKey(pTmpUser, pTmpKey, TRUE))
            {
                goto Ret;
            }

            if (NTLMakeItem(phKey, KEY_HANDLE, (void *)pTmpKey) == NTF_FAILED)
            {
                goto Ret;          // error already set
            }

            // if 40 bit key + no mention of salt, set zeroized salt for RSABase compatibility
            if ((5 == KeyBufLen) && (!(dwFlags & CRYPT_NO_SALT)) &&
                (CALG_SSL2_MASTER != ThisStdHeader->aiKeyAlg))
            {
                if (!MakeKeyRSABaseCompatible(hUID, *phKey))
                    goto Ret;
            }
            break;
        }

        case OPAQUEKEYBLOB:
        {
            if (!ImportOpaqueBlob(hUID, pTmpUser, dwFlags, pbData, dwDataLen, phKey))
                goto Ret;
            break;
        }

        case SYMMETRICWRAPKEYBLOB:
        {
            // get a pointer to the symmetric key to unwrap with (the variable
            // name pExPubKey is a misnomer)
            if ((pExPubKey = (PNTAGKeyList) NTLValidate((HNTAG)hPubKey,
                              hUID, HNTAG_TO_HTYPE((HNTAG)hPubKey))) == NULL)
            {
                // NTLValidate doesn't know what error to set
                // so it set NTE_FAIL -- fix it up.
                if (GetLastError() == NTE_FAIL)
                    SetLastError((DWORD) NTE_BAD_KEY);

                goto Ret;
            }

            if (0 != (dwErr = UnWrapSymKey(hUID, pTmpUser, pExPubKey,
                                           (BYTE*)pbData, dwDataLen,
                                           dwFlags, phKey)))
            {
                SetLastError(dwErr);
                goto Ret;
            }

            break;
        }

        default:
            SetLastError((DWORD) NTE_BAD_TYPE);
            goto Ret;
    }

    fRet = NTF_SUCCEED;
Ret:
#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputImportKey(FALSE, fRet, 0, NULL, 0, 0, 0, phKey);
#endif // DBG -- NOTE:  This section not compiled for retail builds

    if (fInCritSec)
    {
        LeaveCriticalSection(&pTmpUser->CritSec);
    }
    if (pKeyBuf)
        _nt_free(pKeyBuf, KeyBufLen);
    if (pbData2)
        _nt_free(pbData2, dwDataLen - sizeof(BLOBHEADER));
    if ((NTF_FAILED == fRet) && pTmpKey)
        FreeNewKey(pTmpKey);

    return fRet;
}


/*
 -  CPInflateKey
 -
 *  Purpose:
 *                Use to "inflate" (expand) a cryptographic key for use with
 *                the CryptEncrypt and CryptDecrypt functions
 *
 *  Parameters:
 *               IN      hUID    -  Handle to a CSP
 *               IN      hKey    -  Handle to a key
 *               IN      dwFlags -  Flags values
 *
 *  Returns:
 */
BOOL CPInflateKey(
                  IN PNTAGKeyList pTmpKey
                  )
{
    BYTE                *pbRealKey = NULL;
    BOOL                fRet = NTF_FAILED;

    // if space for the key table has been allocated previously
    // then free it
    if (pTmpKey->pData != NULL)
    {
        ASSERT(pTmpKey->cbDataLen);
        _nt_free (pTmpKey->pData, pTmpKey->cbDataLen);
        pTmpKey->cbDataLen = 0;
    }
    else
    {
        ASSERT(pTmpKey->cbDataLen == 0);
    }

    // determine the algorithm to be used
    switch (pTmpKey->Algid)
    {

#ifdef CSP_USE_RC2

        case CALG_RC2:

            if ((pTmpKey->pData = (BYTE *)_nt_malloc(RC2_TABLESIZE)) == NULL)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return NTF_FAILED;
            }

            if (NULL == (pbRealKey = (BYTE *)_nt_malloc(pTmpKey->cbKeyLen +
                                                        pTmpKey->cbSaltLen)))
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }

            memcpy(pbRealKey, pTmpKey->pKeyValue, pTmpKey->cbKeyLen);
            memcpy(pbRealKey+pTmpKey->cbKeyLen, pTmpKey->rgbSalt, pTmpKey->cbSaltLen);

            pTmpKey->cbDataLen = RC2_TABLESIZE;

            RC2KeyEx((WORD *)pTmpKey->pData,
                     pbRealKey,
                     pTmpKey->cbKeyLen + pTmpKey->cbSaltLen,
                     pTmpKey->EffectiveKeyLen);

            break;

#endif

#ifdef CSP_USE_RC4

        case CALG_RC4:

            if ((pTmpKey->pData = (BYTE *)_nt_malloc(sizeof(RC4_KEYSTRUCT)))
                         == NULL)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }

            if (NULL == (pbRealKey = (BYTE *)_nt_malloc(pTmpKey->cbKeyLen +
                                                        pTmpKey->cbSaltLen)))
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }

            memcpy(pbRealKey, pTmpKey->pKeyValue, pTmpKey->cbKeyLen);
            memcpy(pbRealKey+pTmpKey->cbKeyLen, pTmpKey->rgbSalt, pTmpKey->cbSaltLen);

            pTmpKey->cbDataLen = sizeof(RC4_KEYSTRUCT);

            rc4_key((struct RC4_KEYSTRUCT *)pTmpKey->pData, pTmpKey->cbKeyLen+pTmpKey->cbSaltLen,
                    pbRealKey);

            break;

#endif

#ifdef CSP_USE_DES

        case CALG_DES:

            if ((pTmpKey->pData = (BYTE *)_nt_malloc(DES_TABLESIZE)) == NULL)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }

            pTmpKey->cbDataLen = DES_TABLESIZE;

            deskey((DESTable *)pTmpKey->pData, pTmpKey->pKeyValue);

            break;

#endif

#ifdef CSP_USE_3DES

        case CALG_3DES_112:

            if ((pTmpKey->pData = (BYTE *)_nt_malloc(DES3_TABLESIZE)) == NULL)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }

            pTmpKey->cbDataLen = DES3_TABLESIZE;

            tripledes2key((PDES3TABLE)pTmpKey->pData, pTmpKey->pKeyValue);

            break;

        case CALG_3DES:

            if ((pTmpKey->pData = (BYTE *)_nt_malloc(DES3_TABLESIZE)) == NULL)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }

            pTmpKey->cbDataLen = DES3_TABLESIZE;

            tripledes3key((PDES3TABLE)pTmpKey->pData, pTmpKey->pKeyValue);

            break;

#endif

#ifdef CSP_USE_SSL3
        case CALG_SSL3_MASTER:
        case CALG_PCT1_MASTER:
        case CALG_SCHANNEL_MAC_KEY:
            break;
#endif

        default:
            SetLastError((DWORD) NTE_BAD_TYPE);
            goto Ret;
            break;
        }

    fRet = NTF_SUCCEED;
Ret:
    if (pbRealKey)
    {
        _nt_free(pbRealKey, pTmpKey->cbKeyLen + pTmpKey->cbSaltLen);
    }
    return fRet;
}

/*
 -  CPDestroyKey
 -
 *  Purpose:
 *                Destroys the cryptographic key that is being referenced
 *                with the hKey parameter
 *
 *
 *  Parameters:
 *               IN      hUID   -  Handle to a CSP
 *               IN      hKey   -  Handle to a key
 *
 *  Returns:
 */
BOOL CPDestroyKey(IN HCRYPTPROV hUID,
                  IN HCRYPTKEY hKey)
{
    PNTAGKeyList    pTmpKey;
    DWORD           dwErr;
    BOOL            fRet = NTF_FAILED;

#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputDestroyKey(TRUE, FALSE, hUID, hKey);
#endif // DBG -- NOTE:  This section not compiled for retail builds 

    // check the user identification
    if (NTLCheckList ((HNTAG)hUID, USER_HANDLE) == NULL)
    {
        SetLastError((DWORD) NTE_BAD_UID);
        goto Ret;
    }
    dwErr = GetLastError();
    if ((pTmpKey = (PNTAGKeyList) NTLValidate((HNTAG)hKey,
                        hUID, SIGPUBKEY_HANDLE)) == NULL &&
        (pTmpKey = (PNTAGKeyList) NTLValidate((HNTAG)hKey,
                        hUID, EXCHPUBKEY_HANDLE)) == NULL &&
        (pTmpKey = (PNTAGKeyList)NTLValidate((HNTAG)hKey,
                        hUID, KEY_HANDLE)) == NULL)
    {
            // NTLValidate doesn't know what error to set
        // so it set NTE_FAIL -- fix it up.
        if (GetLastError() == NTE_FAIL)
        {
            SetLastError((DWORD) NTE_BAD_KEY);
        }
        goto Ret;
    }
    SetLastError(dwErr);

    // Remove from internal list first so others can't get to it, then free.
    NTLDelete((HNTAG)hKey);

    // scrub the memory where the key information was held
    if (pTmpKey->pKeyValue)
    {
        ASSERT(pTmpKey->cbKeyLen);
        memset(pTmpKey->pKeyValue, 0, pTmpKey->cbKeyLen);
        _nt_free (pTmpKey->pKeyValue, pTmpKey->cbKeyLen);
    }
    if (pTmpKey->pbParams)
    {
        _nt_free (pTmpKey->pbParams, pTmpKey->cbParams);
    }

    if (pTmpKey->pData)
    {
        ASSERT(pTmpKey->cbDataLen);
#ifndef _XBOX        
        if ((CALG_SSL3_MASTER == pTmpKey->Algid) ||
            (CALG_PCT1_MASTER == pTmpKey->Algid))
        {
            FreeSChKey((PSCH_KEY)pTmpKey->pData);
        }
#endif
        memset(pTmpKey->pData, 0, pTmpKey->cbDataLen);
        _nt_free (pTmpKey->pData, pTmpKey->cbDataLen);
    }
    _nt_free (pTmpKey, sizeof(NTAGKeyList));

    fRet = NTF_SUCCEED;
Ret:
#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputDestroyKey(FALSE, fRet, 0, 0);
#endif // DBG -- NOTE:  This section not compiled for retail builds 

    return fRet;
}

/*
 -  CPGetUserKey
 -
 *  Purpose:
 *                Gets a handle to a permanent user key
 *
 *
 *  Parameters:
 *               IN  hUID       -  Handle to the user identifcation
 *               IN  dwWhichKey -  Specification of the key to retrieve
 *               OUT phKey      -  Pointer to key handle of retrieved key
 *
 *  Returns:
 */
BOOL CPGetUserKey(IN HCRYPTPROV hUID,
                  IN DWORD dwWhichKey,
                  OUT HCRYPTKEY *phKey)
{

    PNTAGUserList   pUser;
    PNTAGKeyList    pTmpKey;
    ALG_ID          Algid;
    DWORD           cb;
    BYTE            *pb;
    BYTE            bType;
    DWORD           dwExportability = 0;
    DWORD           dwErr;
    BOOL            fRet = NTF_FAILED;

#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputGetUserKey(TRUE, FALSE, hUID, dwWhichKey, phKey);
#endif // DBG -- NOTE:  This section not compiled for retail builds 

    // check the user identification
    if ((pUser = (PNTAGUserList) NTLCheckList(hUID, USER_HANDLE)) == NULL)
    {
        SetLastError((DWORD)NTE_BAD_UID);
        goto Ret;
    }

    switch (dwWhichKey)
    {
        case AT_KEYEXCHANGE:
            Algid = CALG_RSA_KEYX;
            cb = pUser->ContInfo.ContLens.cbExchPub;
            pb = pUser->ContInfo.pbExchPub;
            if (pUser->ContInfo.fExchExportable)
                dwExportability = CRYPT_EXPORTABLE;
            bType = EXCHPUBKEY_HANDLE;
            break;

        case AT_SIGNATURE:
            Algid = CALG_RSA_SIGN;
            cb = pUser->ContInfo.ContLens.cbSigPub;
            pb = pUser->ContInfo.pbSigPub;
            if (pUser->ContInfo.fSigExportable)
                dwExportability = CRYPT_EXPORTABLE;
            bType = SIGPUBKEY_HANDLE;
            break;

        default:
            SetLastError((DWORD)NTE_BAD_KEY);
            goto Ret;
    }

    if (!ValidKeyAlgid(pUser, Algid))
    {
        SetLastError((DWORD)NTE_BAD_TYPE);
        goto Ret;
    }

    if (0 == cb)
    {
        SetLastError((DWORD)NTE_NO_KEY);
        goto Ret;
    }

    if (NULL == (pTmpKey = MakeNewKey(Algid,
                                      dwExportability,
                                      cb,
                                      hUID,
                                      pb,
                                      FALSE)))
    {
        goto Ret;
    }

    if (NTF_FAILED == NTLMakeItem(phKey, bType, (void *)pTmpKey))
        goto Ret;      // error already set

    fRet = NTF_SUCCEED;
Ret:
#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputGetUserKey(FALSE, fRet, 0, 0, phKey);
#endif // DBG -- NOTE:  This section not compiled for retail builds

    return fRet;
}

/*
 -  CPSetKeyParam
 -
 *  Purpose:
 *                Allows applications to customize various aspects of the
 *                operations of a key
 *
 *  Parameters:
 *               IN      hUID    -  Handle to a CSP
 *               IN      hKey    -  Handle to a key
 *               IN      dwParam -  Parameter number
 *               IN      pbData  -  Pointer to data
 *               IN      dwFlags -  Flags values
 *
 *  Returns:
 */
BOOL CPSetKeyParam(IN HCRYPTPROV hUID,
                   IN HCRYPTKEY hKey,
                   IN DWORD dwParam,
                   IN BYTE *pbData,
                   IN DWORD dwFlags)
{
    PNTAGUserList       pTmpUser;
    PNTAGKeyList        pTmpKey;
    PCRYPT_DATA_BLOB    psData;
    DWORD               *pdw;
    DWORD               dw;
    DWORD               dwKeySpec;
    BOOL                fRet = NTF_FAILED;

#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputSetKeyParam(TRUE, FALSE, hUID, hKey, dwParam, pbData, dwFlags);
#endif // DBG -- NOTE:  This section not compiled for retail builds

    if ((dwFlags & ~CRYPT_SERVER) != 0)
    {
        SetLastError((DWORD) NTE_BAD_FLAGS);
        goto Ret;
    }

    // check the user identification
    if ((pTmpUser = (PNTAGUserList)NTLCheckList(hUID, USER_HANDLE)) == NULL)
    {
        SetLastError((DWORD) NTE_BAD_UID);
        goto Ret;
    }

    if ((pTmpKey = (PNTAGKeyList)NTLValidate((HNTAG)hKey,
                                              hUID, KEY_HANDLE)) == NULL &&
        (pTmpKey = (PNTAGKeyList)NTLValidate((HNTAG)hKey,
                                           hUID, SIGPUBKEY_HANDLE)) == NULL &&
        (pTmpKey = (PNTAGKeyList)NTLValidate((HNTAG)hKey,
                                          hUID, EXCHPUBKEY_HANDLE)) == NULL)
    {
        // NTLValidate doesn't know what error to set
        // so it set NTE_FAIL -- fix it up.
        if (GetLastError() == NTE_FAIL)
        {
            SetLastError((DWORD) NTE_BAD_KEY);
        }
        goto Ret;
    }
    switch (dwParam)
    {
        case KP_IV:
            memcpy(pTmpKey->IV, pbData, RC2_BLOCKLEN);
            break;

        case KP_SALT:
            if ((CALG_RC2 != pTmpKey->Algid) && (CALG_RC4 != pTmpKey->Algid))
            {
                SetLastError((DWORD) NTE_BAD_KEY);
                goto Ret;
            }

            if (pbData == NULL)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                goto Ret;
            }

#ifdef STRONG
            if (pTmpUser->fNewStrongCSP)
            {
                pTmpKey->cbSaltLen = DEFAULT_SALT_NEWSTRONG_LENGTH;
            }
            else
            {
                pTmpKey->cbSaltLen = DEFAULT_SALT_LENGTH;
            }
#else
            pTmpKey->cbSaltLen = DEFAULT_SALT_LENGTH;
#endif // STRONG
            if (pTmpKey->cbSaltLen)
            {
                CopyMemory(pTmpKey->rgbSalt, pbData, pTmpKey->cbSaltLen);
            }

            if (NTAG_FAILED(CPInflateKey(pTmpKey)))
                goto Ret;

            break;

        case KP_SALT_EX:
            if ((CALG_RC2 != pTmpKey->Algid) && (CALG_RC4 != pTmpKey->Algid))
            {
                SetLastError((DWORD) NTE_BAD_KEY);
                goto Ret;
            }

            psData = (PCRYPT_DATA_BLOB)pbData;

            if (pbData == NULL)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                goto Ret;
            }

            pTmpKey->cbSaltLen = psData->cbData;
            CopyMemory(pTmpKey->rgbSalt, psData->pbData, pTmpKey->cbSaltLen);

            if (NTAG_FAILED(CPInflateKey(pTmpKey)))
                goto Ret;

            break;

        case KP_PADDING:
            if (*((DWORD *) pbData) != PKCS5_PADDING)
            {
                SetLastError((DWORD) NTE_BAD_DATA);
                goto Ret;
            }
            break;

        case KP_MODE:
            if ((CALG_RSA_SIGN == pTmpKey->Algid) ||
                (CALG_RSA_KEYX == pTmpKey->Algid))
            {
                SetLastError((DWORD) NTE_BAD_KEY);
                goto Ret;
            }

            if (*pbData != CRYPT_MODE_CBC &&
                *pbData != CRYPT_MODE_ECB &&
                *pbData != CRYPT_MODE_CFB &&
                *pbData != CRYPT_MODE_OFB)
            {
                SetLastError((DWORD) NTE_BAD_DATA);
                goto Ret;
            }
            pTmpKey->Mode = *((DWORD *) pbData);
            break;

        case KP_MODE_BITS:
            dw = *((DWORD *) pbData);
            if ((dw == 0) || (dw > 64))       // if 0 or larger than the blocklength
            {
                SetLastError((DWORD) NTE_BAD_DATA);
                goto Ret;
            }

            pTmpKey->ModeBits = dw;
            break;

        case KP_PERMISSIONS:
            if (*pbData & ~(CRYPT_ENCRYPT|CRYPT_DECRYPT|CRYPT_EXPORT|
                            CRYPT_READ|CRYPT_WRITE|CRYPT_MAC))
            {
                SetLastError((DWORD) NTE_BAD_FLAGS);
                goto Ret;
            }

            // the exportability of a key may not be changed
            if (*((DWORD *) pbData) & CRYPT_EXPORT)
            {
                if (!(pTmpKey->Permissions & CRYPT_EXPORT))
                {
                    SetLastError((DWORD) NTE_BAD_DATA);
                    goto Ret;
                }
            }
            else
            {
                if (pTmpKey->Permissions & CRYPT_EXPORT)
                {
                    SetLastError((DWORD) NTE_BAD_DATA);
                    goto Ret;
                }
            }

            pTmpKey->Permissions = *((DWORD *) pbData);
            break;

        case KP_EFFECTIVE_KEYLEN:
            if (CALG_RC2 != pTmpKey->Algid)
            {
                SetLastError((DWORD)NTE_BAD_KEY);
                goto Ret;
            }

            pdw = (DWORD*)pbData;
            if ((*pdw < RC2_MIN_EFFECTIVE_KEYLEN) || (*pdw > RC2_MAX_EFFECTIVE_KEYLEN))
            {
                SetLastError((DWORD)NTE_BAD_DATA);
                goto Ret;
            }

            pTmpKey->EffectiveKeyLen = *pdw;

            if (NTAG_FAILED(CPInflateKey(pTmpKey)))
                goto Ret;

            break;

#ifdef CSP_USE_SSL3
        case KP_CLIENT_RANDOM:
        case KP_SERVER_RANDOM:
        case KP_CERTIFICATE:
        case KP_CLEAR_KEY:
        case KP_SCHANNEL_ALG:
            if (PROV_RSA_SCHANNEL != pTmpUser->dwProvType)
            {
                SetLastError((DWORD)NTE_BAD_TYPE);
                goto Ret;
            }

            if (!SCHSetKeyParam(pTmpUser, pTmpKey, dwParam, pbData))
                goto Ret;
            break;
#endif // CSP_USE_SSL3

        case KP_OAEP_PARAMS:
            if (CALG_RSA_KEYX != pTmpKey->Algid)
            {
                SetLastError((DWORD)NTE_BAD_KEY);
                goto Ret;
            }

            psData = (PCRYPT_DATA_BLOB)pbData;

            if (pbData == NULL)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                goto Ret;
            }

            // free salt if it already exists
            if (pTmpKey->pbParams)
            {
                _nt_free(pTmpKey->pbParams, pTmpKey->cbParams);
            }
            pTmpKey->pbParams = NULL;

            pTmpKey->cbParams = psData->cbData;

            // alloc variable size
            if ((pTmpKey->pbParams = (BYTE *)_nt_malloc(pTmpKey->cbParams)) == NULL)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                pTmpKey->cbParams = 0;
                goto Ret;
            }
            CopyMemory(pTmpKey->pbParams, psData->pbData, pTmpKey->cbParams);

            break;

#ifdef CSP_USE_SSL3
        case KP_HIGHEST_VERSION:
            if ((CALG_SSL3_MASTER != pTmpKey->Algid) &&
                (CALG_TLS1_MASTER != pTmpKey->Algid))
            {
                SetLastError((DWORD)NTE_BAD_KEY);
                goto Ret;
            }

            if (pbData == NULL)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                goto Ret;
            }

            if (dwFlags & CRYPT_SERVER)
            {
                if((CALG_SSL3_MASTER == pTmpKey->Algid) && (*(DWORD *)pbData >= 0x301))
                {
                    // We're a server doing SSL3, and we also support TLS1.
                    // If the pre_master_secret contains a version number
                    // greater than or equal to TLS1, then abort the connection.
                    if(MAKEWORD(pTmpKey->pKeyValue[1], pTmpKey->pKeyValue[0]) >= 0x301)
                    {
                        SetLastError((DWORD)NTE_BAD_VER);
                        goto Ret;
                    }
                }
            }
            else
            {
                pTmpKey->pKeyValue[0] = HIBYTE(*(DWORD *)pbData);
                pTmpKey->pKeyValue[1] = LOBYTE(*(DWORD *)pbData);
            }

            break;
#endif // CSP_USE_SSL3

        default:
            SetLastError((DWORD) NTE_BAD_TYPE);
            goto Ret;
            break;

    }

    fRet = NTF_SUCCEED;
Ret:
#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputSetKeyParam(FALSE, fRet, 0, 0, 0, NULL, 0);
#endif // DBG -- NOTE:  This section not compiled for retail builds

    return fRet;
}


/*
 -  CPGetKeyParam
 -
 *  Purpose:
 *                Allows applications to get various aspects of the
 *                operations of a key
 *
 *  Parameters:
 *               IN      hUID       -  Handle to a CSP
 *               IN      hKey       -  Handle to a key
 *               IN      dwParam    -  Parameter number
 *               IN      pbData     -  Pointer to data
 *               IN      pdwDataLen -  Length of parameter data
 *               IN      dwFlags    -  Flags values
 *
 *  Returns:
 */
BOOL CPGetKeyParam(IN HCRYPTPROV hUID,
                   IN HCRYPTKEY hKey,
                   IN DWORD dwParam,
                   IN BYTE *pbData,
                   IN DWORD *pwDataLen,
                   IN DWORD dwFlags)
{
    PNTAGUserList   pTmpUser;
    PNTAGKeyList    pTmpKey;
    BSAFE_PUB_KEY   *pBsafePubKey;
    DWORD           *pdw;
    BOOL            fRet = NTF_FAILED;

#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputGetKeyParam(TRUE, FALSE, hUID, hKey, dwParam, pbData,
                              pwDataLen, dwFlags);
#endif // DBG -- NOTE:  This section not compiled for retail builds

    if (dwFlags != 0)
    {
        SetLastError((DWORD) NTE_BAD_FLAGS);
        goto Ret;
    }

    // check the user identification
    if (NULL == (pTmpUser = NTLCheckList ((HNTAG)hUID, USER_HANDLE)))
    {
        SetLastError((DWORD) NTE_BAD_UID);
        goto Ret;
    }

    if ((pTmpKey = (PNTAGKeyList)NTLValidate((HNTAG)hKey,
                                              hUID, KEY_HANDLE)) == NULL &&
        (pTmpKey = (PNTAGKeyList)NTLValidate((HNTAG)hKey,
                                           hUID, SIGPUBKEY_HANDLE)) == NULL &&
        (pTmpKey = (PNTAGKeyList)NTLValidate((HNTAG)hKey,
                                          hUID, EXCHPUBKEY_HANDLE)) == NULL)
    {
        // NTLValidate doesn't know what error to set
        // so it set NTE_FAIL -- fix it up.
        if (GetLastError() == NTE_FAIL)
        {
            SetLastError((DWORD) NTE_BAD_KEY);
        }
        goto Ret;
    }

    if (pwDataLen == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    switch (dwParam)
    {

        case KP_IV:
            if (pbData == NULL || *pwDataLen < RC2_BLOCKLEN)
            {
                *pwDataLen = RC2_BLOCKLEN;

                if (pbData == NULL)
                {
                    fRet = NTF_SUCCEED;
                    goto Ret;
                }
                SetLastError(ERROR_MORE_DATA);
                goto Ret;
            }
            memcpy(pbData, pTmpKey->IV, RC2_BLOCKLEN);
            *pwDataLen = RC2_BLOCKLEN;
            break;

        case KP_SALT:
            if ((CALG_RC2 != pTmpKey->Algid) && (CALG_RC4 != pTmpKey->Algid))
            {
                if ((CALG_DES == pTmpKey->Algid) || (CALG_3DES == pTmpKey->Algid) ||
                    (CALG_3DES_112 == pTmpKey->Algid))
                {
                    *pwDataLen = 0;
                    fRet = NTF_SUCCEED;
                    goto Ret;
                }
                else
                {
                    SetLastError((DWORD) NTE_BAD_KEY);
                    goto Ret;
                }
            }

            if (pbData == NULL || (*pwDataLen < pTmpKey->cbSaltLen))
            {
                *pwDataLen = pTmpKey->cbSaltLen;
                if (pbData == NULL)
                {
                    fRet = NTF_SUCCEED;
                    goto Ret;
                }
                SetLastError(ERROR_MORE_DATA);
                goto Ret;
            }

            CopyMemory(pbData, pTmpKey->rgbSalt, pTmpKey->cbSaltLen);
            *pwDataLen = pTmpKey->cbSaltLen;
            break;

        case KP_PADDING:
            if (pbData == NULL || *pwDataLen < sizeof(DWORD))
            {
                *pwDataLen = sizeof(DWORD);

                if (pbData == NULL)
                {
                    fRet = NTF_SUCCEED;
                    goto Ret;
                }
                SetLastError(ERROR_MORE_DATA);
                goto Ret;
            }
            *((DWORD *) pbData) = PKCS5_PADDING;
            *pwDataLen = sizeof(DWORD);
            break;

        case KP_MODE:
            if (pbData == NULL || *pwDataLen < sizeof(DWORD))
            {
                *pwDataLen = sizeof(DWORD);

                if (pbData == NULL)
                {
                    fRet = NTF_SUCCEED;
                    goto Ret;
                }
                SetLastError(ERROR_MORE_DATA);
                goto Ret;
            }
            *((DWORD *) pbData) = pTmpKey->Mode;
            *pwDataLen = sizeof(DWORD);
            break;

        case KP_MODE_BITS:
            if (pbData == NULL || *pwDataLen < sizeof(DWORD))
            {
                *pwDataLen = sizeof(DWORD);

                if (pbData == NULL)
                {
                    fRet = NTF_SUCCEED;
                    goto Ret;
                }
                SetLastError(ERROR_MORE_DATA);
                goto Ret;
            }
            *((DWORD *) pbData) = pTmpKey->ModeBits;
            *pwDataLen = sizeof(DWORD);
            break;

        case KP_PERMISSIONS:
            if (pbData == NULL || *pwDataLen < sizeof(DWORD))
            {
                *pwDataLen = sizeof(DWORD);

                if (pbData == NULL)
                {
                    fRet = NTF_SUCCEED;
                    goto Ret;
                }
                SetLastError(ERROR_MORE_DATA);
                goto Ret;
            }
            *((DWORD *) pbData) = pTmpKey->Permissions;
            *pwDataLen = sizeof(DWORD);
            break;

        case KP_ALGID:
            if (pbData == NULL || *pwDataLen < sizeof(ALG_ID))
            {
                *pwDataLen = sizeof(ALG_ID);

                if (pbData == NULL)
                {
                    fRet = NTF_SUCCEED;
                    goto Ret;
                }
                SetLastError(ERROR_MORE_DATA);
                goto Ret;
            }
            *((ALG_ID *) pbData) = pTmpKey->Algid;
            *pwDataLen = sizeof(ALG_ID);
            break;

        case KP_KEYLEN:
            if (pbData == NULL || *pwDataLen < sizeof(DWORD))
            {
                *pwDataLen = sizeof(DWORD);

                if (pbData == NULL)
                {
                    fRet = NTF_SUCCEED;
                    goto Ret;
                }
                SetLastError(ERROR_MORE_DATA);
                goto Ret;
            }

            // ALWAYS report keylen in BITS
            if ((HNTAG_TO_HTYPE(hKey) == SIGPUBKEY_HANDLE) ||
                     (HNTAG_TO_HTYPE(hKey) == EXCHPUBKEY_HANDLE))
            {
                pBsafePubKey = (BSAFE_PUB_KEY *) pTmpKey->pKeyValue;
                if (pBsafePubKey == NULL)
                {
                    SetLastError((DWORD) NTE_NO_KEY);
                    goto Ret;
                }
                *((DWORD *) pbData) = pBsafePubKey->bitlen;
                *pwDataLen = sizeof(DWORD);
            }
            else
            {
                *((DWORD *) pbData) = (pTmpKey->cbKeyLen*8);
                *pwDataLen = sizeof(DWORD);
            }
            break;

        case KP_BLOCKLEN:
            if (pbData == NULL || *pwDataLen < sizeof(DWORD))
            {
                *pwDataLen = sizeof(DWORD);

                if (pbData == NULL)
                {
                    fRet = NTF_SUCCEED;
                    goto Ret;
                }
                SetLastError(ERROR_MORE_DATA);
                goto Ret;
            }

            if ((HNTAG_TO_HTYPE(hKey) == SIGPUBKEY_HANDLE) ||
                (HNTAG_TO_HTYPE(hKey) == EXCHPUBKEY_HANDLE))
            {
                pBsafePubKey = (BSAFE_PUB_KEY *) pTmpKey->pKeyValue;
                if (pBsafePubKey == NULL)
                {
                    SetLastError((DWORD) NTE_NO_KEY);
                    goto Ret;
                }
                *((DWORD *) pbData) = pBsafePubKey->bitlen;
                *pwDataLen = sizeof(DWORD);
            }
            else
            {
                switch (pTmpKey->Algid)
                {
#ifdef CSP_USE_RC2
                    case CALG_RC2:
                        *((DWORD *) pbData) = RC2_BLOCKLEN * 8;
                        *pwDataLen = sizeof(DWORD);
                        break;
#endif

#ifdef CSP_USE_DES
                    case CALG_DES:
                        *((DWORD *) pbData) = DES_BLOCKLEN * 8;
                        *pwDataLen = sizeof(DWORD);
                        break;
#endif

#ifdef CSP_USE_3DES
                    case CALG_3DES_112:
                    case CALG_3DES:
                        *((DWORD *) pbData) = DES_BLOCKLEN * 8;
                        *pwDataLen = sizeof(DWORD);
                        break;
#endif

                    default:
                        *((DWORD *) pbData) = 0;
                        *pwDataLen = sizeof(DWORD);
                }
            }

            break;

        case KP_EFFECTIVE_KEYLEN:
            if (CALG_RC2 != pTmpKey->Algid)
            {
                SetLastError((DWORD)NTE_BAD_KEY);
                goto Ret;
            }

            if (pbData == NULL || *pwDataLen < sizeof(DWORD))
            {
                *pwDataLen = sizeof(DWORD);

                if (pbData == NULL)
                {
                    fRet = NTF_SUCCEED;
                    goto Ret;
                }
                SetLastError(ERROR_MORE_DATA);
                goto Ret;
            }

            *pwDataLen = sizeof(DWORD);
            pdw = (DWORD*)pbData;
            *pdw = pTmpKey->EffectiveKeyLen;
            break;

        default:
            SetLastError((DWORD) NTE_BAD_TYPE);
            goto Ret;
            break;

    }

    fRet = NTF_SUCCEED;
Ret:
#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputGetKeyParam(FALSE, fRet, 0, 0, 0, NULL, NULL, 0);
#endif // DBG -- NOTE:  This section not compiled for retail builds

    return fRet;
}

BOOL DeletePersistedKey(
                        PNTAGUserList pTmpUser,
                        DWORD dwKeySpec
                        )
{
    CHAR        *pszExport;
    CHAR        *pszPrivKey;
    CHAR        *pszPubKey;
    BOOL        fMachineKeySet = FALSE;
    BOOL        fRet = FALSE;

    if (pTmpUser->Rights & CRYPT_MACHINE_KEYSET)
    {
        fMachineKeySet = TRUE;
    }

    if (AT_SIGNATURE == dwKeySpec)
    {
        pszExport = "SExport";
        pszPrivKey = "SPvK";
        pszPubKey = "SPbK";
    }
    else if (AT_KEYEXCHANGE == dwKeySpec)
    {
        pszExport = "EExport";
        pszPrivKey = "EPvK";
        pszPubKey = "EPbK";
    }
    else
    {
        SetLastError((DWORD)NTE_BAD_DATA);
        goto Ret;
    }

    // if protected store is available then delete the key from there
    if (pTmpUser->pPStore)
    {
        if (!DeleteKeyFromProtectedStorage(pTmpUser, &g_Strings, dwKeySpec,
                                           fMachineKeySet, FALSE))
        {
            goto Ret;
        }
    }

    // delete stuff from the registry
#ifndef _XBOX
    RegDeleteValue(pTmpUser->hKeys, pszPrivKey);
    RegDeleteValue(pTmpUser->hKeys, pszPubKey);
    RegDeleteValue(pTmpUser->hKeys, pszExport);
#endif

    fRet = NTF_SUCCEED;
Ret:
    return fRet;
}

/*
 -  CPSetProvParam
 -
 *  Purpose:
 *                Allows applications to customize various aspects of the
 *                operations of a provider
 *
 *  Parameters:
 *               IN      hUID    -  Handle to a CSP
 *               IN      dwParam -  Parameter number
 *               IN      pbData  -  Pointer to data
 *               IN      dwFlags -  Flags values
 *
 *  Returns:
 */
BOOL CPSetProvParam(IN HCRYPTPROV hUID,
                    IN DWORD dwParam,
                    IN BYTE *pbData,
                    IN DWORD dwFlags)
{
    PNTAGUserList   pTmpUser;
    long            lsyserr;
    HCRYPTKEY       hKey = 0;
    BOOL            fRet = NTF_FAILED;

#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputSetProvParam(TRUE, FALSE, hUID, dwParam, pbData, dwFlags);
#endif // DBG -- NOTE:  This section not compiled for retail builds 

    if (NULL == (pTmpUser = (PNTAGUserList)NTLCheckList (hUID, USER_HANDLE)))
    {
        SetLastError((DWORD)NTE_BAD_UID);
        goto Ret;
    }

    switch (dwParam)
    {
        case PP_KEYSET_SEC_DESCR:
#ifndef _XBOX
            if ((dwFlags & ~(OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
                             DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION)) != 0)
            {
                SetLastError((DWORD) NTE_BAD_FLAGS);
                goto Ret;
            }

            if (!(dwFlags & OWNER_SECURITY_INFORMATION) &&
                !(dwFlags & GROUP_SECURITY_INFORMATION) &&
                !(dwFlags & DACL_SECURITY_INFORMATION) &&
                !(dwFlags & SACL_SECURITY_INFORMATION))
            {
                SetLastError((DWORD)NTE_BAD_FLAGS);
                goto Ret;
            }

            // set the security descriptor for the hKey of the keyset
            if (0 != (lsyserr = SetSecurityOnContainer(
                             pTmpUser->ContInfo.rgwszFileName,
                             pTmpUser->dwProvType,
                             pTmpUser->Rights & CRYPT_MACHINE_KEYSET,
                             (SECURITY_INFORMATION)dwFlags, 
                             (PSECURITY_DESCRIPTOR)pbData)))
            {
                SetLastError(lsyserr);
                goto Ret;
            }
#endif
            ASSERT( !"PP_KEYSET_SEC_DESCR" );
            break;

        case PP_KEY_TYPE_SUBTYPE:
        {
            if (dwFlags != 0)
            {
                SetLastError((DWORD)NTE_BAD_FLAGS);
                goto Ret;
            }

            fRet = NTF_SUCCEED;
            goto Ret;
        }
        break;

        case PP_UI_PROMPT:
        {
            if (dwFlags != 0)
            {
                SetLastError((DWORD)NTE_BAD_FLAGS);
                goto Ret;
            }

            if (pTmpUser->pPStore)
            {
                if (!SetUIPrompt(pTmpUser, (LPWSTR)pbData))
                {
                    fRet = NTF_SUCCEED;
                    goto Ret;
                }
            }
            else
            {
                SetLastError((DWORD) NTE_BAD_TYPE);
                goto Ret;
            }
        }
        break;

        case PP_DELETEKEY:
        {
            if (dwFlags != 0)
            {
                SetLastError((DWORD)NTE_BAD_FLAGS);
                goto Ret;
            }

            // check if it is a verify context
            if (pTmpUser->Rights & CRYPT_VERIFYCONTEXT)
            {
                SetLastError((DWORD)NTE_BAD_UID);
                goto Ret;
            }

            // check if the keys exists
            if (!CPGetUserKey(hUID, *((DWORD*)pbData), &hKey))
            {
                SetLastError((DWORD)NTE_NO_KEY);
                goto Ret;
            }
            // destroy the key handle right away
            CPDestroyKey(hUID, hKey);

            // delete the key
            if (!DeletePersistedKey(pTmpUser, *((DWORD*)pbData)))
            {
                goto Ret;
            }
        }
        break;

        case PP_SGC_INFO:
#ifndef _XBOX
        {
            if (dwFlags != 0)
            {
                SetLastError((DWORD)NTE_BAD_FLAGS);
                goto Ret;
            }

            // check if it is an SChannel provider
            if (PROV_RSA_SCHANNEL != pTmpUser->dwProvType)
            {
                SetLastError((DWORD)NTE_BAD_TYPE);
                goto Ret;
            }

            // check if the SGC Info (cert) is good
            if (!SetSGCInfo(pTmpUser, pbData))
            {
                SetLastError((DWORD)NTE_FAIL);
                goto Ret;
            }
        }
#endif
        ASSERT( !"PP_SGC_INFO" );
        break;

#ifdef USE_HW_RNG
#ifdef _M_IX86
        case PP_USE_HARDWARE_RNG:
        {
            if (dwFlags != 0)
            {
                SetLastError((DWORD)NTE_BAD_FLAGS);
                goto Ret;
            }

            if (!GetRNGDriverHandle(&(pTmpUser->hRNGDriver)))
            {
                goto Ret;
            }
        }
        break;
#endif // _M_IX86
#endif // USE_HW_RNG

        default:
            SetLastError((DWORD) NTE_BAD_TYPE);
            goto Ret;
            break;
    }

    fRet = NTF_SUCCEED;
Ret:
#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputSetProvParam(FALSE, fRet, 0, 0, NULL, 0);
#endif // DBG -- NOTE:  This section not compiled for retail builds 

    return fRet;
}


/*
 -  CPGetProvParam
 -
 *  Purpose:
 *                Allows applications to get various aspects of the
 *                operations of a provider
 *
 *  Parameters:
 *               IN      hUID       -  Handle to a CSP
 *               IN      dwParam    -  Parameter number
 *               IN      pbData     -  Pointer to data
 *               IN      pdwDataLen -  Length of parameter data
 *               IN      dwFlags    -  Flags values
 *
 *  Returns:
 */
BOOL CPGetProvParam(IN HCRYPTPROV hUID,
                    IN DWORD dwParam,
                    IN BYTE *pbData,
                    IN DWORD *pwDataLen,
                    IN DWORD dwFlags)
{
    PNTAGUserList           pTmpUser;
    long                    lsyserr;
    ENUMALGS                *pEnum;
    ENUMALGSEX              *pEnumEx;
    DWORD                   cbName;
    BYTE                    *pbName;
    LPSTR                   pszName;
    DWORD                   cbTmpData;
    DWORD                   dwErr = 0;
    BOOL                    fRet = NTF_FAILED;

#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputGetProvParam(TRUE, FALSE, hUID, dwParam, pbData,
                               pwDataLen, dwFlags);
#endif // DBG -- NOTE:  This section not compiled for retail builds 

    if ((pTmpUser = (PNTAGUserList) NTLCheckList (hUID, USER_HANDLE)) == NULL)
    {
        SetLastError((DWORD) NTE_BAD_UID);
        goto Ret;
    }

    if (pwDataLen == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    switch (dwParam)
    {
        if (PROV_RSA_SCHANNEL == pTmpUser->dwProvType)
        {
            if ((dwFlags & ~(CRYPT_FIRST | CRYPT_NEXT | CRYPT_SGC_ENUM)) != 0)
            {
                SetLastError((DWORD) NTE_BAD_FLAGS);
                goto Ret;
            }
        }
        else
        {
            if ((dwFlags & ~(CRYPT_FIRST | CRYPT_NEXT)) != 0)
            {
                SetLastError((DWORD) NTE_BAD_FLAGS);
                goto Ret;
            }
        }

        case PP_ENUMALGS:
            switch(pTmpUser->dwProvType)
            {
                case PROV_RSA_FULL:
#ifdef STRONG
                    if (pTmpUser->fNewStrongCSP)
                    {
                        pEnum = (ENUMALGS*)EnumFullNewStrong;
                    }
                    else
                    {
                        pEnum = (ENUMALGS*)EnumFull;
                    }
#else
                    if (pTmpUser->Rights & CRYPT_IN_FRANCE)
                    {
                        pEnum = (ENUMALGS*)EnumFullFrance;
                    }
                    else
                    {
                        pEnum = (ENUMALGS*)EnumFull;
                    }
                    
#endif // STRONG
                    break;


                case PROV_RSA_SIG:
                    pEnum = (ENUMALGS*)EnumSig;
                    break;

                case PROV_RSA_SCHANNEL:
#ifdef STRONG
                    pEnum = (ENUMALGS*)EnumSch;
#else
                    if ((0 != pTmpUser->dwSGCFlags) || (dwFlags & CRYPT_SGC_ENUM))
                    {
                        pEnum = (ENUMALGS*)EnumSchSGC;
                    }
                    else
                    {
                        pEnum = (ENUMALGS*)EnumSch;
                    }
#endif
                    break;
            }

            if (dwFlags & CRYPT_FIRST)
            {
                pTmpUser->dwEnumalgs = 0;
            }
            else if (0xFFFFFFFF == pTmpUser->dwEnumalgs)
            {
                SetLastError((DWORD) NTE_BAD_FLAGS);
                goto Ret;
            }


            if (pEnum[pTmpUser->dwEnumalgs].aiAlgid == 0)
            {
                SetLastError(ERROR_NO_MORE_ITEMS);
                goto Ret;
            }

            if (pbData == NULL || *pwDataLen < sizeof(pEnum[0]))
            {
                *pwDataLen = sizeof(pEnum[0]);

                if (pbData == NULL)
                {
                    fRet = NTF_SUCCEED;
                    goto Ret;
                }
                SetLastError(ERROR_MORE_DATA);
                goto Ret;
            }

            // each entry in ENUMALGS is of fixed size
            memcpy(pbData, &pEnum[pTmpUser->dwEnumalgs], sizeof(pEnum[0]));
            *pwDataLen = sizeof(pEnum[0]);

            pTmpUser->dwEnumalgs++;

            break;

        case PP_ENUMALGS_EX:
            if (PROV_RSA_SCHANNEL == pTmpUser->dwProvType)
            {
                if ((dwFlags & ~(CRYPT_FIRST | CRYPT_NEXT | CRYPT_SGC_ENUM)) != 0)
                {
                    SetLastError((DWORD) NTE_BAD_FLAGS);
                    goto Ret;
                }
            }
            else
            {
                if ((dwFlags & ~(CRYPT_FIRST | CRYPT_NEXT)) != 0)
                {
                    SetLastError((DWORD) NTE_BAD_FLAGS);
                    goto Ret;
                }
            }

            switch(pTmpUser->dwProvType)
            {
                case PROV_RSA_FULL:
#ifdef STRONG
                    if (pTmpUser->fNewStrongCSP)
                    {
                        pEnumEx = (ENUMALGSEX*)EnumExFullNewStrong;
                    }
                    else
                    {
                        pEnumEx = (ENUMALGSEX*)EnumExFull;
                    }
#else
                    if (pTmpUser->Rights & CRYPT_IN_FRANCE)
                    {
                        pEnumEx = (ENUMALGSEX*)EnumExFullFrance;
                    }
                    else
                    {
                        pEnumEx = (ENUMALGSEX*)EnumExFull;
                    }
#endif // STRONG
                    break;

                case PROV_RSA_SIG:
                    pEnumEx = (ENUMALGSEX*)EnumExSig;
                    break;

                case PROV_RSA_SCHANNEL:
#ifdef STRONG
                    pEnumEx = (ENUMALGSEX*)EnumExSch;
#else
                    if ((0 != pTmpUser->dwSGCFlags) || (dwFlags & CRYPT_SGC_ENUM))
                    {
                        pEnumEx = (ENUMALGSEX*)EnumExSchSGC;
                    }
                    else
                    {
                        if (pTmpUser->Rights & CRYPT_IN_FRANCE)
                        {
                            pEnumEx = (ENUMALGSEX*)EnumExSchFrance;
                        }
                        else
                        {
                            pEnumEx = (ENUMALGSEX*)EnumExSch;
                        }
                    }
#endif
                    break;
            }

            if (dwFlags & CRYPT_FIRST)
            {
                pTmpUser->dwEnumalgsEx = 0;
            }
            else if (0xFFFFFFFF == pTmpUser->dwEnumalgsEx)
            {
                SetLastError((DWORD) NTE_BAD_FLAGS);
                goto Ret;
            }

            if (pEnumEx[pTmpUser->dwEnumalgsEx].aiAlgid == 0)
            {
                SetLastError(ERROR_NO_MORE_ITEMS);
                goto Ret;
            }

            if (pbData == NULL || *pwDataLen < sizeof(pEnumEx[0]))
            {
                *pwDataLen = sizeof(pEnumEx[0]);

                if (pbData == NULL)
                {
                    fRet = NTF_SUCCEED;
                    goto Ret;
                }
                SetLastError(ERROR_MORE_DATA);
                goto Ret;
            }

            // each entry in ENUMALGSEX is of fixed size
            memcpy(pbData, &pEnumEx[pTmpUser->dwEnumalgsEx], sizeof(pEnumEx[0]));
            *pwDataLen = sizeof(pEnumEx[0]);

            pTmpUser->dwEnumalgsEx++;

            break;

        case PP_ENUMCONTAINERS:
#ifndef _XBOX
            {
                BOOL fMachineKeySet = pTmpUser->Rights & CRYPT_MACHINE_KEYSET;

                if ((dwFlags & ~(CRYPT_FIRST | CRYPT_NEXT)) != 0)
                {
                    SetLastError((DWORD) NTE_BAD_FLAGS);
                    goto Ret;
                }

                if (dwFlags & CRYPT_FIRST)
                {
                    if (0 != pTmpUser->ContInfo.hFind)
                    {
                        FindClose(pTmpUser->ContInfo.hFind);
                        pTmpUser->ContInfo.hFind = 0;
                    }
                    FreeEnumOldMachKeyEntries(&pTmpUser->ContInfo);
                    FreeEnumRegEntries(&pTmpUser->ContInfo);

                    pTmpUser->ContInfo.fCryptFirst = TRUE;
                    pTmpUser->ContInfo.fNoMoreFiles = FALSE;
                }
                else if (FALSE == pTmpUser->ContInfo.fCryptFirst)
                {
                    SetLastError((DWORD) NTE_BAD_FLAGS);
                    goto Ret;
                }

                if (!pTmpUser->ContInfo.fNoMoreFiles)
                {
                    dwErr = GetNextContainer(pTmpUser->dwProvType,
                                             fMachineKeySet, 
                                             dwFlags,
                                             (LPSTR)pbData,
                                             pwDataLen,
                                             &pTmpUser->ContInfo.hFind);
                }

                if ((0 != dwErr) || pTmpUser->ContInfo.fNoMoreFiles)
                {
                    if ((0 != dwErr) && (ERROR_NO_MORE_ITEMS != dwErr))
                    {
                        SetLastError(dwErr);
                        goto Ret;
                    }

                    pTmpUser->ContInfo.fNoMoreFiles = TRUE;

                    if (fMachineKeySet)
                    {
                        if (0 != (dwErr = EnumOldMachineKeys(pTmpUser->dwProvType,
                                                             &pTmpUser->ContInfo)))
                        {
                            if (ERROR_NO_MORE_ITEMS != dwErr)
                            {
                                SetLastError((DWORD)dwErr);
                                goto Ret;
                            }
                        }
                    }
                    if (0 != (dwErr = EnumRegKeys(&pTmpUser->ContInfo,
                                                  fMachineKeySet,
                                                  pTmpUser->dwProvType,
                                                  pbData,
                                                  pwDataLen)))
                    {
                        SetLastError((DWORD)dwErr);
                        goto Ret;
                    }

                    cbTmpData = *pwDataLen;
                    if ((!fMachineKeySet) || 
                        (0 != (dwErr = GetNextEnumedOldMachKeys(&pTmpUser->ContInfo,
                                              fMachineKeySet,
                                              pTmpUser->dwProvType,
                                              pbData,
                                              &cbTmpData))))
                    {
                        if (0 != (dwErr = GetNextEnumedRegKeys(&pTmpUser->ContInfo,
                                                  fMachineKeySet,
                                                  pTmpUser->dwProvType,
                                                  pbData,
                                                  pwDataLen)))
                        {
                            SetLastError((DWORD)dwErr);
                            goto Ret;
                        }
                    }
                    else
                    {
                        *pwDataLen = cbTmpData;
                    }
                }
            }
#endif
            ASSERT (!"PP_ENUMCONTAINERS");
            break;

        case PP_IMPTYPE:

            if (pbData == NULL || *pwDataLen < sizeof(DWORD))
            {
                *pwDataLen = sizeof(DWORD);

                if (pbData == NULL)
                {
                    fRet = NTF_SUCCEED;
                    goto Ret;
                }
                SetLastError(ERROR_MORE_DATA);
                goto Ret;
            }

            *pwDataLen = sizeof(DWORD);

            *((DWORD *) pbData) = CRYPT_IMPL_SOFTWARE;

            break;

        case PP_NAME:
            switch(pTmpUser->dwProvType)
            {
                case PROV_RSA_FULL:
#ifndef STRONG
                    cbName = sizeof(MS_DEF_PROV);
                    pbName = MS_DEF_PROV;
#else   // STRONG                   
                    if (pTmpUser->fNewStrongCSP)
                    {
                        cbName = sizeof(MS_STRONG_PROV);
                        pbName = MS_STRONG_PROV;
                    }
                    else
                    {
                        cbName = sizeof(MS_ENHANCED_PROV);
                        pbName = MS_ENHANCED_PROV;
                    }
#endif  // STRONG
                    break;

                case PROV_RSA_SIG:
                    cbName = sizeof(PROV_SIG);
                    pbName = PROV_SIG;
                    break;

                case PROV_RSA_SCHANNEL:
                    cbName = sizeof(PROV_SCHANNEL);
                    pbName = PROV_SCHANNEL;
                    break;
            }

            if (pbData == NULL || *pwDataLen < cbName)
            {
                *pwDataLen = cbName;

                if (pbData == NULL)
                {
                    fRet = NTF_SUCCEED;
                    goto Ret;
                }
                SetLastError(ERROR_MORE_DATA);
                goto Ret;
            }

            *pwDataLen = cbName;

            memcpy(pbData, pbName, cbName);

            break;

        case PP_VERSION:
            if (dwFlags != 0)
            {
                SetLastError((DWORD) NTE_BAD_FLAGS);
                goto Ret;
            }

            if (pbData == NULL || *pwDataLen < sizeof(DWORD))
            {
                *pwDataLen = sizeof(DWORD);

                if (pbData == NULL)
                {
                    fRet = NTF_SUCCEED;
                    goto Ret;
                }
                SetLastError(ERROR_MORE_DATA);
                goto Ret;
            }

            *pwDataLen = sizeof(DWORD);

            *((DWORD *) pbData) = 0x200;

            break;

        case PP_CONTAINER:
            pszName = pTmpUser->ContInfo.pszUserName;

            if (pbData == NULL || *pwDataLen < (strlen(pszName) + 1))
            {
                *pwDataLen = strlen(pszName) + 1;

                if (pbData == NULL)
                {
                    fRet = NTF_SUCCEED;
                    goto Ret;
                }
                SetLastError(ERROR_MORE_DATA);
                goto Ret;
            }

            *pwDataLen = strlen(pszName) + 1;

            strcpy(pbData, pszName);
            break;

        case PP_UNIQUE_CONTAINER:
            if (0 != (dwErr = GetUniqueContainerName(&pTmpUser->ContInfo,
                                                     pbData,
                                                     pwDataLen)))
            {
                SetLastError(dwErr);
                goto Ret;
            }
            break;

        case PP_KEYSET_SEC_DESCR:
#ifndef _XBOX
            if ((dwFlags & ~(OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
                             DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION)) != 0)
            {
                SetLastError((DWORD) NTE_BAD_FLAGS);
                goto Ret;
            }

            if (!(dwFlags & OWNER_SECURITY_INFORMATION) &&
                !(dwFlags & GROUP_SECURITY_INFORMATION) &&
                !(dwFlags & DACL_SECURITY_INFORMATION) &&
                !(dwFlags & SACL_SECURITY_INFORMATION))
            {
                SetLastError((DWORD)NTE_BAD_FLAGS);
                goto Ret;
            }

            if (0 != (lsyserr = GetSecurityOnContainer(
                                    pTmpUser->ContInfo.rgwszFileName,
                                    pTmpUser->dwProvType,
                                    pTmpUser->Rights & CRYPT_MACHINE_KEYSET,
                                    (SECURITY_INFORMATION)dwFlags, 
                                    (PSECURITY_DESCRIPTOR)pbData,
                                    pwDataLen)))
            {
                SetLastError(lsyserr);
                goto Ret;
            }
#endif
            ASSERT( !"PP_KEYSET_SEC_DESCR" );
            break;

        case PP_KEYSTORAGE:
            if (dwFlags != 0)
            {
                SetLastError((DWORD) NTE_BAD_FLAGS);
                goto Ret;
            }

            if (pbData == NULL || *pwDataLen < sizeof(DWORD))
            {
                *pwDataLen = sizeof(DWORD);

                if (pbData == NULL)
                {
                    fRet = NTF_SUCCEED;
                    goto Ret;
                }
                SetLastError(ERROR_MORE_DATA);
                goto Ret;
            }

            *pwDataLen = sizeof(DWORD);

            if (pTmpUser->pPStore)
                *((DWORD*)pbData) = CRYPT_PSTORE | CRYPT_UI_PROMPT | CRYPT_SEC_DESCR;
            else
                *((DWORD*)pbData) = CRYPT_SEC_DESCR;

            break;

        case PP_PROVTYPE:
            if (dwFlags != 0)
            {
                SetLastError((DWORD) NTE_BAD_FLAGS);
                goto Ret;
            }

            if (pbData == NULL || *pwDataLen < sizeof(DWORD))
            {
                *pwDataLen = sizeof(DWORD);

                if (pbData == NULL)
                {
                    fRet = NTF_SUCCEED;
                    goto Ret;
                }
                SetLastError(ERROR_MORE_DATA);
                goto Ret;
            }

            *pwDataLen = sizeof(DWORD);
            *((DWORD*)pbData) = pTmpUser->dwProvType;

            break;

        case PP_KEYSET_TYPE:
            if (dwFlags != 0)
            {
                SetLastError((DWORD) NTE_BAD_FLAGS);
                goto Ret;
            }

            if (pbData == NULL || *pwDataLen < sizeof(DWORD))
            {
                *pwDataLen = sizeof(DWORD);

                if (pbData == NULL)
                {
                    fRet = NTF_SUCCEED;
                    goto Ret;
                }
                SetLastError(ERROR_MORE_DATA);
                goto Ret;
            }

            *pwDataLen = sizeof(DWORD);

            if (pTmpUser->Rights & CRYPT_MACHINE_KEYSET)
                *((DWORD*)pbData) = CRYPT_MACHINE_KEYSET;
            else
                *((DWORD*)pbData) = 0;

            break;

        case PP_SIG_KEYSIZE_INC:
        case PP_KEYX_KEYSIZE_INC:
            if (dwFlags != 0)
            {
                SetLastError((DWORD) NTE_BAD_FLAGS);
                goto Ret;
            }

            if (pbData == NULL || *pwDataLen < sizeof(DWORD))
            {
                *pwDataLen = sizeof(DWORD);

                if (pbData == NULL)
                {
                    fRet = NTF_SUCCEED;
                    goto Ret;
                }
                SetLastError(ERROR_MORE_DATA);
                goto Ret;
            }

            *pwDataLen = sizeof(DWORD);

            *((DWORD*)pbData) = RSA_KEYSIZE_INC;
            break;

        case PP_SGC_INFO:
        {
            if (dwFlags != 0)
            {
                SetLastError((DWORD) NTE_BAD_FLAGS);
                goto Ret;
            }

            // check if it is an SChannel provider
            if (PROV_RSA_SCHANNEL != pTmpUser->dwProvType)
            {
                SetLastError((DWORD)NTE_BAD_TYPE);
                goto Ret;
            }

            if (pbData == NULL || *pwDataLen < sizeof(DWORD))
            {
                *pwDataLen = sizeof(DWORD);

                if (pbData == NULL)
                {
                    fRet = NTF_SUCCEED;
                    goto Ret;
                }
                SetLastError(ERROR_MORE_DATA);
                goto Ret;
            }

            *pwDataLen = sizeof(DWORD);
            // return the SGC Flags
            *((DWORD*)pbData) = pTmpUser->dwSGCFlags;
        }
        break;

#ifdef USE_HW_RNG
#ifdef _M_IX86
        case PP_USE_HARDWARE_RNG:
        {
            if (dwFlags != 0)
            {
                SetLastError((DWORD)NTE_BAD_FLAGS);
                goto Ret;
            }

            *pwDataLen = 0;

            // check if the hardware RNG is available for use
            if (!CheckIfRNGAvailable())
            {
                goto Ret;
            }
        }
        break;
#endif // _M_IX86
#endif // USE_HW_RNG

        case PP_KEYSPEC:
            if (dwFlags != 0)
            {
                SetLastError((DWORD) NTE_BAD_FLAGS);
                goto Ret;
            }

            if (pbData == NULL || *pwDataLen < sizeof(DWORD))
            {
                *pwDataLen = sizeof(DWORD);

                if (pbData == NULL)
                {
                    fRet = TRUE;
                    goto Ret;
                }
                SetLastError(ERROR_MORE_DATA);
                goto Ret;
            }

            *pwDataLen = sizeof(DWORD);

            if (PROV_RSA_SIG == pTmpUser->dwProvType)
            {
                *((DWORD*)pbData) = AT_SIGNATURE;
            }
            else if (PROV_RSA_FULL == pTmpUser->dwProvType)
            {
                *((DWORD*)pbData) = AT_SIGNATURE | AT_KEYEXCHANGE;
            }
            else if (PROV_RSA_SCHANNEL == pTmpUser->dwProvType)
            {
                *((DWORD*)pbData) = AT_KEYEXCHANGE;
            }
            break;

        case PP_ENUMEX_SIGNING_PROT:
            *pwDataLen = 0;
            break;

        default:
            SetLastError((DWORD) NTE_BAD_TYPE);
            goto Ret;
            break;

    }

    fRet = NTF_SUCCEED;
Ret:
#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputGetProvParam(FALSE, fRet, 0, 0, NULL, NULL, 0);
#endif // DBG -- NOTE:  This section not compiled for retail builds 

    return fRet;

}


/*
 -  CPSetHashParam
 -
 *  Purpose:
 *                Allows applications to customize various aspects of the
 *                operations of a hash
 *
 *  Parameters:
 *               IN      hUID    -  Handle to a CSP
 *               IN      hHash   -  Handle to a hash
 *               IN      dwParam -  Parameter number
 *               IN      pbData  -  Pointer to data
 *               IN      dwFlags -  Flags values
 *
 *  Returns:
 */
BOOL CPSetHashParam(IN HCRYPTPROV hUID,
                    IN HCRYPTHASH hHash,
                    IN DWORD dwParam,
                    IN BYTE *pbData,
                    IN DWORD dwFlags)
{
    PNTAGHashList       pTmpHash;
    PNTAGKeyList        pTmpKey;
    MD4_object          *pMD4Hash;
    MD5_object          *pMD5Hash;
    A_SHA_CTX           *pSHAHash;
    MACstate            *pMAC;
    PHMAC_INFO          pHMACInfo;
    BYTE                *pb;
    BOOL                fExportable = FALSE;
    BOOL                fRet = NTF_FAILED;

#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputSetHashParam(TRUE, FALSE, hUID, hHash, dwParam,
                               pbData, dwFlags);
#endif // DBG -- NOTE:  This section not compiled for retail builds

    if (dwFlags != 0)
    {
        SetLastError((DWORD) NTE_BAD_FLAGS);
        goto Ret;
    }

    // check the user identification
    if (NTLCheckList ((HNTAG)hUID, USER_HANDLE) == NULL)
    {
        SetLastError((DWORD) NTE_BAD_UID);
        goto Ret;
    }

    if ((pTmpHash = (PNTAGHashList) NTLValidate(hHash, hUID,
                                                HASH_HANDLE)) == NULL)
    {
        if (GetLastError() == NTE_FAIL)
            SetLastError((DWORD) NTE_BAD_HASH);

        goto Ret;
    }

    switch (dwParam)
    {
        case HP_HASHVAL:

            switch (pTmpHash->Algid)
            {
#ifdef CSP_USE_MD2
                case CALG_MD2:
                {
                    MD2_object      *pMD2Hash;

                    pMD2Hash = (MD2_object *) pTmpHash->pHashData;

                    if (pMD2Hash->FinishFlag == TRUE)
                    {
                        SetLastError((DWORD) NTE_BAD_HASH_STATE);
                        goto Ret;
                    }

                    memcpy (&pMD2Hash->MD.state, pbData, MD2DIGESTLEN);

                    break;
                }
#endif

#ifdef CSP_USE_MD4
                case CALG_MD4:

                    pMD4Hash = (MD4_object *) pTmpHash->pHashData;

                    if (pMD4Hash->FinishFlag == TRUE)
                    {
                        SetLastError((DWORD) NTE_BAD_HASH_STATE);
                        goto Ret;
                    }

                    memcpy (&pMD4Hash->MD, pbData, MD4DIGESTLEN);

                    break;
#endif

#ifdef CSP_USE_MD5
                case CALG_MD5:

                    pMD5Hash = (MD5_object *) pTmpHash->pHashData;

                    if (pMD5Hash->FinishFlag == TRUE)
                    {
                        SetLastError((DWORD) NTE_BAD_HASH_STATE);
                        goto Ret;
                    }

                    memcpy (pMD5Hash->digest, pbData, MD5DIGESTLEN);

                    break;
#endif

#ifdef CSP_USE_SHA
                case CALG_SHA:

                    pSHAHash = (A_SHA_CTX *) pTmpHash->pHashData;

                    if (pSHAHash->FinishFlag == TRUE)
                    {
                        SetLastError((DWORD) NTE_BAD_HASH_STATE);
                        goto Ret;
                    }

                    memcpy (pSHAHash->HashVal, pbData, A_SHA_DIGEST_LEN);

                    break;
#endif

#ifdef CSP_USE_SSL3SHAMD5
                case CALG_SSL3_SHAMD5:
                    memcpy (pTmpHash->pHashData, pbData, SSL3_SHAMD5_LEN);

                    break;
#endif

#ifdef CSP_USE_MAC
                case CALG_MAC:

                    pMAC = (MACstate *)pTmpHash->pHashData;

                    if ((pTmpKey = (PNTAGKeyList) NTLValidate(pMAC->hKey,
                                                              hUID,
                                                         KEY_HANDLE)) == NULL)
                    {
                        if (GetLastError() == NTE_FAIL)
                        {
                            SetLastError((DWORD) NTE_BAD_KEY);
                        }
                        goto Ret;
                    }

                    if (pMAC->FinishFlag == TRUE)
                    {
                        SetLastError((DWORD) NTE_BAD_HASH_STATE);
                        goto Ret;
                    }

                    memcpy(pTmpKey->FeedBack, pbData, CRYPT_BLKLEN);

                    break;
#endif

                default:
                    SetLastError((DWORD) NTE_BAD_ALGID);
                    goto Ret;

            }
            pTmpHash->dwHashState |= DATA_IN_HASH;
            break;

        case HP_HMAC_INFO:
            if (CALG_HMAC != pTmpHash->Algid)
            {
                SetLastError((DWORD) NTE_BAD_TYPE);
                goto Ret;
            }

            pHMACInfo = (PHMAC_INFO)pbData;

            pTmpHash->HMACAlgid = pHMACInfo->HashAlgid;

            // now that we know the type of hash we can create it
            if (!LocalCreateHash(pTmpHash->HMACAlgid, (BYTE**)&pTmpHash->pHashData,
                                 &pTmpHash->dwDataLen))
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }

            // if the length of the inner string is 0 then use the default string
            if (0 == pHMACInfo->cbInnerString)
                pTmpHash->cbHMACInner = HMAC_DEFAULT_STRING_LEN;
            else
                pTmpHash->cbHMACInner = pHMACInfo->cbInnerString;

            if (NULL == (pb = _nt_malloc(pTmpHash->cbHMACInner)))
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }

            if (0 == pHMACInfo->cbInnerString)
                memset(pb, 0x36, pTmpHash->cbHMACInner);
            else
                memcpy(pb, pHMACInfo->pbInnerString, pTmpHash->cbHMACInner);

            if (pTmpHash->pbHMACInner)
                _nt_free(pTmpHash->pbHMACInner, pTmpHash->cbHMACInner);
            pTmpHash->pbHMACInner = pb;

            // if the length of the outer string is 0 then use the default string
            if (0 == pHMACInfo->cbOuterString)
                pTmpHash->cbHMACOuter = HMAC_DEFAULT_STRING_LEN;
            else
                pTmpHash->cbHMACOuter = pHMACInfo->cbOuterString;

            if (NULL == (pb = _nt_malloc(pTmpHash->cbHMACOuter)))
            {
                _nt_free(pTmpHash->pbHMACInner, pTmpHash->cbHMACInner);
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }

            if (0 == pHMACInfo->cbOuterString)
                memset(pb, 0x5C, pTmpHash->cbHMACOuter);
            else
                memcpy(pb, pHMACInfo->pbOuterString, pTmpHash->cbHMACOuter);

            if (pTmpHash->pbHMACOuter)
                _nt_free(pTmpHash->pbHMACOuter, pTmpHash->cbHMACOuter);
            pTmpHash->pbHMACOuter = pb;
            break;

#ifdef CSP_USE_SSL3
            case HP_TLS1PRF_LABEL:
            case HP_TLS1PRF_SEED:
            {
                if (CALG_TLS1PRF != pTmpHash->Algid)
                {
                    SetLastError((DWORD)NTE_BAD_HASH);
                    goto Ret;
                }

                if (!SetPRFHashParam((PRF_HASH*)pTmpHash->pHashData,
                                     dwParam, pbData))
                {
                    goto Ret;
                }

                pTmpHash->dwHashState |= DATA_IN_HASH;
                break;
            }
#endif

        default:
            SetLastError((DWORD) NTE_BAD_TYPE);
            goto Ret;
            break;
    }

    if (dwParam == HP_HASHVAL)
        pTmpHash->HashFlags |= HF_VALUE_SET;

    fRet = NTF_SUCCEED;
Ret:
#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputSetHashParam(FALSE, fRet, 0, 0, 0, NULL, 0);
#endif // DBG -- NOTE:  This section not compiled for retail builds

    return fRet;
}

BOOL LocalGetHashVal(
                     IN ALG_ID Algid,
                     IN DWORD dwHashFlags,
                     IN OUT BYTE *pbHashData,
                     OUT BYTE *pbHashVal,
                     OUT DWORD *pcbHashVal
                     )
{
    MD2_object      *pMD2Hash;
    MD4_object      *pMD4Hash;
    MD5_object      *pMD5Hash;
    A_SHA_CTX       *pSHAHash;
    BOOL            fRet = FALSE;

    switch (Algid)
    {
#ifdef CSP_USE_MD2
        case CALG_MD2:
            // make sure there's enough room.
            if (pbHashVal == NULL || *pcbHashVal < MD2DIGESTLEN)
            {
                *pcbHashVal = MD2DIGESTLEN;
                if (pbHashVal == NULL)
                    fRet = TRUE;
                else
                    SetLastError(ERROR_MORE_DATA);
                goto Ret;
            }

            pMD2Hash = (MD2_object *)pbHashData;

            if ((dwHashFlags & HF_VALUE_SET) == 0)
            {
                if (pMD2Hash->FinishFlag == TRUE)
                {
                    *pcbHashVal = MD2DIGESTLEN;
                    memcpy(pbHashVal, pMD2Hash->MD.state, MD2DIGESTLEN);
                    break;
                }

                // set the finish flag on the hash and
                // process what's left in the buffer.
                pMD2Hash->FinishFlag = TRUE;

                // Finish offthe hash
                MD2Final(&pMD2Hash->MD);
            }

            *pcbHashVal = MD2DIGESTLEN;
            memcpy (pbHashVal, pMD2Hash->MD.state, MD2DIGESTLEN);

            break;
#endif

#ifdef CSP_USE_MD4
        case CALG_MD4:
            // make sure there's enough room.
            if (pbHashVal == NULL || *pcbHashVal < MD4DIGESTLEN)
            {
                *pcbHashVal = MD4DIGESTLEN;
                if (pbHashVal == NULL)
                    fRet = TRUE;
                else
                    SetLastError(ERROR_MORE_DATA);
                goto Ret;
            }

            pMD4Hash = (MD4_object *)pbHashData;

            if ((dwHashFlags & HF_VALUE_SET) == 0)
            {
                if (pMD4Hash->FinishFlag == TRUE)
                {
                    *pcbHashVal = MD4DIGESTLEN;
                    memcpy(pbHashVal, &pMD4Hash->MD, *pcbHashVal);
                    break;
                }

                // set the finish flag on the hash and
                // process what's left in the buffer.
                pMD4Hash->FinishFlag = TRUE;

                if (MD4_SUCCESS != MDupdate(&pMD4Hash->MD, pMD4Hash->Buf,
                                            MD4BYTESTOBITS(pMD4Hash->BufLen)))
                {
                    SetLastError((DWORD) NTE_FAIL);
                    goto Ret;
                }
            }

            *pcbHashVal = MD4DIGESTLEN;
            memcpy(pbHashVal, &pMD4Hash->MD, *pcbHashVal);

            break;
#endif

#ifdef CSP_USE_MD5
        case CALG_MD5:
            // make sure there's enough room.
            if (pbHashVal == NULL || *pcbHashVal < MD5DIGESTLEN)
            {
                *pcbHashVal = MD5DIGESTLEN;
                if (pbHashVal == NULL)
                    fRet = TRUE;
                else
                    SetLastError(ERROR_MORE_DATA);
                goto Ret;
            }

            pMD5Hash = (MD5_object *)pbHashData;

            if ((dwHashFlags & HF_VALUE_SET) == 0)
            {
                if (pMD5Hash->FinishFlag == TRUE)
                {
                    *pcbHashVal = MD5DIGESTLEN;
                    memcpy (pbHashVal, pMD5Hash->digest, MD5DIGESTLEN);
                    break;
                }

                // set the finish flag on the hash and
                // process what's left in the buffer.
                pMD5Hash->FinishFlag = TRUE;

                // Finish offthe hash
                MD5Final(pMD5Hash);
            }

            *pcbHashVal = MD5DIGESTLEN;
            memcpy (pbHashVal, pMD5Hash->digest, MD5DIGESTLEN);

            break;
#endif

#ifdef CSP_USE_SHA
        case CALG_SHA:
            // make sure there's enough room.
            if (pbHashVal == NULL || *pcbHashVal < A_SHA_DIGEST_LEN)
            {
                *pcbHashVal = A_SHA_DIGEST_LEN;
                if (pbHashVal == NULL)
                    fRet = TRUE;
                else
                    SetLastError(ERROR_MORE_DATA);
                goto Ret;
            }

            pSHAHash = (A_SHA_CTX *)pbHashData;

            if ((dwHashFlags & HF_VALUE_SET) == 0)
            {
                if (pSHAHash->FinishFlag == TRUE)
                {
                    *pcbHashVal = A_SHA_DIGEST_LEN;
                    memcpy (pbHashVal, pSHAHash->HashVal, A_SHA_DIGEST_LEN);
                    break;
                }

                // set the finish flag on the hash and
                // process what's left in the buffer.
                pSHAHash->FinishFlag = TRUE;

                // Finish off the hash
                A_SHAFinal(pSHAHash, pSHAHash->HashVal);
            }

            *pcbHashVal = A_SHA_DIGEST_LEN;
            memcpy (pbHashVal, pSHAHash->HashVal, A_SHA_DIGEST_LEN);

            break;
#endif

        default:
            SetLastError((DWORD)NTE_BAD_ALGID);
            goto Ret;
    }

    fRet = TRUE;
Ret:
    return fRet;
}

void GetHashLength(IN ALG_ID Algid,
                   OUT DWORD *pcb)
{
    switch (Algid)
    {
#ifdef CSP_USE_MD2
        case CALG_MD2:
            *pcb = MD2DIGESTLEN;
            break;
#endif

#ifdef CSP_USE_MD4
        case CALG_MD4:
            *pcb = MD4DIGESTLEN;
            break;
#endif

#ifdef CSP_USE_MD5
        case CALG_MD5:
            *pcb = MD5DIGESTLEN;
            break;
#endif

#ifdef CSP_USE_SHA
        case CALG_SHA:
            *pcb = A_SHA_DIGEST_LEN;
            break;
#endif
    }
}

/*
 -  CPGetHashParam
 -
 *  Purpose:
 *                Allows applications to get various aspects of the
 *                operations of a key
 *
 *  Parameters:
 *               IN      hUID       -  Handle to a CSP
 *               IN      hHash      -  Handle to a hash
 *               IN      dwParam    -  Parameter number
 *               IN      pbData     -  Pointer to data
 *               IN      pdwDataLen -  Length of parameter data
 *               IN      dwFlags    -  Flags values
 *
 *  Returns:
 */
BOOL CPGetHashParam(IN HCRYPTPROV hUID,
                    IN HCRYPTHASH hHash,
                    IN DWORD dwParam,
                    IN BYTE *pbData,
                    IN DWORD *pwDataLen,
                    IN DWORD dwFlags)
{
    PNTAGHashList   pTmpHash;
    MACstate        *pMAC;
    BOOL            f;
    BYTE            MACbuf[2*CRYPT_BLKLEN];
    PNTAGKeyList    pTmpKey;

    BYTE            rgbFinalHash[A_SHA_DIGEST_LEN];
    DWORD           cbFinalHash;
    DWORD           cb;
    BYTE            *pb = NULL;
    DWORD           cbHashData;
    BYTE            *pbHashData = NULL;
    DWORD           i;

    BOOL            fRet = NTF_FAILED;

#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputGetHashParam(TRUE, FALSE, hUID, hHash, dwParam,
                               pbData, pwDataLen, dwFlags);
#endif // DBG -- NOTE:  This section not compiled for retail builds

    if (dwFlags != 0)
    {
        SetLastError((DWORD) NTE_BAD_FLAGS);
        goto Ret;
    }

    // check the user identification
    if (NTLCheckList ((HNTAG)hUID, USER_HANDLE) == NULL)
    {
        SetLastError((DWORD) NTE_BAD_UID);
        goto Ret;
    }

    if (pwDataLen == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    if ((pTmpHash = (PNTAGHashList) NTLValidate(hHash, hUID,
                                                HASH_HANDLE)) == NULL)
    {
        if (GetLastError() == NTE_FAIL)
            SetLastError((DWORD) NTE_BAD_HASH);

        goto Ret;
    }

    switch (dwParam)
    {

        case HP_ALGID:
            if (pbData == NULL || *pwDataLen < sizeof(DWORD))
            {
                *pwDataLen = sizeof(DWORD);

                if (pbData == NULL)
                {
                    fRet = NTF_SUCCEED;
                    goto Ret;
                }
                SetLastError(ERROR_MORE_DATA);
                goto Ret;
            }

            *((DWORD *) pbData) = pTmpHash->Algid;
            *pwDataLen = sizeof(DWORD);
            break;

        case HP_HASHSIZE:
            if (pbData == NULL || *pwDataLen < sizeof(DWORD))
            {
                *pwDataLen = sizeof(DWORD);

                if (pbData == NULL)
                {
                    fRet = NTF_SUCCEED;
                    goto Ret;
                }
                SetLastError(ERROR_MORE_DATA);
                goto Ret;
            }

            switch (pTmpHash->Algid)
            {
                case CALG_MD2:
                case CALG_MD4:
                case CALG_MD5:
                case CALG_SHA:
                    GetHashLength(pTmpHash->Algid, (DWORD *)pbData);
                    break;

#ifdef CSP_USE_MAC
                case CALG_MAC:
                    *((DWORD *) pbData) = CRYPT_BLKLEN;
                    break;
#endif // CSP_USE_MAC

                case CALG_HMAC:
                    GetHashLength(pTmpHash->HMACAlgid, (DWORD *)pbData);
                    break;

#ifdef CSP_USE_SSL3SHAMD5
                case CALG_SSL3_SHAMD5:
                    *((DWORD *) pbData) = SSL3_SHAMD5_LEN;

                    break;
#endif

                default:
                    SetLastError((DWORD) NTE_BAD_ALGID);
                    goto Ret;
            }

            *pwDataLen = sizeof(DWORD);
            break;

        case HP_HASHVAL:
            switch (pTmpHash->Algid)
            {
#ifdef CSP_USE_SSL3SHAMD5
                case CALG_SSL3_SHAMD5:

                    // make sure there's enough room.
                    if (pbData == NULL || *pwDataLen < SSL3_SHAMD5_LEN)
                    {
                        *pwDataLen = SSL3_SHAMD5_LEN;
                        if (pbData == NULL)
                        {
                            fRet = NTF_SUCCEED;
                            goto Ret;
                        }
                        SetLastError(ERROR_MORE_DATA);
                        goto Ret;
                    }

                    // Hash value must have already been set.
                    if ((pTmpHash->HashFlags & HF_VALUE_SET) == 0)
                    {
                        SetLastError((DWORD) NTE_BAD_HASH_STATE);
                        goto Ret;
                    }

                    *pwDataLen = SSL3_SHAMD5_LEN;
                    memcpy (pbData, pTmpHash->pHashData, SSL3_SHAMD5_LEN);

                    break;
#endif

#ifdef CSP_USE_MAC
                case CALG_MAC:

                    pMAC = (MACstate *)pTmpHash->pHashData;

                    if ((pTmpKey = (PNTAGKeyList) NTLValidate(pMAC->hKey,
                                                              hUID,
                                                         KEY_HANDLE)) == NULL)
                    {
                        if (GetLastError() == NTE_FAIL)
                        {
                            SetLastError((DWORD) NTE_BAD_KEY);
                        }
                        goto Ret;
                    }

                    // make sure there is enough room.
                    if (pbData == NULL || (*pwDataLen < CRYPT_BLKLEN))
                    {
                        *pwDataLen = CRYPT_BLKLEN;
                        if (pbData == NULL)
                        {
                            fRet = NTF_SUCCEED;
                            goto Ret;
                        }
                        SetLastError(ERROR_MORE_DATA);
                        goto Ret;
                    }

                    if (pMAC->FinishFlag == TRUE)
                    {
                        *pwDataLen = CRYPT_BLKLEN;
                        memcpy(pbData, pTmpKey->FeedBack, CRYPT_BLKLEN);
                        break;
                    }

                    // set the finish flag on the hash and
                    // process what's left in the buffer.
                    pMAC->FinishFlag = TRUE;

                    if (pMAC->dwBufLen)
                    {
                        memset(MACbuf, 0, 2*CRYPT_BLKLEN);
                        memcpy(MACbuf, pMAC->Buffer, pMAC->dwBufLen);

                        switch (pTmpKey->Algid)
                        {
                            case CALG_RC2:
                            if (BlockEncrypt(RC2, pTmpKey, RC2_BLOCKLEN, TRUE,
                                             MACbuf,  &pMAC->dwBufLen,
                                             2*CRYPT_BLKLEN) == NTF_FAILED)
                            {
                                goto Ret;
                            }
                            break;

                            case CALG_DES:
                            if (BlockEncrypt(des, pTmpKey, DES_BLOCKLEN, TRUE,
                                             MACbuf,  &pMAC->dwBufLen,
                                             2*CRYPT_BLKLEN) == NTF_FAILED)
                            {
                                goto Ret;
                            }
                            break;
#ifdef CSP_USE_3DES
                            case CALG_3DES_112:
                            case CALG_3DES:
                                if (BlockEncrypt(tripledes, pTmpKey, DES_BLOCKLEN,
                                                 TRUE, MACbuf,  &pMAC->dwBufLen,
                                                 2*CRYPT_BLKLEN) == NTF_FAILED)
                                {
                                    goto Ret;
                                }
                                break;
#endif
                        }
                    }

                    *pwDataLen = CRYPT_BLKLEN;
                    memcpy(pbData, pTmpKey->FeedBack, CRYPT_BLKLEN);

                    break;
#endif

                case CALG_HMAC:
                {
                    if (!(pTmpHash->HMACState & HMAC_FINISHED))
                    {
                        cbFinalHash = sizeof(rgbFinalHash);
                        if (!LocalGetHashVal(pTmpHash->HMACAlgid, pTmpHash->HashFlags,
                                             pTmpHash->pHashData, rgbFinalHash, &cbFinalHash))
                        {
                            goto Ret;
                        }

                        // now XOR the outer string with the key and hash
                        // over this and the inner hash
                        if ((pTmpKey = (PNTAGKeyList) NTLValidate(pTmpHash->hKey, hUID,
                                                                  KEY_HANDLE)) == NULL)
                        {
                            if (GetLastError() == NTE_FAIL)
                            {
                                SetLastError((DWORD) NTE_BAD_KEY);
                            }
                            goto Ret;
                        }

                        if (pTmpKey->cbKeyLen < pTmpHash->cbHMACOuter)
                            cb = pTmpHash->cbHMACOuter;
                        else
                            cb = pTmpKey->cbKeyLen;

                        if (NULL == (pb = (BYTE *)_nt_malloc(cb)))
                        {
                            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                            goto Ret;
                        }
                        memcpy(pb, pTmpHash->pbHMACOuter, pTmpHash->cbHMACOuter);

                        // currently no support for byte reversed keys with HMAC
                        for(i=0;i<pTmpKey->cbKeyLen;i++)
                            pb[i] ^= (pTmpKey->pKeyValue)[i];

                        if (!LocalCreateHash(pTmpHash->HMACAlgid, &pbHashData, &cbHashData))
                        {
                            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                            goto Ret;
                        }

                        if (!LocalHashData(pTmpHash->HMACAlgid, pbHashData, pb, cb))
                        {
                            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                            goto Ret;
                        }

                        if (!LocalHashData(pTmpHash->HMACAlgid, pbHashData, rgbFinalHash,
                                           cbFinalHash))
                        {
                            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                            goto Ret;
                        }
                        _nt_free(pTmpHash->pHashData, pTmpHash->dwDataLen);
                        pTmpHash->dwDataLen = cbHashData;
                        pTmpHash->pHashData = pbHashData;
                        pbHashData = NULL;

                        pTmpHash->HMACState |= HMAC_FINISHED;
                    }

                    if (!LocalGetHashVal(pTmpHash->HMACAlgid, pTmpHash->HashFlags,
                                        pTmpHash->pHashData, pbData, pwDataLen))
                    {
                        goto Ret;
                    }

                }
                break;

#ifdef CSP_USE_SSL3
                case CALG_TLS1PRF:
                {
                    if (!CalculatePRF((PRF_HASH*)pTmpHash->pHashData,
                                      pbData, pwDataLen))
                    {
                        goto Ret;
                    }
                    break;
                }
#endif

                default:
                    if (!LocalGetHashVal(pTmpHash->Algid, pTmpHash->HashFlags,
                                         pTmpHash->pHashData, pbData, pwDataLen))
                    {
                        goto Ret;
                    }
            }

            break;

        default:
            SetLastError((DWORD) NTE_BAD_TYPE);
            goto Ret;
            break;

    }

    fRet = NTF_SUCCEED;
Ret:
#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputGetHashParam(FALSE, fRet, 0, 0, 0, pbData, pwDataLen, 0);
#endif // DBG -- NOTE:  This section not compiled for retail builds

    if (pb)
        _nt_free(pb, cb);
    if (pbHashData)
        _nt_free(pbHashData, cbHashData);

    return fRet;

}

BOOL CopyKey(
             IN PNTAGKeyList pOldKey,
             OUT PNTAGKeyList *ppNewKey)
{
    PNTAGKeyList    pNewKey;
    BOOL            fRet = FALSE;

    if (NULL == (pNewKey = (PNTAGKeyList)_nt_malloc(sizeof(NTAGKeyList))))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Ret;
    }

    memcpy(pNewKey, pOldKey, sizeof(NTAGKeyList));
    pNewKey->pKeyValue = NULL;
    pNewKey->cbDataLen = 0;
    pNewKey->pData = NULL;
    pNewKey->cbSaltLen = 0;

    pNewKey->cbKeyLen = pOldKey->cbKeyLen;
    if (pNewKey->cbKeyLen)
    {
        if (NULL == (pNewKey->pKeyValue = (BYTE*)_nt_malloc(pNewKey->cbKeyLen)))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }
    }

    memcpy(pNewKey->pKeyValue, pOldKey->pKeyValue, pNewKey->cbKeyLen);

    pNewKey->cbDataLen = pOldKey->cbDataLen;
    if (pNewKey->cbDataLen)
    {
        if (NULL == (pNewKey->pData = (BYTE*)_nt_malloc(pNewKey->cbDataLen)))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }
    }

    memcpy(pNewKey->pData, pOldKey->pData, pNewKey->cbDataLen);

    pNewKey->cbSaltLen = pOldKey->cbSaltLen;

    memcpy(pNewKey->rgbSalt, pOldKey->rgbSalt, pNewKey->cbSaltLen);

    *ppNewKey = pNewKey;

    fRet = TRUE;
Ret:
    if ((FALSE == fRet) && pNewKey)
        FreeNewKey(pNewKey);
    return fRet;
}

/*
 -  CPDuplicateKey
 -
 *  Purpose:
 *                Duplicates the state of a key and returns a handle to it
 *
 *  Parameters:
 *               IN      hUID           -  Handle to a CSP
 *               IN      hKey           -  Handle to a key
 *               IN      pdwReserved    -  Reserved
 *               IN      dwFlags        -  Flags
 *               IN      phKey          -  Handle to the new key
 *
 *  Returns:
 */
BOOL CPDuplicateKey(IN HCRYPTPROV hUID,
                    IN HCRYPTKEY hKey,
                    IN DWORD *pdwReserved,
                    IN DWORD dwFlags,
                    IN HCRYPTKEY *phKey)
{
    PNTAGKeyList    pTmpKey;
    PNTAGKeyList    pNewKey = NULL;
    BYTE            bType = KEY_HANDLE;
    BOOL            fRet = NTF_FAILED;

#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputDuplicateKey(TRUE, FALSE, hUID, hKey, pdwReserved,
                               dwFlags, phKey);
#endif // DBG -- NOTE:  This section not compiled for retail builds

    if (NULL != pdwReserved)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    if (0 != dwFlags)
    {
        SetLastError((DWORD)NTE_BAD_FLAGS);
        goto Ret;
    }

    if (NULL == (pTmpKey = (PNTAGKeyList)NTLValidate((HNTAG)hKey, hUID,
                                                      bType)))
    {
        bType = SIGPUBKEY_HANDLE;
        if (NULL == (pTmpKey = (PNTAGKeyList)NTLValidate((HNTAG)hKey, hUID,
                                                         bType)))
        {
            bType = EXCHPUBKEY_HANDLE;
            if (NULL == (pTmpKey = (PNTAGKeyList)NTLValidate((HNTAG)hKey, hUID,
                                                             bType)))
            {
                SetLastError((DWORD)NTE_BAD_KEY);
                goto Ret;
            }
        }
    }

    if (!CopyKey(pTmpKey, &pNewKey))
        goto Ret;          // error already set


    if (NTF_FAILED == NTLMakeItem(phKey, bType, (void *)pNewKey))
        goto Ret;          // error already set

    fRet = NTF_SUCCEED;
Ret:
#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputDuplicateKey(FALSE, fRet, 0, 0, NULL, 0, NULL);
#endif // DBG -- NOTE:  This section not compiled for retail builds

    if ((NTF_FAILED == fRet) && pNewKey)
        FreeNewKey(pNewKey);
    return fRet;
}

//
// Function : TestEncDec
//
// Description : This function expands the passed in key buffer for the appropriate
//               algorithm, and then either encryption or decryption is performed.
//               A comparison is then made to see if the ciphertext or plaintext
//               matches the expected value.
//               The function only uses ECB mode for block ciphers and the plaintext
//               buffer must be the same length as the ciphertext buffer.  The length
//               of the plaintext must be either the block length of the cipher if it
//               is a block cipher or less than MAX_BLOCKLEN if a stream cipher is
//               being used.
//
BOOL TestEncDec(
                IN ALG_ID Algid,
                IN BYTE *pbKey,
                IN DWORD cbKey,
                IN BYTE *pbPlaintext,
                IN DWORD cbPlaintext,
                IN BYTE *pbCiphertext,
                IN BYTE *pbIV,
                IN int iOperation
                )
{
    BYTE    *pbExpandedKey = NULL;
    BYTE    rgbBuffIn[MAX_BLOCKLEN];
    BYTE    rgbBuffOut[MAX_BLOCKLEN];
    DWORD   i;
    BOOL    fRet = FALSE;

    memset(rgbBuffIn, 0, sizeof(rgbBuffIn));
    memset(rgbBuffOut, 0, sizeof(rgbBuffOut));

    // length of data to encrypt must be < MAX_BLOCKLEN 
    if (cbPlaintext > MAX_BLOCKLEN)
    {
        goto Ret;
    }

    // alloc for and expand the key
    switch(Algid)
    {
#ifdef CSP_USE_RC4
        case (CALG_RC4):
        {
            if (NULL == (pbExpandedKey = _nt_malloc(sizeof(RC4_KEYSTRUCT))))
            {
                goto Ret;
            }
            rc4_key((RC4_KEYSTRUCT*)pbExpandedKey, cbKey, pbKey);
            break;
        }
#endif // CSP_USE_RC4

#ifdef CSP_USE_RC2
        case (CALG_RC2):
        {
            if (NULL == (pbExpandedKey = _nt_malloc(RC2_TABLESIZE)))
            {
                goto Ret;
            }
            RC2KeyEx((WORD*)pbExpandedKey, pbKey, cbKey, cbKey * 8);
            break;
        }
#endif // CSP_USE_RC2

#ifdef CSP_USE_DES40
        case (CALG_DES40):
        {
            if (NULL == (pbExpandedKey = _nt_malloc(DES_TABLESIZE)))
            {
                goto Ret;
            }
            pbKey[0] &= 0x0F;    // set 4 leftmost bits of first byte to zero
            pbKey[2] &= 0x0F;    // set 4 leftmost bits of third byte to zero
            pbKey[4] &= 0x0F;    // set 4 leftmost bits of fifth byte to zero
            pbKey[6] &= 0x0F;    // set 4 leftmost bits of seventh byte to zero
            desparityonkey(pbKey, cbKey);
            deskey((DESTable*)pbExpandedKey, pbKey);
            break;
        }
#endif // CSP_USE_DES40

#ifdef CSP_USE_DES
        case (CALG_DES):
        {
            if (NULL == (pbExpandedKey = _nt_malloc(DES_TABLESIZE)))
            {
                goto Ret;
            }
            desparityonkey(pbKey, cbKey);
            deskey((DESTable*)pbExpandedKey, pbKey);
            break;
        }
#endif // CSP_USE_DES

#ifdef CSP_USE_3DES
        desparityonkey(pbKey, cbKey);
        case (CALG_3DES):
        {
            if (NULL == (pbExpandedKey = _nt_malloc(DES3_TABLESIZE)))
            {
                goto Ret;
            }
            tripledes3key((PDES3TABLE)pbExpandedKey, pbKey);
            break;
        }

        case (CALG_3DES_112):
        {
            if (NULL == (pbExpandedKey = _nt_malloc(DES3_TABLESIZE)))
            {
                goto Ret;
            }
            tripledes2key((PDES3TABLE)pbExpandedKey, pbKey);
            break;
        }
#endif // CSP_USE_3DES
    }

    // if encrypting and there is an IV then use it
    if ((ENCRYPT == iOperation) && (CALG_RC4 != Algid))
    {
        memcpy(rgbBuffIn, pbPlaintext, cbPlaintext);

        if (NULL != pbIV)
        {
            for(i = 0; i < cbPlaintext; i++)
            {
                rgbBuffIn[i] = rgbBuffIn[i] ^ pbIV[i];
            }
        }
    }

    // encrypt the plaintext
    switch(Algid)
    {
#ifdef CSP_USE_RC4
        case (CALG_RC4):
        {
            if (ENCRYPT == iOperation)
            {            
                memcpy(rgbBuffOut, pbPlaintext, cbPlaintext);
            }
            else
            {
                memcpy(rgbBuffOut, pbCiphertext, cbPlaintext);
            }
            rc4((RC4_KEYSTRUCT*)pbExpandedKey, cbPlaintext, rgbBuffOut);
            break;
        }
#endif // CSP_USE_RC4

#ifdef CSP_USE_RC2
        case (CALG_RC2):
        {
            if (ENCRYPT == iOperation)
            {
                RC2(rgbBuffOut, rgbBuffIn, pbExpandedKey, ENCRYPT);
            }
            else
            {
                RC2(rgbBuffOut, pbCiphertext, pbExpandedKey, DECRYPT);
            }
            break;
        }
#endif // CSP_USE_RC2

#ifdef CSP_USE_DES40
        case (CALG_DES40):
        {
            if (ENCRYPT == iOperation)
            {
                des(rgbBuffOut, rgbBuffIn, pbExpandedKey, ENCRYPT);
            }
            else
            {
                des(rgbBuffOut, pbCiphertext, pbExpandedKey, DECRYPT);
            }
            break;
        }
#endif // CSP_USE_DES40

#ifdef CSP_USE_DES
        case (CALG_DES):
        {
            if (ENCRYPT == iOperation)
            {
                des(rgbBuffOut, rgbBuffIn, pbExpandedKey, ENCRYPT);
            }
            else
            {
                des(rgbBuffOut, pbCiphertext, pbExpandedKey, DECRYPT);
            }
            break;
        }
#endif // CSP_USE_DES

#ifdef CSP_USE_3DES
        case (CALG_3DES):
        case (CALG_3DES_112):
        {
            if (ENCRYPT == iOperation)
            {
                tripledes(rgbBuffOut, rgbBuffIn, pbExpandedKey, ENCRYPT);
            }
            else
            {
                tripledes(rgbBuffOut, pbCiphertext, pbExpandedKey, DECRYPT);
            }
            break;
        }
#endif // CSP_USE_3DES
    }

    // compare the encrypted plaintext with the passed in ciphertext
    if (ENCRYPT == iOperation)
    {
        if (memcmp(pbCiphertext, rgbBuffOut, cbPlaintext))
        {
            goto Ret;
        }
    }
    // compare the decrypted ciphertext with the passed in plaintext
    else
    {
        // if there is an IV then use it
        if (NULL != pbIV)
        {
            for(i = 0; i < cbPlaintext; i++)
            {
                rgbBuffOut[i] = rgbBuffOut[i] ^ pbIV[i];
            }
        }

        if (memcmp(pbPlaintext, rgbBuffOut, cbPlaintext))
        {
            goto Ret;
        }
    }

    fRet = TRUE;
Ret:
    if (pbExpandedKey)
    {
        _nt_free(pbExpandedKey, 0);
    }

    return fRet;
}

//
// Function : TestSymmetricAlgorithm
//
// Description : This function expands the passed in key buffer for the appropriate algorithm,
//               encrypts the plaintext buffer with the same algorithm and key, and the
//               compares the passed in expected ciphertext with the calculated ciphertext
//               to make sure they are the same.  The opposite is then done with decryption.
//               The function only uses ECB mode for block ciphers and the plaintext
//               buffer must be the same length as the ciphertext buffer.  The length
//               of the plaintext must be either the block length of the cipher if it
//               is a block cipher or less than MAX_BLOCKLEN if a stream cipher is
//               being used.
//
BOOL TestSymmetricAlgorithm(
                            IN ALG_ID Algid,
                            IN BYTE *pbKey,
                            IN DWORD cbKey,
                            IN BYTE *pbPlaintext,
                            IN DWORD cbPlaintext,
                            IN BYTE *pbCiphertext,
                            IN BYTE *pbIV
                            )
{
    BOOL    fRet = FALSE;

    if (!TestEncDec(Algid, pbKey, cbKey, pbPlaintext, cbPlaintext,
                    pbCiphertext, pbIV, ENCRYPT))
    {
        goto Ret;
    }
    if (!TestEncDec(Algid, pbKey, cbKey, pbPlaintext, cbPlaintext,
                    pbCiphertext, pbIV, DECRYPT))
    {
        goto Ret;
    }

    fRet = TRUE;
Ret:
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\rsabase\nt_rand.c ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : nt_rand.c                                              //
//  DESCRIPTION   : Crypto CP interfaces:                                  //
//                  CPGenRandom                                            //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//	Jan 25 1995 larrys  Changed from Nametag                           //
//      Feb 23 1995 larrys  Changed NTag_SetLastError to SetLastError      //
//      Apr 10 1995 larrys  Fix comments                                   //
//      Oct 27 1995 rajeshk Added provider parameter to GenRandom call     //
//      Nov  3 1995 larrys  Merge for NT checkin                           //
//      Oct 14 1996 jeffspel Changed GenRandom to NewGenRandom             //
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "sha.h"
#include "rsa_fast.h"
#include "rsa_math.h"
#include "randlib.h"

static BYTE DSSPRIVATEKEYINIT[] =
{ 0x67, 0x45, 0x23, 0x01, 0xef, 0xcd, 0xab, 0x89,
  0x98, 0xba, 0xdc, 0xfe, 0x10, 0x32, 0x54, 0x76,
  0xc3, 0xd2, 0xe1, 0xf0};

static BYTE DSSPERMSGINIT[] =
{ 0xef, 0xcd, 0xab, 0x89, 0x98, 0xba, 0xdc, 0xfe,
  0x10, 0x32, 0x54, 0x76, 0xc3, 0xd2, 0xe1, 0xf0,
  0x67, 0x45, 0x23, 0x01};

static BYTE MODULUS[] =
{ 0xf5, 0xc1, 0x56, 0xb1, 0xd5, 0x48, 0x42, 0x2e,
  0xbd, 0xa5, 0x44, 0x41, 0xc7, 0x1c, 0x24, 0x08,
  0x3f, 0x80, 0x3c, 0x90};


BYTE g_rgbRNGState[A_SHA_DIGEST_LEN];

//
// Function : AddSeeds
//
// Description : This function adds the 160 bit seeds pointed to by pdwSeed1 and
//               pdwSeed2, it also adds 1 to this sum and mods the sum by
//               2^160.
//

void AddSeeds(
              IN DWORD *pdwSeed1,
              IN OUT DWORD *pdwSeed2
              )
{
    DWORD   dwTmp;
    DWORD   dwOverflow = 1;
    DWORD   i;

    for (i = 0; i < 5; i++)
    {
        dwTmp = dwOverflow + pdwSeed1[i];
        dwOverflow = (dwOverflow > dwTmp);
        pdwSeed2[i] = pdwSeed2[i] + dwTmp;
        dwOverflow = ((dwTmp > pdwSeed2[i]) || dwOverflow);
    }
}


void SHA_mod_q(
               BYTE      *pbHash,              // In
               BYTE      *pbQ,                 // In
               BYTE      *pbNewHash            // Out
               )    
/*
        Given SHA(message), compute SHA(message) mod qdigit.
        Output is in the interval [0, qdigit-1].
        Although SHA(message) may exceed qdigit,
        it cannot exceed 2*qdigit since the leftmost bit 
        of qdigit is 1.
*/
{
    BYTE    rgbHash[A_SHA_DIGEST_LEN];

    if (-1 != Compare((DWORD*)rgbHash,  // hash is greater so subtract
                      (DWORD*)pbQ,
                      A_SHA_DIGEST_LEN / sizeof(DWORD)))  
    {
        Sub((DWORD*)pbNewHash,
            (DWORD*)rgbHash,
            (DWORD*)pbQ,
            A_SHA_DIGEST_LEN / sizeof(DWORD));
    }
    else
    {
        memcpy(pbNewHash, pbHash, A_SHA_DIGEST_LEN / sizeof(DWORD));
    }
} /* SHA_mod_q */

//
// Function : RNG16BitStateCheck
//
// Description : This function compares each 160 bits of the buffer with
//               the next 160 bits and if they are the same the function
//               errors out.  The IN buffer is expected to be A_SHA_DIGEST_LEN
//               bytes long.  The function fails if the RNG is gets the same
//               input buffer of 160 bits twice in a row.
//

BOOL RNG16BitStateCheck(
                        IN OUT DWORD *pdwOut,
                        IN DWORD *pdwIn,
                        IN DWORD cbNeeded
                        )
{
    BOOL    fRet = FALSE;

    if (0 == memcmp(g_rgbRNGState, pdwIn, A_SHA_DIGEST_LEN))
    {
        memcpy(g_rgbRNGState, (BYTE*)pdwIn, A_SHA_DIGEST_LEN);
        goto Ret;
    }

    memcpy(g_rgbRNGState, (BYTE*)pdwIn, A_SHA_DIGEST_LEN);

    memcpy((BYTE*)pdwOut, (BYTE*)pdwIn, cbNeeded);

    fRet = TRUE;
Ret:
    return fRet;
}

//
// Function : FIPS186Gen
//
// Description : FIPS 186 RNG, the seed is generated by calling NewGenRandom.
//

BOOL FIPS186Gen(
                IN HANDLE hRNGDriver,
                IN BYTE **ppbContextSeed,
                IN DWORD *pcbContextSeed,
                IN BYTE *pbInitValue,     // this is t, must be 20 bytes
                IN BYTE *pbModulus,       // this must be a 20 byte prime
                IN OUT BYTE *pb,
                IN DWORD cb
                )
{
    DWORD           rgdwSeed[A_SHA_DIGEST_LEN/sizeof(DWORD)];    // 160 bits
    DWORD           rgdwNewSeed[A_SHA_DIGEST_LEN/sizeof(DWORD)]; // 160 bits
    A_SHA_CTX       SHACtxt;
    BYTE            rgbBuf[A_SHA_DIGEST_LEN];
    DWORD           cbBuf;
    BYTE            *pbTmp = pb;
    DWORD           cbTmp = cb;
    DWORD           i;
    BOOL            fRet = FALSE;

    while (cbTmp)
    {
#ifdef USE_HW_RNG
#ifdef _M_IX86
        // get a 160 bit random seed
        if (INVALID_HANDLE_VALUE != hRNGDriver)
        {
	        if (!HWRNGGenRandom(hRNGDriver,
                                (BYTE*)rgdwNewSeed,
                                sizeof(rgdwNewSeed)))
            {
                SetLastError((DWORD)NTE_FAIL);
                goto Ret;
            }
        }
        else
#endif // _M_IX86
#endif // USE_HW_RNG
        {
            // get a 160 bit random seed
            NewGenRandom(ppbContextSeed, pcbContextSeed,
                         (BYTE*)rgdwNewSeed, sizeof(rgdwNewSeed));
        }

        for (i = 0; i < A_SHA_DIGEST_LEN/sizeof(DWORD); i++)
        {
            rgdwSeed[i] ^= rgdwNewSeed[i];
        }

        A_SHAInit (&SHACtxt);
        memcpy(SHACtxt.state, pbInitValue, A_SHA_DIGEST_LEN);

        // perform the one way function
        A_SHAUpdate(&SHACtxt, (BYTE*)rgdwSeed, sizeof(rgdwSeed));
        A_SHAFinal(&SHACtxt, rgbBuf);

        // continuous 16 bit state check
        if (A_SHA_DIGEST_LEN < cbTmp)
        {
            cbBuf = A_SHA_DIGEST_LEN;
        }
        else
        {
            cbBuf = cbTmp;
        }
        if (!RNG16BitStateCheck((DWORD*)pbTmp, (DWORD*)rgbBuf, cbBuf))
        {
            SetLastError((DWORD)NTE_FAIL);
            goto Ret;
        }
        pbTmp += cbBuf;
        cbTmp -= cbBuf;
        if (0 == cbTmp)
            break;

        // modular reduction with modulus Q
        SHA_mod_q(rgbBuf, pbModulus, (BYTE*)rgdwNewSeed);

        // (1 + previous seed + new random) mod 2^160
        AddSeeds(rgdwNewSeed, rgdwSeed);
    }

    fRet = TRUE;
Ret:
    return fRet;
}

BOOL FIPS186GenRandom(
                      IN HANDLE *phRNGDriver,
                      IN BYTE **ppbContextSeed,
                      IN DWORD *pcbContextSeed,
                      IN OUT BYTE *pb,
                      IN DWORD cb
                      )
{
    return FIPS186Gen(*phRNGDriver, ppbContextSeed, pcbContextSeed,
                      DSSPRIVATEKEYINIT, MODULUS, pb, cb);
}

void FIPS186GenRandomWithException(
                      IN HANDLE *phRNGDriver,
                      IN BYTE **ppbContextSeed,
                      IN DWORD *pcbContextSeed,
                      IN OUT BYTE *pb,
                      IN DWORD cb
                      )
{
    if (!FIPS186Gen(*phRNGDriver, ppbContextSeed, pcbContextSeed,
                    DSSPRIVATEKEYINIT, MODULUS, pb, cb))
    {
        // nasty way to cause an error but need either this
        // or redo rsa32.lib
        RaiseException ( NTE_FAIL, 0, 0, 0 );;
    }
}


/*
 -	CPGenRandom
 -
 *	Purpose:
 *                Used to fill a buffer with random bytes
 *
 *
 *	Parameters:
 *               IN  hUID       -  Handle to the user identifcation
 *               IN  dwLen      -  Number of bytes of random data requested
 *               OUT pbBuffer   -  Pointer to the buffer where the random
 *                                 bytes are to be placed
 *
 *	Returns:
 */
BOOL CPGenRandom(IN HCRYPTPROV hUID,
                 IN DWORD dwLen,
                 OUT BYTE *pbBuffer)
{
    PNTAGUserList   pTmpUser;
    BOOL            fRet = NTF_FAILED;

#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputGenRandom(TRUE, FALSE, hUID, dwLen, pbBuffer);
#endif // DBG -- NOTE:  This section not compiled for retail builds

	// check the user identification
	if (NULL == (pTmpUser = NTLCheckList (hUID, USER_HANDLE)))
	{
		SetLastError((DWORD) NTE_BAD_UID);
		goto Ret;
	}

    FIPS186Gen(pTmpUser->hRNGDriver,
               &pTmpUser->ContInfo.pbRandom,
               &pTmpUser->ContInfo.ContLens.cbRandom,
               DSSPRIVATEKEYINIT,
               MODULUS, pbBuffer, dwLen);

    fRet = NTF_SUCCEED;
Ret:
#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputGenRandom(FALSE, fRet, 0, 0, NULL);
#endif // DBG -- NOTE:  This section not compiled for retail builds

	return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\rsabase\nt_crypt.c ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : nt_crypt.c                                             //
//  DESCRIPTION   : Crypto CP interfaces:                                  //
//                  CPEncrypt                                              //
//                  CPDecrypt                                              //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Jan 25 1995 larrys  Changed from Nametag                           //
//      Jan 30 1995 larrys  Cleanup code                                   //
//      Feb 23 1995 larrys  Changed NTag_SetLastError to SetLastError      //
//      Apr 10 1995 larrys  Added freeing of RC4 key data on final flag    //
//      May  8 1995 larrys  Changes for MAC hashing                        //
//      May  9 1995 larrys  Added check for double encryption              //
//      May 10 1995 larrys  added private api calls                        //
//      Jul 13 1995 larrys  Changed MAC stuff                              //
//      Aug 16 1995 larrys  Removed exchange key stuff                     //
//      Oct 05 1995 larrys  Fixed bugs 50 & 51                             //
//      Nov  8 1995 larrys  Fixed SUR bug 10769                            //
//      May 15 1996 larrys  Changed NTE_NO_MEMORY to ERROR_NOT_ENOUGHT...  //
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "nt_rsa.h"
#include "mac.h"
#include "tripldes.h"
#include "swnt_pk.h"
#include "protstor.h"
#include "ntagum.h"

#ifndef STRONG
#define DE_BLOCKLEN             8       // size of double encrypt block

BYTE        dbDEncrypt[DE_BLOCKLEN];    // First 8 bytes of last encrypt
BOOL        fDEncrypt = FALSE;          // Flag for Double encrypt
BYTE        dbDDecrypt[DE_BLOCKLEN];    // First 8 bytes of last Decrypt
DWORD       fDDecrypt = FALSE;          // Flag for Double Decrypt
#endif // STRONG

extern CSP_STRINGS g_Strings;

BOOL FIsLegalKey(
                 PNTAGUserList pTmpUser,
                 PNTAGKeyList pKey,
                 BOOL fRC2BigKeyOK
                 );

BOOL CPInflateKey(
                  IN PNTAGKeyList pTmpKey
                  );

/* BlockEncrypt -

        Run a block cipher over a block of size *pdwDataLen.

*/

BOOL BlockEncrypt(void EncFun(BYTE *In, BYTE *Out, void *key, int op),
                  PNTAGKeyList pKey,
                  int BlockLen,
                  BOOL Final,
                  BYTE  *pbData,
                  DWORD *pdwDataLen,
                  DWORD dwBufLen)
{
    DWORD   cbPartial, dwPadVal, dwDataLen;
    BYTE    *pbBuf;

    dwDataLen = *pdwDataLen;
    
    // Check to see if we are encrypting something already

    if (pKey->InProgress == FALSE)
    {
        pKey->InProgress = TRUE;
        if (pKey->Mode == CRYPT_MODE_CBC || pKey->Mode == CRYPT_MODE_CFB)
        {
            memcpy(pKey->FeedBack, pKey->IV, BlockLen);
        }
    }

    // check length of the buffer and calculate the pad
    // (if multiple of blocklen, do a full block of pad)
    
    cbPartial = (dwDataLen % BlockLen);
    if (Final)
    {
        dwPadVal = BlockLen - cbPartial;
        if (pbData == NULL || dwBufLen < dwDataLen + dwPadVal)
        {
            // set what we need
            *pdwDataLen = dwDataLen + dwPadVal;
            if (pbData == NULL)
            {
                return NTF_SUCCEED;
            }

            SetLastError(ERROR_MORE_DATA);
            return NTF_FAILED;
        }
        else
        {
            // Clear encryption flag
            pKey->InProgress = FALSE;
        }

    }
    else
    {

        if (pbData == NULL)
        {
            *pdwDataLen = dwDataLen;
            return NTF_SUCCEED;
        }

        // Non-Final make multiple of the blocklen
        if (cbPartial)
        {
            // set what we need
            *pdwDataLen = dwDataLen + cbPartial;
            ASSERT((*pdwDataLen % BlockLen) == 0);
            SetLastError((DWORD) NTE_BAD_DATA);
            return NTF_FAILED;
        }
        dwPadVal = 0;
    }

    // allocate memory for a temporary buffer
    if ((pbBuf = (BYTE *)_nt_malloc(BlockLen)) == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NTF_FAILED;
    }

    if (dwPadVal)
    {
        // Fill the pad with a value equal to the
        // length of the padding, so decrypt will
        // know the length of the original data
        // and as a simple integrity check.
        
        memset(pbData + dwDataLen, (int)dwPadVal, (size_t)dwPadVal);
    }

    dwDataLen += dwPadVal;
    *pdwDataLen = dwDataLen;

    ASSERT((dwDataLen % BlockLen) == 0);
    
    // pump the full blocks of data through
    while (dwDataLen)
    {
        ASSERT(dwDataLen >= (DWORD)BlockLen);

        // put the plaintext into a temporary
        // buffer, then encrypt the data
        // back into the caller's buffer
            
        memcpy(pbBuf, pbData, BlockLen);

        switch(pKey->Mode)
        {
            case CRYPT_MODE_CBC:
                CBC(EncFun, BlockLen, pbData, pbBuf, pKey->pData,
                    ENCRYPT, pKey->FeedBack);
                break;

            case CRYPT_MODE_ECB:
                EncFun(pbData, pbBuf, pKey->pData, ENCRYPT);
                break;

            case CRYPT_MODE_CFB:
                CFB(EncFun, BlockLen, pbData, pbBuf, pKey->pData,
                    ENCRYPT, pKey->FeedBack);
                break;

            default:
                _nt_free(pbBuf, BlockLen);
                SetLastError((DWORD) NTE_BAD_ALGID);
                return NTF_FAILED;
                break;
        }
        pbData += BlockLen;
        dwDataLen -= BlockLen;
    }
    
    _nt_free(pbBuf, BlockLen);

    return NTF_SUCCEED;

}

BOOL BlockDecrypt(void DecFun(BYTE *In, BYTE *Out, void *key, int op),
                  PNTAGKeyList pKey,
                  int BlockLen,
                  BOOL Final,
                  BYTE  *pbData,
                  DWORD *pdwDataLen)
{
    BYTE    *pbBuf;
    DWORD   dwDataLen, BytePos, dwPadVal, i;

    dwDataLen = *pdwDataLen;
    
    // Check to see if we are decrypting something already

    if (pKey->InProgress == FALSE)
    {
        pKey->InProgress = TRUE;
        if (pKey->Mode == CRYPT_MODE_CBC ||
            pKey->Mode == CRYPT_MODE_CFB)
        {
            memcpy(pKey->FeedBack, pKey->IV, BlockLen);
        }
    }

    // The data length must be a multiple of the algorithm
    // pad size.
    if (dwDataLen % BlockLen)
    {
        SetLastError((DWORD) NTE_BAD_DATA);
        return NTF_FAILED;
    }

    // allocate memory for a temporary buffer
    if ((pbBuf = (BYTE *)_nt_malloc(BlockLen)) == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NTF_FAILED;
    }

    // pump the data through the decryption, including padding
    // NOTE: the total length is a multiple of BlockLen
    
    for (BytePos = 0; (BytePos + BlockLen) <= dwDataLen; BytePos += BlockLen)
    {
        // put the encrypted text into a temp buffer
        memcpy (pbBuf, pbData + BytePos, BlockLen);

        switch (pKey->Mode)
        {
            case CRYPT_MODE_CBC:
                CBC(DecFun, BlockLen, pbData + BytePos, pbBuf, pKey->pData,
                    DECRYPT, pKey->FeedBack);
                break;

            case CRYPT_MODE_ECB:
                DecFun(pbData + BytePos, pbBuf, pKey->pData, DECRYPT);
                break;

            case CRYPT_MODE_CFB:
                CFB(DecFun, BlockLen, pbData + BytePos, pbBuf, pKey->pData,
                    DECRYPT, pKey->FeedBack);
                break;

            default:
                _nt_free(pbBuf, BlockLen);
                SetLastError((DWORD) NTE_BAD_ALGID);
                return NTF_FAILED;
                break;
        }

    }

    _nt_free(pbBuf, BlockLen);

    // if this is the final block of data then
    // verify the padding and remove the pad size
    // from the data length. NOTE: The padding is
    // filled with a value equal to the length
    // of the padding and we are guaranteed >= 1
    // byte of pad.
    // ## NOTE: if the pad is wrong, the user's
    // buffer is hosed, because
    // ## we've decrypted into the user's
    // buffer -- can we re-encrypt it?

    if (Final)
    {
        pKey->InProgress = FALSE;
        
        dwPadVal = (DWORD)*(pbData + dwDataLen - 1);
        if (dwPadVal == 0 || dwPadVal > (DWORD) BlockLen)
        {
            SetLastError((DWORD) NTE_BAD_DATA);
            return NTF_FAILED;
        }
        
        // Make sure all the (rest of the) pad bytes are correct.
        for (i=1; i<dwPadVal; i++)
        {
            if (pbData[dwDataLen - (i + 1)] != dwPadVal)
            {
                SetLastError((DWORD) NTE_BAD_DATA);
                return NTF_FAILED;
            }
        }

        // Only need to update the length on final
        *pdwDataLen -= dwPadVal;
    }

    return NTF_SUCCEED;
}

BOOL RSAEncryptionAllowed(
                          PNTAGUserList pTmpUser,
                          DWORD dwFlags
                          )
{
    BOOL    fRet = FALSE;

    if (FIsWinNT())
    {
        if (((dwFlags == 0) || (0x9C580000 != dwFlags)) &&
            (pTmpUser->fIsLocalSystem))
        {
            fRet = TRUE;
        }
    }
    return fRet;
}

/*
 -      SymEncrypt
 -
 *      Purpose:
 *                Encrypt data with symmetric algorithms.  This function is used
 *                by the LocalEncrypt function as well as the WrapSymKey (nt_key.c)
 *                function.
 *
 *      Parameters:
 *               IN  pKey          -  Handle to the key
 *               IN  fFinal        -  Boolean indicating if this is the final
 *                                    block of plaintext
 *               IN OUT pbData     -  Data to be encrypted
 *               IN OUT pcbData    -  Pointer to the length of the data to be
 *                                    encrypted
 *               IN cbBuf          -  Size of Data buffer
 *
 *      Returns:
 */

BOOL SymEncrypt(
                IN PNTAGKeyList pKey,
                IN BOOL fFinal,
                IN OUT BYTE *pbData,
                IN OUT DWORD *pcbData,
                IN DWORD cbBuf
                )
{
    BOOL    fRet = FALSE;

    // determine which algorithm is to be used
    switch (pKey->Algid)
    {
#ifdef CSP_USE_RC2
        case CALG_RC2:
            if (!BlockEncrypt(RC2, pKey, RC2_BLOCKLEN, fFinal, pbData,
                              pcbData, cbBuf))
            {
                goto Ret;
            }
            break;
#endif

#ifdef CSP_USE_DES
        case CALG_DES:
            if (!BlockEncrypt(des, pKey, DES_BLOCKLEN, fFinal, pbData,
                              pcbData, cbBuf))
            {
                goto Ret;
            }
            break;
#endif

#ifdef CSP_USE_3DES
        case CALG_3DES_112:
        case CALG_3DES:
            if (!BlockEncrypt(tripledes, pKey, DES_BLOCKLEN, fFinal, pbData,
                              pcbData, cbBuf))
            {
                goto Ret;
            }
            break;
#endif

#ifdef CSP_USE_RC4

        case CALG_RC4:
            if (pbData == NULL)
            {
                fRet = TRUE;
                goto Ret;
            }
            if (*pcbData > cbBuf)
            {
                SetLastError(ERROR_MORE_DATA);
                goto Ret;
            }
            rc4((struct RC4_KEYSTRUCT *)pKey->pData, *pcbData, pbData);

            if (fFinal)
            {
                if (pKey->pData)
                    _nt_free (pKey->pData, pKey->cbDataLen);
                pKey->pData = 0;
                pKey->cbDataLen = 0;
            }

            break;
#endif

        default:
            SetLastError((DWORD) NTE_BAD_ALGID);
            goto Ret;
            break;
    }

    fRet = TRUE;
Ret:
    return fRet;
}

/*
 -      LocalEncrypt
 -
 *      Purpose:
 *                Encrypt data
 *
 *
 *      Parameters:
 *               IN  hUID          -  Handle to the CSP user
 *               IN  hKey          -  Handle to the key
 *               IN  hHash         -  Optional handle to a hash
 *               IN  Final         -  Boolean indicating if this is the final
 *                                    block of plaintext
 *               IN OUT pbData     -  Data to be encrypted
 *               IN OUT pdwDataLen -  Pointer to the length of the data to be
 *                                    encrypted
 *               IN dwBufLen       -  Size of Data buffer
 *               IN fIsExternal    -  Flag to tell if the call is for internal 
 *                                    CSP use or external caller
 *
 *      Returns:
 */

BOOL LocalEncrypt(IN HCRYPTPROV hUID,
                  IN HCRYPTKEY hKey,
                  IN HCRYPTHASH hHash,
                  IN BOOL Final,
                  IN DWORD dwFlags,
                  IN OUT BYTE *pbData,
                  IN OUT DWORD *pdwDataLen,
                  IN DWORD dwBufSize,
                  IN BOOL fIsExternal)
{
    DWORD               dwDataLen;
    PNTAGUserList       pTmpUser;
    PNTAGKeyList        pTmpKey;
    PNTAGKeyList        pTmpKey2;
    PNTAGHashList       pTmpHash;
    DWORD               dwLen;
    MACstate            *pMAC;
    BSAFE_PUB_KEY       *pBsafePubKey;
    BYTE                *pbOutput = NULL;
    BOOL                fRet = FALSE;

    if ((dwFlags != 0) && (0x9C580000 != dwFlags))
    {
        SetLastError((DWORD) NTE_BAD_FLAGS);
        goto Ret;
    }

    dwDataLen = *pdwDataLen;

    if ((Final == FALSE) && (dwDataLen == 0))
    {
        // If no data to encrypt and this isn't the last block,
        // then we're done. (if Final, we need to pad)
        fRet = TRUE;
        goto Ret;
    }

    if ((pTmpUser = (PNTAGUserList) NTLCheckList (hUID, USER_HANDLE)) == NULL)
    {
        SetLastError((DWORD) NTE_BAD_UID);
        goto Ret;
    }

    //
    // Check if encryption allowed
    //
    if (fIsExternal &&
        (PROV_RSA_SCHANNEL != pTmpUser->dwProvType) &&
        ((pTmpUser->Rights & CRYPT_DISABLE_CRYPT) == CRYPT_DISABLE_CRYPT))
    {
        SetLastError((DWORD) NTE_PERM);
        goto Ret;
    }

    if (NULL == (pTmpKey = (PNTAGKeyList) NTLValidate(hKey, hUID, KEY_HANDLE)))
    {
        if (NULL == (pTmpKey = (PNTAGKeyList) NTLValidate(hKey, hUID, EXCHPUBKEY_HANDLE)))
        {
            // NTLValidate doesn't know what error to set
            // so it set NTE_FAIL -- fix it up.
            if (GetLastError() == NTE_FAIL)
            {
                SetLastError((DWORD) NTE_BAD_KEY);
            }
            goto Ret;
        }
    }

    if ((pTmpKey->Algid != CALG_RSA_KEYX) &&
        (!FIsLegalKey(pTmpUser, pTmpKey, FALSE)))
    {
        SetLastError((DWORD) NTE_BAD_KEY);
        goto Ret;
    }

    if ((Final == FALSE) && (pTmpKey->Algid != CALG_RC4))
    {
        if (dwDataLen < CRYPT_BLKLEN)
        {
            *pdwDataLen = CRYPT_BLKLEN;
            SetLastError((DWORD) NTE_BAD_DATA);
            goto Ret;
        }
    }

#ifndef STRONG
    if (fDEncrypt && pbData != NULL && *pdwDataLen != 0)
    {
        if (memcmp(dbDEncrypt, pbData, DE_BLOCKLEN) == 0)
        {
            SetLastError((DWORD) NTE_DOUBLE_ENCRYPT);
            goto Ret;
        }
    }
#endif // STRONG

    // Check if we should do an auto-inflate
    if ((pTmpKey->pData == NULL) && (pTmpKey->Algid != CALG_RSA_KEYX))
    {
        if (NTAG_FAILED(CPInflateKey(pTmpKey)))
        {
            goto Ret;
        }
    }

    if ((hHash != 0) && (NULL != pbData))
    {
        if ((pTmpHash = (PNTAGHashList)NTLValidate(hHash, hUID,
            HASH_HANDLE)) == NULL)
        {
            SetLastError((DWORD) NTE_BAD_HASH);
            goto Ret;
        }

	    if (pTmpHash->Algid == CALG_MAC)
        {
            // Check if we should do an auto-inflate
            pMAC = pTmpHash->pHashData;
            if ((pTmpKey2 = (PNTAGKeyList) NTLValidate(pMAC->hKey, hUID,
                                                      KEY_HANDLE)) == NULL)
            {
                // NTLValidate doesn't know what error to set
                // so it set NTE_FAIL -- fix it up.
                if (GetLastError() == NTE_FAIL)
                {
                    SetLastError((DWORD) NTE_BAD_KEY);
                }
                goto Ret;
            }
            if (pTmpKey2->pData == NULL)
            {
                if (NTAG_FAILED(CPInflateKey(pTmpKey2)))
                {
                    goto Ret;
                }
            }
        }

        if (!CPHashData(hUID, hHash, pbData, *pdwDataLen, 0))
        {
            goto Ret;
        }

    }

    // determine which algorithm is to be used
    switch (pTmpKey->Algid)
    {
        case CALG_RSA_KEYX:
#ifndef STRONG
            if (!RSAEncryptionAllowed(pTmpUser, dwFlags))
            {
                SetLastError((DWORD) NTE_BAD_KEY);
                goto Ret;
            }
#endif // STRONG

            pBsafePubKey = (BSAFE_PUB_KEY *) pTmpKey->pKeyValue;

            if (pBsafePubKey == NULL)
            {
                SetLastError((DWORD) NTE_BAD_KEY);
                goto Ret;
            }

            // compute length of resulting data
            dwLen = (pBsafePubKey->bitlen + 7) / 8;
        
            if (!CheckDataLenForRSAEncrypt(dwLen, *pdwDataLen, dwFlags))
            {
                SetLastError((DWORD) NTE_BAD_LEN);
                goto Ret;
            }

            if (pbData == NULL || dwBufSize < dwLen)
            {
                *pdwDataLen = dwLen;    // set what we need
                if (pbData == NULL)
                {
                    fRet = TRUE;
                    goto Ret;
                }
                SetLastError(ERROR_MORE_DATA);
                goto Ret;
            }
            
            if (NULL == (pbOutput = (BYTE*)_nt_malloc(dwLen)))
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }

            // perform the RSA encryption
            if (!RSAEncrypt(pTmpUser, pBsafePubKey, pbData, *pdwDataLen,
                            pTmpKey->pbParams, pTmpKey->cbParams, dwFlags,
                            pbOutput))
            {
                goto Ret;
            }

            *pdwDataLen = dwLen;
            memcpy(pbData, pbOutput, *pdwDataLen);

            break;

        default:
            if (!SymEncrypt(pTmpKey, Final, pbData, pdwDataLen, dwBufSize))
            {
                goto Ret;
            }
    }

#ifndef STRONG
    if (pbData != NULL && *pdwDataLen >= DE_BLOCKLEN)
    {
        memcpy(dbDEncrypt, pbData, DE_BLOCKLEN);
        fDEncrypt = TRUE;
    }
    else
    {
        fDEncrypt = FALSE;
    }
#endif  // STRONG

    fRet = TRUE;
Ret:
    if (pbOutput)
        _nt_free(pbOutput, dwLen);

    return fRet;
}

/*
 -      CPEncrypt
 -
 *      Purpose:
 *                Encrypt data
 *
 *
 *      Parameters:
 *               IN  hUID          -  Handle to the CSP user
 *               IN  hKey          -  Handle to the key
 *               IN  hHash         -  Optional handle to a hash
 *               IN  Final         -  Boolean indicating if this is the final
 *                                    block of plaintext
 *               IN  dwFlags       -  Flags values
 *               IN OUT pbData     -  Data to be encrypted
 *               IN OUT pdwDataLen -  Pointer to the length of the data to be
 *                                    encrypted
 *               IN dwBufLen       -  Size of Data buffer
 *
 *      Returns:
 */

BOOL CPEncrypt(IN HCRYPTPROV hUID,
               IN HCRYPTKEY hKey,
               IN HCRYPTHASH hHash,
               IN BOOL Final,
               IN DWORD dwFlags,
               IN OUT BYTE *pbData,
               IN OUT DWORD *pdwDataLen,
               IN DWORD dwBufSize)
{
    BOOL    fRet;

#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputEncrypt(TRUE, FALSE, hUID, hKey, hHash, Final,
                          dwFlags, pbData, pdwDataLen, dwBufSize);
#endif // DBG -- NOTE:  This section not compiled for retail builds

    fRet = LocalEncrypt(hUID, hKey, hHash, Final, dwFlags,
                        pbData, pdwDataLen, dwBufSize, TRUE);

#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputEncrypt(FALSE, fRet, 0, 0, 0, FALSE, 0, NULL, NULL, 0);
#endif // DBG -- NOTE:  This section not compiled for retail builds

    return fRet;
}

/*
 -      SymDecrypt
 -
 *      Purpose:
 *                Decrypt data with symmetric algorithms.  This function is used
 *                by the LocalDecrypt function as well as the UnWrapSymKey (nt_key.c)
 *                function.
 *
 *      Parameters:
 *               IN  pKey          -  Handle to the key
 *               IN  pHash         -  Handle to a hash if needed
 *               IN  fFinal        -  Boolean indicating if this is the final
 *                                    block of plaintext
 *               IN OUT pbData     -  Data to be decrypted
 *               IN OUT pcbData    -  Pointer to the length of the data to be
 *                                    decrypted
 *
 *      Returns:
 */

BOOL SymDecrypt(
                IN PNTAGKeyList pKey,
                IN PNTAGHashList pHash,
                IN BOOL fFinal,
                IN OUT BYTE *pbData,
                IN OUT DWORD *pcbData
                )
{
    MACstate    *pMAC;
    BOOL        fRet = FALSE;

    // determine which algorithm is to be used
    switch (pKey->Algid)
    {
#ifdef CSP_USE_RC2
        // the decryption is to be done with the RC2 algorithm
        case CALG_RC2:

            if (BlockDecrypt(RC2, pKey, RC2_BLOCKLEN, fFinal, pbData,
                             pcbData) == NTF_FAILED)
            {
                goto Ret;
            }

            if ((fFinal) && (NULL != pHash) && (pHash->Algid == CALG_MAC) &&
                (pKey->Mode == CRYPT_MODE_CBC))
            {
                pMAC = (MACstate *)pHash->pHashData;
                memcpy(pMAC->Feedback, pKey->FeedBack, RC2_BLOCKLEN);
                pHash->dwHashState |= DATA_IN_HASH;
            }

            break;
#endif

#ifdef CSP_USE_DES
        // the decryption is to be done with DES
        case CALG_DES:
            if (BlockDecrypt(des, pKey, DES_BLOCKLEN, fFinal, pbData,
                             pcbData) == NTF_FAILED)
            {
                goto Ret;
            }

            if ((fFinal) && (NULL != pHash) &&  (pHash->Algid == CALG_MAC) &&
                (pKey->Mode == CRYPT_MODE_CBC))
            {
                pMAC = (MACstate *)pHash->pHashData;
                memcpy(pMAC->Feedback, pKey->FeedBack, RC2_BLOCKLEN);
                pHash->dwHashState |= DATA_IN_HASH;
            }
            break;
#endif

#ifdef CSP_USE_3DES
        // the decryption is to be done with the triple DES
        case CALG_3DES_112:
        case CALG_3DES:
            if (BlockDecrypt(tripledes, pKey, DES_BLOCKLEN, fFinal, pbData,
                             pcbData) == NTF_FAILED)
            {
                goto Ret;
            }

            if ((fFinal) && (NULL != pHash) &&  (pHash->Algid == CALG_MAC) &&
                (pKey->Mode == CRYPT_MODE_CBC))
            {
                pMAC = (MACstate *)pHash->pHashData;
                memcpy(pMAC->Feedback, pKey->FeedBack, RC2_BLOCKLEN);
                pHash->dwHashState |= DATA_IN_HASH;
            }
            break;
#endif

#ifdef CSP_USE_RC4
        case CALG_RC4:
            rc4((struct RC4_KEYSTRUCT *)pKey->pData, *pcbData, pbData);
            if (fFinal)
            {
                _nt_free (pKey->pData, pKey->cbDataLen);
                pKey->pData = 0;
                pKey->cbDataLen = 0;
            }

            break;
#endif

        default:
            SetLastError((DWORD) NTE_BAD_ALGID);
            goto Ret;
            break;
    }

    fRet = TRUE;
Ret:
    return fRet;
}

/*
 -      LocalDecrypt
 -
 *      Purpose:
 *                Decrypt data
 *
 *
 *      Parameters:
 *               IN  hUID          -  Handle to the CSP user
 *               IN  hKey          -  Handle to the key
 *               IN  hHash         -  Optional handle to a hash
 *               IN  Final         -  Boolean indicating if this is the final
 *                                    block of ciphertext
 *               IN  dwFlags       -  Flags values
 *               IN OUT pbData     -  Data to be decrypted
 *               IN OUT pdwDataLen -  Pointer to the length of the data to be
 *                                    decrypted
 *               IN fIsExternal    -  Flag to tell if the call is for internal 
 *                                    CSP use or external caller
 *
 *      Returns:
 */
BOOL LocalDecrypt(IN HCRYPTPROV hUID,
                  IN HCRYPTKEY hKey,
                  IN HCRYPTHASH hHash,
                  IN BOOL Final,
                  IN DWORD dwFlags,
                  IN OUT BYTE *pbData,
                  IN OUT DWORD *pdwDataLen,
                  IN BOOL fIsExternal)
{
    PNTAGUserList       pTmpUser;
    PNTAGKeyList        pTmpKey;
    PNTAGHashList       pTmpHash = NULL;
    DWORD               dwLen;
    BSAFE_PRV_KEY       *pBsafePrvKey = NULL;
    DWORD               cbBsafePrvKey = 0;
    BYTE                *pbNewData = NULL;
    DWORD               cbNewData;
    BOOL                fMachineKeyset = FALSE;
    BOOL                fRet = FALSE;

    if ((dwFlags != 0) && (0x9C580000 != dwFlags))
    {
        SetLastError((DWORD) NTE_BAD_FLAGS);
        goto Ret;
    }

    // We're done if decrypting 0 bytes.
    if (*pdwDataLen == 0)
    {
        if (Final == TRUE)
        {
            SetLastError((DWORD) NTE_BAD_LEN);
            goto Ret;
        }
        fRet = TRUE;
        goto Ret;
    }

    if ((pTmpUser = (PNTAGUserList) NTLCheckList (hUID, USER_HANDLE)) == NULL)
    {
        SetLastError((DWORD) NTE_BAD_UID);
        goto Ret;
    }

    //
    // Check if decryption allowed
    //
    if (fIsExternal &&
        (PROV_RSA_SCHANNEL != pTmpUser->dwProvType) &&
        ((pTmpUser->Rights & CRYPT_DISABLE_CRYPT) == CRYPT_DISABLE_CRYPT))
    {
        SetLastError((DWORD) NTE_PERM);
        goto Ret;
    }

    // Check the key against the user.
    if (NULL == (pTmpKey = (PNTAGKeyList) NTLValidate(hKey, hUID, KEY_HANDLE)))
    {
        if (NULL == (pTmpKey = (PNTAGKeyList) NTLValidate(hKey, hUID, EXCHPUBKEY_HANDLE)))
        {
            // NTLValidate doesn't know what error to set
            // so it set NTE_FAIL -- fix it up.
            if (GetLastError() == NTE_FAIL)
                SetLastError((DWORD) NTE_BAD_KEY);

            goto Ret;
        }
    }

#ifndef STRONG
    if (fDDecrypt)
    {
        if (memcmp(dbDDecrypt, pbData, DE_BLOCKLEN) == 0)
        {
            SetLastError((DWORD) NTE_DOUBLE_ENCRYPT);
            goto Ret;
        }
    }
#endif // STRONG

    if ((pTmpKey->Algid != CALG_RSA_KEYX) &&
        (!FIsLegalKey(pTmpUser, pTmpKey, TRUE)))
    {
        SetLastError((DWORD) NTE_BAD_KEY);
        goto Ret;
    }

    // Check if we should do an auto-inflate
    if ((pTmpKey->pData == NULL) && (pTmpKey->Algid != CALG_RSA_KEYX))
    {
        if (NTAG_FAILED(CPInflateKey(pTmpKey)))
        {
            goto Ret;
        }
    }

    // Check if we need to hash before encryption
    if (hHash != 0)
    {
        if ((pTmpHash = (PNTAGHashList)NTLValidate(hHash, hUID,
                                                   HASH_HANDLE)) == NULL)
        {
            SetLastError((DWORD) NTE_BAD_HASH);
            goto Ret;
        }

    }
    
    // determine which algorithm is to be used
    switch (pTmpKey->Algid)
    {
        case CALG_RSA_KEYX:
#ifndef STRONG
            if (!RSAEncryptionAllowed(pTmpUser, dwFlags))
            {
                SetLastError((DWORD) NTE_BAD_KEY);
                goto Ret;
            }
#endif // STRONG

            // check if the public key matches the private key
            if (pTmpUser->ContInfo.pbExchPub == NULL)
            {
                SetLastError((DWORD) NTE_NO_KEY);
                goto Ret;
            }

            if ((pTmpUser->ContInfo.ContLens.cbExchPub != pTmpKey->cbKeyLen)||
                memcmp(pTmpUser->ContInfo.pbExchPub, pTmpKey->pKeyValue,
                       pTmpUser->ContInfo.ContLens.cbExchPub))
            {
                SetLastError((DWORD) NTE_BAD_KEY);
                goto Ret;
            }

            // if using protected store then load the key now
            if (!UnprotectPrivKey(pTmpUser, g_Strings.pwszImportSimple,
                                  FALSE, FALSE))
            {
                SetLastError((DWORD) NTE_BAD_KEYSET);
                goto Ret;
            }
            pBsafePrvKey = (BSAFE_PRV_KEY *)pTmpUser->pExchPrivKey;

            if (NULL == pBsafePrvKey)
            {
                SetLastError((DWORD) NTE_NO_KEY);
                goto Ret;
            }

            //; perform the RSA decryption
            if (!RSADecrypt(pTmpUser, pBsafePrvKey, pbData, *pdwDataLen,
                            pTmpKey->pbParams, pTmpKey->cbParams,
                            dwFlags, &pbNewData, &cbNewData))
            {
                goto Ret;
            }

            *pdwDataLen = cbNewData;
            memcpy(pbData, pbNewData, *pdwDataLen);
            break;

        default:
            if (!SymDecrypt(pTmpKey, pTmpHash, Final, pbData, pdwDataLen))
            {
                goto Ret;
            }
    }

    if (hHash != 0)
    {
        if (pTmpHash->Algid != CALG_MAC)
        {
            if (!CPHashData(hUID, hHash, pbData, *pdwDataLen, 0))
            {
                goto Ret;
            }
        }
    }

#ifndef STRONG
    if (*pdwDataLen >= DE_BLOCKLEN)
    {
        memcpy(dbDDecrypt, pbData, DE_BLOCKLEN);
        fDDecrypt = TRUE;
    }
    else
    {
        fDDecrypt = FALSE;
    }
#endif // STRONG

    fRet = TRUE;
Ret:
    if (pbNewData)
        _nt_free(pbNewData, cbNewData);
    
    return fRet;
}

/*
 -      CPDecrypt
 -
 *      Purpose:
 *                Decrypt data
 *
 *
 *      Parameters:
 *               IN  hUID          -  Handle to the CSP user
 *               IN  hKey          -  Handle to the key
 *               IN  hHash         -  Optional handle to a hash
 *               IN  Final         -  Boolean indicating if this is the final
 *                                    block of ciphertext
 *               IN  dwFlags       -  Flags values
 *               IN OUT pbData     -  Data to be decrypted
 *               IN OUT pdwDataLen -  Pointer to the length of the data to be
 *                                    decrypted
 *
 *      Returns:
 */
BOOL CPDecrypt(IN HCRYPTPROV hUID,
               IN HCRYPTKEY hKey,
               IN HCRYPTHASH hHash,
               IN BOOL Final,
               IN DWORD dwFlags,
               IN OUT BYTE *pbData,
               IN OUT DWORD *pdwDataLen)
{
    BOOL    fRet;

#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputDecrypt(TRUE, FALSE, hUID, hKey, hHash, Final,
                          dwFlags, pbData, pdwDataLen);
#endif // DBG -- NOTE:  This section not compiled for retail builds

    fRet = LocalDecrypt(hUID, hKey, hHash, Final,
                        dwFlags, pbData, pdwDataLen, TRUE);

#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputDecrypt(FALSE, fRet, 0, 0, 0, FALSE, 0, NULL, NULL);
#endif // DBG -- NOTE:  This section not compiled for retail builds

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\rsabase\nt_sign.c ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : nt_sign.c                                              //
//  DESCRIPTION   : Crypto CP interfaces:                                  //
//                  CPSignHash                                             //
//                  CPVerifySignature                                      //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Jan 25 1995 larrys  Changed from Nametag                           //
//      Feb 23 1995 larrys  Changed NTag_SetLastError to SetLastError      //
//      Mar 23 1995 larrys  Added variable key length                      //
//      May 10 1995 larrys  added private api calls                        //
//      Aug 03 1995 larrys  Fix for bug 10                                 //
//      Aug 22 1995 larrys  Added descriptions to sign and verify hash     //
//      Aug 30 1995 larrys  Changed Algid to dwKeySpec                     //
//      Aug 30 1995 larrys  Removed RETURNASHVALUE from CryptGetHashValue  //
//      Aug 31 1995 larrys  Fixed CryptSignHash for pbSignature == NULL    //
//      Aug 31 1995 larrys  Fix for Bug 28                                 //
//      Sep 12 1995 Jeffspel/ramas  Merged STT onto SCP                    //
//      Sep 12 1995 Jeffspel/ramas  BUGS FIXED PKCS#1 Padding.             //
//      Sep 18 1995 larrys  Removed flag fro CryptSignHash                 //
//      Oct 13 1995 larrys  Changed GetHashValue to GetHashParam           //
//      Oct 23 1995 larrys  Added MD2                                      //
//      Oct 25 1995 larrys  Change length of sDescription string           //
//      Nov 10 1995 DBarlow Bug #61                                        //
//      Dec 11 1995 larrys  Added error return check                       //
//      May 15 1996 larrys  Changed NTE_NO_MEMORY to ERROR_NOT_ENOUGHT...  //
//      May 29 1996 larrys  Bug 101                                        //
//      Jun  6 1996 a-johnb Added support for SSL 3.0 signatures           //
//      May 23 1997 jeffspel Added provider type checking                  //
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

//#include <wtypes.h>
#include "precomp.h"
#include "ntagum.h"
#include "nt_rsa.h"
#include "protstor.h"
#include "swnt_pk.h"

extern HINSTANCE hInstance;
extern CSP_STRINGS g_Strings;

//
// Reverse ASN.1 Encodings of possible hash identifiers.  The leading byte is the length
// of the byte string.
//

static const BYTE
#ifdef CSP_USE_MD2
    *md2Encodings[]
            //      1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18
        = {
            "\x12\x10\x04\x00\x05\x02\x02\x0d\xf7\x86\x48\x86\x2a\x08\x06\x0c\x30\x20\x30",
            "\x10\x10\x04\x02\x02\x0d\xf7\x86\x48\x86\x2a\x08\x06\x0a\x30\x1e\x30",
            "\x00" },
#endif
#ifdef CSP_USE_MD4
    *md4Encodings[]
        = {
            "\x12\x10\x04\x00\x05\x04\x02\x0d\xf7\x86\x48\x86\x2a\x08\x06\x0c\x30\x20\x30",
            "\x10\x10\x04\x04\x02\x0d\xf7\x86\x48\x86\x2a\x08\x06\x0a\x30\x1e\x30",
            "\x00" },
#endif
#ifdef CSP_USE_MD5
    *md5Encodings[]
        = {
            "\x12\x10\x04\x00\x05\x05\x02\x0d\xf7\x86\x48\x86\x2a\x08\x06\x0c\x30\x20\x30",
            "\x10\x10\x04\x05\x02\x0d\xf7\x86\x48\x86\x2a\x08\x06\x0a\x30\x1e\x30",
            "\x00" },
#endif
#ifdef CSP_USE_SHA
    *shaEncodings[]
        = {
            //      1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18
            "\x0f\x14\x04\x00\x05\x1a\x02\x03\x0e\x2b\x05\x06\x09\x30\x21\x30",
            "\x0d\x14\x04\x1a\x02\x03\x0e\x2b\x05\x06\x07\x30\x1f\x30",
            "\x00" },
#endif
    *endEncodings[]
        = { "\x00" };

/*
 -      ApplyPKCS1SigningFormat
 -
 *      Purpose:
 *                Format a buffer with PKCS 1 for signing
 *
 */
BOOL ApplyPKCS1SigningFormat(IN  BSAFE_PUB_KEY *pPubKey,
                             IN  ALG_ID HashAlgid,
                             IN  BYTE *pbHash,
                             IN  DWORD cbHash,
                             IN  DWORD dwFlags,
                             OUT BYTE *pbPKCS1Format)
{
    BYTE    *pbStart;
    BYTE    *pbEnd;
    BYTE    bTmp;
    DWORD   i;
    BOOL    fRet = FALSE;

    // insert the block type
    pbPKCS1Format[pPubKey->datalen - 1] = 0x01;

    // insert the type I padding
    memset(pbPKCS1Format, 0xff, pPubKey->datalen-1);

    // Reverse it
    for (i = 0; i < cbHash; i++)
    {
        pbPKCS1Format[i] = pbHash[cbHash - (i + 1)];
    }

    if (!(CRYPT_NOHASHOID && dwFlags))
    {
        switch (HashAlgid)
        {
#ifdef CSP_USE_MD2
            case CALG_MD2:
            {
                // PKCS delimit the hash value
                pbEnd = (LPBYTE)md2Encodings[0];
                pbStart = pbPKCS1Format + cbHash;
                bTmp = *pbEnd++;
                while (0 < bTmp--)
                    *pbStart++ = *pbEnd++;
                *pbStart++ = 0;
                break;
            }

#endif

#ifdef CSP_USE_MD4
            case CALG_MD4:
            {
                // PKCS delimit the hash value
                pbEnd = (LPBYTE)md4Encodings[0];
                pbStart = pbPKCS1Format + cbHash;
                bTmp = *pbEnd++;
                while (0 < bTmp--)
                    *pbStart++ = *pbEnd++;
                *pbStart++ = 0;
                break;
            }
#endif

#ifdef CSP_USE_MD5
            case CALG_MD5:
            {
                // PKCS delimit the hash value
                pbEnd = (LPBYTE)md5Encodings[0];
                pbStart = pbPKCS1Format + cbHash;
                bTmp = *pbEnd++;
                while (0 < bTmp--)
                    *pbStart++ = *pbEnd++;
                *pbStart++ = 0;
                break;
            }

#endif

#ifdef CSP_USE_SHA
            case CALG_SHA:
            {
                // PKCS delimit the hash value
                pbEnd = (LPBYTE)shaEncodings[0];
                pbStart = pbPKCS1Format + cbHash;
                bTmp = *pbEnd++;
                while (0 < bTmp--)
                    *pbStart++ = *pbEnd++;
                *pbStart++ = 0;
                break;
            }
#endif

#ifdef CSP_USE_SSL3SHAMD5
            case CALG_SSL3_SHAMD5:
                // Don't put in any PKCS crud
                pbStart = pbPKCS1Format + cbHash;
                *pbStart++ = 0;
                break;
#endif

            default:
                SetLastError((DWORD) NTE_BAD_ALGID);
                goto Ret;
        }
    }
    else
    {
        pbPKCS1Format[cbHash] = 0x00;
    }

    fRet = TRUE;
Ret:
    return fRet;
}

/*
 -      ApplyX931SigningFormat
 -
 *      Purpose:
 *                Format a buffer with X.9.31 for signing, assumes
 *                the buffer to be formatted is at least the length
 *                of the signature (cbSig).
 *
 */
void ApplyX931SigningFormat(IN  DWORD cbSig,
                            IN  BYTE *pbHash,
                            IN  DWORD cbHash,
                            IN  BOOL fDataInHash,
                            OUT BYTE *pbFormatted)
{
    DWORD   i;

    // insert P3
    pbFormatted[0] = 0xcc;
    pbFormatted[1] = 0x33;

    // Reverse it
    for (i = 0; i < cbHash; i++)
    {
        pbFormatted[i + 2] = pbHash[cbHash - (i + 1)];
    }
    pbFormatted[22] = 0xba;

    // insert P2
    memset(pbFormatted + 23, 0xbb, cbSig - 24);

    // insert P1
    if (fDataInHash)
    {
        pbFormatted[cbSig - 1] = 0x6b;
    }
    else
    {
        pbFormatted[cbSig - 1] = 0x4b;
    }
}

/*
 -      CPSignHash
 -
 *      Purpose:
 *                Create a digital signature from a hash
 *
 *
 *      Parameters:
 *               IN  hUID         -  Handle to the user identifcation
 *               IN  hHash        -  Handle to hash object
 *               IN  dwKeySpec    -  Key pair that is used to sign with
 *                                   algorithm to be used
 *               IN  sDescription -  Description of data to be signed
 *               IN  dwFlags      -  Flags values
 *               OUT pbSignture   -  Pointer to signature data
 *               OUT dwHashLen    -  Pointer to the len of the signature data
 *
 *      Returns:
 */
BOOL CPSignHash(IN  HCRYPTPROV hUID,
                IN  HCRYPTHASH hHash,
                IN  DWORD dwKeySpec,
                IN  LPCWSTR sDescription,
                IN  DWORD dwFlags,
                OUT BYTE *pbSignature,
                OUT DWORD *pdwSigLen)
{
    PNTAGUserList           pTmpUser = NULL;
    PNTAGHashList           pTmpHash;
    BSAFE_PRV_KEY           *pPrivKey = NULL;
    DWORD                   cbPrivKey = 0;
    MD2_object              *pMD2Hash;
    MD4_object              *pMD4Hash;
    MD5_object              *pMD5Hash;
    A_SHA_CTX               *pSHAHash;
    BYTE                    rgbTmpHash[SSL3_SHAMD5_LEN];
    DWORD                   cbTmpHash = SSL3_SHAMD5_LEN;
    BYTE                    *pbInput = NULL;
    BYTE                    *pbSigT = NULL;
    LPBYTE                  pbStart, pbEnd;
    DWORD                   cbSigLen;
    BYTE                    bTmp;
    BOOL                    fSigKey;
    BSAFE_PUB_KEY           *pPubKey;
    LPWSTR                  szPrompt;
    BOOL                    fDataInHash = FALSE;
    BOOL                    fRet = NTF_FAILED;

#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputSignHash(TRUE, FALSE, hUID, hHash, dwKeySpec, sDescription,
                           dwFlags, pbSignature, pdwSigLen);
#endif // DBG -- NOTE:  This section not compiled for retail builds

    if ((dwFlags & ~(CRYPT_NOHASHOID | CRYPT_X931_FORMAT)) != 0)
    {
        SetLastError((DWORD) NTE_BAD_FLAGS);
        goto Ret;
    }

    if ((pTmpUser = (PNTAGUserList) NTLCheckList (hUID, USER_HANDLE)) == NULL)
    {
        SetLastError((DWORD) NTE_BAD_UID);
        goto Ret;
    }

    // get the user's public key
    if (dwKeySpec == AT_KEYEXCHANGE)
    {
        fSigKey = FALSE;
        pPubKey = (BSAFE_PUB_KEY *)pTmpUser->ContInfo.pbExchPub;
        szPrompt = g_Strings.pwszSignWExch;
    }
    else if (dwKeySpec == AT_SIGNATURE)
    {
        if (PROV_RSA_SCHANNEL == pTmpUser->dwProvType)
        {
            SetLastError((DWORD) NTE_BAD_ALGID);
            goto Ret;
        }

        fSigKey = TRUE;
        pPubKey = (BSAFE_PUB_KEY *)pTmpUser->ContInfo.pbSigPub;
        szPrompt = g_Strings.pwszSigning;
    }
    else
    {
        SetLastError((DWORD) NTE_BAD_ALGID);
        goto Ret;
    }

    // check to make sure the key exists
    if (NULL == pPubKey)
    {
        SetLastError((DWORD) NTE_BAD_KEYSET);
        goto Ret;
    }

    cbSigLen = (pPubKey->bitlen + 7) / 8;
    if (pbSignature == NULL || *pdwSigLen < cbSigLen)
    {
        *pdwSigLen = cbSigLen;
        if (pbSignature == NULL)
        {
            fRet = NTF_SUCCEED;
            goto Ret;
        }
        SetLastError(ERROR_MORE_DATA);
        goto Ret;
    }

    // check to see if the hash is in the hash list
    if ((pTmpHash = (PNTAGHashList)NTLValidate(hHash, hUID,
                                               HASH_HANDLE)) == NULL)
    {
        if (GetLastError() == NTF_FAILED)
            SetLastError((DWORD) NTE_BAD_HASH);
        goto Ret;
    }

    // zero the output buffer
    memset (pbSignature, 0, cbSigLen);

    switch (pTmpHash->Algid)
    {
#ifdef CSP_USE_MD2
        case CALG_MD2:
            pMD2Hash = (MD2_object *)pTmpHash->pHashData;
            break;

#endif

#ifdef CSP_USE_MD4
        case CALG_MD4:
            pMD4Hash = (MD4_object *)pTmpHash->pHashData;
            break;
#endif

#ifdef CSP_USE_MD5
        case CALG_MD5:
            pMD5Hash = (MD5_object *)pTmpHash->pHashData;
            break;

#endif

#ifdef CSP_USE_SHA
        case CALG_SHA:
        {
            pSHAHash = (A_SHA_CTX *)pTmpHash->pHashData;
            break;
        }
#endif

#ifdef CSP_USE_SSL3SHAMD5
        case CALG_SSL3_SHAMD5:

            // Hash value must have already been set.
            if ((pTmpHash->HashFlags & HF_VALUE_SET) == 0)
            {
                SetLastError((DWORD) NTE_BAD_HASH_STATE);
                goto Ret;
            }
            break;
#endif

        default:
            SetLastError((DWORD) NTE_BAD_ALGID);
            goto Ret;
    }

    // WARNING :due to vulnerabilities sDescription field is should NO longer be used
    if (sDescription != NULL)
    {
        if (!CPHashData(hUID, hHash, (CHAR *) sDescription,
                        lstrlenW(sDescription) * sizeof(WCHAR), 0))
        {
            SetLastError((DWORD) NTE_BAD_HASH);
            goto Ret;
        }
    }

    // check if this is a NULL hash (no data hashed) for X.9.31 format
    if (pTmpHash->dwHashState & DATA_IN_HASH)
    {
        fDataInHash = TRUE;
    }

    // now copy the hash into the input buffer
    cbTmpHash = pPubKey->keylen;
    if (!CPGetHashParam(hUID, hHash, HP_HASHVAL, rgbTmpHash, &cbTmpHash, 0))
        goto Ret;

    if ((pbInput = (BYTE *)_nt_malloc(pPubKey->keylen)) == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Ret;
    }

    // use X.9.31 padding for FIPS certification
    if (dwFlags & CRYPT_X931_FORMAT)
    {
        if (pTmpHash->Algid != CALG_SHA1)
        {
            SetLastError((DWORD) NTE_BAD_ALGID);
            goto Ret;
        }

        ApplyX931SigningFormat(cbSigLen,
                               rgbTmpHash,
                               cbTmpHash,
                               fDataInHash,
                               pbInput);
    }
    // use PKCS #1 padding
    else
    {
        if (!ApplyPKCS1SigningFormat(pPubKey,
                                     pTmpHash->Algid,
                                     rgbTmpHash,
                                     cbTmpHash,
                                     dwFlags,
                                     pbInput))
        {
            // last error set
            goto Ret;
        }
    }

    // encrypt the hash value in input
    if (NULL == (pbSigT = (BYTE *)_nt_malloc(pPubKey->keylen)))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Ret;
    }

    // load the appropriate key if necessary
    if (!UnprotectPrivKey(pTmpUser, szPrompt, fSigKey, FALSE))
    {
        SetLastError((DWORD) NTE_BAD_KEYSET);
        goto Ret;
    }

    // get the user's private key
    if (fSigKey)
        pPrivKey = (BSAFE_PRV_KEY *)pTmpUser->pSigPrivKey;
    else
        pPrivKey = (BSAFE_PRV_KEY *)pTmpUser->pExchPrivKey;

    if (pPrivKey == NULL)
    {
        SetLastError((DWORD) NTE_NO_KEY);
        goto Ret;
    }

    if (pPubKey->keylen != pPrivKey->keylen)
    {
        SetLastError((DWORD) NTE_BAD_KEYSET);
        goto Ret;
    }

    RSAPrivateDecrypt(pTmpUser->pOffloadInfo, pPrivKey, pbInput, pbSigT);

    memcpy(pbSignature, pbSigT, cbSigLen);

    *pdwSigLen = cbSigLen;

    fRet = NTF_SUCCEED;
Ret:
#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputSignHash(FALSE, fRet, 0, 0, 0, NULL, 0, NULL, NULL);
#endif // DBG -- NOTE:  This section not compiled for retail builds

    if (pbSigT)
        _nt_free (pbSigT, pPubKey->keylen);
    if (pbInput)
        _nt_free(pbInput, pPubKey->keylen);

    return fRet;
}


/*
 -      VerifyPKCS1SigningFormat
 -
 *      Purpose:
 *                Check the format on a buffer to make sure the PKCS 1
 *                formatting is correct.
 *
 */
BOOL VerifyPKCS1SigningFormat(IN  BSAFE_PUB_KEY *pKey,
                              IN  PNTAGHashList pTmpHash,
                              IN  BYTE *pbHash,
                              IN  DWORD cbHash,
                              IN  DWORD dwFlags,
                              OUT BYTE *pbPKCS1Format)
{
    MD2_object      *pMD2Hash;
    MD4_object      *pMD4Hash;
    MD5_object      *pMD5Hash;
    A_SHA_CTX       *pSHAHash;
    BYTE            *pbTmp;
    const BYTE      **rgEncOptions;
    BYTE            rgbTmpHash[SSL3_SHAMD5_LEN];
    DWORD           i;
    DWORD           cb;
    BYTE            *pbStart;
    DWORD           cbTmp;
    BOOL            fRet = FALSE;

    switch(pTmpHash->Algid)
    {

#ifdef CSP_USE_MD2

        case CALG_MD2:
            pMD2Hash = (MD2_object *)pTmpHash->pHashData;
            pbTmp = (BYTE *) &(pMD2Hash->MD);
            rgEncOptions = md2Encodings;
            break;

#endif

#ifdef CSP_USE_MD4

        case CALG_MD4:
            pMD4Hash = (MD4_object *)pTmpHash->pHashData;
            pbTmp = (BYTE *) &(pMD4Hash->MD);
            rgEncOptions = md4Encodings;
            break;

#endif

#ifdef CSP_USE_MD5
        case CALG_MD5:
            pMD5Hash = (MD5_object *)pTmpHash->pHashData;
            pbTmp = (BYTE *)pMD5Hash->digest;
            rgEncOptions = md5Encodings;
            break;

#endif

#ifdef CSP_USE_SHA
        case CALG_SHA:
            pSHAHash = (A_SHA_CTX *)pTmpHash->pHashData;
            pbTmp = (BYTE *)pSHAHash->HashVal;
            rgEncOptions = shaEncodings;
            break;

#endif

#ifdef CSP_USE_SSL3SHAMD5
        case CALG_SSL3_SHAMD5:

            // Hash value must have already been set.
            if ((pTmpHash->HashFlags & HF_VALUE_SET) == 0)
            {
                SetLastError((DWORD) NTE_BAD_HASH);
                goto Ret;
            }
            pbTmp = pTmpHash->pHashData;
            rgEncOptions = NULL;

            break;
#endif

        default:
            SetLastError((DWORD) NTE_BAD_HASH);
            goto Ret;
    }

    // Reverse the hash to match the signature.
    for (i = 0; i < cbHash; i++)
    {
        rgbTmpHash[i] = pbHash[cbHash - (i + 1)];
    }

    // See if it matches.
    if (memcmp (rgbTmpHash, pbPKCS1Format, cbHash))
    {
        SetLastError((DWORD) NTE_BAD_SIGNATURE);
        goto Ret;
    }

    cb = cbHash;
    if (!(CRYPT_NOHASHOID & dwFlags))
    {
        // Check for any signature type identifiers
        if(rgEncOptions != NULL) {
            for (i = 0; 0 != *rgEncOptions[i]; i += 1)
            {
                pbStart = (LPBYTE)rgEncOptions[i];
                cbTmp = *pbStart++;
                if (0 == memcmp(&pbPKCS1Format[cb], pbStart, cbTmp))
                {
                    cb += cbTmp;   // Adjust the end of the hash data.
                    break;
                }
            }
        }
    }

    // check to make sure the rest of the PKCS #1 padding is correct
    if ((0x00 != pbPKCS1Format[cb]) || (0x00 != pbPKCS1Format[pKey->datalen]) ||
         (0x1 != pbPKCS1Format[pKey->datalen - 1]))
    {
        SetLastError((DWORD) NTE_BAD_SIGNATURE);
        goto Ret;
    }

    for (i = cb + 1; i < (DWORD)pKey->datalen - 1; i++)
    {
        if (0xff != pbPKCS1Format[i])
        {
            SetLastError((DWORD) NTE_BAD_SIGNATURE);
            goto Ret;
        }
    }

    fRet = TRUE;
Ret:
    return fRet;
}

/*
 -      VerifyX931SigningFormat
 -
 *      Purpose:
 *                Check the format on a buffer to make sure the X.9.31
 *                formatting is correct.
 *
 */
BOOL VerifyX931SigningFormat(IN  BYTE *pbHash,
                             IN  DWORD cbHash,
                             IN  BOOL fDataInHash,
                             IN  BYTE *pbFormatted,
                             IN  DWORD cbFormatted)
{
    BYTE    rgbTmpHash[SSL3_SHAMD5_LEN];
    DWORD   i;
    BOOL    fRet = FALSE;

    // check P3
    if ((0xcc != pbFormatted[0]) || (0x33 != pbFormatted[1]) ||
        (0xba != pbFormatted[cbHash + 2]))
    {
        SetLastError((DWORD) NTE_BAD_SIGNATURE);
        goto Ret;
    }

    // Reverse the hash to match the signature and check if it matches.
    for (i = 0; i < cbHash; i++)
    {
        rgbTmpHash[i] = pbHash[cbHash - (i + 1)];
    }

    if (0 != memcmp(rgbTmpHash, pbFormatted + 2, cbHash))
    {
        SetLastError((DWORD) NTE_BAD_SIGNATURE);
        goto Ret;
    }

    // check P2
    for (i = 23; i < (cbFormatted - 24); i++)
    {
        if (0xbb != pbFormatted[i])
        {
            SetLastError((DWORD) NTE_BAD_SIGNATURE);
            goto Ret;
        }
    }

    // check P1
    if (fDataInHash)
    {
        if (0x6b != pbFormatted[cbFormatted - 1])
        {
            SetLastError((DWORD) NTE_BAD_SIGNATURE);
            goto Ret;
        }
    }
    else
    {
        if (0x4b != pbFormatted[cbFormatted - 1])
        {
            SetLastError((DWORD) NTE_BAD_SIGNATURE);
            goto Ret;
        }
    }

    fRet = TRUE;
Ret:
    return fRet;
}

/*
 -      CPVerifySignature
 -
 *      Purpose:
 *                Used to verify a signature against a hash object
 *
 *
 *      Parameters:
 *               IN  hUID         -  Handle to the user identifcation
 *               IN  hHash        -  Handle to hash object
 *               IN  pbSignture   -  Pointer to signature data
 *               IN  dwSigLen     -  Length of the signature data
 *               IN  hPubKey      -  Handle to the public key for verifying
 *                                   the signature
 *               IN  Algid        -  Algorithm identifier of the signature
 *                                   algorithm to be used
 *               IN  sDescription -  String describing the signed data
 *               IN  dwFlags      -  Flags values
 *
 *      Returns:
 */
BOOL CPVerifySignature(IN HCRYPTPROV hUID,
                       IN HCRYPTHASH hHash,
                       IN CONST BYTE *pbSignature,
                       IN DWORD dwSigLen,
                       IN HCRYPTKEY hPubKey,
                       IN LPCWSTR sDescription,
                       IN DWORD dwFlags)
{
    PNTAGUserList           pTmpUser;
    PNTAGHashList           pTmpHash;
    PNTAGKeyList            pPubKey;
    BSAFE_PUB_KEY           *pKey;
    BYTE                    *pOutput = NULL;
    BSAFE_PUB_KEY           *pBsafePubKey;
    BYTE                    *pbSigT = NULL;
    BYTE                    *pbStart;
    BYTE                    *pbEnd;
    int                     i;
    BYTE                    rgbTmpHash[SSL3_SHAMD5_LEN];
    DWORD                   cbTmpHash = SSL3_SHAMD5_LEN;
    BYTE                    bTmp;
    DWORD                   cbLocalSigLen;
    BOOL                    fDataInHash = FALSE;
    BOOL                    fRet = NTF_FAILED;

#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputVerifySignature(TRUE, FALSE, hUID, hHash, (BYTE*)pbSignature,
                                  dwSigLen, hPubKey, sDescription, dwFlags);
#endif // DBG -- NOTE:  This section not compiled for retail builds

    if ((dwFlags & ~(CRYPT_NOHASHOID | CRYPT_X931_FORMAT)) != 0)
    {
        SetLastError((DWORD) NTE_BAD_FLAGS);
        goto Ret;
    }

    // check the user identification
    if ((pTmpUser = (PNTAGUserList) NTLCheckList (hUID, USER_HANDLE)) == NULL)
    {
        SetLastError((DWORD) NTE_BAD_UID);
        goto Ret;
    }

    // check to see if the hash is in the hash list
    if ((pTmpHash = (PNTAGHashList) NTLValidate(hHash, hUID,
                                                HASH_HANDLE)) == NULL)
    {
        // NTLValidate doesn't know what error to set
        // so it set NTE_FAIL -- fix it up.
        if (GetLastError() == NTE_FAIL)
            SetLastError((DWORD) NTE_BAD_HASH);

        goto Ret;
    }

    if ((CALG_MD2 != pTmpHash->Algid) &&
        (CALG_MD4 != pTmpHash->Algid) &&
        (CALG_MD5 != pTmpHash->Algid) &&
        (CALG_SHA != pTmpHash->Algid) &&
        (CALG_SSL3_SHAMD5 != pTmpHash->Algid))
    {
        SetLastError((DWORD) NTE_BAD_HASH);
        goto Ret;
    }

    switch(HNTAG_TO_HTYPE((HNTAG)hPubKey))
    {
        case SIGPUBKEY_HANDLE:
        case EXCHPUBKEY_HANDLE:
            if ((pPubKey = (PNTAGKeyList) NTLValidate((HNTAG)hPubKey,
                              hUID, HNTAG_TO_HTYPE((HNTAG)hPubKey))) == NULL)
            {
                // NTLValidate doesn't know what error to set
                // so it set NTE_FAIL -- fix it up.
                if (GetLastError() == NTE_FAIL)
                    SetLastError((DWORD) NTE_BAD_KEY);

                goto Ret;
            }
            break;

        default:
            SetLastError((DWORD) NTE_BAD_KEY);
            goto Ret;
    }


    pKey = (BSAFE_PUB_KEY *)pPubKey->pKeyValue;
    pBsafePubKey = (BSAFE_PUB_KEY *) pKey;
    cbLocalSigLen = (pBsafePubKey->bitlen+7)/8;

    if (dwSigLen != cbLocalSigLen)
    {
        SetLastError((DWORD) NTE_BAD_SIGNATURE);
        goto Ret;
    }

    if ((pOutput = (BYTE *)_nt_malloc(pBsafePubKey->keylen)) == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Ret;
    }

    // encrypt the hash value in output
    if (NULL == (pbSigT = (BYTE *)_nt_malloc(pBsafePubKey->keylen)))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Ret;
    }
    memset(pbSigT, 0, pBsafePubKey->keylen);
    memcpy(pbSigT, pbSignature, cbLocalSigLen);
    if (0 != RSAPublicEncrypt(pTmpUser->pOffloadInfo, pBsafePubKey, pbSigT, pOutput))
    {
        SetLastError((DWORD) NTE_BAD_SIGNATURE);
        goto Ret;
    }

    // WARNING : due to vulnerabilities sDescription field is should NO longer be used
    if (sDescription != NULL)
    {
        if (!CPHashData(hUID, hHash, (CHAR *) sDescription,
                        lstrlenW(sDescription) * sizeof(WCHAR), 0))
        {
            goto Ret;
        }
    }

    // check if this is a NULL hash (no data hashed) for X.9.31 format
    if (pTmpHash->dwHashState & DATA_IN_HASH)
    {
        fDataInHash = TRUE;
    }

    if (!CPGetHashParam(hUID, hHash, HP_HASHVAL, rgbTmpHash, &cbTmpHash, 0))
    {
        goto Ret;
    }

    // use X.9.31 padding for FIPS certification
    if (dwFlags & CRYPT_X931_FORMAT)
    {
        if (!VerifyX931SigningFormat(rgbTmpHash,
                                     cbTmpHash,
                                     fDataInHash,
                                     pOutput,
                                     (pBsafePubKey->bitlen + 7) / 8))
        {
            goto Ret;
        }
    }
    // use PKCS #1 padding
    else
    {
        if (!VerifyPKCS1SigningFormat(pKey,
                                      pTmpHash,
                                      rgbTmpHash,
                                      cbTmpHash,
                                      dwFlags,
                                      pOutput))
        {
            goto Ret;
        }
    }

    fRet = NTF_SUCCEED;
Ret:
#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputVerifySignature(FALSE, fRet, 0, 0, NULL, 0, 0, NULL, 0);
#endif // DBG -- NOTE:  This section not compiled for retail builds

    if (pbSigT)
        _nt_free(pbSigT, pBsafePubKey->keylen);
    if (pOutput)
        _nt_free(pOutput, pBsafePubKey->keylen);

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\rsabase\precomp.h ===
#include "xapip.h"
#include "winbasep.h"

//#undef UNICODE					// ## Not Yet
//#include <windows.h>
//#include <windef.h>
//#include <malloc.h>
//#include <string.h>
//#include <time.h>
#include <wtypes.h>
#include <winuser.h>

typedef ULONG REGSAM;
#define MAX_COMPUTERNAME_LENGTH 15

#include "scp.h"
#include "nt_rsa.h"
#include "contman.h"
#include "ntagimp1.h"
#include "manage.h"

#pragma	hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\rsabase\nt_hash.c ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : nt_hash.c                                              //
//  DESCRIPTION   : Crypto CP interfaces:                                  //
//                  CPBeginHash                                            //
//                  CPUpdateHash                                           //
//                  CPDestroyHash                                          //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Jan 25 1995 larrys  Changed from Nametag                           //
//      Feb 23 1995 larrys  Changed NTag_SetLastError to SetLastError      //
//      May  8 1995 larrys  Changes for MAC hashing                        //
//      May 10 1995 larrys  added private api calls                        //
//      Jul 13 1995 larrys  Changed MAC stuff                              //
//      Aug 07 1995 larrys  Added Auto-Inflate to CryptBeginHash           //
//      Aug 30 1995 larrys  Removed RETURNASHVALUE from CryptGetHashValue  //
//      Sep 19 1995 larrys  changed USERDATA to CRYPT_USERDATA             //
//      Oct 03 1995 larrys  check for 0 on Createhash for hKey             //
//      Oct 05 1995 larrys  Changed HashSessionKey to hash key material    //
//      Oct 13 1995 larrys  Removed CPGetHashValue                         //
//      Oct 17 1995 larrys  Added MD2                                      //
//      Nov  3 1995 larrys  Merge for NT checkin                           //
//      Nov 14 1995 larrys  Fixed memory leak                              //
//      Mar 01 1996 rajeshk Added check for Hash Values                    //
//      May 15 1996 larrys  Changed NTE_NO_MEMORY to ERROR_NOT_ENOUGHT...  //
//      Jun  6 1996 a-johnb Added support for SSL 3.0 signatures           //
//      Apr 25 1997 jeffspel Fix for Bug 76393, GPF on pbData = NULL       //
//      May 23 1997 jeffspel Added provider type checking                  //
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "nt_rsa.h"
#include "tripldes.h"
#include "mac.h"
#include "ssl3.h"

BOOL FIsLegalKey(
                 PNTAGUserList pTmpUser,
                 PNTAGKeyList pKey,
                 BOOL fRC2BigKeyOK
                 );

BOOL CPInflateKey(
                  IN PNTAGKeyList pTmpKey
                  );

BOOL BlockEncrypt(void EncFun(BYTE *In, BYTE *Out, void *key, int op),
                  PNTAGKeyList pKey,
                  int BlockLen,
                  BOOL Final,
                  BYTE  *pbData,
                  DWORD *pdwDataLen,
                  DWORD dwBufLen);

#ifdef CSP_USE_MD5
//
// Function : TestMD5
//
// Description : This function hashes the passed in message with the MD5 hash
//               algorithm and returns the resulting hash value.
//
BOOL TestMD5(
             BYTE *pbMsg,
             DWORD cbMsg,
             BYTE *pbHash
             )
{
    MD5_CTX	MD5;
    BOOL    fRet = FALSE;

    // Check length for input data
    if (0 == cbMsg)
    {
        goto Ret;
    }

    // Initialize MD5
    MD5Init(&MD5);

    // Compute MD5 
    MD5Update(&MD5, pbMsg, cbMsg);

    MD5Final(&MD5);
    memcpy(pbHash, MD5.digest, MD5DIGESTLEN);

    fRet = TRUE;
Ret:
    return fRet;
}
#endif // CSP_USE_MD5

#ifdef CSP_USE_SHA1
//
// Function : TestSHA1
//
// Description : This function hashes the passed in message with the SHA1 hash
//               algorithm and returns the resulting hash value.
//
BOOL TestSHA1(
              BYTE *pbMsg,
              DWORD cbMsg,
              BYTE *pbHash
              )
{
    A_SHA_CTX	HashContext;
    BOOL        fRet = FALSE;

    // Check length for input data
    if (0 == cbMsg)
    {
        goto Ret;
    }

    // Initialize SHA
    A_SHAInit(&HashContext);

    // Compute SHA 
    A_SHAUpdate(&HashContext, pbMsg, cbMsg);

    A_SHAFinal(&HashContext, pbHash);

    fRet = TRUE;
Ret:
    return fRet;
}
#endif // CSP_USE_SHA1

BOOL ValidHashAlgid(
                    PNTAGUserList pTmpUser,
                    ALG_ID Algid
                    )
{
    if ((PROV_RSA_SCHANNEL == pTmpUser->dwProvType) &&
        ((CALG_MD2 == Algid) || (CALG_MD4 == Algid)))
        return FALSE;
    else
        return TRUE;
}

// local function for creating hashes
BOOL LocalCreateHash(
                     IN ALG_ID Algid,
                     OUT BYTE **ppbHashData,
                     OUT DWORD *pcbHashData
                     )
{
    BOOL    fRet = FALSE;

    switch (Algid)
    {
#ifdef CSP_USE_MD2
        case CALG_MD2:
        {
            MD2_object      *pMD2Hash;

            *pcbHashData = sizeof(MD2_object);

            if (NULL == (pMD2Hash = (MD2_object *)_nt_malloc(*pcbHashData)))
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }

            memset ((BYTE *)pMD2Hash, 0, sizeof(MD2_object));

            *ppbHashData = (BYTE*)pMD2Hash;

            // Set up the Initial MD2 Hash State
            pMD2Hash->FinishFlag = FALSE;
        
            break;
        }
#endif

#ifdef CSP_USE_MD4
        case CALG_MD4:
        {
            MD4_object      *pMD4Hash;

            *pcbHashData = sizeof(MD4_object);

            if (NULL == (pMD4Hash = (MD4_object *)_nt_malloc(*pcbHashData)))
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }

            memset ((BYTE *)pMD4Hash, 0, sizeof(MD4_object));

            // Set up our State
            *ppbHashData = (BYTE*)pMD4Hash;
            
            // Set up the Initial MD4 Hash State
            pMD4Hash->FinishFlag = FALSE;
            MDbegin(&pMD4Hash->MD);

            break;
        }
#endif

#ifdef CSP_USE_MD5
        case CALG_MD5:
        {
            MD5_object      *pMD5Hash;

            *pcbHashData = sizeof(MD5_object);

            if (NULL == (pMD5Hash = (MD5_object *)_nt_malloc(*pcbHashData)))
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }

            // Set up the our state
            *ppbHashData = (BYTE*)pMD5Hash;

            pMD5Hash->FinishFlag = FALSE;

            // call the code to actually begin an MD5 hash
            MD5Init(pMD5Hash);

            break;
        }
#endif

#ifdef CSP_USE_SHA
        case CALG_SHA:
        {
            A_SHA_CTX       *pSHAHash;

            *pcbHashData = sizeof(A_SHA_CTX);
                
            if (NULL == (pSHAHash = (A_SHA_CTX *)_nt_malloc(*pcbHashData)))
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }

            // Set up our state
            *ppbHashData = (BYTE*)pSHAHash;
            
            A_SHAInit(pSHAHash);
            pSHAHash->FinishFlag = FALSE;

            break;
        }
#endif

        default:
            SetLastError((DWORD) NTE_BAD_ALGID);
            goto Ret;
    }

    fRet = TRUE;
Ret:
    return fRet;
}

/*
 -  CPBeginHash
 -
 *  Purpose:
 *                initate the hashing of a stream of data
 *
 *
 *  Parameters:
 *               IN  hUID    -  Handle to the user identifcation
 *               IN  Algid   -  Algorithm identifier of the hash algorithm
 *                              to be used
 *               IN  hKey    -  Optional key for MAC algorithms
 *               IN  dwFlags -  Flags values
 *               OUT pHash   -  Handle to hash object
 *
 *  Returns:
 */
BOOL CPCreateHash(IN HCRYPTPROV hUID,
                  IN ALG_ID Algid,
                  IN HCRYPTKEY hKey,
                  IN DWORD dwFlags,
                  OUT HCRYPTHASH *phHash)
{
    PNTAGUserList   pTmpUser;
    PNTAGHashList   pCurrentHash = NULL;
    PNTAGKeyList    pTmpKey;
    WORD            count = 0;
//#ifdef CSP_USE_SSL3
    PSCH_HASH       pSChHash;
//#endif // CSP_USE_SSL3
    BOOL            fRet = NTF_FAILED;

#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputCreateHash(TRUE, FALSE, hUID, Algid, hKey, dwFlags, phHash);
#endif // DBG -- NOTE:  This section not compiled for retail builds

    if (dwFlags != 0)
    {
        SetLastError((DWORD) NTE_BAD_FLAGS);
        goto Ret;
    }

    // check if the user handle is valid
    if (NULL == (pTmpUser = NTLCheckList (hUID, USER_HANDLE)))
    {
        goto Ret;
    }

    if (!ValidHashAlgid(pTmpUser, Algid))
    {
        SetLastError((DWORD)NTE_BAD_ALGID);
        goto Ret;
    }

    // Prepare the structure to be used as the hash handle
    if (NULL == (pCurrentHash =
                  (PNTAGHashList) _nt_malloc(sizeof(NTAGHashList))))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Ret;
    }

    memset(pCurrentHash, 0, sizeof(NTAGHashList));
    pCurrentHash->Algid = Algid;
    pCurrentHash->hUID = hUID;

    // determine which hash algorithm is to be used
    switch (Algid)
    {
#ifdef CSP_USE_MAC

        case CALG_MAC:
        {
            MACstate        *pMACVal;

            if (hKey == 0)
            {
                SetLastError((DWORD) NTE_BAD_KEY);
                goto Ret;
            }

            if ((pTmpKey = (PNTAGKeyList) NTLValidate(hKey, hUID,
                                                      KEY_HANDLE)) == NULL)
            {
                if (GetLastError() == NTE_FAIL)
                {
                    SetLastError((DWORD) NTE_BAD_KEY);
                }
                goto Ret;
            }

            if (pTmpKey->Mode != CRYPT_MODE_CBC)
            {
                SetLastError((DWORD) NTE_BAD_KEY);
                goto Ret;
            }

            // Check if we should do an auto-inflate
            if (pTmpKey->pData == NULL)
            {
                if (NTAG_FAILED(CPInflateKey(pTmpKey)))
                {
                    goto Ret;
                }
            }

            if ((pMACVal = (MACstate *)_nt_malloc(sizeof(MACstate)))==NULL)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }

            pCurrentHash->pHashData = pMACVal;
            pCurrentHash->dwDataLen = sizeof(MACstate);
            pMACVal->dwBufLen = 0;
            pMACVal->hKey = hKey;
            pMACVal->FinishFlag = FALSE;

            break;
        }
#endif

        case CALG_HMAC:
        {
            if (hKey == 0)
            {
                SetLastError(NTE_BAD_KEY);
                goto Ret;
            }

            if ((pTmpKey = (PNTAGKeyList) NTLValidate(hKey, hUID,
                                                      KEY_HANDLE)) == NULL)
            {
                SetLastError((DWORD) NTE_BAD_KEY);
                goto Ret;
            }

            pCurrentHash->hKey = hKey;
            break;
        }

#ifdef CSP_USE_SSL3SHAMD5
        case CALG_SSL3_SHAMD5:
        {
       
            if ((pCurrentHash->pHashData = _nt_malloc(SSL3_SHAMD5_LEN)) == NULL)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }

            pCurrentHash->dwDataLen = SSL3_SHAMD5_LEN;

            break;
        }
#endif

#ifdef CSP_USE_SSL3
        case CALG_SCHANNEL_MASTER_HASH:
        {

            if (0 == hKey)
            {
                SetLastError((DWORD) NTE_BAD_KEY);
                goto Ret;
            }

            if (NULL == (pTmpKey = (PNTAGKeyList) NTLValidate(hKey, hUID, KEY_HANDLE)))
            {
                if (GetLastError() == NTE_FAIL)
                    SetLastError((DWORD) NTE_BAD_KEY);
                goto Ret;
            }

            if ((CALG_SSL3_MASTER != pTmpKey->Algid) &&
                (CALG_PCT1_MASTER != pTmpKey->Algid) &&
                (pTmpKey->cbKeyLen > MAX_PREMASTER_LEN))
            {
                SetLastError((DWORD) NTE_BAD_KEY);
                goto Ret;
            }

            pCurrentHash->dwDataLen = sizeof(SCH_HASH);
            if (NULL == (pCurrentHash->pHashData = (BYTE *)_nt_malloc(pCurrentHash->dwDataLen)))
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }
            memset(pCurrentHash->pHashData, 0, pCurrentHash->dwDataLen);
            pSChHash = (PSCH_HASH)pCurrentHash->pHashData;

            pSChHash->ProtocolAlgid = pTmpKey->Algid;

            if (!SChGenMasterKey(pTmpKey, pSChHash))
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }

            break;
        }

        case CALG_TLS1PRF:
        {
            PRF_HASH    *pPRFHash;
            PSCH_KEY    pSChKey;

            if (0 == hKey)
            {
                SetLastError((DWORD) NTE_BAD_KEY);
                goto Ret;
            }

            if (NULL == (pTmpKey = (PNTAGKeyList) NTLValidate(hKey, hUID, KEY_HANDLE)))
            {
                if (GetLastError() == NTE_FAIL)
                    SetLastError((DWORD) NTE_BAD_KEY);
                goto Ret;
            }

            if (CALG_TLS1_MASTER != pTmpKey->Algid)
            {
                SetLastError((DWORD) NTE_BAD_KEY);
                goto Ret;
            }
            // check if the master key is finished
            pSChKey = (PSCH_KEY)pTmpKey->pData;
            if ((!pSChKey->fFinished) || (TLS_MASTER_LEN != pTmpKey->cbKeyLen))
            {
                SetLastError((DWORD) NTE_BAD_KEY_STATE);
                goto Ret;
            }

            pCurrentHash->dwDataLen = sizeof(PRF_HASH);
            if (NULL == (pCurrentHash->pHashData = (BYTE *)_nt_malloc(pCurrentHash->dwDataLen)))
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }
            memset(pCurrentHash->pHashData, 0, pCurrentHash->dwDataLen);
            pPRFHash = (PRF_HASH*)pCurrentHash->pHashData;

            memcpy(pPRFHash->rgbMasterKey, pTmpKey->pKeyValue, TLS_MASTER_LEN);
            break;
        }
#endif // CSP_USE_SSL3

        default:
            if (hKey != 0)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                goto Ret;
            }

            if (!LocalCreateHash(Algid, (BYTE**)&pCurrentHash->pHashData,
                                 &pCurrentHash->dwDataLen))
            {
                goto Ret;
            }
    }
  
    if (NTLMakeItem(phHash, HASH_HANDLE, pCurrentHash) == NTF_FAILED)
    {
        goto Ret;          // error already set
    }

    fRet = NTF_SUCCEED;
Ret:
#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputCreateHash(FALSE, fRet, 0, 0, 0, 0, phHash);
#endif // DBG -- NOTE:  This section not compiled for retail builds

    if ((NTF_FAILED == fRet) && pCurrentHash)
    {
        if (pCurrentHash->pHashData)
            _nt_free(pCurrentHash->pHashData, pCurrentHash->dwDataLen);
        _nt_free(pCurrentHash, sizeof(NTAGHashList));
    }

    return fRet;
}

BOOL LocalHashData(
                   IN ALG_ID Algid,
                   IN OUT BYTE *pbHashData,
                   IN BYTE *pbData,
                   IN DWORD cbData
                   )
{
    BYTE    *ptmp;
    DWORD   BytePos;
    BOOL    fRet = FALSE;

    switch(Algid)
    {
#ifdef CSP_USE_MD2
        case CALG_MD2:
        {
            MD2_object      *pMD2Hash;

            // make sure the hash is updatable
            pMD2Hash = (MD2_object *)pbHashData;
            if (pMD2Hash->FinishFlag == TRUE)
            {
                SetLastError((DWORD) NTE_BAD_HASH_STATE);
                goto Ret;
            }

            if (0 != MD2Update(&pMD2Hash->MD, pbData, cbData))
            {
                SetLastError((DWORD)NTE_FAIL);
                goto Ret;
            }

	        break;
        }
#endif

#ifdef CSP_USE_MD4
        case CALG_MD4:
        {
            MD4_object      *pMD4Hash;

            pMD4Hash = (MD4_object *)pbHashData;

            // make sure the hash is updatable
            if (pMD4Hash->FinishFlag == TRUE)
            {
                SetLastError((DWORD)NTE_BAD_HASH_STATE);
                goto Ret;
            }

            // MD4 hashes when the size == MD4BLOCKSIZE and finishes the
            // hash when the given size is < MD4BLOCKSIZE.
            // So, ensure that the user always gives a full block here --
            // when NTagFinishHash is called, we'll send the last bit and
            // that'll finish off the hash.

            ptmp = (BYTE *)pbData;
            for (;;)
            {
                // check if there's plenty of room in the buffer
                if (cbData < (MD4BLOCKSIZE - pMD4Hash->BufLen))
                {
                    // just append to whatever's already
                    memcpy(pMD4Hash->Buf + pMD4Hash->BufLen, ptmp, cbData);

                    // set of the trailing buffer length field
                    pMD4Hash->BufLen += (BYTE)cbData;
                    break;
                }

                // determine what we need to fill the buffer, then do it.
                BytePos = MD4BLOCKSIZE - pMD4Hash->BufLen;
                memcpy(pMD4Hash->Buf + pMD4Hash->BufLen, ptmp, BytePos);

                // The buffer is now full, process it.
                
                if (MD4_SUCCESS != MDupdate(&pMD4Hash->MD, pMD4Hash->Buf,
                                            MD4BYTESTOBITS(MD4BLOCKSIZE)))
                {
                    SetLastError((DWORD) NTE_FAIL);
                    goto Ret;
                }

                // now it's empty.
                pMD4Hash->BufLen = 0;

                // we processed some bytes, so reflect that and try again
                cbData -= BytePos;
                ptmp += BytePos;

                if (cbData == 0)
                {
                    break;
                }
            }
            break;
        }
#endif

#ifdef CSP_USE_MD5
        case CALG_MD5:
        {
            MD5_object      *pMD5Hash;

            // make sure the hash is updatable
            pMD5Hash = (MD5_object *)pbHashData;
            if (pMD5Hash->FinishFlag == TRUE)
            {
                SetLastError((DWORD) NTE_BAD_HASH_STATE);
                goto Ret;
            }
            MD5Update(pMD5Hash, pbData, cbData);

            break;
        }
#endif

#ifdef CSP_USE_SHA
        case CALG_SHA:
        {
            A_SHA_CTX   *pSHAHash;

            // make sure the hash is updatable
            pSHAHash = (A_SHA_CTX *)pbHashData;
            if (pSHAHash->FinishFlag == TRUE)
            {
                SetLastError((DWORD) NTE_BAD_HASH_STATE);
                goto Ret;
            }
            A_SHAUpdate(pSHAHash, pbData, cbData);

            break;
        }
#endif

        default:
            SetLastError((DWORD) NTE_BAD_ALGID);
            goto Ret;
    }

    fRet = TRUE;
Ret:
    return fRet;
}

BOOL LocalMACData(IN HCRYPTPROV hUID,
                  IN PNTAGHashList pTmpHash,
                  IN CONST BYTE *pbData,
                  IN DWORD cbData
                  )
{
    MACstate        *pMAC;
    PNTAGKeyList    pTmpKey;
    BYTE            *pbTmp;
    DWORD           dwTmpLen;
    BYTE            *pb = NULL;
    DWORD           cb;
    DWORD           i;
    BYTE            *pbJunk = NULL;
    DWORD           dwBufSlop;
    DWORD           dwEncLen;
    BOOL            fRet = FALSE;

    dwTmpLen = cbData;
    pbTmp = (BYTE *) pbData;

    switch(pTmpHash->Algid)
    {
#ifdef CSP_USE_MAC
        case CALG_MAC:
        {
            pMAC = (MACstate *)pTmpHash->pHashData;

            // make sure the hash is updatable
            if (pMAC->FinishFlag == TRUE)
            {
                SetLastError((DWORD) NTE_BAD_HASH_STATE);
                goto Ret;
            }

            if ((pTmpKey = (PNTAGKeyList) NTLValidate(pMAC->hKey, hUID,
                                                      KEY_HANDLE)) == NULL)
            {
                if (GetLastError() == NTE_FAIL)
                {
                    SetLastError((DWORD) NTE_BAD_KEY);
                }
                goto Ret;
            }

            if (pMAC->dwBufLen + dwTmpLen <= CRYPT_BLKLEN)
            {
                memcpy(pMAC->Buffer + pMAC->dwBufLen, pbTmp, dwTmpLen);
                pMAC->dwBufLen += dwTmpLen;
                fRet = NTF_SUCCEED;
                goto Ret;
            }

            memcpy(pMAC->Buffer+pMAC->dwBufLen, pbTmp,
                   (CRYPT_BLKLEN - pMAC->dwBufLen));

            dwTmpLen -= (CRYPT_BLKLEN - pMAC->dwBufLen);
            pbTmp += (CRYPT_BLKLEN - pMAC->dwBufLen);

            pMAC->dwBufLen = CRYPT_BLKLEN;

            switch (pTmpKey->Algid)
            {
                case CALG_RC2:
                    if (BlockEncrypt(RC2, pTmpKey, RC2_BLOCKLEN, FALSE,
                                     pMAC->Buffer,  &pMAC->dwBufLen,
                                     CRYPT_BLKLEN) == NTF_FAILED)
                    {
                        goto Ret;
                    }
                    break;

                case CALG_DES:
                    if (BlockEncrypt(des, pTmpKey, DES_BLOCKLEN, FALSE,
                                     pMAC->Buffer,  &pMAC->dwBufLen,
                                     CRYPT_BLKLEN) == NTF_FAILED)
                    {
                        goto Ret;
                    }
                    break;

#ifdef CSP_USE_3DES
                case CALG_3DES_112:
                case CALG_3DES:
                    if (BlockEncrypt(tripledes, pTmpKey, DES_BLOCKLEN,
                                     FALSE, pMAC->Buffer,  &pMAC->dwBufLen,
                                     CRYPT_BLKLEN) == NTF_FAILED)
                    {
                        goto Ret;
                    }
                    break;
#endif
            }

            pMAC->dwBufLen = 0;
        
            dwBufSlop = dwTmpLen % CRYPT_BLKLEN;
            if (dwBufSlop == 0)
            {
                dwBufSlop = CRYPT_BLKLEN;
            }

            if ((pbJunk = _nt_malloc(dwTmpLen)) == NULL)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }

            memcpy(pbJunk, pbTmp, dwTmpLen - dwBufSlop);

            dwEncLen = dwTmpLen - dwBufSlop;

            switch (pTmpKey->Algid)
            {
                case CALG_RC2:
                    if (BlockEncrypt(RC2, pTmpKey, RC2_BLOCKLEN, FALSE,
                                     pbJunk,  &dwEncLen,
                                     dwTmpLen) == NTF_FAILED)
                    {
                        goto Ret;
                    }
                    break;

                case CALG_DES:
                    if (BlockEncrypt(des, pTmpKey, DES_BLOCKLEN, FALSE,
                                     pbJunk,  &dwEncLen,
                                     dwTmpLen) == NTF_FAILED)
                    {
                        goto Ret;
                    }
                    break;

#ifdef CSP_USE_3DES
                case CALG_3DES_112:
                case CALG_3DES:
                    if (BlockEncrypt(tripledes, pTmpKey, DES_BLOCKLEN,
                                     FALSE, pbJunk,  &dwEncLen,
                                     dwTmpLen) == NTF_FAILED)
                    {
                        goto Ret;
                    }
                    break;
#endif
            }

            memcpy(pMAC->Buffer, pbTmp + dwEncLen, dwBufSlop);
            pMAC->dwBufLen = dwBufSlop;

            break;
        }
#endif

        case CALG_HMAC:
        {
            if (!(pTmpHash->HMACState & HMAC_STARTED))
            {
                if ((pTmpKey = (PNTAGKeyList) NTLValidate(pTmpHash->hKey, hUID,
                                                          KEY_HANDLE)) == NULL)
                {
                    if (GetLastError() == NTE_FAIL)
                    {
                        SetLastError((DWORD) NTE_BAD_KEY);
                    }
                    goto Ret;
                }

                if (pTmpKey->cbKeyLen < pTmpHash->cbHMACInner)
                    cb = pTmpHash->cbHMACInner;
                else
                    cb = pTmpKey->cbKeyLen;

                if (NULL == (pb = (BYTE *)_nt_malloc(cb)))
                {
                    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    goto Ret;
                }
                memcpy(pb, pTmpHash->pbHMACInner, pTmpHash->cbHMACInner);

                // currently no support for byte reversed keys with HMAC
                for(i=0;i<pTmpKey->cbKeyLen;i++)
                    pb[i] ^= (pTmpKey->pKeyValue)[i];

                if (!LocalHashData(pTmpHash->HMACAlgid, pTmpHash->pHashData, pb, cb))
                {
                    goto Ret;
                }

                pTmpHash->HMACState |= HMAC_STARTED;
            }

            if (!LocalHashData(pTmpHash->HMACAlgid, pTmpHash->pHashData,
                               (BYTE*)pbData, cbData))        
            {
                goto Ret;
            }

            break;
        }
    }

    fRet = TRUE;
Ret:
    if (pbJunk)
        _nt_free(pbJunk, dwTmpLen);
    if (pb)
         _nt_free(pb, cb);

    return fRet;
}

/*
 -  CPHashData
 -
 *  Purpose:
 *                Compute the cryptograghic hash on a stream of data
 *
 *
 *  Parameters:
 *               IN  hUID      -  Handle to the user identifcation
 *               IN  hHash     -  Handle to hash object
 *               IN  pbData    -  Pointer to data to be hashed
 *               IN  dwDataLen -  Length of the data to be hashed
 *               IN  dwFlags   -  Flags values
 *
 *  Returns:
 */
BOOL CPHashData(IN HCRYPTPROV hUID,
                IN HCRYPTHASH hHash,
                IN CONST BYTE *pbData,
                IN DWORD dwDataLen,
                IN DWORD dwFlags)
{
    PNTAGHashList               pTmpHash;
    PNTAGUserList               pUser;
    DWORD                       dwBufSlop;
    DWORD                       dwEncLen;
    BOOL                        fRet = NTF_FAILED;

#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputHashData(TRUE, FALSE, hUID, hHash, (BYTE*)pbData,
                           dwDataLen, dwFlags);
#endif // DBG -- NOTE:  This section not compiled for retail builds

    if (0 != (dwFlags & ~(CRYPT_USERDATA)))
    {
        SetLastError((DWORD) NTE_BAD_FLAGS);
        goto Ret;
    }

    if ((pUser = (PNTAGUserList) NTLCheckList(hUID, USER_HANDLE)) == NULL)
    {
        SetLastError((DWORD)NTE_BAD_UID);
        goto Ret;
    }

    if (0 == dwDataLen)
    {
        fRet = NTF_SUCCEED;
        goto Ret;
    }

    if (NULL == pbData)
    {
        SetLastError((DWORD)NTE_BAD_DATA);
        goto Ret;
    }

    if ((pTmpHash = (PNTAGHashList) NTLValidate(hHash, hUID,
                                                HASH_HANDLE)) == NULL)
    {
        // NTLValidate doesn't know what error to set
        // so it set NTE_FAIL -- fix it up.
        if (GetLastError() == NTE_FAIL)
            SetLastError((DWORD) NTE_BAD_HASH);
        
        goto Ret;
    }

    if (pTmpHash->HashFlags & HF_VALUE_SET)
    {
        SetLastError((DWORD) NTE_BAD_HASH_STATE);
        goto Ret;
    }

    switch (pTmpHash->Algid)
    {
#ifdef CSP_USE_MAC
        case CALG_MAC:
#endif // CSP_USE_MAC
        case CALG_HMAC:
            if (!LocalMACData(hUID, pTmpHash, pbData, dwDataLen))
            {
                goto Ret;
            }
            break;

/*
        {
            pMAC = (MACstate *)pTmpHash->pHashData;

            // make sure the hash is updatable
            if (pMAC->FinishFlag == TRUE)
            {
                SetLastError((DWORD) NTE_BAD_HASH_STATE);
                goto Ret;
            }

            if ((pTmpKey = (PNTAGKeyList) NTLValidate(pMAC->hKey, hUID,
                                                      KEY_HANDLE)) == NULL)
            {
                if (GetLastError() == NTE_FAIL)
                {
                    SetLastError((DWORD) NTE_BAD_KEY);
                }
                goto Ret;
            }

            if (pMAC->dwBufLen + dwTmpLen <= CRYPT_BLKLEN)
            {
                memcpy(pMAC->Buffer+pMAC->dwBufLen, pbTmp, dwTmpLen);
                pMAC->dwBufLen += dwTmpLen;
                fRet = NTF_SUCCEED;
                goto Ret;
            }

            memcpy(pMAC->Buffer+pMAC->dwBufLen, pbTmp,
                   (CRYPT_BLKLEN - pMAC->dwBufLen));

            dwTmpLen -= (CRYPT_BLKLEN - pMAC->dwBufLen);
            pbTmp += (CRYPT_BLKLEN - pMAC->dwBufLen);

            pMAC->dwBufLen = CRYPT_BLKLEN;

            switch (pTmpKey->Algid)
            {
                case CALG_RC2:
                    if (BlockEncrypt(RC2, pTmpKey, RC2_BLOCKLEN, FALSE,
                                     pMAC->Buffer,  &pMAC->dwBufLen,
                                     CRYPT_BLKLEN) == NTF_FAILED)
                    {
                        goto Ret;
                    }
                    break;

                case CALG_DES:
                    if (BlockEncrypt(des, pTmpKey, DES_BLOCKLEN, FALSE,
                                     pMAC->Buffer,  &pMAC->dwBufLen,
                                     CRYPT_BLKLEN) == NTF_FAILED)
                    {
                        goto Ret;
                    }
            }

            pMAC->dwBufLen = 0;
        
            dwBufSlop = dwTmpLen % CRYPT_BLKLEN;
            if (dwBufSlop == 0)
            {
                dwBufSlop = CRYPT_BLKLEN;
            }

            if ((pbJunk = _nt_malloc(dwTmpLen)) == NULL)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }

            memcpy(pbJunk, pbTmp, dwTmpLen - dwBufSlop);

            dwEncLen = dwTmpLen - dwBufSlop;

            switch (pTmpKey->Algid)
            {
                case CALG_RC2:
                    if (BlockEncrypt(RC2, pTmpKey, RC2_BLOCKLEN, FALSE,
                                     pbJunk,  &dwEncLen,
                                     dwTmpLen) == NTF_FAILED)
                    {
                        goto Ret;
                    }
                    break;

                case CALG_DES:
                    if (BlockEncrypt(des, pTmpKey, DES_BLOCKLEN, FALSE,
                                     pbJunk,  &dwEncLen,
                                     dwTmpLen) == NTF_FAILED)
                    {
                        goto Ret;
                    }
            }

        
            memcpy(pMAC->Buffer, pbTmp + dwEncLen, dwBufSlop);
            pMAC->dwBufLen = dwBufSlop;

            break;
        }
#endif

        case CALG_HMAC:
        {
            if (!(pTmpHash->HMACState & HMAC_STARTED))
            {
                if ((pTmpKey = (PNTAGKeyList) NTLValidate(pTmpHash->hKey, hUID,
                                                          KEY_HANDLE)) == NULL)
                {
                    if (GetLastError() == NTE_FAIL)
                    {
                        SetLastError((DWORD) NTE_BAD_KEY);
                    }
                    goto Ret;
                }

                if (pTmpKey->cbKeyLen < pTmpHash->cbHMACInner)
                    cb = pTmpHash->cbHMACInner;
                else
                    cb = pTmpKey->cbKeyLen;

                if (NULL == (pb = (BYTE *)_nt_malloc(cb)))
                {
                    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    goto Ret;
                }
                memcpy(pb, pTmpHash->pbHMACInner, pTmpHash->cbHMACInner);

                // currently no support for byte reversed keys with HMAC
                for(i=0;i<pTmpKey->cbKeyLen;i++)
                    pb[i] ^= (pTmpKey->pKeyValue)[i];

                if (!LocalHashData(pTmpHash->HMACAlgid, pTmpHash->pHashData, pb, cb))
                {
                    goto Ret;
                }

                pTmpHash->HMACState |= HMAC_STARTED;
            }

            if (!LocalHashData(pTmpHash->HMACAlgid, pTmpHash->pHashData,
                               (BYTE*)pbData, dwDataLen))        
            {
                goto Ret;
            }

            break;
        }
*/
        default:
            if (!LocalHashData(pTmpHash->Algid, pTmpHash->pHashData, (BYTE*)pbData, dwDataLen))
            {
                goto Ret;
            }
    }

    pTmpHash->dwHashState |= DATA_IN_HASH;

    fRet = NTF_SUCCEED;
Ret:
#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputHashData(FALSE, fRet, 0, 0, NULL, 0, 0);
#endif // DBG -- NOTE:  This section not compiled for retail builds
/*
    if (pbJunk)
        _nt_free(pbJunk, dwTmpLen);
    if (pb)
         _nt_free(pb, cb);
*/
    return fRet;
}

BOOL SetupKeyToBeHashed(
                        PNTAGHashList pHash,
                        PNTAGKeyList pKey,
                        BYTE **ppbData,
                        DWORD *pcbData,
                        DWORD dwFlags)
{
    DWORD   cb;
    DWORD   i;
    BOOL    fRet = FALSE;
    
    *ppbData = NULL;
    cb = pKey->cbKeyLen;

    if (NULL == (*ppbData = (BYTE *)_nt_malloc(cb)))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Ret;
    }

    if (CRYPT_LITTLE_ENDIAN & dwFlags)
    {
        memcpy(*ppbData, pKey->pKeyValue, cb);
    }
    else
    {
        // Reverse the session key bytes
        for (i = 0; i < cb; i++)
            (*ppbData)[i] = (pKey->pKeyValue)[cb - i - 1];
    }

    *pcbData = cb;

    fRet = TRUE;
Ret:
    return fRet;
}

/*
 -      CPHashSessionKey
 -
 *      Purpose:
 *                Compute the cryptograghic hash on a key object.
 *
 *
 *      Parameters:
 *               IN  hUID      -  Handle to the user identifcation
 *               IN  hHash     -  Handle to hash object
 *               IN  hKey      -  Handle to a key object
 *               IN  dwFlags   -  Flags values
 *
 *      Returns:
 *               CRYPT_FAILED
 *               CRYPT_SUCCEED
 */
BOOL CPHashSessionKey(IN HCRYPTPROV hUID,
                      IN HCRYPTHASH hHash,
                      IN HCRYPTKEY hKey,
                      IN DWORD dwFlags)
{
    PNTAGHashList       pTmpHash;
    PNTAGKeyList        pTmpKey;
    PNTAGUserList       pTmpUser;
    BSAFE_PUB_KEY       *pBsafePubKey;
    DWORD               dwDataLen;
    BYTE                *pbData = NULL;
    DWORD               BytePos;
    BOOL                f;
    BYTE                *pScratch;
    DWORD               z;
#ifdef CSP_USE_SSL3
    PSCH_KEY            pSChKey;
#endif // CSP_USE_SSL3
    BOOL                fRet = NTF_FAILED;

#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputHashSessionKey(TRUE, FALSE, hUID, hHash, hKey, dwFlags);
#endif // DBG -- NOTE:  This section not compiled for retail builds

    if (dwFlags & ~(CRYPT_LITTLE_ENDIAN))
    {
        SetLastError((DWORD) NTE_BAD_FLAGS);
        goto Ret;
    }

    // check the user identification
    if ((pTmpUser = (PNTAGUserList) NTLCheckList (hUID, USER_HANDLE)) == NULL)
    {
        SetLastError((DWORD) NTE_BAD_UID);
        goto Ret;
    }

    if ((pTmpHash = (PNTAGHashList) NTLValidate(hHash, hUID,
                                HASH_HANDLE)) == NULL)
    {
        if (GetLastError() == NTE_FAIL)
        {
            SetLastError((DWORD) NTE_BAD_HASH);
        }

        goto Ret;
    }

    if (pTmpHash->HashFlags & HF_VALUE_SET)
    {
        SetLastError((DWORD) NTE_BAD_HASH_STATE);
        goto Ret;
    }

    if ((pTmpKey = (PNTAGKeyList) NTLValidate((HNTAG)hKey, hUID, KEY_HANDLE))
                == NULL)
    {
        if (GetLastError() == NTE_FAIL)
        {
            SetLastError((DWORD) NTE_BAD_KEY);
        }

        goto Ret;
    }

    if (!FIsLegalKey(pTmpUser, pTmpKey, FALSE))
    {
        SetLastError((DWORD) NTE_BAD_KEY);
        goto Ret;
    }

#ifdef CSP_USE_SSL3
    if ((CALG_SSL3_MASTER == pTmpKey->Algid) ||
        (CALG_TLS1_MASTER == pTmpKey->Algid) ||
        (CALG_PCT1_MASTER == pTmpKey->Algid))
    {
        if (NULL == pTmpKey->pData)
        {
            SetLastError((DWORD)NTE_BAD_KEY);
            goto Ret;
        }
        pSChKey = (PSCH_KEY)pTmpKey->pData;
        if (FALSE == pSChKey->fFinished)
        {
            SetLastError((DWORD)NTE_BAD_KEY);
            goto Ret;
        }
    }
#endif // CSP_USE_SSL3

#if 0
    // Check if we should do an auto-inflate
    if (pTmpKey->pData == NULL)
    {
        if (NTAG_FAILED(CPInflateKey(pTmpKey)))
        {
            goto Ret;
        }
    }
#endif

#ifdef CSP_USE_DES
    if ((CALG_DES == pTmpKey->Algid) || (CALG_3DES == pTmpKey->Algid) ||
        (CALG_3DES_112 == pTmpKey->Algid))
    {
        if (PROV_RSA_SCHANNEL != pTmpUser->dwProvType)
        {
#ifdef STRONG
            if (pTmpUser->fNewStrongCSP ||
                (!(pTmpUser->Rights & CRYPT_DES_HASHKEY_BACKWARDS)))
#endif // STRONG
            {
                desparityonkey(pTmpKey->pKeyValue, pTmpKey->cbKeyLen);
            }
        }
    }
#endif

    if (!SetupKeyToBeHashed(pTmpHash, pTmpKey, &pbData, &dwDataLen, dwFlags))
        goto Ret;

    switch (pTmpHash->Algid)
    {
#ifdef CSP_USE_MD2
        case CALG_MD2:
        {
            MD2_object      *pMD2Hash;

            pMD2Hash = (MD2_object *) pTmpHash->pHashData;

            // make sure the hash is updatable
            if (pMD2Hash->FinishFlag == TRUE)
            {
                SetLastError((DWORD) NTE_BAD_HASH_STATE);
                goto Ret;
            }

            f = MD2Update(&pMD2Hash->MD, pbData, dwDataLen);

            if (f != 0)
            {
                SetLastError((DWORD) NTE_FAIL);
                goto Ret;
            }

            break;
        }
#endif

#ifdef CSP_USE_MD4
        case CALG_MD4:
        {
            MD4_object      *pMD4Hash;
                        
            pMD4Hash = (MD4_object *) pTmpHash->pHashData;

            // make sure the hash is updatable
            if (pMD4Hash->FinishFlag == TRUE)
            {
                SetLastError((DWORD) NTE_BAD_HASH_STATE);
                goto Ret;
            }

            for (;;)
            {
                // check if there's plenty of room in the buffer
                if ((pMD4Hash->BufLen + dwDataLen) < MD4BLOCKSIZE)
                {
                    // just append to whatever's already
                    memcpy (pMD4Hash->Buf + pMD4Hash->BufLen, pbData,
                            dwDataLen);

                    // set of the trailing buffer length field
                    pMD4Hash->BufLen += (BYTE) dwDataLen;

                    break;
                }

                // determine what we need to fill the buffer, then do it.
                BytePos = MD4BLOCKSIZE - pMD4Hash->BufLen;
                memcpy (pMD4Hash->Buf + pMD4Hash->BufLen, pbData, BytePos);

                // The buffer is now full, process it.
                f = MDupdate(&pMD4Hash->MD, pMD4Hash->Buf,
                             MD4BYTESTOBITS(MD4BLOCKSIZE));
                
                if (f != MD4_SUCCESS)
                {
                    SetLastError((DWORD) NTE_FAIL);
                    goto Ret;
                }

                // now it's empty.
                pMD4Hash->BufLen = 0;

                // we processed some bytes, so reflect that and try again
                dwDataLen -= BytePos;

                if (dwDataLen == 0)
                {
                    break;
                }
            }
            break;
        }
#endif

#ifdef CSP_USE_MD5
        case CALG_MD5:
        {
            MD5_object  *pMD5Hash;

            pMD5Hash = (MD5_object *) pTmpHash->pHashData;

            // make sure the hash is updatable
            if (pMD5Hash->FinishFlag == TRUE)
            {
                SetLastError((DWORD) NTE_BAD_HASH_STATE);
                goto Ret;
            }

            MD5Update(pMD5Hash, pbData, dwDataLen);

            break;
        }
#endif

#ifdef CSP_USE_SHA
        case CALG_SHA:
        {
            A_SHA_CTX   *pSHAHash;

            pSHAHash = (A_SHA_CTX *)pTmpHash->pHashData;

            // make sure the hash is updatable
            if (pSHAHash->FinishFlag == TRUE)
            {
                SetLastError((DWORD) NTE_BAD_HASH_STATE);
                goto Ret;
            }

            A_SHAUpdate(pSHAHash, (BYTE *) pbData, dwDataLen);

            break;
        }
#endif

#ifdef CSP_USE_MAC
        case CALG_MAC:
#endif // CSP_USE_MAC
        case CALG_HMAC:
            if (!LocalMACData(hUID, pTmpHash, pbData, dwDataLen))
            {
                goto Ret;
            }
            break;

        default:
            SetLastError((DWORD) NTE_BAD_ALGID);
            goto Ret;
    }

    pTmpHash->dwHashState |= DATA_IN_HASH;

    fRet = NTF_SUCCEED;
Ret:
#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputHashSessionKey(FALSE, fRet, 0, 0, 0, 0);
#endif // DBG -- NOTE:  This section not compiled for retail builds

    if (pbData)
        _nt_free(pbData, dwDataLen);

    return fRet;
}


void FreeHash(IN PNTAGHashList pHash)
{
    if (pHash)
    {
        if (pHash->pHashData)
            _nt_free(pHash->pHashData, pHash->dwDataLen);
        if (pHash->pbHMACInner)
            _nt_free(pHash->pbHMACInner, pHash->cbHMACInner);
        if (pHash->pbHMACOuter)
            _nt_free(pHash->pbHMACOuter, pHash->cbHMACOuter);
        _nt_free(pHash, sizeof(NTAGHashList));
    }
}

/*
-   CPDestroyHash
-
*   Purpose:
*                Destory the hash object
*
*
*   Parameters:
*               IN  hUID      -  Handle to the user identifcation
*               IN  hHash     -  Handle to hash object
*
*   Returns:
*/
BOOL CPDestroyHash(IN HCRYPTPROV hUID,
                   IN HCRYPTHASH hHash)
{
    PNTAGHashList   pTmpHash;
    BOOL            fRet = NTF_FAILED;

#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputDestroyHash(TRUE, FALSE, hUID, hHash);
#endif // DBG -- NOTE:  This section not compiled for retail builds

    // check the user identification
    if (NTLCheckList (hUID, USER_HANDLE) == NULL)
    {
        SetLastError((DWORD) NTE_BAD_UID);
        goto Ret;
    }

    if ((pTmpHash = (PNTAGHashList) NTLValidate(hHash, hUID,
                                                HASH_HANDLE)) == NULL)
    {
        // NTLValidate doesn't know what error to set
        // so it set NTE_FAIL -- fix it up.
        if (GetLastError() == NTE_FAIL)
        {
            SetLastError((DWORD) NTE_BAD_HASH);
        }
        goto Ret;
    }

    switch (pTmpHash->Algid)
    {

#ifdef CSP_USE_MD2
            
        case CALG_MD2:

#endif

#ifdef CSP_USE_MD4
            
        case CALG_MD4:

#endif

#ifdef CSP_USE_MD5

        case CALG_MD5:

#endif

#ifdef CSP_USE_SHA

        case CALG_SHA:

#endif

#ifdef CSP_USE_SSL3SHAMD5

        case CALG_SSL3_SHAMD5:

#endif

#ifdef CSP_USE_MAC

        case CALG_MAC:
        case CALG_HMAC:

#endif
               
#ifdef CSP_USE_SSL3
        case CALG_SCHANNEL_MASTER_HASH:
        case CALG_TLS1PRF:
#endif

            if (CALG_SCHANNEL_MASTER_HASH == pTmpHash->Algid)
            {
                FreeSChHash((PSCH_HASH)pTmpHash->pHashData);
            }
            memnuke(pTmpHash->pHashData, pTmpHash->dwDataLen);
            break;

        default:
            SetLastError((DWORD) NTE_BAD_ALGID);
            goto Ret;
    }

    // Remove from internal list first so others can't get to it, then free.
    NTLDelete(hHash);
    FreeHash(pTmpHash);

    fRet = NTF_SUCCEED;
Ret:
#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputDestroyHash(FALSE, fRet, 0, 0);
#endif // DBG -- NOTE:  This section not compiled for retail builds

    return fRet;

}

BOOL CopyHash(
              IN PNTAGHashList pOldHash,
              OUT PNTAGHashList *ppNewHash)
{
    PNTAGHashList   pNewHash;
    BOOL            fRet = FALSE;

    if (NULL == (pNewHash = (PNTAGHashList)_nt_malloc(sizeof(NTAGHashList))))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Ret;
    }

    memcpy(pNewHash, pOldHash, sizeof(NTAGHashList));
    pNewHash->dwDataLen = pOldHash->dwDataLen;
    if (pNewHash->dwDataLen)
    {
        if (NULL == (pNewHash->pHashData = (BYTE*)_nt_malloc(pNewHash->dwDataLen)))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }
    }

    memcpy(pNewHash->pHashData, pOldHash->pHashData, pNewHash->dwDataLen);

    *ppNewHash = pNewHash;

    fRet = TRUE;
Ret:
    if (FALSE == fRet)
        FreeHash(pNewHash);
    return fRet;
}

/*
 -  CPDuplicateHash
 -
 *  Purpose:
 *                Duplicates the state of a hash and returns a handle to it
 *
 *  Parameters:
 *               IN      hUID           -  Handle to a CSP
 *               IN      hHash          -  Handle to a hash
 *               IN      pdwReserved    -  Reserved
 *               IN      dwFlags        -  Flags
 *               IN      phHash         -  Handle to the new hash
 *
 *  Returns:
 */
BOOL CPDuplicateHash(IN HCRYPTPROV hUID,
                    IN HCRYPTHASH hHash,
                    IN DWORD *pdwReserved,
                    IN DWORD dwFlags,
                    IN HCRYPTHASH *phHash)
{
    PNTAGHashList   pTmpHash;
    PNTAGHashList   pNewHash = NULL;
    BOOL            fRet = NTF_FAILED;

#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputDuplicateHash(TRUE, FALSE, hUID, hHash, pdwReserved,
                                dwFlags, phHash);
#endif // DBG -- NOTE:  This section not compiled for retail builds

    if (NULL != pdwReserved)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    if (0 != dwFlags)
    {
        SetLastError((DWORD)NTE_BAD_FLAGS);
        goto Ret;
    }

    if (NULL == (pTmpHash = (PNTAGHashList)NTLValidate((HNTAG)hHash, hUID, HASH_HANDLE)))
    {
        SetLastError((DWORD)NTE_BAD_HASH);
        goto Ret;
    }

    if (!CopyHash(pTmpHash, &pNewHash))
        goto Ret;          // error already set

            
    if (NTF_FAILED == NTLMakeItem(phHash, HASH_HANDLE, (void *)pNewHash))
        goto Ret;          // error already set

    fRet = NTF_SUCCEED;
Ret:
#if DBG         // NOTE:  This section not compiled for retail builds
    CSPDebugOutputDuplicateHash(FALSE, fRet, 0, 0, NULL, 0, NULL);
#endif // DBG -- NOTE:  This section not compiled for retail builds

    if (NTF_FAILED == fRet)
        FreeHash(pNewHash);
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\rsabase\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rsabase.rc
//
#define IDS_NOSIG                       1
#define IDS_SIZEFILE                    2
#define IDS_MEMORY                      3
#define IDS_READFILE                    4
#define IDS_OPENREGISTRY                5
#define IDS_WRITEREGISTRY               6
#define IDS_OPENDLL                     7
#define IDS_SIZEDLL                     8
#define IDS_READDLL                     9
#define IDS_REINSTALL                   10
#define IDS_READREGISTRY                11
#define IDS_BADINSTALL                  12
#define IDS_NORES                       13
#define IDS_BADRES                      14
#define IDS_ALLOW_CHKBOX_TEXT           15
#define IDS_PASSWORD_PROMPT             18
#define IDS_CONFIRM_PASSWORD_PROMPT     19
#define IDS_OLD_PASSWORD_PROMPT         20
#define IDS_GENKEY_BOXTEXT              21
#define IDS_GENKEY_OW_BOXTEXT           22
#define IDS_IMPORT_PRIVATE_BOXTEXT      23
#define IDS_IMPORT_PRIVATE_OW_BOXTEXT   24
#define IDS_SIGN_BOXTEXT                25
#define IDS_EXPORT_PRIVATE_BOXTEXT      27
#define IDS_IMPORT_SIMPLE_BOXTEXT       28
#define IDS_CHANGEPASS_BOXTEXT          29
#define IDS_NEW_PASSWORD_TITLE          30
#define IDS_SOLICIT_PASSWORD_TITLE      31
#define IDS_OVERWRITE_PASSWORD_TITLE    32
#define IDS_AT_SIGNATURE                33
#define IDS_AT_KEYEXCHANGE              34
#define IDD_NEW_PASSWORD                101
#define IDD_SOLICIT_PASSWORD            102
#define IDD_OVERWRITE_PASSWORD          103
#define IDC_EDIT1                       1000
#define IDC_EDIT2                       1001
#define IDC_PASSWORD_STATICTEXT         1002
#define IDC_CONFIRM_PASSWORD_STATICTEXT 1003
#define IDC_EDIT3                       1005
#define IDC_OLD_PASSWORD_STATICTEXT     1006
#define IDC_CHECK_NOASK                 1007
#define IDC_BOXTEXT                     1008

// designated resource for in file signatures
#define CRYPT_SIG_RESOURCE_NUMBER   	666

// designated resource for in file signatures
#define CRYPT_MAC_RESOURCE_NUMBER   	667

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1008
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\rsabase\protstor.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : protstor.c                                             //
//  DESCRIPTION   : Code for storing keys in the protected store:          //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Dec  4 1996 jeffspel Created                                       //
//      Apr 21 1997 jeffspel  Changes for NT 5 tree                        //
//      Jul 28 1997 jeffspel Added ability to delete a persisted key       //
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "wincrypt.h"
#include "pstore.h"
#include "protstor.h"
#include "ntagum.h"


typedef HRESULT PSCREATEINST(
    IPStore **ppProvider,
    PST_PROVIDERID *pProviderID,
    void *pReserved,
    DWORD dwFlags);

#define CRYPTO_KEY_TYPE_STRING       L"Cryptographic Keys"
static GUID DefTypeGuid = {0x4d1fa410,
                    0x6fd9,
                    0x11d0,
                    {0x8C, 0x58, 0x00, 0xC0, 0x4F, 0xD9, 0x12, 0x6B}};

#define CRYPTO_SIG_SUBTYPE_STRING    L"RSA Signature Keys"
static GUID DefSigGuid = {0x4d1fa411,
                    0x6fd9,
                    0x11D0,
                    {0x8C, 0x58, 0x00, 0xC0, 0x4F, 0xD9, 0x12, 0x6B}};

#define CRYPTO_EXCH_SUBTYPE_STRING   L"RSA Exchange Keys"
static GUID DefExchGuid = {0x4d1fa412,
                    0x6fd9,
                    0x11D0,
                    {0x8C, 0x58, 0x00, 0xC0, 0x4F, 0xD9, 0x12, 0x6B}};

static GUID SysProv = MS_BASE_PSTPROVIDER_ID;

void FreePSInfo(
                PSTORE_INFO *pPStore
                )
{
    IPStore     *pIPS = (IPStore*)pPStore->pProv;

    if (pPStore)
    {
        if (pIPS)
            pIPS->Release();
#ifndef _XBOX
        if (pPStore->hInst)
            FreeLibrary(pPStore->hInst);
#endif
        if (pPStore->szPrompt)
            _nt_free(pPStore->szPrompt, pPStore->cbPrompt);
        _nt_free(pPStore, sizeof(PSTORE_INFO));
    }
}

BOOL CheckPStoreAvailability(
                             PSTORE_INFO *pPStore
                             )
{
#ifndef _XBOX
    PSCREATEINST    *pfnCreateInstProc = NULL;
    BOOL            fRet = FALSE;

    if (NULL == (pPStore->hInst = LoadLibrary("pstorec.dll")))
        goto Ret;


    if (0 == (pfnCreateInstProc =
              (PSCREATEINST*)GetProcAddress(pPStore->hInst,
                                            "PStoreCreateInstance")))
        goto Ret;

    if (S_OK != pfnCreateInstProc((IPStore**)(&pPStore->pProv),
                                   &SysProv, NULL, 0))
        goto Ret;

    memcpy(&pPStore->SigType, &DefTypeGuid, sizeof(GUID));
    memcpy(&pPStore->SigSubtype, &DefSigGuid, sizeof(GUID));
    memcpy(&pPStore->ExchType, &DefTypeGuid, sizeof(GUID));
    memcpy(&pPStore->ExchSubtype, &DefExchGuid, sizeof(GUID));

    fRet = TRUE;
Ret:
    return fRet;
#else
    ASSERT( !"CheckPStoreAvailability" );
    return FALSE;
#endif
}

BOOL CreateNewPSKeyset(
                       PSTORE_INFO *pPStore,
                       DWORD dwFlags
                       )
{
    PST_ACCESSCLAUSE    rgClauses[2];
    PST_ACCESSRULE      rgRules[2];
    PST_ACCESSRULESET   Rules;
    PST_TYPEINFO        Info;
    PST_PROMPTINFO      PromptInfo = {NULL, NULL};
    HRESULT             hr;
    IPStore             *pIPS = (IPStore*)pPStore->pProv;
    DWORD               dwRegLoc = PST_KEY_CURRENT_USER;
    BOOL                fRet = FALSE;

    if (dwFlags & CRYPT_MACHINE_KEYSET)
        dwRegLoc = PST_KEY_LOCAL_MACHINE;

    // if type is not available the create it
    memset(&Info, 0, sizeof(Info));
    Info.cbSize = sizeof(PST_TYPEINFO);
    Info.szDisplayName = CRYPTO_KEY_TYPE_STRING;
    if (S_OK != (hr = pIPS->CreateType(dwRegLoc,
                                       &pPStore->SigType,
                                       &Info,
                                       0)))
    {
        if (PST_E_TYPE_EXISTS != hr)
            goto Ret;
    }

    // make same rules for read, write access
    rgRules[0].cbSize = sizeof(PST_ACCESSRULE);
    rgRules[0].AccessModeFlags = PST_READ;
    rgRules[0].cClauses = 0;
    rgRules[0].rgClauses = NULL;
    rgRules[1].cbSize = sizeof(PST_ACCESSRULE);
    rgRules[1].AccessModeFlags = PST_WRITE;
    rgRules[1].cClauses = 0;
    rgRules[1].rgClauses = NULL;

    Rules.cbSize = sizeof(PST_ACCESSRULESET);
    Rules.cRules = 2;
    Rules.rgRules = rgRules;

    // create the signature subtype
    Info.szDisplayName = CRYPTO_SIG_SUBTYPE_STRING;
    PromptInfo.szPrompt = L"";
    if (S_OK != (hr = pIPS->CreateSubtype(dwRegLoc,
                                          &pPStore->SigType,
                                          &pPStore->SigSubtype,
                                          &Info,
                                          &Rules,
                                          0)))
    {
        if (PST_E_TYPE_EXISTS != hr)
            goto Ret;
    }

    // create the exchange subtype
    Info.szDisplayName = CRYPTO_EXCH_SUBTYPE_STRING;
    if (S_OK != (hr = pIPS->CreateSubtype(dwRegLoc,
                                          &pPStore->SigType,
                                          &pPStore->ExchSubtype,
                                          &Info,
                                          &Rules,
                                          0)))
    {
        if (PST_E_TYPE_EXISTS != hr)
            goto Ret;
    }

    fRet = TRUE;
Ret:
    return fRet;
}

BOOL GetKeysetTypeAndSubType(
                             PNTAGUserList pUser
                             )
{
    BOOL    fDefault = TRUE;
    BYTE    *pb1 = NULL;
    DWORD   cb1;
    BYTE    *pb2 = NULL;
    DWORD   cb2;
    BOOL    fRet = FALSE;

    memcpy(&pUser->pPStore->SigType, &DefTypeGuid, sizeof(GUID));
    memcpy(&pUser->pPStore->SigSubtype, &DefSigGuid, sizeof(GUID));
    memcpy(&pUser->pPStore->ExchType, &DefTypeGuid, sizeof(GUID));
    memcpy(&pUser->pPStore->ExchSubtype, &DefExchGuid, sizeof(GUID));

    // look in registry and see if the type and subtype Guids are there
    if (NTF_SUCCEED != ReadRegValue(pUser->hKeys, "SigTypeSubtype",
                                    &pb1, &cb1, TRUE))
        goto Ret;

    if (NTF_SUCCEED != ReadRegValue(pUser->hKeys, "ExchTypeSubtype",
                                    &pb2, &cb2, TRUE))
        goto Ret;

    if (pb1 && pb2)
        fDefault = FALSE;

    if (pb1)
    {
        memcpy(&pUser->pPStore->SigType, pb1, sizeof(GUID));
        memcpy(&pUser->pPStore->SigSubtype, pb1 + sizeof(GUID), sizeof(GUID));
    }

    if (pb2)
    {
        memcpy(&pUser->pPStore->ExchType, pb2, sizeof(GUID));
        memcpy(&pUser->pPStore->ExchSubtype, pb2 + sizeof(GUID), sizeof(GUID));
    }

    fRet = TRUE;
Ret:
    if (pb1)
        _nt_free(pb1, cb1);
    if (pb2)
        _nt_free(pb2, cb2);
    return fRet;
}

BOOL SetUIPrompt(
                 PNTAGUserList pUser,
                 LPWSTR szPrompt
                 )
{
    DWORD   cb;
    LPWSTR  sz = NULL;
    BOOL    fRet = FALSE;

    // check if sig or exch keys are loaded and if so error
    if (NULL == pUser->pPStore)
    {
        SetLastError((DWORD)NTE_BAD_KEYSET);
        goto Ret;
    }

    if (NULL != szPrompt)
    {
        cb = (lstrlenW(szPrompt) + 1) * sizeof(WCHAR);

        if (NULL == (sz = (LPWSTR)_nt_malloc(cb)))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        lstrcpyW(sz, szPrompt);
    }

    if (pUser->pPStore->szPrompt)
        _nt_free(pUser->pPStore->szPrompt, pUser->pPStore->cbPrompt);

    pUser->pPStore->cbPrompt = cb;
    pUser->pPStore->szPrompt = sz;

    fRet = TRUE;
Ret:
    return fRet;
}

BOOL PickleKey(
               BOOL fExportable,
	           size_t cbPriv,
	           PBYTE pbPriv,
               PBYTE *ppbData,
               PDWORD pcbData
               )
{
    BOOL fRet = FALSE;

    if (NULL != pbPriv)
    {
        // alloc the appropriate amount of space
        *pcbData = cbPriv + sizeof(DWORD) + sizeof(BOOL);
        if (NULL == (*ppbData = (PBYTE)_nt_malloc(*pcbData)))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        // copy exportable info into buffer
        memcpy(*ppbData, &fExportable, sizeof(BOOL));

        // copy length of keying material into buffer
        memcpy(*ppbData + sizeof(BOOL), &cbPriv, sizeof(DWORD));

        // copy keying material into buffer
        memcpy(*ppbData + sizeof(DWORD) + sizeof(BOOL), pbPriv, cbPriv);
    }

    fRet = TRUE;
Ret:
    return fRet;
}

BOOL UnpickleKey(
                 PBYTE pbData,
                 DWORD cbData,
                 BOOL *pfExportable,
	             DWORD *pcbPriv,
	             PBYTE *ppbPriv
                 )
{
    BOOL fRet = FALSE;

    if (NULL != pbData)
    {
        // pull out the exportable info
        memcpy(pfExportable, pbData, sizeof(BOOL));

        // pull out the length of the key material
        memcpy(pcbPriv, pbData + sizeof(BOOL), sizeof(DWORD));

        // free the current key material memory
        if (NULL != *ppbPriv)
            _nt_free(*ppbPriv, *pcbPriv);
        
        // alloc new memory for the key material
        if (NULL == (*ppbPriv = (PBYTE)_nt_malloc(*pcbPriv)))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        // copy key material
        memcpy(*ppbPriv, pbData + sizeof(DWORD) + sizeof(BOOL), *pcbPriv);
    }

    fRet = TRUE;
Ret:
    return fRet;
}

BOOL RestoreKeyFromProtectedStorage(
                                    PNTAGUserList pUser,
                                    LPWSTR szKeyName,
                                    BYTE **ppbKey,
                                    DWORD *pcbKey,
                                    LPWSTR szPrompt,
                                    BOOL fSigKey,
                                    BOOL fMachineKeySet,
                                    BOOL *pfUIOnKey
                                    )
{
    HRESULT         hr;
    DWORD           cb;
    BYTE            *pb = NULL;
    GUID            *pType;
    GUID            *pSubtype;
    BOOL            *pf;
    PST_PROMPTINFO  PromptInfo;
    IPStore         *pIPS = (IPStore*)(pUser->pPStore->pProv);
    DWORD           dwRegLoc = PST_KEY_CURRENT_USER;
    BOOL            fRet = FALSE;

    *pfUIOnKey = FALSE;

    if (fMachineKeySet)
        dwRegLoc = PST_KEY_LOCAL_MACHINE;

    memset(&PromptInfo, 0, sizeof(PromptInfo));
    PromptInfo.cbSize = sizeof(PST_PROMPTINFO);
    if (fSigKey)
    {
        if (0 == pUser->ContInfo.ContLens.cbSigPub)
        {
            fRet = TRUE;
            goto Ret;
        }
        pType = &pUser->pPStore->SigType;
        pSubtype = &pUser->pPStore->SigSubtype;
        pf = &pUser->ContInfo.fSigExportable;
    }
    else
    {
        if (0 == pUser->ContInfo.ContLens.cbExchPub)
        {
            fRet = TRUE;
            goto Ret;
        }
        pType = &pUser->pPStore->ExchType;
        pSubtype = &pUser->pPStore->ExchSubtype;
        pf = &pUser->ContInfo.fExchExportable;
    }

    // read the item from secure storage
    PromptInfo.hwndApp = NULL;
    if (NULL == pUser->pPStore->szPrompt)
        PromptInfo.szPrompt = szPrompt;
    else
        PromptInfo.szPrompt = pUser->pPStore->szPrompt;

    if (S_OK != (hr = pIPS->ReadItem(dwRegLoc,
                                     pType,
                                     pSubtype,
                                     szKeyName,
                                     &cb,
                                     &pb,
                                     &PromptInfo,
                                     PST_PROMPT_QUERY | PST_NO_UI_MIGRATION)))
    {
        // this function returns PST_E_ITEM_EXISTS if there is UI on the item
        if (PST_E_ITEM_EXISTS == hr)
        {
            *pfUIOnKey = TRUE;
        }
        else
        {
            goto Ret;
        }
    }

    if (!UnpickleKey(pb, cb, pf, pcbKey, ppbKey))
        goto Ret;

    fRet = TRUE;
Ret:
    if (pb)
        LocalFree(pb);
    return fRet;
}

BOOL MakeUnicodeKeysetName(
                           BYTE *pszName,
                           LPWSTR *ppszWName
                           )
{
    long    i;
    DWORD   cb;
    BOOL    fRet = FALSE;

    cb = (DWORD)lstrlenA((LPSTR)pszName);
    if (NULL == (*ppszWName = (LPWSTR)_nt_malloc((cb + 1) * sizeof(WCHAR))))
    {
        SetLastError((DWORD)ERROR_NOT_ENOUGH_MEMORY);
        goto Ret;
    }

    for(i=0;i<(long)cb;i++)
        (*ppszWName)[i] = (WCHAR)(pszName[i]);

    fRet = TRUE;
Ret:
    return fRet;
}

BOOL RestoreKeysetFromProtectedStorage(
                                       PNTAGUserList pUser,
                                       LPWSTR szPrompt,
                                       BYTE **ppbKey,
                                       DWORD *pcbKey,
                                       BOOL fSigKey,
                                       BOOL fMachineKeySet,
                                       BOOL *pfUIOnKey
                                       )
{
    LPWSTR  pszWName = NULL;
    BOOL    fRet = FALSE;

    // convert the keyset name to unicode
    if (!MakeUnicodeKeysetName((BYTE*)pUser->ContInfo.pszUserName, &pszWName))
        goto Ret;

    // restore the signature key
    if (!RestoreKeyFromProtectedStorage(pUser, pszWName, ppbKey, pcbKey,
                                        szPrompt, fSigKey, fMachineKeySet,
                                        pfUIOnKey))
        goto Ret;

    fRet = TRUE;
Ret:
    if (pszWName)
        _nt_free(pszWName, (wcslen(pszWName) + 1) * sizeof(WCHAR));
    return fRet;
}

void RemoveKeysetFromMemory(
                            PNTAGUserList pUser
                            )
{
    pUser->ContInfo.fSigExportable = FALSE;
    if (pUser->pSigPrivKey)
    {
        _nt_free(pUser->pSigPrivKey, pUser->SigPrivLen);
        pUser->SigPrivLen = 0;
        pUser->pSigPrivKey = NULL;
    }

    pUser->ContInfo.fExchExportable = FALSE;
    if (pUser->pExchPrivKey)
    {
        _nt_free(pUser->pExchPrivKey, pUser->ExchPrivLen);
        pUser->ExchPrivLen = 0;
        pUser->pExchPrivKey = NULL;
    }
}

BOOL SaveKeyToProtectedStorage(
                               PNTAGUserList pUser,
                               DWORD dwFlags,
                               LPWSTR szPrompt,
                               BOOL fSigKey,
                               BOOL fMachineKeySet
                               )
{
    HRESULT         hr;
    PBYTE           pb = NULL;
    DWORD           cb;
    GUID            *pType;
    GUID            *pSubtype;
    BOOL            f;
    BYTE            *pbKey;
    size_t          cbKey;
    LPWSTR          pszWName = NULL;
    LPSTR           szKeyName;
    PST_PROMPTINFO  PromptInfo;
    IPStore         *pIPS = (IPStore*)(pUser->pPStore->pProv);
    DWORD           dwRegLoc = PST_KEY_CURRENT_USER;
    DWORD           dwConfirm = PST_CF_NONE;

    BOOL            fRet = FALSE;

    if (fMachineKeySet)
        dwRegLoc = PST_KEY_LOCAL_MACHINE;

    memset(&PromptInfo, 0, sizeof(PromptInfo));
    PromptInfo.cbSize = sizeof(PST_PROMPTINFO);
    if (fSigKey)
    {
        pType = &pUser->pPStore->SigType;
        pSubtype = &pUser->pPStore->SigSubtype;
        f = pUser->ContInfo.fSigExportable;
        cbKey = pUser->SigPrivLen;
        pbKey = pUser->pSigPrivKey;
        szKeyName = "SPbK";
        if (dwFlags & CRYPT_USER_PROTECTED)
            dwConfirm = PST_CF_DEFAULT;
    }
    else
    {
        pType = &pUser->pPStore->ExchType;
        pSubtype = &pUser->pPStore->ExchSubtype;
        f = pUser->ContInfo.fExchExportable;
        cbKey = pUser->ExchPrivLen;
        pbKey = pUser->pExchPrivKey;
        szKeyName = "EPbK";
        if (dwFlags & CRYPT_USER_PROTECTED)
            dwConfirm = PST_CF_DEFAULT;
    }

    // format the signature key and exportable info
    if (!PickleKey(f, cbKey, pbKey, &pb, &cb))
        goto Ret;

    if (pb)
    {
        // make a unicode version of the keyset name
        if (!MakeUnicodeKeysetName((BYTE*)pUser->ContInfo.pszUserName, &pszWName))
            goto Ret;

        PromptInfo.hwndApp = NULL;
        if (NULL == pUser->pPStore->szPrompt)
            PromptInfo.szPrompt = szPrompt;
        else
            PromptInfo.szPrompt = pUser->pPStore->szPrompt;

        if (S_OK != (hr = pIPS->WriteItem(dwRegLoc,
                                          pType,
                                          pSubtype,
                                          pszWName,
                                          cb,
                                          pb,
                                          &PromptInfo,
                                          dwConfirm,
                                          0)))
            goto Ret;
    }

    fRet = TRUE;
Ret:
    if (pb)
        _nt_free(pb, cb);
    if (pszWName)
        _nt_free(pszWName, (wcslen(pszWName) + 1) * sizeof(WCHAR));
    return fRet;
}

BOOL DeleteKeyFromProtectedStorage(
                                   NTAGUserList *pUser,
                                   PCSP_STRINGS pStrings,
                                   DWORD dwKeySpec,
                                   BOOL fMachineKeySet,
                                   BOOL fMigration
                                   )
{
    LPWSTR          szWUserName = NULL;
    PST_PROMPTINFO  PromptInfo;
    IPStore         *pIPS;
    DWORD           dwRegLoc = PST_KEY_CURRENT_USER;
    BOOL            fRet = FALSE;

    memset(&PromptInfo, 0, sizeof(PromptInfo));
    PromptInfo.cbSize = sizeof(PST_PROMPTINFO);
    PromptInfo.hwndApp = NULL;

    if (fMachineKeySet)
        dwRegLoc = PST_KEY_LOCAL_MACHINE;

    // make a unicode name
    if (!MakeUnicodeKeysetName((BYTE*)pUser->ContInfo.pszUserName,
                               &szWUserName))
    {
        goto Ret;
    }

    pIPS = (IPStore*)(pUser->pPStore->pProv);

    if (AT_SIGNATURE == dwKeySpec)
    {
        if (fMigration)
        {
            PromptInfo.szPrompt = pStrings->pwszDeleteMigrSig;
        }
        else
        {
            PromptInfo.szPrompt = pStrings->pwszDeleteSig;
        }
        pIPS->DeleteItem(dwRegLoc,
                         &pUser->pPStore->SigType,
                         &pUser->pPStore->SigSubtype,
                         szWUserName,
                         &PromptInfo,
                         PST_NO_UI_MIGRATION);
    }
    else
    {
        if (fMigration)
        {
            PromptInfo.szPrompt = pStrings->pwszDeleteMigrExch;
        }
        else
        {
            PromptInfo.szPrompt = pStrings->pwszDeleteExch;
        }
        pIPS->DeleteItem(dwRegLoc,
                         &pUser->pPStore->ExchType,
                         &pUser->pPStore->ExchSubtype,
                         szWUserName,
                         &PromptInfo,
                         PST_NO_UI_MIGRATION);
    }

    fRet = TRUE;
Ret:
    if (szWUserName)
        _nt_free(szWUserName, (wcslen(szWUserName) + 1) * sizeof(WCHAR));
    return fRet;
}

BOOL DeleteFromProtectedStorage(
                                CONST char *pszUserID,
                                PCSP_STRINGS pStrings,
                                HKEY hRegKey,
                                BOOL fMachineKeySet
                                )
{
    GUID            Guid;
    NTAGUserList    User;
    BOOL            fRet = FALSE;

    // set up the User List structure
    memset(&User, 0, sizeof(User));
    User.ContInfo.pszUserName = (LPSTR)pszUserID;
    User.hKeys = hRegKey;

    if (NULL == (User.pPStore = (PSTORE_INFO*)_nt_malloc(sizeof(PSTORE_INFO))))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Ret;
    }

    if (!CheckPStoreAvailability(User.pPStore))
    {
        SetLastError((DWORD)NTE_FAIL);
        goto Ret;
    }

    // get type and subtypes
    if (!GetKeysetTypeAndSubType(&User))
        goto Ret;

    // delete each key
    if (!DeleteKeyFromProtectedStorage(&User, pStrings, AT_SIGNATURE,
                                       fMachineKeySet, FALSE))
    {
        goto Ret;
    }
    if (!DeleteKeyFromProtectedStorage(&User, pStrings, AT_KEYEXCHANGE,
                                       fMachineKeySet, FALSE))
    {
        goto Ret;
    }

    fRet = TRUE;
Ret:
    if (User.pPStore)
        FreePSInfo(User.pPStore);
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\rsabase\sgccheck.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : sgccheck.h                                              //
//  DESCRIPTION   : include file                                           //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Jun 23 1998 jeffspel Created                                       //
//                                                                         //
//  Copyright (C) 1998 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef	__SGCCHECK_H__
#define	__SGCCHECK_H__

#ifdef __cplusplus
extern "C" {
#endif

BOOL LoadSGCRoots(
                  IN CRITICAL_SECTION *pCritSec             // must be initialized
                  );


//
// delete the public key values
//
void SGCDeletePubKeyValues(
                           IN OUT BYTE **ppbKeyMod,
                           IN OUT DWORD *pcbKeyMod,
                           IN OUT DWORD *pdwKeyExpo
                           );

//
// get the public key form the cert context and assign it to the
// passed in parameters
//

BOOL SGCAssignPubKey(
                     IN PCCERT_CONTEXT pCertContext,
                     IN OUT BYTE **ppbKeyMod,
                     IN OUT DWORD *pcbKeyMod,
                     IN OUT DWORD *pdwKeyExpo
                     );

//
// check if the context may be SGC enabled
//

BOOL SPQueryCFLevel(
                    IN PCCERT_CONTEXT pCertContext,
                    IN BYTE *pbExchKeyMod,
                    IN DWORD cbExchKeyMod,
                    IN DWORD dwExchKeyExpo,
                    OUT DWORD *pdwSGCFlags
                    );

#ifdef __cplusplus
}
#endif

#endif // __SGCCHECK_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\rsabase\protstor.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : protstor.h                                             //
//  DESCRIPTION   :                                                        //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Dec  4 1996 jeffspel  Create                                       //
//      Apr 21 1997 jeffspel  Changes for NT 5 tree                        //
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef __PROTSTOR_H__
#define __PROTSTOR_H__

#ifdef __cplusplus
extern "C" {
#endif

BOOL CheckPStoreAvailability(
                         PSTORE_INFO *pPStore
                         );

BOOL CreateNewPSKeyset(
                       PSTORE_INFO *pPStore,
                       DWORD dwFlags
                       );

BOOL GetKeysetTypeAndSubType(
                             PNTAGUserList pUser
                             );

BOOL RestoreKeysetFromProtectedStorage(
                                       PNTAGUserList pUser,
                                       LPWSTR szPrompt,
                                       BYTE **ppbKey,
                                       DWORD *pcbKey,
                                       BOOL fSigKey,
                                       BOOL fMachineKeySet,
                                       BOOL *pfUIOnKey
                                       );

void RemoveKeysetFromMemory(
                            PNTAGUserList pUser
                            );

BOOL SetUIPrompt(
                 PNTAGUserList pUser,
                 LPWSTR szPrompt
                 );

BOOL SaveKeyToProtectedStorage(
                               PNTAGUserList pUser,
                               DWORD dwFlags,
                               LPWSTR szPrompt,
                               BOOL fSigKey,
                               BOOL fMachineKeySet
                               );

BOOL DeleteKeyFromProtectedStorage(
                                   NTAGUserList *pUser,
                                   PCSP_STRINGS pStrings,
                                   DWORD dwKeySpec,
                                   BOOL fMachineKeySet,
                                   BOOL fMigration
                                   );

BOOL DeleteFromProtectedStorage(
                                CONST char *pszUserID,
                                PCSP_STRINGS pStrings,
                                HKEY hRegKey,
                                BOOL fMachineKeySet
                                );

void FreePSInfo(
                PSTORE_INFO *pPStore
                );

#ifdef __cplusplus
}
#endif

#endif // __PROTSTOR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\rsabase\ssl3.c ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ssl3.c                                               //
//  DESCRIPTION   : Code for performing the SSL3 protocol:                 //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//  Dec  2 1996 jeffspel Created                                           //
//  Apr 8 1997  jeffspel Added PCT1 support
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "nt_rsa.h"
#include "nt_blobs.h"
#include "manage.h"
#include "ssl3.h"
#ifdef CSP_USE_3DES
#include "tripldes.h"
#endif

#define HMAC_K_PADSIZE              64

BOOL FIsLegalSGCKeySize(
                     IN ALG_ID Algid,
                     IN DWORD cbKey,
                     IN BOOL fRC2BigKeyOK,
                     IN BOOL fGenKey,
                     OUT BOOL *pfPubKey
                     );

BOOL FIsLegalKeySize(
                     IN ALG_ID Algid,
                     IN DWORD cbKey,
                     IN BOOL fRC2BigKeyOK,
                     IN DWORD dwFlags,
                     OUT BOOL *pfPubKey
                     );

BOOL FIsLegalKey(
                 PNTAGUserList pTmpUser,
                 PNTAGKeyList pKey,
                 BOOL fRC2BigKeyOK
                 );

void FreeNewKey(PNTAGKeyList pOldKey);

PNTAGKeyList MakeNewKey(
        ALG_ID      aiKeyAlg,
        DWORD       dwRights,
        DWORD       dwKeyLen,
        HCRYPTPROV  hUID,
        BYTE        *pbKeyData,
        BOOL        fUsePassedKeyBuffer
    );

BOOL MyPrimitiveSHA(
			PBYTE       pbData, 
			DWORD       cbData,
            BYTE        rgbHash[A_SHA_DIGEST_LEN])
{
    BOOL fRet = FALSE;
    A_SHA_CTX   sSHAHash;

            
    A_SHAInit(&sSHAHash);
    A_SHAUpdate(&sSHAHash, (BYTE *) pbData, cbData);
    A_SHAFinal(&sSHAHash, rgbHash);

    fRet = TRUE;
//Ret:

    return fRet;
}                                

BOOL MyPrimitiveMD5(
			PBYTE       pbData, 
			DWORD       cbData,
            BYTE        rgbHash[MD5DIGESTLEN])
{
    BOOL fRet = FALSE;
    MD5_CTX   sMD5Hash;

            
    MD5Init(&sMD5Hash);
    MD5Update(&sMD5Hash, (BYTE *) pbData, cbData);
    MD5Final(&sMD5Hash);
    memcpy(rgbHash, sMD5Hash.digest, MD5DIGESTLEN);

    fRet = TRUE;
//Ret:

    return fRet;
}                                

BOOL MyPrimitiveHMACParam(
        PBYTE       pbKeyMaterial, 
        DWORD       cbKeyMaterial,
        PBYTE       pbData, 
        DWORD       cbData,
        ALG_ID      Algid,
        BYTE        rgbHMAC[A_SHA_DIGEST_LEN])
{
    BYTE    rgbFirstHash[A_SHA_DIGEST_LEN];
    BYTE    rgbHMACTmp[HMAC_K_PADSIZE+A_SHA_DIGEST_LEN];
    BOOL    fRet = FALSE;

    BYTE    rgbKipad[HMAC_K_PADSIZE];
    BYTE    rgbKopad[HMAC_K_PADSIZE];
    DWORD   dwBlock;

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;

    
    ZeroMemory(rgbKipad, HMAC_K_PADSIZE);
    CopyMemory(rgbKipad, pbKeyMaterial, cbKeyMaterial);

    ZeroMemory(rgbKopad, HMAC_K_PADSIZE);
    CopyMemory(rgbKopad, pbKeyMaterial, cbKeyMaterial);

    // Kipad, Kopad are padded sMacKey. Now XOR across...
    for(dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(DWORD); dwBlock++)
    {
        ((DWORD*)rgbKipad)[dwBlock] ^= 0x36363636;
        ((DWORD*)rgbKopad)[dwBlock] ^= 0x5C5C5C5C;
    }

    // prepend Kipad to data, Hash to get H1
    if (CALG_SHA1 == Algid)
    {
        // do this inline since it would require data copy
        A_SHA_CTX   sSHAHash;

        A_SHAInit(&sSHAHash);
        A_SHAUpdate(&sSHAHash, rgbKipad, HMAC_K_PADSIZE);
        A_SHAUpdate(&sSHAHash, pbData, cbData);

        // Finish off the hash
        A_SHAFinal(&sSHAHash, sSHAHash.HashVal);

        // prepend Kopad to H1, hash to get HMAC
        CopyMemory(rgbHMACTmp, rgbKopad, HMAC_K_PADSIZE);
        CopyMemory(rgbHMACTmp+HMAC_K_PADSIZE, sSHAHash.HashVal, A_SHA_DIGEST_LEN);

        if (!MyPrimitiveSHA(
			    rgbHMACTmp, 
			    HMAC_K_PADSIZE + A_SHA_DIGEST_LEN,
                rgbHMAC))
            goto Ret;
    }
    else
    {
        // do this inline since it would require data copy
        MD5_CTX   sMD5Hash;
            
        MD5Init(&sMD5Hash);
        MD5Update(&sMD5Hash, rgbKipad, HMAC_K_PADSIZE);
        MD5Update(&sMD5Hash, pbData, cbData);
        MD5Final(&sMD5Hash);

        // prepend Kopad to H1, hash to get HMAC
        CopyMemory(rgbHMACTmp, rgbKopad, HMAC_K_PADSIZE);
        CopyMemory(rgbHMACTmp+HMAC_K_PADSIZE, sMD5Hash.digest, MD5DIGESTLEN);

        if (!MyPrimitiveMD5(
			    rgbHMACTmp, 
			    HMAC_K_PADSIZE + MD5DIGESTLEN,
                rgbHMAC))
            goto Ret;
    }

    fRet = TRUE;
Ret:

    return fRet;    
}

//+ ---------------------------------------------------------------------
// the P_Hash algorithm from TLS 
BOOL P_Hash
(
    PBYTE  pbSecret,
    DWORD  cbSecret, 

    PBYTE  pbSeed,  
    DWORD  cbSeed,  

    ALG_ID Algid,

    PBYTE  pbKeyOut, //Buffer to copy the result...
    DWORD  cbKeyOut  //# of bytes of key length they want as output.
)
{
    BOOL    fRet = FALSE;
    BYTE    rgbDigest[A_SHA_DIGEST_LEN];      
    DWORD   iKey;
    DWORD   cbHash;

    PBYTE   pbAofiDigest = NULL;

    if (NULL == (pbAofiDigest = (BYTE*)_nt_malloc(cbSeed + A_SHA_DIGEST_LEN)))
        goto Ret;

    if (CALG_SHA1 == Algid)
    {
        cbHash = A_SHA_DIGEST_LEN;
    }
    else
    {
        cbHash = MD5DIGESTLEN;
    }

//   First, we define a data expansion function, P_hash(secret, data)
//   which uses a single hash function to expand a secret and seed into
//   an arbitrary quantity of output:

//       P_hash(secret, seed) = HMAC_hash(secret, A(1) + seed) +
//                              HMAC_hash(secret, A(2) + seed) +
//                              HMAC_hash(secret, A(3) + seed) + ...

//   Where + indicates concatenation.

//   A() is defined as:
//       A(0) = seed
//       A(i) = HMAC_hash(secret, A(i-1))


    // build A(1)
    if (!MyPrimitiveHMACParam(pbSecret, cbSecret, pbSeed, cbSeed,
                              Algid, pbAofiDigest))
        goto Ret;

    // create Aofi: (  A(i) | seed )
    CopyMemory(&pbAofiDigest[cbHash], pbSeed, cbSeed);

    for (iKey=0; cbKeyOut; iKey++)
    {
        // build Digest = HMAC(key | A(i) | seed);
        if (!MyPrimitiveHMACParam(pbSecret, cbSecret, pbAofiDigest,
                                  cbSeed + cbHash, Algid, rgbDigest))
            goto Ret;

        // append to pbKeyOut
        if(cbKeyOut < cbHash)
        {
            CopyMemory(pbKeyOut, rgbDigest, cbKeyOut);
            break;
        }
        else
        {
            CopyMemory(pbKeyOut, rgbDigest, cbHash);
            pbKeyOut += cbHash;
        }

        cbKeyOut -= cbHash;

        // build A(i) = HMAC(key, A(i-1))
        if (!MyPrimitiveHMACParam(pbSecret, cbSecret, pbAofiDigest, cbHash,
                                  Algid, pbAofiDigest))
            goto Ret;
    }

    fRet = TRUE;
Ret:
    if (pbAofiDigest)
        _nt_free(pbAofiDigest, cbSeed + A_SHA_DIGEST_LEN);

    return fRet;
}

BOOL PRF(
    PBYTE  pbSecret,
    DWORD  cbSecret, 

    PBYTE  pbLabel,  
    DWORD  cbLabel,
    
    PBYTE  pbSeed,  
    DWORD  cbSeed,  

    PBYTE  pbKeyOut, //Buffer to copy the result...
    DWORD  cbKeyOut  //# of bytes of key length they want as output.
    )
{
    BYTE    *pbBuff = NULL;
    BYTE    *pbLabelAndSeed = NULL;
    DWORD   cbLabelAndSeed;
    DWORD   cbOdd;
    DWORD   cbHalfSecret;
    DWORD   i;
    BOOL    fRet = FALSE;

    cbOdd = cbSecret % 2;
    cbHalfSecret = cbSecret / 2;

    cbLabelAndSeed = cbLabel + cbSeed;
    if (NULL == (pbLabelAndSeed = (BYTE*)_nt_malloc(cbLabelAndSeed)))
        goto Ret;
    if (NULL == (pbBuff = (BYTE*)_nt_malloc(cbKeyOut)))
        goto Ret;

    // copy label and seed into one buffer
    memcpy(pbLabelAndSeed, pbLabel, cbLabel);
    memcpy(pbLabelAndSeed + cbLabel, pbSeed, cbSeed);

    // Use P_hash to calculate MD5 half
    if (!P_Hash(pbSecret, cbHalfSecret + cbOdd, pbLabelAndSeed,  
                cbLabelAndSeed, CALG_MD5, pbKeyOut, cbKeyOut))
        goto Ret;

    // Use P_hash to calculate SHA half
    if (!P_Hash(pbSecret + cbHalfSecret, cbHalfSecret + cbOdd, pbLabelAndSeed,  
                cbLabelAndSeed, CALG_SHA1, pbBuff, cbKeyOut))
        goto Ret;

    // XOR the two halves
    for (i=0;i<cbKeyOut;i++)
    {
        pbKeyOut[i] = pbKeyOut[i] ^ pbBuff[i];
    }
    fRet = TRUE;
Ret:
    if (pbBuff)
        _nt_free(pbBuff, cbKeyOut);
    if (pbLabelAndSeed)
        _nt_free(pbLabelAndSeed, cbLabelAndSeed);
    return fRet;
}

void FreeSChHash(
                 PSCH_HASH       pSChHash
                 )
{
    if (pSChHash->pbCertData)
        _nt_free(pSChHash->pbCertData, pSChHash->cbCertData);
}

void FreeSChKey(
                PSCH_KEY    pSChKey
                )
{
    if (pSChKey->pbCertData)
        _nt_free(pSChKey->pbCertData, pSChKey->cbCertData);
}

BOOL SCHSetKeyParam(
                    IN PNTAGUserList pTmpUser,
                    IN OUT PNTAGKeyList pKey,
                    IN DWORD dwParam,
                    IN PBYTE pbData
                    )
{
    PCRYPT_DATA_BLOB    pDataBlob = (PCRYPT_DATA_BLOB)pbData;
    PSCH_KEY            pSChKey;
    PSCHANNEL_ALG       pSChAlg;
    BOOL                fPubKey = FALSE;
    BOOL                fRet = FALSE;

    if ((CALG_SSL3_MASTER != pKey->Algid) &&
        (CALG_PCT1_MASTER != pKey->Algid) &&
        (CALG_TLS1_MASTER != pKey->Algid) &&
        (CALG_SSL2_MASTER != pKey->Algid))
    {
        SetLastError((DWORD) NTE_BAD_TYPE);
        goto Ret;
    }

    if (NULL == pKey->pData)
    {
        if (NULL == (pKey->pData = (BYTE*)_nt_malloc(sizeof(SCH_KEY))))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }
        memset(pKey->pData, 0, sizeof(SCH_KEY));
    }

    pSChKey = (PSCH_KEY)pKey->pData;

    if (KP_SCHANNEL_ALG == dwParam)
    {
        pSChAlg = (PSCHANNEL_ALG)pbData;
        pSChKey->dwFlags = pSChAlg->dwFlags;   // set the international version indicator

        switch(pSChAlg->dwUse)
        {
            case SCHANNEL_MAC_KEY:
                switch(pSChAlg->Algid)
                {
                    case CALG_MD5:
                        if (CALG_PCT1_MASTER == pKey->Algid)
                        {
                            pSChKey->cbHash = MD5DIGESTLEN;
                            pSChKey->cbEncMac = pSChAlg->cBits / 8;
                        }
                        else
                        {
                            if (pSChAlg->cBits != (MD5DIGESTLEN * 8))
                            {
                                SetLastError((DWORD)NTE_BAD_DATA);
                                goto Ret;
                            }
                            pSChKey->cbEncMac = MD5DIGESTLEN;
                        }
                        break;

                    case CALG_SHA1:
                        if (CALG_PCT1_MASTER == pKey->Algid)
                        {
                            pSChKey->cbHash = A_SHA_DIGEST_LEN;
                            pSChKey->cbEncMac = pSChAlg->cBits / 8;
                        }
                        else
                        {
                            if (pSChAlg->cBits != (A_SHA_DIGEST_LEN * 8))
                            {
                                SetLastError((DWORD)NTE_BAD_DATA);
                                goto Ret;
                            }
                            pSChKey->cbEncMac = A_SHA_DIGEST_LEN;
                        }
                        break;

                    default:
                        SetLastError((DWORD)NTE_BAD_DATA);
                        goto Ret;
                }
                pSChKey->HashAlgid = pSChAlg->Algid;
                break;

            case SCHANNEL_ENC_KEY:
                if (pSChAlg->cBits % 8)
                {
                    SetLastError((DWORD)NTE_BAD_DATA);
                    goto Ret;
                }

                if ((PROV_RSA_SCHANNEL == pTmpUser->dwProvType) &&
                    (0 != pTmpUser->dwSGCFlags))
                {
                    if (!FIsLegalSGCKeySize(pSChAlg->Algid, pSChAlg->cBits / 8,
                                            FALSE, FALSE, &fPubKey))
                    {
                        goto Ret;
                    }
                }
                else
                {
                    if (!FIsLegalKeySize(pSChAlg->Algid, pSChAlg->cBits / 8,
                                         FALSE, 0, &fPubKey))
                    {
                        goto Ret;
                    }
                }

                switch(pSChAlg->Algid)
                {
#ifdef CSP_USE_RC4
                    case CALG_RC4:
                        pSChKey->cbIV = 0;
                        break;
#endif

#ifdef CSP_USE_RC2
                    case CALG_RC2:
                        pSChKey->cbIV = RC2_BLOCKLEN;
                        break;
#endif

#ifdef CSP_USE_DES
                    case CALG_DES:
                        pSChKey->cbIV = DES_BLOCKLEN;
                        break;
#endif
                        
#ifdef CSP_USE_3DES
                    case CALG_3DES_112:
                        pSChKey->cbIV = DES_BLOCKLEN;
                        break;

                    case CALG_3DES:
                        pSChKey->cbIV = DES_BLOCKLEN;
                        break;
#endif

                    default:
                        SetLastError((DWORD)NTE_BAD_DATA);
                        goto Ret;
                }

                // For SSL2 check that the length of the master key matches the
                // the requested encryption length
                if ((CALG_SSL2_MASTER == pKey->Algid) &&
                    ((pSChAlg->cBits / 8) != pKey->cbKeyLen))
                {
                    SetLastError((DWORD)NTE_BAD_KEY);
                    goto Ret;
                }

                pSChKey->cbEnc = (pSChAlg->cBits / 8);
                pSChKey->EncAlgid = pSChAlg->Algid;
                break;

            default:
                SetLastError((DWORD)NTE_BAD_DATA);
                goto Ret;
        }
    }
    else
    {
        switch (dwParam)
        {
            case KP_CLIENT_RANDOM:
                if (pDataBlob->cbData > MAX_RANDOM_LEN)
                {
                    SetLastError((DWORD)NTE_BAD_DATA);
                    goto Ret;
                }

                pSChKey->cbClientRandom = pDataBlob->cbData;
                memcpy(pSChKey->rgbClientRandom, pDataBlob->pbData, pDataBlob->cbData);
                break;

            case KP_SERVER_RANDOM:
                if (pDataBlob->cbData > MAX_RANDOM_LEN)
                {
                    SetLastError((DWORD)NTE_BAD_DATA);
                    goto Ret;
                }

                pSChKey->cbServerRandom = pDataBlob->cbData;
                memcpy(pSChKey->rgbServerRandom, pDataBlob->pbData, pDataBlob->cbData);
                break;

            case KP_CERTIFICATE:
                if (CALG_PCT1_MASTER != pKey->Algid)
                {
                    SetLastError((DWORD) NTE_BAD_TYPE);
                    goto Ret;
                }

                if(pSChKey->pbCertData)
                {
                    _nt_free(pSChKey->pbCertData, pSChKey->cbCertData);
                }
                pSChKey->cbCertData = pDataBlob->cbData;
                if (NULL == (pSChKey->pbCertData = (BYTE*)_nt_malloc(pSChKey->cbCertData)))
                {
                    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    goto Ret;
                }
                memcpy(pSChKey->pbCertData, pDataBlob->pbData, pDataBlob->cbData);
                break;

            case KP_CLEAR_KEY:
                if (pDataBlob->cbData > MAX_RANDOM_LEN)
                {
                    SetLastError((DWORD)NTE_BAD_DATA);
                    goto Ret;
                }

                if ((CALG_PCT1_MASTER != pKey->Algid) &&
                    (CALG_SSL2_MASTER != pKey->Algid))
                {
                    SetLastError((DWORD) NTE_BAD_TYPE);
                    goto Ret;
                }

                pSChKey->cbClearData = pDataBlob->cbData;
                memcpy(pSChKey->rgbClearData, pDataBlob->pbData, pDataBlob->cbData);
                break;

            default:
                SetLastError((DWORD) NTE_BAD_TYPE);
                goto Ret;
        }
    }

    fRet = TRUE;
Ret:
    return fRet;
}

BOOL SCHGetKeyParam(
                    PNTAGKeyList pKey,
                    DWORD dwParam,
                    PBYTE pbData
                    )
{
    return TRUE;
}

BOOL SSL3SingleHash(
                    HCRYPTPROV hUID,
                    PBYTE pbString,
                    DWORD cbString,
                    PBYTE pbSecret,
                    DWORD cbSecret,
                    PBYTE pbRand1,
                    DWORD cbRand1,
                    PBYTE pbRand2,
                    DWORD cbRand2,
                    PBYTE pbResult
                    )
{
    HCRYPTHASH hHashSHA = 0;
    HCRYPTHASH hHashMD5 = 0;
    BYTE rgb[A_SHA_DIGEST_LEN];
    DWORD cb;
    BOOL fRet = FALSE;

    // perform the SHA hashing
    if (!CPCreateHash(hUID, CALG_SHA1, 0, 0, &hHashSHA))
        goto Ret;

    if (!CPHashData(hUID, hHashSHA, pbString, cbString, 0))
        goto Ret;

    if (!CPHashData(hUID, hHashSHA, pbSecret, cbSecret, 0))
        goto Ret;

    if (!CPHashData(hUID, hHashSHA, pbRand1, cbRand1, 0))
        goto Ret;
    if (!CPHashData(hUID, hHashSHA, pbRand2, cbRand2, 0))
        goto Ret;

    cb = A_SHA_DIGEST_LEN;
    if (!CPGetHashParam(hUID, hHashSHA, HP_HASHVAL, rgb, &cb, 0))
        goto Ret;

    // perform the MD5 hashing
    if (!CPCreateHash(hUID, CALG_MD5, 0, 0, &hHashMD5))
        goto Ret;

    if (!CPHashData(hUID, hHashMD5, pbSecret, cbSecret, 0))
        goto Ret;

    if (!CPHashData(hUID, hHashMD5, rgb, A_SHA_DIGEST_LEN, 0))
        goto Ret;

    cb = MD5DIGESTLEN;
    if (!CPGetHashParam(hUID, hHashMD5, HP_HASHVAL, pbResult, &cb, 0))
        goto Ret;

    fRet = TRUE;
Ret:
    if (hHashSHA)
        CPDestroyHash(hUID, hHashSHA);
    if (hHashMD5)
        CPDestroyHash(hUID, hHashMD5);
    return fRet;
}

BOOL SSL3HashPreMaster(
                       HCRYPTPROV hUID,
                       PBYTE pbSecret,
                       DWORD cbSecret,
                       PBYTE pbRand1,
                       DWORD cbRand1,
                       PBYTE pbRand2,
                       DWORD cbRand2,
                       PBYTE pbFinal,
                       DWORD cbFinal
                       )
{
    BYTE    rgbString[17];   // know max length from MAX_RANDOM_LEN
    DWORD   cLimit;
    DWORD   cbIndex = 0;
    long    i;
    BOOL    fRet = FALSE;

    if ((cbFinal > MAX_RANDOM_LEN) || ((cbFinal % MD5DIGESTLEN) != 0))
    {
        SetLastError((DWORD)NTE_FAIL);
        goto Ret;
    }

    cLimit = cbFinal / MD5DIGESTLEN;

    for (i=0;i<(long)cLimit;i++)
    {
        memset(rgbString, 0x41 + i, i + 1);
        if (!SSL3SingleHash(hUID, rgbString, i + 1, pbSecret,
                            cbSecret, pbRand1, cbRand1,
                            pbRand2, cbRand2, pbFinal + cbIndex))
            goto Ret;
        cbIndex += MD5DIGESTLEN;
    }
    fRet = TRUE;
Ret:
    return fRet;
}

BOOL SChGenMasterKey(
                     PNTAGKeyList pKey,
                     PSCH_HASH pSChHash
                     )
{
    PSCH_KEY    pSChKey;
    DWORD       cb;
    BYTE        *pbClientAndServer = NULL;
    DWORD       cbClientAndServer;
    BOOL        fRet = FALSE;

    pSChKey = (PSCH_KEY)pKey->pData;
    pSChHash->dwFlags = pSChKey->dwFlags;   // set the international flag from the key

    switch(pKey->Algid)
    {
        case CALG_SSL3_MASTER:
            if (!pSChKey->fFinished)
            {
                // copy the premaster secret
                pSChKey->cbPremaster = pKey->cbKeyLen;
                memcpy(pSChKey->rgbPremaster, pKey->pKeyValue, pSChKey->cbPremaster);

                // hash the pre-master secret
                if (!SSL3HashPreMaster(pKey->hUID,
                                       pSChKey->rgbPremaster,
                                       pSChKey->cbPremaster,
                                       pSChKey->rgbClientRandom,
                                       pSChKey->cbClientRandom,
                                       pSChKey->rgbServerRandom,
                                       pSChKey->cbServerRandom,
                                       pKey->pKeyValue,
                                       pKey->cbKeyLen))
                    goto Ret;
            }

            // copy the necessary information to the hash
            pSChHash->EncAlgid = pSChKey->EncAlgid;
            pSChHash->cbEnc = pSChKey->cbEnc;
            pSChHash->cbEncMac = pSChKey->cbEncMac;
            pSChHash->cbIV = pSChKey->cbIV;
            pSChHash->cbClientRandom = pSChKey->cbClientRandom;
            memcpy(pSChHash->rgbClientRandom, pSChKey->rgbClientRandom, pSChHash->cbClientRandom);
            pSChHash->cbServerRandom = pSChKey->cbServerRandom;
            memcpy(pSChHash->rgbServerRandom, pSChKey->rgbServerRandom, pSChHash->cbServerRandom);

            cb = pSChHash->cbEnc * 2 + pSChHash->cbEncMac * 2 + pSChHash->cbIV * 2;
            pSChHash->cbFinal = (cb / MD5DIGESTLEN) * MD5DIGESTLEN;
            if (cb % MD5DIGESTLEN)
            {
                pSChHash->cbFinal += MD5DIGESTLEN;
            }

            // hash the master secret
            if (!SSL3HashPreMaster(pKey->hUID,
                                   pKey->pKeyValue,
                                   pKey->cbKeyLen,
                                   pSChKey->rgbServerRandom,
                                   pSChKey->cbServerRandom,
                                   pSChKey->rgbClientRandom,
                                   pSChKey->cbClientRandom,
                                   pSChHash->rgbFinal,
                                   pSChHash->cbFinal))
                goto Ret;

            pSChKey->fFinished = TRUE;
            break;

        case CALG_TLS1_MASTER:
            cbClientAndServer = pSChKey->cbClientRandom + pSChKey->cbServerRandom;
            if (NULL == (pbClientAndServer =
                    (BYTE*)_nt_malloc(cbClientAndServer)))
            {
                goto Ret;
            }

            if (!pSChKey->fFinished)
            {
                // copy the premaster secret
                pSChKey->cbPremaster = pKey->cbKeyLen;
                memcpy(pSChKey->rgbPremaster, pKey->pKeyValue, pSChKey->cbPremaster);

                // concatenate the client random and server random
                memcpy(pbClientAndServer, pSChKey->rgbClientRandom,
                       pSChKey->cbClientRandom);
                memcpy(pbClientAndServer + pSChKey->cbClientRandom,
                       pSChKey->rgbServerRandom, pSChKey->cbServerRandom);

                // hash the pre-master secret
                if (!PRF(pSChKey->rgbPremaster, pSChKey->cbPremaster,
                         "master secret", 13,
                         pbClientAndServer, cbClientAndServer,
                         pKey->pKeyValue, TLS_MASTER_LEN))
                {
                    goto Ret;
                }
            }

            // copy the necessary information to the hash
            pSChHash->EncAlgid = pSChKey->EncAlgid;
            pSChHash->cbEnc = pSChKey->cbEnc;
            pSChHash->cbEncMac = pSChKey->cbEncMac;
            pSChHash->cbIV = pSChKey->cbIV;
            pSChHash->cbClientRandom = pSChKey->cbClientRandom;
            memcpy(pSChHash->rgbClientRandom, pSChKey->rgbClientRandom,
                   pSChHash->cbClientRandom);
            pSChHash->cbServerRandom = pSChKey->cbServerRandom;
            memcpy(pSChHash->rgbServerRandom, pSChKey->rgbServerRandom,
                   pSChHash->cbServerRandom);

            pSChHash->cbFinal = pSChHash->cbEnc * 2 + pSChHash->cbEncMac * 2 +
                                pSChHash->cbIV * 2;

            // concatenate the server random and client random 
            memcpy(pbClientAndServer, pSChKey->rgbServerRandom,
                   pSChKey->cbServerRandom);
            memcpy(pbClientAndServer + pSChKey->cbServerRandom,
                   pSChKey->rgbClientRandom, pSChKey->cbClientRandom);

            // hash the master secret
            if (!PRF(pKey->pKeyValue, pKey->cbKeyLen,
                     "key expansion", 13,
                     pbClientAndServer, cbClientAndServer,
                     pSChHash->rgbFinal, pSChHash->cbFinal))
                goto Ret;

            pSChKey->fFinished = TRUE;
            break;

        case CALG_PCT1_MASTER:
            pSChHash->cbFinal = pKey->cbKeyLen;
            memcpy(pSChHash->rgbFinal, pKey->pKeyValue, pSChHash->cbFinal);

            // copy the necessary information to the hash
            pSChHash->EncAlgid = pSChKey->EncAlgid;
            pSChHash->HashAlgid = pSChKey->HashAlgid;
            pSChHash->cbEnc = pSChKey->cbEnc;
            pSChHash->cbEncMac = pSChKey->cbEncMac;
            pSChHash->cbHash = pSChKey->cbHash;
            pSChHash->cbIV = pSChKey->cbIV;
            pSChHash->cbClientRandom = pSChKey->cbClientRandom;
            memcpy(pSChHash->rgbClientRandom, pSChKey->rgbClientRandom, pSChHash->cbClientRandom);
            pSChHash->cbServerRandom = pSChKey->cbServerRandom;
            memcpy(pSChHash->rgbServerRandom, pSChKey->rgbServerRandom, pSChHash->cbServerRandom);

            pSChHash->cbCertData = pSChKey->cbCertData;
            if (NULL == (pSChHash->pbCertData = (BYTE*)_nt_malloc(pSChHash->cbCertData)))
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }
            memcpy(pSChHash->pbCertData, pSChKey->pbCertData, pSChHash->cbCertData);
            pSChHash->cbClearData = pSChKey->cbClearData;
            memcpy(pSChHash->rgbClearData, pSChKey->rgbClearData, pSChHash->cbClearData);
            break;

        case CALG_SSL2_MASTER:
            pSChHash->cbFinal = pKey->cbKeyLen;
            memcpy(pSChHash->rgbFinal, pKey->pKeyValue, pSChHash->cbFinal);

            // copy the necessary information to the hash
            pSChHash->EncAlgid = pSChKey->EncAlgid;
            pSChHash->HashAlgid = pSChKey->HashAlgid;
            pSChHash->cbEnc = pSChKey->cbEnc;
            pSChHash->cbEncMac = pSChKey->cbEncMac;
            pSChHash->cbHash = pSChKey->cbHash;
            pSChHash->cbIV = pSChKey->cbIV;
            pSChHash->cbClientRandom = pSChKey->cbClientRandom;
            memcpy(pSChHash->rgbClientRandom, pSChKey->rgbClientRandom, pSChHash->cbClientRandom);
            pSChHash->cbServerRandom = pSChKey->cbServerRandom;
            memcpy(pSChHash->rgbServerRandom, pSChKey->rgbServerRandom, pSChHash->cbServerRandom);
            pSChHash->cbClearData = pSChKey->cbClearData;
            memcpy(pSChHash->rgbClearData, pSChKey->rgbClearData, pSChHash->cbClearData);
            break;
    }

    fRet = TRUE;
Ret:
    if (pbClientAndServer)
        _nt_free(pbClientAndServer, cbClientAndServer);
    return fRet;
}

BOOL HelperHash(
                HCRYPTPROV hProv,
                BYTE *pb,
                DWORD cb,
                ALG_ID Algid,
                BYTE **ppbHash,
                DWORD *pcbHash,
                BOOL fAlloc
                )
{
    HCRYPTHASH  hHash = 0;
    BOOL        fRet = FALSE;

    if (fAlloc)
    {
        *ppbHash = NULL;
    }

    // hash the key and stuff into a usable key
    if (!CPCreateHash(hProv, Algid, 0, 0, &hHash))
        goto Ret;

    if (!CPHashData(hProv, hHash, pb, cb, 0))
        goto Ret;

    if (fAlloc)
    {
        if (!CPGetHashParam(hProv, hHash, HP_HASHVAL, NULL, pcbHash, 0))
            goto Ret;

        if (NULL == (*ppbHash = (BYTE*)_nt_malloc(*pcbHash)))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }
    }

    if (!CPGetHashParam(hProv, hHash, HP_HASHVAL, *ppbHash, pcbHash, 0))
        goto Ret;

    fRet = TRUE;
Ret:
    if (hHash)
        CPDestroyHash(hProv, hHash);
    if ((FALSE == fRet) && fAlloc && *ppbHash)
    {
        _nt_free(*ppbHash, *pcbHash);
        *ppbHash = NULL;
    }
    return fRet;
}

BOOL SSL3DeriveWriteKey(
                        PNTAGUserList pTmpUser,
                        PNTAGHashList pHash,
                        DWORD dwFlags,
                        HCRYPTKEY *phKey
                        )
{
    PSCH_HASH       pSChHash;
    DWORD           cbOffset;
    BYTE            rgbTmp[MD5DIGESTLEN];
    DWORD           cbTmp;
    BYTE            *pbIV = NULL;
    DWORD           cbIV;
    BOOL            fUseIV = FALSE;
    BYTE            *pbKey = NULL;
    DWORD           cbKey;
    PNTAGKeyList    pTmpKey = NULL;
    BYTE            rgbBuff[MAX_RANDOM_LEN * 2 + MAX_PREMASTER_LEN];
    DWORD           cbBuff;
    BOOL            fRet = FALSE;
    DWORD           dwRights;

    pSChHash = (PSCH_HASH)pHash->pHashData;
    cbOffset = 2 * pSChHash->cbEncMac;

    // get the IV
    if (CALG_RC4 != pSChHash->EncAlgid)
        fUseIV = TRUE;

    // if not flagged as a server key then default is client
    if (pSChHash->dwFlags & INTERNATIONAL_USAGE)
    {
        if (CRYPT_SERVER & dwFlags)
        {
            cbBuff = pSChHash->cbEnc + pSChHash->cbServerRandom + pSChHash->cbClientRandom;
            if (cbBuff > sizeof(rgbBuff))
                goto Ret;
            memcpy(rgbBuff, pSChHash->rgbFinal + cbOffset + pSChHash->cbEnc, pSChHash->cbEnc);
            memcpy(rgbBuff + pSChHash->cbEnc, pSChHash->rgbServerRandom, pSChHash->cbServerRandom);
            memcpy(rgbBuff + pSChHash->cbEnc + pSChHash->cbServerRandom,
                   pSChHash->rgbClientRandom, pSChHash->cbClientRandom);
            if (!HelperHash(pHash->hUID, rgbBuff, cbBuff, CALG_MD5,
                            &pbKey, &cbKey, TRUE))
                goto Ret;

            if (fUseIV)
            {
                cbBuff = pSChHash->cbServerRandom + pSChHash->cbClientRandom;
                memcpy(rgbBuff, pSChHash->rgbServerRandom, pSChHash->cbServerRandom);
                memcpy(rgbBuff + pSChHash->cbServerRandom,
                       pSChHash->rgbClientRandom, pSChHash->cbClientRandom);
                if (!HelperHash(pHash->hUID, rgbBuff, cbBuff, CALG_MD5,
                                &pbIV, &cbIV, TRUE))
                    goto Ret;
            }
        }
        else
        {
            cbBuff = pSChHash->cbEnc + pSChHash->cbServerRandom + pSChHash->cbClientRandom;
            if (cbBuff > sizeof(rgbBuff))
                goto Ret;
            memcpy(rgbBuff, pSChHash->rgbFinal + cbOffset, pSChHash->cbEnc);
            memcpy(rgbBuff + pSChHash->cbEnc, pSChHash->rgbClientRandom, pSChHash->cbClientRandom);
            memcpy(rgbBuff + pSChHash->cbEnc + pSChHash->cbClientRandom,
                   pSChHash->rgbServerRandom, pSChHash->cbServerRandom);
            if (!HelperHash(pHash->hUID, rgbBuff, cbBuff, CALG_MD5,
                            &pbKey, &cbKey, TRUE))
                goto Ret;

            if (fUseIV)
            {
                cbBuff = pSChHash->cbServerRandom + pSChHash->cbClientRandom;
                memcpy(rgbBuff, pSChHash->rgbClientRandom, pSChHash->cbClientRandom);
                memcpy(rgbBuff + pSChHash->cbClientRandom,
                       pSChHash->rgbServerRandom, pSChHash->cbServerRandom);
                if (!HelperHash(pHash->hUID, rgbBuff, cbBuff, CALG_MD5,
                                &pbIV, &cbIV, TRUE))
                    goto Ret;
            }
        }
    }
    else
    {
        cbKey = pSChHash->cbEnc;
        if (NULL == (pbKey = (BYTE*)_nt_malloc(cbKey)))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        cbIV = pSChHash->cbIV;
        if (NULL == (pbIV = (BYTE*)_nt_malloc(cbIV)))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        if (CRYPT_SERVER & dwFlags)
        {
            memcpy(pbKey, pSChHash->rgbFinal + cbOffset + pSChHash->cbEnc,
                   pSChHash->cbEnc);

            memcpy(pbIV, pSChHash->rgbFinal + cbOffset + pSChHash->cbEnc * 2 +
                   pSChHash->cbIV, pSChHash->cbIV);
        }
        else
        {
            memcpy(pbKey, pSChHash->rgbFinal + cbOffset, pSChHash->cbEnc);

            memcpy(pbIV, pSChHash->rgbFinal + cbOffset + pSChHash->cbEnc * 2,
                   pSChHash->cbIV);
        }
    }

    // check if the key is CRYPT_EXPORTABLE
    if (dwFlags & CRYPT_EXPORTABLE)
        dwRights = CRYPT_EXPORTABLE;

    // make the new key
    if (NULL == (pTmpKey = MakeNewKey(pSChHash->EncAlgid,
                                      dwRights,
                                      pSChHash->cbEnc,
                                      pHash->hUID,
                                      pbKey,
                                      FALSE)))
    {
        goto Ret;
    }

    if (CALG_RC2 == pSChHash->EncAlgid)
    {
        pTmpKey->EffectiveKeyLen = RC2_SCHANNEL_DEFAULT_EFFECTIVE_KEYLEN;
    }

    if ((pSChHash->dwFlags & INTERNATIONAL_USAGE) &&
        ((CALG_RC2 == pSChHash->EncAlgid) || (CALG_RC4 == pSChHash->EncAlgid)))
    {
        pTmpKey->cbSaltLen = RC_KEYLEN - pSChHash->cbEnc;
        memcpy(pTmpKey->rgbSalt, pbKey + pSChHash->cbEnc, pTmpKey->cbSaltLen);
    }

    // check keylength...
    if (!FIsLegalKey(pTmpUser, pTmpKey, FALSE))
        goto Ret;

    // set the IV if necessary
    if (fUseIV)
    {
        // set the mode to CBC
        pTmpKey->Mode = CRYPT_MODE_CBC;

        // set the IV
        memcpy(pTmpKey->IV, pbIV, CRYPT_BLKLEN);       // Initialization vector
    }

    if (NTF_FAILED == NTLMakeItem(phKey, KEY_HANDLE, (void *)pTmpKey))
        goto Ret;

    fRet = TRUE;
Ret:
    if (pbKey)
        _nt_free(pbKey, cbKey);
    if (pbIV)
        _nt_free(pbIV, cbIV);
    if (FALSE == fRet)
    {
        if (pTmpKey)
            FreeNewKey(pTmpKey);
    }
    return fRet;
}

BOOL PCT1MakeKeyHash(
                        PNTAGHashList pHash,
                        DWORD c,
                        DWORD dwFlags,
                        BOOL fWriteKey,
                        BYTE *pbBuff,
                        DWORD *pcbBuff
                        )
{
    BYTE        *pb = NULL;
    DWORD       cb = 0;
    DWORD       cbIndex;
    PSCH_HASH   pSChHash;
    BYTE        *pbStr;
    DWORD       cbStr;
    DWORD       i;
    BYTE        *pbHash = NULL;
    DWORD       cbHash;
    DWORD       fRet = FALSE;

    pSChHash = (PSCH_HASH)pHash->pHashData;

    // For reasons of backward compatibility, use the formula:
    //     hash( i, "foo"^i, MASTER_KEY, ...
    // rather than:
    //     hash( i, "foo", MASTER_KEY, ...
    // when deriving encryption keys.

    if (fWriteKey)
    {
        if (CRYPT_SERVER & dwFlags)
        {
            pbStr = PCT1_S_WRT;
            cbStr = PCT1_S_WRT_LEN;
            cb = cbStr * c;
        }
        else
        {
            pbStr = PCT1_C_WRT;
            cbStr = PCT1_C_WRT_LEN;
            cb = pSChHash->cbCertData + cbStr * c * 2;
        }
    }
    else
    {
        if (CRYPT_SERVER & dwFlags)
        {
            pbStr = PCT1_S_MAC;
            cbStr = PCT1_S_MAC_LEN;
        }
        else
        {
            pbStr = PCT1_C_MAC;
            cbStr = PCT1_C_MAC_LEN;
            cb = pSChHash->cbCertData + cbStr * c;
        }
    }

    cb += 1 + (3 * cbStr * c) + pSChHash->cbFinal +
          + pSChHash->cbClientRandom  + pSChHash->cbServerRandom;

    if (NULL == (pb = (BYTE*)_nt_malloc(cb)))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Ret;
    }

    // form the buffer to be hashed
    pb[0] = (BYTE)c;
    cbIndex = 1;

    if (fWriteKey)
    {
        for(i=0;i<c;i++)
        {
            memcpy(pb + cbIndex, pbStr, cbStr);
            cbIndex += cbStr;
        }
    }

    memcpy(pb + cbIndex, pSChHash->rgbFinal, pSChHash->cbFinal);
    cbIndex += pSChHash->cbFinal;
    for(i=0;i<c;i++)
    {
        memcpy(pb + cbIndex, pbStr, cbStr);
        cbIndex += cbStr;
    }
    memcpy(pb + cbIndex, pSChHash->rgbServerRandom, pSChHash->cbServerRandom);
    cbIndex += pSChHash->cbServerRandom;
    for(i=0;i<c;i++)
    {
        memcpy(pb + cbIndex, pbStr, cbStr);
        cbIndex += cbStr;
    }

    if (!(CRYPT_SERVER & dwFlags))
    {
        memcpy(pb + cbIndex, pSChHash->pbCertData, pSChHash->cbCertData);
        cbIndex += pSChHash->cbCertData;
        for(i=0;i<c;i++)
        {
            memcpy(pb + cbIndex, pbStr, cbStr);
            cbIndex += cbStr;
        }
    }

    memcpy(pb + cbIndex, pSChHash->rgbClientRandom, pSChHash->cbClientRandom);
    cbIndex += pSChHash->cbClientRandom;
    for(i=0;i<c;i++)
    {
        memcpy(pb + cbIndex, pbStr, cbStr);
        cbIndex += cbStr;
    }

    if (!HelperHash(pHash->hUID, pb, cb, pSChHash->HashAlgid,
                    &pbHash, &cbHash, TRUE))
        goto Ret;

    *pcbBuff = cbHash;
    memcpy(pbBuff, pbHash, *pcbBuff);

    fRet = TRUE;
Ret:
    if (pb)
        _nt_free(pb, cb);
    if (pbHash)
        _nt_free(pbHash, cbHash);
    return fRet;
}

BOOL PCT1MakeExportableWriteKey(
                                PNTAGHashList pHash,
                                BYTE *pbBuff,
                                DWORD *pcbBuff
                                )
{
    BYTE        *pb = NULL;
    DWORD       cb;
    BYTE        *pbHash = NULL;
    DWORD       cbHash;
    PSCH_HASH   pSChHash;
    DWORD       fRet = FALSE;

    pSChHash = (PSCH_HASH)pHash->pHashData;

    // assumption is made that exportable keys are 16 bytes in length (RC4 & RC2)
    cb = 5 + *pcbBuff + pSChHash->cbClearData;

    if (NULL == (pb = (BYTE*)_nt_malloc(cb)))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Ret;
    }

    // form the buffer to be hashed
    pb[0] = 1;
    memcpy(pb + 1, "sl", 2);
    memcpy(pb + 3, pbBuff, *pcbBuff);
    memcpy(pb + 3 + *pcbBuff, "sl", 2);
    memcpy(pb + 5 + *pcbBuff, pSChHash->rgbClearData, pSChHash->cbClearData);

    if (!HelperHash(pHash->hUID, pb, cb, pSChHash->HashAlgid,
                    &pbHash, &cbHash, TRUE))
        goto Ret;

    *pcbBuff = cbHash;
    memcpy(pbBuff, pbHash, *pcbBuff);

    fRet = TRUE;
Ret:
    if (pb)
        _nt_free(pb, cb);
    if (pbHash)
        _nt_free(pbHash, cbHash);
    return fRet;
}


BOOL PCT1DeriveKey(
                   PNTAGUserList pTmpUser,
                   ALG_ID Algid,
                   PNTAGHashList pHash,
                   DWORD dwFlags,
                   HCRYPTKEY *phKey
                   )
{
    BYTE            rgbHashBuff[A_SHA_DIGEST_LEN * 2];  // SHA is largest hash and max is two concatenated
    DWORD           cbHashBuff = 0;
    BYTE            rgbTmpBuff[A_SHA_DIGEST_LEN * 2];  // SHA is largest hash and max is two concatenated
    DWORD           cbTmpBuff;
    DWORD           cb;
    DWORD           cbKey;
    PNTAGKeyList    pTmpKey = NULL;
    DWORD           i;
    DWORD           cHashes;
    ALG_ID          KeyAlgid;
    BOOL            fWriteKey = FALSE;
    PSCH_HASH       pSChHash;
    BYTE            rgbSalt[MAX_SALT_LEN];
    DWORD           cbSalt;
    BOOL            fRet = FALSE;
    DWORD           dwRights;

    memset(rgbSalt, 0, sizeof(rgbSalt));
    pSChHash = (PSCH_HASH)pHash->pHashData;

    switch(Algid)
    {
        case CALG_SCHANNEL_MAC_KEY:
            cbKey = pSChHash->cbEncMac;
            KeyAlgid = Algid;
            break;

        case CALG_SCHANNEL_ENC_KEY:
            fWriteKey = TRUE;
            cbKey = pSChHash->cbEnc;
            KeyAlgid = pSChHash->EncAlgid;
            break;

        default:
            SetLastError((DWORD)NTE_BAD_ALGID);
            goto Ret;
    }

    cHashes = (cbKey + (pSChHash->cbHash - 1)) / pSChHash->cbHash;
    if (cHashes > 2)
        goto Ret;

    for (i=0;i<cHashes;i++)
    {
        if (!PCT1MakeKeyHash(pHash, i + 1, dwFlags, fWriteKey,
                             rgbHashBuff + cbHashBuff, &cb))
            goto Ret;
        cbHashBuff += cb;
    }

    if ((CALG_SCHANNEL_ENC_KEY == Algid) &&
        (EXPORTABLE_KEYLEN == pSChHash->cbEnc))
    {
        cbHashBuff = cbKey;
        if (!PCT1MakeExportableWriteKey(pHash, rgbHashBuff, &cbHashBuff))
            goto Ret;

        cbSalt = EXPORTABLE_SALTLEN;
        memcpy(rgbSalt, rgbHashBuff + pSChHash->cbEnc, cbSalt);
    }

    // check if the key is CRYPT_EXPORTABLE
    if (dwFlags & CRYPT_EXPORTABLE)
        dwRights = CRYPT_EXPORTABLE;

    // make the new key
    if (NULL == (pTmpKey = MakeNewKey(KeyAlgid, dwRights, cbKey,
                                      pHash->hUID, rgbHashBuff,
                                      FALSE)))
        goto Ret;
    if (CALG_RC2 == KeyAlgid)
    {
        pTmpKey->EffectiveKeyLen = RC2_SCHANNEL_DEFAULT_EFFECTIVE_KEYLEN;
    }

    if ((CALG_SCHANNEL_ENC_KEY == Algid) &&
        (EXPORTABLE_KEYLEN == pSChHash->cbEnc))
    {
        pTmpKey->cbSaltLen = cbSalt;
        memcpy(pTmpKey->rgbSalt, rgbSalt, cbSalt);
    }

    // check keylength...
    if (!FIsLegalKey(pTmpUser, pTmpKey, FALSE))
        goto Ret;

    if (NTF_FAILED == NTLMakeItem(phKey, KEY_HANDLE, (void *)pTmpKey))
        goto Ret;

    fRet = TRUE;
Ret:
    if (FALSE == fRet)
    {
        if (pTmpKey)
        {
            FreeNewKey(pTmpKey);
        }
    }
    return fRet;
}

BOOL TLSDeriveExportableRCKey(
                              PSCH_HASH pSChHash,
                              BYTE *pbClientAndServer,
                              DWORD cbClientAndServer,
                              BYTE **ppbKey,
                              DWORD *pcbKey,
                              BYTE *pbSalt,
                              DWORD *pcbSalt,
                              DWORD dwFlags)
{
    BOOL    fRet = FALSE;

    // use key length 16 because this should only occur with RC2 and RC4
    // and those key lengths should be 16
    if ((CALG_RC2 == pSChHash->EncAlgid) || (CALG_RC4 == pSChHash->EncAlgid))
    {
        *pcbKey = RC_KEYLEN;
        *pcbSalt = RC_KEYLEN - pSChHash->cbEnc;
    }
    else
    {
        *pcbKey = pSChHash->cbEnc;
    }
    if (NULL == (*ppbKey = (BYTE*)_nt_malloc(*pcbKey)))
        goto Ret;

    // check if it is a server key or client key
    if (dwFlags & CRYPT_SERVER)
    {
        if (!PRF(pSChHash->rgbFinal + pSChHash->cbEncMac * 2 + pSChHash->cbEnc,
                 pSChHash->cbEnc, "server write key", 16,
                 pbClientAndServer, cbClientAndServer,
                 *ppbKey, *pcbKey))
        {
            goto Ret;
        }
    }
    else
    {
        if (!PRF(pSChHash->rgbFinal + pSChHash->cbEncMac * 2,
                 pSChHash->cbEnc, "client write key", 16,
                 pbClientAndServer, cbClientAndServer,
                 *ppbKey, *pcbKey))
        {
            goto Ret;
        }
    }

    if (0 != *pcbSalt)
    {
        memcpy(pbSalt, (*ppbKey) + pSChHash->cbEnc, *pcbSalt);
    }

    fRet = TRUE;
Ret:
    return fRet;
}

BOOL TLSDeriveExportableEncKey(
                               PSCH_HASH pSChHash,
                               BYTE **ppbKey,
                               DWORD *pcbKey,
                               BYTE **ppbRealKey,
                               BYTE *pbSalt,
                               DWORD *pcbSalt,
                               BYTE *pbIV,
                               DWORD dwFlags)
{
    BYTE    *pbClientAndServer = NULL;
    DWORD   cbClientAndServer;
    BYTE    *pbIVBlock = NULL;
    BOOL    fRet = FALSE;

    cbClientAndServer = pSChHash->cbClientRandom + pSChHash->cbServerRandom;
    if (NULL == (pbClientAndServer = (BYTE*)_nt_malloc(cbClientAndServer)))
        goto Ret;

    if (NULL == (pbIVBlock = (BYTE*)_nt_malloc(pSChHash->cbIV * 2)))
        goto Ret;

    // concatenate the server random and client random 
    memcpy(pbClientAndServer, pSChHash->rgbClientRandom,
           pSChHash->cbClientRandom);
    memcpy(pbClientAndServer + pSChHash->cbClientRandom,
           pSChHash->rgbServerRandom, pSChHash->cbServerRandom);

    // calculate the IV block
    if (pSChHash->cbIV)
    {
        if (!PRF(NULL, 0, "IV block", 8, pbClientAndServer,
                 cbClientAndServer, pbIVBlock, pSChHash->cbIV * 2))
        {
            goto Ret;
        }
        if (dwFlags & CRYPT_SERVER)
            memcpy(pbIV, pbIVBlock + pSChHash->cbIV, pSChHash->cbIV);
        else
            memcpy(pbIV, pbIVBlock, pSChHash->cbIV);
    }

    // check if it is a server key or client key
    if (!TLSDeriveExportableRCKey(pSChHash,
                                  pbClientAndServer,
                                  cbClientAndServer,
                                  ppbKey,
                                  pcbKey,
                                  pbSalt,
                                  pcbSalt,
                                  dwFlags))
    {
        goto Ret;
    }
    *ppbRealKey = *ppbKey;

    fRet = TRUE;
Ret:
    if (pbIVBlock)
        _nt_free(pbIVBlock, pSChHash->cbIV * 2);
    if (pbClientAndServer)
        _nt_free(pbClientAndServer, cbClientAndServer);
    return fRet;
}

BOOL TLSDeriveKey(
                  PNTAGUserList pTmpUser,
                  ALG_ID Algid,
                  PNTAGHashList pHash,
                  DWORD dwFlags,
                  HCRYPTKEY *phKey
                  )
{
    PSCH_HASH       pSChHash;
    PNTAGKeyList    pTmpKey = NULL;
    BYTE            *pbKey;
    DWORD           cbKey;
    BYTE            rgbSalt[MAX_SALT_LEN];
    DWORD           cbSalt = 0;
    BYTE            rgbIV[CRYPT_BLKLEN];
    DWORD           cbIVIndex;
    ALG_ID          KeyAlgid;
    BYTE            *pbAllocKey = NULL;
    DWORD           cbAllocKey;
    DWORD           dwRights = 0;
    BOOL            fRet = FALSE;

    memset(rgbIV, 0, sizeof(rgbIV));
    memset(rgbSalt, 0, sizeof(rgbSalt));
    pSChHash = (PSCH_HASH)pHash->pHashData;

    switch(Algid)
    {
        case CALG_SCHANNEL_MAC_KEY:
            cbKey = pSChHash->cbEncMac;
            KeyAlgid = Algid;

            // check if it is a server key or client key
            if (dwFlags & CRYPT_SERVER)
            {
                pbKey = pSChHash->rgbFinal + pSChHash->cbEncMac;
            }
            else
            {
                pbKey = pSChHash->rgbFinal;
            }
            break;

        case CALG_SCHANNEL_ENC_KEY:
            cbKey = pSChHash->cbEnc;
            KeyAlgid = pSChHash->EncAlgid;

            // if in exportable situation then call the exportable routine
            if (pSChHash->dwFlags & INTERNATIONAL_USAGE)
            {
                if (!TLSDeriveExportableEncKey(pSChHash, &pbAllocKey,
                                               &cbAllocKey, &pbKey, rgbSalt,
                                               &cbSalt, rgbIV, dwFlags))
                {
                    goto Ret;
                }
            }
            else
            {
                if (dwFlags & CRYPT_SERVER)
                {
                    pbKey = pSChHash->rgbFinal + pSChHash->cbEncMac * 2 +
                            pSChHash->cbEnc;

                    if (pSChHash->cbIV)
                    {
                        cbIVIndex = pSChHash->cbEncMac * 2 + 
                                    pSChHash->cbEnc * 2 + pSChHash->cbIV;
                    }
                }
                else
                {
                    pbKey = pSChHash->rgbFinal + pSChHash->cbEncMac * 2;

                    if (pSChHash->cbIV)
                    {
                        cbIVIndex = pSChHash->cbEncMac * 2 +
                                    pSChHash->cbEnc * 2;
                    }
                }
                memcpy(rgbIV, pSChHash->rgbFinal + cbIVIndex,
                       pSChHash->cbIV);
            }
            break;

        default:
            SetLastError((DWORD)NTE_BAD_ALGID);
            goto Ret;
    }

    // check if the key is CRYPT_EXPORTABLE
    if (dwFlags & CRYPT_EXPORTABLE)
        dwRights = CRYPT_EXPORTABLE;

    // make the new key
    if (NULL == (pTmpKey = MakeNewKey(KeyAlgid, dwRights, cbKey,
                                      pHash->hUID, pbKey,
                                      FALSE)))
        goto Ret;
    if (CALG_RC2 == KeyAlgid)
    {
        pTmpKey->EffectiveKeyLen = RC2_SCHANNEL_DEFAULT_EFFECTIVE_KEYLEN;
    }

    // set up the salt
    memcpy(pTmpKey->rgbSalt, rgbSalt, cbSalt);
    pTmpKey->cbSaltLen = cbSalt;

    // copy IV if necessary
    if (pSChHash->cbIV)
    {
        memcpy(pTmpKey->IV, rgbIV, pSChHash->cbIV);
    }

    // check keylength...
    if (!FIsLegalKey(pTmpUser, pTmpKey, FALSE))
        goto Ret;

    if (NTF_FAILED == NTLMakeItem(phKey, KEY_HANDLE, (void *)pTmpKey))
        goto Ret;

    fRet = TRUE;
Ret:
    if (pbAllocKey)
        _nt_free(pbAllocKey, cbAllocKey);
    if (FALSE == fRet)
    {
        if (pTmpKey)
        {
            FreeNewKey(pTmpKey);
        }
    }
    return fRet;
}

BOOL SSL2DeriveKey(
                   PNTAGUserList pTmpUser,
                   ALG_ID Algid,
                   PNTAGHashList pHash,
                   DWORD dwFlags,
                   HCRYPTKEY *phKey
                   )
{
    PSCH_HASH       pSChHash;
    BYTE            rgbHash[2 * MD5DIGESTLEN];
    BYTE            *pbHash;
    DWORD           cbHash = 2 * MD5DIGESTLEN;
    BYTE            *pbTmp = NULL;
    DWORD           cbTmp;
    BYTE            *pbKey;
    DWORD           cbKey;
    BYTE            rgbSalt[MAX_SALT_LEN];
    DWORD           cbSalt = 0;
    DWORD           cbIndex;
    DWORD           cbChangeByte;
    PNTAGKeyList    pTmpKey = NULL;
    BOOL            fRet = FALSE;
    DWORD           dwRights = 0;

    memset(rgbSalt, 0, sizeof(rgbSalt));

    if (CALG_SCHANNEL_ENC_KEY != Algid)
    {
        SetLastError((DWORD)NTE_BAD_ALGID);
        goto Ret;
    }

    pbHash = rgbHash;
    pSChHash = (PSCH_HASH)pHash->pHashData;

    // set up the buffer to be hashed 
    cbTmp = pSChHash->cbFinal + pSChHash->cbClearData +
            pSChHash->cbClientRandom + pSChHash->cbServerRandom + 1;

    if (NULL == (pbTmp = (BYTE*)_nt_malloc(cbTmp)))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Ret;
    }
    memcpy(pbTmp, pSChHash->rgbClearData,
           pSChHash->cbClearData);
    cbIndex = pSChHash->cbClearData;

    // exportability check
    memcpy(pbTmp + cbIndex, pSChHash->rgbFinal, pSChHash->cbFinal);
    cbIndex += pSChHash->cbFinal;

    cbChangeByte = cbIndex;
    cbIndex++;

    memcpy(pbTmp + cbIndex, pSChHash->rgbClientRandom,
           pSChHash->cbClientRandom);
    cbIndex += pSChHash->cbClientRandom;
    memcpy(pbTmp + cbIndex, pSChHash->rgbServerRandom,
           pSChHash->cbServerRandom);
    cbIndex += pSChHash->cbServerRandom;

    switch(pSChHash->EncAlgid)
    {
#ifdef CSP_USE_RC2
        case CALG_RC2:
#endif
#ifdef CSP_USE_RC4
        case CALG_RC4:
#endif
            if (CRYPT_SERVER & dwFlags)
            {
                pbTmp[cbChangeByte] = 0x30;
            }
            else
            {
                pbTmp[cbChangeByte] = 0x31;
            }
            
            // hash the data to get the key
            if (!HelperHash(pHash->hUID, pbTmp, cbTmp, CALG_MD5,
                            &pbHash, &cbHash, FALSE))
                goto Ret;

            pbKey = pbHash;

            // check for export
            if (pSChHash->cbClearData)
            {
                cbKey = 5;
                cbSalt = 11;
                memcpy(rgbSalt, pbKey + cbKey, cbSalt);
            }
            else
            {
                cbKey = 16;
            }
            break;

#ifdef CSP_USE_DES
        case CALG_DES:
            pbTmp[cbChangeByte] = 0x30;
            // hash the data to get the key
            if (!HelperHash(pHash->hUID, pbTmp, cbTmp,
                            CALG_MD5, &pbHash, &cbHash, FALSE))
                goto Ret;

            if (CRYPT_SERVER & dwFlags)
            {
                pbKey = pbHash;
            }
            else
            {
                pbKey = pbHash + DES_KEYSIZE;
            }
            cbKey = DES_KEYSIZE;
            break;
#endif

#ifdef CSP_USE_3DES
        case CALG_3DES:
            if (CRYPT_SERVER & dwFlags)
            {
                pbTmp[cbChangeByte] = 0x30;
                // hash the data to get the key
                if (!HelperHash(pHash->hUID, pbTmp, cbTmp,
                                CALG_MD5, &pbHash, &cbHash, FALSE))
                    goto Ret;

                pbTmp[cbChangeByte] = 0x31;
                pbHash = rgbHash + MD5DIGESTLEN;
                // hash the data to get the key
                if (!HelperHash(pHash->hUID, pbTmp, cbTmp, CALG_MD5,
                                &pbHash, &cbHash, FALSE))
                    goto Ret;
                pbKey = rgbHash;
            }
            else
            {
                pbTmp[cbChangeByte] = 0x31;
                // hash the data to get the key
                if (!HelperHash(pHash->hUID, pbTmp, cbTmp,
                                CALG_MD5, &pbHash, &cbHash, FALSE))
                    goto Ret;

                pbTmp[cbChangeByte] = 0x32;
                pbHash = rgbHash + MD5DIGESTLEN;
                // hash the data to get the key
                if (!HelperHash(pHash->hUID, pbTmp, cbTmp, CALG_MD5,
                                &pbHash, &cbHash, FALSE))
                    goto Ret;
                pbKey = rgbHash + DES_KEYSIZE;
            }
            cbKey = DES3_KEYSIZE;
            break;
#endif
    }

    // check if the key is CRYPT_EXPORTABLE
    if (dwFlags & CRYPT_EXPORTABLE)
        dwRights = CRYPT_EXPORTABLE;

    // make the new key
    if (NULL == (pTmpKey = MakeNewKey(pSChHash->EncAlgid,
                                      dwRights,
                                      cbKey,
                                      pHash->hUID,
                                      pbKey,
                                      FALSE)))
    {
        goto Ret;
    }

    if (CALG_RC2 == pSChHash->EncAlgid)
    {
        pTmpKey->EffectiveKeyLen = RC2_SCHANNEL_DEFAULT_EFFECTIVE_KEYLEN;
    }

    pTmpKey->cbSaltLen = cbSalt;
    memcpy(pTmpKey->rgbSalt, rgbSalt, cbSalt);

    // check keylength...
    if (!FIsLegalKey(pTmpUser, pTmpKey, FALSE))
        goto Ret;

    if (NTF_FAILED == NTLMakeItem(phKey, KEY_HANDLE, (void *)pTmpKey))
        goto Ret;

    fRet = TRUE;
Ret:
    if (pbTmp)
        _nt_free(pbTmp, cbTmp);
    if (FALSE == fRet)
    {
        if (pTmpKey)
        {
            FreeNewKey(pTmpKey);
        }
    }
    return fRet;
}

BOOL SecureChannelDeriveKey(
                            PNTAGUserList pTmpUser,
                            PNTAGHashList pHash,
                            ALG_ID Algid,
                            DWORD dwFlags,
                            HCRYPTKEY *phKey
                            )
{
    PSCH_HASH       pSChHash;
    BYTE            *pbKey = NULL;
    DWORD           cbKey;
    PNTAGKeyList    pTmpKey = NULL;
    BOOL            fRet = FALSE;
    DWORD           dwRights;

    pSChHash = (PSCH_HASH)pHash->pHashData;

    switch(pSChHash->ProtocolAlgid)
    {
        case CALG_SSL3_MASTER:
            switch(Algid)
            {
                case CALG_SCHANNEL_MAC_KEY:
                    cbKey = pSChHash->cbEncMac;
                    if (NULL == (pbKey = (BYTE*)_nt_malloc(cbKey)))
                    {
                        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                        goto Ret;
                    }

                    // if not flagged as a server key then default is client
                    if (CRYPT_SERVER & dwFlags)
                    {
                        memcpy(pbKey, pSChHash->rgbFinal + cbKey, cbKey);
                    }
                    else
                    {
                        memcpy(pbKey, pSChHash->rgbFinal, cbKey);
                    }

                    // check if the key is CRYPT_EXPORTABLE
                    if (dwFlags & CRYPT_EXPORTABLE)
                        dwRights = CRYPT_EXPORTABLE;

                    // make the new key
                    if (NULL == (pTmpKey = MakeNewKey(Algid,
                                                      dwRights,
                                                      cbKey,
                                                      pHash->hUID,
                                                      pbKey,
                                                      TRUE)))
                    {
                        goto Ret;
                    }
                    pbKey = NULL;

                    // check keylength...
                    if (!FIsLegalKey(pTmpUser, pTmpKey, FALSE))
                        goto Ret;

                    if (NTF_FAILED == NTLMakeItem(phKey, KEY_HANDLE, (void *)pTmpKey))
                        goto Ret;

                    break;

                case CALG_SCHANNEL_ENC_KEY:
                    // derive the write keys
                    if (!SSL3DeriveWriteKey(pTmpUser, pHash, dwFlags, phKey))
                        goto Ret;
                    break;

                default:
                    SetLastError((DWORD)NTE_BAD_ALGID);
                    goto Ret;
            }
            break;

        case CALG_PCT1_MASTER:
            // derive the PCT1 key
            if (!PCT1DeriveKey(pTmpUser, Algid, pHash, dwFlags, phKey))
                goto Ret;
            break;

        case CALG_TLS1_MASTER:
            // derive the PCT1 key
            if (!TLSDeriveKey(pTmpUser, Algid, pHash, dwFlags, phKey))
                goto Ret;
            break;

        case CALG_SSL2_MASTER:
            // derive the PCT1 key
            if (!SSL2DeriveKey(pTmpUser, Algid, pHash, dwFlags, phKey))
                goto Ret;
            break;
    }

    fRet = TRUE;
Ret:
    if (pbKey)
        _nt_free(pbKey, cbKey);
    if ((FALSE == fRet) && pTmpKey)
    {
        FreeNewKey(pTmpKey);
    }
    return fRet;
}

BOOL SetPRFHashParam(
                     PRF_HASH *pPRFHash,
                     DWORD dwParam,
                     BYTE *pbData
                     )
{
    CRYPT_DATA_BLOB *pBlob;
    BOOL            fRet = FALSE;

    pBlob = (CRYPT_DATA_BLOB*)pbData;

    if (HP_TLS1PRF_LABEL == dwParam)
    {
        if (pBlob->cbData > sizeof(pPRFHash->rgbLabel))
        {
            SetLastError((DWORD)NTE_BAD_DATA);
            goto Ret;
        }
        pPRFHash->cbLabel = pBlob->cbData;
        memcpy(pPRFHash->rgbLabel, pBlob->pbData, pBlob->cbData);
    }
    else
    {
        if (pBlob->cbData > sizeof(pPRFHash->rgbSeed))
        {
            SetLastError((DWORD)NTE_BAD_DATA);
            goto Ret;
        }
        pPRFHash->cbSeed = pBlob->cbData;
        memcpy(pPRFHash->rgbSeed, pBlob->pbData, pBlob->cbData);
    }

    fRet = TRUE;
Ret:
    return fRet;
}

BOOL CalculatePRF(
                  PRF_HASH *pPRFHash,
                  BYTE *pbData,
                  DWORD *pcbData
                  )
{
    BOOL    fRet = FALSE;

    if (NULL == pbData)
    {
        *pcbData = 0;
    }
    else
    {
        if ((0 == pPRFHash->cbSeed) || (0 == pPRFHash->cbLabel))
        {
            SetLastError((DWORD)NTE_BAD_HASH_STATE);
            goto Ret;
        }

        if (!PRF(pPRFHash->rgbMasterKey, sizeof(pPRFHash->rgbMasterKey),
                 pPRFHash->rgbLabel, pPRFHash->cbLabel,
                 pPRFHash->rgbSeed, pPRFHash->cbSeed,
                 pbData, *pcbData))
        {
            SetLastError((DWORD)NTE_FAIL);
            goto Ret;
        }
    }

    fRet = TRUE;
Ret:
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\rsabase\swnt_pk.c ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : swnt_pk.c                                              //
//  DESCRIPTION   :                                                        //
//  Software nametag public key management functions.  These functions     //
//  isolate the peculiarities of public key management without a token     // 
//                                                                         //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//  Jan 25 1995 larrys   Changed from Nametag                              //
//  Mar 01 1995 terences Fixed key pair handle creation                    //
//  Mar 08 1995 larrys   Fixed warning                                     //
//  Mar 23 1995 larrys   Added variable key length                         //
//  Apr 17 1995 larrys   Added 1024 key gen                                //
//  Apr 19 1995 larrys   Changed CRYPT_EXCH_PUB to AT_KEYEXCHANGE          //
//  Aug 16 1995 larrys   Removed exchange key stuff                        //
//  Sep 12 1995 larrys   Removed 2 DWORDS from exported keys               //
//  Sep 28 1995 larrys   Changed format of PKCS                            //
//  Oct 04 1995 larrys   Fixed problem with PKCS format                    //
//  Oct 27 1995 rajeshk  RandSeed Stuff added hUID to PKCS2Encrypt         //
//  Nov  3 1995 larrys   Merge for NT checkin                              //
//  Dec 11 1995 larrys   Added check for error return from RSA routine     //
//  May 15 1996 larrys  Changed NTE_NO_MEMORY to ERROR_NOT_ENOUGHT...      //
//  Oct 14 1996 jeffspel Changed GenRandoms to NewGenRandoms               //
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "randlib.h"
#include "ntagum.h"
#include "swnt_pk.h"
#include "protstor.h"
#include "sha.h"
#include "rng.h"

extern CSP_STRINGS g_Strings;

void FIPS186GenRandomWithException(
                      IN HANDLE *phRNGDriver,
                      IN BYTE **ppbContextSeed,
                      IN DWORD *pcbContextSeed,
                      IN OUT BYTE *pb,
                      IN DWORD cb
                      );

// do the modular exponentiation calculation M^PubKey mod N
DWORD RSAPublicEncrypt(
                       IN PEXPO_OFFLOAD_STRUCT pOffloadInfo,
                       IN BSAFE_PUB_KEY *pBSPubKey,
                       IN BYTE *pbInput,
                       IN BYTE *pbOutput
                       )
{
    BOOL            fOffloadSuccess = FALSE;
    DWORD           cbMod;
    DWORD           dw = 1;

    //
    // Two checks (needed for FIPS) before offloading to the offload
    // module.
    //
    // First check is if there is an offload module, this
    // will only be the case if the pOffloadInfo is not NULL.
    //
    // Second check is if this public key is OK, by checking
    // the magic value in the key struct.
    //
    if (NULL != pOffloadInfo)
    {
        if (RSA1 != pBSPubKey->magic)
        {
            SetLastError((DWORD)NTE_BAD_KEY);
            goto Ret;
        }

        cbMod = (pBSPubKey->bitlen + 7) / 8;
        fOffloadSuccess = ModularExpOffload(pOffloadInfo,
                                            pbInput,
                                            (BYTE*)&(pBSPubKey->pubexp),
                                            sizeof(pBSPubKey->pubexp),
                                            (BYTE*)pBSPubKey +
                                                   sizeof(BSAFE_PUB_KEY),
                                            cbMod, pbOutput, NULL, 0);
    }

    if (!fOffloadSuccess)
    {
        BSafeEncPublic(pBSPubKey, pbInput, pbOutput);
        dw = 0;
    }
    else
    {
        dw = 0;
    }
Ret:
    return dw;
}

// do the modular exponentiation calculation M^PrivKey Exponent mod N
DWORD RSAPrivateDecrypt(
                        IN PEXPO_OFFLOAD_STRUCT pOffloadInfo,
                        IN BSAFE_PRV_KEY *pBSPrivKey,
                        IN BYTE *pbInput,
                        IN BYTE *pbOutput
                        )
{
    BOOL            fOffloadSuccess = FALSE;
    DWORD           cbMod;
    DWORD           cbHalfKeylen;
    DWORD           dw = 1;

    //
    // Two checks (needed for FIPS) before offloading to the offload
    // module.
    //
    // First check is if there is an offload module, this
    // will only be the case if the pOffloadInfo is not NULL.
    //
    // Second check is if this private key is OK, by checking
    // the magic value in the key struct.
    //
    if (NULL != pOffloadInfo)
    {
        if (RSA2 != pBSPrivKey->magic)
        {
            SetLastError((DWORD)NTE_BAD_KEY);
            goto Ret;
        }

        cbMod = (pBSPrivKey->bitlen + 7) / 8;
        cbHalfKeylen = (pBSPrivKey->keylen + 1) / 2;
        fOffloadSuccess = ModularExpOffload(pOffloadInfo,
                                    pbInput,
                                    (BYTE*)pBSPrivKey + sizeof(BSAFE_PUB_KEY)
                                           + cbHalfKeylen * 7,
                                    cbMod,
                                    (BYTE*)pBSPrivKey + sizeof(BSAFE_PUB_KEY),
                                    cbMod, pbOutput, NULL, 0);
    }

    if (!fOffloadSuccess)
    {
        BSafeDecPrivate(pBSPrivKey, pbInput, pbOutput)
        dw = 0;
    }
    else
    {
        dw = 0;
    }
Ret:
    return dw;
}

BOOL CheckDataLenForRSAEncrypt(
                               IN DWORD cbMod,   // length of the modulus
                               IN DWORD cbData,  // length of the data
                               IN DWORD dwFlags  // flags
                               )
{
    BOOL    fRet = FALSE;

    // if the OAEP flag is set then check for that length
    if (dwFlags & CRYPT_OAEP)
    {
        if (cbMod < (cbData + A_SHA_DIGEST_LEN * 2 + 1))
            goto Ret;
    }
    // Check for PKCS 1 type 2 padding
    else
    {
        // one byte for the top zero byte, one byte for the type,
        // and one byte for the low zero byte,
        // plus a minimum padding string is 8 bytes
        if (cbMod < (cbData + 11))
            goto Ret;
    }
    fRet = TRUE;
Ret:
    return fRet;
}

/************************************************************************/
/* MaskGeneration generates a mask for OAEP based on the SHA1 hash      */
/* function.                                                            */
/* NULL for the ppbMask parameter indicates the buffer is to be alloced.*/
/************************************************************************/
BOOL MaskGeneration(
                    IN BYTE *pbSeed,
                    IN DWORD cbSeed,
                    IN DWORD cbMask,
                    OUT BYTE **ppbMask,
                    IN BOOL fAlloc
                    )
{
    DWORD       dwCount;
    BYTE        rgbCount[sizeof(DWORD)];
    BYTE        *pbCount;
    A_SHA_CTX   SHA1Ctxt;
    DWORD       cb = cbMask;
    BYTE        *pb;
    DWORD       i;
    DWORD       j;
    BOOL        fRet = FALSE;

    // NULL for *ppbMask indicates the buffer is to be alloced
    if (fAlloc)
    {
        if (NULL == (*ppbMask = (BYTE*)_nt_malloc(cbMask)))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }
    }
    pb = *ppbMask;

    dwCount = (cbMask + (A_SHA_DIGEST_LEN - 1)) / A_SHA_DIGEST_LEN;

    for (i = 0; i < dwCount; i++)
    {
        // clear the hash context
        memset(&SHA1Ctxt, 0, sizeof(SHA1Ctxt));

        // hash the seed and the count
        A_SHAInit(&SHA1Ctxt);
        A_SHAUpdate(&SHA1Ctxt, pbSeed, cbSeed);
        // Reverse the count bytes
        pbCount = (BYTE*)&i;
        for (j = 0; j < sizeof(DWORD); j++)
        {
            rgbCount[j] = pbCount[sizeof(DWORD) - j - 1];
        }
        A_SHAUpdate(&SHA1Ctxt, rgbCount, sizeof(DWORD));
        A_SHAFinal(&SHA1Ctxt, SHA1Ctxt.HashVal);

        // copy the bytes from this hash into the mask buffer
        if (cb >= A_SHA_DIGEST_LEN)
        {
            memcpy(pb, SHA1Ctxt.HashVal, A_SHA_DIGEST_LEN);
        }
        else
        {
            memcpy(pb, SHA1Ctxt.HashVal, cb);
            break;
        }
        cb -= A_SHA_DIGEST_LEN;
        pb += A_SHA_DIGEST_LEN;
    }

    fRet = TRUE;
Ret:
    return fRet;
}

/************************************************************************/
/* ApplyPadding applies OAEP (Bellare-Rogoway) padding to a RSA key     */
/* blob.  The function does the seed generation, MGF and masking.       */
/************************************************************************/
BOOL ApplyPadding (
                   IN PNTAGUserList pTmpUser,
                   IN OUT BYTE* pb,             // buffer
                   IN DWORD cb                  // length of the data to mask
                                                // not including seed
                   )
{
    BYTE        rgbSeed[A_SHA_DIGEST_LEN];
    BYTE        rgbDigest[A_SHA_DIGEST_LEN];
    BYTE        *pbMask = NULL;
    BYTE        rgbSeedMask[A_SHA_DIGEST_LEN];
    BYTE        *pbSeedMask;
    DWORD       i;
    BOOL        fRet = FALSE;

    // generate the random seed
    if (!FIPS186GenRandom(&pTmpUser->hRNGDriver,
                          &pTmpUser->ContInfo.pbRandom,
                          &pTmpUser->ContInfo.ContLens.cbRandom,
                          rgbSeed, A_SHA_DIGEST_LEN))
    {
        SetLastError((DWORD)NTE_FAIL);
        goto Ret;
    }

    // generate the data mask from the seed
    if (!MaskGeneration(rgbSeed, sizeof(rgbSeed), cb, &pbMask, TRUE))
    {
        goto Ret;
    }

    // XOR the data mask with the data
    for (i = 0; i < cb; i++)
    {
        pb[i + A_SHA_DIGEST_LEN + 1] = pb[i + A_SHA_DIGEST_LEN + 1] ^ pbMask[i];
    }

    // generate the seed mask from the masked data
    pbSeedMask = rgbSeedMask;
    if (!MaskGeneration(pb + A_SHA_DIGEST_LEN + 1, cb,
                        A_SHA_DIGEST_LEN, &pbSeedMask, FALSE))
    {
        goto Ret;
    }

    // XOR the seed mask with the seed and put that into the
    // pb buffer
    for (i = 0; i < A_SHA_DIGEST_LEN; i++)
    {
        pb[i + 1] = rgbSeed[i] ^ rgbSeedMask[i];
    }

    fRet = TRUE;
Ret:
    if (pbMask)
        _nt_free(pbMask, cb);
    return fRet;
}

/************************************************************************/
/* RemovePadding checks OAEP (Bellare-Rogoway) padding on a RSA decrypt */
/* blob.                                                                */
/************************************************************************/
BOOL RemovePadding (
                    IN OUT BYTE* pb,
                    IN DWORD cb
                    )
{
    BYTE    rgbSeedMask[A_SHA_DIGEST_LEN];
    BYTE    *pbSeedMask;
    BYTE    *pbMask = NULL;
    DWORD   i;
    BOOL    fRet = FALSE;

    memset(rgbSeedMask, 0, A_SHA_DIGEST_LEN);

    // check the most significant byte is 0x00
    if (0x00 != pb[0])
    {
        SetLastError((DWORD)NTE_BAD_DATA);
        goto Ret;
    }

    // generate the seed mask from the masked data
    pbSeedMask = rgbSeedMask;
    if (!MaskGeneration(pb + A_SHA_DIGEST_LEN + 1, cb - (A_SHA_DIGEST_LEN + 1),
                        A_SHA_DIGEST_LEN, &pbSeedMask, FALSE))
    {
        goto Ret;
    }

    // XOR the seed mask with the seed and put that into the
    // pb buffer
    for (i = 0; i < A_SHA_DIGEST_LEN; i++)
    {
        pb[i + 1] = pb[i + 1] ^ rgbSeedMask[i];
    }

    // generate the data mask from the seed
    if (!MaskGeneration(pb + 1, A_SHA_DIGEST_LEN,
                        cb - (A_SHA_DIGEST_LEN + 1), &pbMask, TRUE))
    {
        goto Ret;
    }

    // XOR the data mask with the data
    for (i = 0; i < cb - (A_SHA_DIGEST_LEN + 1); i++)
    {
        pb[i + A_SHA_DIGEST_LEN + 1] =
            pb[i + A_SHA_DIGEST_LEN + 1] ^ pbMask[i];
    }

    fRet = TRUE;
Ret:
    if (pbMask)
        _nt_free(pbMask, cb - (A_SHA_DIGEST_LEN + 1));
    return fRet;
}

/************************************************************************/
/* OAEPEncrypt performs a RSA encryption using OAEP (Bellare-Rogoway)   */
/* as the padding scheme.  The current implementation uses SHA1 as the  */
/* hash function.                                                       */
/************************************************************************/
BOOL OAEPEncrypt(
                IN PNTAGUserList pTmpUser,
                IN BSAFE_PUB_KEY *pBSPubKey,
                IN BYTE *pbPlaintext,
                IN DWORD cbPlaintext,
                IN BYTE *pbParams,
                IN DWORD cbParams,
                OUT BYTE *pbOut
                )
{
    BYTE        *pbInput = NULL;
    BYTE        *pbOutput = NULL;
    BYTE        *pbReverse = NULL;
    DWORD       dwLen;
    A_SHA_CTX   SHA1Ctxt;
    DWORD       i;
    DWORD       cb;
    DWORD       dwLastErr = 0;
    BOOL        fSucc = FALSE;

    memset(&SHA1Ctxt, 0, sizeof(SHA1Ctxt));

    // start off by hashing the Encoding parameters (pbParams)
    A_SHAInit(&SHA1Ctxt);
    if (0 != cbParams)
    {
        A_SHAUpdate(&SHA1Ctxt, pbParams, cbParams);
    }
    A_SHAFinal(&SHA1Ctxt, SHA1Ctxt.HashVal);

    // alloc space for an internal buffer
    if(NULL == (pbInput = (BYTE *)_nt_malloc(pBSPubKey->keylen * 2 +
                                             ((pBSPubKey->bitlen + 7) / 8))))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Ret;
    }
    pbOutput = pbInput + pBSPubKey->keylen;
    pbReverse = pbInput + pBSPubKey->keylen * 2;

    // add the pHash
    memcpy(pbReverse + A_SHA_DIGEST_LEN + 1, SHA1Ctxt.HashVal,
           A_SHA_DIGEST_LEN);

    // figure the length of PS, 

    // put the 0x01 byte in, skipping past the PS,
    // note that the PS is zero bytes so it is just there
    cb = ((pBSPubKey->bitlen + 7) / 8) - (1 + cbPlaintext);
    pbReverse[cb] = 0x01;
    cb++;

    // copy in the message bytes
    memcpy(pbReverse + cb, pbPlaintext, cbPlaintext);

    // do the seed generation, MGF and masking
    cb = ((pBSPubKey->bitlen + 7) / 8) - (A_SHA_DIGEST_LEN + 1);
    if (!ApplyPadding(pTmpUser, pbReverse, cb))
    {
        goto Ret;
    }

    // byte reverse the whole thing before RSA encrypting
    for (i = 0; i < (pBSPubKey->bitlen + 7) / 8; i++)
    {
        pbInput[i] = pbReverse[((pBSPubKey->bitlen + 7) / 8) - i - 1];
    }

    // RSA encrypt this
    if (0 != RSAPublicEncrypt(pTmpUser->pOffloadInfo, pBSPubKey, pbInput, pbOutput))
    {
        SetLastError((DWORD)NTE_FAIL);
        goto Ret;
    }

    memcpy(pbOut, pbOutput, (pBSPubKey->bitlen + 7) / 8);

    fSucc = TRUE;
Ret:
    if (pbInput)
    {
        memset(pbInput, 0, pBSPubKey->keylen * 2 + (pBSPubKey->bitlen + 7) / 8);
        _nt_free(pbInput, pBSPubKey->keylen * 2 + (pBSPubKey->bitlen + 7) / 8);
    }

    return fSucc;
}

/************************************************************************/
/* OAEPDecrypt performs a RSA decryption checking that OAEP             */
/* (Bellare-Rogoway) is the padding scheme.  The current implementation */
/* uses SHA1 as the hash function.                                      */
/************************************************************************/
BOOL OAEPDecrypt(
                IN PNTAGUserList pTmpUser,
                IN BSAFE_PRV_KEY *pBSPrivKey,
                IN BYTE *pbBlob,
                IN DWORD cbBlob,
                IN BYTE *pbParams,
                IN DWORD cbParams,
                OUT BYTE **ppbPlaintext,
                OUT DWORD *pcbPlaintext
                )
{
    BYTE*       pbOutput = NULL;
    BYTE*       pbInput = NULL;
    BYTE*       pbReverse = NULL;
    A_SHA_CTX   SHA1Ctxt;
    DWORD       cb;
    DWORD       i;
    BOOL        fRet = FALSE;

    memset(&SHA1Ctxt, 0, sizeof(SHA1Ctxt));

    cb = (pBSPrivKey->bitlen + 7) / 8;
    if (cbBlob > cb)
    {
        SetLastError((DWORD)NTE_BAD_DATA);
        goto Ret;
    }

    if (NULL == (pbOutput = (BYTE *)_nt_malloc((pBSPrivKey->keylen + 2) * 2 + cb)))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Ret;
    }
    pbInput = pbOutput + pBSPrivKey->keylen + 2;
    pbReverse = pbOutput + (pBSPrivKey->keylen + 2) * 2;

    // perform the RSA decryption
    memcpy(pbInput, pbBlob, cb);
    if (0 != RSAPrivateDecrypt(pTmpUser->pOffloadInfo, pBSPrivKey, pbInput, pbOutput))
    {
        SetLastError((DWORD)NTE_FAIL);
        goto Ret;
    }

    for (i = 0; i < cb; i++)
    {
        pbReverse[i] = pbOutput[cb - i - 1];
    }
    // remove OAEP (Bellare-Rogoway) padding
    if (!RemovePadding(pbReverse, cb))
    {
        goto Ret;
    }

    // hash the Encoding parameters (pbParams)
    A_SHAInit(&SHA1Ctxt);
    if (0 != cbParams)
    {
        A_SHAUpdate(&SHA1Ctxt, pbParams, cbParams);
    }
    A_SHAFinal(&SHA1Ctxt, SHA1Ctxt.HashVal);

    // check the hash of the encoding parameters against the message
    if (0 != memcmp(SHA1Ctxt.HashVal, pbReverse + A_SHA_DIGEST_LEN + 1,
                    A_SHA_DIGEST_LEN))
    {
        SetLastError((DWORD)NTE_BAD_DATA);
        goto Ret;
    }

    // check the zero bytes and check the 0x01 byte
    for (i = A_SHA_DIGEST_LEN * 2 + 1; i < cb; i++)
    {
        if (0x01 == pbReverse[i])
        {
            i++;
            break;
        }
        else if (0x00 != pbReverse[i])
        {
            SetLastError((DWORD)NTE_BAD_DATA);
            goto Ret;
        }
    }

    *pcbPlaintext = cb - i;
    if (NULL == (*ppbPlaintext = (BYTE*)_nt_malloc(*pcbPlaintext)))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Ret;
    }
    memcpy(*ppbPlaintext, pbReverse + i, *pcbPlaintext);

    fRet = TRUE;
Ret:
    // scrub the output buffer
    if (pbOutput)
    {
        memset(pbOutput, 0, pBSPrivKey->keylen * 2 + cb);
        _nt_free(pbOutput, pBSPrivKey->keylen * 2 + cb);
    }

    return fRet;
}


BOOL PKCS2Encrypt(
                  PNTAGUserList pTmpUser,
                  DWORD dwFlags,
                  BSAFE_PUB_KEY *pKey,
                  BYTE *InBuf,
                  DWORD InBufLen,
                  BYTE *OutBuf
                  )
{
    DWORD   i;
    BYTE    *pScratch = NULL;
    BYTE    *pScratch2 = NULL;
    BYTE    *pLocal;
    DWORD   temp;
    DWORD   z;
    BOOL    fRet = FALSE;

    if ((pScratch = (BYTE *)_nt_malloc(pKey->keylen)) == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Ret;
    }

    if ((pScratch2 = (BYTE *)_nt_malloc(pKey->keylen)) == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Ret;
    }
    
    memset(pScratch, 0, pKey->keylen);

    pScratch[pKey->datalen - 1] = PKCS_BLOCKTYPE_2;
    if (!FIPS186GenRandom(&pTmpUser->hRNGDriver,
                          &pTmpUser->ContInfo.pbRandom,
                          &pTmpUser->ContInfo.ContLens.cbRandom,
                          pScratch+InBufLen+1, (pKey->datalen)-InBufLen-2))
    {
        SetLastError(NTE_FAIL);
        goto Ret;
    }

    pLocal = pScratch + InBufLen + 1;

    // Need to insure that none of the padding bytes are zero.
    temp = pKey->datalen - InBufLen - 2;
    while (temp)
    {
        if (*pLocal == 0)
        {
            if (!FIPS186GenRandom(&pTmpUser->hRNGDriver,
                                  &pTmpUser->ContInfo.pbRandom,
                                  &pTmpUser->ContInfo.ContLens.cbRandom,
                                  pLocal, 1))
            {
                SetLastError(NTE_FAIL);
                goto Ret;
            }
        }
        else
        {
            pLocal++;
            temp--;
        }
    }
    
#ifdef CSP_USE_SSL3
    // if SSL2_FALLBACK has been specified then put threes in the 8
    // least significant bytes of the random padding
    if (CRYPT_SSL2_FALLBACK & dwFlags)
    {
        memset(pScratch + InBufLen + 1, 0x03, 8);
    }
#endif

    // Reverse the session key bytes
    for (z = 0; z < InBufLen; ++z) pScratch[z] = InBuf[InBufLen - z - 1];

    if (0 != RSAPublicEncrypt(pTmpUser->pOffloadInfo, pKey, pScratch, pScratch2))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Ret;
    }

    memcpy(OutBuf, pScratch2, pKey->keylen - 2*sizeof(DWORD));

    fRet = TRUE;
Ret:
    if (pScratch)
        _nt_free(pScratch, pKey->keylen);
    if (pScratch2)
        _nt_free(pScratch2, pKey->keylen);
    
    return fRet;
}

BOOL PKCS2Decrypt(
                  IN PNTAGUserList pTmpUser,
                  IN BSAFE_PRV_KEY *pKey,
                  IN DWORD dwFlags,
                  IN BYTE *InBuf,
                  OUT BYTE **ppbOutBuf,
                  OUT DWORD *pcbOutBuf)
{
    DWORD   i;
    BYTE    *pScratch = NULL;
    BYTE    *pScratch2 = NULL;
    DWORD   z;
    BOOL    fRet = FALSE;

    if (NULL == (pScratch = (BYTE *)_nt_malloc(pKey->keylen * 2)))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Ret;
    }
    pScratch2 = pScratch + pKey->keylen;

    memcpy(pScratch2, InBuf, pKey->keylen - 2*sizeof(DWORD));

    if (0 != RSAPrivateDecrypt(pTmpUser->pOffloadInfo, pKey, pScratch2, pScratch))
    {
        SetLastError((DWORD)NTE_FAIL);
        goto Ret;
    }

    if ((pScratch[pKey->datalen - 1] != PKCS_BLOCKTYPE_2) ||
        (pScratch[pKey->datalen] != 0))
    {
        SetLastError((DWORD) NTE_BAD_DATA);
        goto Ret;
    }

    i = pKey->datalen - 2;

    while((i > 0) && (pScratch[i]))
        i--;

    if ((*ppbOutBuf = (BYTE *)_nt_malloc(i)) == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Ret;
    }
    *pcbOutBuf = i;

#ifdef CSP_USE_SSL3
    // if SSL2_FALLBACK has been specified then check if threes
    // are in the 8  least significant bytes of the random padding
    if (CRYPT_SSL2_FALLBACK & dwFlags)
    {
        BOOL fFallbackError = TRUE;

        for(z = i + 1; z < i + 9; z++)
        {
            if (0x03 != pScratch[z])
            {
                fFallbackError = FALSE;
                break;
            }
        }
        if(fFallbackError)
        {
            SetLastError((DWORD)NTE_BAD_VER);
            goto Ret;
        }
    }
#endif

    // Reverse the session key bytes
    for (z = 0; z < i; ++z)
        (*ppbOutBuf)[z] = pScratch[i - z - 1];

    fRet = TRUE;
Ret:
    if (pScratch)
        _nt_free(pScratch, pKey->keylen);

    return fRet;
}

/************************************************************************/
/* RSAEncrypt performs a RSA encryption.                                */
/************************************************************************/
BOOL RSAEncrypt(
                IN PNTAGUserList pTmpUser,
                IN BSAFE_PUB_KEY *pBSPubKey,
                IN BYTE *pbPlaintext,
                IN DWORD cbPlaintext,
                IN BYTE *pbParams,
                IN DWORD cbParams,
                IN DWORD dwFlags,
                OUT BYTE *pbOut
                )
{
    BOOL    fRet = FALSE;

    // check the length of the data
    if (!CheckDataLenForRSAEncrypt((pBSPubKey->bitlen + 7) / 8,
                                   cbPlaintext, dwFlags))
    {
        goto Ret;
    }

    // use OAEP if the flag is set
    if (dwFlags & CRYPT_OAEP)
    {
        if (!OAEPEncrypt(pTmpUser, pBSPubKey, pbPlaintext,
                         cbPlaintext, pbParams, cbParams, pbOut))
        {
            goto Ret;
        }
    }
    // use PKCS #1 Type 2
    else
    {
        if (!PKCS2Encrypt(pTmpUser, dwFlags, pBSPubKey,
                          pbPlaintext, cbPlaintext, pbOut))
        {
            goto Ret;
        }
    }

    fRet = TRUE;
Ret:
    return fRet;
}

/************************************************************************/
/* RSADecrypt performs a RSA decryption.                                */
/************************************************************************/
BOOL RSADecrypt(
                IN PNTAGUserList pTmpUser,
                IN BSAFE_PRV_KEY *pBSPrivKey,
                IN BYTE *pbBlob,
                IN DWORD cbBlob,
                IN BYTE *pbParams,
                IN DWORD cbParams,
                IN DWORD dwFlags,
                OUT BYTE **ppbPlaintext,
                OUT DWORD *pcbPlaintext
                )
{
    BOOL    fRet = FALSE;

    // use OAEP if the flag is set
    if (dwFlags & CRYPT_OAEP)
    {
        if (!OAEPDecrypt(pTmpUser, pBSPrivKey, pbBlob, cbBlob, pbParams,
                         cbParams, ppbPlaintext, pcbPlaintext))
        {
            goto Ret;
        }
    }
    // use PKCS #1 Type 2
    else
    {
        if (!PKCS2Decrypt(pTmpUser, pBSPrivKey, dwFlags, pbBlob, ppbPlaintext,
                          pcbPlaintext))
        {
            goto Ret;
        }
    }

    fRet = TRUE;
Ret:
    return fRet;
}

//
// Function : EncryptAndDecryptWithRSAKey
//
// Description : This function creates a buffer and then encrypts that with
//               the passed in private key and decrypts with the passed in
//               public key.  The function is used for FIPS 140-1 compliance
//               to make sure that newly generated/imported keys work and
//               in the self test during DLL initialization.
//

DWORD EncryptAndDecryptWithRSAKey(
                                  IN BYTE *pbRSAPub,
                                  IN BYTE *pbRSAPriv,
                                  IN BOOL fSigKey,
                                  IN BOOL fEncryptCheck
                                  )
{
    BSAFE_PRV_KEY   *pBSafePriv = (BSAFE_PRV_KEY*)pbRSAPriv;
    BYTE            *pb = NULL;
    DWORD           cb;
    DWORD           cbKey;
    DWORD           i;
    DWORD           dwErr = 0;

    // alloc space for the plaintext and ciphertext
    cb = pBSafePriv->keylen;
    cbKey = pBSafePriv->bitlen / 8;
    if (NULL == (pb = _nt_malloc(cb * 3)))
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    // reverse the hash so it is in little endian
    for (i = 0; i < 16; i++)
    {
        pb[i] = (BYTE)i + 1;
    }
    memset(pb + 17, 0xFF, cbKey - 18);

    if (fSigKey)
    {
        // encrypt with the private key
        BSafeDecPrivate(pBSafePriv, pb, pb + cb);
    }
    else
    {
        // encrypt with the public key
        BSafeEncPublic((BSAFE_PUB_KEY*)pbRSAPub,
                                      pb,
                                      pb + cb);
    }

    // we can't do this check when importing private keys since many
    // applications use private keys with exponent of 1 to import
    // plaintext symmetric keys
    if (fEncryptCheck)
    {
        if (0 == (memcmp(pb, pb + cb, cb)))
        {
            dwErr = NTE_BAD_KEY;
            goto Ret;
        }
    }

    if (fSigKey)
    {
        // decrypt with the public key
        BSafeEncPublic((BSAFE_PUB_KEY*)pbRSAPub,
                                      pb + cb,
                                      pb + (cb * 2));
    }
    else
    {
        // encrypt with the private key
        BSafeDecPrivate(pBSafePriv, pb + cb, pb + (cb * 2));
    }

    // compare to the plaintext and the decrypted text
    if (memcmp(pb, pb + cb * 2, cbKey))
    {
        dwErr = (DWORD)NTE_BAD_KEY;
        goto Ret;
    }
Ret:
    if (pb)
        _nt_free(pb, cbB * 3);

    return dwErr;
}

BOOL ReGenKey(HCRYPTPROV hUser,
              DWORD dwFlags,
              DWORD dwWhichKey,
              HCRYPTKEY *phKey,
              DWORD bits)
{
    BYTE                **ThisPubKey, **ThisPrivKey;
    DWORD               *pThisPubLen, *pThisPrivLen;
    BYTE                *pNewPubKey = NULL;
    BYTE                *pNewPrivKey = NULL;
    DWORD               PrivateKeySize, PublicKeySize;
    DWORD               localbits;
    PNTAGUserList       pOurUser;
    BOOL                fSigKey;
    LPWSTR              szPrompt;
    BOOL                *pfExportable;
    BOOL                fAlloc = FALSE;
    BOOL                fInCritSec = FALSE;
    DWORD               dwErr;
    BSAFE_OTHER_INFO    OtherInfo;
    BSAFE_OTHER_INFO    *pOtherInfo = NULL;
    BOOL                fRet = FALSE;

    memset(&OtherInfo, 0, sizeof(OtherInfo));

    // ## MTS: No user structure locking
    if ((pOurUser = (PNTAGUserList) NTLCheckList(hUser, USER_HANDLE)) == NULL)
    {
        SetLastError((DWORD) NTE_BAD_UID);
        goto Ret;
    }

    // wrap with a try since there is a critical sections in here
    try
    {
        EnterCriticalSection(&pOurUser->CritSec);
        fInCritSec = TRUE;

        localbits = bits;

        if (!BSafeComputeKeySizes(&PublicKeySize, &PrivateKeySize, &localbits))
        {
            SetLastError((DWORD) NTE_FAIL);
            goto Ret;
        }

        if ((pNewPubKey = (BYTE *)_nt_malloc(PublicKeySize)) == NULL)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }
        fAlloc = TRUE;

        // allocate space for the new key exchange public key
        if ((pNewPrivKey = (BYTE *)_nt_malloc(PrivateKeySize)) == NULL)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }
    
        // initialize the user's state in the random number generation
#ifndef _XBOX
        if (!InitRand(&pOurUser->ContInfo.pbRandom,
                      &pOurUser->ContInfo.ContLens.cbRandom))
        {
            SetLastError((DWORD) NTE_FAIL);
            goto Ret;
        }
#endif

        // generate the key exchange key pair
        if (INVALID_HANDLE_VALUE != pOurUser->hRNGDriver)
        {
            OtherInfo.pRNGInfo = &pOurUser->hRNGDriver;
            OtherInfo.pFuncRNG = FIPS186GenRandomWithException;
            pOtherInfo = &OtherInfo;
        }
        if (!BSafeMakeKeyPairEx2(pOtherInfo,
                                 (BSAFE_PUB_KEY *) pNewPubKey,
                                 (BSAFE_PRV_KEY *) pNewPrivKey,
                                 bits,
                                 0x10001))
        {
            SetLastError((DWORD) NTE_FAIL);
            goto Ret;
        }

        // uninitialize the user's state from the random number generation
        if (!XRNGGenerateBytes(pOurUser->ContInfo.pbRandom,
                        pOurUser->ContInfo.ContLens.cbRandom))
        {
            SetLastError((DWORD) NTE_FAIL);
            goto Ret;
        }

        // test the RSA key to make sure it works
        if (0 != (dwErr = EncryptAndDecryptWithRSAKey(pNewPubKey, pNewPrivKey, TRUE, TRUE)))
        {
            SetLastError(dwErr);
            goto Ret;
        }

        // test the RSA key to make sure it works
        if (0 != (dwErr = EncryptAndDecryptWithRSAKey(pNewPubKey, pNewPrivKey, FALSE, TRUE)))
        {
            SetLastError(dwErr);
            goto Ret;
        }

        if (dwWhichKey == NTPK_USE_SIG)
        {
            ThisPubKey = &pOurUser->ContInfo.pbSigPub;
            ThisPrivKey = &pOurUser->pSigPrivKey;
            pThisPubLen = &pOurUser->ContInfo.ContLens.cbSigPub;
            pThisPrivLen = &pOurUser->SigPrivLen;
            pfExportable = &pOurUser->ContInfo.fSigExportable;
            fSigKey = TRUE;
            szPrompt = g_Strings.pwszCreateRSASig;
        }
        else
        {
            ThisPubKey = &pOurUser->ContInfo.pbExchPub;
            ThisPrivKey = &pOurUser->pExchPrivKey;
            pThisPubLen = &pOurUser->ContInfo.ContLens.cbExchPub;
            pThisPrivLen = &pOurUser->ExchPrivLen;
            pfExportable = &pOurUser->ContInfo.fExchExportable;
            fSigKey = FALSE;
            szPrompt = g_Strings.pwszCreateRSAExch;
        }

        if (*ThisPubKey)
        {
            ASSERT(*pThisPubLen);
            ASSERT(*pThisPrivLen);
            ASSERT(*ThisPrivKey);
    
            _nt_free (*ThisPubKey, *pThisPubLen);
    
            _nt_free (*ThisPrivKey, *pThisPrivLen);
        }
#ifdef NTAGDEBUG
        else
        {
            ASSERT(*pThisPrivLen == 0);
            ASSERT(*pThisPubLen == 0);
            ASSERT(*ThisPrivKey == 0);
            ASSERT(*ThisPubKey == 0);
        }
#endif

        fAlloc = FALSE;

        *pThisPrivLen = PrivateKeySize;
        *pThisPubLen = PublicKeySize;
        *ThisPrivKey = pNewPrivKey;
        *ThisPubKey = pNewPubKey;

        if (dwFlags & CRYPT_EXPORTABLE)
            *pfExportable = TRUE;
        else
            *pfExportable = FALSE;

        // if the context being used is a Verify Context then the key is not
        // persisted to storage
        if (!(pOurUser->Rights & CRYPT_VERIFYCONTEXT))
        {
            // write the new keys to the user storage file
            if (!ProtectPrivKey(pOurUser, szPrompt, dwFlags, fSigKey))
            {
                goto Ret;          // error already set
            }
        }

        if (dwWhichKey == NTPK_USE_SIG)
        {
            if (!CPGetUserKey(hUser, AT_SIGNATURE, phKey))
                goto Ret;
        }
        else
        {
            if (!CPGetUserKey(hUser, AT_KEYEXCHANGE, phKey))
                goto Ret;
        }

        fRet = TRUE;
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fInCritSec)
    {
        LeaveCriticalSection(&pOurUser->CritSec);
    }
    if (fAlloc)
    {
        if (pNewPrivKey)
            _nt_free(pNewPrivKey, PrivateKeySize);
        if (pNewPubKey)
            _nt_free(pNewPubKey, PublicKeySize);
    }
    
    return fRet;
}

//
// Routine : DerivePublicFromPrivate
//
// Description : Derive the public RSA key from the private RSA key.  This is
//               done and the resulting public key is placed in the appropriate
//               place in the context pointer (pTmpUser).
//

BOOL DerivePublicFromPrivate(
                             IN PNTAGUserList pUser,
                             IN BOOL fSigKey
                             )
{
    DWORD           *pcbPubKey;
    BYTE            **ppbPubKey = NULL;
    BSAFE_PUB_KEY   *pBSafePubKey;
    BSAFE_PRV_KEY   *pBSafePrivKey;
    DWORD           cb;
    BOOL            fRet = FALSE;

    // variable assignments depending on if its sig or exch
    if (fSigKey)
    {
        pcbPubKey = &pUser->ContInfo.ContLens.cbSigPub;
        ppbPubKey = &pUser->ContInfo.pbSigPub;
        pBSafePrivKey = (BSAFE_PRV_KEY*)pUser->pSigPrivKey;
    }
    else
    {
        pcbPubKey = &pUser->ContInfo.ContLens.cbExchPub;
        ppbPubKey = &pUser->ContInfo.pbExchPub;
        pBSafePrivKey = (BSAFE_PRV_KEY*)pUser->pExchPrivKey;
    }

    // figure out how much space is needed for the public key
    cb = ((((pBSafePrivKey->bitlen >> 1) + 63) / 32) * 8); // 8 = 2 * DIGIT_BYTES (rsa_fast.h)
    cb += sizeof(BSAFE_PUB_KEY);

    // check if space has been alloced for the public key and if
    // so is it large enough
    if (cb > *pcbPubKey)
    {
        _nt_free(*ppbPubKey, *pcbPubKey);
        *pcbPubKey = cb;

        if (NULL == (*ppbPubKey = _nt_malloc(*pcbPubKey)))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }
    }

    // copy over the public key components
    pBSafePubKey = (BSAFE_PUB_KEY*)*ppbPubKey;
    pBSafePubKey->magic = RSA1;
    pBSafePubKey->keylen = pBSafePrivKey->keylen;
    pBSafePubKey->bitlen = pBSafePrivKey->bitlen;
    pBSafePubKey->datalen = pBSafePrivKey->datalen;
    pBSafePubKey->pubexp = pBSafePrivKey->pubexp;
    memcpy(*ppbPubKey + sizeof(BSAFE_PUB_KEY),
           (BYTE*)pBSafePrivKey + sizeof(BSAFE_PRV_KEY),
           cb - sizeof(BSAFE_PUB_KEY));

    fRet = TRUE;
Ret:
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\rsabase\ssl3.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ssl3.h                                             //
//  DESCRIPTION   :                                                        //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Dec  2 1996 jeffspel  Create                                        //
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef __SSL3_H__
#define __SSL3_H__

#ifdef __cplusplus
extern "C" {
#endif

#define     EXPORTABLE_KEYLEN   5
#define     EXPORTABLE_SALTLEN  11
#define     RC_KEYLEN           16
#define     MAX_PREMASTER_LEN   48
#define     MAX_RANDOM_LEN      256

#define     TLS_MASTER_LEN   48

// definition of a Secure Channel hash structure
typedef struct _SCH_KeyData
{
    BYTE        rgbPremaster[MAX_PREMASTER_LEN];
    DWORD       cbPremaster;
    BYTE        rgbClientRandom[MAX_RANDOM_LEN];
    DWORD       cbClientRandom;
    BYTE        rgbServerRandom[MAX_RANDOM_LEN];
    DWORD       cbServerRandom;
    BYTE        *pbCertData;
    DWORD       cbCertData;
    BYTE        rgbClearData[MAX_RANDOM_LEN];
    DWORD       cbClearData;
    ALG_ID      EncAlgid;
    ALG_ID      HashAlgid;
    DWORD       cbEnc;
    DWORD       cbEncMac;
    DWORD       cbHash;
    DWORD       cbIV;
    BOOL        fFinished;
    BOOL        dwFlags;
} SCH_KEY, *PSCH_KEY;

// definition of a Secure Channel hash structure
typedef struct _SCH_HashData
{
    ALG_ID      ProtocolAlgid;
    ALG_ID      EncAlgid;
    ALG_ID      HashAlgid;
    DWORD       cbEnc;
    DWORD       cbEncMac;
    DWORD       cbHash;
    DWORD       cbIV;
    BYTE        rgbClientRandom[MAX_RANDOM_LEN];
    DWORD       cbClientRandom;
    BYTE        rgbServerRandom[MAX_RANDOM_LEN];
    DWORD       cbServerRandom;
    BYTE        *pbCertData;
    DWORD       cbCertData;
    BYTE        rgbClearData[MAX_RANDOM_LEN];
    DWORD       cbClearData;
	BYTE        rgbFinal[MAX_RANDOM_LEN];
    DWORD       cbFinal;
    BOOL        dwFlags;
} SCH_HASH, *PSCH_HASH;

// definition of a TLS1 PRF hash structure
typedef struct _PRF_HashData
{
    BYTE        rgbLabel[MAX_RANDOM_LEN];
    DWORD       cbLabel;
    BYTE        rgbSeed[MAX_RANDOM_LEN];
    DWORD       cbSeed;
	BYTE        rgbMasterKey[TLS_MASTER_LEN];
} PRF_HASH;

// strings for deriving PCT1 keys
#define     PCT1_C_WRT          "cw"
#define     PCT1_C_WRT_LEN      2
#define     PCT1_S_WRT          "svw"
#define     PCT1_S_WRT_LEN      3
#define     PCT1_C_MAC          "cmac"
#define     PCT1_C_MAC_LEN      4
#define     PCT1_S_MAC          "svmac"
#define     PCT1_S_MAC_LEN      5

void FreeSChHash(
                 PSCH_HASH       pSChHash
                 );

void FreeSChKey(
                PSCH_KEY    pSChKey
                );

BOOL SCHSetKeyParam(
                    IN PNTAGUserList pTmpUser,
                    IN OUT PNTAGKeyList pKey,
                    IN DWORD dwParam,
                    IN PBYTE pbData
                    );

BOOL SCHGetKeyParam(
                    PNTAGKeyList pKey,
                    DWORD dwParam,
                    PBYTE pbData
                    );

BOOL SChGenMasterKey(
                     PNTAGKeyList pKey,
                     PSCH_HASH pSChHash
                     );

BOOL SecureChannelDeriveKey(
                            PNTAGUserList pTmpUser,
                            PNTAGHashList pHash,
                            ALG_ID Algid,
                            DWORD dwFlags,
                            HCRYPTKEY *phKey
                            );

BOOL SetPRFHashParam(
                     PRF_HASH *pPRFHash,
                     DWORD dwParam,
                     BYTE *pbData
                     );

BOOL CalculatePRF(
                  PRF_HASH *pPRFHash,
                  BYTE *pbData,
                  DWORD *pcbData
                  );

#ifdef __cplusplus
}
#endif

#endif // __SSL3_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\rsabase\swnt_pk.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : swnt_pk.h                                              //
//  DESCRIPTION   :                                                        //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Apr 19 1995 larrys  Cleanup                                        //
//  	Oct 27 1995 rajeshk  RandSeed Stuff added hUID to PKCS2Encrypt     //
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef __SWNT_PK_H__
#define __SWNT_PK_H__

#ifdef __cplusplus
extern "C" {
#endif

#define NTPK_USE_SIG    0
#define NTPK_USE_EXCH   1


#define PKCS_BLOCKTYPE_1        1
#define PKCS_BLOCKTYPE_2        2
        
//
// Function : EncryptAndDecryptWithRSAKey
//
// Description : This function creates a buffer and then encrypts that with
//               the passed in private key and decrypts with the passed in
//               public key.  The function is used for FIPS 140-1 compliance
//               to make sure that newly generated/imported keys work and
//               in the self test during DLL initialization.
//

DWORD EncryptAndDecryptWithRSAKey(
                                  IN BYTE *pbRSAPub,
                                  IN BYTE *pbRSAPriv,
                                  IN BOOL fSigKey,
                                  IN BOOL fEncryptCheck
                                  );

BOOL ReGenKey(HCRYPTPROV hUser,
              DWORD dwFlags,
              DWORD dwWhichKey,
              HCRYPTKEY *phKey,
              DWORD bits);

BOOL CheckDataLenForRSAEncrypt(
                               IN DWORD cbMod,   // length of the modulus
                               IN DWORD cbData,  // length of the data
                               IN DWORD dwFlags  // flags
                               );

// do the modular exponentiation calculation M^PubKey mod N
DWORD RSAPublicEncrypt(
                       IN PEXPO_OFFLOAD_STRUCT pOffloadInfo,
                       IN BSAFE_PUB_KEY *pBSPubKey,
                       IN BYTE *pbInput,
                       IN BYTE *pbOutput
                       );

// do the modular exponentiation calculation M^PrivKey Exponent mod N
DWORD RSAPrivateDecrypt(
                        IN PEXPO_OFFLOAD_STRUCT pOffloadInfo,
                        IN BSAFE_PRV_KEY *pBSPrivKey,
                        IN BYTE *pbInput,
                        IN BYTE *pbOutput
                        );

/************************************************************************/
/* RSAEncrypt performs a RSA encryption.                                */
/************************************************************************/
BOOL RSAEncrypt(
                IN PNTAGUserList pTmpUser,
                IN BSAFE_PUB_KEY *pBSPubKey,
                IN BYTE *pbPlaintext,
                IN DWORD cbPlaintext,
                IN BYTE *pbParams,
                IN DWORD cbParams,
                IN DWORD dwFlags,
                OUT BYTE *pbOut
                );

/************************************************************************/
/* RSADecrypt performs a RSA decryption.                                */
/************************************************************************/
BOOL RSADecrypt(
                IN PNTAGUserList pTmpUser,
                IN BSAFE_PRV_KEY *pBSPrivKey,
                IN BYTE *pbBlob,
                IN DWORD cbBlob,
                IN BYTE *pbParams,
                IN DWORD cbParams,
                IN DWORD dwFlags,
                OUT BYTE **ppbPlaintext,
                OUT DWORD *pcbPlaintext
                );

//
// Routine : DerivePublicFromPrivate
//
// Description : Derive the public RSA key from the private RSA key.  This is
//               done and the resulting public key is placed in the appropriate
//               place in the context pointer (pTmpUser).
//

BOOL DerivePublicFromPrivate(
                             IN PNTAGUserList pUser,
                             IN BOOL fSigKey
                             );

#ifdef __cplusplus
}
#endif

#endif // __SWNT_PK_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\sclogon\winscard.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    WinSCard

Abstract:

    This header file provides the definitions and symbols necessary for an
    Application or Smart Card Service Provider to access the Smartcard
    Subsystem.

Environment:

    Win32

Notes:

--*/

#ifndef _WINSCARD_H_
#define _WINSCARD_H_

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#include <wtypes.h>
#include <winioctl.h>
#include "winsmcrd.h"
#ifndef SCARD_S_SUCCESS
#include "SCardErr.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifndef _LPCBYTE_DEFINED
#define _LPCBYTE_DEFINED
typedef const BYTE *LPCBYTE;
#endif
#ifndef _LPCVOID_DEFINED
#define _LPCVOID_DEFINED
typedef const VOID *LPCVOID;
#endif

#ifndef WINSCARDAPI
#define WINSCARDAPI
#endif
#ifndef WINSCARDDATA
#define WINSCARDDATA __declspec(dllimport)
#endif

WINSCARDDATA extern const SCARD_IO_REQUEST
    g_rgSCardT0Pci,
    g_rgSCardT1Pci,
    g_rgSCardRawPci;
#define SCARD_PCI_T0  (&g_rgSCardT0Pci)
#define SCARD_PCI_T1  (&g_rgSCardT1Pci)
#define SCARD_PCI_RAW (&g_rgSCardRawPci)


//
////////////////////////////////////////////////////////////////////////////////
//
//  Service Manager Access Services
//
//      The following services are used to manage user and terminal contexts for
//      Smart Cards.
//

typedef ULONG_PTR SCARDCONTEXT;
typedef SCARDCONTEXT *PSCARDCONTEXT, *LPSCARDCONTEXT;

typedef ULONG_PTR SCARDHANDLE;
typedef SCARDHANDLE *PSCARDHANDLE, *LPSCARDHANDLE;

#define SCARD_AUTOALLOCATE (DWORD)(-1)

#define SCARD_SCOPE_USER     0  // The context is a user context, and any
                                // database operations are performed within the
                                // domain of the user.
#define SCARD_SCOPE_TERMINAL 1  // The context is that of the current terminal,
                                // and any database operations are performed
                                // within the domain of that terminal.  (The
                                // calling application must have appropriate
                                // access permissions for any database actions.)
#define SCARD_SCOPE_SYSTEM    2 // The context is the system context, and any
                                // database operations are performed within the
                                // domain of the system.  (The calling
                                // application must have appropriate access
                                // permissions for any database actions.)

extern WINSCARDAPI LONG WINAPI
SCardEstablishContext(
    IN  DWORD dwScope,
    IN  LPCVOID pvReserved1,
    IN  LPCVOID pvReserved2,
    OUT LPSCARDCONTEXT phContext);

extern WINSCARDAPI LONG WINAPI
SCardReleaseContext(
    IN      SCARDCONTEXT hContext);

extern WINSCARDAPI LONG WINAPI
SCardIsValidContext(
    IN      SCARDCONTEXT hContext);


//
////////////////////////////////////////////////////////////////////////////////
//
//  Smart Card Database Management Services
//
//      The following services provide for managing the Smart Card Database.
//

#define SCARD_ALL_READERS       TEXT("SCard$AllReaders\000")
#define SCARD_DEFAULT_READERS   TEXT("SCard$DefaultReaders\000")
#define SCARD_LOCAL_READERS     TEXT("SCard$LocalReaders\000")
#define SCARD_SYSTEM_READERS    TEXT("SCard$SystemReaders\000")

#define SCARD_PROVIDER_PRIMARY  1   // Primary Provider Id
#define SCARD_PROVIDER_CSP      2   // Crypto Service Provider Id


//
// Database Reader routines
//

extern WINSCARDAPI LONG WINAPI
SCardListReaderGroupsA(
    IN      SCARDCONTEXT hContext,
    OUT     LPSTR mszGroups,
    IN OUT  LPDWORD pcchGroups);
extern WINSCARDAPI LONG WINAPI
SCardListReaderGroupsW(
    IN      SCARDCONTEXT hContext,
    OUT     LPWSTR mszGroups,
    IN OUT  LPDWORD pcchGroups);
#ifdef UNICODE
#define SCardListReaderGroups  SCardListReaderGroupsW
#else
#define SCardListReaderGroups  SCardListReaderGroupsA
#endif // !UNICODE

extern WINSCARDAPI LONG WINAPI
SCardListReadersA(
    IN      SCARDCONTEXT hContext,
    IN      LPCSTR mszGroups,
    OUT     LPSTR mszReaders,
    IN OUT  LPDWORD pcchReaders);
extern WINSCARDAPI LONG WINAPI
SCardListReadersW(
    IN      SCARDCONTEXT hContext,
    IN      LPCWSTR mszGroups,
    OUT     LPWSTR mszReaders,
    IN OUT  LPDWORD pcchReaders);
#ifdef UNICODE
#define SCardListReaders  SCardListReadersW
#else
#define SCardListReaders  SCardListReadersA
#endif // !UNICODE

extern WINSCARDAPI LONG WINAPI
SCardListCardsA(
    IN      SCARDCONTEXT hContext,
    IN      LPCBYTE pbAtr,
    IN      LPCGUID rgquidInterfaces,
    IN      DWORD cguidInterfaceCount,
    OUT     LPSTR mszCards,
    IN OUT  LPDWORD pcchCards);
extern WINSCARDAPI LONG WINAPI
SCardListCardsW(
    IN      SCARDCONTEXT hContext,
    IN      LPCBYTE pbAtr,
    IN      LPCGUID rgquidInterfaces,
    IN      DWORD cguidInterfaceCount,
    OUT     LPWSTR mszCards,
    IN OUT  LPDWORD pcchCards);
#ifdef UNICODE
#define SCardListCards  SCardListCardsW
#else
#define SCardListCards  SCardListCardsA
#endif // !UNICODE
//
// NOTE:    The routine SCardListCards name differs from the PC/SC definition.
//          It should be:
//
//              extern WINSCARDAPI LONG WINAPI
//              SCardListCardTypes(
//                  IN      SCARDCONTEXT hContext,
//                  IN      LPCBYTE pbAtr,
//                  IN      LPCGUID rgquidInterfaces,
//                  IN      DWORD cguidInterfaceCount,
//                  OUT     LPTSTR mszCards,
//                  IN OUT  LPDWORD pcchCards);
//
//          Here's a work-around MACRO:
#define SCardListCardTypes SCardListCards

extern WINSCARDAPI LONG WINAPI
SCardListInterfacesA(
    IN      SCARDCONTEXT hContext,
    IN      LPCSTR szCard,
    OUT     LPGUID pguidInterfaces,
    IN OUT  LPDWORD pcguidInterfaces);
extern WINSCARDAPI LONG WINAPI
SCardListInterfacesW(
    IN      SCARDCONTEXT hContext,
    IN      LPCWSTR szCard,
    OUT     LPGUID pguidInterfaces,
    IN OUT  LPDWORD pcguidInterfaces);
#ifdef UNICODE
#define SCardListInterfaces  SCardListInterfacesW
#else
#define SCardListInterfaces  SCardListInterfacesA
#endif // !UNICODE

extern WINSCARDAPI LONG WINAPI
SCardGetProviderIdA(
    IN      SCARDCONTEXT hContext,
    IN      LPCSTR szCard,
    OUT     LPGUID pguidProviderId);
extern WINSCARDAPI LONG WINAPI
SCardGetProviderIdW(
    IN      SCARDCONTEXT hContext,
    IN      LPCWSTR szCard,
    OUT     LPGUID pguidProviderId);
#ifdef UNICODE
#define SCardGetProviderId  SCardGetProviderIdW
#else
#define SCardGetProviderId  SCardGetProviderIdA
#endif // !UNICODE
//
// NOTE:    The routine SCardGetProviderId in this implementation uses GUIDs.
//          The PC/SC definition uses BYTEs.
//

extern WINSCARDAPI LONG WINAPI
SCardGetCardTypeProviderNameA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR szCardName,
    IN DWORD dwProviderId,
    OUT LPSTR szProvider,
    IN OUT LPDWORD pcchProvider);
extern WINSCARDAPI LONG WINAPI
SCardGetCardTypeProviderNameW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szCardName,
    IN DWORD dwProviderId,
    OUT LPWSTR szProvider,
    IN OUT LPDWORD pcchProvider);
#ifdef UNICODE
#define SCardGetCardTypeProviderName  SCardGetCardTypeProviderNameW
#else
#define SCardGetCardTypeProviderName  SCardGetCardTypeProviderNameA
#endif // !UNICODE
//
// NOTE:    This routine is an extension to the PC/SC definitions.
//


//
// Database Writer routines
//

extern WINSCARDAPI LONG WINAPI
SCardIntroduceReaderGroupA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR szGroupName);
extern WINSCARDAPI LONG WINAPI
SCardIntroduceReaderGroupW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szGroupName);
#ifdef UNICODE
#define SCardIntroduceReaderGroup  SCardIntroduceReaderGroupW
#else
#define SCardIntroduceReaderGroup  SCardIntroduceReaderGroupA
#endif // !UNICODE

extern WINSCARDAPI LONG WINAPI
SCardForgetReaderGroupA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR szGroupName);
extern WINSCARDAPI LONG WINAPI
SCardForgetReaderGroupW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szGroupName);
#ifdef UNICODE
#define SCardForgetReaderGroup  SCardForgetReaderGroupW
#else
#define SCardForgetReaderGroup  SCardForgetReaderGroupA
#endif // !UNICODE

extern WINSCARDAPI LONG WINAPI
SCardIntroduceReaderA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR szReaderName,
    IN LPCSTR szDeviceName);
extern WINSCARDAPI LONG WINAPI
SCardIntroduceReaderW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szReaderName,
    IN LPCWSTR szDeviceName);
#ifdef UNICODE
#define SCardIntroduceReader  SCardIntroduceReaderW
#else
#define SCardIntroduceReader  SCardIntroduceReaderA
#endif // !UNICODE

extern WINSCARDAPI LONG WINAPI
SCardForgetReaderA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR szReaderName);
extern WINSCARDAPI LONG WINAPI
SCardForgetReaderW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szReaderName);
#ifdef UNICODE
#define SCardForgetReader  SCardForgetReaderW
#else
#define SCardForgetReader  SCardForgetReaderA
#endif // !UNICODE

extern WINSCARDAPI LONG WINAPI
SCardAddReaderToGroupA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR szReaderName,
    IN LPCSTR szGroupName);
extern WINSCARDAPI LONG WINAPI
SCardAddReaderToGroupW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szReaderName,
    IN LPCWSTR szGroupName);
#ifdef UNICODE
#define SCardAddReaderToGroup  SCardAddReaderToGroupW
#else
#define SCardAddReaderToGroup  SCardAddReaderToGroupA
#endif // !UNICODE

extern WINSCARDAPI LONG WINAPI
SCardRemoveReaderFromGroupA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR szReaderName,
    IN LPCSTR szGroupName);
extern WINSCARDAPI LONG WINAPI
SCardRemoveReaderFromGroupW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szReaderName,
    IN LPCWSTR szGroupName);
#ifdef UNICODE
#define SCardRemoveReaderFromGroup  SCardRemoveReaderFromGroupW
#else
#define SCardRemoveReaderFromGroup  SCardRemoveReaderFromGroupA
#endif // !UNICODE

extern WINSCARDAPI LONG WINAPI
SCardIntroduceCardTypeA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR szCardName,
    IN LPCGUID pguidPrimaryProvider,
    IN LPCGUID rgguidInterfaces,
    IN DWORD dwInterfaceCount,
    IN LPCBYTE pbAtr,
    IN LPCBYTE pbAtrMask,
    IN DWORD cbAtrLen);
extern WINSCARDAPI LONG WINAPI
SCardIntroduceCardTypeW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szCardName,
    IN LPCGUID pguidPrimaryProvider,
    IN LPCGUID rgguidInterfaces,
    IN DWORD dwInterfaceCount,
    IN LPCBYTE pbAtr,
    IN LPCBYTE pbAtrMask,
    IN DWORD cbAtrLen);
#ifdef UNICODE
#define SCardIntroduceCardType  SCardIntroduceCardTypeW
#else
#define SCardIntroduceCardType  SCardIntroduceCardTypeA
#endif // !UNICODE
//
// NOTE:    The routine SCardIntroduceCardType's parameters' order differs from
//          the PC/SC definition.  It should be:
//
//              extern WINSCARDAPI LONG WINAPI
//              SCardIntroduceCardType(
//                  IN SCARDCONTEXT hContext,
//                  IN LPCTSTR szCardName,
//                  IN LPCBYTE pbAtr,
//                  IN LPCBYTE pbAtrMask,
//                  IN DWORD cbAtrLen,
//                  IN LPCGUID pguidPrimaryProvider,
//                  IN LPCGUID rgguidInterfaces,
//                  IN DWORD dwInterfaceCount);
//
//          Here's a work-around MACRO:
#define PCSCardIntroduceCardType(hContext, szCardName, pbAtr, pbAtrMask, cbAtrLen, pguidPrimaryProvider, rgguidInterfaces, dwInterfaceCount) \
          SCardIntroduceCardType(hContext, szCardName, pguidPrimaryProvider, rgguidInterfaces, dwInterfaceCount, pbAtr, pbAtrMask, cbAtrLen)

extern WINSCARDAPI LONG WINAPI
SCardSetCardTypeProviderNameA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR szCardName,
    IN DWORD dwProviderId,
    IN LPCSTR szProvider);
extern WINSCARDAPI LONG WINAPI
SCardSetCardTypeProviderNameW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szCardName,
    IN DWORD dwProviderId,
    IN LPCWSTR szProvider);
#ifdef UNICODE
#define SCardSetCardTypeProviderName  SCardSetCardTypeProviderNameW
#else
#define SCardSetCardTypeProviderName  SCardSetCardTypeProviderNameA
#endif // !UNICODE
//
// NOTE:    This routine is an extention to the PC/SC specifications.
//

extern WINSCARDAPI LONG WINAPI
SCardForgetCardTypeA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR szCardName);
extern WINSCARDAPI LONG WINAPI
SCardForgetCardTypeW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szCardName);
#ifdef UNICODE
#define SCardForgetCardType  SCardForgetCardTypeW
#else
#define SCardForgetCardType  SCardForgetCardTypeA
#endif // !UNICODE


//
////////////////////////////////////////////////////////////////////////////////
//
//  Service Manager Support Routines
//
//      The following services are supplied to simplify the use of the Service
//      Manager API.
//

extern WINSCARDAPI LONG WINAPI
SCardFreeMemory(
    IN SCARDCONTEXT hContext,
    IN LPCVOID pvMem);

extern WINSCARDAPI HANDLE WINAPI
SCardGetStartedEvent(void);


//
////////////////////////////////////////////////////////////////////////////////
//
//  Reader Services
//
//      The following services supply means for tracking cards within readers.
//

typedef struct {
    LPCSTR      szReader;       // reader name
    LPVOID      pvUserData;     // user defined data
    DWORD       dwCurrentState; // current state of reader at time of call
    DWORD       dwEventState;   // state of reader after state change
    DWORD       cbAtr;          // Number of bytes in the returned ATR.
    BYTE        rgbAtr[36];     // Atr of inserted card, (extra alignment bytes)
} SCARD_READERSTATEA, *PSCARD_READERSTATEA, *LPSCARD_READERSTATEA;
typedef struct {
    LPCWSTR     szReader;       // reader name
    LPVOID      pvUserData;     // user defined data
    DWORD       dwCurrentState; // current state of reader at time of call
    DWORD       dwEventState;   // state of reader after state change
    DWORD       cbAtr;          // Number of bytes in the returned ATR.
    BYTE        rgbAtr[36];     // Atr of inserted card, (extra alignment bytes)
} SCARD_READERSTATEW, *PSCARD_READERSTATEW, *LPSCARD_READERSTATEW;
#ifdef UNICODE
typedef SCARD_READERSTATEW SCARD_READERSTATE;
typedef PSCARD_READERSTATEW PSCARD_READERSTATE;
typedef LPSCARD_READERSTATEW LPSCARD_READERSTATE;
#else
typedef SCARD_READERSTATEA SCARD_READERSTATE;
typedef PSCARD_READERSTATEA PSCARD_READERSTATE;
typedef LPSCARD_READERSTATEA LPSCARD_READERSTATE;
#endif // UNICODE

// Backwards compatibility macros
#define SCARD_READERSTATE_A SCARD_READERSTATEA
#define SCARD_READERSTATE_W SCARD_READERSTATEW
#define PSCARD_READERSTATE_A PSCARD_READERSTATEA
#define PSCARD_READERSTATE_W PSCARD_READERSTATEW
#define LPSCARD_READERSTATE_A LPSCARD_READERSTATEA
#define LPSCARD_READERSTATE_W LPSCARD_READERSTATEW

#define SCARD_STATE_UNAWARE     0x00000000  // The application is unaware of the
                                            // current state, and would like to
                                            // know.  The use of this value
                                            // results in an immediate return
                                            // from state transition monitoring
                                            // services.  This is represented by
                                            // all bits set to zero.
#define SCARD_STATE_IGNORE      0x00000001  // The application requested that
                                            // this reader be ignored.  No other
                                            // bits will be set.
#define SCARD_STATE_CHANGED     0x00000002  // This implies that there is a
                                            // difference between the state
                                            // believed by the application, and
                                            // the state known by the Service
                                            // Manager.  When this bit is set,
                                            // the application may assume a
                                            // significant state change has
                                            // occurred on this reader.
#define SCARD_STATE_UNKNOWN     0x00000004  // This implies that the given
                                            // reader name is not recognized by
                                            // the Service Manager.  If this bit
                                            // is set, then SCARD_STATE_CHANGED
                                            // and SCARD_STATE_IGNORE will also
                                            // be set.
#define SCARD_STATE_UNAVAILABLE 0x00000008  // This implies that the actual
                                            // state of this reader is not
                                            // available.  If this bit is set,
                                            // then all the following bits are
                                            // clear.
#define SCARD_STATE_EMPTY       0x00000010  // This implies that there is not
                                            // card in the reader.  If this bit
                                            // is set, all the following bits
                                            // will be clear.
#define SCARD_STATE_PRESENT     0x00000020  // This implies that there is a card
                                            // in the reader.
#define SCARD_STATE_ATRMATCH    0x00000040  // This implies that there is a card
                                            // in the reader with an ATR
                                            // matching one of the target cards.
                                            // If this bit is set,
                                            // SCARD_STATE_PRESENT will also be
                                            // set.  This bit is only returned
                                            // on the SCardLocateCard() service.
#define SCARD_STATE_EXCLUSIVE   0x00000080  // This implies that the card in the
                                            // reader is allocated for exclusive
                                            // use by another application.  If
                                            // this bit is set,
                                            // SCARD_STATE_PRESENT will also be
                                            // set.
#define SCARD_STATE_INUSE       0x00000100  // This implies that the card in the
                                            // reader is in use by one or more
                                            // other applications, but may be
                                            // connected to in shared mode.  If
                                            // this bit is set,
                                            // SCARD_STATE_PRESENT will also be
                                            // set.
#define SCARD_STATE_MUTE        0x00000200  // This implies that the card in the
                                            // reader is unresponsive or not
                                            // supported by the reader or
                                            // software.
#define SCARD_STATE_UNPOWERED   0x00000400  // This implies that the card in the
                                            // reader has not been powered up.

extern WINSCARDAPI LONG WINAPI
SCardLocateCardsA(
    IN      SCARDCONTEXT hContext,
    IN      LPCSTR mszCards,
    IN OUT  LPSCARD_READERSTATEA rgReaderStates,
    IN      DWORD cReaders);
extern WINSCARDAPI LONG WINAPI
SCardLocateCardsW(
    IN      SCARDCONTEXT hContext,
    IN      LPCWSTR mszCards,
    IN OUT  LPSCARD_READERSTATEW rgReaderStates,
    IN      DWORD cReaders);
#ifdef UNICODE
#define SCardLocateCards  SCardLocateCardsW
#else
#define SCardLocateCards  SCardLocateCardsA
#endif // !UNICODE

extern WINSCARDAPI LONG WINAPI
SCardGetStatusChangeA(
    IN      SCARDCONTEXT hContext,
    IN      DWORD dwTimeout,
    IN OUT  LPSCARD_READERSTATEA rgReaderStates,
    IN      DWORD cReaders);
extern WINSCARDAPI LONG WINAPI
SCardGetStatusChangeW(
    IN      SCARDCONTEXT hContext,
    IN      DWORD dwTimeout,
    IN OUT  LPSCARD_READERSTATEW rgReaderStates,
    IN      DWORD cReaders);
#ifdef UNICODE
#define SCardGetStatusChange  SCardGetStatusChangeW
#else
#define SCardGetStatusChange  SCardGetStatusChangeA
#endif // !UNICODE

extern WINSCARDAPI LONG WINAPI
SCardCancel(
    IN      SCARDCONTEXT hContext);


//
////////////////////////////////////////////////////////////////////////////////
//
//  Card/Reader Communication Services
//
//      The following services provide means for communication with the card.
//

#define SCARD_SHARE_EXCLUSIVE 1 // This application is not willing to share this
                                // card with other applications.
#define SCARD_SHARE_SHARED    2 // This application is willing to share this
                                // card with other applications.
#define SCARD_SHARE_DIRECT    3 // This application demands direct control of
                                // the reader, so it is not available to other
                                // applications.

#define SCARD_LEAVE_CARD      0 // Don't do anything special on close
#define SCARD_RESET_CARD      1 // Reset the card on close
#define SCARD_UNPOWER_CARD    2 // Power down the card on close
#define SCARD_EJECT_CARD      3 // Eject the card on close

extern WINSCARDAPI LONG WINAPI
SCardConnectA(
    IN      SCARDCONTEXT hContext,
    IN      LPCSTR szReader,
    IN      DWORD dwShareMode,
    IN      DWORD dwPreferredProtocols,
    OUT     LPSCARDHANDLE phCard,
    OUT     LPDWORD pdwActiveProtocol);
extern WINSCARDAPI LONG WINAPI
SCardConnectW(
    IN      SCARDCONTEXT hContext,
    IN      LPCWSTR szReader,
    IN      DWORD dwShareMode,
    IN      DWORD dwPreferredProtocols,
    OUT     LPSCARDHANDLE phCard,
    OUT     LPDWORD pdwActiveProtocol);
#ifdef UNICODE
#define SCardConnect  SCardConnectW
#else
#define SCardConnect  SCardConnectA
#endif // !UNICODE

extern WINSCARDAPI LONG WINAPI
SCardReconnect(
    IN      SCARDHANDLE hCard,
    IN      DWORD dwShareMode,
    IN      DWORD dwPreferredProtocols,
    IN      DWORD dwInitialization,
    OUT     LPDWORD pdwActiveProtocol);

extern WINSCARDAPI LONG WINAPI
SCardDisconnect(
    IN      SCARDHANDLE hCard,
    IN      DWORD dwDisposition);

extern WINSCARDAPI LONG WINAPI
SCardBeginTransaction(
    IN      SCARDHANDLE hCard);

extern WINSCARDAPI LONG WINAPI
SCardEndTransaction(
    IN      SCARDHANDLE hCard,
    IN      DWORD dwDisposition);

extern WINSCARDAPI LONG WINAPI
SCardCancelTransaction(
    IN      SCARDHANDLE hCard);
//
// NOTE:    This call corresponds to the PC/SC SCARDCOMM::Cancel routine,
//          terminating a blocked SCardBeginTransaction service.
//


extern WINSCARDAPI LONG WINAPI
SCardState(
    IN SCARDHANDLE hCard,
    OUT LPDWORD pdwState,
    OUT LPDWORD pdwProtocol,
    OUT LPBYTE pbAtr,
    IN OUT LPDWORD pcbAtrLen);
//
// NOTE:    SCardState is an obsolete routine.  PC/SC has replaced it with
//          SCardStatus.
//

extern WINSCARDAPI LONG WINAPI
SCardStatusA(
    IN SCARDHANDLE hCard,
    OUT LPSTR szReaderName,
    IN OUT LPDWORD pcchReaderLen,
    OUT LPDWORD pdwState,
    OUT LPDWORD pdwProtocol,
    OUT LPBYTE pbAtr,
    IN OUT LPDWORD pcbAtrLen);
extern WINSCARDAPI LONG WINAPI
SCardStatusW(
    IN SCARDHANDLE hCard,
    OUT LPWSTR szReaderName,
    IN OUT LPDWORD pcchReaderLen,
    OUT LPDWORD pdwState,
    OUT LPDWORD pdwProtocol,
    OUT LPBYTE pbAtr,
    IN OUT LPDWORD pcbAtrLen);
#ifdef UNICODE
#define SCardStatus  SCardStatusW
#else
#define SCardStatus  SCardStatusA
#endif // !UNICODE

extern WINSCARDAPI LONG WINAPI
SCardTransmit(
    IN SCARDHANDLE hCard,
    IN LPCSCARD_IO_REQUEST pioSendPci,
    IN LPCBYTE pbSendBuffer,
    IN DWORD cbSendLength,
    IN OUT LPSCARD_IO_REQUEST pioRecvPci,
    OUT LPBYTE pbRecvBuffer,
    IN OUT LPDWORD pcbRecvLength);


//
////////////////////////////////////////////////////////////////////////////////
//
//  Reader Control Routines
//
//      The following services provide for direct, low-level manipulation of the
//      reader by the calling application allowing it control over the
//      attributes of the communications with the card.
//

extern WINSCARDAPI LONG WINAPI
SCardControl(
    IN      SCARDHANDLE hCard,
    IN      DWORD dwControlCode,
    IN      LPCVOID lpInBuffer,
    IN      DWORD nInBufferSize,
    OUT     LPVOID lpOutBuffer,
    IN      DWORD nOutBufferSize,
    OUT     LPDWORD lpBytesReturned);

extern WINSCARDAPI LONG WINAPI
SCardGetAttrib(
    IN SCARDHANDLE hCard,
    IN DWORD dwAttrId,
    OUT LPBYTE pbAttr,
    IN OUT LPDWORD pcbAttrLen);
//
// NOTE:    The routine SCardGetAttrib's name differs from the PC/SC definition.
//          It should be:
//
//              extern WINSCARDAPI LONG WINAPI
//              SCardGetReaderCapabilities(
//                  IN SCARDHANDLE hCard,
//                  IN DWORD dwTag,
//                  OUT LPBYTE pbAttr,
//                  IN OUT LPDWORD pcbAttrLen);
//
//          Here's a work-around MACRO:
#define SCardGetReaderCapabilities SCardGetAttrib

extern WINSCARDAPI LONG WINAPI
SCardSetAttrib(
    IN SCARDHANDLE hCard,
    IN DWORD dwAttrId,
    IN LPCBYTE pbAttr,
    IN DWORD cbAttrLen);
//
// NOTE:    The routine SCardSetAttrib's name differs from the PC/SC definition.
//          It should be:
//
//              extern WINSCARDAPI LONG WINAPI
//              SCardSetReaderCapabilities(
//                  IN SCARDHANDLE hCard,
//                  IN DWORD dwTag,
//                  OUT LPBYTE pbAttr,
//                  IN OUT LPDWORD pcbAttrLen);
//
//          Here's a work-around MACRO:
#define SCardSetReaderCapabilities SCardSetAttrib


//
////////////////////////////////////////////////////////////////////////////////
//
//  Smart Card Dialog definitions
//
//      The following section contains structures and  exported function
//      declarations for the Smart Card Common Dialog dialog.
//

// Defined constants
// Flags
#define SC_DLG_MINIMAL_UI       0x01
#define SC_DLG_NO_UI            0x02
#define SC_DLG_FORCE_UI         0x04

#define SCERR_NOCARDNAME        0x4000
#define SCERR_NOGUIDS           0x8000

typedef SCARDHANDLE (WINAPI *LPOCNCONNPROCA) (IN SCARDCONTEXT, IN LPSTR, IN LPSTR, IN PVOID);
typedef SCARDHANDLE (WINAPI *LPOCNCONNPROCW) (IN SCARDCONTEXT, IN LPWSTR, IN LPWSTR, IN PVOID);
#ifdef UNICODE
#define LPOCNCONNPROC  LPOCNCONNPROCW
#else
#define LPOCNCONNPROC  LPOCNCONNPROCA
#endif // !UNICODE
typedef BOOL (WINAPI *LPOCNCHKPROC) (IN SCARDCONTEXT, IN SCARDHANDLE, IN PVOID);
typedef void (WINAPI *LPOCNDSCPROC) (IN SCARDCONTEXT, IN SCARDHANDLE, IN PVOID);


//
// OPENCARD_SEARCH_CRITERIA: In order to specify a user-extended search,
// lpfnCheck must not be NULL.  Moreover, the connection to be made to the
// card before performing the callback must be indicated by either providing
// lpfnConnect and lpfnDisconnect OR by setting dwShareMode.
// If both the connection callbacks and dwShareMode are non-NULL, the callbacks
// will be used.
//

typedef struct {
    DWORD           dwStructSize;
    LPSTR           lpstrGroupNames;        // OPTIONAL reader groups to include in
    DWORD           nMaxGroupNames;         //          search.  NULL defaults to
                                            //          SCard$DefaultReaders
    LPCGUID         rgguidInterfaces;       // OPTIONAL requested interfaces
    DWORD           cguidInterfaces;        //          supported by card's SSP
    LPSTR           lpstrCardNames;         // OPTIONAL requested card names; all cards w/
    DWORD           nMaxCardNames;          //          matching ATRs will be accepted
    LPOCNCHKPROC    lpfnCheck;              // OPTIONAL if NULL no user check will be performed.
    LPOCNCONNPROCA  lpfnConnect;            // OPTIONAL if lpfnConnect is provided,
    LPOCNDSCPROC    lpfnDisconnect;         //          lpfnDisconnect must also be set.
    LPVOID          pvUserData;             // OPTIONAL parameter to callbacks
    DWORD           dwShareMode;            // OPTIONAL must be set if lpfnCheck is not null
    DWORD           dwPreferredProtocols;   // OPTIONAL
} OPENCARD_SEARCH_CRITERIAA, *POPENCARD_SEARCH_CRITERIAA, *LPOPENCARD_SEARCH_CRITERIAA;
typedef struct {
    DWORD           dwStructSize;
    LPWSTR          lpstrGroupNames;        // OPTIONAL reader groups to include in
    DWORD           nMaxGroupNames;         //          search.  NULL defaults to
                                            //          SCard$DefaultReaders
    LPCGUID         rgguidInterfaces;       // OPTIONAL requested interfaces
    DWORD           cguidInterfaces;        //          supported by card's SSP
    LPWSTR          lpstrCardNames;         // OPTIONAL requested card names; all cards w/
    DWORD           nMaxCardNames;          //          matching ATRs will be accepted
    LPOCNCHKPROC    lpfnCheck;              // OPTIONAL if NULL no user check will be performed.
    LPOCNCONNPROCW  lpfnConnect;            // OPTIONAL if lpfnConnect is provided,
    LPOCNDSCPROC    lpfnDisconnect;         //          lpfnDisconnect must also be set.
    LPVOID          pvUserData;             // OPTIONAL parameter to callbacks
    DWORD           dwShareMode;            // OPTIONAL must be set if lpfnCheck is not null
    DWORD           dwPreferredProtocols;   // OPTIONAL
} OPENCARD_SEARCH_CRITERIAW, *POPENCARD_SEARCH_CRITERIAW, *LPOPENCARD_SEARCH_CRITERIAW;
#ifdef UNICODE
typedef OPENCARD_SEARCH_CRITERIAW OPENCARD_SEARCH_CRITERIA;
typedef POPENCARD_SEARCH_CRITERIAW POPENCARD_SEARCH_CRITERIA;
typedef LPOPENCARD_SEARCH_CRITERIAW LPOPENCARD_SEARCH_CRITERIA;
#else
typedef OPENCARD_SEARCH_CRITERIAA OPENCARD_SEARCH_CRITERIA;
typedef POPENCARD_SEARCH_CRITERIAA POPENCARD_SEARCH_CRITERIA;
typedef LPOPENCARD_SEARCH_CRITERIAA LPOPENCARD_SEARCH_CRITERIA;
#endif // UNICODE


//
// OPENCARDNAME_EX: used by SCardUIDlgSelectCard; replaces obsolete OPENCARDNAME
//

typedef struct {
    DWORD           dwStructSize;           // REQUIRED
    SCARDCONTEXT    hSCardContext;          // REQUIRED
    HWND            hwndOwner;              // OPTIONAL
    DWORD           dwFlags;                // OPTIONAL -- default is SC_DLG_MINIMAL_UI
    LPCSTR          lpstrTitle;             // OPTIONAL
    LPCSTR          lpstrSearchDesc;        // OPTIONAL (eg. "Please insert your <brandname> smart card.")
    HICON           hIcon;                  // OPTIONAL 32x32 icon for your brand insignia
    POPENCARD_SEARCH_CRITERIAA pOpenCardSearchCriteria; // OPTIONAL
    LPOCNCONNPROCA  lpfnConnect;            // OPTIONAL - performed on successful selection
    LPVOID          pvUserData;             // OPTIONAL parameter to lpfnConnect
    DWORD           dwShareMode;            // OPTIONAL - if lpfnConnect is NULL, dwShareMode and
    DWORD           dwPreferredProtocols;   // OPTIONAL dwPreferredProtocols will be used to
                                            //          connect to the selected card
    LPSTR           lpstrRdr;               // REQUIRED [IN|OUT] Name of selected reader
    DWORD           nMaxRdr;                // REQUIRED [IN|OUT]
    LPSTR           lpstrCard;              // REQUIRED [IN|OUT] Name of selected card
    DWORD           nMaxCard;               // REQUIRED [IN|OUT]
    DWORD           dwActiveProtocol;       // [OUT] set only if dwShareMode not NULL
    SCARDHANDLE     hCardHandle;            // [OUT] set if a card connection was indicated
} OPENCARDNAME_EXA, *POPENCARDNAME_EXA, *LPOPENCARDNAME_EXA;
typedef struct {
    DWORD           dwStructSize;           // REQUIRED
    SCARDCONTEXT    hSCardContext;          // REQUIRED
    HWND            hwndOwner;              // OPTIONAL
    DWORD           dwFlags;                // OPTIONAL -- default is SC_DLG_MINIMAL_UI
    LPCWSTR         lpstrTitle;             // OPTIONAL
    LPCWSTR         lpstrSearchDesc;        // OPTIONAL (eg. "Please insert your <brandname> smart card.")
    HICON           hIcon;                  // OPTIONAL 32x32 icon for your brand insignia
    POPENCARD_SEARCH_CRITERIAW pOpenCardSearchCriteria; // OPTIONAL
    LPOCNCONNPROCW  lpfnConnect;            // OPTIONAL - performed on successful selection
    LPVOID          pvUserData;             // OPTIONAL parameter to lpfnConnect
    DWORD           dwShareMode;            // OPTIONAL - if lpfnConnect is NULL, dwShareMode and
    DWORD           dwPreferredProtocols;   // OPTIONAL dwPreferredProtocols will be used to
                                            //          connect to the selected card
    LPWSTR          lpstrRdr;               // REQUIRED [IN|OUT] Name of selected reader
    DWORD           nMaxRdr;                // REQUIRED [IN|OUT]
    LPWSTR          lpstrCard;              // REQUIRED [IN|OUT] Name of selected card
    DWORD           nMaxCard;               // REQUIRED [IN|OUT]
    DWORD           dwActiveProtocol;       // [OUT] set only if dwShareMode not NULL
    SCARDHANDLE     hCardHandle;            // [OUT] set if a card connection was indicated
} OPENCARDNAME_EXW, *POPENCARDNAME_EXW, *LPOPENCARDNAME_EXW;
#ifdef UNICODE
typedef OPENCARDNAME_EXW OPENCARDNAME_EX;
typedef POPENCARDNAME_EXW POPENCARDNAME_EX;
typedef LPOPENCARDNAME_EXW LPOPENCARDNAME_EX;
#else
typedef OPENCARDNAME_EXA OPENCARDNAME_EX;
typedef POPENCARDNAME_EXA POPENCARDNAME_EX;
typedef LPOPENCARDNAME_EXA LPOPENCARDNAME_EX;
#endif // UNICODE

#define OPENCARDNAMEA_EX OPENCARDNAME_EXA
#define OPENCARDNAMEW_EX OPENCARDNAME_EXW
#define POPENCARDNAMEA_EX POPENCARDNAME_EXA
#define POPENCARDNAMEW_EX POPENCARDNAME_EXW
#define LPOPENCARDNAMEA_EX LPOPENCARDNAME_EXA
#define LPOPENCARDNAMEW_EX LPOPENCARDNAME_EXW


//
// SCardUIDlgSelectCard replaces GetOpenCardName
//

extern WINSCARDAPI LONG WINAPI
SCardUIDlgSelectCardA(
    LPOPENCARDNAMEA_EX);
extern WINSCARDAPI LONG WINAPI
SCardUIDlgSelectCardW(
    LPOPENCARDNAMEW_EX);
#ifdef UNICODE
#define SCardUIDlgSelectCard  SCardUIDlgSelectCardW
#else
#define SCardUIDlgSelectCard  SCardUIDlgSelectCardA
#endif // !UNICODE


//
// "Smart Card Common Dialog" definitions for backwards compatibility
//  with the Smart Card Base Services SDK version 1.0
//

typedef struct {
    DWORD           dwStructSize;
    HWND            hwndOwner;
    SCARDCONTEXT    hSCardContext;
    LPSTR           lpstrGroupNames;
    DWORD           nMaxGroupNames;
    LPSTR           lpstrCardNames;
    DWORD           nMaxCardNames;
    LPCGUID         rgguidInterfaces;
    DWORD           cguidInterfaces;
    LPSTR           lpstrRdr;
    DWORD           nMaxRdr;
    LPSTR           lpstrCard;
    DWORD           nMaxCard;
    LPCSTR          lpstrTitle;
    DWORD           dwFlags;
    LPVOID          pvUserData;
    DWORD           dwShareMode;
    DWORD           dwPreferredProtocols;
    DWORD           dwActiveProtocol;
    LPOCNCONNPROCA  lpfnConnect;
    LPOCNCHKPROC    lpfnCheck;
    LPOCNDSCPROC    lpfnDisconnect;
    SCARDHANDLE     hCardHandle;
} OPENCARDNAMEA, *POPENCARDNAMEA, *LPOPENCARDNAMEA;
typedef struct {
    DWORD           dwStructSize;
    HWND            hwndOwner;
    SCARDCONTEXT    hSCardContext;
    LPWSTR          lpstrGroupNames;
    DWORD           nMaxGroupNames;
    LPWSTR          lpstrCardNames;
    DWORD           nMaxCardNames;
    LPCGUID         rgguidInterfaces;
    DWORD           cguidInterfaces;
    LPWSTR          lpstrRdr;
    DWORD           nMaxRdr;
    LPWSTR          lpstrCard;
    DWORD           nMaxCard;
    LPCWSTR         lpstrTitle;
    DWORD           dwFlags;
    LPVOID          pvUserData;
    DWORD           dwShareMode;
    DWORD           dwPreferredProtocols;
    DWORD           dwActiveProtocol;
    LPOCNCONNPROCW  lpfnConnect;
    LPOCNCHKPROC    lpfnCheck;
    LPOCNDSCPROC    lpfnDisconnect;
    SCARDHANDLE     hCardHandle;
} OPENCARDNAMEW, *POPENCARDNAMEW, *LPOPENCARDNAMEW;
#ifdef UNICODE
typedef OPENCARDNAMEW OPENCARDNAME;
typedef POPENCARDNAMEW POPENCARDNAME;
typedef LPOPENCARDNAMEW LPOPENCARDNAME;
#else
typedef OPENCARDNAMEA OPENCARDNAME;
typedef POPENCARDNAMEA POPENCARDNAME;
typedef LPOPENCARDNAMEA LPOPENCARDNAME;
#endif // UNICODE

// Backwards compatibility macros
#define OPENCARDNAME_A OPENCARDNAMEA
#define OPENCARDNAME_W OPENCARDNAMEW
#define POPENCARDNAME_A POPENCARDNAMEA
#define POPENCARDNAME_W POPENCARDNAMEW
#define LPOPENCARDNAME_A LPOPENCARDNAMEA
#define LPOPENCARDNAME_W LPOPENCARDNAMEW

extern WINSCARDAPI LONG WINAPI
GetOpenCardNameA(
    LPOPENCARDNAMEA);
extern WINSCARDAPI LONG WINAPI
GetOpenCardNameW(
    LPOPENCARDNAMEW);
#ifdef UNICODE
#define GetOpenCardName  GetOpenCardNameW
#else
#define GetOpenCardName  GetOpenCardNameA
#endif // !UNICODE

extern WINSCARDAPI LONG WINAPI
SCardDlgExtendedError (void);

#ifdef __cplusplus
}
#endif
#endif // _WINSCARD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\sclogon\sclogon.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ScLogon

Abstract:

    This module provides helper functions for use by winlogon (GINA, Kerberos)

Author:

    Amanda Matlosz (amatlosz) 10/22/1997

Environment:

    Win32, C++ w/ Exceptions

Notes:

        03-11-98 Wrap calls to GetLastError() to workaround bug where LastErr gets
                        clobbered.  Added event logging to make logon smoother.

                04-02-98 Removed all references to WinVerifyTrust; this is something
                                                Kerberos itself is responsible for.
--*/

/////////////////////////////////////////////////////////////////////////////
//
// Includes

#if !defined(_AMD64_) && !defined(_X86_) && !defined(_IA64_)
#define _X86_ 1
#endif
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#ifndef UNICODE
#define UNICODE
#endif
#endif
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN 1
#endif


extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
}

#include <windows.h>
#include <winscard.h>
#include <wincrypt.h>
#include <softpub.h>
#include <stddef.h>
#include <crtdbg.h>
#include "sclogon.h"
#include "unicodes.h"
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <tchar.h>

#define STATUS_SMARTCARD_SUBSYSTEM_FAILURE 0x8000ffff
#define EVENT_ID_BUILDCC 3
#define EVENT_ID_GETCERT 3
#define EVENT_ID_GETPROVPARAM 3
#define EVENT_ID_VERIFYCARD 3
#define EVENT_ID_GENRANDBITS 3
#define EVENT_ID_SIGNMSG_NOSC 3
#define EVENT_ID_SIGNMSG 3
#define EVENT_ID_VERIFYMSG_NOSC 3
#define EVENT_ID_VERIFYMSG 3
#define EVENT_ID_ENCMSG_NOSC 3
#define EVENT_ID_ENCMSG 3
#define EVENT_ID_DECMSG_NOSC 3
#define EVENT_ID_DECMSG 3

#ifndef KP_KEYEXCHANGE_PIN
#define KP_KEYEXCHANGE_PIN 32
#else
#if 32 != KP_KEYEXCHANGE_PIN
#error Invalid KP_KEYEXCHANGE_PIN assumption
#endif
#endif
#ifndef CRYPT_SILENT
#define CRYPT_SILENT 0x40
#else
#if 0x40 != CRYPT_SILENT
#error Duplicate CRYPT_SILENT definition
#endif
#endif
#ifndef SCARD_PROVIDER_CSP
#define SCARD_PROVIDER_CSP 2
#else
#if 2 != SCARD_PROVIDER_CSP
#error Invalid SCARD_PROVIDER_CSP definition
#endif
#endif

#if defined(DBG) || defined(DEBUG)
BOOL SCDebug = TRUE;
#define DebugPrint(a) _DebugPrint a
void
__cdecl
_DebugPrint(
    LPCSTR szFormat,
    ...
    )
{
    if (SCDebug) {
        CHAR szBuffer[512];
        va_list ap;

        va_start(ap, szFormat);
        vsprintf(szBuffer, szFormat, ap);
        OutputDebugStringA(szBuffer);
    }
}
#else
#define DebugPrint(a)
#endif

// TODO: The following logging is still proving useful.
// TODO: leave in for B3: integrate more tightly w/ winlogon/kerberos ??
//#include <sclmsg.h>

// A Global class used to maintain internal state.
class CSCLogonInit
{
public:
    // Runs at image creation
    CSCLogonInit(
        BOOL *pfResult)
    {
        m_hCrypt = NULL;
        *pfResult = TRUE;
    };

    // Runs at image termination
    ~CSCLogonInit()
    {
        Release();
    };

    // Cleans up current state.
    void
    Release(
        void)
    {
        if (NULL != m_hCrypt)
        {
            CryptReleaseContext(m_hCrypt, 0);
            m_hCrypt = NULL;
        }
    }

    // Relinquish control of the crypto context.
    HCRYPTPROV
    RelinquishCryptCtx(
        LogonInfo* pLogon)
    {
        HCRYPTPROV hProv;

        hProv = CryptCtx(pLogon);
        m_hCrypt = NULL;
        return hProv;
    };

    // Get the crypto context, creating it if it's not there.
    HCRYPTPROV
    CryptCtx(
        LogonInfo* pLogon)
    {
        HCRYPTPROV hProv;
        LPCTSTR szRdr = NULL;
        LPCTSTR szCntr = NULL;
        LPTSTR szFQCN = NULL;
        LONG lLen = 0;

        if (NULL == m_hCrypt)
        {
            BOOL fSts;

            // Prepare FullyQualifiedContainerName for CryptAcCntx call

            szRdr = GetReaderName((LPBYTE)pLogon);
            szCntr = GetContainerName((LPBYTE)pLogon);

            lLen = (lstrlen(szRdr) + lstrlen(szCntr) + 10)*sizeof(TCHAR);
            szFQCN = (LPTSTR)LocalAlloc(LPTR, lLen);
            if (NULL != szFQCN)
            {
                wsprintf(szFQCN, TEXT("\\\\.\\%s\\%s"), szRdr, szCntr);

                fSts = CryptAcquireContext(
                    &m_hCrypt,
                    szFQCN,
                    GetCSPName((LPBYTE)pLogon),
                    PROV_RSA_FULL,  // ?TODO? from pbLogonInfo
                    CRYPT_SILENT | CRYPT_MACHINE_KEYSET
                    );

                LocalFree(szFQCN);
            }
            else
            {
                fSts = FALSE;
            }
        }
        hProv = m_hCrypt;
        return hProv;
    }

protected:
    HCRYPTPROV m_hCrypt;
};

// For tracing errors in ScHelper*

NTSTATUS LogEvent(NTSTATUS NtErr, DWORD dwEventID)
{
#ifndef _XBOX
    DWORD dwErr;
    //
    // Convert the error back to a Win32 error
    //
    switch (NtErr)
    {
    case STATUS_INVALID_PARAMETER:
        dwErr = ERROR_INVALID_DATA;
        break;

    case STATUS_SMARTCARD_SUBSYSTEM_FAILURE:
            // A Cryptxxx API just failed
        dwErr = GetLastError();
        switch (dwErr)
        {
        case SCARD_W_WRONG_CHV:
        case SCARD_E_INVALID_CHV:
            NtErr = STATUS_SMARTCARD_WRONG_PIN;
            break;

        case SCARD_W_CHV_BLOCKED:
            NtErr = STATUS_SMARTCARD_CARD_BLOCKED;
            break;

        case SCARD_W_REMOVED_CARD:
        case SCARD_E_NO_SMARTCARD:
            NtErr = STATUS_SMARTCARD_NO_CARD;
            break;

        case NTE_BAD_KEYSET:
        case NTE_KEYSET_NOT_DEF:
            NtErr = STATUS_SMARTCARD_NO_KEY_CONTAINER;
            break;

        case SCARD_E_NO_SUCH_CERTIFICATE:
        case SCARD_E_CERTIFICATE_UNAVAILABLE:
            NtErr = STATUS_SMARTCARD_NO_CERTIFICATE;
            break;

        case NTE_NO_KEY:
            NtErr = STATUS_SMARTCARD_NO_KEYSET;
            break;

        case SCARD_E_TIMEOUT:
        case SCARD_F_COMM_ERROR:
        case SCARD_E_COMM_DATA_LOST:
            NtErr = STATUS_SMARTCARD_IO_ERROR;
            break;

        //default:
            // Nothing, leave NtErr unchanged
        }
        break;

    case STATUS_INSUFFICIENT_RESOURCES:
    case STATUS_NO_MEMORY:
        dwErr = ERROR_OUTOFMEMORY;
        break;

    case STATUS_BUFFER_TOO_SMALL:
        dwErr = SEC_E_BUFFER_TOO_SMALL;
        break;

    default:
        dwErr = SCARD_E_UNEXPECTED;
    }

    if (0 == dwErr)
    {
        return NtErr;
    }

    //
    // Initialize log as necessary
    //
    HKEY    hKey;
    DWORD   disp;

    long err = RegCreateKeyEx(
        HKEY_LOCAL_MACHINE,
        TEXT("System\\CurrentControlSet\\Services\\EventLog\\Application\\Smart Card Logon"),
        0,
        TEXT(""),
        REG_OPTION_NON_VOLATILE,
        KEY_WRITE,
        NULL,
        &hKey,
        &disp
        );

    if (ERROR_SUCCESS != err)
    {
        return NtErr;
    }

    if (disp == REG_CREATED_NEW_KEY)
    {
        PBYTE l_szModulePath = (PBYTE)TEXT("%SystemRoot%\\System32\\scarddlg.dll");
        ULONG l_uLen = (_tcslen((LPCTSTR)l_szModulePath) + 1)*sizeof(TCHAR);

        RegSetValueEx(
            hKey,
            TEXT("EventMessageFile"),
            0,
            REG_EXPAND_SZ,
            l_szModulePath,
            l_uLen
            );

        disp = (DWORD)(
            EVENTLOG_ERROR_TYPE |
            EVENTLOG_WARNING_TYPE |
            EVENTLOG_INFORMATION_TYPE
            );

        RegSetValueEx(
            hKey,
            TEXT("TypesSupported"),
            0,
            REG_DWORD,
            (PBYTE) &disp,
            sizeof(DWORD)
            );
    }

    RegCloseKey(hKey);

    HANDLE hEventSource = RegisterEventSource(
        NULL,
        TEXT("Smart Card Logon")
        );

    if (NULL != hEventSource)
    {
        DWORD dwLen = 0;
        LPTSTR szErrorString = NULL;
        TCHAR szBuffer[2+8+1];  // Enough for "0x????????"

        dwLen = FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER
                | FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                dwErr,
                LANG_NEUTRAL,
                (LPTSTR)&szErrorString,
                0,
                NULL);

        if (dwLen == 0)
        {
            _stprintf(szBuffer, _T("0x%08lX"), dwErr);
            szErrorString = szBuffer;
        }

        ReportEvent(
            hEventSource,
            EVENTLOG_ERROR_TYPE,
            0,              // event category
            dwEventID,      // event identifier // resourceID for the messagetable entry...
            NULL,           // user security identifier (optional)
            1,              // number of strings to merge with message
            sizeof(long),   // size of binary data, in bytes
            (LPCTSTR*)&szErrorString,   // array of strings to merge with message
            (LPVOID)&dwErr   // address of binary data
            );

        DeregisterEventSource(hEventSource);

        if ((NULL != szErrorString) && (szErrorString != szBuffer))
        {
            LocalFree((LPVOID)szErrorString);
        }

    }

    return NtErr;
#else
	return ERROR_SUCCESS;
#endif
}


//////////////////////////////////////////////////////////////////////////////
//
// Structs



//////////////////////////////////////////////////////////////////////////////
//
// Functions
//

// Internal helpers: called by the ScLogon APIs to perform certain tedious work

/*++

GetReaderName:
GetCardName:
GetContainerName:
GetCSPName:

  : Intended for accessing the LogonInformation glob

Author:

        Amanda Matlosz

Note:

  Some of these are made available to outside callers; see sclogon.h

--*/

extern "C"
PBYTE
WINAPI
ScBuildLogonInfo(
    LPCTSTR szCard,
    LPCTSTR szReader,
    LPCTSTR szContainer,
    LPCTSTR szCSP)
{
    // No assumptions are made regarding the values of the incoming parameters;
    // At this point, it is legal for them all to be empty.
    // It is also possible that NULL values are being passed in -- if this is the case,
    // they must be replaced with empty strings.

    LPCTSTR szCardI = TEXT("");
    LPCTSTR szReaderI = TEXT("");
    LPCTSTR szContainerI = TEXT("");
    LPCTSTR szCSPI = TEXT("");

    if (NULL != szCard)
    {
        szCardI = szCard;
    }
    if (NULL != szReader)
    {
        szReaderI = szReader;
    }
    if (NULL != szContainer)
    {
        szContainerI = szContainer;
    }
    if (NULL != szCSP)
    {
        szCSPI = szCSP;
    }


    //
    // Build the LogonInfo glob using strings (or empty strings)
    //

    DWORD cbLi = offsetof(LogonInfo, bBuffer)
                 + (lstrlen(szCardI) + 1) * sizeof(TCHAR)
                 + (lstrlen(szReaderI) + 1) * sizeof(TCHAR)
                 + (lstrlen(szContainerI) + 1) * sizeof(TCHAR)
                 + (lstrlen(szCSPI) + 1) * sizeof(TCHAR);
    LogonInfo* pLI = (LogonInfo*)LocalAlloc(LPTR, cbLi);

    if (NULL == pLI)
    {
        return NULL;
    }

    pLI->ContextInformation = NULL;
    pLI->dwLogonInfoLen = cbLi;
    LPTSTR pBuffer = pLI->bBuffer;

    pLI->nCardNameOffset = 0;
    lstrcpy(pBuffer, szCardI);
    pBuffer += (lstrlen(szCardI)+1);

    pLI->nReaderNameOffset = (ULONG) (pBuffer-pLI->bBuffer);
    lstrcpy(pBuffer, szReaderI);
    pBuffer += (lstrlen(szReaderI)+1);

    pLI->nContainerNameOffset = (ULONG) (pBuffer-pLI->bBuffer);
    lstrcpy(pBuffer, szContainerI);
    pBuffer += (lstrlen(szContainerI)+1);

    pLI->nCSPNameOffset = (ULONG) (pBuffer-pLI->bBuffer);
    lstrcpy(pBuffer, szCSPI);
    pBuffer += (lstrlen(szCSPI)+1);

    _ASSERTE(cbLi == (DWORD)((LPBYTE)pBuffer - (LPBYTE)pLI));
    return (PBYTE)pLI;
}


LPCTSTR WINAPI GetReaderName(PBYTE pbLogonInfo)
{
    LogonInfo* pLI = (LogonInfo*)pbLogonInfo;

    if (NULL == pLI)
    {
        return NULL;
    }
    return &pLI->bBuffer[pLI->nReaderNameOffset];
};

LPCTSTR WINAPI GetCardName(PBYTE pbLogonInfo)
{
    LogonInfo* pLI = (LogonInfo*)pbLogonInfo;

    if (NULL == pLI)
    {
        return NULL;
    }
    return &pLI->bBuffer[pLI->nCardNameOffset];
};

LPCTSTR WINAPI GetContainerName(PBYTE pbLogonInfo)
{
    LogonInfo* pLI = (LogonInfo*)pbLogonInfo;

    if (NULL == pLI)
    {
        return NULL;
    }
    return &pLI->bBuffer[pLI->nContainerNameOffset];
};

LPCTSTR WINAPI GetCSPName(PBYTE pbLogonInfo)
{
    LogonInfo* pLI = (LogonInfo*)pbLogonInfo;

    if (NULL == pLI)
    {
        return NULL;
    }
    return &pLI->bBuffer[pLI->nCSPNameOffset];
};

/*++
BuildCertContext:

  Generates a certificate context with (static) keyprov info suitable for
  CertStore-based operations.

        If the PIN is provided, it is assumed the hProv (if provided) has not had the
        PIN parameter set...



Arguments:

    hProv -- must be a valid HCRYPTPROV

    pucPIN -- may be empty; used to set the PIN for hProv

    pbCert -- assumed to be a valid certificate; must not be NULL
    dwCertLen

    CertificateContext -- pointer to a pointer to the resultant CertContext

Return Value:

        NTSTATUS indicating STATUS_SUCCESS or error (see winerror.h or scarderr.h)

Author:

        Amanda Matlosz

Note:

--*/
NTSTATUS
BuildCertContext(
    IN HCRYPTPROV hProv,
    IN PUNICODE_STRING pucPIN,
    IN PBYTE pbCert,
    IN DWORD dwCertLen,
    OUT PCCERT_CONTEXT *CertificateContext
    )
{
    NTSTATUS lResult = STATUS_SUCCESS;
    BOOL fSts = FALSE;

    CRYPT_KEY_PROV_INFO KeyProvInfo;
    LPSTR szContainerName = NULL;
    LPSTR szProvName = NULL;
    CUnicodeString wszContainerName, wszProvName;
    DWORD cbContainerName, cbProvName;

    //
    // Check params
    //
    if ((NULL == hProv) || (NULL == pbCert || 0 == dwCertLen))
    {
        ASSERT(FALSE);
        lResult = STATUS_INVALID_PARAMETER;
        goto ErrorExit;
    }

    //
    // Convert the certificate into a Cert Context.
    //
    *CertificateContext = CertCreateCertificateContext(
                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                    pbCert,
                    dwCertLen);
    if (NULL == *CertificateContext)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    //
    //  Associate cryptprovider w/ the private key property of this cert
    //

    //  ... need the container name

    fSts = CryptGetProvParam(
            hProv,
            PP_CONTAINER,
            NULL,     // out
            &cbContainerName,   // in/out
            0);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }
    szContainerName = (LPSTR)LocalAlloc(LPTR, cbContainerName);
    if (NULL == szContainerName)
    {
        lResult = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }
    fSts = CryptGetProvParam(
            hProv,
            PP_CONTAINER,
            (PBYTE)szContainerName,     // out
            &cbContainerName,   // in/out
            0);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }
    wszContainerName = szContainerName;

    //  ... need the provider name

    fSts = CryptGetProvParam(
            hProv,
            PP_NAME,
            NULL,     // out
            &cbProvName,   // in/out
            0);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }
    szProvName = (LPSTR)LocalAlloc(LPTR, cbProvName);
    if (NULL == szProvName)
    {
        lResult = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }
    fSts = CryptGetProvParam(
            hProv,
            PP_NAME,
            (PBYTE)szProvName,     // out
            &cbProvName,   // in/out
            0);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }
    wszProvName = szProvName;

    //
    // Set the cert context properties to reflect the prov info
    //

    KeyProvInfo.pwszContainerName = (LPWSTR)(LPCWSTR)wszContainerName;
    KeyProvInfo.pwszProvName = (LPWSTR)(LPCWSTR)wszProvName;
    KeyProvInfo.dwProvType = PROV_RSA_FULL;
    KeyProvInfo.dwFlags = CERT_SET_KEY_CONTEXT_PROP_ID;
    KeyProvInfo.cProvParam = 0;
    KeyProvInfo.rgProvParam = NULL;
    KeyProvInfo.dwKeySpec = AT_KEYEXCHANGE;
    KeyProvInfo.dwFlags |= CERT_SET_KEY_CONTEXT_PROP_ID;

    fSts = CertSetCertificateContextProperty(
                *CertificateContext,
                CERT_KEY_PROV_INFO_PROP_ID,
                0,
                (void *)&KeyProvInfo);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;

        // the cert's been incorrectly created -- scrap it.
        CertFreeCertificateContext(*CertificateContext);
        *CertificateContext = NULL;

        goto ErrorExit;
    }

    CERT_KEY_CONTEXT certKeyContext;
    certKeyContext.cbSize = sizeof(CERT_KEY_CONTEXT);
    certKeyContext.hCryptProv = hProv;
    certKeyContext.dwKeySpec = KeyProvInfo.dwKeySpec;

    fSts = CertSetCertificateContextProperty(
                *CertificateContext,
                CERT_KEY_CONTEXT_PROP_ID,
                0,
                (void *)&certKeyContext);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;

        // the cert's been incorrectly created -- scrap it.
        CertFreeCertificateContext(*CertificateContext);
        *CertificateContext = NULL;

        goto ErrorExit;
    }

ErrorExit:

    if(NULL != szContainerName)
    {
        LocalFree(szContainerName);
        szContainerName = NULL;
    }
    if(NULL != szProvName)
    {
        LocalFree(szProvName);
        szProvName = NULL;
    }

    if (!NT_SUCCESS(lResult))
    {
        lResult = LogEvent(lResult, (DWORD)EVENT_ID_BUILDCC);
    }

    return lResult;
}


///////////////////////////////////////////////////////////////////////////////
//
// ScLogon APIs
//


/*++

ScHelperInitializeContext:

        Prepares contextual information to be used by LSA while handling this
        smart card session.

Arguments:

        None.

Return Value:

        None

Author:

        Richard Ward

Note:

        Used by LSA.

--*/
NTSTATUS WINAPI
ScHelperInitializeContext(
    IN OUT PBYTE pbLogonInfo,
    IN ULONG cbLogonInfo
    )
{
    ULONG AllowedSize;

    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    if ((cbLogonInfo < sizeof(ULONG)) ||
        (cbLogonInfo != pLI->dwLogonInfoLen))
    {
        return(STATUS_INVALID_PARAMETER);
    }

    AllowedSize = (cbLogonInfo - sizeof(LogonInfo) ) / sizeof(TCHAR) + sizeof(DWORD) ;
    //
    // Verify the other fields of the logon info
    //
    if ((pLI->nCardNameOffset > pLI->nReaderNameOffset) ||
        (pLI->bBuffer[pLI->nReaderNameOffset-1] != TEXT('\0')))
    {
        return(STATUS_INVALID_PARAMETER);
    }
    if ((pLI->nReaderNameOffset > pLI->nContainerNameOffset) ||
        (pLI->bBuffer[pLI->nContainerNameOffset-1] != TEXT('\0')))
    {
        return(STATUS_INVALID_PARAMETER);
    }
    if ((pLI->nContainerNameOffset > pLI->nCSPNameOffset) ||
        (pLI->bBuffer[pLI->nCSPNameOffset-1] != TEXT('\0')))
    {
        return(STATUS_INVALID_PARAMETER);
    }
    if ((pLI->nCSPNameOffset > AllowedSize) ||
        (pLI->bBuffer[AllowedSize-1] != TEXT('\0')))
    {
        return(STATUS_INVALID_PARAMETER);
    }


    _ASSERTE(pLI->ContextInformation == NULL);

    BOOL fResult;
    pLI->ContextInformation = new CSCLogonInit(&fResult);
    if (pLI->ContextInformation == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    else
    {
        if (!fResult)
        {
            delete pLI->ContextInformation;
            pLI->ContextInformation = NULL;
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
    }

    return(STATUS_SUCCESS);
}

/*++

ScHelperRelease:

        Releases contextual information used by LSA while handling this
        smart card session.

Arguments:

        None.

Return Value:

        None

Author:

        Richard Ward

Note:

        Used by LSA.

--*/
VOID WINAPI
ScHelperRelease(
    IN OUT PBYTE pbLogonInfo
    )
{
    _ASSERTE(NULL != pbLogonInfo);
    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    CSCLogonInit * LogonInit = (CSCLogonInit *) pLI->ContextInformation;

    if (LogonInit != NULL)
    {
        LogonInit->Release();
        delete LogonInit;
        pLI->ContextInformation = NULL;
    }
}


/*++

ScHelperGetCertFromLogonInfo:

        Returns a CertificateContext for the cert on the card specified by the
        LogonInfo.  Creates the cert context by calling BuildCertContext,
        which generates a certificate context with (static) keyprov info
        suitable for CertStore-based operations.

Arguments:

        pucPIN may need the PIN to get a cert off certain SCs

Return Value:

        None

Author:

        Amanda Matlosz

Note:

        Used by LSA.

--*/
NTSTATUS WINAPI
ScHelperGetCertFromLogonInfo(
    IN PBYTE pbLogonInfo,
    IN PUNICODE_STRING pucPIN,
    OUT PCCERT_CONTEXT *CertificateContext
    )
{
    _ASSERTE(NULL != pbLogonInfo);
    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    CSCLogonInit * LogonInit = (CSCLogonInit *) pLI->ContextInformation;
    BOOL fSts;
    NTSTATUS lResult = STATUS_SUCCESS;
    PCCERT_CONTEXT pCertCtx = NULL;
    HCRYPTPROV hProv = NULL;
    HCRYPTKEY hKey = NULL;
    LPBYTE pbCert = NULL;
    DWORD cbCertLen;

    //
    // Make sure we've got a Crypto Provider up and running.
    //
    hProv = LogonInit->RelinquishCryptCtx(pLI);
    if (NULL == hProv)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    //
    // Get the key handle.
    //
    fSts = CryptGetUserKey(
                hProv,
                AT_KEYEXCHANGE,
                &hKey);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }


    //
    // Upload the certificate.
    //

    fSts = CryptGetKeyParam(
                hKey,
                KP_CERTIFICATE,
                NULL,
                &cbCertLen,
                0);
    if (!fSts)
    {
        DWORD dwGLE = GetLastError();

        if (ERROR_MORE_DATA != dwGLE)
        {
            if (NTE_NOT_FOUND == dwGLE)
            {
                SetLastError(SCARD_E_NO_SUCH_CERTIFICATE);
            }
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
            goto ErrorExit;
        }
    }
    
    pbCert = (LPBYTE)LocalAlloc(LPTR, cbCertLen);
    if (NULL == pbCert)
    {
        lResult = STATUS_NO_MEMORY;
        goto ErrorExit;
    }
    fSts = CryptGetKeyParam(
                hKey,
                KP_CERTIFICATE,
                pbCert,
                &cbCertLen,
                0);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    lResult = BuildCertContext(
        hProv,
        pucPIN,
        pbCert,
        cbCertLen,
        &pCertCtx);
    if (NT_SUCCESS(lResult))
    {
        // The cert context will take care of the crypt context now.
        hProv = NULL;
    }

    //
    // Clean up and return.
    //

ErrorExit:
    *CertificateContext = pCertCtx;

        // Do this early so GetLastError is not clobbered
    if (!NT_SUCCESS(lResult))
    {
        lResult = LogEvent(lResult, (DWORD)EVENT_ID_GETCERT);
    }

    if (NULL != hKey)
    {
        CryptDestroyKey(hKey);
    }
    if (NULL != hProv)
    {
        CryptReleaseContext(hProv, 0);
    }
    if (NULL != pbCert)
    {
        LocalFree(pbCert);
    }

    return lResult;
}

/*++

ScHelperGetProvParam:

        This API wraps the CryptGetProvParam routine for use with a smart card.
Arguments:

        pucPIN supplies a Unicode string containing the card's PIN.


        pbLogonInfo supplies the information required to identify the card, csp,
                etc.  It cannot be NULL.

        The other parameters are identical to CryptGetProvParam


Return Value:

    A STATUS_SUCECSS for success, or an error
--*/

NTSTATUS WINAPI
ScHelperGetProvParam(
    IN PUNICODE_STRING pucPIN,
    IN PBYTE pbLogonInfo,
    DWORD dwParam,
    BYTE*pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags
    )
{
    _ASSERTE(NULL != pbLogonInfo);

    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    CSCLogonInit * LogonInit = (CSCLogonInit *) pLI->ContextInformation;
    NTSTATUS lResult = STATUS_SUCCESS;
    HCRYPTPROV hProv = NULL;
    BOOL fSts;


    hProv = LogonInit->CryptCtx(pLI);
    if (NULL == hProv)
    {
        return LogEvent(STATUS_SMARTCARD_SUBSYSTEM_FAILURE, (DWORD)EVENT_ID_GETPROVPARAM);
    }

    fSts = CryptGetProvParam(
            hProv,
            dwParam,
            pbData,
            pdwDataLen,
            dwFlags
            );

    if (!fSts)
    {
        if (GetLastError() == ERROR_NO_MORE_ITEMS)
        {
            return (STATUS_NO_MORE_ENTRIES);
        }
        else
        {
            return LogEvent(STATUS_SMARTCARD_SUBSYSTEM_FAILURE, (DWORD)EVENT_ID_GETPROVPARAM);
        }
    }
    
    return(STATUS_SUCCESS);    
}


/*++

ScHelperVerifyCard:

        This API provides an easy way to verify the integrity of the card
        identified by pbLogonInfo (ie, that it has the private key associated
        w/ the public key contained in the certificate it returned via
        ScHelperGetCertFromLogonInfo) and, in so doing, authenticates the user
                to the card.

Arguments:

        pucPIN supplies a Unicode string containing the card's PIN.

        CertificateContext supplies the cert context received via
                ScHelperGetCertFromLogonInfo.

        hCertStore supplies the handle of a cert store which contains a CTL to
                use during certificate verification, or NULL to use the system default
                store.

        pbLogonInfo supplies the information required to identify the card, csp,
                etc.  It cannot be NULL.


Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    STATUS_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.
--*/

NTSTATUS WINAPI
ScHelperVerifyCard(
    IN PUNICODE_STRING pucPIN,
    IN PCCERT_CONTEXT CertificateContext,
    IN HCERTSTORE hCertStore,
    IN PBYTE pbLogonInfo
    )
{
    _ASSERTE(NULL != pbLogonInfo);

    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    CSCLogonInit * LogonInit = (CSCLogonInit *) pLI->ContextInformation;
    NTSTATUS lResult = STATUS_SUCCESS;
    HCRYPTHASH hHash = NULL;
    HCRYPTPROV hProv = NULL;
    HCRYPTKEY hKey = NULL;
    PBYTE pbBlob = NULL;
    ULONG ulBlobLen = 32;
    PBYTE pbSignature = NULL;
    ULONG ulSigLen = 0;
    BOOL fSts;

    //
    // Make sure we've got a Crypto Provider up and running.
    //

    hProv = LogonInit->CryptCtx(pLI);
    if (NULL == hProv)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    //
    // Generate a random key blob as the message to sign
    //

    pbBlob = (LPBYTE)LocalAlloc(LPTR, ulBlobLen);
    if (NULL == pbBlob)
    {
        lResult = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }

    fSts = CryptGenRandom(hProv, ulBlobLen, pbBlob);

    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    //
    // The card signs a hash of the message...
    //

    lResult = ScHelperSignMessage(
                pucPIN,
                pbLogonInfo,
                NULL,
                CALG_MD5,
                pbBlob,
                ulBlobLen,
                pbSignature,
                &ulSigLen);

    if (STATUS_BUFFER_TOO_SMALL != lResult)
    {
        goto ErrorExit;
    }

    pbSignature = (LPBYTE)LocalAlloc(LPTR, ulSigLen);

    if (NULL == pbSignature)
    {
        lResult = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }

    lResult = ScHelperSignMessage(
                pucPIN,
                pbLogonInfo,
                NULL,
                CALG_MD5,
                pbBlob,
                ulBlobLen,
                pbSignature,
                &ulSigLen);

    if (!NT_SUCCESS(lResult))
    {
        goto ErrorExit;
    }

    //
    // Verify the signature is correct
    //

    lResult = ScHelperVerifyMessage(
                pbLogonInfo,
                NULL,
                CertificateContext,
                CALG_MD5,
                pbBlob,
                ulBlobLen,
                pbSignature,
                ulSigLen);

    //
    // Clean up and return.
    //

ErrorExit:

        // Do this early so GetLastError is not clobbered
    if (!NT_SUCCESS(lResult))
    {
        lResult = LogEvent(lResult, (DWORD)EVENT_ID_VERIFYCARD);
    }

    if (NULL != hKey)
    {
        CryptDestroyKey(hKey);
    }
    if (NULL != pbSignature)
    {
        LocalFree(pbSignature);
    }
    if (NULL != pbBlob)
    {
            LocalFree(pbBlob);
    }

    return lResult;
}


NTSTATUS WINAPI
ScHelperGenRandBits(
    IN PBYTE pbLogonInfo,
    IN OUT ScHelper_RandomCredBits* psc_rcb
)
{
    _ASSERTE(NULL != pbLogonInfo);

    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    CSCLogonInit * LogonInit = (CSCLogonInit *) pLI->ContextInformation;
    NTSTATUS lResult = STATUS_SUCCESS;
    HCRYPTPROV hProv = NULL;
    BOOL fSts = FALSE;

    //
    // Make sure we've got a Crypto Provider up and running.
    //

    hProv = LogonInit->CryptCtx(pLI);
    if (NULL == hProv)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    memset(psc_rcb, 0, sizeof(*psc_rcb));
    fSts = CryptGenRandom(hProv, 32, psc_rcb->bR1);

    if (fSts)
    {
        fSts = CryptGenRandom(hProv, 32, psc_rcb->bR2);
    }

    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
    }

ErrorExit:

    if (!NT_SUCCESS(lResult))
    {
        lResult = LogEvent(lResult, (DWORD)EVENT_ID_GENRANDBITS);
    }

    return lResult;
}


/*++

ScHelperCreateCredKeys:

    This routine (called by ScHelperVerifyCardAndCreds and
    ScHelperEncryptCredentials) munges a R1 and R2 to derive symmetric keys
    for encrypting and decrypting KDC creds, and or genearting an HMAC.

Arguments:

        pucPIN supplies a Unicode string containing the card's PIN.

        pbLogonInfo supplies the information required to identify the card, csp,
                etc.  It cannot be NULL.

        psc_rcb supplies the R1 and R2, previously generated by a call to
                ScHelperGenRandBits.

        phHmacKey recieves the generated HMAC key.

        phRc4Key receives the generated RC4 key.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    STATUS_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Remarks:

    You may supply a value of NULL to EncryptedData to receive only the
    required size of the EncryptedData buffer.

Author:

    Amanda Matlosz (amatlosz) 6/23/1999

--*/

NTSTATUS WINAPI
ScHelperCreateCredKeys(
    IN PUNICODE_STRING pucPIN,
    IN PBYTE pbLogonInfo,
    IN ScHelper_RandomCredBits* psc_rcb,
    IN OUT HCRYPTKEY* phHmacKey,
    IN OUT HCRYPTKEY* phRc4Key,
    IN OUT HCRYPTPROV* phProv
)
{
    NTSTATUS lResult = STATUS_SUCCESS;
    HCRYPTHASH hHash = NULL;
    HCRYPTPROV hProv = NULL;
    PBYTE pbR1Sig = NULL;
    DWORD dwR1SigLen = 0;
    HCRYPTHASH hKHash = NULL;
    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    CUnicodeString szPin(pucPIN);
    BOOL fSts = FALSE;
    *phProv = NULL;

    // check params

    if (NULL == psc_rcb || NULL == phHmacKey || NULL == phRc4Key)
    {
        return(STATUS_INVALID_PARAMETER);
    }

    // Get hProv for smart card

    if (NULL != pucPIN)
    {
		if (!szPin.Valid())
		{
			return(STATUS_INSUFFICIENT_RESOURCES);
		}
	}

    CSCLogonInit * LogonInit = (CSCLogonInit *) pLI->ContextInformation;
    hProv = LogonInit->CryptCtx(pLI);
    if (NULL == hProv)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    // Sign R1 w/ smart card

    fSts = CryptCreateHash(
        hProv,
        CALG_SHA1,
        NULL,
        NULL,
        &hHash);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    fSts = CryptHashData(
                hHash,
                psc_rcb->bR1,
                32, // TODO: const
                0);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    //
    // Declare the PIN.
    //

    if (NULL != pucPIN)
    {
        fSts = CryptSetProvParam(
                hProv,
                PP_KEYEXCHANGE_PIN,
                (LPBYTE)((LPCSTR)szPin),
                0);
        if (!fSts)
        {
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
            goto ErrorExit;
        }
    }

    fSts = CryptSignHash(
        hHash,
        AT_KEYEXCHANGE,
        NULL,
        0,
        NULL,
        &dwR1SigLen);
//  if (fSts || ERROR_MORE_DATA != GetLastError())
    if (0 >= dwR1SigLen)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    pbR1Sig = (LPBYTE)LocalAlloc(LPTR, dwR1SigLen);

    if (NULL == pbR1Sig)
    {
        lResult = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }

    fSts = CryptSignHash(
        hHash,
        AT_KEYEXCHANGE,
        NULL,
        0,
        pbR1Sig,
        &dwR1SigLen);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    // TODO: sigR1 is the key to hash R2 with;
    // for now, just hash 'em together; use generic CSP
    fSts = CryptAcquireContext(
        phProv,
        NULL,
        NULL,
        PROV_RSA_FULL,
        CRYPT_VERIFYCONTEXT
        );
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    fSts = CryptCreateHash(
        *phProv,
        CALG_SHA1,
        NULL,
        NULL,
        &hKHash
        );
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    fSts = CryptHashData(
        hKHash,
        pbR1Sig,
        dwR1SigLen,
        NULL
        );
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    fSts = CryptHashData(
        hKHash,
        psc_rcb->bR2,
        32, // TODO: use a const
        NULL
        );
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    // create the rc4 key for the cred&hmac encryption

    fSts = CryptDeriveKey(
        *phProv,
        CALG_RC4, // stream cipher,
        hKHash,
        NULL,
        phRc4Key
        );
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    // create the key for the HMAC from the hash of R1&2

    fSts = CryptDeriveKey(
        *phProv,
        CALG_RC2,
        hKHash,
        NULL,
        phHmacKey
        );
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

ErrorExit:

    //
    // cleanup
    //

    if (NULL != hHash)
    {
        CryptDestroyHash(hHash);
    }

    if (NULL != hKHash)
    {
        CryptDestroyHash(hKHash);
    }

    if (NULL != pbR1Sig)
    {
        LocalFree(pbR1Sig);
    }

    return lResult;
}


NTSTATUS WINAPI
ScHelperCreateCredHMAC(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hHmacKey,
    IN PBYTE CleartextData,
    IN ULONG CleartextDataSize,
    IN OUT PBYTE* ppbHmac,
    IN OUT DWORD* pdwHmacLen
)
{
    NTSTATUS lResult = STATUS_SUCCESS;
    HCRYPTHASH hHMAC = NULL;
    HMAC_INFO hmac_info;
    BOOL fSts = FALSE;

    fSts = CryptCreateHash(
        hProv,
        CALG_HMAC,
        hHmacKey,
        NULL,
        &hHMAC
        );
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    memset(&hmac_info, 0, sizeof(HMAC_INFO));
    hmac_info.HashAlgid = CALG_SHA1;

    fSts = CryptSetHashParam(
        hHMAC,
        HP_HMAC_INFO,
        (PBYTE)&hmac_info,
        NULL
        );
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    fSts = CryptHashData(
        hHMAC,
        CleartextData,
        CleartextDataSize,
        NULL);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    fSts = CryptGetHashParam(
        hHMAC,
        HP_HASHVAL,
        *ppbHmac,
        pdwHmacLen,
        NULL
        );
    if (0 >= *pdwHmacLen)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    *ppbHmac = (PBYTE)LocalAlloc(LPTR, *pdwHmacLen);

    if (NULL == *ppbHmac)
    {
        lResult = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }

    fSts = CryptGetHashParam(
        hHMAC,
        HP_HASHVAL,
        *ppbHmac,
        pdwHmacLen,
        NULL
        );
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

ErrorExit:

    if (NULL != hHMAC)
    {
        CryptDestroyHash(hHMAC);
    }

    return lResult;
}

/*++

ScHelperVerifyCardAndCreds:

    This routine combines Card Verification and Credential Decryption.

Arguments:

        pucPIN supplies a Unicode string containing the card's PIN.

        CertificateContext supplies the cert context received via
                ScHelperGetCertFromLogonInfo.

        hCertStore supplies the handle of a cert store which contains a CTL to
                use during certificate verification, or NULL to use the system
                default store.

        pbLogonInfo supplies the information required to identify the card, csp,
                etc.  It cannot be NULL.

        EncryptedData receives the encrypted credential blob.

        EncryptedDataSize supplies the size of the EncryptedData buffer in
            bytes, and receives the actual size of the encrypted blob.

        CleartextData supplies a credential blob to be encrypted.

        CleartextDataSize supplies the size of the blob, in bytes.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    STATUS_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Remarks:

    You may supply a value of NULL to EncryptedData to receive only the
    required size of the EncryptedData buffer.

Author:

    Doug Barlow (dbarlow) 5/24/1999

--*/

NTSTATUS WINAPI
ScHelperVerifyCardAndCreds(
    IN PUNICODE_STRING pucPIN,
    IN PCCERT_CONTEXT CertificateContext,
    IN HCERTSTORE hCertStore,
    IN PBYTE pbLogonInfo,
    IN PBYTE EncryptedData,
    IN ULONG EncryptedDataSize,
    OUT OPTIONAL PBYTE CleartextData,
    OUT PULONG CleartextDataSize
    )
{
    NTSTATUS lResult = STATUS_SUCCESS;

    // Verify the Card

    lResult = ScHelperVerifyCard(
                pucPIN,
                CertificateContext,
                hCertStore,
                pbLogonInfo);

    // Decrypt the Creds

    if (NT_SUCCESS(lResult))
    {
        lResult = ScHelperDecryptCredentials(
                pucPIN,
                CertificateContext,
                hCertStore,
                pbLogonInfo,
                EncryptedData,
                EncryptedDataSize,
                CleartextData,
                CleartextDataSize);
    }

    return lResult;
}




/*++

ScHelperDecryptCredentials:

    This routine decrypts an encrypted credential blob.

Arguments:

        pucPIN supplies a Unicode string containing the card's PIN.

        CertificateContext supplies the cert context received via
                ScHelperGetCertFromLogonInfo.

        hCertStore supplies the handle of a cert store which contains a CTL to
                use during certificate verification, or NULL to use the system
                default store.

        EncryptedData supplies the encrypted credential blob.

        EncryptedDataSize supplies the length of the encrypted credential blob,
            in bytes.

        CleartextData receives the decrypted credential blob.

        CleartextDataSize supplies the length of the CleartextData buffer, and
            receives the actual length of returned decrypted credential blob.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    STATUS_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Remarks:

    You may supply a value of NULL to CleartextData to receive only the
    required size of the buffer in CleartextDataSize.


Author:

    Doug Barlow (dbarlow) 5/24/1999

--*/

NTSTATUS WINAPI
ScHelperDecryptCredentials(
    IN PUNICODE_STRING pucPIN,
    IN PCCERT_CONTEXT CertificateContext,
    IN HCERTSTORE hCertStore,
    IN PBYTE pbLogonInfo,
    IN PBYTE EncryptedData,
    IN ULONG EncryptedDataSize,
    OUT OPTIONAL PBYTE CleartextData,
    OUT PULONG CleartextDataSize)
{
    NTSTATUS lResult = STATUS_SUCCESS;
    PBYTE pbCredBlob = NULL;
    DWORD dwCredBlobSize = 0;
    PBYTE pbHmac = NULL;        // the HMAC stored with the cred blob
    DWORD dwHmacSize = NULL;    // size of HMAC stored with cred blob
    PBYTE pbNewHmac = NULL;     // HMAC generated from cred blob for verify
    DWORD dwNewHmacSize = 0;    // size of gen'd HMAC
    PBYTE pb = NULL;
    DWORD dw = 0;
    PBYTE pbPlainCred = NULL;
    DWORD dwPlainCredSize = 0;
    HCRYPTKEY hHmacKey = NULL;
    HCRYPTKEY hRc4Key = NULL;
    HCRYPTPROV hGenProv = NULL;
    BOOL fSts = FALSE;


    // pull the SCH_RCB out of the EncryptedData blob
    ScHelper_RandomCredBits* psch_rcb = (ScHelper_RandomCredBits*)EncryptedData;
    // and build a private copy of the blob itself
    dwCredBlobSize = EncryptedDataSize - sizeof(ScHelper_RandomCredBits);
    pbCredBlob = (PBYTE)LocalAlloc(LPTR, dwCredBlobSize);
    if (NULL == pbCredBlob)
    {
        lResult = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }
    pb = EncryptedData + sizeof(ScHelper_RandomCredBits);
    CopyMemory(pbCredBlob, pb, dwCredBlobSize);


    //
    // Fetch the keys we need to decrypt & verify the cred blob
    //

    lResult = ScHelperCreateCredKeys(
                pucPIN,
                pbLogonInfo,
                psch_rcb,
                &hHmacKey,
                &hRc4Key,
                &hGenProv
                );
    if (!NT_SUCCESS(lResult))
    {
        goto ErrorExit;
    }


    //
    // Decrypt the cred blob
    //

    fSts = CryptDecrypt(
        hRc4Key,
        NULL,
        TRUE,
        NULL,
        pbCredBlob,
        &dwCredBlobSize);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    //
    // pull the HMAC out & verify it
    //

    dwHmacSize = (DWORD)*pbCredBlob;
    pbHmac = pbCredBlob + sizeof(DWORD);
    pbPlainCred = pbCredBlob + dwHmacSize + sizeof(DWORD);
    dwPlainCredSize = dwCredBlobSize - dwHmacSize - sizeof(DWORD);


    lResult = ScHelperCreateCredHMAC(
        hGenProv,
        hHmacKey,
        pbPlainCred,
        dwPlainCredSize,
        &pbNewHmac,
        &dwNewHmacSize);
    if (!NT_SUCCESS(lResult))
    {
        goto ErrorExit;
    }


    lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
    if (dwNewHmacSize == dwHmacSize)
    {
        for (dw = 0;
            (dw < dwNewHmacSize) && ((BYTE)*(pbHmac+dw)==(BYTE)*(pbNewHmac+dw));
            dw++);
        if (dwNewHmacSize == dw)
        {
            // verification succeeded!
            lResult = STATUS_SUCCESS;
        }
    }
    if (!NT_SUCCESS(lResult))
    {
        goto ErrorExit;
    }


    //
    // return the decrypted blob or just its length, as necessary
    //

    if ((NULL != CleartextData) && (0 < *CleartextDataSize))
    {
        if (*CleartextDataSize >= dwPlainCredSize)
        {
            CopyMemory(CleartextData, pbPlainCred, dwPlainCredSize);
        }
        else
            lResult = STATUS_BUFFER_TOO_SMALL;
    }
    else
    {
        lResult = STATUS_BUFFER_TOO_SMALL;
    }
    *CleartextDataSize = dwPlainCredSize;

    //
    // Cleanup and return
    //
ErrorExit:

    if (NULL != pbNewHmac)
    {
        LocalFree(pbNewHmac);
    }

    if (NULL != hHmacKey)
    {
        CryptDestroyKey(hHmacKey);
    }

    if (NULL != hRc4Key)
    {
        CryptDestroyKey(hRc4Key);
    }

    if (NULL != hGenProv)
    {
        CryptReleaseContext(hGenProv, NULL);
    }

    return lResult;
}


/*++

ScHelperEncryptCredentials:

    This routine encrypts a credential blob.

Arguments:

        pucPIN supplies a Unicode string containing the card's PIN.

        CertificateContext supplies the cert context received via
                ScHelperGetCertFromLogonInfo.

        hCertStore supplies the handle of a cert store which contains a CTL to
                use during certificate verification, or NULL to use the system
                default store.

        CleartextData supplies the cleartext credential blob.

        CleartextDataSize supplies the length of the cleartext credential blob,
            in bytes.

        EncryptedData receives the encrypted credential blob.

        EncryptedDataSize supplies the length of the EncryptedData buffer, and
            receives the actual length of returned encrypted credential blob.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    STATUS_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Remarks:

    You may supply a value of NULL to EncryptedData to receive only the
    required size of the buffer in EncryptedDataSize.


Author:

    Doug Barlow (dbarlow) 5/24/1999

--*/


NTSTATUS WINAPI
ScHelperEncryptCredentials(
    IN PUNICODE_STRING pucPIN,
    IN PCCERT_CONTEXT CertificateContext,
    IN HCERTSTORE hCertStore,
    IN ScHelper_RandomCredBits* psch_rcb,
    IN PBYTE pbLogonInfo,
    IN PBYTE CleartextData,
    IN ULONG CleartextDataSize,
    OUT OPTIONAL PBYTE EncryptedData,
    OUT PULONG EncryptedDataSize)
{
    NTSTATUS lResult = STATUS_SUCCESS;

    HCRYPTPROV hProv = NULL;
    BOOL fSts;
    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    ULONG SignedEncryptedCredSize = 0;
    PBYTE SignedEncryptedCred = NULL; // encrypted cred&sig, !including R1+R2
    HCRYPTKEY hHmacKey = NULL;
    HCRYPTKEY hRc4Key = NULL;
    PBYTE pbHmac = NULL;
    DWORD dwHmacLen = 0;
    PBYTE pbCredsAndHmac  = NULL;
    DWORD dwCredsAndHmacLen = 0;
    DWORD dwEncryptedCredSize = 0;
    PBYTE pb = NULL;

    // parameter checking?


    //
    // do stuff to determine size required for SignedEncryptedCred
    //

    lResult = ScHelperCreateCredKeys(
                pucPIN,
                pbLogonInfo,
                psch_rcb,
                &hHmacKey,
                &hRc4Key,
                &hProv
                );
    if (!NT_SUCCESS(lResult))
    {
        goto ErrorExit;
    }

    // HMAC creds
    lResult = ScHelperCreateCredHMAC(
        hProv,
        hHmacKey,
        CleartextData,
        CleartextDataSize,
        &pbHmac,
        &dwHmacLen);
    if (!NT_SUCCESS(lResult))
    {
        goto ErrorExit;
    }


    // make a buffer with creds and HMAC

    pbCredsAndHmac = NULL;
    dwCredsAndHmacLen = dwHmacLen + CleartextDataSize + sizeof(DWORD);
    pbCredsAndHmac = (PBYTE)LocalAlloc(LPTR, dwCredsAndHmacLen);
    if (NULL == pbCredsAndHmac)
    {
        lResult = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }
    pb = pbCredsAndHmac;
    CopyMemory(pb, &dwHmacLen, sizeof(DWORD));
    pb += sizeof(DWORD);
    CopyMemory(pb, pbHmac, dwHmacLen);
    pb += dwHmacLen;
    CopyMemory(pb, CleartextData, CleartextDataSize);

    // Encrypt creds+HMAC
    dwEncryptedCredSize = dwCredsAndHmacLen;

    // After CryptEncrypt, dwCredsAndHmacLen describes the length of the data
    // to encrypt and dwEncryptedCredSize describes the req'd buffer length

    // TODO: VERIFY THE HANDLING OF dwEncryptedCredSize and dwCresAndHmacLen

    fSts = CryptEncrypt(
        hRc4Key,
        NULL,
        TRUE,
        NULL,
        pbCredsAndHmac,
        &dwEncryptedCredSize,
        dwCredsAndHmacLen
        );
    if (!fSts)
    {
        if (GetLastError() != ERROR_MORE_DATA)
        {
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
            goto ErrorExit;    
        }                
    }

    //
    // Create the final blob for return, or inform user of size, as necessary
    //

    if ((NULL != EncryptedData) && (0 < *EncryptedDataSize))
    {

        if (*EncryptedDataSize >= dwEncryptedCredSize + sizeof(ScHelper_RandomCredBits))
        {
            // the user gave us enough space for the whole thing.

            // if the previous CryptEncrypt failed with ERROR_MORE_DATA
            // we can now do something about it...
            if (!fSts)
            {
                // resize pbCredsAndHmac
                LocalFree(pbCredsAndHmac);
                pbCredsAndHmac = (PBYTE)LocalAlloc(LPTR, dwCredsAndHmacLen);
                if (NULL == pbCredsAndHmac)
                {
                    lResult = STATUS_INSUFFICIENT_RESOURCES;
                    goto ErrorExit;
                }
                // reset pbCredsAndHmac
                pb = pbCredsAndHmac;
                CopyMemory(pb, &dwHmacLen, sizeof(DWORD));
                pb += sizeof(DWORD);
                CopyMemory(pb, pbHmac, dwHmacLen);
                pb += dwHmacLen;
                CopyMemory(pb, CleartextData, CleartextDataSize);
                // re-encrypt CredsAndHmac
                fSts = CryptEncrypt(
                    hRc4Key,
                    NULL,
                    TRUE,
                    NULL,
                    pbCredsAndHmac,
                    &dwCredsAndHmacLen, // length of data
                    dwEncryptedCredSize // length of buffer
                    );
                if (!fSts)
                {
                    lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
                    goto ErrorExit;
                }
            }

            pb = EncryptedData;

            CopyMemory(pb, (PBYTE)psch_rcb, sizeof(ScHelper_RandomCredBits));
            pb += sizeof(ScHelper_RandomCredBits);
            CopyMemory(pb, pbCredsAndHmac, dwCredsAndHmacLen);

        }
        else
        {
            lResult = STATUS_BUFFER_TOO_SMALL;
        }
    }
    else
    {
        lResult = STATUS_BUFFER_TOO_SMALL;
    }
    *EncryptedDataSize = dwEncryptedCredSize + sizeof(ScHelper_RandomCredBits);

ErrorExit:

    // clean up!

    if (NULL != pbCredsAndHmac)
    {
        LocalFree(pbCredsAndHmac);
    }

    if (NULL != pbHmac)
    {
        LocalFree(pbHmac);
    }

    if (NULL != hRc4Key)
    {
        CryptDestroyKey(hRc4Key);
    }

    if (NULL != hHmacKey)
    {
        CryptDestroyKey(hHmacKey);
    }

    if (NULL != hProv)
    {
        CryptReleaseContext(hProv, NULL);
    }

    return lResult;
}


/*++

ScHelperSignMessage:

        ScHelperSignMessage() needs the logoninfo and PIN in order to find the card
        that will do the signing...

Arguments:

        pucPIN may need the PIN to get a cert off certain SCs

Return Value:

        "success" or "failure"

Author:

        Amanda Matlosz

Note:

        Used by LSA.

--*/
NTSTATUS WINAPI
ScHelperSignMessage(
    IN PUNICODE_STRING pucPIN,
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN ULONG Algorithm,
    IN PBYTE Buffer,
    IN ULONG BufferLength,
    OUT PBYTE Signature,
    OUT PULONG SignatureLength
    )
{
    NTSTATUS lResult = STATUS_SUCCESS;
    HCRYPTHASH hHash = NULL;
    HCRYPTPROV hProv = NULL;
    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    CUnicodeString szPin(pucPIN);
    BOOL fSts;

    //
    // Make sure we've got a Crypto Provider up and running.
    //

    if (ARGUMENT_PRESENT(Provider))
    {
        hProv = Provider;
    }
    else
    {
		if (NULL != pucPIN)
		{
			if (!szPin.Valid())
			{
				return(STATUS_INSUFFICIENT_RESOURCES);
			}
		}


        CSCLogonInit * LogonInit = (CSCLogonInit *) pLI->ContextInformation;
        hProv = LogonInit->CryptCtx(pLI);
        if (NULL == hProv)
        {
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
            goto ErrorExit;
        }
    }

    //
    // We'll need a hash handle, too.
    //

    fSts = CryptCreateHash(
            hProv,
            Algorithm,
            NULL, // HCRYPTKEY (used for keyed algs, like block ciphers
            0,  // reserved for future use
            &hHash);

    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }


    //
    // Hash the input data.
    //

    fSts = CryptHashData(
                hHash,
                Buffer,
                BufferLength,
                0);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;        
        goto ErrorExit;
    }


    if (!ARGUMENT_PRESENT(Provider))
    {
        //
        // Declare the PIN.
        //

        if (NULL != pucPIN)
        {
            fSts = CryptSetProvParam(
                    hProv,
                    PP_KEYEXCHANGE_PIN,
                    (LPBYTE)((LPCSTR)szPin),
                    0);
            if (!fSts)
            {
                lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;  
                goto ErrorExit;
            }
        }
    }

    //
    // OK, sign it with the exchange key from the smart card or the supplied signature key. ????
    //

    fSts = CryptSignHash(
                hHash,
                AT_KEYEXCHANGE,
                NULL,
                0,
                Signature,
                SignatureLength);
    if (!fSts)
    {
        if (GetLastError() == ERROR_MORE_DATA)
        {
            lResult = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        }
    }

    //
    // All done, clean up and return.
    //

ErrorExit:
        // Do this early so GetLastError is not clobbered
    if (!NT_SUCCESS(lResult))
    {
        lResult = LogEvent(
            lResult,
            (DWORD)((ARGUMENT_PRESENT(Provider))?EVENT_ID_SIGNMSG_NOSC:EVENT_ID_SIGNMSG)
            );
    }

    if (NULL != hHash)
    {
        CryptDestroyHash(hHash);
    }

    return lResult;
}


/*++

ScHelperVerifyMessage:

// ScHelperVerifyMessage() returns STATUS_SUCCESS if the signature provided is
// the hash of the buffer encrypted by the owner of the cert.

Arguments:

        pucPIN may need the PIN to get a cert off certain SCs

Return Value:

        "success" or "failure"

Author:

        Amanda Matlosz

Note:

        Used by LSA.

--*/
NTSTATUS WINAPI
ScHelperVerifyMessage(
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN PCCERT_CONTEXT CertificateContext,
    IN ULONG Algorithm,
    IN PBYTE Buffer,
    IN ULONG BufferLength,
    IN PBYTE Signature,
    IN ULONG SignatureLength
    )
{
    HCRYPTPROV hProv = NULL;
    HCRYPTKEY hKey = NULL;
    HCRYPTHASH hHash = NULL;
    PCERT_PUBLIC_KEY_INFO pInfo = NULL;
    BOOL fSts;
    NTSTATUS lResult = STATUS_SUCCESS;
    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;


    //
    // Make sure we've got a Crypto Provider up and running.
    //

    if (ARGUMENT_PRESENT(Provider))
    {
        hProv = Provider;
    }
    else
    {
        CSCLogonInit * LogonInit = (CSCLogonInit *) pLI->ContextInformation;
        hProv = LogonInit->CryptCtx(pLI);
        if (NULL == hProv)
        {
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
            goto ErrorExit;
        }
    }

    //
    // Convert the certificate handle into a Public Key handle.
    //

    fSts = CryptImportPublicKeyInfo(
                hProv,
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                &CertificateContext->pCertInfo->SubjectPublicKeyInfo,
                &hKey);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }


    //
    // We'll need a hash handle, too.
    //

    fSts = CryptCreateHash(
                hProv,
                Algorithm,
                NULL, // HCRYPTKEY (used for keyed algs, like block ciphers
                0,  // reserved for future use
                &hHash);

    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }


    //
    // Hash the input data.
    //

    fSts = CryptHashData(
                hHash,
                Buffer,
                BufferLength,
                0);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }


    //
    // So is this signature any good?
    //

    fSts = CryptVerifySignature(
                hHash,
                Signature,
                SignatureLength,
                hKey,
                NULL,
                0);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }


    //
    // All done, clean up and return.
    //

ErrorExit:
        // Do this early so GetLastError is not clobbered
    if (!NT_SUCCESS(lResult))
    {
        lResult = LogEvent(
            lResult,
            (DWORD)((ARGUMENT_PRESENT(Provider))?EVENT_ID_VERIFYMSG_NOSC:EVENT_ID_VERIFYMSG)
            );
    }

    if (NULL != hHash)
    {
        CryptDestroyHash(hHash);
    }
    if (NULL != hKey)
    {
        CryptDestroyKey(hKey);
    }

    return lResult;
}

/*++

ScHelperSignPkcsMessage:

        ScHelperSignMessage() needs the logoninfo and PIN in order to find the card
        that will do the signing...

Arguments:

        pucPIN may need the PIN to get a cert off certain SCs

Return Value:

        "success" or "failure"

Author:

        Amanda Matlosz

Note:

        Used by LSA.

--*/
NTSTATUS WINAPI
ScHelperSignPkcsMessage(
    IN OPTIONAL PUNICODE_STRING pucPIN,
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN PCCERT_CONTEXT Certificate,
    IN PCRYPT_ALGORITHM_IDENTIFIER Algorithm,
    IN DWORD dwSignMessageFlags,
    IN PBYTE Buffer,
    IN ULONG BufferLength,
    OUT OPTIONAL PBYTE SignedBuffer,
    OUT OPTIONAL PULONG SignedBufferLength
    )
{
    NTSTATUS lResult = STATUS_SUCCESS;
    HCRYPTPROV hProv = NULL;
    BOOL fSts;
    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    CRYPT_SIGN_MESSAGE_PARA Parameter = {0};
    CUnicodeString szPin(pucPIN);
    const BYTE * BufferArray = Buffer;

    if (NULL != pucPIN)
    {
		if (!szPin.Valid())
		{
			return(STATUS_INSUFFICIENT_RESOURCES);
		}
	}

    //
    // Make sure we've got a Crypto Provider up and running.
    //

    if (ARGUMENT_PRESENT(Provider))
    {
        hProv = Provider;
    }
    else
    {
        CSCLogonInit * LogonInit = (CSCLogonInit *) pLI->ContextInformation;
        hProv = LogonInit->CryptCtx(pLI);
        if (NULL == hProv)
        {
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
            goto ErrorExit;
        }

        //
        // Declare the PIN.
        //

        if (NULL != pucPIN)
        {
            fSts = CryptSetProvParam(
                    hProv,
                    PP_KEYEXCHANGE_PIN,
                    (LPBYTE)((LPCSTR)szPin),
                    0);
            if (!fSts)
            {
                lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
                goto ErrorExit;
            }
        }
    }


    //
    // Sign the message
    //

    Parameter.cbSize = sizeof(CRYPT_SIGN_MESSAGE_PARA);
    Parameter.dwMsgEncodingType = PKCS_7_ASN_ENCODING | X509_ASN_ENCODING;
    Parameter.pSigningCert = Certificate;
    Parameter.HashAlgorithm = *Algorithm;
    Parameter.cMsgCert = 1;
    Parameter.rgpMsgCert = &Certificate;
    Parameter.dwFlags = dwSignMessageFlags;


    fSts = CryptSignMessage(
            &Parameter,
            FALSE,              // no detached signature
            1,                  // one buffer to sign
            &BufferArray,
            &BufferLength,
            SignedBuffer,
            SignedBufferLength);

    if (!fSts)
    {
        if (GetLastError() == ERROR_MORE_DATA)
        {
            lResult = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        }
        goto ErrorExit;
    }


    //
    // All done, clean up and return.
    //

ErrorExit:

    if (!NT_SUCCESS(lResult))
    {
        lResult = LogEvent(lResult, (DWORD)EVENT_ID_SIGNMSG);
    }

    return lResult;
}


/*++

ScHelperVerifyPkcsMessage:

// ScHelperVerifyMessage() returns STATUS_SUCCESS if the signature provided is
// the hash of the buffer encrypted by the owner of the cert.

Arguments:

        pucPIN may need the PIN to get a cert off certain SCs

Return Value:

        "success" or "failure"

Author:

        Amanda Matlosz

Note:

        Used by LSA.

--*/
NTSTATUS WINAPI
ScHelperVerifyPkcsMessage(
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN PBYTE Buffer,
    IN ULONG BufferLength,
    OUT OPTIONAL PBYTE DecodedBuffer,
    OUT OPTIONAL PULONG DecodedBufferLength,
    OUT OPTIONAL PCCERT_CONTEXT * CertificateContext
    )
{
    CRYPT_VERIFY_MESSAGE_PARA Parameter = {0};
    BOOL fSts;
    NTSTATUS lResult = STATUS_SUCCESS;

    Parameter.cbSize = sizeof(CRYPT_VERIFY_MESSAGE_PARA);
    Parameter.dwMsgAndCertEncodingType = PKCS_7_ASN_ENCODING | X509_ASN_ENCODING;
    Parameter.hCryptProv = NULL;

    //
    // Indicate that we want to get the certificate from the message
    // cert store.
    //

    Parameter.pfnGetSignerCertificate = NULL;
    fSts = CryptVerifyMessageSignature(
                &Parameter,
                0,              // only check first signer
                Buffer,
                BufferLength,
                DecodedBuffer,
                DecodedBufferLength,
                CertificateContext
                );

    if (!fSts)
    {
        if (GetLastError() == ERROR_MORE_DATA)
        {
            lResult = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        }
        goto ErrorExit;
    }


    //
    // All done, clean up and return.
    //

ErrorExit:

    if (!NT_SUCCESS(lResult))
    {
        lResult = LogEvent(lResult, (DWORD)EVENT_ID_VERIFYMSG);

    }

    return lResult;
}

/*++

ScHelperEncryptMessage:

    Encrypts a message with the public key associated w/ the provided
        certificate.  The resultant encoding is PKCS-7 compliant.

Arguments:

        pucPIN may need the PIN to get a cert off certain SCs

Return Value:

        "success" or "failure"

Author:

    Amanda Matlosz (AMatlosz) 1-06-98

Note:

        Either pbLogonInfo or Provided must be set; if both are set,
        Provider is used.

        Algorithm expects a CRYPT_ALGORITHM_IDENTIFIER cai;
        If there are no parameters to the alg, cai.Parameters.cbData *must* be 0;

        CALG_RC4, no parameters:
                cai.pszObjId = szOID_RSA_RC4;
                cai.Parameters.cbData = 0;

        Used by LSA.

--*/
NTSTATUS WINAPI
ScHelperEncryptMessage(
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN PCCERT_CONTEXT CertificateContext,
    IN PCRYPT_ALGORITHM_IDENTIFIER Algorithm,
    IN PBYTE Buffer,                        // The data to encrypt
    IN ULONG BufferLength,                  // The length of that data
    OUT PBYTE CipherText,                   // Receives the formatted CipherText
    IN PULONG pCipherLength                 // Supplies size of CipherText buffer
    )                                       // Receives length of actual CipherText
{
    NTSTATUS lResult = STATUS_SUCCESS;
    HCRYPTPROV hProv = NULL;
    BOOL fSts;
    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    CRYPT_ENCRYPT_MESSAGE_PARA EncryptPara;
    DWORD cbEncryptParaSize = 0;

    //
    // Make sure we've got a Crypto Provider up and running.
    //

    if (ARGUMENT_PRESENT(Provider))
    {
        hProv = Provider;
    }
    else
    {
        CSCLogonInit * LogonInit = (CSCLogonInit *) pLI->ContextInformation;
        hProv = LogonInit->CryptCtx(pLI);
        if (NULL == hProv)
        {
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
            goto ErrorExit;
        }
    }


    //
    // Encrypt the message
    //

    cbEncryptParaSize = sizeof(EncryptPara);
    memset(&EncryptPara, 0, cbEncryptParaSize);
    EncryptPara.cbSize = cbEncryptParaSize;
    EncryptPara.dwMsgEncodingType = PKCS_7_ASN_ENCODING | X509_ASN_ENCODING;
    EncryptPara.hCryptProv = hProv;
    EncryptPara.ContentEncryptionAlgorithm = *Algorithm;

    fSts = CryptEncryptMessage(
            &EncryptPara,
            1,
            &CertificateContext,
            Buffer,
            BufferLength,
            CipherText,
            pCipherLength);

    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

ErrorExit:

    if (!NT_SUCCESS(lResult))
    {
        lResult = LogEvent(
            lResult,
            (DWORD)((ARGUMENT_PRESENT(Provider))?EVENT_ID_ENCMSG_NOSC:EVENT_ID_ENCMSG)
            );
    }

    return lResult;
}


/*++

ScHelperDecryptMessage :

    Deciphers a PKCS-7 encoded message with the private key associated
        w/ the provided certificate.

Arguments:

        Either pbLogonInfo or Provider must be set; if both are set,
        Provider is used.


Return Value:

        "success" or "failure"

Author:

    Amanda Matlosz (AMatlosz) 1-06-98

Note:

        ** CertificateContext subtleties: **

        CryptDecryptMessage takes as a parameter a pointer to a certificate store;
        it will use the first appropriate certificate context it finds in that
        store to perform the decryption.  In order to make this call, we create a
        CertificateStore in memory, and add the provided CertificateContext to it.

        CertAddCertificateContextToStore actually places a copy of the certificate
        context in the store.  In so doing, it strips off any properties that are
        not permanent -- if a HCRYPTPROV is associated with the KeyContext of the
        source CertificateContext, it will NOT be associated with the KeyContext
        of the cert context in the store.

        Although this is appropriate behavior in most cases, we need that property
        to be kept intact when dealing with Smart Card CSPs (to avoid surprise
        "Insert PIN" dialogs), so after adding the CertificateContext to the store,
        we turn around and get the CERT_KEY_CONTEXT_PROP_ID from the source
        certcontext and (re)set it on the certcontext in the memory store.

        ** Algorithm notes: **

        Algorithm expects a CRYPT_ALGORITHM_IDENTIFIER cai;
        If there are no parameters to the alg, cai.Parameters.cbData *must* be 0;

        for example: CALG_RC4, no parameters:
                cai.pszObjId = szOID_RSA_RC4;
                cai.Parameters.cbData = 0;

        Used by LSA.

--*/
NTSTATUS WINAPI
ScHelperDecryptMessage(
    IN PUNICODE_STRING pucPIN,
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN PCCERT_CONTEXT CertificateContext,
    IN PBYTE CipherText,        // Supplies formatted CipherText
    IN ULONG CipherLength,      // Supplies the length of the CiperText
    OUT PBYTE ClearText,        // Receives decrypted message
    IN OUT PULONG pClearLength  // Supplies length of buffer, receives actual length
    )
{
    NTSTATUS lResult = STATUS_SUCCESS;
    HCRYPTPROV hProv = NULL;
    PCCERT_CONTEXT pStoreCertContext = NULL;
    HCERTSTORE hCertStore = NULL;
    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    CUnicodeString szPin(pucPIN);
    CERT_KEY_CONTEXT CertKeyContext;
    DWORD cbData = sizeof(CERT_KEY_CONTEXT); // PhilH swears this will not grow!
    BOOL fSts;

    //
    // Make sure we've got a Crypto Provider up and running.
    //

    if (ARGUMENT_PRESENT(Provider))
    {
        hProv = Provider;
    }
    else
    {
		if (NULL != pucPIN)
		{
			if (!szPin.Valid())
			{
				return(STATUS_INSUFFICIENT_RESOURCES);
			}
		}


        CSCLogonInit * LogonInit = (CSCLogonInit *) pLI->ContextInformation;
        hProv = LogonInit->CryptCtx(pLI);
        if (NULL == hProv)
        {
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
            goto ErrorExit;
        }

        //
        // Declare the PIN.
        //

        if (NULL != pucPIN )
        {
            fSts = CryptSetProvParam(
                    hProv,
                    PP_KEYEXCHANGE_PIN,
                    (LPBYTE)((LPCSTR)szPin),
                    0);
            if (!fSts)
            {
                lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
                goto ErrorExit;
            }
        }
    }

    //
    // Open a temporary certstore to hold this certcontext
    //

    hCertStore = CertOpenStore(
                            CERT_STORE_PROV_MEMORY,
                            0, // not applicable
                            hProv,
                            CERT_STORE_NO_CRYPT_RELEASE_FLAG, // auto-release hProv NOT OK
                            NULL);

    if (NULL == hCertStore)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    fSts = CertAddCertificateContextToStore(
            hCertStore,
            CertificateContext,
            CERT_STORE_ADD_ALWAYS,
            &pStoreCertContext);

    //
    // NOW WE NEED TO RESET THE KEY CONTEXT PROPERTY ON THIS CERTCONTEXT
        // IN THE MEMORY STORE (see function header/notes) AS APPROPRIATE
        //
        // ie, IFF the certcontext we were give has the key_context property,
        // reset it (and fail if the resetting doesn't work)
        //
    fSts = CertGetCertificateContextProperty(
                CertificateContext,
                CERT_KEY_CONTEXT_PROP_ID,
                (void *)&CertKeyContext,
                &cbData);

        if (TRUE == fSts)
        {
                fSts = CertSetCertificateContextProperty(
                                        pStoreCertContext,
                                        CERT_KEY_CONTEXT_PROP_ID,
                                        CERT_STORE_NO_CRYPT_RELEASE_FLAG, // no auto-release hProv!
                                        (void *)&CertKeyContext);

                if (!fSts)
                {
                        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
                        goto ErrorExit;
                }
        }

    //
    // Decrypt the message
    //

    CRYPT_DECRYPT_MESSAGE_PARA DecryptPara;
    DecryptPara.cbSize = sizeof(DecryptPara);
    DecryptPara.dwMsgAndCertEncodingType = X509_ASN_ENCODING | PKCS_7_ASN_ENCODING;
    DecryptPara.cCertStore = 1;
    DecryptPara.rghCertStore = &hCertStore;

    fSts = CryptDecryptMessage(
            &DecryptPara,
            CipherText,
            CipherLength,
            ClearText,
            pClearLength,
            NULL);

    if (!fSts)
    {
        if (GetLastError() == ERROR_MORE_DATA)
        {
            lResult = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        }
        goto ErrorExit;
    }

ErrorExit:

        // Do this early so GetLastError is not clobbered
    if (!NT_SUCCESS(lResult))
    {
        lResult = LogEvent(
            lResult,
            (DWORD)((ARGUMENT_PRESENT(Provider))?EVENT_ID_DECMSG_NOSC:EVENT_ID_DECMSG)
            );
    }

    if (hCertStore != NULL)
    {
        fSts = CertCloseStore(hCertStore, CERT_CLOSE_STORE_FORCE_FLAG);
        if (!fSts)
        {
            if (!NT_SUCCESS(lResult))
                lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        }
    }

    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\sclogon\unicodes.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    unicodes

Abstract:

    This module implements the CUnicodeString class.  This class allows a string
    to automatically convert between PUNICODE_STRING, LPCSTR, and LPCWSTR.

Author:

    Doug Barlow (dbarlow) 11/6/1997

Environment:

    Win32, C++

Notes:

    ?Notes?

--*/

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN 1
#endif
#include <windows.h>
#include <wincrypt.h>
#include <crtdbg.h>
#include "scLogon.h"
#include "unicodes.h"


//
// Piddly routines.
//

CUnicodeString::CUnicodeString(
    void)
{
    m_szAnsi = NULL;
    m_wszUnicode = NULL;
    m_fFlags = fBothGood;
}

CUnicodeString::CUnicodeString(
    LPCSTR sz)
{
    m_szAnsi = NULL;
    m_wszUnicode = NULL;
    m_fFlags = fBothGood;
    Set(sz);
}

CUnicodeString::CUnicodeString(
    LPCWSTR wsz)
{
    m_szAnsi = NULL;
    m_wszUnicode = NULL;
    m_fFlags = fBothGood;
    Set(wsz);
}

CUnicodeString::CUnicodeString(
    PUNICODE_STRING pus)
{
    m_szAnsi = NULL;
    m_wszUnicode = NULL;
    m_fFlags = fBothGood;
    Set(pus);
}

CUnicodeString::~CUnicodeString()
{
    if (NULL != m_szAnsi)
    {
        memset(m_szAnsi, 0, lstrlenA(m_szAnsi));
        LocalFree(m_szAnsi);
    }
    if (NULL != m_wszUnicode)
    {
        memset(m_wszUnicode, 0, lstrlenW(m_wszUnicode)*sizeof(WCHAR));
        LocalFree(m_wszUnicode);
    }
}

PUNICODE_STRING
CUnicodeString::Set(
    PUNICODE_STRING pus)
{
    if (NULL != m_szAnsi)
    {
        LocalFree(m_szAnsi);
        m_szAnsi = NULL;
    }
    if (NULL != m_wszUnicode)
    {
        LocalFree(m_wszUnicode);
        m_wszUnicode = NULL;
    }
    m_fFlags = fNoneGood;
    if (pus != NULL)
    {
        m_wszUnicode = (LPWSTR)LocalAlloc(LPTR, pus->Length + sizeof(WCHAR));
        if (m_wszUnicode != NULL)
        {
            CopyMemory(
                m_wszUnicode,
                pus->Buffer,
                pus->Length
                );
            m_wszUnicode[pus->Length/sizeof(WCHAR)] = L'\0';
            m_fFlags = fUnicodeGood;
        }
    }
    return pus;
}


/*++

Set:

    These methods initialize the object to a given string.

Arguments:

    sz - Supplies an ANSI string with which to initialize the object.

    wsz - Supplies a UNICODE string with which to initialize the object.

    pus - Supplies a pointer to a UNICODE_STRING structure from which to
        initialize the object.

Return Value:

    The same value as was provided.

Author:

    Doug Barlow (dbarlow) 11/6/1997

--*/

LPCSTR
CUnicodeString::Set(
    LPCSTR sz)
{
    if (NULL != m_wszUnicode)
    {
        LocalFree(m_wszUnicode);
        m_wszUnicode = NULL;
    }
    if (NULL != m_szAnsi)
        LocalFree(m_szAnsi);
    m_fFlags = fNoneGood;

    m_szAnsi = (LPSTR)LocalAlloc(LPTR, (lstrlenA(sz) + 1) * sizeof(CHAR));
    if (NULL != m_szAnsi)
    {
        lstrcpyA(m_szAnsi, sz);
        m_fFlags = fAnsiGood;
    }
    return m_szAnsi;
}

LPCWSTR
CUnicodeString::Set(
    LPCWSTR wsz)
{
    if (NULL != m_szAnsi)
    {
        LocalFree(m_szAnsi);
        m_szAnsi = NULL;
    }
    if (NULL != m_wszUnicode)
        LocalFree(m_wszUnicode);
    m_fFlags = fNoneGood;
    m_wszUnicode = (LPWSTR)LocalAlloc(LPTR, (lstrlenW(wsz) + 1) * sizeof(WCHAR));
    if (m_wszUnicode != NULL)
    {
        lstrcpyW(m_wszUnicode, wsz);
        m_fFlags = fUnicodeGood;
    }
    return m_wszUnicode;
}

CUnicodeString::operator PUNICODE_STRING(
    void)
{
    m_us.Buffer = (LPWSTR)Unicode();
    m_us.Length = m_us.MaximumLength = (USHORT)(lstrlenW(m_us.Buffer) * sizeof(WCHAR));
    return &m_us;
}


/*++

Unicode:

    This method ensures that the object has a valaid internal UNICODE
    representation.

Arguments:

    None

Return Value:

    The represented string, in UNICODE format.

Author:

    Doug Barlow (dbarlow) 11/6/1997

--*/

LPCWSTR
CUnicodeString::Unicode(
    void)
{
    int length;


    //
    // See what data we've got, and if any conversion is necessary.
    //

    switch (m_fFlags)
    {
    case fAnsiGood:
        // The ANSI value is good.  Convert it to Unicode.
        _ASSERTE(NULL != m_szAnsi);
        length =
            MultiByteToWideChar(
                CP_ACP,
                0,
                m_szAnsi,
                -1,
                NULL,
                0);
        if (NULL != m_wszUnicode)
        {
            LocalFree(m_wszUnicode);
        }
        if (0 != length)
        {
            m_wszUnicode = (LPWSTR)LocalAlloc(LPTR, (length + 1) * sizeof(WCHAR));
            if (m_wszUnicode == NULL)
            {
                break;
            }
            length =
                MultiByteToWideChar(
                    CP_ACP,
                    0,
                    m_szAnsi,
                    -1,
                    m_wszUnicode,
                    length);
            m_wszUnicode[length] = 0;
        }
        else
        {
            m_wszUnicode = NULL;
        }
        m_fFlags = fBothGood;
        break;

    case fUnicodeGood:
    case fBothGood:
        // The Unicode value is good.  Just return that.
        break;

    case fNoneGood:
    default:
        // Internal error.
        _ASSERT(FALSE);
        break;
    }
    return m_wszUnicode;
}


/*++

Ansi:

    This method ensures that the object has a valaid internal ANSI
    representation.

Arguments:

    None

Return Value:

    The represented string, in ANSI format.

Author:

    Doug Barlow (dbarlow) 11/6/1997

--*/

LPCSTR
CUnicodeString::Ansi(
    void)
{
    int length;


    //
    // See what data we've got, and if any conversion is necessary.
    //

    switch (m_fFlags)
    {
    case fUnicodeGood:
        // The Unicode buffer is good.  Convert it to ANSI.
        length =
            WideCharToMultiByte(
                CP_ACP,
                0,
                m_wszUnicode,
                -1,
                NULL,
                0,
                NULL,
                NULL);
        if (NULL != m_szAnsi)
        {
            LocalFree(m_szAnsi);
        }

        if (0 != length)
        {
            m_szAnsi = (LPSTR)LocalAlloc(LPTR, (length + 1) * sizeof(CHAR));
            if (m_szAnsi == NULL)
            {
                break;
            }
            length =
                WideCharToMultiByte(
                    CP_ACP,
                    0,
                    m_wszUnicode,
                    -1,
                    m_szAnsi,
                    length,
                    NULL,
                    NULL);
            m_szAnsi[length] = 0;
        }
        else
        {
            m_szAnsi = NULL;
        }
        m_fFlags = fBothGood;
        break;

    case fAnsiGood:
    case fBothGood:
        // The ANSI buffer is good.  We'll return that.
        break;

    case fNoneGood:
    default:
        // An internal error.
        _ASSERT(FALSE);
        break;
    }
    return m_szAnsi;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\wincrmsg\crmsgp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       crmsgp.h
//
//  Contents:   Private Header for Cryptographic Message APIs
//
//  History:    12-Dec-96   kevinr    created
//
//--------------------------------------------------------------------------

#ifndef __WINCRMSG_P_INCLUDED__
#define __WINCRMSG_P_INCLUDED__

#if DBG
#define STATIC
#else
#define STATIC static
#endif

#ifndef OSS_CRYPT_ASN1
#define parameters_present AlgorithmIdentifier_parameters_present
#define unauthAttributes_present SignerInfo_unauthAttributes_present
#define certificates_present SignedData_certificates_present
#define crls_present SignedData_crls_present
#define date_present RecipientKeyIdentifier_date_present
#define other_present RecipientKeyIdentifier_other_present
#define content_present ContentInfo_content_present
#define authAttributes_present SignerInfoWithBlobs_authAttributes_present

#define issuerAndSerialNumber_chosen CertIdentifier_issuerAndSerialNumber_chosen
#define subjectKeyIdentifier_chosen CertIdentifier_subjectKeyIdentifier_chosen

#endif  // OSS_CRYPT_ASN1


#define INFO_LEN_ALIGN(Len)  ((Len + 7) & ~7)

#define STRUCT_CBSIZE(StructName, FieldName)   \
    (offsetof(StructName, FieldName) + sizeof(((StructName *) 0)->FieldName))

#define ICM_TAG_NULL            0x00
#define ICM_TAG_CONSTRUCTED     0x20
#define ICM_TAG_SEQ             0x30
#define ICM_TAG_SET             0x31
#define ICM_TAG_OCTETSTRING     0x04
#define ICM_TAG_NULL_OCTETS     0x05
#define ICM_TAG_CONTEXT_0       0x80
#define ICM_TAG_CONTEXT_1       0x81

#define ICM_TAG_CONSTRUCTED_CONTEXT_0     (ICM_TAG_CONSTRUCTED | ICM_TAG_CONTEXT_0)
#define ICM_TAG_CONSTRUCTED_CONTEXT_1     (ICM_TAG_CONSTRUCTED | ICM_TAG_CONTEXT_1)

#define ICM_LENGTH_INDEFINITE   0x80


// Streaming flags
#define ICMS_QUEUE_OUTPUT_FLAG  0x80000000


typedef struct _SIMPLEBLOBHEADER {
    ALG_ID  aiEncAlg;
} SIMPLEBLOBHEADER, *PSIMPLEBLOBHEADER;

#define SIZE_OSS_OID    16

extern ObjectID aoidMessages[];

extern const CRYPT_OBJID_TABLE aotSign[];
extern const DWORD COUNTOF_aotSign;

extern const LPSTR apszObjIdPKCS7[];
extern const DWORD COUNTOF_apszObjIdPKCS7;

extern const CRYPT_OBJID_TABLE aotContentEncryption[];
extern const DWORD COUNTOF_aotContentEncryption;

extern const LPSTR pszObjIdDataType;
extern const LPSTR pszObjIdContentType;
extern const LPSTR pszObjIdMessageDigest;

#define INVALID_ENCODING_SIZE (0xFFFFFFFE)

#define ZEROSTRUCT(arg) (memset( &arg, 0, sizeof(arg)))

typedef struct _ICM_BUFFER {
    PBYTE   pbData;
    DWORD   cbSize;
    DWORD   cbUsed;
    DWORD   cbDead;
} ICM_BUFFER, *PICM_BUFFER;

#define ICM_BUFFER_SIZE_INCR    1024

void *
WINAPI
ICM_Alloc(
    IN size_t cbBytes);

void *
WINAPI
ICM_AllocZero(
    IN size_t cb);

void *
WINAPI
ICM_ReAlloc(
    IN void     *pvOrg,
    IN size_t   cb);

void
WINAPI
ICM_Free(
    IN void *pv);

BOOL
WINAPI
ICM_AppendBlob(
    PCRYPT_DATA_BLOB    pblob,
    const BYTE          *pbIn,
    DWORD               cbIn);

BOOL
WINAPI
ICM_CopyOssObjectIdentifier(
    OUT ObjectID    *poiDst,
    IN  ObjectID    *poiSrc);


typedef struct _CONTENT_INFO {
    LPSTR           pszContentType;
    CRYPT_DATA_BLOB content;
} CONTENT_INFO, *PCONTENT_INFO;

class CHashList;
class CBlobList;
class CSignerList;
class COssDecodeInfoList;

#ifdef CMS_PKCS7
class CHashNode;
typedef struct _SIGNER_ENCODE_DATA_INFO {
    HCRYPTPROV          hCryptProv;
    DWORD               dwKeySpec;
    CHashNode           *pHashNode;
} SIGNER_ENCODE_DATA_INFO, *PSIGNER_ENCODE_DATA_INFO;
#endif  // CMS_PKCS7

typedef struct _SIGNED_DATA_INFO {
    int             version;
    CBlobList       *pAlgidList;
    PCONTENT_INFO   pci;
    CBlobList       *pCertificateList;
    CBlobList       *pCrlList;
    CSignerList     *pSignerList;
} SIGNED_DATA_INFO, *PSIGNED_DATA_INFO;

typedef struct _CRYPT_MSG_INFO {
    CRITICAL_SECTION    CriticalSection;
    LONG                lRefCnt;
    HCRYPTPROV          hCryptProv;             // decode
    BOOL                fDefaultCryptProv;      // decode
    DWORD               dwKeySpec;              // key to use in CryptSignHash
    DWORD               dwEncodingType;         // encode
    DWORD               dwMsgType;
    DWORD               dwFlags;
    VOID                *pvMsg;
    BOOL                fEncoding;
    DWORD               dwPhase;
    LPSTR               pszInnerContentObjID;
    // signed or signed-and-enveloped
    PSIGNED_DATA_INFO   psdi;
    // signed, digested or signed-and-enveloped
    BOOL                fDetached;
    CHashList           *pHashList;
#ifdef CMS_PKCS7
    // encode signed
    DWORD               cSignerEncodeDataInfo;
    PSIGNER_ENCODE_DATA_INFO rgSignerEncodeDataInfo;
#endif  // CMS_PKCS7
    // enveloped or signed-and-enveloped
    HCRYPTKEY           hkeyContentCrypt;
    HCRYPTPROV          hCryptProvContentCrypt;
    CRYPT_DATA_BLOB     Plaintext;
    DWORD               dwDecryptedRecipientIndex;
#ifdef CMS_PKCS7
    DWORD               dwDecryptedRecipientEncryptedKeyIndex;
#endif  // CMS_PKCS7
#ifndef CMS_PKCS7
    PBYTE               pbEncryptParameters;        // encoded and allocated
#endif  // CMS_PKCS7
    // streaming
    PCMSG_STREAM_INFO   pStreamInfo;
    DWORD               aflStream;
    DWORD               aflDecode;
    BOOL                fStreamCallbackOutput;
    BOOL                fStreamContentExtracted;
    ICM_BUFFER          bufDecode;
    ICM_BUFFER          bufEncode;
    ICM_BUFFER          bufOutput;
    ICM_BUFFER          bufCrypt;
    ICM_BUFFER          bufPendingCrypt;
    DWORD               cbBlockSize;
    BOOL                fBlockCipher;
    DWORD               cEndNullPairs;          // decode
    DWORD               cInnerNullPairs;        // decode
    DWORD               cLevelIndefiniteInner;  // decode
    DWORD               cbDefiniteRemain;       // decode
    DWORD               cbContentInfo;          // decode
    ObjectIdentifierType *pooid;                // decode
    DWORD               aflOuter;               // decode
    DWORD               aflInner;               // decode
    COssDecodeInfoList  *plDecodeInfo;          // decode

#ifdef CMS_PKCS7
    // Optional OriginatorInfo for decoded CMS EnvelopedData
    CBlobList           *pCertificateList;
    CBlobList           *pCrlList;

    // Misc allocations, such as, Algorithm parameters
    CBlobList           *pFreeList;
#endif  // CMS_PKCS7

} CRYPT_MSG_INFO, *PCRYPT_MSG_INFO;


//--------------------------------------------------------------------------
// Decoding progress flags
#define ICMS_DECODED_PREFIX                 0x00000001
#define ICMS_DECODED_CONTENT_START          0x00000002
#define ICMS_DECODED_CONTENT                0x00000004
#define ICMS_DECODED_SUFFIX                 0x00000008

#define ICMS_DECODED_CONTENTINFO_SEQ        0x00000010
#define ICMS_DECODED_CONTENTINFO_CONTENT    0x00000020
//#define ICMS_DECODED_                       0x00000040
//#define ICMS_DECODED_                       0x00000080

// Signed
#define ICMS_DECODED_SIGNED_SEQ             0x00000100
#define ICMS_DECODED_SIGNED_VERSION         0x00000200
#define ICMS_DECODED_SIGNED_DIGESTALGOS     0x00000400
#define ICMS_DECODED_SIGNED_CONTENTINFO     0x00000800
#define ICMS_DECODED_SIGNED_CERTIFICATES    0x00001000
#define ICMS_DECODED_SIGNED_CRLS            0x00002000
#define ICMS_DECODED_SIGNED_SIGNERINFOS     0x00004000
//#define ICMS_DECODED_                       0x00008000

// Enveloped
#define ICMS_DECODED_ENVELOPED_SEQ          0x00000100
#define ICMS_DECODED_ENVELOPED_VERSION      0x00000200
#define ICMS_DECODED_ENVELOPED_RECIPINFOS   0x00000400
#define ICMS_DECODED_ENVELOPED_ECISEQ       0x00000800
#define ICMS_DECODED_ENVELOPED_ECITYPE      0x00001000
#define ICMS_DECODED_ENVELOPED_ECIALGID     0x00002000
#define ICMS_DECODED_ENVELOPED_ECICONTENT   0x00004000
#ifdef CMS_PKCS7
#define ICMS_DECODED_ENVELOPED_ORIGINATOR   0x00008000
#define ICMS_DECODED_ENVELOPED_ATTR         0x00010000
#endif  // CMS_PKCS7
//#define ICMS_DECODED_                       0x00020000

// Misc flags
#define ICMS_INNER_OCTETSTRING              0x00100000
#define ICMS_FINAL                          0x00200000
#define ICMS_NONBARE                        0x00400000
#define ICMS_RAW_DATA                       0x00800000
#define ICMS_PROCESS_CONTENT_BEGUN          0x01000000
#define ICMS_PROCESS_CONTENT_DONE           0x02000000


// Used in streaming decode parsing
#define ICMS_TOKEN_INDEFINITE           1
#define ICMS_TOKEN_NULLPAIR             2
#define ICMS_TOKEN_DEFINITE             3
#define ICMS_TOKEN_INCOMPLETE           4


#if DBG
#define CMSGP_STREAM_CRYPT_BLOCK_COUNT         1
#else
#define CMSGP_STREAM_CRYPT_BLOCK_COUNT       128
#endif
#define CMSGP_STREAM_MAX_ENCRYPT_BUFFER     1024


typedef struct _OSS_DECODE_INFO {
    int         iPDU;
    PVOID       pvPDU;
} OSS_DECODE_INFO, *POSS_DECODE_INFO;

DEFINE_LIST_AND_NODE_CLASS( COssDecodeInfoList, COssDecodeInfoNode, OSS_DECODE_INFO);


DEFINE_LIST_AND_NODE_CLASS( CBlobList, CBlobNode, CRYPT_DATA_BLOB);


typedef struct _SIGNER_DATA_INFO {
    CRYPT_DATA_BLOB     blob;
    CBlobList           *pUnauthAttrList;
} SIGNER_DATA_INFO, *PSIGNER_DATA_INFO;

DEFINE_LIST_AND_NODE_CLASS( CSignerList, CSignerNode, SIGNER_DATA_INFO);

typedef struct _ICM_HASH_INFO {
#ifndef CMS_PKCS7
    HCRYPTPROV          hCryptProv;
#endif  // CMS_PKCS7
    DWORD               dwAlgoCAPI;
    HCRYPTHASH          hHash;
    CRYPT_HASH_BLOB     HashBlob;
} ICM_HASH_INFO, *PICM_HASH_INFO;

DEFINE_LIST_AND_NODE_CLASS( CHashList, CHashNode, ICM_HASH_INFO);


extern HCRYPTASN1MODULE  ICM_hAsn1Module;
__inline ASN1encoding_t ICM_GetEncoder(void)
{
    return I_CryptGetAsn1Encoder(ICM_hAsn1Module);
}
__inline ASN1decoding_t ICM_GetDecoder(void)
{
    return I_CryptGetAsn1Decoder(ICM_hAsn1Module);
}

BOOL
WINAPI
ICM_GetLengthOctets(
    IN DWORD            cbContent,
    OUT OPTIONAL PBYTE  pbOut,
    IN OUT PDWORD       pcbOut);

VOID
WINAPI
ICM_SetLastError(
    IN DWORD    dwError);

BOOL
WINAPI
ICM_GetCAPI(
    IN DWORD                        dwGroupId,
    IN PCRYPT_ALGORITHM_IDENTIFIER  pai,
    OUT PDWORD                      pdwAlgId);

LONG
WINAPI
ICM_ObjIdToIndex(
    IN ObjectID *poi);

BOOL
WINAPI
ICM_EqualObjectIDs(
    IN ObjectID     *poid1,
    IN ObjectID     *poid2);

BOOL
WINAPI
ICM_IsData(
    IN  LPSTR   pszContentType);

BOOL
WINAPI
ICM_InsertTailBlob(
    IN OUT CBlobList    *pBlobList,
    IN Any              *pAny);

BOOL
WINAPI
ICM_InsertTailSigner(
    IN OUT CSignerList  *pSignerList,
    IN Any              *pAny);

BOOL
WINAPI
ICM_CreateHashList(
    IN HCRYPTPROV       hCryptProv,
    IN OUT CHashList    **ppHashList,
    IN CBlobList        *pAlgidList);

BOOL
WINAPI
ICM_UpdateListDigest(
    IN CHashList    *pHashList,
    IN const BYTE   *pbData,
    IN DWORD        cbData);

#ifdef CMS_PKCS7
BOOL
WINAPI
ICM_IsDuplicateSignerEncodeHashAlgorithm(
    IN PCMSG_SIGNER_ENCODE_INFO rgSigners,
    IN PCMSG_SIGNER_ENCODE_INFO pNewSigner,
    OUT OPTIONAL DWORD *pdwPrevIndex = NULL
    );

BOOL
WINAPI
ICM_FillSignerEncodeEncryptedDigests(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fMaxLength);

#else

BOOL
WINAPI
ICM_FillSignerEncryptedDigest(
    IN SignerInfo   *psi,
    IN LPSTR        pszInnerContentObjID,
    IN CHashNode    *pnHash,
    IN DWORD        dwKeySpec,
    IN BOOL         fMaxLength);
#endif  // CMS_PKCS7

BOOL
WINAPI
ICM_GetKeyBlockSize(
    IN HCRYPTKEY        hkey,
    OUT PDWORD          pcbBlock,
    OUT OPTIONAL PBOOL  pfBlockCipher);

#ifdef CMS_PKCS7
BOOL
WINAPI
ICM_InitializeContentEncryptInfo(
    IN PCMSG_ENVELOPED_ENCODE_INFO pEnvelopedEncodeInfo,
    OUT PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo
    );

void
WINAPI
ICM_FreeContentEncryptInfo(
    IN PCMSG_ENVELOPED_ENCODE_INFO pEnvelopedEncodeInfo,
    IN OUT PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo
    );

BOOL
WINAPI
ICM_FillOssCmsRecipientInfos(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN OUT CmsRecipientInfos *poris,
#ifdef OSS_CRYPT_ASN1
    IN OUT int *pEnvelopedDataVersion
#else
    IN OUT ASN1int32_t *pEnvelopedDataVersion
#endif  // OSS_CRYPT_ASN1
    );
void
WINAPI
ICM_FreeOssCmsRecipientInfos(
    IN OUT CmsRecipientInfos *poris
    );

#else

//  rgcbEncryptParameters[1] is the dwEncryptFlags passed to
//  ICM_ExportEncryptKey
BOOL
WINAPI
ICM_GenEncryptKey(
    IN OUT HCRYPTPROV               *phCryptProv,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    IN PVOID                        pvEncryptAuxInfo,
    IN PCERT_PUBLIC_KEY_INFO        pPublicKeyInfo,
    IN PFN_CMSG_ALLOC               pfnAlloc,
    OUT HCRYPTKEY                   *phEncryptKey,
    OUT PBYTE                       *ppbEncryptParameters,
    OUT DWORD                       rgcbEncryptParameters[2]);

// rgcbData[1] is the dwEncryptFlags passed from ICM_GenEncryptKey
BOOL
WINAPI
ICM_ExportEncryptKey(
    IN HCRYPTPROV                   hCryptProv,
    IN HCRYPTKEY                    hEncryptKey,
    IN PCERT_PUBLIC_KEY_INFO        pPublicKeyInfo,
    OUT PBYTE                       pbData,
    IN OUT DWORD                    rgcbData[2]);

BOOL
WINAPI
ICM_ImportEncryptKey(
    IN HCRYPTPROV                   hCryptProv,
    IN DWORD                        dwKeySpec,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiPubKey,
    IN PBYTE                        pbEncodedKey,
    IN DWORD                        cbEncodedKey,
    OUT HCRYPTKEY                   *phEncryptKey);

#endif  // CMS_PKCS7

BOOL
WINAPI
ICM_EncryptBuffer(
    IN HCRYPTKEY    hkeyEncrypt,
    HCRYPTHASH      hHash,
    IN const BYTE   *pbPlain,
    IN DWORD        cbPlain,
    OUT PBYTE       *ppbCipher,
    OUT PDWORD      pcbCipher);

BOOL
WINAPI
ICMS_SetDecryptKey(
    IN PCRYPT_MSG_INFO  pcmi,
    IN HCRYPTKEY        hkeyDecrypt);

BOOL
WINAPI
ICMS_ExtractContent(
    IN PCRYPT_MSG_INFO  pcmi,
    IN const BYTE       *pbDER,
    IN DWORD            cbDER,
    OUT PDWORD          pcbContent,
    OUT const BYTE      **ppbContent);

BOOL
WINAPI
ICMS_OpenToEncodeData(
    IN PCRYPT_MSG_INFO          pcmi);

BOOL
WINAPI
ICMS_UpdateEncodingData(
    IN PCRYPT_MSG_INFO  pcmi,
    IN PBYTE            pbData,
    IN DWORD            cbData,
    IN BOOL             fFinal);

BOOL
WINAPI
ICMS_UpdateDecodingInner(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fFinal);

BOOL
WINAPI
ICMS_UpdateDecoding(
    IN PCRYPT_MSG_INFO  pcmi,
    IN const BYTE       *pbData,
    IN DWORD            cbData,
    IN BOOL             fFinal);

BOOL
WINAPI
ICMS_OpenToEncodeSignedData(
    IN PCRYPT_MSG_INFO          pcmi,
    IN PCMSG_SIGNED_ENCODE_INFO psmei);

BOOL
WINAPI
ICMS_UpdateEncodingSignedData(
    IN PCRYPT_MSG_INFO  pcmi,
    IN PBYTE            pbData,
    IN DWORD            cbData,
    IN BOOL             fFinal);

BOOL
WINAPI
ICMS_OpenToEncodeEnvelopedData(
    IN PCRYPT_MSG_INFO              pcmi,
    IN PCMSG_ENVELOPED_ENCODE_INFO  pemei);

BOOL
WINAPI
ICMS_UpdateEncodingEnvelopedData(
    IN PCRYPT_MSG_INFO  pcmi,
    IN const BYTE       *pbPlain,
    IN DWORD            cbPlain,
    IN BOOL             fFinal);

DWORD
WINAPI
ICM_LengthSigned(
    IN PCMSG_SIGNED_ENCODE_INFO psmei,
    IN DWORD                    dwFlags,
    IN LPSTR                    pszInnerContentObjID,
    IN DWORD                    cbData,
    OUT OPTIONAL PDWORD         pcbContent);

DWORD
WINAPI
ICM_LengthEnveloped(
    IN PCMSG_ENVELOPED_ENCODE_INFO  pemei,
    IN DWORD                        dwFlags,
    IN OPTIONAL LPSTR               pszInnerContentObjID,
    IN DWORD                        cbData,
    OUT OPTIONAL PDWORD             pcbContent);

// OCTET STRING callback, used for streaming
typedef BOOL (WINAPI *POSTRCALLBACK)(
        IN const void       *pvArg,
        IN OUT PICM_BUFFER  pbuf,
        IN OUT PDWORD       pcbPending,
        IN BOOL             fFinal);

BOOL
WINAPI
ICMS_HashContent(
    IN PCRYPT_MSG_INFO  pcmi,
    IN PBYTE            pbData,
    IN DWORD            cbData);


BOOL
WINAPI
ICM_GetSignerIdFromSignerEncodeInfo(
    IN PCMSG_SIGNER_ENCODE_INFO psei,
    OUT PCERT_ID                pSignerId);

#endif  // __WINCRMSG_P_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\sclogon\winsmcrd.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    winsmcrd.h

Abstract:
    Smart Card class/port IOCTL codes. This file is required for all code
    user mode and kernel mode, using Smart Card IOCTL's, defines,
    data structures

Revision History:

--*/


#ifndef _NTDDSCRD_H2_
#define _NTDDSCRD_H2_

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _WINSCARD_H_
typedef DWORD ULONG;
typedef WORD UWORD;
typedef BYTE UCHAR;
#else
typedef ULONG DWORD;
// typedef UWORD WORD;
typedef UCHAR BYTE;
#endif

#ifndef DEVICE_TYPE_SMARTCARD
#define FILE_DEVICE_SMARTCARD           0x00000031
#else
#if 0x00000031 != FILE_DEVICE_SMARTCARD
#error "Incorrect Smart Card Device Definition"
#endif
#endif


//
// Various constants
//

#define SCARD_ATR_LENGTH 33  // ISO 7816-3 spec.

//
///////////////////////////////////////////////////////////////////////////////
//
//  Protocol Flag definitions
//

#define SCARD_PROTOCOL_UNDEFINED    0x00000000  // There is no active protocol.
#define SCARD_PROTOCOL_T0           0x00000001  // T=0 is the active protocol.
#define SCARD_PROTOCOL_T1           0x00000002  // T=1 is the active protocol.
#define SCARD_PROTOCOL_RAW          0x00010000  // Raw is the active protocol.
//
// This is the mask of ISO defined transmission protocols
//
#define SCARD_PROTOCOL_Tx           (SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1)
//
// Use the default transmission parameters / card clock freq.
//
#define SCARD_PROTOCOL_DEFAULT      0x80000000
//
// Use optimal transmission parameters / card clock freq.
// Since using the optimal parameters is the default case no bit is defined to be 1
//
#define SCARD_PROTOCOL_OPTIMAL      0x00000000


//
// Ioctl parameters 1 for IOCTL_SMARTCARD_POWER
//
#define SCARD_POWER_DOWN 0          // Power down the card.
#define SCARD_COLD_RESET 1          // Cycle power and reset the card.
#define SCARD_WARM_RESET 2          // Force a reset on the card.

//
///////////////////////////////////////////////////////////////////////////////
//
//  Reader Action IOCTLs
//

#define SCARD_CTL_CODE(code)        CTL_CODE(FILE_DEVICE_SMARTCARD, \
                                            (code), \
                                            METHOD_BUFFERED, \
                                            FILE_ANY_ACCESS)

#define IOCTL_SMARTCARD_POWER           SCARD_CTL_CODE( 1)
#define IOCTL_SMARTCARD_GET_ATTRIBUTE   SCARD_CTL_CODE( 2)
#define IOCTL_SMARTCARD_SET_ATTRIBUTE   SCARD_CTL_CODE( 3)
#define IOCTL_SMARTCARD_CONFISCATE      SCARD_CTL_CODE( 4)
#define IOCTL_SMARTCARD_TRANSMIT        SCARD_CTL_CODE( 5)
#define IOCTL_SMARTCARD_EJECT           SCARD_CTL_CODE( 6)
#define IOCTL_SMARTCARD_SWALLOW         SCARD_CTL_CODE( 7)
// #define IOCTL_SMARTCARD_READ            SCARD_CTL_CODE( 8) obsolete
// #define IOCTL_SMARTCARD_WRITE           SCARD_CTL_CODE( 9) obsolete
#define IOCTL_SMARTCARD_IS_PRESENT      SCARD_CTL_CODE(10)
#define IOCTL_SMARTCARD_IS_ABSENT       SCARD_CTL_CODE(11)
#define IOCTL_SMARTCARD_SET_PROTOCOL    SCARD_CTL_CODE(12)
#define IOCTL_SMARTCARD_GET_STATE       SCARD_CTL_CODE(14)
#define IOCTL_SMARTCARD_GET_LAST_ERROR  SCARD_CTL_CODE(15)
#define IOCTL_SMARTCARD_GET_PERF_CNTR   SCARD_CTL_CODE(16)


//
///////////////////////////////////////////////////////////////////////////////
//
// Tags for requesting card and reader attributes
//

#define MAXIMUM_ATTR_STRING_LENGTH 32   // Nothing bigger than this from getAttr
#define MAXIMUM_SMARTCARD_READERS  10   // Limit the readers on the system

#define SCARD_ATTR_VALUE(Class, Tag) ((((ULONG)(Class)) << 16) | ((ULONG)(Tag)))

#define SCARD_CLASS_VENDOR_INFO     1   // Vendor information definitions
#define SCARD_CLASS_COMMUNICATIONS  2   // Communication definitions
#define SCARD_CLASS_PROTOCOL        3   // Protocol definitions
#define SCARD_CLASS_POWER_MGMT      4   // Power Management definitions
#define SCARD_CLASS_SECURITY        5   // Security Assurance definitions
#define SCARD_CLASS_MECHANICAL      6   // Mechanical characteristic definitions
#define SCARD_CLASS_VENDOR_DEFINED  7   // Vendor specific definitions
#define SCARD_CLASS_IFD_PROTOCOL    8   // Interface Device Protocol options
#define SCARD_CLASS_ICC_STATE       9   // ICC State specific definitions
#define SCARD_CLASS_PERF       0x7ffe   // performace counters
#define SCARD_CLASS_SYSTEM     0x7fff   // System-specific definitions

#define SCARD_ATTR_VENDOR_NAME SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_INFO, 0x0100)
#define SCARD_ATTR_VENDOR_IFD_TYPE SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_INFO, 0x0101)
#define SCARD_ATTR_VENDOR_IFD_VERSION SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_INFO, 0x0102)
#define SCARD_ATTR_VENDOR_IFD_SERIAL_NO SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_INFO, 0x0103)
#define SCARD_ATTR_CHANNEL_ID SCARD_ATTR_VALUE(SCARD_CLASS_COMMUNICATIONS, 0x0110)
#define SCARD_ATTR_PROTOCOL_TYPES SCARD_ATTR_VALUE(SCARD_CLASS_PROTOCOL, 0x0120)
// #define SCARD_ATTR_ASYNC_PROTOCOL_TYPES SCARD_ATTR_VALUE(SCARD_CLASS_PROTOCOL, 0x0120)
#define SCARD_ATTR_DEFAULT_CLK SCARD_ATTR_VALUE(SCARD_CLASS_PROTOCOL, 0x0121)
#define SCARD_ATTR_MAX_CLK SCARD_ATTR_VALUE(SCARD_CLASS_PROTOCOL, 0x0122)
#define SCARD_ATTR_DEFAULT_DATA_RATE SCARD_ATTR_VALUE(SCARD_CLASS_PROTOCOL, 0x0123)
#define SCARD_ATTR_MAX_DATA_RATE SCARD_ATTR_VALUE(SCARD_CLASS_PROTOCOL, 0x0124)
#define SCARD_ATTR_MAX_IFSD SCARD_ATTR_VALUE(SCARD_CLASS_PROTOCOL, 0x0125)
// #define SCARD_ATTR_SYNC_PROTOCOL_TYPES SCARD_ATTR_VALUE(SCARD_CLASS_PROTOCOL, 0x0126)
#define SCARD_ATTR_POWER_MGMT_SUPPORT SCARD_ATTR_VALUE(SCARD_CLASS_POWER_MGMT, 0x0131)
#define SCARD_ATTR_USER_TO_CARD_AUTH_DEVICE SCARD_ATTR_VALUE(SCARD_CLASS_SECURITY, 0x0140)
#define SCARD_ATTR_USER_AUTH_INPUT_DEVICE SCARD_ATTR_VALUE(SCARD_CLASS_SECURITY, 0x0142)
#define SCARD_ATTR_CHARACTERISTICS SCARD_ATTR_VALUE(SCARD_CLASS_MECHANICAL, 0x0150)

#define SCARD_ATTR_CURRENT_PROTOCOL_TYPE SCARD_ATTR_VALUE(SCARD_CLASS_IFD_PROTOCOL, 0x0201)
#define SCARD_ATTR_CURRENT_CLK SCARD_ATTR_VALUE(SCARD_CLASS_IFD_PROTOCOL, 0x0202)
#define SCARD_ATTR_CURRENT_F SCARD_ATTR_VALUE(SCARD_CLASS_IFD_PROTOCOL, 0x0203)
#define SCARD_ATTR_CURRENT_D SCARD_ATTR_VALUE(SCARD_CLASS_IFD_PROTOCOL, 0x0204)
#define SCARD_ATTR_CURRENT_N SCARD_ATTR_VALUE(SCARD_CLASS_IFD_PROTOCOL, 0x0205)
#define SCARD_ATTR_CURRENT_W SCARD_ATTR_VALUE(SCARD_CLASS_IFD_PROTOCOL, 0x0206)
#define SCARD_ATTR_CURRENT_IFSC SCARD_ATTR_VALUE(SCARD_CLASS_IFD_PROTOCOL, 0x0207)
#define SCARD_ATTR_CURRENT_IFSD SCARD_ATTR_VALUE(SCARD_CLASS_IFD_PROTOCOL, 0x0208)
#define SCARD_ATTR_CURRENT_BWT SCARD_ATTR_VALUE(SCARD_CLASS_IFD_PROTOCOL, 0x0209)
#define SCARD_ATTR_CURRENT_CWT SCARD_ATTR_VALUE(SCARD_CLASS_IFD_PROTOCOL, 0x020a)
#define SCARD_ATTR_CURRENT_EBC_ENCODING SCARD_ATTR_VALUE(SCARD_CLASS_IFD_PROTOCOL, 0x020b)
#define SCARD_ATTR_EXTENDED_BWT SCARD_ATTR_VALUE(SCARD_CLASS_IFD_PROTOCOL, 0x020c)

#define SCARD_ATTR_ICC_PRESENCE SCARD_ATTR_VALUE(SCARD_CLASS_ICC_STATE, 0x0300)
#define SCARD_ATTR_ICC_INTERFACE_STATUS SCARD_ATTR_VALUE(SCARD_CLASS_ICC_STATE, 0x0301)
#define SCARD_ATTR_CURRENT_IO_STATE SCARD_ATTR_VALUE(SCARD_CLASS_ICC_STATE, 0x0302)
#define SCARD_ATTR_ATR_STRING SCARD_ATTR_VALUE(SCARD_CLASS_ICC_STATE, 0x0303)
#define SCARD_ATTR_ICC_TYPE_PER_ATR SCARD_ATTR_VALUE(SCARD_CLASS_ICC_STATE, 0x0304)

#define SCARD_ATTR_ESC_RESET SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_DEFINED, 0xA000)
#define SCARD_ATTR_ESC_CANCEL SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_DEFINED, 0xA003)
#define SCARD_ATTR_ESC_AUTHREQUEST SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_DEFINED, 0xA005)
#define SCARD_ATTR_MAXINPUT SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_DEFINED, 0xA007)

#define SCARD_ATTR_DEVICE_UNIT SCARD_ATTR_VALUE(SCARD_CLASS_SYSTEM, 0x0001)
#define SCARD_ATTR_DEVICE_IN_USE SCARD_ATTR_VALUE(SCARD_CLASS_SYSTEM, 0x0002)
#define SCARD_ATTR_DEVICE_FRIENDLY_NAME_A SCARD_ATTR_VALUE(SCARD_CLASS_SYSTEM, 0x0003)
#define SCARD_ATTR_DEVICE_SYSTEM_NAME_A SCARD_ATTR_VALUE(SCARD_CLASS_SYSTEM, 0x0004)
#define SCARD_ATTR_DEVICE_FRIENDLY_NAME_W SCARD_ATTR_VALUE(SCARD_CLASS_SYSTEM, 0x0005)
#define SCARD_ATTR_DEVICE_SYSTEM_NAME_W SCARD_ATTR_VALUE(SCARD_CLASS_SYSTEM, 0x0006)
#define SCARD_ATTR_SUPRESS_T1_IFS_REQUEST SCARD_ATTR_VALUE(SCARD_CLASS_SYSTEM, 0x0007)

#define SCARD_PERF_NUM_TRANSMISSIONS SCARD_ATTR_VALUE(SCARD_CLASS_PERF, 0x0001)
#define SCARD_PERF_BYTES_TRANSMITTED SCARD_ATTR_VALUE(SCARD_CLASS_PERF, 0x0002)
#define SCARD_PERF_TRANSMISSION_TIME SCARD_ATTR_VALUE(SCARD_CLASS_PERF, 0x0003)

#ifdef UNICODE
#define SCARD_ATTR_DEVICE_FRIENDLY_NAME SCARD_ATTR_DEVICE_FRIENDLY_NAME_W
#define SCARD_ATTR_DEVICE_SYSTEM_NAME SCARD_ATTR_DEVICE_SYSTEM_NAME_W
#else
#define SCARD_ATTR_DEVICE_FRIENDLY_NAME SCARD_ATTR_DEVICE_FRIENDLY_NAME_A
#define SCARD_ATTR_DEVICE_SYSTEM_NAME SCARD_ATTR_DEVICE_SYSTEM_NAME_A
#endif


//
// T=0 Protocol Defines
//

#define SCARD_T0_HEADER_LENGTH 7
#define SCARD_T0_CMD_LENGTH 5


//
// T=1 Protocol Defines
//

#define SCARD_T1_PROLOGUE_LENGTH 3
#define SCARD_T1_EPILOGUE_LENGTH 2
#define SCARD_T1_MAX_IFS 254


//
///////////////////////////////////////////////////////////////////////////////
//
//  Reader states
//

#define SCARD_UNKNOWN     0   // This value implies the driver is unaware
                              // of the current state of the reader.
#define SCARD_ABSENT      1   // This value implies there is no card in
                              // the reader.
#define SCARD_PRESENT     2   // This value implies there is a card is
                              // present in the reader, but that it has
                              // not been moved into position for use.
#define SCARD_SWALLOWED   3   // This value implies there is a card in the
                              // reader in position for use.  The card is
                              // not powered.
#define SCARD_POWERED     4   // This value implies there is power is
                              // being provided to the card, but the
                              // Reader Driver is unaware of the mode of
                              // the card.
#define SCARD_NEGOTIABLE  5   // This value implies the card has been
                              // reset and is awaiting PTS negotiation.
#define SCARD_SPECIFIC    6   // This value implies the card has been
                              // reset and specific communication
                              // protocols have been established.

////////////////////////////////////////////////////////////////////////////////
//
//  I/O Services
//
//      The following services provide access to the I/O capabilities of the
//      reader drivers.  Services of the Smart Card are requested by placing the
//      following structure into the protocol buffer:
//


typedef struct _SCARD_IO_REQUEST{
    DWORD dwProtocol;   // Protocol identifier
    DWORD cbPciLength;  // Protocol Control Information Length
} SCARD_IO_REQUEST, *PSCARD_IO_REQUEST, *LPSCARD_IO_REQUEST;
typedef const SCARD_IO_REQUEST *LPCSCARD_IO_REQUEST;


//
// T=0 protocol services.
//

typedef struct {
    BYTE
        bCla,   // The instruction class
        bIns,   // The instruction code within the instruction class
        bP1,
        bP2,    // Parameters to the instruction
        bP3;    // Size of I/O Transfer
} SCARD_T0_COMMAND, *LPSCARD_T0_COMMAND;

typedef struct {
    SCARD_IO_REQUEST ioRequest;
    BYTE
        bSw1,
        bSw2;           // Return codes from the instruction
    union
    {
        SCARD_T0_COMMAND CmdBytes;
        BYTE rgbHeader[5];
    };
} SCARD_T0_REQUEST;

typedef SCARD_T0_REQUEST *PSCARD_T0_REQUEST, *LPSCARD_T0_REQUEST;


//
//  T=1 Protocol Services
//

typedef struct {
    SCARD_IO_REQUEST ioRequest;
} SCARD_T1_REQUEST;
typedef SCARD_T1_REQUEST *PSCARD_T1_REQUEST, *LPSCARD_T1_REQUEST;


//
////////////////////////////////////////////////////////////////////////////////
//
//  Driver attribute flags
//

#define SCARD_READER_SWALLOWS       0x00000001  // Reader has a card swallowing
                                                // mechanism.
#define SCARD_READER_EJECTS         0x00000002  // Reader has a card ejection
                                                // mechanism.
#define SCARD_READER_CONFISCATES    0x00000004  // Reader has a card capture
                                                // mechanism.

//
///////////////////////////////////////////////////////////////////////////////
//
// Type of reader
//
#define SCARD_READER_TYPE_SERIAL    0x01
#define SCARD_READER_TYPE_PARALELL  0x02
#define SCARD_READER_TYPE_KEYBOARD  0x04
#define SCARD_READER_TYPE_SCSI      0x08
#define SCARD_READER_TYPE_IDE       0x10
#define SCARD_READER_TYPE_USB       0x20
#define SCARD_READER_TYPE_PCMCIA    0x40
#define SCARD_READER_TYPE_VENDOR    0xF0

#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\wincrmsg\msgasn1.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       msgasn1.cpp
//
//  Contents:   Conversion APIs to/from ASN.1 data structures
//
//  Functions:  ICM_Asn1ToAttribute
//              ICM_Asn1ToAlgorithmIdentifier
//              ICM_Asn1FromAlgorithmIdentifier
//
//  History:    16-Apr-96   kevinr   created
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

void *ICM_Alloc( IN size_t cbBytes);
void ICM_Free( IN void *pv);

//+-------------------------------------------------------------------------
//  Convert an CRYPT_ATTRIBUTE to an ASN1 Attribute
//
//  Returns FALSE iff conversion failed.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_Asn1ToAttribute(
    IN PCRYPT_ATTRIBUTE       patr,
    OUT Attribute       *poatr)
{
    BOOL        fRet;
    DWORD       i;
    Any         *pAny;
    PCRYPT_ATTR_BLOB  pblob;

    DWORD       cbValue;
    PBYTE       pbValue;

    for (i=patr->cValue, pblob=patr->rgValue, cbValue = 0;
            i>0;
            i--, pblob++) {
        cbValue += pblob->cbData;
    }

    poatr->attributeType.count = 16;
    if (!PkiAsn1ToObjectIdentifier(
            patr->pszObjId,
            &poatr->attributeType.count,
            poatr->attributeType.value))
        goto PkiAsn1ToObjectIdentifierError;
    poatr->attributeValue.value = (Any *)ICM_Alloc(
        patr->cValue * sizeof(Any) + cbValue);
    if (NULL == poatr->attributeValue.value)
        goto AttributeValueMallocError;
    poatr->attributeValue.count = patr->cValue;

    pbValue = (PBYTE) (poatr->attributeValue.value + patr->cValue);
    for (i=patr->cValue, pAny=poatr->attributeValue.value, pblob=patr->rgValue;
            i>0;
            i--, pAny++, pblob++) {
        DWORD cbData = pblob->cbData;

        if (cbData)
            memcpy(pbValue, pblob->pbData, cbData);
        pAny->length = cbData;
        pAny->value  = pbValue;
        pbValue += cbData;
    }

    assert(pbValue == ((PBYTE) (poatr->attributeValue.value + patr->cValue)) +
        cbValue);

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(PkiAsn1ToObjectIdentifierError,CRYPT_E_OID_FORMAT)
TRACE_ERROR(AttributeValueMallocError)  // error already set
}


//+-------------------------------------------------------------------------
//  Convert an CRYPT_ALGORITHM_IDENTIFIER to an ASN1 AlgorithmIdentifier
//
//  Returns FALSE iff conversion failed.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_Asn1ToAlgorithmIdentifier(
    IN PCRYPT_ALGORITHM_IDENTIFIER pai,
    OUT AlgorithmIdentifier *pAsn1AlgId)
{
    BOOL    fRet;
    static BYTE abDerNULL[] = {5, 0};


    pAsn1AlgId->algorithm.count = 16;
    if (!PkiAsn1ToObjectIdentifier(
            pai->pszObjId,
            &pAsn1AlgId->algorithm.count,
            pAsn1AlgId->algorithm.value))
        goto PkiAsn1ToObjectIdentifierError;
    pAsn1AlgId->bit_mask = parameters_present;
    if (0 == pai->Parameters.cbData) {
        pAsn1AlgId->parameters.length = sizeof( abDerNULL);
        pAsn1AlgId->parameters.value = abDerNULL;
    } else {
        pAsn1AlgId->parameters.length = pai->Parameters.cbData;
        pAsn1AlgId->parameters.value = pai->Parameters.pbData;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(PkiAsn1ToObjectIdentifierError,CRYPT_E_OID_FORMAT)
}


//+-------------------------------------------------------------------------
//  Convert an ASN1 AlgorithmIdentifier to an CRYPT_ALGORITHM_IDENTIFIER
//
//  Returns FALSE iff conversion failed.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_Asn1FromAlgorithmIdentifier(
    IN AlgorithmIdentifier *pAsn1AlgId,
    OUT PCRYPT_ALGORITHM_IDENTIFIER pai)
{
    DWORD   cbObjId;
    BOOL    fRet;

    cbObjId = 0;
    if (!PkiAsn1FromObjectIdentifier(
            pAsn1AlgId->algorithm.count,
            pAsn1AlgId->algorithm.value,
            NULL,
            &cbObjId))
        goto PkiAsn1FromObjectIdentifierSizeError;
    pai->pszObjId = (LPSTR)ICM_Alloc( cbObjId);
    if (!PkiAsn1FromObjectIdentifier(
            pAsn1AlgId->algorithm.count,
            pAsn1AlgId->algorithm.value,
            pai->pszObjId,
            &cbObjId))
        goto PkiAsn1FromObjectIdentifierError;
    if (pAsn1AlgId->bit_mask & parameters_present) {
        pai->Parameters.cbData = pAsn1AlgId->parameters.length;
        pai->Parameters.pbData = (PBYTE)pAsn1AlgId->parameters.value;
    } else {
        pai->Parameters.cbData = 0;
        pai->Parameters.pbData = NULL;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(PkiAsn1FromObjectIdentifierSizeError)
TRACE_ERROR(PkiAsn1FromObjectIdentifierError)
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\sclogon\unicodes.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    unicodes

Abstract:

    This header file describes the CUnicodeString class, useful for converting
    string types.

Author:

    Doug Barlow (dbarlow) 11/6/1997

Environment:

    Win32, C++

Notes:

    ?Notes?

--*/

#ifndef _UNICODES_H_
#define _UNICODES_H_

//
//==============================================================================
//
//  CUnicodeString
//

class CUnicodeString
{
public:

    //  Constructors & Destructor
    CUnicodeString(void);
    CUnicodeString(LPCSTR sz);
    CUnicodeString(LPCWSTR wsz);
    CUnicodeString(PUNICODE_STRING pus);
    ~CUnicodeString();

    //  Properties
    //  Methods
    LPCSTR  Set(LPCSTR sz);
    LPCWSTR Set(LPCWSTR wsz);
    PUNICODE_STRING Set(PUNICODE_STRING pus);
    BOOL Valid(void)
    {
        if (m_fFlags == fNoneGood)
        {
            return(FALSE);
        }
        else
        {
            return(TRUE);
        }
    }

    //  Operators
    LPCSTR operator=(LPCSTR sz)
    { return Set(sz); };
    LPCWSTR operator=(LPCWSTR wsz)
    { return Set(wsz); };
    PUNICODE_STRING operator=(PUNICODE_STRING pus)
    { return Set(pus);};
    operator LPCSTR(void)
    { return Ansi(); };
    operator LPCWSTR(void)
    { return Unicode(); };
    operator PUNICODE_STRING(void);

protected:
    //  Properties
    UNICODE_STRING m_us;
    LPSTR m_szAnsi;
    LPWSTR m_wszUnicode;
    enum {
        fNoneGood = 0,
        fAnsiGood = 1,
        fUnicodeGood = 2,
        fBothGood = 3
    } m_fFlags;

    //  Methods
    LPCWSTR Unicode(void);      // Return the text as a Unicode string.
    LPCSTR Ansi(void);          // Return the text as an Ansi string.
};

#endif // _UNICODES_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\wincrmsg\pkcs.c ===
/* Copyright (C) Microsoft Corporation, 1996 - 1999 All rights reserved. */
/* ASN.1 definitions for GlobalDirectives */

#pragma warning(push,3)

#include <windows.h>
#include "pkcs.h"


#pragma warning (pop)

// unreferenced inline function has been removed
#pragma warning (disable: 4514)

// unreferenced formal parameter
#pragma warning (disable: 4100)

// assignment within conditional expression
#pragma warning (disable: 4706)

ASN1module_t PKCS_Module = NULL;

static int ASN1CALL ASN1Enc_ObjectID(ASN1encoding_t enc, ASN1uint32_t tag, ObjectID *val);
static int ASN1CALL ASN1Enc_ObjectIdentifierType(ASN1encoding_t enc, ASN1uint32_t tag, ObjectIdentifierType *val);
static int ASN1CALL ASN1Enc_OctetStringType(ASN1encoding_t enc, ASN1uint32_t tag, OctetStringType *val);
static int ASN1CALL ASN1Enc_IntegerType(ASN1encoding_t enc, ASN1uint32_t tag, IntegerType *val);
static int ASN1CALL ASN1Enc_HugeIntegerType(ASN1encoding_t enc, ASN1uint32_t tag, HugeIntegerType *val);
static int ASN1CALL ASN1Enc_AlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, AlgorithmIdentifier *val);
static int ASN1CALL ASN1Enc_AlgorithmIdentifierNC2(ASN1encoding_t enc, ASN1uint32_t tag, AlgorithmIdentifierNC2 *val);
static int ASN1CALL ASN1Enc_DigestAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, DigestAlgorithmIdentifier *val);
static int ASN1CALL ASN1Enc_AlgorithmIdentifiers(ASN1encoding_t enc, ASN1uint32_t tag, AlgorithmIdentifiers *val);
static int ASN1CALL ASN1Enc_AttributeSetValue(ASN1encoding_t enc, ASN1uint32_t tag, AttributeSetValue *val);
static int ASN1CALL ASN1Enc_AttributeSetValueNC(ASN1encoding_t enc, ASN1uint32_t tag, AttributeSetValueNC *val);
static int ASN1CALL ASN1Enc_SetOfAny(ASN1encoding_t enc, ASN1uint32_t tag, SetOfAny *val);
static int ASN1CALL ASN1Enc_Attribute(ASN1encoding_t enc, ASN1uint32_t tag, Attribute *val);
static int ASN1CALL ASN1Enc_AttributeNC2(ASN1encoding_t enc, ASN1uint32_t tag, AttributeNC2 *val);
static int ASN1CALL ASN1Enc_Attributes(ASN1encoding_t enc, ASN1uint32_t tag, Attributes *val);
static int ASN1CALL ASN1Enc_AttributesNC(ASN1encoding_t enc, ASN1uint32_t tag, AttributesNC *val);
static int ASN1CALL ASN1Enc_AttributesNC2(ASN1encoding_t enc, ASN1uint32_t tag, AttributesNC2 *val);
static int ASN1CALL ASN1Enc_Crls(ASN1encoding_t enc, ASN1uint32_t tag, Crls *val);
static int ASN1CALL ASN1Enc_CrlsNC(ASN1encoding_t enc, ASN1uint32_t tag, CrlsNC *val);
static int ASN1CALL ASN1Enc_ContentEncryptionAlgId(ASN1encoding_t enc, ASN1uint32_t tag, ContentEncryptionAlgId *val);
static int ASN1CALL ASN1Enc_DigestEncryptionAlgId(ASN1encoding_t enc, ASN1uint32_t tag, DigestEncryptionAlgId *val);
static int ASN1CALL ASN1Enc_DigestEncryptionAlgIdNC(ASN1encoding_t enc, ASN1uint32_t tag, DigestEncryptionAlgIdNC *val);
static int ASN1CALL ASN1Enc_Certificates(ASN1encoding_t enc, ASN1uint32_t tag, Certificates *val);
static int ASN1CALL ASN1Enc_CertificatesNC(ASN1encoding_t enc, ASN1uint32_t tag, CertificatesNC *val);
static int ASN1CALL ASN1Enc_IssuerAndSerialNumber(ASN1encoding_t enc, ASN1uint32_t tag, IssuerAndSerialNumber *val);
static int ASN1CALL ASN1Enc_KeyEncryptionAlgId(ASN1encoding_t enc, ASN1uint32_t tag, KeyEncryptionAlgId *val);
static int ASN1CALL ASN1Enc_ContentInfo(ASN1encoding_t enc, ASN1uint32_t tag, ContentInfo *val);
static int ASN1CALL ASN1Enc_ContentInfoNC(ASN1encoding_t enc, ASN1uint32_t tag, ContentInfoNC *val);
static int ASN1CALL ASN1Enc_DigestAlgorithmIdentifiers(ASN1encoding_t enc, ASN1uint32_t tag, DigestAlgorithmIdentifiers *val);
static int ASN1CALL ASN1Enc_DigestAlgorithmIdentifiersNC(ASN1encoding_t enc, ASN1uint32_t tag, DigestAlgorithmIdentifiersNC *val);
static int ASN1CALL ASN1Enc_SignerInfos(ASN1encoding_t enc, ASN1uint32_t tag, SignerInfos *val);
static int ASN1CALL ASN1Enc_DigestAlgorithmBlobs(ASN1encoding_t enc, ASN1uint32_t tag, DigestAlgorithmBlobs *val);
static int ASN1CALL ASN1Enc_SignerInfosNC(ASN1encoding_t enc, ASN1uint32_t tag, SignerInfosNC *val);
static int ASN1CALL ASN1Enc_SignerInfoWithAABlobs(ASN1encoding_t enc, ASN1uint32_t tag, SignerInfoWithAABlobs *val);
static int ASN1CALL ASN1Enc_SignerInfoWithAABlob(ASN1encoding_t enc, ASN1uint32_t tag, SignerInfoWithAABlob *val);
static int ASN1CALL ASN1Enc_SignerInfoWithAttrBlobs(ASN1encoding_t enc, ASN1uint32_t tag, SignerInfoWithAttrBlobs *val);
static int ASN1CALL ASN1Enc_SignerInfoWithBlobs(ASN1encoding_t enc, ASN1uint32_t tag, SignerInfoWithBlobs *val);
static int ASN1CALL ASN1Enc_RecipientInfos(ASN1encoding_t enc, ASN1uint32_t tag, RecipientInfos *val);
static int ASN1CALL ASN1Enc_EncryptedContentInfo(ASN1encoding_t enc, ASN1uint32_t tag, EncryptedContentInfo *val);
static int ASN1CALL ASN1Enc_RecipientInfo(ASN1encoding_t enc, ASN1uint32_t tag, RecipientInfo *val);
static int ASN1CALL ASN1Enc_SignedAndEnvelopedData(ASN1encoding_t enc, ASN1uint32_t tag, SignedAndEnvelopedData *val);
static int ASN1CALL ASN1Enc_DigestedData(ASN1encoding_t enc, ASN1uint32_t tag, DigestedData *val);
static int ASN1CALL ASN1Enc_EncryptedData(ASN1encoding_t enc, ASN1uint32_t tag, EncryptedData *val);
static int ASN1CALL ASN1Enc_CertIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, CertIdentifier *val);
static int ASN1CALL ASN1Enc_OriginatorInfo(ASN1encoding_t enc, ASN1uint32_t tag, OriginatorInfo *val);
static int ASN1CALL ASN1Enc_OriginatorInfoNC(ASN1encoding_t enc, ASN1uint32_t tag, OriginatorInfoNC *val);
static int ASN1CALL ASN1Enc_CmsRecipientInfos(ASN1encoding_t enc, ASN1uint32_t tag, CmsRecipientInfos *val);
static int ASN1CALL ASN1Enc_KeyTransRecipientInfo(ASN1encoding_t enc, ASN1uint32_t tag, KeyTransRecipientInfo *val);
static int ASN1CALL ASN1Enc_OriginatorPublicKey(ASN1encoding_t enc, ASN1uint32_t tag, OriginatorPublicKey *val);
static int ASN1CALL ASN1Enc_RecipientEncryptedKeys(ASN1encoding_t enc, ASN1uint32_t tag, RecipientEncryptedKeys *val);
static int ASN1CALL ASN1Enc_OtherKeyAttribute(ASN1encoding_t enc, ASN1uint32_t tag, OtherKeyAttribute *val);
static int ASN1CALL ASN1Enc_MailListKeyIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, MailListKeyIdentifier *val);
static int ASN1CALL ASN1Enc_DigestInfo(ASN1encoding_t enc, ASN1uint32_t tag, DigestInfo *val);
static int ASN1CALL ASN1Enc_SignedData(ASN1encoding_t enc, ASN1uint32_t tag, SignedData *val);
static int ASN1CALL ASN1Enc_SignerInfo(ASN1encoding_t enc, ASN1uint32_t tag, SignerInfo *val);
static int ASN1CALL ASN1Enc_SignedDataWithBlobs(ASN1encoding_t enc, ASN1uint32_t tag, SignedDataWithBlobs *val);
static int ASN1CALL ASN1Enc_EnvelopedData(ASN1encoding_t enc, ASN1uint32_t tag, EnvelopedData *val);
static int ASN1CALL ASN1Enc_CmsEnvelopedData(ASN1encoding_t enc, ASN1uint32_t tag, CmsEnvelopedData *val);
static int ASN1CALL ASN1Enc_OriginatorIdentifierOrKey(ASN1encoding_t enc, ASN1uint32_t tag, OriginatorIdentifierOrKey *val);
static int ASN1CALL ASN1Enc_RecipientKeyIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, RecipientKeyIdentifier *val);
static int ASN1CALL ASN1Enc_MailListRecipientInfo(ASN1encoding_t enc, ASN1uint32_t tag, MailListRecipientInfo *val);
static int ASN1CALL ASN1Enc_KeyAgreeRecipientInfo(ASN1encoding_t enc, ASN1uint32_t tag, KeyAgreeRecipientInfo *val);
static int ASN1CALL ASN1Enc_RecipientIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, RecipientIdentifier *val);
static int ASN1CALL ASN1Enc_CmsRecipientInfo(ASN1encoding_t enc, ASN1uint32_t tag, CmsRecipientInfo *val);
static int ASN1CALL ASN1Enc_RecipientEncryptedKey(ASN1encoding_t enc, ASN1uint32_t tag, RecipientEncryptedKey *val);
static int ASN1CALL ASN1Dec_ObjectID(ASN1decoding_t dec, ASN1uint32_t tag, ObjectID *val);
static int ASN1CALL ASN1Dec_ObjectIdentifierType(ASN1decoding_t dec, ASN1uint32_t tag, ObjectIdentifierType *val);
static int ASN1CALL ASN1Dec_OctetStringType(ASN1decoding_t dec, ASN1uint32_t tag, OctetStringType *val);
static int ASN1CALL ASN1Dec_IntegerType(ASN1decoding_t dec, ASN1uint32_t tag, IntegerType *val);
static int ASN1CALL ASN1Dec_HugeIntegerType(ASN1decoding_t dec, ASN1uint32_t tag, HugeIntegerType *val);
static int ASN1CALL ASN1Dec_AlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, AlgorithmIdentifier *val);
static int ASN1CALL ASN1Dec_AlgorithmIdentifierNC2(ASN1decoding_t dec, ASN1uint32_t tag, AlgorithmIdentifierNC2 *val);
static int ASN1CALL ASN1Dec_DigestAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, DigestAlgorithmIdentifier *val);
static int ASN1CALL ASN1Dec_AlgorithmIdentifiers(ASN1decoding_t dec, ASN1uint32_t tag, AlgorithmIdentifiers *val);
static int ASN1CALL ASN1Dec_AttributeSetValue(ASN1decoding_t dec, ASN1uint32_t tag, AttributeSetValue *val);
static int ASN1CALL ASN1Dec_AttributeSetValueNC(ASN1decoding_t dec, ASN1uint32_t tag, AttributeSetValueNC *val);
static int ASN1CALL ASN1Dec_SetOfAny(ASN1decoding_t dec, ASN1uint32_t tag, SetOfAny *val);
static int ASN1CALL ASN1Dec_Attribute(ASN1decoding_t dec, ASN1uint32_t tag, Attribute *val);
static int ASN1CALL ASN1Dec_AttributeNC2(ASN1decoding_t dec, ASN1uint32_t tag, AttributeNC2 *val);
static int ASN1CALL ASN1Dec_Attributes(ASN1decoding_t dec, ASN1uint32_t tag, Attributes *val);
static int ASN1CALL ASN1Dec_AttributesNC(ASN1decoding_t dec, ASN1uint32_t tag, AttributesNC *val);
static int ASN1CALL ASN1Dec_AttributesNC2(ASN1decoding_t dec, ASN1uint32_t tag, AttributesNC2 *val);
static int ASN1CALL ASN1Dec_Crls(ASN1decoding_t dec, ASN1uint32_t tag, Crls *val);
static int ASN1CALL ASN1Dec_CrlsNC(ASN1decoding_t dec, ASN1uint32_t tag, CrlsNC *val);
static int ASN1CALL ASN1Dec_ContentEncryptionAlgId(ASN1decoding_t dec, ASN1uint32_t tag, ContentEncryptionAlgId *val);
static int ASN1CALL ASN1Dec_DigestEncryptionAlgId(ASN1decoding_t dec, ASN1uint32_t tag, DigestEncryptionAlgId *val);
static int ASN1CALL ASN1Dec_DigestEncryptionAlgIdNC(ASN1decoding_t dec, ASN1uint32_t tag, DigestEncryptionAlgIdNC *val);
static int ASN1CALL ASN1Dec_Certificates(ASN1decoding_t dec, ASN1uint32_t tag, Certificates *val);
static int ASN1CALL ASN1Dec_CertificatesNC(ASN1decoding_t dec, ASN1uint32_t tag, CertificatesNC *val);
static int ASN1CALL ASN1Dec_IssuerAndSerialNumber(ASN1decoding_t dec, ASN1uint32_t tag, IssuerAndSerialNumber *val);
static int ASN1CALL ASN1Dec_KeyEncryptionAlgId(ASN1decoding_t dec, ASN1uint32_t tag, KeyEncryptionAlgId *val);
static int ASN1CALL ASN1Dec_ContentInfo(ASN1decoding_t dec, ASN1uint32_t tag, ContentInfo *val);
static int ASN1CALL ASN1Dec_ContentInfoNC(ASN1decoding_t dec, ASN1uint32_t tag, ContentInfoNC *val);
static int ASN1CALL ASN1Dec_DigestAlgorithmIdentifiers(ASN1decoding_t dec, ASN1uint32_t tag, DigestAlgorithmIdentifiers *val);
static int ASN1CALL ASN1Dec_DigestAlgorithmIdentifiersNC(ASN1decoding_t dec, ASN1uint32_t tag, DigestAlgorithmIdentifiersNC *val);
static int ASN1CALL ASN1Dec_SignerInfos(ASN1decoding_t dec, ASN1uint32_t tag, SignerInfos *val);
static int ASN1CALL ASN1Dec_DigestAlgorithmBlobs(ASN1decoding_t dec, ASN1uint32_t tag, DigestAlgorithmBlobs *val);
static int ASN1CALL ASN1Dec_SignerInfosNC(ASN1decoding_t dec, ASN1uint32_t tag, SignerInfosNC *val);
static int ASN1CALL ASN1Dec_SignerInfoWithAABlobs(ASN1decoding_t dec, ASN1uint32_t tag, SignerInfoWithAABlobs *val);
static int ASN1CALL ASN1Dec_SignerInfoWithAABlob(ASN1decoding_t dec, ASN1uint32_t tag, SignerInfoWithAABlob *val);
static int ASN1CALL ASN1Dec_SignerInfoWithAttrBlobs(ASN1decoding_t dec, ASN1uint32_t tag, SignerInfoWithAttrBlobs *val);
static int ASN1CALL ASN1Dec_SignerInfoWithBlobs(ASN1decoding_t dec, ASN1uint32_t tag, SignerInfoWithBlobs *val);
static int ASN1CALL ASN1Dec_RecipientInfos(ASN1decoding_t dec, ASN1uint32_t tag, RecipientInfos *val);
static int ASN1CALL ASN1Dec_EncryptedContentInfo(ASN1decoding_t dec, ASN1uint32_t tag, EncryptedContentInfo *val);
static int ASN1CALL ASN1Dec_RecipientInfo(ASN1decoding_t dec, ASN1uint32_t tag, RecipientInfo *val);
static int ASN1CALL ASN1Dec_SignedAndEnvelopedData(ASN1decoding_t dec, ASN1uint32_t tag, SignedAndEnvelopedData *val);
static int ASN1CALL ASN1Dec_DigestedData(ASN1decoding_t dec, ASN1uint32_t tag, DigestedData *val);
static int ASN1CALL ASN1Dec_EncryptedData(ASN1decoding_t dec, ASN1uint32_t tag, EncryptedData *val);
static int ASN1CALL ASN1Dec_CertIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, CertIdentifier *val);
static int ASN1CALL ASN1Dec_OriginatorInfo(ASN1decoding_t dec, ASN1uint32_t tag, OriginatorInfo *val);
static int ASN1CALL ASN1Dec_OriginatorInfoNC(ASN1decoding_t dec, ASN1uint32_t tag, OriginatorInfoNC *val);
static int ASN1CALL ASN1Dec_CmsRecipientInfos(ASN1decoding_t dec, ASN1uint32_t tag, CmsRecipientInfos *val);
static int ASN1CALL ASN1Dec_KeyTransRecipientInfo(ASN1decoding_t dec, ASN1uint32_t tag, KeyTransRecipientInfo *val);
static int ASN1CALL ASN1Dec_OriginatorPublicKey(ASN1decoding_t dec, ASN1uint32_t tag, OriginatorPublicKey *val);
static int ASN1CALL ASN1Dec_RecipientEncryptedKeys(ASN1decoding_t dec, ASN1uint32_t tag, RecipientEncryptedKeys *val);
static int ASN1CALL ASN1Dec_OtherKeyAttribute(ASN1decoding_t dec, ASN1uint32_t tag, OtherKeyAttribute *val);
static int ASN1CALL ASN1Dec_MailListKeyIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, MailListKeyIdentifier *val);
static int ASN1CALL ASN1Dec_DigestInfo(ASN1decoding_t dec, ASN1uint32_t tag, DigestInfo *val);
static int ASN1CALL ASN1Dec_SignedData(ASN1decoding_t dec, ASN1uint32_t tag, SignedData *val);
static int ASN1CALL ASN1Dec_SignerInfo(ASN1decoding_t dec, ASN1uint32_t tag, SignerInfo *val);
static int ASN1CALL ASN1Dec_SignedDataWithBlobs(ASN1decoding_t dec, ASN1uint32_t tag, SignedDataWithBlobs *val);
static int ASN1CALL ASN1Dec_EnvelopedData(ASN1decoding_t dec, ASN1uint32_t tag, EnvelopedData *val);
static int ASN1CALL ASN1Dec_CmsEnvelopedData(ASN1decoding_t dec, ASN1uint32_t tag, CmsEnvelopedData *val);
static int ASN1CALL ASN1Dec_OriginatorIdentifierOrKey(ASN1decoding_t dec, ASN1uint32_t tag, OriginatorIdentifierOrKey *val);
static int ASN1CALL ASN1Dec_RecipientKeyIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, RecipientKeyIdentifier *val);
static int ASN1CALL ASN1Dec_MailListRecipientInfo(ASN1decoding_t dec, ASN1uint32_t tag, MailListRecipientInfo *val);
static int ASN1CALL ASN1Dec_KeyAgreeRecipientInfo(ASN1decoding_t dec, ASN1uint32_t tag, KeyAgreeRecipientInfo *val);
static int ASN1CALL ASN1Dec_RecipientIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, RecipientIdentifier *val);
static int ASN1CALL ASN1Dec_CmsRecipientInfo(ASN1decoding_t dec, ASN1uint32_t tag, CmsRecipientInfo *val);
static int ASN1CALL ASN1Dec_RecipientEncryptedKey(ASN1decoding_t dec, ASN1uint32_t tag, RecipientEncryptedKey *val);
static void ASN1CALL ASN1Free_ObjectID(ObjectID *val);
static void ASN1CALL ASN1Free_ObjectIdentifierType(ObjectIdentifierType *val);
static void ASN1CALL ASN1Free_OctetStringType(OctetStringType *val);
static void ASN1CALL ASN1Free_HugeIntegerType(HugeIntegerType *val);
static void ASN1CALL ASN1Free_AlgorithmIdentifier(AlgorithmIdentifier *val);
static void ASN1CALL ASN1Free_AlgorithmIdentifierNC2(AlgorithmIdentifierNC2 *val);
static void ASN1CALL ASN1Free_DigestAlgorithmIdentifier(DigestAlgorithmIdentifier *val);
static void ASN1CALL ASN1Free_AlgorithmIdentifiers(AlgorithmIdentifiers *val);
static void ASN1CALL ASN1Free_AttributeSetValue(AttributeSetValue *val);
static void ASN1CALL ASN1Free_AttributeSetValueNC(AttributeSetValueNC *val);
static void ASN1CALL ASN1Free_SetOfAny(SetOfAny *val);
static void ASN1CALL ASN1Free_Attribute(Attribute *val);
static void ASN1CALL ASN1Free_AttributeNC2(AttributeNC2 *val);
static void ASN1CALL ASN1Free_Attributes(Attributes *val);
static void ASN1CALL ASN1Free_AttributesNC(AttributesNC *val);
static void ASN1CALL ASN1Free_AttributesNC2(AttributesNC2 *val);
static void ASN1CALL ASN1Free_Crls(Crls *val);
static void ASN1CALL ASN1Free_CrlsNC(CrlsNC *val);
static void ASN1CALL ASN1Free_ContentEncryptionAlgId(ContentEncryptionAlgId *val);
static void ASN1CALL ASN1Free_DigestEncryptionAlgId(DigestEncryptionAlgId *val);
static void ASN1CALL ASN1Free_DigestEncryptionAlgIdNC(DigestEncryptionAlgIdNC *val);
static void ASN1CALL ASN1Free_Certificates(Certificates *val);
static void ASN1CALL ASN1Free_CertificatesNC(CertificatesNC *val);
static void ASN1CALL ASN1Free_IssuerAndSerialNumber(IssuerAndSerialNumber *val);
static void ASN1CALL ASN1Free_KeyEncryptionAlgId(KeyEncryptionAlgId *val);
static void ASN1CALL ASN1Free_ContentInfo(ContentInfo *val);
static void ASN1CALL ASN1Free_ContentInfoNC(ContentInfoNC *val);
static void ASN1CALL ASN1Free_DigestAlgorithmIdentifiers(DigestAlgorithmIdentifiers *val);
static void ASN1CALL ASN1Free_DigestAlgorithmIdentifiersNC(DigestAlgorithmIdentifiersNC *val);
static void ASN1CALL ASN1Free_SignerInfos(SignerInfos *val);
static void ASN1CALL ASN1Free_DigestAlgorithmBlobs(DigestAlgorithmBlobs *val);
static void ASN1CALL ASN1Free_SignerInfosNC(SignerInfosNC *val);
static void ASN1CALL ASN1Free_SignerInfoWithAABlobs(SignerInfoWithAABlobs *val);
static void ASN1CALL ASN1Free_SignerInfoWithAABlob(SignerInfoWithAABlob *val);
static void ASN1CALL ASN1Free_SignerInfoWithAttrBlobs(SignerInfoWithAttrBlobs *val);
static void ASN1CALL ASN1Free_SignerInfoWithBlobs(SignerInfoWithBlobs *val);
static void ASN1CALL ASN1Free_RecipientInfos(RecipientInfos *val);
static void ASN1CALL ASN1Free_EncryptedContentInfo(EncryptedContentInfo *val);
static void ASN1CALL ASN1Free_RecipientInfo(RecipientInfo *val);
static void ASN1CALL ASN1Free_SignedAndEnvelopedData(SignedAndEnvelopedData *val);
static void ASN1CALL ASN1Free_DigestedData(DigestedData *val);
static void ASN1CALL ASN1Free_EncryptedData(EncryptedData *val);
static void ASN1CALL ASN1Free_CertIdentifier(CertIdentifier *val);
static void ASN1CALL ASN1Free_OriginatorInfo(OriginatorInfo *val);
static void ASN1CALL ASN1Free_OriginatorInfoNC(OriginatorInfoNC *val);
static void ASN1CALL ASN1Free_CmsRecipientInfos(CmsRecipientInfos *val);
static void ASN1CALL ASN1Free_KeyTransRecipientInfo(KeyTransRecipientInfo *val);
static void ASN1CALL ASN1Free_OriginatorPublicKey(OriginatorPublicKey *val);
static void ASN1CALL ASN1Free_RecipientEncryptedKeys(RecipientEncryptedKeys *val);
static void ASN1CALL ASN1Free_OtherKeyAttribute(OtherKeyAttribute *val);
static void ASN1CALL ASN1Free_MailListKeyIdentifier(MailListKeyIdentifier *val);
static void ASN1CALL ASN1Free_DigestInfo(DigestInfo *val);
static void ASN1CALL ASN1Free_SignedData(SignedData *val);
static void ASN1CALL ASN1Free_SignerInfo(SignerInfo *val);
static void ASN1CALL ASN1Free_SignedDataWithBlobs(SignedDataWithBlobs *val);
static void ASN1CALL ASN1Free_EnvelopedData(EnvelopedData *val);
static void ASN1CALL ASN1Free_CmsEnvelopedData(CmsEnvelopedData *val);
static void ASN1CALL ASN1Free_OriginatorIdentifierOrKey(OriginatorIdentifierOrKey *val);
static void ASN1CALL ASN1Free_RecipientKeyIdentifier(RecipientKeyIdentifier *val);
static void ASN1CALL ASN1Free_MailListRecipientInfo(MailListRecipientInfo *val);
static void ASN1CALL ASN1Free_KeyAgreeRecipientInfo(KeyAgreeRecipientInfo *val);
static void ASN1CALL ASN1Free_RecipientIdentifier(RecipientIdentifier *val);
static void ASN1CALL ASN1Free_CmsRecipientInfo(CmsRecipientInfo *val);
static void ASN1CALL ASN1Free_RecipientEncryptedKey(RecipientEncryptedKey *val);

typedef ASN1BerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[48] = {
    (ASN1EncFun_t) ASN1Enc_ObjectID,
    (ASN1EncFun_t) ASN1Enc_ObjectIdentifierType,
    (ASN1EncFun_t) ASN1Enc_OctetStringType,
    (ASN1EncFun_t) ASN1Enc_IntegerType,
    (ASN1EncFun_t) ASN1Enc_HugeIntegerType,
    (ASN1EncFun_t) ASN1Enc_AlgorithmIdentifier,
    (ASN1EncFun_t) ASN1Enc_AlgorithmIdentifierNC2,
    (ASN1EncFun_t) ASN1Enc_AlgorithmIdentifiers,
    (ASN1EncFun_t) ASN1Enc_AttributeSetValue,
    (ASN1EncFun_t) ASN1Enc_AttributeSetValueNC,
    (ASN1EncFun_t) ASN1Enc_SetOfAny,
    (ASN1EncFun_t) ASN1Enc_AttributeNC2,
    (ASN1EncFun_t) ASN1Enc_Attributes,
    (ASN1EncFun_t) ASN1Enc_AttributesNC,
    (ASN1EncFun_t) ASN1Enc_AttributesNC2,
    (ASN1EncFun_t) ASN1Enc_CrlsNC,
    (ASN1EncFun_t) ASN1Enc_CertificatesNC,
    (ASN1EncFun_t) ASN1Enc_IssuerAndSerialNumber,
    (ASN1EncFun_t) ASN1Enc_ContentInfo,
    (ASN1EncFun_t) ASN1Enc_ContentInfoNC,
    (ASN1EncFun_t) ASN1Enc_DigestAlgorithmIdentifiersNC,
    (ASN1EncFun_t) ASN1Enc_SignerInfos,
    (ASN1EncFun_t) ASN1Enc_DigestAlgorithmBlobs,
    (ASN1EncFun_t) ASN1Enc_SignerInfosNC,
    (ASN1EncFun_t) ASN1Enc_SignerInfoWithAABlobs,
    (ASN1EncFun_t) ASN1Enc_SignerInfoWithAABlob,
    (ASN1EncFun_t) ASN1Enc_SignerInfoWithAttrBlobs,
    (ASN1EncFun_t) ASN1Enc_SignerInfoWithBlobs,
    (ASN1EncFun_t) ASN1Enc_RecipientInfos,
    (ASN1EncFun_t) ASN1Enc_EncryptedContentInfo,
    (ASN1EncFun_t) ASN1Enc_RecipientInfo,
    (ASN1EncFun_t) ASN1Enc_SignedAndEnvelopedData,
    (ASN1EncFun_t) ASN1Enc_DigestedData,
    (ASN1EncFun_t) ASN1Enc_EncryptedData,
    (ASN1EncFun_t) ASN1Enc_CertIdentifier,
    (ASN1EncFun_t) ASN1Enc_OriginatorInfo,
    (ASN1EncFun_t) ASN1Enc_OriginatorInfoNC,
    (ASN1EncFun_t) ASN1Enc_CmsRecipientInfos,
    (ASN1EncFun_t) ASN1Enc_KeyTransRecipientInfo,
    (ASN1EncFun_t) ASN1Enc_DigestInfo,
    (ASN1EncFun_t) ASN1Enc_SignedData,
    (ASN1EncFun_t) ASN1Enc_SignerInfo,
    (ASN1EncFun_t) ASN1Enc_SignedDataWithBlobs,
    (ASN1EncFun_t) ASN1Enc_EnvelopedData,
    (ASN1EncFun_t) ASN1Enc_CmsEnvelopedData,
    (ASN1EncFun_t) ASN1Enc_MailListRecipientInfo,
    (ASN1EncFun_t) ASN1Enc_KeyAgreeRecipientInfo,
    (ASN1EncFun_t) ASN1Enc_CmsRecipientInfo,
};
typedef ASN1BerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[48] = {
    (ASN1DecFun_t) ASN1Dec_ObjectID,
    (ASN1DecFun_t) ASN1Dec_ObjectIdentifierType,
    (ASN1DecFun_t) ASN1Dec_OctetStringType,
    (ASN1DecFun_t) ASN1Dec_IntegerType,
    (ASN1DecFun_t) ASN1Dec_HugeIntegerType,
    (ASN1DecFun_t) ASN1Dec_AlgorithmIdentifier,
    (ASN1DecFun_t) ASN1Dec_AlgorithmIdentifierNC2,
    (ASN1DecFun_t) ASN1Dec_AlgorithmIdentifiers,
    (ASN1DecFun_t) ASN1Dec_AttributeSetValue,
    (ASN1DecFun_t) ASN1Dec_AttributeSetValueNC,
    (ASN1DecFun_t) ASN1Dec_SetOfAny,
    (ASN1DecFun_t) ASN1Dec_AttributeNC2,
    (ASN1DecFun_t) ASN1Dec_Attributes,
    (ASN1DecFun_t) ASN1Dec_AttributesNC,
    (ASN1DecFun_t) ASN1Dec_AttributesNC2,
    (ASN1DecFun_t) ASN1Dec_CrlsNC,
    (ASN1DecFun_t) ASN1Dec_CertificatesNC,
    (ASN1DecFun_t) ASN1Dec_IssuerAndSerialNumber,
    (ASN1DecFun_t) ASN1Dec_ContentInfo,
    (ASN1DecFun_t) ASN1Dec_ContentInfoNC,
    (ASN1DecFun_t) ASN1Dec_DigestAlgorithmIdentifiersNC,
    (ASN1DecFun_t) ASN1Dec_SignerInfos,
    (ASN1DecFun_t) ASN1Dec_DigestAlgorithmBlobs,
    (ASN1DecFun_t) ASN1Dec_SignerInfosNC,
    (ASN1DecFun_t) ASN1Dec_SignerInfoWithAABlobs,
    (ASN1DecFun_t) ASN1Dec_SignerInfoWithAABlob,
    (ASN1DecFun_t) ASN1Dec_SignerInfoWithAttrBlobs,
    (ASN1DecFun_t) ASN1Dec_SignerInfoWithBlobs,
    (ASN1DecFun_t) ASN1Dec_RecipientInfos,
    (ASN1DecFun_t) ASN1Dec_EncryptedContentInfo,
    (ASN1DecFun_t) ASN1Dec_RecipientInfo,
    (ASN1DecFun_t) ASN1Dec_SignedAndEnvelopedData,
    (ASN1DecFun_t) ASN1Dec_DigestedData,
    (ASN1DecFun_t) ASN1Dec_EncryptedData,
    (ASN1DecFun_t) ASN1Dec_CertIdentifier,
    (ASN1DecFun_t) ASN1Dec_OriginatorInfo,
    (ASN1DecFun_t) ASN1Dec_OriginatorInfoNC,
    (ASN1DecFun_t) ASN1Dec_CmsRecipientInfos,
    (ASN1DecFun_t) ASN1Dec_KeyTransRecipientInfo,
    (ASN1DecFun_t) ASN1Dec_DigestInfo,
    (ASN1DecFun_t) ASN1Dec_SignedData,
    (ASN1DecFun_t) ASN1Dec_SignerInfo,
    (ASN1DecFun_t) ASN1Dec_SignedDataWithBlobs,
    (ASN1DecFun_t) ASN1Dec_EnvelopedData,
    (ASN1DecFun_t) ASN1Dec_CmsEnvelopedData,
    (ASN1DecFun_t) ASN1Dec_MailListRecipientInfo,
    (ASN1DecFun_t) ASN1Dec_KeyAgreeRecipientInfo,
    (ASN1DecFun_t) ASN1Dec_CmsRecipientInfo,
};
static const ASN1FreeFun_t freefntab[48] = {
    (ASN1FreeFun_t) ASN1Free_ObjectID,
    (ASN1FreeFun_t) ASN1Free_ObjectIdentifierType,
    (ASN1FreeFun_t) ASN1Free_OctetStringType,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) ASN1Free_HugeIntegerType,
    (ASN1FreeFun_t) ASN1Free_AlgorithmIdentifier,
    (ASN1FreeFun_t) ASN1Free_AlgorithmIdentifierNC2,
    (ASN1FreeFun_t) ASN1Free_AlgorithmIdentifiers,
    (ASN1FreeFun_t) ASN1Free_AttributeSetValue,
    (ASN1FreeFun_t) ASN1Free_AttributeSetValueNC,
    (ASN1FreeFun_t) ASN1Free_SetOfAny,
    (ASN1FreeFun_t) ASN1Free_AttributeNC2,
    (ASN1FreeFun_t) ASN1Free_Attributes,
    (ASN1FreeFun_t) ASN1Free_AttributesNC,
    (ASN1FreeFun_t) ASN1Free_AttributesNC2,
    (ASN1FreeFun_t) ASN1Free_CrlsNC,
    (ASN1FreeFun_t) ASN1Free_CertificatesNC,
    (ASN1FreeFun_t) ASN1Free_IssuerAndSerialNumber,
    (ASN1FreeFun_t) ASN1Free_ContentInfo,
    (ASN1FreeFun_t) ASN1Free_ContentInfoNC,
    (ASN1FreeFun_t) ASN1Free_DigestAlgorithmIdentifiersNC,
    (ASN1FreeFun_t) ASN1Free_SignerInfos,
    (ASN1FreeFun_t) ASN1Free_DigestAlgorithmBlobs,
    (ASN1FreeFun_t) ASN1Free_SignerInfosNC,
    (ASN1FreeFun_t) ASN1Free_SignerInfoWithAABlobs,
    (ASN1FreeFun_t) ASN1Free_SignerInfoWithAABlob,
    (ASN1FreeFun_t) ASN1Free_SignerInfoWithAttrBlobs,
    (ASN1FreeFun_t) ASN1Free_SignerInfoWithBlobs,
    (ASN1FreeFun_t) ASN1Free_RecipientInfos,
    (ASN1FreeFun_t) ASN1Free_EncryptedContentInfo,
    (ASN1FreeFun_t) ASN1Free_RecipientInfo,
    (ASN1FreeFun_t) ASN1Free_SignedAndEnvelopedData,
    (ASN1FreeFun_t) ASN1Free_DigestedData,
    (ASN1FreeFun_t) ASN1Free_EncryptedData,
    (ASN1FreeFun_t) ASN1Free_CertIdentifier,
    (ASN1FreeFun_t) ASN1Free_OriginatorInfo,
    (ASN1FreeFun_t) ASN1Free_OriginatorInfoNC,
    (ASN1FreeFun_t) ASN1Free_CmsRecipientInfos,
    (ASN1FreeFun_t) ASN1Free_KeyTransRecipientInfo,
    (ASN1FreeFun_t) ASN1Free_DigestInfo,
    (ASN1FreeFun_t) ASN1Free_SignedData,
    (ASN1FreeFun_t) ASN1Free_SignerInfo,
    (ASN1FreeFun_t) ASN1Free_SignedDataWithBlobs,
    (ASN1FreeFun_t) ASN1Free_EnvelopedData,
    (ASN1FreeFun_t) ASN1Free_CmsEnvelopedData,
    (ASN1FreeFun_t) ASN1Free_MailListRecipientInfo,
    (ASN1FreeFun_t) ASN1Free_KeyAgreeRecipientInfo,
    (ASN1FreeFun_t) ASN1Free_CmsRecipientInfo,
};
static const ULONG sizetab[48] = {
    SIZE_PKCS_Module_PDU_0,
    SIZE_PKCS_Module_PDU_1,
    SIZE_PKCS_Module_PDU_2,
    SIZE_PKCS_Module_PDU_3,
    SIZE_PKCS_Module_PDU_4,
    SIZE_PKCS_Module_PDU_5,
    SIZE_PKCS_Module_PDU_6,
    SIZE_PKCS_Module_PDU_7,
    SIZE_PKCS_Module_PDU_8,
    SIZE_PKCS_Module_PDU_9,
    SIZE_PKCS_Module_PDU_10,
    SIZE_PKCS_Module_PDU_11,
    SIZE_PKCS_Module_PDU_12,
    SIZE_PKCS_Module_PDU_13,
    SIZE_PKCS_Module_PDU_14,
    SIZE_PKCS_Module_PDU_15,
    SIZE_PKCS_Module_PDU_16,
    SIZE_PKCS_Module_PDU_17,
    SIZE_PKCS_Module_PDU_18,
    SIZE_PKCS_Module_PDU_19,
    SIZE_PKCS_Module_PDU_20,
    SIZE_PKCS_Module_PDU_21,
    SIZE_PKCS_Module_PDU_22,
    SIZE_PKCS_Module_PDU_23,
    SIZE_PKCS_Module_PDU_24,
    SIZE_PKCS_Module_PDU_25,
    SIZE_PKCS_Module_PDU_26,
    SIZE_PKCS_Module_PDU_27,
    SIZE_PKCS_Module_PDU_28,
    SIZE_PKCS_Module_PDU_29,
    SIZE_PKCS_Module_PDU_30,
    SIZE_PKCS_Module_PDU_31,
    SIZE_PKCS_Module_PDU_32,
    SIZE_PKCS_Module_PDU_33,
    SIZE_PKCS_Module_PDU_34,
    SIZE_PKCS_Module_PDU_35,
    SIZE_PKCS_Module_PDU_36,
    SIZE_PKCS_Module_PDU_37,
    SIZE_PKCS_Module_PDU_38,
    SIZE_PKCS_Module_PDU_39,
    SIZE_PKCS_Module_PDU_40,
    SIZE_PKCS_Module_PDU_41,
    SIZE_PKCS_Module_PDU_42,
    SIZE_PKCS_Module_PDU_43,
    SIZE_PKCS_Module_PDU_44,
    SIZE_PKCS_Module_PDU_45,
    SIZE_PKCS_Module_PDU_46,
    SIZE_PKCS_Module_PDU_47,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */

void ASN1CALL PKCS_Module_Startup(void)
{
    PKCS_Module = ASN1_CreateModule(0x10000, ASN1_BER_RULE_DER, ASN1FLAGS_NOASSERT, 48, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x73636b70);
}

void ASN1CALL PKCS_Module_Cleanup(void)
{
    ASN1_CloseModule(PKCS_Module);
    PKCS_Module = NULL;
}

static int ASN1CALL ASN1Enc_ObjectID(ASN1encoding_t enc, ASN1uint32_t tag, ObjectID *val)
{
    if (!ASN1BEREncObjectIdentifier2(enc, tag ? tag : 0x6, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ObjectID(ASN1decoding_t dec, ASN1uint32_t tag, ObjectID *val)
{
    if (!ASN1BERDecObjectIdentifier2(dec, tag ? tag : 0x6, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ObjectID(ObjectID *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ObjectIdentifierType(ASN1encoding_t enc, ASN1uint32_t tag, ObjectIdentifierType *val)
{
    if (!ASN1BEREncObjectIdentifier2(enc, tag ? tag : 0x6, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ObjectIdentifierType(ASN1decoding_t dec, ASN1uint32_t tag, ObjectIdentifierType *val)
{
    if (!ASN1BERDecObjectIdentifier2(dec, tag ? tag : 0x6, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ObjectIdentifierType(ObjectIdentifierType *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_OctetStringType(ASN1encoding_t enc, ASN1uint32_t tag, OctetStringType *val)
{
    if (!ASN1DEREncOctetString(enc, tag ? tag : 0x4, (val)->length, (val)->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OctetStringType(ASN1decoding_t dec, ASN1uint32_t tag, OctetStringType *val)
{
    if (!ASN1BERDecOctetString(dec, tag ? tag : 0x4, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_OctetStringType(OctetStringType *val)
{
    if (val) {
	ASN1octetstring_free(val);
    }
}

static int ASN1CALL ASN1Enc_IntegerType(ASN1encoding_t enc, ASN1uint32_t tag, IntegerType *val)
{
    if (!ASN1BEREncS32(enc, tag ? tag : 0x2, *val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IntegerType(ASN1decoding_t dec, ASN1uint32_t tag, IntegerType *val)
{
    if (!ASN1BERDecS32Val(dec, tag ? tag : 0x2, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_HugeIntegerType(ASN1encoding_t enc, ASN1uint32_t tag, HugeIntegerType *val)
{
    if (!ASN1BEREncSX(enc, tag ? tag : 0x2, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_HugeIntegerType(ASN1decoding_t dec, ASN1uint32_t tag, HugeIntegerType *val)
{
    if (!ASN1BERDecSXVal(dec, tag ? tag : 0x2, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_HugeIntegerType(HugeIntegerType *val)
{
    if (val) {
	ASN1intx_free(val);
    }
}

static int ASN1CALL ASN1Enc_AlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, AlgorithmIdentifier *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->algorithm))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncOpenType(enc, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, AlgorithmIdentifier *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->algorithm))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOpenType(dd, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AlgorithmIdentifier(AlgorithmIdentifier *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1open_free(&(val)->parameters);
	}
    }
}

static int ASN1CALL ASN1Enc_AlgorithmIdentifierNC2(ASN1encoding_t enc, ASN1uint32_t tag, AlgorithmIdentifierNC2 *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->algorithm))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncOpenType(enc, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AlgorithmIdentifierNC2(ASN1decoding_t dec, ASN1uint32_t tag, AlgorithmIdentifierNC2 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->algorithm))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOpenType2(dd, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AlgorithmIdentifierNC2(AlgorithmIdentifierNC2 *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_DigestAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, DigestAlgorithmIdentifier *val)
{
    if (!ASN1Enc_AlgorithmIdentifier(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DigestAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, DigestAlgorithmIdentifier *val)
{
    if (!ASN1Dec_AlgorithmIdentifier(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DigestAlgorithmIdentifier(DigestAlgorithmIdentifier *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(val);
    }
}

static int ASN1CALL ASN1Enc_AlgorithmIdentifiers(ASN1encoding_t enc, ASN1uint32_t tag, AlgorithmIdentifiers *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_AlgorithmIdentifier(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AlgorithmIdentifiers(ASN1decoding_t dec, ASN1uint32_t tag, AlgorithmIdentifiers *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (AlgorithmIdentifier *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_AlgorithmIdentifier(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AlgorithmIdentifiers(AlgorithmIdentifiers *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_AlgorithmIdentifier(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_AlgorithmIdentifier(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_AttributeSetValue(ASN1encoding_t enc, ASN1uint32_t tag, AttributeSetValue *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AttributeSetValue(ASN1decoding_t dec, ASN1uint32_t tag, AttributeSetValue *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (AttributeSetValue_Set *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecOpenType(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AttributeSetValue(AttributeSetValue *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1open_free(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1open_free(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_AttributeSetValueNC(ASN1encoding_t enc, ASN1uint32_t tag, AttributeSetValueNC *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AttributeSetValueNC(ASN1decoding_t dec, ASN1uint32_t tag, AttributeSetValueNC *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (AttributeSetValueNC_Set *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecOpenType2(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AttributeSetValueNC(AttributeSetValueNC *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 1; i < (val)->count; i++) {
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_SetOfAny(ASN1encoding_t enc, ASN1uint32_t tag, SetOfAny *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfAny(ASN1decoding_t dec, ASN1uint32_t tag, SetOfAny *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (SetOfAny_Set *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecOpenType(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfAny(SetOfAny *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1open_free(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1open_free(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_Attribute(ASN1encoding_t enc, ASN1uint32_t tag, Attribute *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->attributeType))
	return 0;
    if (!ASN1Enc_AttributeSetValue(enc, 0, &(val)->attributeValue))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Attribute(ASN1decoding_t dec, ASN1uint32_t tag, Attribute *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->attributeType))
	return 0;
    if (!ASN1Dec_AttributeSetValue(dd, 0, &(val)->attributeValue))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Attribute(Attribute *val)
{
    if (val) {
	ASN1Free_AttributeSetValue(&(val)->attributeValue);
    }
}

static int ASN1CALL ASN1Enc_AttributeNC2(ASN1encoding_t enc, ASN1uint32_t tag, AttributeNC2 *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->attributeType))
	return 0;
    if (!ASN1Enc_AttributeSetValueNC(enc, 0, &(val)->attributeValue))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AttributeNC2(ASN1decoding_t dec, ASN1uint32_t tag, AttributeNC2 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->attributeType))
	return 0;
    if (!ASN1Dec_AttributeSetValueNC(dd, 0, &(val)->attributeValue))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AttributeNC2(AttributeNC2 *val)
{
    if (val) {
	ASN1Free_AttributeSetValueNC(&(val)->attributeValue);
    }
}

static int ASN1CALL ASN1Enc_Attributes(ASN1encoding_t enc, ASN1uint32_t tag, Attributes *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_Attribute(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Attributes(ASN1decoding_t dec, ASN1uint32_t tag, Attributes *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (Attribute *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_Attribute(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Attributes(Attributes *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_Attribute(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_Attribute(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_AttributesNC(ASN1encoding_t enc, ASN1uint32_t tag, AttributesNC *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AttributesNC(ASN1decoding_t dec, ASN1uint32_t tag, AttributesNC *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (AttributeNC *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecOpenType2(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AttributesNC(AttributesNC *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 1; i < (val)->count; i++) {
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_AttributesNC2(ASN1encoding_t enc, ASN1uint32_t tag, AttributesNC2 *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_AttributeNC2(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AttributesNC2(ASN1decoding_t dec, ASN1uint32_t tag, AttributesNC2 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (AttributeNC2 *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_AttributeNC2(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AttributesNC2(AttributesNC2 *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_AttributeNC2(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_AttributeNC2(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_Crls(ASN1encoding_t enc, ASN1uint32_t tag, Crls *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Crls(ASN1decoding_t dec, ASN1uint32_t tag, Crls *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (CertificateRevocationList *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecOpenType(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Crls(Crls *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1open_free(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1open_free(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_CrlsNC(ASN1encoding_t enc, ASN1uint32_t tag, CrlsNC *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CrlsNC(ASN1decoding_t dec, ASN1uint32_t tag, CrlsNC *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (CertificateRevocationListNC *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecOpenType2(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CrlsNC(CrlsNC *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 1; i < (val)->count; i++) {
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_ContentEncryptionAlgId(ASN1encoding_t enc, ASN1uint32_t tag, ContentEncryptionAlgId *val)
{
    if (!ASN1Enc_AlgorithmIdentifier(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ContentEncryptionAlgId(ASN1decoding_t dec, ASN1uint32_t tag, ContentEncryptionAlgId *val)
{
    if (!ASN1Dec_AlgorithmIdentifier(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ContentEncryptionAlgId(ContentEncryptionAlgId *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(val);
    }
}

static int ASN1CALL ASN1Enc_DigestEncryptionAlgId(ASN1encoding_t enc, ASN1uint32_t tag, DigestEncryptionAlgId *val)
{
    if (!ASN1Enc_AlgorithmIdentifier(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DigestEncryptionAlgId(ASN1decoding_t dec, ASN1uint32_t tag, DigestEncryptionAlgId *val)
{
    if (!ASN1Dec_AlgorithmIdentifier(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DigestEncryptionAlgId(DigestEncryptionAlgId *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(val);
    }
}

static int ASN1CALL ASN1Enc_DigestEncryptionAlgIdNC(ASN1encoding_t enc, ASN1uint32_t tag, DigestEncryptionAlgIdNC *val)
{
    if (!ASN1Enc_AlgorithmIdentifierNC2(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DigestEncryptionAlgIdNC(ASN1decoding_t dec, ASN1uint32_t tag, DigestEncryptionAlgIdNC *val)
{
    if (!ASN1Dec_AlgorithmIdentifierNC2(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DigestEncryptionAlgIdNC(DigestEncryptionAlgIdNC *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifierNC2(val);
    }
}

static int ASN1CALL ASN1Enc_Certificates(ASN1encoding_t enc, ASN1uint32_t tag, Certificates *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Certificates(ASN1decoding_t dec, ASN1uint32_t tag, Certificates *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (Certificate *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecOpenType(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Certificates(Certificates *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1open_free(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1open_free(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_CertificatesNC(ASN1encoding_t enc, ASN1uint32_t tag, CertificatesNC *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CertificatesNC(ASN1decoding_t dec, ASN1uint32_t tag, CertificatesNC *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (CertificateNC *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecOpenType2(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CertificatesNC(CertificatesNC *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 1; i < (val)->count; i++) {
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_IssuerAndSerialNumber(ASN1encoding_t enc, ASN1uint32_t tag, IssuerAndSerialNumber *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->issuer))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->serialNumber))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IssuerAndSerialNumber(ASN1decoding_t dec, ASN1uint32_t tag, IssuerAndSerialNumber *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecOpenType(dd, &(val)->issuer))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->serialNumber))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_IssuerAndSerialNumber(IssuerAndSerialNumber *val)
{
    if (val) {
	ASN1open_free(&(val)->issuer);
	ASN1intx_free(&(val)->serialNumber);
    }
}

static int ASN1CALL ASN1Enc_KeyEncryptionAlgId(ASN1encoding_t enc, ASN1uint32_t tag, KeyEncryptionAlgId *val)
{
    if (!ASN1Enc_AlgorithmIdentifier(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KeyEncryptionAlgId(ASN1decoding_t dec, ASN1uint32_t tag, KeyEncryptionAlgId *val)
{
    if (!ASN1Dec_AlgorithmIdentifier(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KeyEncryptionAlgId(KeyEncryptionAlgId *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(val);
    }
}

static int ASN1CALL ASN1Enc_ContentInfo(ASN1encoding_t enc, ASN1uint32_t tag, ContentInfo *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->contentType))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1BEREncOpenType(enc, &(val)->content))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ContentInfo(ASN1decoding_t dec, ASN1uint32_t tag, ContentInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->contentType))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	if (t == 0x80000000) {
	    (val)->o[0] |= 0x80;
	    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
		return 0;
	    if (!ASN1BERDecOpenType(dd0, &(val)->content))
		return 0;
	    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
		return 0;
	}
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ContentInfo(ContentInfo *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1open_free(&(val)->content);
	}
    }
}

static int ASN1CALL ASN1Enc_ContentInfoNC(ASN1encoding_t enc, ASN1uint32_t tag, ContentInfoNC *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->contentType))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1BEREncOpenType(enc, &(val)->content))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ContentInfoNC(ASN1decoding_t dec, ASN1uint32_t tag, ContentInfoNC *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->contentType))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	if (t == 0x80000000) {
	    (val)->o[0] |= 0x80;
	    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
		return 0;
	    if (!ASN1BERDecOpenType2(dd0, &(val)->content))
		return 0;
	    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
		return 0;
	}
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ContentInfoNC(ContentInfoNC *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_DigestAlgorithmIdentifiers(ASN1encoding_t enc, ASN1uint32_t tag, DigestAlgorithmIdentifiers *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_DigestAlgorithmIdentifier(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DigestAlgorithmIdentifiers(ASN1decoding_t dec, ASN1uint32_t tag, DigestAlgorithmIdentifiers *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (DigestAlgorithmIdentifier *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_DigestAlgorithmIdentifier(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DigestAlgorithmIdentifiers(DigestAlgorithmIdentifiers *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_DigestAlgorithmIdentifier(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_DigestAlgorithmIdentifier(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_DigestAlgorithmIdentifiersNC(ASN1encoding_t enc, ASN1uint32_t tag, DigestAlgorithmIdentifiersNC *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DigestAlgorithmIdentifiersNC(ASN1decoding_t dec, ASN1uint32_t tag, DigestAlgorithmIdentifiersNC *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (DigestAlgorithmIdentifierNC *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecOpenType2(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DigestAlgorithmIdentifiersNC(DigestAlgorithmIdentifiersNC *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 1; i < (val)->count; i++) {
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_SignerInfos(ASN1encoding_t enc, ASN1uint32_t tag, SignerInfos *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_SignerInfo(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SignerInfos(ASN1decoding_t dec, ASN1uint32_t tag, SignerInfos *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (SignerInfo *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_SignerInfo(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SignerInfos(SignerInfos *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_SignerInfo(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_SignerInfo(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_DigestAlgorithmBlobs(ASN1encoding_t enc, ASN1uint32_t tag, DigestAlgorithmBlobs *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DigestAlgorithmBlobs(ASN1decoding_t dec, ASN1uint32_t tag, DigestAlgorithmBlobs *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (DigestAlgorithmBlob *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecOpenType2(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DigestAlgorithmBlobs(DigestAlgorithmBlobs *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 1; i < (val)->count; i++) {
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_SignerInfosNC(ASN1encoding_t enc, ASN1uint32_t tag, SignerInfosNC *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SignerInfosNC(ASN1decoding_t dec, ASN1uint32_t tag, SignerInfosNC *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (SignerInfosNC_Set *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecOpenType2(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SignerInfosNC(SignerInfosNC *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 1; i < (val)->count; i++) {
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_SignerInfoWithAABlobs(ASN1encoding_t enc, ASN1uint32_t tag, SignerInfoWithAABlobs *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_SignerInfoWithAABlob(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SignerInfoWithAABlobs(ASN1decoding_t dec, ASN1uint32_t tag, SignerInfoWithAABlobs *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (SignerInfoWithAABlob *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_SignerInfoWithAABlob(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SignerInfoWithAABlobs(SignerInfoWithAABlobs *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_SignerInfoWithAABlob(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_SignerInfoWithAABlob(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_SignerInfoWithAABlob(ASN1encoding_t enc, ASN1uint32_t tag, SignerInfoWithAABlob *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->version))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->sid))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->digestAlgorithm))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->authenticatedAttributes))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->digestEncryptionAlgorithm))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->encryptedDigest))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_AttributesNC(enc, 0x80000001, &(val)->dummyUAAs))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SignerInfoWithAABlob(ASN1decoding_t dec, ASN1uint32_t tag, SignerInfoWithAABlob *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecOpenType2(dd, &(val)->version))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->sid))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->digestAlgorithm))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->authenticatedAttributes))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->digestEncryptionAlgorithm))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->encryptedDigest))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_AttributesNC(dd, 0x80000001, &(val)->dummyUAAs))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SignerInfoWithAABlob(SignerInfoWithAABlob *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_AttributesNC(&(val)->dummyUAAs);
	}
    }
}

static int ASN1CALL ASN1Enc_SignerInfoWithAttrBlobs(ASN1encoding_t enc, ASN1uint32_t tag, SignerInfoWithAttrBlobs *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->version))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->sid))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->digestAlgorithm))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_AttributesNC(enc, 0x80000000, &(val)->authAttributes))
	    return 0;
    }
    if (!ASN1Enc_DigestEncryptionAlgIdNC(enc, 0, &(val)->digestEncryptionAlgorithm))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->encryptedDigest))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_AttributesNC(enc, 0x80000001, &(val)->unauthAttributes))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SignerInfoWithAttrBlobs(ASN1decoding_t dec, ASN1uint32_t tag, SignerInfoWithAttrBlobs *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecOpenType2(dd, &(val)->version))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->sid))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->digestAlgorithm))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_AttributesNC(dd, 0x80000000, &(val)->authAttributes))
	    return 0;
    }
    if (!ASN1Dec_DigestEncryptionAlgIdNC(dd, 0, &(val)->digestEncryptionAlgorithm))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->encryptedDigest))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_AttributesNC(dd, 0x80000001, &(val)->unauthAttributes))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SignerInfoWithAttrBlobs(SignerInfoWithAttrBlobs *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_AttributesNC(&(val)->authAttributes);
	}
	ASN1Free_DigestEncryptionAlgIdNC(&(val)->digestEncryptionAlgorithm);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_AttributesNC(&(val)->unauthAttributes);
	}
    }
}

static int ASN1CALL ASN1Enc_SignerInfoWithBlobs(ASN1encoding_t enc, ASN1uint32_t tag, SignerInfoWithBlobs *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->sid))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->digestAlgorithm))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_AttributesNC2(enc, 0x80000000, &(val)->authAttributes))
	    return 0;
    }
    if (!ASN1Enc_DigestEncryptionAlgIdNC(enc, 0, &(val)->digestEncryptionAlgorithm))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->encryptedDigest).length, ((val)->encryptedDigest).value))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_AttributesNC2(enc, 0x80000001, &(val)->unauthAttributes))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SignerInfoWithBlobs(ASN1decoding_t dec, ASN1uint32_t tag, SignerInfoWithBlobs *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->sid))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->digestAlgorithm))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_AttributesNC2(dd, 0x80000000, &(val)->authAttributes))
	    return 0;
    }
    if (!ASN1Dec_DigestEncryptionAlgIdNC(dd, 0, &(val)->digestEncryptionAlgorithm))
	return 0;
    if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->encryptedDigest))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_AttributesNC2(dd, 0x80000001, &(val)->unauthAttributes))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SignerInfoWithBlobs(SignerInfoWithBlobs *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_AttributesNC2(&(val)->authAttributes);
	}
	ASN1Free_DigestEncryptionAlgIdNC(&(val)->digestEncryptionAlgorithm);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_AttributesNC2(&(val)->unauthAttributes);
	}
    }
}

static int ASN1CALL ASN1Enc_RecipientInfos(ASN1encoding_t enc, ASN1uint32_t tag, RecipientInfos *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_RecipientInfo(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RecipientInfos(ASN1decoding_t dec, ASN1uint32_t tag, RecipientInfos *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (RecipientInfo *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_RecipientInfo(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RecipientInfos(RecipientInfos *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_RecipientInfo(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_RecipientInfo(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_EncryptedContentInfo(ASN1encoding_t enc, ASN1uint32_t tag, EncryptedContentInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->contentType))
	return 0;
    if (!ASN1Enc_ContentEncryptionAlgId(enc, 0, &(val)->contentEncryptionAlgorithm))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1DEREncOctetString(enc, 0x80000000, ((val)->encryptedContent).length, ((val)->encryptedContent).value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptedContentInfo(ASN1decoding_t dec, ASN1uint32_t tag, EncryptedContentInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->contentType))
	return 0;
    if (!ASN1Dec_ContentEncryptionAlgId(dd, 0, &(val)->contentEncryptionAlgorithm))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOctetString(dd, 0x80000000, &(val)->encryptedContent))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncryptedContentInfo(EncryptedContentInfo *val)
{
    if (val) {
	ASN1Free_ContentEncryptionAlgId(&(val)->contentEncryptionAlgorithm);
	if ((val)->o[0] & 0x80) {
	    ASN1octetstring_free(&(val)->encryptedContent);
	}
    }
}

static int ASN1CALL ASN1Enc_RecipientInfo(ASN1encoding_t enc, ASN1uint32_t tag, RecipientInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1Enc_IssuerAndSerialNumber(enc, 0, &(val)->issuerAndSerialNumber))
	return 0;
    if (!ASN1Enc_KeyEncryptionAlgId(enc, 0, &(val)->keyEncryptionAlgorithm))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->encryptedKey).length, ((val)->encryptedKey).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RecipientInfo(ASN1decoding_t dec, ASN1uint32_t tag, RecipientInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1Dec_IssuerAndSerialNumber(dd, 0, &(val)->issuerAndSerialNumber))
	return 0;
    if (!ASN1Dec_KeyEncryptionAlgId(dd, 0, &(val)->keyEncryptionAlgorithm))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->encryptedKey))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RecipientInfo(RecipientInfo *val)
{
    if (val) {
	ASN1Free_IssuerAndSerialNumber(&(val)->issuerAndSerialNumber);
	ASN1Free_KeyEncryptionAlgId(&(val)->keyEncryptionAlgorithm);
	ASN1octetstring_free(&(val)->encryptedKey);
    }
}

static int ASN1CALL ASN1Enc_SignedAndEnvelopedData(ASN1encoding_t enc, ASN1uint32_t tag, SignedAndEnvelopedData *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1Enc_RecipientInfos(enc, 0, &(val)->recipientInfos))
	return 0;
    if (!ASN1Enc_DigestAlgorithmIdentifiers(enc, 0, &(val)->digestAlgorithms))
	return 0;
    if (!ASN1Enc_EncryptedContentInfo(enc, 0, &(val)->encryptedContentInfo))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_Certificates(enc, 0x80000000, &(val)->certificates))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_Crls(enc, 0x80000001, &(val)->crls))
	    return 0;
    }
    if (!ASN1Enc_SignerInfos(enc, 0, &(val)->signerInfos))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SignedAndEnvelopedData(ASN1decoding_t dec, ASN1uint32_t tag, SignedAndEnvelopedData *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1Dec_RecipientInfos(dd, 0, &(val)->recipientInfos))
	return 0;
    if (!ASN1Dec_DigestAlgorithmIdentifiers(dd, 0, &(val)->digestAlgorithms))
	return 0;
    if (!ASN1Dec_EncryptedContentInfo(dd, 0, &(val)->encryptedContentInfo))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_Certificates(dd, 0x80000000, &(val)->certificates))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_Crls(dd, 0x80000001, &(val)->crls))
	    return 0;
    }
    if (!ASN1Dec_SignerInfos(dd, 0, &(val)->signerInfos))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SignedAndEnvelopedData(SignedAndEnvelopedData *val)
{
    if (val) {
	ASN1Free_RecipientInfos(&(val)->recipientInfos);
	ASN1Free_DigestAlgorithmIdentifiers(&(val)->digestAlgorithms);
	ASN1Free_EncryptedContentInfo(&(val)->encryptedContentInfo);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_Certificates(&(val)->certificates);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_Crls(&(val)->crls);
	}
	ASN1Free_SignerInfos(&(val)->signerInfos);
    }
}

static int ASN1CALL ASN1Enc_DigestedData(ASN1encoding_t enc, ASN1uint32_t tag, DigestedData *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1Enc_DigestAlgorithmIdentifier(enc, 0, &(val)->digestAlgorithm))
	return 0;
    if (!ASN1Enc_ContentInfo(enc, 0, &(val)->contentInfo))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->digest).length, ((val)->digest).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DigestedData(ASN1decoding_t dec, ASN1uint32_t tag, DigestedData *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1Dec_DigestAlgorithmIdentifier(dd, 0, &(val)->digestAlgorithm))
	return 0;
    if (!ASN1Dec_ContentInfo(dd, 0, &(val)->contentInfo))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->digest))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DigestedData(DigestedData *val)
{
    if (val) {
	ASN1Free_DigestAlgorithmIdentifier(&(val)->digestAlgorithm);
	ASN1Free_ContentInfo(&(val)->contentInfo);
	ASN1octetstring_free(&(val)->digest);
    }
}

static int ASN1CALL ASN1Enc_EncryptedData(ASN1encoding_t enc, ASN1uint32_t tag, EncryptedData *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1Enc_EncryptedContentInfo(enc, 0, &(val)->encryptedContentInfo))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptedData(ASN1decoding_t dec, ASN1uint32_t tag, EncryptedData *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1Dec_EncryptedContentInfo(dd, 0, &(val)->encryptedContentInfo))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncryptedData(EncryptedData *val)
{
    if (val) {
	ASN1Free_EncryptedContentInfo(&(val)->encryptedContentInfo);
    }
}

static int ASN1CALL ASN1Enc_CertIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, CertIdentifier *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_IssuerAndSerialNumber(enc, 0, &(val)->u.issuerAndSerialNumber))
	    return 0;
	break;
    case 2:
	if (!ASN1DEREncOctetString(enc, 0x80000000, ((val)->u.subjectKeyIdentifier).length, ((val)->u.subjectKeyIdentifier).value))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CertIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, CertIdentifier *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x10:
	(val)->choice = 1;
	if (!ASN1Dec_IssuerAndSerialNumber(dec, 0, &(val)->u.issuerAndSerialNumber))
	    return 0;
	break;
    case 0x80000000:
	(val)->choice = 2;
	if (!ASN1BERDecOctetString(dec, 0x80000000, &(val)->u.subjectKeyIdentifier))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CertIdentifier(CertIdentifier *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_IssuerAndSerialNumber(&(val)->u.issuerAndSerialNumber);
	    break;
	case 2:
	    ASN1octetstring_free(&(val)->u.subjectKeyIdentifier);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_OriginatorInfo(ASN1encoding_t enc, ASN1uint32_t tag, OriginatorInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_Certificates(enc, 0x80000000, &(val)->certificates))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_Crls(enc, 0x80000001, &(val)->crls))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OriginatorInfo(ASN1decoding_t dec, ASN1uint32_t tag, OriginatorInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_Certificates(dd, 0x80000000, &(val)->certificates))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_Crls(dd, 0x80000001, &(val)->crls))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_OriginatorInfo(OriginatorInfo *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_Certificates(&(val)->certificates);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_Crls(&(val)->crls);
	}
    }
}

static int ASN1CALL ASN1Enc_OriginatorInfoNC(ASN1encoding_t enc, ASN1uint32_t tag, OriginatorInfoNC *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_CertificatesNC(enc, 0x80000000, &(val)->certificates))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_CrlsNC(enc, 0x80000001, &(val)->crls))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OriginatorInfoNC(ASN1decoding_t dec, ASN1uint32_t tag, OriginatorInfoNC *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_CertificatesNC(dd, 0x80000000, &(val)->certificates))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_CrlsNC(dd, 0x80000001, &(val)->crls))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_OriginatorInfoNC(OriginatorInfoNC *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_CertificatesNC(&(val)->certificates);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_CrlsNC(&(val)->crls);
	}
    }
}

static int ASN1CALL ASN1Enc_CmsRecipientInfos(ASN1encoding_t enc, ASN1uint32_t tag, CmsRecipientInfos *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_CmsRecipientInfo(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CmsRecipientInfos(ASN1decoding_t dec, ASN1uint32_t tag, CmsRecipientInfos *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (CmsRecipientInfo *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_CmsRecipientInfo(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CmsRecipientInfos(CmsRecipientInfos *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_CmsRecipientInfo(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_CmsRecipientInfo(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_KeyTransRecipientInfo(ASN1encoding_t enc, ASN1uint32_t tag, KeyTransRecipientInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1Enc_CertIdentifier(enc, 0, &(val)->rid))
	return 0;
    if (!ASN1Enc_KeyEncryptionAlgId(enc, 0, &(val)->keyEncryptionAlgorithm))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->encryptedKey).length, ((val)->encryptedKey).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KeyTransRecipientInfo(ASN1decoding_t dec, ASN1uint32_t tag, KeyTransRecipientInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1Dec_CertIdentifier(dd, 0, &(val)->rid))
	return 0;
    if (!ASN1Dec_KeyEncryptionAlgId(dd, 0, &(val)->keyEncryptionAlgorithm))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->encryptedKey))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KeyTransRecipientInfo(KeyTransRecipientInfo *val)
{
    if (val) {
	ASN1Free_CertIdentifier(&(val)->rid);
	ASN1Free_KeyEncryptionAlgId(&(val)->keyEncryptionAlgorithm);
	ASN1octetstring_free(&(val)->encryptedKey);
    }
}

static int ASN1CALL ASN1Enc_OriginatorPublicKey(ASN1encoding_t enc, ASN1uint32_t tag, OriginatorPublicKey *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_AlgorithmIdentifier(enc, 0, &(val)->algorithm))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->publicKey).length, ((val)->publicKey).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OriginatorPublicKey(ASN1decoding_t dec, ASN1uint32_t tag, OriginatorPublicKey *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_AlgorithmIdentifier(dd, 0, &(val)->algorithm))
	return 0;
    if (!ASN1BERDecBitString(dd, 0x3, &(val)->publicKey))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_OriginatorPublicKey(OriginatorPublicKey *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(&(val)->algorithm);
	ASN1bitstring_free(&(val)->publicKey);
    }
}

static int ASN1CALL ASN1Enc_RecipientEncryptedKeys(ASN1encoding_t enc, ASN1uint32_t tag, RecipientEncryptedKeys *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_RecipientEncryptedKey(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RecipientEncryptedKeys(ASN1decoding_t dec, ASN1uint32_t tag, RecipientEncryptedKeys *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (RecipientEncryptedKey *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_RecipientEncryptedKey(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RecipientEncryptedKeys(RecipientEncryptedKeys *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_RecipientEncryptedKey(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_RecipientEncryptedKey(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_OtherKeyAttribute(ASN1encoding_t enc, ASN1uint32_t tag, OtherKeyAttribute *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->keyAttrId))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncOpenType(enc, &(val)->keyAttr))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OtherKeyAttribute(ASN1decoding_t dec, ASN1uint32_t tag, OtherKeyAttribute *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->keyAttrId))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOpenType(dd, &(val)->keyAttr))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_OtherKeyAttribute(OtherKeyAttribute *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1open_free(&(val)->keyAttr);
	}
    }
}

static int ASN1CALL ASN1Enc_MailListKeyIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, MailListKeyIdentifier *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->kekIdentifier).length, ((val)->kekIdentifier).value))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->date))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_OtherKeyAttribute(enc, 0, &(val)->other))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MailListKeyIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, MailListKeyIdentifier *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->kekIdentifier))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x18) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecGeneralizedTime(dd, 0x18, &(val)->date))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_OtherKeyAttribute(dd, 0, &(val)->other))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MailListKeyIdentifier(MailListKeyIdentifier *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->kekIdentifier);
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_OtherKeyAttribute(&(val)->other);
	}
    }
}

static int ASN1CALL ASN1Enc_DigestInfo(ASN1encoding_t enc, ASN1uint32_t tag, DigestInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_DigestAlgorithmIdentifier(enc, 0, &(val)->digestAlgorithm))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->digest).length, ((val)->digest).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DigestInfo(ASN1decoding_t dec, ASN1uint32_t tag, DigestInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_DigestAlgorithmIdentifier(dd, 0, &(val)->digestAlgorithm))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->digest))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DigestInfo(DigestInfo *val)
{
    if (val) {
	ASN1Free_DigestAlgorithmIdentifier(&(val)->digestAlgorithm);
	ASN1octetstring_free(&(val)->digest);
    }
}

static int ASN1CALL ASN1Enc_SignedData(ASN1encoding_t enc, ASN1uint32_t tag, SignedData *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1Enc_DigestAlgorithmIdentifiers(enc, 0, &(val)->digestAlgorithms))
	return 0;
    if (!ASN1Enc_ContentInfo(enc, 0, &(val)->contentInfo))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_Certificates(enc, 0x80000000, &(val)->certificates))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_Crls(enc, 0x80000001, &(val)->crls))
	    return 0;
    }
    if (!ASN1Enc_SignerInfos(enc, 0, &(val)->signerInfos))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SignedData(ASN1decoding_t dec, ASN1uint32_t tag, SignedData *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1Dec_DigestAlgorithmIdentifiers(dd, 0, &(val)->digestAlgorithms))
	return 0;
    if (!ASN1Dec_ContentInfo(dd, 0, &(val)->contentInfo))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_Certificates(dd, 0x80000000, &(val)->certificates))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_Crls(dd, 0x80000001, &(val)->crls))
	    return 0;
    }
    if (!ASN1Dec_SignerInfos(dd, 0, &(val)->signerInfos))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SignedData(SignedData *val)
{
    if (val) {
	ASN1Free_DigestAlgorithmIdentifiers(&(val)->digestAlgorithms);
	ASN1Free_ContentInfo(&(val)->contentInfo);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_Certificates(&(val)->certificates);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_Crls(&(val)->crls);
	}
	ASN1Free_SignerInfos(&(val)->signerInfos);
    }
}

static int ASN1CALL ASN1Enc_SignerInfo(ASN1encoding_t enc, ASN1uint32_t tag, SignerInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1Enc_CertIdentifier(enc, 0, &(val)->sid))
	return 0;
    if (!ASN1Enc_DigestAlgorithmIdentifier(enc, 0, &(val)->digestAlgorithm))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_Attributes(enc, 0x80000000, &(val)->authenticatedAttributes))
	    return 0;
    }
    if (!ASN1Enc_DigestEncryptionAlgId(enc, 0, &(val)->digestEncryptionAlgorithm))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->encryptedDigest).length, ((val)->encryptedDigest).value))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_Attributes(enc, 0x80000001, &(val)->unauthAttributes))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SignerInfo(ASN1decoding_t dec, ASN1uint32_t tag, SignerInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1Dec_CertIdentifier(dd, 0, &(val)->sid))
	return 0;
    if (!ASN1Dec_DigestAlgorithmIdentifier(dd, 0, &(val)->digestAlgorithm))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_Attributes(dd, 0x80000000, &(val)->authenticatedAttributes))
	    return 0;
    }
    if (!ASN1Dec_DigestEncryptionAlgId(dd, 0, &(val)->digestEncryptionAlgorithm))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->encryptedDigest))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_Attributes(dd, 0x80000001, &(val)->unauthAttributes))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SignerInfo(SignerInfo *val)
{
    if (val) {
	ASN1Free_CertIdentifier(&(val)->sid);
	ASN1Free_DigestAlgorithmIdentifier(&(val)->digestAlgorithm);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_Attributes(&(val)->authenticatedAttributes);
	}
	ASN1Free_DigestEncryptionAlgId(&(val)->digestEncryptionAlgorithm);
	ASN1octetstring_free(&(val)->encryptedDigest);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_Attributes(&(val)->unauthAttributes);
	}
    }
}

static int ASN1CALL ASN1Enc_SignedDataWithBlobs(ASN1encoding_t enc, ASN1uint32_t tag, SignedDataWithBlobs *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1Enc_DigestAlgorithmIdentifiersNC(enc, 0, &(val)->digestAlgorithms))
	return 0;
    if (!ASN1Enc_ContentInfoNC(enc, 0, &(val)->contentInfo))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_CertificatesNC(enc, 0x80000000, &(val)->certificates))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_CrlsNC(enc, 0x80000001, &(val)->crls))
	    return 0;
    }
    if (!ASN1Enc_SignerInfosNC(enc, 0, &(val)->signerInfos))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SignedDataWithBlobs(ASN1decoding_t dec, ASN1uint32_t tag, SignedDataWithBlobs *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1Dec_DigestAlgorithmIdentifiersNC(dd, 0, &(val)->digestAlgorithms))
	return 0;
    if (!ASN1Dec_ContentInfoNC(dd, 0, &(val)->contentInfo))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_CertificatesNC(dd, 0x80000000, &(val)->certificates))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_CrlsNC(dd, 0x80000001, &(val)->crls))
	    return 0;
    }
    if (!ASN1Dec_SignerInfosNC(dd, 0, &(val)->signerInfos))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SignedDataWithBlobs(SignedDataWithBlobs *val)
{
    if (val) {
	ASN1Free_DigestAlgorithmIdentifiersNC(&(val)->digestAlgorithms);
	ASN1Free_ContentInfoNC(&(val)->contentInfo);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_CertificatesNC(&(val)->certificates);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_CrlsNC(&(val)->crls);
	}
	ASN1Free_SignerInfosNC(&(val)->signerInfos);
    }
}

static int ASN1CALL ASN1Enc_EnvelopedData(ASN1encoding_t enc, ASN1uint32_t tag, EnvelopedData *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1Enc_RecipientInfos(enc, 0, &(val)->recipientInfos))
	return 0;
    if (!ASN1Enc_EncryptedContentInfo(enc, 0, &(val)->encryptedContentInfo))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EnvelopedData(ASN1decoding_t dec, ASN1uint32_t tag, EnvelopedData *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1Dec_RecipientInfos(dd, 0, &(val)->recipientInfos))
	return 0;
    if (!ASN1Dec_EncryptedContentInfo(dd, 0, &(val)->encryptedContentInfo))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EnvelopedData(EnvelopedData *val)
{
    if (val) {
	ASN1Free_RecipientInfos(&(val)->recipientInfos);
	ASN1Free_EncryptedContentInfo(&(val)->encryptedContentInfo);
    }
}

static int ASN1CALL ASN1Enc_CmsEnvelopedData(ASN1encoding_t enc, ASN1uint32_t tag, CmsEnvelopedData *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_OriginatorInfo(enc, 0x80000000, &(val)->originatorInfo))
	    return 0;
    }
    if (!ASN1Enc_CmsRecipientInfos(enc, 0, &(val)->recipientInfos))
	return 0;
    if (!ASN1Enc_EncryptedContentInfo(enc, 0, &(val)->encryptedContentInfo))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_Attributes(enc, 0x80000001, &(val)->unprotectedAttrs))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CmsEnvelopedData(ASN1decoding_t dec, ASN1uint32_t tag, CmsEnvelopedData *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_OriginatorInfo(dd, 0x80000000, &(val)->originatorInfo))
	    return 0;
    }
    if (!ASN1Dec_CmsRecipientInfos(dd, 0, &(val)->recipientInfos))
	return 0;
    if (!ASN1Dec_EncryptedContentInfo(dd, 0, &(val)->encryptedContentInfo))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_Attributes(dd, 0x80000001, &(val)->unprotectedAttrs))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CmsEnvelopedData(CmsEnvelopedData *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_OriginatorInfo(&(val)->originatorInfo);
	}
	ASN1Free_CmsRecipientInfos(&(val)->recipientInfos);
	ASN1Free_EncryptedContentInfo(&(val)->encryptedContentInfo);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_Attributes(&(val)->unprotectedAttrs);
	}
    }
}

static int ASN1CALL ASN1Enc_OriginatorIdentifierOrKey(ASN1encoding_t enc, ASN1uint32_t tag, OriginatorIdentifierOrKey *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_IssuerAndSerialNumber(enc, 0, &(val)->u.issuerAndSerialNumber))
	    return 0;
	break;
    case 2:
	if (!ASN1DEREncOctetString(enc, 0x80000000, ((val)->u.subjectKeyIdentifier).length, ((val)->u.subjectKeyIdentifier).value))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_OriginatorPublicKey(enc, 0x80000001, &(val)->u.originatorKey))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OriginatorIdentifierOrKey(ASN1decoding_t dec, ASN1uint32_t tag, OriginatorIdentifierOrKey *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x10:
	(val)->choice = 1;
	if (!ASN1Dec_IssuerAndSerialNumber(dec, 0, &(val)->u.issuerAndSerialNumber))
	    return 0;
	break;
    case 0x80000000:
	(val)->choice = 2;
	if (!ASN1BERDecOctetString(dec, 0x80000000, &(val)->u.subjectKeyIdentifier))
	    return 0;
	break;
    case 0x80000001:
	(val)->choice = 3;
	if (!ASN1Dec_OriginatorPublicKey(dec, 0x80000001, &(val)->u.originatorKey))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_OriginatorIdentifierOrKey(OriginatorIdentifierOrKey *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_IssuerAndSerialNumber(&(val)->u.issuerAndSerialNumber);
	    break;
	case 2:
	    ASN1octetstring_free(&(val)->u.subjectKeyIdentifier);
	    break;
	case 3:
	    ASN1Free_OriginatorPublicKey(&(val)->u.originatorKey);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_RecipientKeyIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, RecipientKeyIdentifier *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->subjectKeyIdentifier).length, ((val)->subjectKeyIdentifier).value))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->date))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_OtherKeyAttribute(enc, 0, &(val)->other))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RecipientKeyIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, RecipientKeyIdentifier *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->subjectKeyIdentifier))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x18) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecGeneralizedTime(dd, 0x18, &(val)->date))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_OtherKeyAttribute(dd, 0, &(val)->other))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RecipientKeyIdentifier(RecipientKeyIdentifier *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->subjectKeyIdentifier);
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_OtherKeyAttribute(&(val)->other);
	}
    }
}

static int ASN1CALL ASN1Enc_MailListRecipientInfo(ASN1encoding_t enc, ASN1uint32_t tag, MailListRecipientInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1Enc_MailListKeyIdentifier(enc, 0, &(val)->mlid))
	return 0;
    if (!ASN1Enc_KeyEncryptionAlgId(enc, 0, &(val)->keyEncryptionAlgorithm))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->encryptedKey).length, ((val)->encryptedKey).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MailListRecipientInfo(ASN1decoding_t dec, ASN1uint32_t tag, MailListRecipientInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1Dec_MailListKeyIdentifier(dd, 0, &(val)->mlid))
	return 0;
    if (!ASN1Dec_KeyEncryptionAlgId(dd, 0, &(val)->keyEncryptionAlgorithm))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->encryptedKey))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MailListRecipientInfo(MailListRecipientInfo *val)
{
    if (val) {
	ASN1Free_MailListKeyIdentifier(&(val)->mlid);
	ASN1Free_KeyEncryptionAlgId(&(val)->keyEncryptionAlgorithm);
	ASN1octetstring_free(&(val)->encryptedKey);
    }
}

static int ASN1CALL ASN1Enc_KeyAgreeRecipientInfo(ASN1encoding_t enc, ASN1uint32_t tag, KeyAgreeRecipientInfo *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_OriginatorIdentifierOrKey(enc, 0, &(val)->originator))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->ukm).length, ((val)->ukm).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1Enc_KeyEncryptionAlgId(enc, 0, &(val)->keyEncryptionAlgorithm))
	return 0;
    if (!ASN1Enc_RecipientEncryptedKeys(enc, 0, &(val)->recipientEncryptedKeys))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KeyAgreeRecipientInfo(ASN1decoding_t dec, ASN1uint32_t tag, KeyAgreeRecipientInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_OriginatorIdentifierOrKey(dd0, 0, &(val)->originator))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->ukm))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1Dec_KeyEncryptionAlgId(dd, 0, &(val)->keyEncryptionAlgorithm))
	return 0;
    if (!ASN1Dec_RecipientEncryptedKeys(dd, 0, &(val)->recipientEncryptedKeys))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KeyAgreeRecipientInfo(KeyAgreeRecipientInfo *val)
{
    if (val) {
	ASN1Free_OriginatorIdentifierOrKey(&(val)->originator);
	if ((val)->o[0] & 0x80) {
	    ASN1octetstring_free(&(val)->ukm);
	}
	ASN1Free_KeyEncryptionAlgId(&(val)->keyEncryptionAlgorithm);
	ASN1Free_RecipientEncryptedKeys(&(val)->recipientEncryptedKeys);
    }
}

static int ASN1CALL ASN1Enc_RecipientIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, RecipientIdentifier *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_IssuerAndSerialNumber(enc, 0, &(val)->u.issuerAndSerialNumber))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_RecipientKeyIdentifier(enc, 0x80000000, &(val)->u.rKeyId))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RecipientIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, RecipientIdentifier *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x10:
	(val)->choice = 1;
	if (!ASN1Dec_IssuerAndSerialNumber(dec, 0, &(val)->u.issuerAndSerialNumber))
	    return 0;
	break;
    case 0x80000000:
	(val)->choice = 2;
	if (!ASN1Dec_RecipientKeyIdentifier(dec, 0x80000000, &(val)->u.rKeyId))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RecipientIdentifier(RecipientIdentifier *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_IssuerAndSerialNumber(&(val)->u.issuerAndSerialNumber);
	    break;
	case 2:
	    ASN1Free_RecipientKeyIdentifier(&(val)->u.rKeyId);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_CmsRecipientInfo(ASN1encoding_t enc, ASN1uint32_t tag, CmsRecipientInfo *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_KeyTransRecipientInfo(enc, 0, &(val)->u.keyTransRecipientInfo))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_KeyAgreeRecipientInfo(enc, 0x80000001, &(val)->u.keyAgreeRecipientInfo))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_MailListRecipientInfo(enc, 0x80000002, &(val)->u.mailListRecipientInfo))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CmsRecipientInfo(ASN1decoding_t dec, ASN1uint32_t tag, CmsRecipientInfo *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x10:
	(val)->choice = 1;
	if (!ASN1Dec_KeyTransRecipientInfo(dec, 0, &(val)->u.keyTransRecipientInfo))
	    return 0;
	break;
    case 0x80000001:
	(val)->choice = 2;
	if (!ASN1Dec_KeyAgreeRecipientInfo(dec, 0x80000001, &(val)->u.keyAgreeRecipientInfo))
	    return 0;
	break;
    case 0x80000002:
	(val)->choice = 3;
	if (!ASN1Dec_MailListRecipientInfo(dec, 0x80000002, &(val)->u.mailListRecipientInfo))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CmsRecipientInfo(CmsRecipientInfo *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_KeyTransRecipientInfo(&(val)->u.keyTransRecipientInfo);
	    break;
	case 2:
	    ASN1Free_KeyAgreeRecipientInfo(&(val)->u.keyAgreeRecipientInfo);
	    break;
	case 3:
	    ASN1Free_MailListRecipientInfo(&(val)->u.mailListRecipientInfo);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_RecipientEncryptedKey(ASN1encoding_t enc, ASN1uint32_t tag, RecipientEncryptedKey *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_RecipientIdentifier(enc, 0, &(val)->rid))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->encryptedKey).length, ((val)->encryptedKey).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RecipientEncryptedKey(ASN1decoding_t dec, ASN1uint32_t tag, RecipientEncryptedKey *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_RecipientIdentifier(dd, 0, &(val)->rid))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->encryptedKey))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RecipientEncryptedKey(RecipientEncryptedKey *val)
{
    if (val) {
	ASN1Free_RecipientIdentifier(&(val)->rid);
	ASN1octetstring_free(&(val)->encryptedKey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\wincrmsg\msglen.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       msglen.cpp
//
//  Contents:   Cryptographic Message Length APIs
//
//  APIs:       CryptMsgCalculateEncodedLength
//
//  History:    12-Dec-96   kevinr    created
//
//--------------------------------------------------------------------------

#include "global.hxx"


//+-------------------------------------------------------------------------
//  Calculate the length of the OBJECT IDENTIFIER encoded blob.
//  We do this by doing the encode using OSS and throwing away the result.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthObjId(
    IN LPSTR   pszObjId)
{
    DWORD           cbSize;
    DWORD           cb;
    ASN1encodedOID_t eoid;       ZEROSTRUCT(eoid); 
    ASN1encoding_t  pEnc = ICM_GetEncoder();

    if (0 == PkiAsn1DotValToEncodedOid(pEnc, pszObjId, &eoid))
        goto DotValToEncodedOidError;

    ICM_GetLengthOctets( eoid.length, NULL, &cb);
    cbSize = 1 + cb + eoid.length;                  // OBJECT IDENTIFIER

    PkiAsn1FreeEncodedOid(pEnc, &eoid);

CommonReturn:
    return cbSize;
ErrorReturn:
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
SET_ERROR(DotValToEncodedOidError,CRYPT_E_OID_FORMAT)
}


//+-------------------------------------------------------------------------
//  Calculate the length of the AlgorithmIdentifier encoded blob.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthAlgorithmIdentifier(
    IN PCRYPT_ALGORITHM_IDENTIFIER pai,
    IN BOOL fNoNullParameters = FALSE
    )
{
    DWORD           cbSize;
    DWORD           cb;

    if (INVALID_ENCODING_SIZE == (cbSize  = ICM_LengthObjId( pai->pszObjId)))
        goto CommonReturn;
    if (!fNoNullParameters)
        cbSize += max( 2, pai->Parameters.cbData);
    ICM_GetLengthOctets( cbSize, NULL, &cb);
    cbSize += cb + 1;                       // AlgorithmIdentifier seq

CommonReturn:
    return cbSize;
}


//+-------------------------------------------------------------------------
//  Calculate the length of the ContentInfo encoded blob.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthContentInfo(
    IN DWORD            dwFlags,
    IN OPTIONAL LPSTR   pszContentType,
    IN DWORD            cbData,
    OUT OPTIONAL PDWORD pcbContent)
{
    DWORD           cbSize;
    DWORD           cbTmp;
    DWORD           cb;

    if (INVALID_ENCODING_SIZE == (cbSize = ICM_LengthObjId(
                pszContentType ? pszContentType : pszObjIdDataType)))
        goto LengthContentTypeError;

    if (0 == (dwFlags & CMSG_DETACHED_FLAG)) {
        cbTmp = cbData;
        ICM_GetLengthOctets( cbTmp, NULL, &cb);

        if (NULL == pszContentType
#ifdef CMS_PKCS7
                || ((dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG) &&
                        !ICM_IsData(pszContentType))
#endif  // CMS_PKCS7
                ) {
            // data, not already encoded
            // Gets its own OCTET STRING wrapper.
            cbTmp += 1 + cb;            // OCTET STRING
            ICM_GetLengthOctets( cbTmp, NULL, &cb);
        }
        cbSize += 1 + cb + cbTmp;       // [0] EXPLICIT
    }

    if (pcbContent)
        *pcbContent = cbSize;

    ICM_GetLengthOctets( cbSize, NULL, &cb);
    cbSize += 1 + cb;                   // ContentInfo seq

CommonReturn:
    return cbSize;
ErrorReturn:
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
TRACE_ERROR(LengthContentTypeError)     // error already set
}


//+-------------------------------------------------------------------------
//  Calculate the length of the EncryptedContentInfo encoded blob.
//
//  The return length assumes the encrypted content is
//  encapsulated.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthEncryptedContentInfo(
    IN HCRYPTKEY                    hEncryptKey,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiContentEncryption,
    IN OPTIONAL LPSTR               pszContentTypeOrg,
    IN DWORD                        cbData)
{
    DWORD       cbSize;
    DWORD       cb;
    DWORD       cbBlockSize;
    BOOL        fBlockCipher;
    DWORD       cbCipher;
    LPSTR       pszContentType = pszContentTypeOrg ? pszContentTypeOrg :
                                                     pszObjIdDataType;

    if (INVALID_ENCODING_SIZE == (cbSize = ICM_LengthObjId( pszContentType)))
        goto LengthContentTypeError;
    if (INVALID_ENCODING_SIZE == (cb = ICM_LengthAlgorithmIdentifier( paiContentEncryption)))
        goto LengthAlgorithmIdentifierError;
    cbSize += cb;

    cbCipher = cbData;
    if (0 < cbCipher) {
        if (!ICM_GetKeyBlockSize(
                hEncryptKey,
                &cbBlockSize,
                &fBlockCipher))
            goto GetEncryptBlockSizeError;

        if (fBlockCipher) {
            cbCipher += cbBlockSize;
            cbCipher -= cbCipher % cbBlockSize;
        }
    }

    ICM_GetLengthOctets( cbCipher, NULL, &cb);  // encryptedContent
    cbSize += 1 + cb + cbCipher;                // [0] IMPLICIT

    ICM_GetLengthOctets( cbSize, NULL, &cb);
    cbSize += 1 + cb;                           // EncryptedContentInfo seq

CommonReturn:
    return cbSize;
ErrorReturn:
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
TRACE_ERROR(LengthContentTypeError)
TRACE_ERROR(LengthAlgorithmIdentifierError)
TRACE_ERROR(GetEncryptBlockSizeError)
}


#ifndef CMS_PKCS7
//+-------------------------------------------------------------------------
//  Calculate the length of the IssuerAndSerialNumber encoded blob.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthIssuerAndSerialNumber(
    IN PCERT_INFO   pCertInfo)
{
    DWORD           cbSize;
    DWORD           cb;

    cbSize = pCertInfo->SerialNumber.cbData;
    ICM_GetLengthOctets( cbSize, NULL, &cb);
    cbSize += cb + 1;                       // SerialNumber INTEGER
    cbSize += pCertInfo->Issuer.cbData;     // Issuer already encoded
    ICM_GetLengthOctets( cbSize, NULL, &cb);
    cbSize += cb + 1;                       // IssuerAndSerialNumber seq

    return cbSize;
}
#endif  // CMS_PKCS7

//+-------------------------------------------------------------------------
//  Calculate the length of the CertId encoded blob.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthCertId(
    IN PCERT_ID     pCertId)
{
    DWORD           cbSize;
    DWORD           cb;

    switch (pCertId->dwIdChoice) {
        case CERT_ID_ISSUER_SERIAL_NUMBER:
            cbSize = pCertId->IssuerSerialNumber.SerialNumber.cbData;
            ICM_GetLengthOctets( cbSize, NULL, &cb);
            cbSize += cb + 1;                   // SerialNumber INTEGER
            cbSize += pCertId->IssuerSerialNumber.Issuer.cbData; // Issuer ANY
            ICM_GetLengthOctets( cbSize, NULL, &cb);
            cbSize += cb + 1;                   // IssuerSerialNumber seq
            break;
        case CERT_ID_KEY_IDENTIFIER:
            cbSize = pCertId->KeyId.cbData;
            ICM_GetLengthOctets( cbSize, NULL, &cb);
            cbSize += cb + 1;                   // KeyId OCTET STRING
            break;
        default:
            goto InvalidCertIdChoice;
    };

CommonReturn:
    return cbSize;
ErrorReturn:
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
SET_ERROR(InvalidCertIdChoice, E_INVALIDARG)
}


//+-------------------------------------------------------------------------
//  Calculate the length of the EncryptedDigest encoded blob plus the
//  algorithm identifier
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthEncryptedDigestAndAlgorithm(
    IN HCRYPTPROV                   hCryptProv,
    IN DWORD                        dwKeySpec,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiDigest,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiDigestEncrypt)
{
    DWORD       dwError = ERROR_SUCCESS;
    DWORD       cbSignature;
    DWORD       cbSize = 0;
    DWORD       cb;
    HCRYPTHASH  hHash = NULL;
    PCCRYPT_OID_INFO pOIDInfo;
    DWORD       dwAlgIdDigest;
    DWORD       dwAlgIdPubKey;
    DWORD       dwAlgIdFlags;
    CRYPT_ALGORITHM_IDENTIFIER aiDigestEncrypt;
    BOOL        fNoNullParameters;

    dwAlgIdPubKey = 0;
    dwAlgIdFlags = 0;
    if (pOIDInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            paiDigestEncrypt->pszObjId,
            CRYPT_PUBKEY_ALG_OID_GROUP_ID)) {
        dwAlgIdPubKey = pOIDInfo->Algid;
        if (1 <= pOIDInfo->ExtraInfo.cbData / sizeof(DWORD)) {
            DWORD *pdwExtra = (DWORD *) pOIDInfo->ExtraInfo.pbData;
            dwAlgIdFlags = pdwExtra[0];
        }

        // Check if more than just the NULL parameters
        if (2 < paiDigestEncrypt->Parameters.cbData) {
            // Check if we should use the public key parameters
            if (0 == (dwAlgIdFlags &
                    CRYPT_OID_USE_PUBKEY_PARA_FOR_PKCS7_FLAG)) {
                memset(&aiDigestEncrypt, 0, sizeof(aiDigestEncrypt));
                aiDigestEncrypt.pszObjId = paiDigestEncrypt->pszObjId;
                paiDigestEncrypt = &aiDigestEncrypt;
            }
        }
    } else if (pOIDInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            paiDigestEncrypt->pszObjId,
            CRYPT_SIGN_ALG_OID_GROUP_ID)) {
        DWORD *pdwExtra = (DWORD *) pOIDInfo->ExtraInfo.pbData;

        if (1 <= pOIDInfo->ExtraInfo.cbData / sizeof(DWORD))
            dwAlgIdPubKey = pdwExtra[0];
        if (2 <= pOIDInfo->ExtraInfo.cbData / sizeof(DWORD))
            dwAlgIdFlags = pdwExtra[1];
    }


    if (CALG_DSS_SIGN == dwAlgIdPubKey &&
            0 == (dwAlgIdFlags & CRYPT_OID_INHIBIT_SIGNATURE_FORMAT_FLAG))
        cbSignature = CERT_MAX_ASN_ENCODED_DSS_SIGNATURE_LEN;
    else {
        if (dwKeySpec == 0)
            dwKeySpec = AT_SIGNATURE;

        if (!(ICM_GetCAPI(
                CRYPT_HASH_ALG_OID_GROUP_ID,
                paiDigest,
                &dwAlgIdDigest) ||
              ICM_GetCAPI(
                CRYPT_SIGN_ALG_OID_GROUP_ID,
                paiDigest,
                &dwAlgIdDigest)))
            goto DigestGetCAPIError;
        if (!CryptCreateHash(
                hCryptProv,
                dwAlgIdDigest,
                NULL,               // hKey - optional for MAC
                0,                  // dwFlags
                &hHash))
            goto CreateHashError;
        if (!CryptHashData(
                hHash,
                (PBYTE)&cb,
                sizeof(DWORD),
                0))                 // dwFlags
            goto HashDataError;
        if (!CryptSignHash(
                hHash,
                dwKeySpec,
                NULL,               // description
                0,                  // dwFlags
                NULL,               // pb
                &cbSignature))
            goto SignHashSizeError;
    }
    ICM_GetLengthOctets( cbSignature, NULL, &cb);
    cbSize += cbSignature + cb + 1;                       // OCTET STRING

    if (0 == paiDigestEncrypt->Parameters.cbData &&
            0 != (dwAlgIdFlags & CRYPT_OID_NO_NULL_ALGORITHM_PARA_FLAG))
        fNoNullParameters = TRUE;
        // NO NULL parameters
    else
        fNoNullParameters = FALSE;

    if (INVALID_ENCODING_SIZE == (cb = ICM_LengthAlgorithmIdentifier(
            paiDigestEncrypt, fNoNullParameters)))
        goto SubjectPublicKeyInfoAlgorithmError;
    cbSize += cb;

CommonReturn:
    if (hHash)
        CryptDestroyHash(hHash);
    ICM_SetLastError(dwError);
    return cbSize;

ErrorReturn:
    dwError = GetLastError();
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
SET_ERROR(DigestGetCAPIError,CRYPT_E_UNKNOWN_ALGO)
TRACE_ERROR(SubjectPublicKeyInfoAlgorithmError)
TRACE_ERROR(CreateHashError)
TRACE_ERROR(HashDataError)
TRACE_ERROR(SignHashSizeError)
}


//+-------------------------------------------------------------------------
//  Calculate the length of the Digest encoded blob.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthDigest(
    IN HCRYPTPROV                   hCryptProv,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiDigest)
{
    DWORD       dwError = ERROR_SUCCESS;
    DWORD       cbSize;
    DWORD       cb;
    DWORD       dwAlgIdDigest;
    HCRYPTHASH  hHash = NULL;

    if (0 == hCryptProv) {
        if (0 == (hCryptProv = I_CryptGetDefaultCryptProv(0)))
            goto GetDefaultCryptProvError;
    }

    if (!ICM_GetCAPI(
            CRYPT_HASH_ALG_OID_GROUP_ID,
            paiDigest,
            &dwAlgIdDigest))
        goto DigestGetCAPIError;
    if (!CryptCreateHash(
            hCryptProv,
            dwAlgIdDigest,
            NULL,               // hKey - optional for MAC
            0,                  // dwFlags
            &hHash))
        goto CreateHashError;
    if (!CryptHashData(
            hHash,
            (PBYTE)&cb,
            sizeof(DWORD),
            0))                 // dwFlags
        goto HashDataError;
    if (!CryptGetHashParam(
            hHash,
            HP_HASHVAL,
            NULL,               // pbHash
            &cbSize,
            0))                 // dwFlags
        goto GetHashParamSizeError;
    ICM_GetLengthOctets( cbSize, NULL, &cb);
    cbSize += cb + 1;                       // OCTET STRING

CommonReturn:
    if (hHash)
        CryptDestroyHash(hHash);
    ICM_SetLastError(dwError);
    return cbSize;

ErrorReturn:
    dwError = GetLastError();
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
TRACE_ERROR(GetDefaultCryptProvError)
SET_ERROR(DigestGetCAPIError,CRYPT_E_UNKNOWN_ALGO)
TRACE_ERROR(CreateHashError)
TRACE_ERROR(HashDataError)
TRACE_ERROR(GetHashParamSizeError)
}


//+-------------------------------------------------------------------------
//  Calculate the length of the Attributes encoded blob.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthAttributes(
    IN HCRYPTPROV                   hCryptProv,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiDigest,
    IN DWORD                        cAttr,
    IN PCRYPT_ATTRIBUTE             rgAttr,
    IN LPSTR                        pszInnerContentObjID,
    IN BOOL                         fAuthAttr)
{
    DWORD               cbSize = 0;
    DWORD               cbAttrS;
    DWORD               cbAttr;
    DWORD               cbTmp;
    DWORD               cb;
    PCRYPT_ATTRIBUTE    patr;
    PCRYPT_ATTR_BLOB    pblobAttr;
    DWORD               i;
    DWORD               j;
    BOOL                fDataType = !pszInnerContentObjID ||
                                    (0 == strcmp( pszInnerContentObjID, pszObjIdDataType));

    for (i=cAttr, patr=rgAttr, cbAttrS=0;
            i>0;
            i--, patr++) {
        if (0 == (cbAttr = ICM_LengthObjId( patr->pszObjId)))
            goto PatrLengthObjIdError;
        for (j=patr->cValue, pblobAttr=patr->rgValue, cbTmp=0;
                j>0;
                j--, pblobAttr++)
            cbTmp += pblobAttr->cbData;
        ICM_GetLengthOctets( cbTmp, NULL, &cb);
        cbAttr += cbTmp + cb + 1;       // AttributeSetValue set
        ICM_GetLengthOctets( cbAttr, NULL, &cb);
        cbAttrS += cbAttr + cb + 1;     // Attribute seq
    }

    if (fAuthAttr && (cAttr || !fDataType)) {
        // content type
        cbAttr = ICM_LengthObjId( szOID_RSA_contentType);
        if (INVALID_ENCODING_SIZE == (cbTmp = ICM_LengthObjId(
                        pszInnerContentObjID ?
                        pszInnerContentObjID : pszObjIdDataType)))
            goto InnerContentLengthObjIdError;
        ICM_GetLengthOctets( cbTmp, NULL, &cb);
        cbAttr += cbTmp + cb + 1;       // AttributeSetValue set
        ICM_GetLengthOctets( cbAttr, NULL, &cb);
        cbAttrS += cbAttr + cb + 1;     // Attribute seq

        // message digest
        cbAttr = ICM_LengthObjId( szOID_RSA_messageDigest);
        if (INVALID_ENCODING_SIZE == (cbTmp = ICM_LengthDigest( hCryptProv, paiDigest)))
            goto LengthDigestError;
        ICM_GetLengthOctets( cbTmp, NULL, &cb);
        cbAttr += cbTmp + cb + 1;       // AttributeSetValue set
        ICM_GetLengthOctets( cbAttr, NULL, &cb);
        cbAttrS += cbAttr + cb + 1;     // Attribute seq
    }

    if (cbAttrS) {
        ICM_GetLengthOctets( cbAttrS, NULL, &cb);
        cbSize = cbAttrS + cb + 1;          // Attributes set
    }

CommonReturn:
    return cbSize;

ErrorReturn:
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
TRACE_ERROR(PatrLengthObjIdError)           // error already set
TRACE_ERROR(InnerContentLengthObjIdError)   // error already set
TRACE_ERROR(LengthDigestError)              // error already set
}


//+-------------------------------------------------------------------------
//  Calculate the length of the SignerInfos encoded blob.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthSignerInfos(
    IN DWORD                    cSigners,
    IN PCMSG_SIGNER_ENCODE_INFO rgSigners,
    IN LPSTR                    pszInnerContentObjID
#ifdef CMS_PKCS7
    ,
    OUT BOOL                    *pfHasCmsSignerId
#endif  // CMS_PKCS7
    )
{
    DWORD                       cbSize;
    DWORD                       cbSigner;
    DWORD                       cbSignerS;
    DWORD                       cb;
    PCMSG_SIGNER_ENCODE_INFO    psei;
    DWORD                       i;
    PCRYPT_ALGORITHM_IDENTIFIER paiDigestEncrypt;
    CERT_ID                     SignerId;

#ifdef CMS_PKCS7
    *pfHasCmsSignerId = FALSE;
#endif  // CMS_PKCS7

    for (i=cSigners, psei=rgSigners, cbSignerS=0;
            i>0;
            i--,
#ifdef CMS_PKCS7
            psei = (PCMSG_SIGNER_ENCODE_INFO) ((BYTE *) psei + psei->cbSize)) {
#else
            psei++) {
#endif  // CMS_PKCS7
        cbSigner = 1 + 1 + 1;               // version

        if (!ICM_GetSignerIdFromSignerEncodeInfo(psei, &SignerId))
            goto GetSignerIdError;
#ifdef CMS_PKCS7
        if (CERT_ID_ISSUER_SERIAL_NUMBER != SignerId.dwIdChoice)
            *pfHasCmsSignerId = TRUE;
#endif  // CMS_PKCS7
        if (INVALID_ENCODING_SIZE == (cb = ICM_LengthCertId( &SignerId)))
            goto CertIdError;
        cbSigner += cb;
        if (INVALID_ENCODING_SIZE == (cb = ICM_LengthAlgorithmIdentifier( &psei->HashAlgorithm)))
            goto HashAlgorithmError;
        cbSigner += cb;
        if (INVALID_ENCODING_SIZE == (cb = ICM_LengthAttributes(
                            psei->hCryptProv,
                            &psei->HashAlgorithm,
                            psei->cAuthAttr,
                            psei->rgAuthAttr,
                            pszInnerContentObjID,
                            TRUE)))
            goto AuthAttributesError;
        cbSigner += cb;
#ifdef CMS_PKCS7
    if (STRUCT_CBSIZE(CMSG_SIGNER_ENCODE_INFO, HashEncryptionAlgorithm) <=
            psei->cbSize && psei->HashEncryptionAlgorithm.pszObjId)
        paiDigestEncrypt = &psei->HashEncryptionAlgorithm;
    else
#endif  // CMS_PKCS7
        paiDigestEncrypt = &psei->pCertInfo->SubjectPublicKeyInfo.Algorithm;

        if (INVALID_ENCODING_SIZE == (cb =
                        ICM_LengthEncryptedDigestAndAlgorithm(
                            psei->hCryptProv,
                            psei->dwKeySpec,
                            &psei->HashAlgorithm,
                            paiDigestEncrypt)))
            goto EncryptedDigestError;
        cbSigner += cb;
        if (INVALID_ENCODING_SIZE == (cb = ICM_LengthAttributes(
                            NULL,
                            NULL,
                            psei->cUnauthAttr,
                            psei->rgUnauthAttr,
                            NULL,
                            FALSE)))
            goto UnauthAttributesError;
        cbSigner += cb;
        ICM_GetLengthOctets( cbSigner, NULL, &cb);
        cbSignerS += cbSigner + cb + 1;     // SignerInfo seq
    }
    ICM_GetLengthOctets( cbSignerS, NULL, &cb);
    cbSize = cbSignerS + cb + 1;            // SignerInfo seq

CommonReturn:
    return cbSize;

ErrorReturn:
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
TRACE_ERROR(GetSignerIdError)                       // error already set
TRACE_ERROR(CertIdError)                            // error already set
TRACE_ERROR(HashAlgorithmError)                     // error already set
TRACE_ERROR(AuthAttributesError)                    // error already set
TRACE_ERROR(UnauthAttributesError)                  // error already set
TRACE_ERROR(EncryptedDigestError)                   // error already set
}


//+-------------------------------------------------------------------------
//  Calculate the length of the SignedData.digestAlgorithms encoded blob.
//
#ifndef CMS_PKCS7
//  Assumes no duplicate removal. OK for single-signer case, which
//  is only one currently supported.
#endif
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthSignedDigestAlgorithms(
    IN DWORD                    cSigners,
    IN PCMSG_SIGNER_ENCODE_INFO rgSigners)
{
    DWORD                       cbSize;
    DWORD                       cbAlgoS;
    DWORD                       cb;
    PCMSG_SIGNER_ENCODE_INFO    psei;
    DWORD                       i;

#ifdef CMS_PKCS7
    for (i=cSigners, psei=rgSigners, cbAlgoS=0; i>0;
            i--,
            psei = (PCMSG_SIGNER_ENCODE_INFO) ((BYTE *) psei + psei->cbSize)) {
        assert(STRUCT_CBSIZE(CMSG_SIGNER_ENCODE_INFO, rgUnauthAttr) <=
            psei->cbSize);
        if (ICM_IsDuplicateSignerEncodeHashAlgorithm(
                rgSigners,
                psei
                ))
            continue;

        if (INVALID_ENCODING_SIZE == (cb = ICM_LengthAlgorithmIdentifier( &psei->HashAlgorithm)))
            goto HashAlgorithmError;
        cbAlgoS += cb;
    }
#else
    for (i=cSigners, psei=rgSigners, cbAlgoS=0;
            i>0;
            i--, psei++) {
        if (INVALID_ENCODING_SIZE == (cb = ICM_LengthAlgorithmIdentifier( &psei->HashAlgorithm)))
            goto HashAlgorithmError;
        cbAlgoS += cb;
    }
#endif  // CMS_PKCS7
    ICM_GetLengthOctets( cbAlgoS, NULL, &cb);
    cbSize = cbAlgoS + cb + 1;            // digestAlgorithms set

CommonReturn:
    return cbSize;

ErrorReturn:
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
TRACE_ERROR(HashAlgorithmError)     // error already set
}

#ifdef CMS_PKCS7

//+-------------------------------------------------------------------------
//  Calculate the length of an enveloped message.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthEnveloped(
    IN PCMSG_ENVELOPED_ENCODE_INFO  pemei,
    IN DWORD                        dwFlags,
    IN OPTIONAL LPSTR               pszInnerContentObjID,
    IN DWORD                        cbData,
    OUT OPTIONAL PDWORD             pcbContent)
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD cbSize;
    DWORD cb;

    CMSG_CONTENT_ENCRYPT_INFO ContentEncryptInfo;
        ZEROSTRUCT(ContentEncryptInfo);
    CmsRecipientInfos recipientInfos; ZEROSTRUCT(recipientInfos);
#ifdef OSS_CRYPT_ASN1
    int version = 0;
#else
    ASN1int32_t version = 0;
#endif  // OSS_CRYPT_ASN1

    ASN1error_e Asn1Err;
    ASN1encoding_t pEnc = ICM_GetEncoder();
    PBYTE pbEncoded = NULL;
    DWORD cbEncoded;

    assert(pemei->cbSize >= STRUCT_CBSIZE(CMSG_ENVELOPED_ENCODE_INFO,
        rgpRecipients));
#ifdef CMS_PKCS7
    if (pemei->cbSize <
                STRUCT_CBSIZE(CMSG_ENVELOPED_ENCODE_INFO, rgpRecipients))
#else
    assert(0 != pemei->cRecipients);
    if (pemei->cbSize <
                STRUCT_CBSIZE(CMSG_ENVELOPED_ENCODE_INFO, rgpRecipients) ||
            0 == pemei->cRecipients)
#endif  // CMS_PKCS7
        goto InvalidArg;

    // version
    cbSize = 1 + 1 + 1;

    // originatorInfo OPTIONAL
    //
    // unprotectedAttrs OPTIONAL
    if (pemei->cbSize >= sizeof(CMSG_ENVELOPED_ENCODE_INFO)) {
        DWORD cbOriginator = 0;
        DWORD cbTmp;
        DWORD i;
        PCERT_BLOB pCert;
        PCRL_BLOB pCrl;
        cbOriginator = 0;

        for (i = pemei->cCertEncoded, pCert = pemei->rgCertEncoded, cbTmp=0;
                i > 0;
                i--, pCert++)
            cbTmp += pCert->cbData;
        for (i = pemei->cAttrCertEncoded, pCert = pemei->rgAttrCertEncoded;
                i > 0;
                i--, pCert++)
            cbTmp += pCert->cbData;
        if (cbTmp) {
            ICM_GetLengthOctets(cbTmp, NULL, &cb);
            cbOriginator += 1 + cb + cbTmp;     // [0] IMPLICIT Certificates
        }

        for (i = pemei->cCrlEncoded, pCrl = pemei->rgCrlEncoded, cbTmp=0;
                i > 0;
                i--, pCrl++)
            cbTmp += pCrl->cbData;
        if (cbTmp) {
            ICM_GetLengthOctets(cbTmp, NULL, &cb);
            cbOriginator += 1 + cb + cbTmp;     // [1] IMPLICIT Crls
        }

        if (cbOriginator) {
            ICM_GetLengthOctets(cbOriginator, NULL, &cb);
            cbSize += 1 + cb + cbOriginator; // [0] IMPLICIT OriginatorInfo
        }

        if (0 < pemei->cUnprotectedAttr) {
            if (INVALID_ENCODING_SIZE == (cb = ICM_LengthAttributes(
                                NULL,
                                NULL,
                                pemei->cUnprotectedAttr,
                                pemei->rgUnprotectedAttr,
                                NULL,
                                FALSE)))
                goto UnprotectedAttrError;
            cbSize += cb;
        }
    }

    // recipientInfos
    if (!ICM_InitializeContentEncryptInfo(pemei, &ContentEncryptInfo))
        goto InitializeContentEncryptInfoError;
    ContentEncryptInfo.dwEncryptFlags |=
        CMSG_CONTENT_ENCRYPT_PAD_ENCODED_LEN_FLAG;
    if (!ICM_FillOssCmsRecipientInfos(
            &ContentEncryptInfo,
            &recipientInfos,
            &version
            ))
        goto FillOssCmsRecipientInfosError;
    if (0 != (Asn1Err = PkiAsn1Encode(
            pEnc,
            &recipientInfos,
            CmsRecipientInfos_PDU,
            &pbEncoded,
            &cbEncoded)))
        goto EncodeCmsRecipientInfosError;
    cbSize += cbEncoded;

    // encryptedContentInfo
    if (INVALID_ENCODING_SIZE == (cb = ICM_LengthEncryptedContentInfo(
                    ContentEncryptInfo.hContentEncryptKey,
                    &ContentEncryptInfo.ContentEncryptionAlgorithm,
                    pszInnerContentObjID,
                    cbData)))
        goto LengthEncryptedContentInfoError;
    cbSize += cb;

    if (pcbContent)
        *pcbContent = cbSize;

    ICM_GetLengthOctets( cbSize, NULL, &cb);
    cbSize += 1 + cb;                           // CmsEnvelopedData seq

CommonReturn:
    PkiAsn1FreeEncoded(pEnc, pbEncoded);
    ICM_FreeContentEncryptInfo(pemei, &ContentEncryptInfo);
    ICM_FreeOssCmsRecipientInfos(&recipientInfos);

    ICM_SetLastError(dwError);
    return cbSize;

ErrorReturn:
    dwError = GetLastError();
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
SET_ERROR(InvalidArg,E_INVALIDARG)
TRACE_ERROR(UnprotectedAttrError)
TRACE_ERROR(InitializeContentEncryptInfoError)
TRACE_ERROR(FillOssCmsRecipientInfosError)
SET_ERROR_VAR(EncodeCmsRecipientInfosError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(LengthEncryptedContentInfoError)
}
#else


//+-------------------------------------------------------------------------
//  Calculate the length of the EncryptedKey encoded blob.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthEncryptedKey(
    IN HCRYPTPROV                   hCryptProv,
    IN HCRYPTKEY                    hEncryptKey,
    IN PCERT_PUBLIC_KEY_INFO        pPublicKeyInfo,
    IN DWORD                        dwEncryptFlags)
{
    DWORD cbSize;
    // rgcbEncryptedKey[1] contains dwEncryptFlags
    DWORD rgcbEncryptedKey[2];
    DWORD cb;

    rgcbEncryptedKey[1] = dwEncryptFlags;

    // Length only export calculation
    if (!ICM_ExportEncryptKey(
            hCryptProv,
            hEncryptKey,
            pPublicKeyInfo,
            NULL,               // pbData
            rgcbEncryptedKey) || 0 == rgcbEncryptedKey[0])
        goto ExportKeyError;

    // Add bytes for ASN.1 tag and length
    ICM_GetLengthOctets(rgcbEncryptedKey[0], NULL, &cb);
    cbSize = rgcbEncryptedKey[0] + cb + 1;       // OCTET STRING

CommonReturn:
    return cbSize;

ErrorReturn:
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
TRACE_ERROR(ExportKeyError)
}


//+-------------------------------------------------------------------------
//  Calculate the length of the RecipientInfos encoded blob.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthRecipientInfos(
    IN HCRYPTPROV                   hCryptProv,
    IN HCRYPTKEY                    hEncryptKey,
    IN DWORD                        cRecipients,
    IN PCERT_INFO                   *rgpRecipients,
    IN DWORD                        dwEncryptFlags)
{
    DWORD       cbSize;
    DWORD       cbRecipient;
    DWORD       cbRecipientS;
    DWORD       cb;
    PCERT_INFO  *ppCertInfo;
    DWORD       i;

    for (i=cRecipients, ppCertInfo=rgpRecipients, cbRecipientS=0;
            i>0;
            i--, ppCertInfo++) {
        cbRecipient = 1 + 1 + 1;                // version
        if (INVALID_ENCODING_SIZE == (cb = ICM_LengthIssuerAndSerialNumber( *ppCertInfo)))
            goto IssuerAndSerialNumberError;
        cbRecipient += cb;
        if (INVALID_ENCODING_SIZE == (cb = ICM_LengthAlgorithmIdentifier(
                            &(*ppCertInfo)->SubjectPublicKeyInfo.Algorithm)))
            goto SubjectPublicKeyInfoAlgorithmError;
        cbRecipient += cb;
        if (INVALID_ENCODING_SIZE == (cb = ICM_LengthEncryptedKey(
                            hCryptProv,
                            hEncryptKey,
                            &(*ppCertInfo)->SubjectPublicKeyInfo,
                            dwEncryptFlags)))
            goto EncryptedKeyError;
        cbRecipient += cb;
        ICM_GetLengthOctets( cbRecipient, NULL, &cb);
        cbRecipientS += cbRecipient + cb + 1;   // RecipientInfo
    }
    ICM_GetLengthOctets( cbRecipientS, NULL, &cb);
    cbSize = cbRecipientS + cb + 1;             // RecipientInfos seq

CommonReturn:
    return cbSize;

ErrorReturn:
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
TRACE_ERROR(IssuerAndSerialNumberError)             // error already set
TRACE_ERROR(SubjectPublicKeyInfoAlgorithmError)     // error already set
TRACE_ERROR(EncryptedKeyError)                      // error already set
}


//+-------------------------------------------------------------------------
//  Calculate the length of an enveloped message.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthEnveloped(
    IN PCMSG_ENVELOPED_ENCODE_INFO  pemei,
    IN DWORD                        dwFlags,
    IN OPTIONAL LPSTR               pszInnerContentObjID,
    IN DWORD                        cbData,
    OUT OPTIONAL PDWORD             pcbContent)
{
    DWORD       dwError = ERROR_SUCCESS;
    DWORD       cbSize;
    DWORD       cb;
    HCRYPTPROV  hCryptProv;
    HCRYPTKEY   hEncryptKey = NULL;

    CRYPT_ALGORITHM_IDENTIFIER  ContentEncryptionAlgorithm;
    PBYTE                       pbEncryptParameters = NULL;

    // rgcbEncryptParameters[1] contains dwEncryptFlags
    DWORD                       rgcbEncryptParameters[2];

    // version
    cbSize = 1 + 1 + 1;

    if (0 == pemei->cRecipients)
        goto InvalidArg;
    hCryptProv = pemei->hCryptProv;

    ContentEncryptionAlgorithm = pemei->ContentEncryptionAlgorithm;
    rgcbEncryptParameters[0] = 0;
    rgcbEncryptParameters[1] = 0;   // dwEncryptFlags
    if (!ICM_GenEncryptKey(
            &hCryptProv,
            &ContentEncryptionAlgorithm,
            pemei->pvEncryptionAuxInfo,
            &pemei->rgpRecipients[0]->SubjectPublicKeyInfo,
            ICM_Alloc,
            &hEncryptKey,
            &pbEncryptParameters,
            rgcbEncryptParameters))
        goto GenKeyError;
    if (rgcbEncryptParameters[0] && pbEncryptParameters) {
        ContentEncryptionAlgorithm.Parameters.pbData = pbEncryptParameters;
        ContentEncryptionAlgorithm.Parameters.cbData = rgcbEncryptParameters[0];
    }

    // recipientInfos
    if (INVALID_ENCODING_SIZE == (cb = ICM_LengthRecipientInfos(
                    hCryptProv,
                    hEncryptKey,
                    pemei->cRecipients,
                    pemei->rgpRecipients,
                    rgcbEncryptParameters[1])))     // dwEncryptFlags
        goto LengthRecipientInfosError;
    cbSize += cb;

    // encryptedContentInfo
    if (INVALID_ENCODING_SIZE == (cb = ICM_LengthEncryptedContentInfo(
                    hEncryptKey,
                    &ContentEncryptionAlgorithm,
                    pszInnerContentObjID,
                    cbData)))
        goto LengthEncryptedContentInfoError;
    cbSize += cb;

    if (pcbContent)
        *pcbContent = cbSize;

    ICM_GetLengthOctets( cbSize, NULL, &cb);
    cbSize += 1 + cb;                           // EnvelopedData seq

CommonReturn:
    if (hEncryptKey)
        CryptDestroyKey(hEncryptKey);
    ICM_Free(pbEncryptParameters);
    ICM_SetLastError(dwError);
    return cbSize;

ErrorReturn:
    dwError = GetLastError();
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
SET_ERROR(InvalidArg,E_INVALIDARG)
TRACE_ERROR(GenKeyError)
TRACE_ERROR(LengthRecipientInfosError)
TRACE_ERROR(LengthEncryptedContentInfoError)
}

#endif  // CMS_PKCS7


//+-------------------------------------------------------------------------
//  Calculate the length of a signed message.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthSigned(
    IN PCMSG_SIGNED_ENCODE_INFO psmei,
    IN DWORD                    dwFlags,
    IN OPTIONAL LPSTR           pszInnerContentObjID,
    IN DWORD                    cbData,
    OUT OPTIONAL PDWORD         pcbContent)
{
    DWORD                       cbSize;
    DWORD                       cbSignedData;
    DWORD                       cbTmp;
    DWORD                       cb;
    DWORD                       i;
    PCERT_BLOB                  pCert;
    PCRL_BLOB                   pCrl;

#ifdef CMS_PKCS7
    DWORD                       cAttrCertEncoded;
    BOOL                        fHasCmsSignerId = FALSE;
#endif  // CMS_PKCS7

    cbSignedData = 1 + 1 + 1;           // version

    if (INVALID_ENCODING_SIZE == (cb = ICM_LengthSignedDigestAlgorithms(
                    psmei->cSigners,
                    psmei->rgSigners)))
        goto LengthSignedDigestAlgorithmsError;
    cbSignedData += cb;

#ifdef CMS_PKCS7
    if (psmei->cbSize >= STRUCT_CBSIZE(CMSG_SIGNED_ENCODE_INFO,
            rgAttrCertEncoded)) {
        cAttrCertEncoded = psmei->cAttrCertEncoded;

        if (cAttrCertEncoded)
            dwFlags |= CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
    } else
        cAttrCertEncoded = 0;
#endif  // CMS_PKCS7

    // Do this before the ContentInfo. Need to know if we need to
    // encapsulate the content for KeyId Signers.
    if (INVALID_ENCODING_SIZE == (cb = ICM_LengthSignerInfos(
                    psmei->cSigners,
                    psmei->rgSigners,
                    pszInnerContentObjID
#ifdef CMS_PKCS7
                    ,
                    &fHasCmsSignerId
#endif  // CMS_PKCS7
                    )))
        goto SignerInfosError;
    cbSignedData += cb;
#ifdef CMS_PKCS7
    if (fHasCmsSignerId)
        dwFlags |= CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
#endif  // CMS_PKCS7

    if (INVALID_ENCODING_SIZE == (cb = ICM_LengthContentInfo(
                    dwFlags,
                    pszInnerContentObjID,
                    cbData,
                    NULL)))
        goto LengthContentInfoError;
    cbSignedData += cb;

    for (i = psmei->cCertEncoded, pCert = psmei->rgCertEncoded, cbTmp=0;
            i > 0;
            i--, pCert++)
        cbTmp += pCert->cbData;

#ifdef CMS_PKCS7
    if (cAttrCertEncoded) {
        for (i = cAttrCertEncoded, pCert = psmei->rgAttrCertEncoded;
                i > 0;
                i--, pCert++)
            cbTmp += pCert->cbData;
    }
#endif  // CMS_PKCS7

    if (cbTmp) {
        ICM_GetLengthOctets( cbTmp, NULL, &cb);
        cbSignedData += 1 + cb + cbTmp;     // [0] IMPLICIT Certificates
    }

    for (i = psmei->cCrlEncoded, pCrl = psmei->rgCrlEncoded, cbTmp=0;
            i > 0;
            i--, pCrl++)
        cbTmp += pCrl->cbData;
    if (cbTmp) {
        ICM_GetLengthOctets( cbTmp, NULL, &cb);
        cbSignedData += 1 + cb + cbTmp;     // [1] IMPLICIT Crls
    }

    if (pcbContent)
        *pcbContent = cbSignedData;

    ICM_GetLengthOctets( cbSignedData, NULL, &cb);
    cbSize = 1 + cb + cbSignedData;     // SignedData seq

CommonReturn:
    return cbSize;

ErrorReturn:
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
TRACE_ERROR(LengthSignedDigestAlgorithmsError)  // error already set
TRACE_ERROR(LengthContentInfoError)             // error already set
TRACE_ERROR(SignerInfosError)                   // error already set
}


//+-------------------------------------------------------------------------
//  Calculate the length of a digested message.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthDigested(
    IN PCMSG_HASHED_ENCODE_INFO pdmei,
    IN DWORD                    dwFlags,
    IN OPTIONAL LPSTR           pszInnerContentObjID,
    IN DWORD                    cbData,
    OUT OPTIONAL PDWORD         pcbContent)
{
    DWORD       cbSize;
    DWORD       cb;

    cbSize = 1 + 1 + 1;             // version

    if (INVALID_ENCODING_SIZE == (cb = ICM_LengthAlgorithmIdentifier( &pdmei->HashAlgorithm)))
        goto HashAlgorithmError;
    cbSize += cb;

    if (INVALID_ENCODING_SIZE == (cb = ICM_LengthContentInfo(
                    dwFlags,
                    pszInnerContentObjID,
                    cbData,
                    NULL)))
        goto LengthContentInfoError;
    cbSize += cb;

    if (INVALID_ENCODING_SIZE == (cb = ICM_LengthDigest( pdmei->hCryptProv, &pdmei->HashAlgorithm)))
        goto DigestError;
    cbSize += cb;

    if (pcbContent)
        *pcbContent = cbSize;

    ICM_GetLengthOctets( cbSize, NULL, &cb);
    cbSize += 1 + cb;               // DigestedData seq

CommonReturn:
    return cbSize;

ErrorReturn:
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
TRACE_ERROR(HashAlgorithmError)     // error already set
TRACE_ERROR(LengthContentInfoError) // error already set
TRACE_ERROR(DigestError)            // error already set
}

//+-------------------------------------------------------------------------
//  Calculate the length of an encoded cryptographic message.
//
//  Calculates the length of the encoded message given the
//  message type, encoding parameters and total length of
//  the data to be updated. Note, this might not be the exact length.
//  However, it will always be greater than or equal to the actual length.
//--------------------------------------------------------------------------
DWORD
WINAPI
CryptMsgCalculateEncodedLength(
    IN DWORD            dwEncodingType,
    IN DWORD            dwFlags,
    IN DWORD            dwMsgType,
    IN void const       *pvMsgEncodeInfo,
    IN OPTIONAL LPSTR   pszInnerContentObjID,
    IN DWORD            cbData)
{
    DWORD   cbSize = INVALID_ENCODING_SIZE;
    LPSTR   pszContentType = NULL;
    DWORD   cb;
    DWORD   cbContent = 0;

    if (GET_CMSG_ENCODING_TYPE(dwEncodingType) != PKCS_7_ASN_ENCODING)
        goto InvalidEncoding;

    switch (dwMsgType) {
    case CMSG_DATA:
        if (NULL != pvMsgEncodeInfo)
            goto InvalidEncodeInfo;
        cbContent = cbData;
        ICM_GetLengthOctets( cbData, NULL, &cb);
        cbSize = 1 + cb + cbData;       // OCTET STRING
        pszContentType = pszObjIdDataType;
        break;

    case CMSG_SIGNED:
        if (INVALID_ENCODING_SIZE == (cbSize = ICM_LengthSigned(
                                (PCMSG_SIGNED_ENCODE_INFO)pvMsgEncodeInfo,
                                dwFlags,
                                pszInnerContentObjID,
                                cbData,
                                &cbContent)))
            goto LengthSignedError;
        pszContentType = szOID_RSA_signedData;
        break;

    case CMSG_ENVELOPED:
        if (INVALID_ENCODING_SIZE == (cbSize = ICM_LengthEnveloped(
                                (PCMSG_ENVELOPED_ENCODE_INFO)pvMsgEncodeInfo,
                                dwFlags,
                                pszInnerContentObjID,
                                cbData,
                                &cbContent)))
            goto LengthEnvelopedError;
        pszContentType = szOID_RSA_envelopedData;
        break;

    case CMSG_HASHED:
        if (INVALID_ENCODING_SIZE == (cbSize = ICM_LengthDigested(
                                (PCMSG_HASHED_ENCODE_INFO)pvMsgEncodeInfo,
                                dwFlags,
                                pszInnerContentObjID,
                                cbData,
                                &cbContent)))
            goto LengthDigestedError;
        pszContentType = szOID_RSA_digestedData;
        break;

    case CMSG_SIGNED_AND_ENVELOPED:
    case CMSG_ENCRYPTED:
        goto MessageTypeNotSupportedYet;

    default:
        goto InvalidMsgType;
    }

    if (0 == (dwFlags & CMSG_BARE_CONTENT_FLAG)) {
        if (INVALID_ENCODING_SIZE == (cbSize = ICM_LengthContentInfo(
                            0,                      // dwFlags
                            pszContentType,
                            cbSize,
                            &cbContent)))
            goto LengthContentInfoError;
    }

CommonReturn:
    return (cbSize == INVALID_ENCODING_SIZE) ? 0 :
           ((dwFlags & CMSG_CONTENTS_OCTETS_FLAG) ? cbContent : cbSize);

ErrorReturn:
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
SET_ERROR(InvalidEncoding,E_INVALIDARG)
SET_ERROR(InvalidEncodeInfo,E_INVALIDARG)
SET_ERROR(MessageTypeNotSupportedYet,CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(InvalidMsgType,CRYPT_E_INVALID_MSG_TYPE)
TRACE_ERROR(LengthSignedError)              // error already set
TRACE_ERROR(LengthEnvelopedError)           // error already set
TRACE_ERROR(LengthDigestedError)            // error already set
TRACE_ERROR(LengthContentInfoError)         // error already set
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\wincrmsg\msgasn1.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       msgasn1.h
//
//  Contents:   Conversion APIs to/from ASN.1 data structures
//
//  Functions:  ICM_Asn1ToAttribute
//              ICM_Asn1ToAlgorithmIdentifier
//              ICM_Asn1FromAlgorithmIdentifier
//
//  History:    16-Apr-96   kevinr   created
//
//--------------------------------------------------------------------------

#ifndef __MSGASN1_H__
#define __MSGASN1_H__

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  Convert an CRYPT_ATTRIBUTE to an ASN1 Attribute
//
//  Returns FALSE iff conversion failed.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_Asn1ToAttribute(
    IN PCRYPT_ATTRIBUTE       patr,
    OUT Attribute       *pAsn1Attr);


//+-------------------------------------------------------------------------
//  Convert an CRYPT_ALGORITHM_IDENTIFIER to an ASN1 AlgorithmIdentifier
//
//  Returns FALSE iff conversion failed.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_Asn1ToAlgorithmIdentifier(
    IN PCRYPT_ALGORITHM_IDENTIFIER pai,
    OUT AlgorithmIdentifier *pAsn1AlgId);


//+-------------------------------------------------------------------------
//  Convert an ASN1 AlgorithmIdentifier to an CRYPT_ALGORITHM_IDENTIFIER
//
//  Returns FALSE iff conversion failed.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_Asn1FromAlgorithmIdentifier(
    IN AlgorithmIdentifier *pAsn1AlgId,
    OUT PCRYPT_ALGORITHM_IDENTIFIER pai);

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\wincrmsg\msgstrm.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       msgstrm.cpp
//
//  Contents:   Cryptographic Message Streaming API support
//
//  APIs:       
//
//  History:    20-Feb-97   kevinr    created
//
//--------------------------------------------------------------------------

#include "global.hxx"

#define ICMS_NOCRYPT 0

#if (DBG && ICMS_NOCRYPT)
#define CryptEncrypt ICMS_PlainEncrypt
#define CryptDecrypt ICMS_PlainDecrypt

//+-------------------------------------------------------------------------
//  Encrypt a buffer using a NOP algorithm, ie. ciphertext == plaintext
//  Assumes that all but the last block are a multiple of the block
//  size in length.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_PlainEncrypt(
    IN HCRYPTKEY    hkeyCrypt,
    IN HCRYPTHASH   hHash,
    IN BOOL         fFinal,
    IN DWORD        dwFlags,
    IN OUT PBYTE    pbData,
    IN OUT PDWORD   pcbData,
    IN DWORD        cbBuf)
{
    BOOL        fRet;
    DWORD       cbBlockLen;
    BOOL        fBlockCipher;
    DWORD       cbCipher;
    DWORD       cbPlain = *pcbData;
    DWORD       cbPad;
    DWORD       i;

    if (!fFinal)
        goto SuccessReturn;

    if (!ICM_GetKeyBlockSize( hkeyCrypt, &cbBlockLen, &fBlockCipher))
        goto GetKeyBlockSizeError;
    if (!fBlockCipher)
        goto SuccessReturn;             // if stream, cipher == plain

    cbCipher  = cbPlain;
    cbCipher += cbBlockLen;
    cbCipher -= cbCipher % cbBlockLen; // make a multiple of block size
    cbPad     = cbCipher - cbPlain;

    if (cbCipher > cbBuf)
        goto BufferTooSmallError;

    // pad the "ciphertext"
    FillMemory( pbData + cbPlain, cbPad, cbPad);
    *pcbData = cbCipher;

SuccessReturn:
    fRet = TRUE;
CommonReturn:
	return fRet;

ErrorReturn:
	fRet = FALSE;
	goto CommonReturn;
TRACE_ERROR(GetKeyBlockSizeError)       // error already set
TRACE_ERROR(BufferTooSmallError)        // error already set
}


//+-------------------------------------------------------------------------
//  Decrypt a buffer using a NOP algorithm, ie. ciphertext == plaintext
//  Assumes all input sizes are multiples of the block size.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_PlainDecrypt(
    IN HCRYPTKEY    hkeyCrypt,
    IN HCRYPTHASH   hHash,
    IN BOOL         fFinal,
    IN DWORD        dwFlags,
    IN OUT PBYTE    pbData,
    IN OUT PDWORD   pcbData)
{
    BOOL        fRet;
    PBYTE       pb;
    DWORD       cbBlockLen;
    BOOL        fBlockCipher;
    DWORD       cbCipher = *pcbData;
    DWORD       cbPlain;
    DWORD       cbPad;

    if (!fFinal)
        goto SuccessReturn;

    if (!ICM_GetKeyBlockSize( hkeyCrypt, &cbBlockLen, &fBlockCipher))
        goto GetKeyBlockSizeError;
    if (!fBlockCipher)
        goto SuccessReturn;             // if stream, cipher == plain

    cbPad = (DWORD)(*(pbData + cbCipher - 1));  // check last byte

    if (cbCipher < cbPad)
        goto CipherTextTooSmallError;

    cbPlain = cbCipher - cbPad;
    *pcbData = cbPlain;

SuccessReturn:
    fRet = TRUE;
CommonReturn:
	return fRet;

ErrorReturn:
	fRet = FALSE;
	goto CommonReturn;
TRACE_ERROR(GetKeyBlockSizeError)       // error already set
TRACE_ERROR(CipherTextTooSmallError)    // error already set
}
#endif  // (DBG && ICMS_NOCRYPT)


//+-------------------------------------------------------------------------
//  Do a CryptMsgGetParam to a buffer alloc'd by ICM_Alloc
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_AllocGetParam(
    IN HCRYPTMSG    hCryptMsg,
    IN DWORD        dwParamType,
    IN DWORD        dwIndex,
    OUT PBYTE       *ppbData,
    OUT DWORD       *pcbData)
{
    BOOL    fRet;
    DWORD   cb;
    PBYTE   pb = NULL;
    
    if (!CryptMsgGetParam(
            hCryptMsg,
            dwParamType,
            dwIndex,
            NULL,
            &cb))
        goto GetEncodedSizeError;
    if (NULL == (pb = (PBYTE)ICM_Alloc(cb)))
        goto AllocEncodedError;
    if (!CryptMsgGetParam(
            hCryptMsg,
            dwParamType,
            dwIndex,
            pb,
            &cb))
        goto GetEncodedError;

    fRet = TRUE;
CommonReturn:
    *ppbData = pb;
    *pcbData = cb;
	return fRet;

ErrorReturn:
    ICM_Free(pb);
    pb = NULL;
    cb = 0;
	fRet = FALSE;
	goto CommonReturn;
TRACE_ERROR(GetEncodedSizeError)
TRACE_ERROR(AllocEncodedError)
TRACE_ERROR(GetEncodedError)
}


//+-------------------------------------------------------------------------
//  Peel off the identifier and length octets.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_ExtractContent(
    IN PCRYPT_MSG_INFO  pcmi,
    IN const BYTE       *pbDER,
    IN DWORD            cbDER,
    OUT PDWORD          pcbContent,
    OUT const BYTE      **ppbContent)
{
    BOOL        fRet;
    LONG        cbSkipped = 0;
    DWORD       cbEntireContent;

    if (!pcmi->fStreamContentExtracted) {
        if (0 > (cbSkipped = Asn1UtilExtractContent(
                                    pbDER,
                                    cbDER,
                                    &cbEntireContent,
                                    ppbContent)))
            goto ExtractContentError;
        pcmi->fStreamContentExtracted = TRUE;
    } else {
        *ppbContent = pbDER;
    }

    *pcbContent = cbDER - cbSkipped;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(ExtractContentError)        // error already set
}


//+-------------------------------------------------------------------------
//  Get the next token from the buffer.
//  If the encoding is definite-length, set *pcbContent to be the size of the
//  contents octets.
//
//  Here, a "token" is either identifier/length octets, or the double-NULL
//  terminating an indefinite-length encoding.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_GetToken(
    IN PICM_BUFFER      pbuf,
    OUT PDWORD          pdwToken,
    OUT OPTIONAL PDWORD pcbContent)
{
    DWORD       dwError = ERROR_SUCCESS;
    BOOL        fRet;
    DWORD       dwToken;
    LONG        lth;
    DWORD       cbContent = 0;
    const BYTE  *pbContent;
    PBYTE       pbData = pbuf->pbData + pbuf->cbDead;
    DWORD       cbData = pbuf->cbUsed - pbuf->cbDead;
    DWORD       cbConsumed = 0;

    if (2 > cbData) {
        dwToken = ICMS_TOKEN_INCOMPLETE;
    } else if (0 == pbData[0] && 0 == pbData[1]) {
        dwToken = ICMS_TOKEN_NULLPAIR;
        cbConsumed = 2;
    } else {
        if (0 > (lth = Asn1UtilExtractContent(
                            pbData,
                            cbData,
                            &cbContent,
                            &pbContent))) {
            if (ASN1UTIL_INSUFFICIENT_DATA != lth)
                goto ExtractContentError;
            dwToken = ICMS_TOKEN_INCOMPLETE;
        } else {
            dwToken = (CMSG_INDEFINITE_LENGTH == cbContent) ?
                      ICMS_TOKEN_INDEFINITE : ICMS_TOKEN_DEFINITE;
            cbConsumed = (DWORD)lth;
        }
    }

    if (ICMS_TOKEN_INCOMPLETE != dwToken)
        pbuf->cbDead += cbConsumed;

    fRet = TRUE;
CommonReturn:
    *pdwToken = dwToken;
    if (pcbContent)
        *pcbContent = cbContent;
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    dwToken   = 0;
    cbContent = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(ExtractContentError)            // error already set
}


//+-------------------------------------------------------------------------
//  Process incremental content data, for a string.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_ProcessStringContent(
    IN PICM_BUFFER      pbuf,
    IN OUT PDWORD       paflStream,
    IN OUT PDWORD       pcbPending,
    IN OUT PDWORD       pcLevelIndefiniteInner,
    IN POSTRCALLBACK    postrcbk,
    IN const void       *pvArg)
{
    BOOL        fRet;
    DWORD       dwToken;
    DWORD       cbContent;

    while (TRUE) {
        if (*pcbPending) {
            // *pcbPending bytes need to be processed, so we process
            // as many as possible from the buffer.
            if (!postrcbk( pvArg, pbuf, pcbPending, FALSE))
                goto CallbackError;
        }

        if (0 == *pcbPending) {
            // No bytes currently counted for processing. One of:
            // 1. first time through
            // 2. last time through
            // 3. nested within an indefinite-length encoding
            if (0 == *pcLevelIndefiniteInner) {
                // The first time through, and also when we have processed the
                // entire octet string, we get here. The flag is clear
                // the first time (so we set it after getting a token, which
                // either sets *pcbPending or bumps *pcLevelIndefiniteInner),
                // and set afterwards (so we mark done and bail).
                if (*paflStream & ICMS_PROCESS_CONTENT_BEGUN) {
                    // 2. last time through
                    if (!postrcbk( pvArg, pbuf, pcbPending, TRUE))
                        goto CallbackFinalError;
                    *paflStream |= ICMS_PROCESS_CONTENT_DONE;
                    goto SuccessReturn;                         // All done
                }
            }
            // One of:
            // 1. first time through
            // 3. nested within an indefinite-length encoding
            if (!ICMS_GetToken( pbuf, &dwToken, &cbContent))
                goto GetTokenError;
            switch(dwToken) {
            case ICMS_TOKEN_INDEFINITE: ++*pcLevelIndefiniteInner;  break;
            case ICMS_TOKEN_NULLPAIR:   --*pcLevelIndefiniteInner;  break;
            case ICMS_TOKEN_DEFINITE:   *pcbPending = cbContent;    break;
            case ICMS_TOKEN_INCOMPLETE: goto SuccessReturn;     // need input
            default:                    goto InvalidTokenError;
            }

            *paflStream |= ICMS_PROCESS_CONTENT_BEGUN;
        } else {
            // More definite-length data remains to be copied out, but it
            // is not yet in the buffer.
            break;
        }
    }

SuccessReturn:
    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(InvalidTokenError)                 // error already set
TRACE_ERROR(GetTokenError)                     // error already set
TRACE_ERROR(CallbackError)                     // error already set
TRACE_ERROR(CallbackFinalError)                // error already set
}


//+-------------------------------------------------------------------------
//  Queue data to the buffer.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_QueueToBuffer(
    IN PICM_BUFFER      pbuf,
    IN PBYTE            pbData,
    IN DWORD            cbData)
{
    BOOL            fRet;
    DWORD           cbNewSize;
    DWORD           cbNewUsed;

    if (0 == cbData)
        goto SuccessReturn;

    if (pbuf->pbData && pbuf->cbDead) {
        // Move the still-active bytes up to the front of the buffer.
        // NB- Might overlap, so use MoveMemory.
        MoveMemory(
                pbuf->pbData,
                pbuf->pbData + pbuf->cbDead,
                pbuf->cbUsed - pbuf->cbDead);
        pbuf->cbUsed -= pbuf->cbDead;
        pbuf->cbDead  = 0;
    }

    for (cbNewUsed=pbuf->cbUsed + cbData, cbNewSize=pbuf->cbSize;
            cbNewUsed > cbNewSize;
            cbNewSize += ICM_BUFFER_SIZE_INCR)
        ;
    if (cbNewSize > pbuf->cbSize) {
        if (NULL == (pbuf->pbData=(PBYTE)ICM_ReAlloc( pbuf->pbData, cbNewSize)))
            goto ReAllocBufferError;
        pbuf->cbSize = cbNewSize;
    }

    CopyMemory( pbuf->pbData + pbuf->cbUsed, pbData, cbData);
    pbuf->cbUsed += cbData;

SuccessReturn:
    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(ReAllocBufferError)         // error already set
}


//+-------------------------------------------------------------------------
//  Copy out or queue some data eventually destined for the callback.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_Output(
    IN PCRYPT_MSG_INFO  pcmi,
    IN PBYTE            pbData,
    IN DWORD            cbData,
    IN BOOL             fFinal)
{
    BOOL                    fRet;
    PCMSG_STREAM_INFO       pcsi            = pcmi->pStreamInfo;
    PFN_CMSG_STREAM_OUTPUT  pfnStreamOutput = pcsi->pfnStreamOutput;
    void                    *pvArg          = pcsi->pvArg;
    PICM_BUFFER             pbuf            = &pcmi->bufOutput;

    if (pcmi->fStreamCallbackOutput) {
        if (pbuf->cbUsed) {
            // Copy out the queued data
            if (!pfnStreamOutput( pvArg, pbuf->pbData, pbuf->cbUsed, FALSE))
                goto OutputBufferError;
            pbuf->cbUsed = 0;
        }
        if (cbData || fFinal) {
            if (!pfnStreamOutput( pvArg, pbData, cbData, fFinal))
                goto OutputError;
        }
    } else {
        if (!ICMS_QueueToBuffer( pbuf, pbData, cbData))
            goto QueueOutputError;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutputBufferError)      // error already set
TRACE_ERROR(QueueOutputError)       // error already set
TRACE_ERROR(OutputError)            // error already set
}


//+-------------------------------------------------------------------------
//  Copy out the pair of NULLs following the contents octets of an indefinite-
//  length encoding.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_OutputNullPairs(
    IN PCRYPT_MSG_INFO  pcmi,
    IN DWORD            cPairs,
    IN BOOL             fFinal)
{
    BOOL                fRet;
    BYTE                abNULL[8*2];    ZEROSTRUCT(abNULL);

    if (cPairs > (sizeof(abNULL)/2))
        goto CountOfNullPairsTooLargeError;

    if (!ICMS_Output( pcmi, abNULL, cPairs * 2, fFinal))
        goto OutputError;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(CountOfNullPairsTooLargeError)      // error already set
TRACE_ERROR(OutputError)                        // error already set
}


//+-------------------------------------------------------------------------
//  Copy out the part of the encoding preceding the contents octets.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_OutputEncodedPrefix(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BYTE             bTag,
    IN DWORD            cbData)
{
    BOOL                    fRet;
    DWORD                   dwError = ERROR_SUCCESS;
    BYTE                    abPrefix[6];
    DWORD                   cbPrefix;

    abPrefix[0] = bTag;
    if (CMSG_INDEFINITE_LENGTH == cbData) {
        abPrefix[1] = ICM_LENGTH_INDEFINITE;
        cbPrefix = 1;
    } else {
        cbPrefix = sizeof(abPrefix) - 1;
        ICM_GetLengthOctets( cbData, abPrefix + 1, &cbPrefix);
    }

    if (!ICMS_Output( pcmi, abPrefix, cbPrefix + 1, FALSE))
        goto OutputError;

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutputError)            // error already set
}


//+-------------------------------------------------------------------------
//  Copy out the part of the ContentInfo encoding preceding
//  the content's content.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_OutputEncodedPrefixContentInfo(
    IN PCRYPT_MSG_INFO  pcmi,
    IN LPSTR            pszContentType,
    IN DWORD            cbData,
    IN DWORD            dwFlags = 0)
{
    BOOL                    fRet;
    DWORD                   dwError = ERROR_SUCCESS;
    ASN1error_e             Asn1Err;
    ASN1encoding_t          pEnc = ICM_GetEncoder();
    PBYTE                   pbEncoded = NULL;
    DWORD                   cbEncoded;
    ObjectID                ossObjID;
    BYTE                    abContentInfo[6];
    DWORD                   cbContentInfo;
    BYTE                    abContent[6];
    DWORD                   cbContent = 0;
    BYTE                    abContentOctetString[6];
    DWORD                   cbContentOctetString = 0;
    DWORD                   cbSize = cbData;

    if (dwFlags & CMSG_DETACHED_FLAG) {
        // NoContent
        if (CMSG_INDEFINITE_LENGTH != cbData)
            cbSize = 0;
    } else {
        if (NULL == pszContentType
#ifdef CMS_PKCS7
                || (dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG)
#endif  // CMS_PKCS7
                ) {
            // The content is not already encoded, so encode it as an octet string.
            abContentOctetString[0] = ICM_TAG_OCTETSTRING;
            if (CMSG_INDEFINITE_LENGTH == cbData) {
                abContentOctetString[0] |= ICM_TAG_CONSTRUCTED;
                abContentOctetString[1] = ICM_LENGTH_INDEFINITE;
                cbContentOctetString = 1;
            } else {
                cbContentOctetString = sizeof(abContentOctetString) - 1;
                ICM_GetLengthOctets(
                            cbData,
                            abContentOctetString + 1,
                            &cbContentOctetString);
                cbSize += 1 + cbContentOctetString;
            }
        }

        // content, [0] EXPLICIT
        abContent[0] = ICM_TAG_CONSTRUCTED | ICM_TAG_CONTEXT_0;
        if (CMSG_INDEFINITE_LENGTH == cbData) {
            abContent[1] = ICM_LENGTH_INDEFINITE;
            cbContent = 1;
        } else {
            cbContent = sizeof(abContent) - 1;
            ICM_GetLengthOctets( cbSize, abContent + 1, &cbContent);
            cbSize += 1 + cbContent;
        }
    }

    // contentType
    ossObjID.count = SIZE_OSS_OID;
    if (!PkiAsn1ToObjectIdentifier(
            pszContentType ? pszContentType : pszObjIdDataType,
            &ossObjID.count,
            ossObjID.value))
        goto ConvToObjectIdentifierError;
    if (0 != (Asn1Err = PkiAsn1Encode(
            pEnc,
            &ossObjID,
            ObjectIdentifierType_PDU,
            &pbEncoded,
            &cbEncoded)))
        goto EncodeObjectIdentifierError;
    cbSize += cbEncoded;

    abContentInfo[0] = ICM_TAG_SEQ;
    if (CMSG_INDEFINITE_LENGTH == cbData) {
        abContentInfo[1] = ICM_LENGTH_INDEFINITE;
        cbContentInfo = 1;
    } else {
        cbContentInfo = sizeof(abContentInfo) - 1;
        ICM_GetLengthOctets( cbSize, abContentInfo + 1, &cbContentInfo);
    }

    if (!ICMS_Output( pcmi, abContentInfo, cbContentInfo + 1, FALSE))
        goto OutputContentInfoError;
    if (!ICMS_Output( pcmi, pbEncoded, cbEncoded, FALSE))
        goto OutputContentTypeError;
    if (0 == (dwFlags & CMSG_DETACHED_FLAG)) {
        if (!ICMS_Output( pcmi, abContent, cbContent + 1, FALSE))
            goto OutputContentError;
        if (NULL == pszContentType
#ifdef CMS_PKCS7
                || (dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG)
#endif  // CMS_PKCS7
                ) {
            if (!ICMS_Output( 
                    pcmi,
                    abContentOctetString,
                    cbContentOctetString + 1,
                    FALSE))
                goto OutputContentOctetStringError;
        }
    }

    fRet = TRUE;
CommonReturn:
    PkiAsn1FreeEncoded(pEnc, pbEncoded);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(EncodeObjectIdentifierError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(ConvToObjectIdentifierError)        // error already set
TRACE_ERROR(OutputContentInfoError)             // error already set
TRACE_ERROR(OutputContentTypeError)             // error already set
TRACE_ERROR(OutputContentError)                 // error already set
TRACE_ERROR(OutputContentOctetStringError)      // error already set
}


//+-------------------------------------------------------------------------
//  Copy out the part of the EncryptedContentInfo encoding preceding
//  the content's content.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_OutputEncodedPrefixEncryptedContentInfo(
    IN PCRYPT_MSG_INFO      pcmi,
    IN LPSTR                pszContentType,
    IN AlgorithmIdentifier  *poaiContentEncryption,
    IN DWORD                cbData)
{
    BOOL                    fRet;
    DWORD                   dwError = ERROR_SUCCESS;
    ASN1error_e             Asn1Err;
    ASN1encoding_t          pEnc = ICM_GetEncoder();
    PBYTE                   pbEncodedContentType = NULL;
    DWORD                   cbEncodedContentType;
    PBYTE                   pbEncodedContentEncryptionAlgorithm = NULL;
    DWORD                   cbEncodedContentEncryptionAlgorithm;
    ObjectID                ossObjID;
    BYTE                    abEncryptedContentInfo[6];
    DWORD                   cbEncryptedContentInfo;
    BYTE                    abEncryptedContent[6];
    DWORD                   cbEncryptedContent;
    DWORD                   cbSize = 0;
    DWORD                   cbCipher = cbData;
    DWORD                   cbBlockSize = pcmi->cbBlockSize;

    if (pcmi->fBlockCipher && 0 < cbCipher) {
        cbCipher += cbBlockSize;
        cbCipher -= cbCipher % cbBlockSize;
    }

    // encryptedContent, [0] IMPLICIT
    abEncryptedContent[0] = ICM_TAG_CONTEXT_0;
    if (CMSG_INDEFINITE_LENGTH == cbData) {
        abEncryptedContent[0] |= ICM_TAG_CONSTRUCTED;
        abEncryptedContent[1] = ICM_LENGTH_INDEFINITE;
        cbEncryptedContent = 1;
    } else {
        // NOTE: for nonData, either encapsulated or the cbData excludes
        // the outer tag and length octets.
        cbEncryptedContent = sizeof(abEncryptedContent) - 1;
        ICM_GetLengthOctets( cbCipher, abEncryptedContent + 1, &cbEncryptedContent);
        cbSize = 1 + cbEncryptedContent + cbCipher;
    }

    // contentType
    ossObjID.count = SIZE_OSS_OID;
    if (!PkiAsn1ToObjectIdentifier(
            pszContentType ? pszContentType : pszObjIdDataType,
            &ossObjID.count,
            ossObjID.value))
        goto ConvToObjectIdentifierError;
    if (0 != (Asn1Err = PkiAsn1Encode(
            pEnc,
            &ossObjID,
            ObjectIdentifierType_PDU,
            &pbEncodedContentType,
            &cbEncodedContentType)))
        goto EncodeObjectIdentifierError;
    cbSize += cbEncodedContentType;

    // contentEncryptionAlgorithm
    if (0 != (Asn1Err = PkiAsn1Encode(
            pEnc,
            poaiContentEncryption,
            AlgorithmIdentifier_PDU,
            &pbEncodedContentEncryptionAlgorithm,
            &cbEncodedContentEncryptionAlgorithm)))
        goto EncodeContentEncryptionAlgorithmError;
    cbSize += cbEncodedContentEncryptionAlgorithm;

    // EncryptedContentInfo
    abEncryptedContentInfo[0] = ICM_TAG_SEQ;
    if (CMSG_INDEFINITE_LENGTH == cbData) {
        abEncryptedContentInfo[1] = ICM_LENGTH_INDEFINITE;
        cbEncryptedContentInfo = 1;
    } else {
        cbEncryptedContentInfo = sizeof(abEncryptedContentInfo) - 1;
        ICM_GetLengthOctets(
                cbSize,
                abEncryptedContentInfo + 1,
                &cbEncryptedContentInfo);
    }

    // Queue the encoded header
    if (!ICMS_Output(
                pcmi,
                abEncryptedContentInfo,
                cbEncryptedContentInfo + 1,
                FALSE))
        goto OutputContentInfoError;
    if (!ICMS_Output(
                pcmi,
                pbEncodedContentType,
                cbEncodedContentType,
                FALSE))
        goto OutputContentTypeError;
    if (!ICMS_Output(
                pcmi,
                pbEncodedContentEncryptionAlgorithm,
                cbEncodedContentEncryptionAlgorithm,
                FALSE))
        goto OutputContentEncryptionAlgorithmError;
    if (!ICMS_Output(
                pcmi,
                abEncryptedContent,
                cbEncryptedContent + 1,
                FALSE))
        goto OutputEncryptedContentError;

    fRet = TRUE;
CommonReturn:
    PkiAsn1FreeEncoded(pEnc, pbEncodedContentType);
    PkiAsn1FreeEncoded(pEnc, pbEncodedContentEncryptionAlgorithm);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(EncodeObjectIdentifierError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR_VAR(EncodeContentEncryptionAlgorithmError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(ConvToObjectIdentifierError)            // error already set
TRACE_ERROR(OutputContentInfoError)                 // error already set
TRACE_ERROR(OutputContentTypeError)                 // error already set
TRACE_ERROR(OutputContentEncryptionAlgorithmError)  // error already set
TRACE_ERROR(OutputEncryptedContentError)            // error already set
}


//+-------------------------------------------------------------------------
//  Copy out the encoding of an OSS type.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_OutputEncoded(
    IN PCRYPT_MSG_INFO  pcmi,
    IN int              iPDU,
    IN OPTIONAL BYTE    bTag,
    IN PVOID            pv,
    IN BOOL             fFinal)
{
    BOOL                    fRet;
    DWORD                   dwError = ERROR_SUCCESS;
    ASN1error_e             Asn1Err;
    ASN1encoding_t          pEnc = ICM_GetEncoder();
    PBYTE                   pbEncoded = NULL;
    DWORD                   cbEncoded;

    if (0 != (Asn1Err = PkiAsn1Encode(
            pEnc,
            pv,
            iPDU,
            &pbEncoded,
            &cbEncoded)))
        goto EncodeError;

    if (bTag)
        pbEncoded[0] = bTag;         // poke in the right tag

    if (!ICMS_Output(pcmi, pbEncoded, cbEncoded, fFinal))
        goto OutputError;

    fRet = TRUE;
CommonReturn:
    PkiAsn1FreeEncoded(pEnc, pbEncoded);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(EncodeError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(OutputError)                // error already set
}


//+-------------------------------------------------------------------------
//  Create the buffer for an enveloped message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_CreateEnvelopedBuffer(
    IN PCRYPT_MSG_INFO  pcmi)
{
    DWORD       dwError = ERROR_SUCCESS;
    BOOL        fRet;
    PBYTE       pbBuffer = NULL;
    DWORD       cbBuffer;
    DWORD       cbAlloc;
    DWORD       cbBlockSize;
    BOOL        fBlockCipher;
    PICM_BUFFER pbuf = &pcmi->bufCrypt;

    if (!ICM_GetKeyBlockSize(
                pcmi->hkeyContentCrypt,
                &cbBlockSize,
                &fBlockCipher))
        goto GetEncryptBlockSizeError;

    pcmi->cbBlockSize  = cbBlockSize;
    pcmi->fBlockCipher = fBlockCipher;

    cbBuffer = min( cbBlockSize * CMSGP_STREAM_CRYPT_BLOCK_COUNT,
                    CMSGP_STREAM_MAX_ENCRYPT_BUFFER);
    if (fBlockCipher) {
        cbBuffer += cbBlockSize;
        cbBuffer -= cbBuffer % cbBlockSize; // make a multiple of block size
    }

    // Add one block for growth during encrypt, and to save during decrypt.
    cbAlloc = cbBuffer + 1 * cbBlockSize;
    // Block ciphers pad the ciphertext, and if the plaintext is a
    // multiple of the block size the padding is one block.
    if (NULL == (pbBuffer = (PBYTE)ICM_Alloc( cbAlloc)))
        goto AllocBufferError;
    pbuf->pbData = pbBuffer;
    pbuf->cbSize = cbBuffer;

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    ICM_Free( pbBuffer);
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetEncryptBlockSizeError)       // error already set
TRACE_ERROR(AllocBufferError)               // error already set
}




//+-------------------------------------------------------------------------
//  Encode and copy out the part of the data message up to the inner content.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_OpenToEncodeData(
    IN PCRYPT_MSG_INFO          pcmi)
{
    BOOL        fRet;
    DWORD       dwError = ERROR_SUCCESS;
    DWORD       cbData = pcmi->pStreamInfo->cbContent;

    if (pcmi->dwFlags & CMSG_BARE_CONTENT_FLAG) {
        BYTE bTag;

        if (CMSG_INDEFINITE_LENGTH == cbData)
            bTag = ICM_TAG_OCTETSTRING | ICM_TAG_CONSTRUCTED;
        else
            bTag = ICM_TAG_OCTETSTRING;

        // Output octet string
        if (!ICMS_OutputEncodedPrefix(
                    pcmi,
                    bTag,
                    cbData))
            goto OutputOctetStringError;
    } else {
        // Output ContentInfo
        if (!ICMS_OutputEncodedPrefixContentInfo(
                    pcmi,
                    NULL,
                    cbData))
            goto OutputContentInfoError;
    }

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutputContentInfoError)             // error already set
TRACE_ERROR(OutputOctetStringError)             // error already set
}


//+-------------------------------------------------------------------------
//  Encode and copy out the part of the data message after the inner content.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_UpdateEncodingData(
    IN PCRYPT_MSG_INFO  pcmi,
    IN PBYTE            pbData,
    IN DWORD            cbData,
    IN BOOL             fFinal)
{
    BOOL        fRet;
    DWORD       dwError = ERROR_SUCCESS;
    BOOL        fDefinite = (CMSG_INDEFINITE_LENGTH != pcmi->pStreamInfo->cbContent);
    DWORD       cNullPairs;

    pcmi->fStreamCallbackOutput = TRUE;                 // Enable the callback
    if (!fDefinite) {
        // The content is an indefinite-length octet string encoded by us,
        // so make each output chunk definite-length.
        if (!ICMS_OutputEncodedPrefix(
                    pcmi,
                    ICM_TAG_OCTETSTRING,
                    cbData))
            goto OutputOctetStringError;
    }
    if (!ICMS_Output( pcmi, pbData, cbData, fFinal && fDefinite))
        goto OutputError;
        
    if (fFinal && !fDefinite) {
        // End of indefinite-length encoding, so emit some NULL pairs
        cNullPairs = 1;                 // content
        if (0 == (pcmi->dwFlags & CMSG_BARE_CONTENT_FLAG))
            cNullPairs += 2;
        if (!ICMS_OutputNullPairs( pcmi, cNullPairs, TRUE))
            goto OutputNullPairsError;
    }

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutputOctetStringError)             // error already set
TRACE_ERROR(OutputError)                        // error already set
TRACE_ERROR(OutputNullPairsError)               // error already set
}


//+-------------------------------------------------------------------------
//  Encode and copy out the part of the signed message up to the inner content.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_OpenToEncodeSignedData(
    IN PCRYPT_MSG_INFO          pcmi,
    IN PCMSG_SIGNED_ENCODE_INFO psmei)
{
    BOOL        fRet;
    DWORD       dwError = ERROR_SUCCESS;
    SignedData  *psd = (SignedData *)pcmi->pvMsg;
    DWORD       cbData = pcmi->pStreamInfo->cbContent;
    LPSTR       pszInnerContentObjID = pcmi->pszInnerContentObjID;
    DWORD       cbSigned;
    DWORD       cbSignedDataContent;

    // Output ContentInfo, if appropriate
    if (CMSG_INDEFINITE_LENGTH == cbData) {
        cbSigned            = CMSG_INDEFINITE_LENGTH;
        cbSignedDataContent = CMSG_INDEFINITE_LENGTH;
    } else {
        if (INVALID_ENCODING_SIZE == (cbSigned = ICM_LengthSigned(
                psmei,
                pcmi->dwFlags,
                pszInnerContentObjID,
                cbData,
                &cbSignedDataContent)))
            goto LengthSignedError;
    }
    if (0 == (pcmi->dwFlags & CMSG_BARE_CONTENT_FLAG)) {
        if (!ICMS_OutputEncodedPrefixContentInfo(
                    pcmi,
                    szOID_RSA_signedData,
                    cbSigned))
            goto OutputContentInfoError;
    }
    if (!ICMS_OutputEncodedPrefix(
                pcmi,
                ICM_TAG_SEQ,
                cbSignedDataContent))
        goto OutputSignedDataError;

    // version
    if (!ICMS_OutputEncoded(
                pcmi,
                IntegerType_PDU,
                0,                          // bTag
                &psd->version,
                FALSE))
        goto OutputIntegerError;

    // digestAlgorithms
    if (!ICMS_OutputEncoded(
                pcmi,
                AlgorithmIdentifiers_PDU,
                0,                          // bTag
                &psd->digestAlgorithms,
                FALSE))
        goto OutputAlgorithmIdentifiersError;

    // contentInfo
    if (!ICMS_OutputEncodedPrefixContentInfo(
                pcmi,
                pcmi->pszInnerContentObjID,
                cbData,
                pcmi->dwFlags))
        goto OutputInnerContentInfoError;

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(LengthSignedError)                  // error already set
TRACE_ERROR(OutputContentInfoError)             // error already set
TRACE_ERROR(OutputSignedDataError)              // error already set
TRACE_ERROR(OutputIntegerError)                 // error already set
TRACE_ERROR(OutputAlgorithmIdentifiersError)    // error already set
TRACE_ERROR(OutputInnerContentInfoError)        // error already set
}


//+-------------------------------------------------------------------------
//  Encode and copy out the part of the signed message after the inner content.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_UpdateEncodingSignedData(
    IN PCRYPT_MSG_INFO  pcmi,
    IN PBYTE            pbData,
    IN DWORD            cbData,
    IN BOOL             fFinal)
{
    BOOL                fRet;
    DWORD               dwError = ERROR_SUCCESS;
    SignedData          *psd = (SignedData *)pcmi->pvMsg;
    PCMSG_STREAM_INFO   pcsi = pcmi->pStreamInfo;
    BOOL                fDefinite = (CMSG_INDEFINITE_LENGTH != pcsi->cbContent);
    DWORD               cNullPairs;

    if (pcmi->pszInnerContentObjID
#ifdef CMS_PKCS7
            && 0 == (pcmi->dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG)
#endif  // CMS_PKCS7
            ) {
        if (0 == (pcmi->aflStream & ICMS_PROCESS_CONTENT_DONE)) {
            if (!ICMS_HashContent( pcmi, pbData, cbData))
                goto HashContentError;
        }
    } else {
        if (!ICM_UpdateListDigest( pcmi->pHashList, pbData, cbData))
            goto UpdateDigestError;
    }

    pcmi->fStreamCallbackOutput = TRUE;             // Enable the callback
    if (0 == (pcmi->dwFlags & CMSG_DETACHED_FLAG)) {
        if (!fDefinite && (NULL == pcmi->pszInnerContentObjID
#ifdef CMS_PKCS7
                || (pcmi->dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG)
#endif  // CMS_PKCS7
                )) {
            // The content is an indefinite-length octet string encoded by us,
            // so make each output chunk definite-length.
            if (!ICMS_OutputEncodedPrefix(
                        pcmi,
                        ICM_TAG_OCTETSTRING,
                        cbData))
                goto OutputOctetStringError;
        }
        if (!ICMS_Output( pcmi, pbData, cbData, FALSE))
            goto OutputError;
    }
    // else
    //  detached => don't output the detached content to be hashed

    if (fFinal) {
        if (!fDefinite) {
            // End of indefinite-length encoding, so emit some NULL pairs
            cNullPairs = 1;                 // ContentInfo
            if (0 == (pcmi->dwFlags & CMSG_DETACHED_FLAG)) {
                cNullPairs++;               // [0] EXPLICIT
                if (NULL == pcmi->pszInnerContentObjID
#ifdef CMS_PKCS7
                        || (pcmi->dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG)
#endif  // CMS_PKCS7
                        )
                    cNullPairs++;       // We did the octet string encoding
            }
            // else
            //  detached => no content ([0] EXPLICIT)

            if (!ICMS_OutputNullPairs( pcmi, cNullPairs, FALSE))
                goto OutputNullPairsError;
        }

        if ((psd->bit_mask & certificates_present) &&
                    !ICMS_OutputEncoded(
                            pcmi,
                            SetOfAny_PDU,
                            ICM_TAG_CONSTRUCTED | ICM_TAG_CONTEXT_0,
                            &psd->certificates,
                            FALSE))
            goto OutputCertsError;

        if ((psd->bit_mask & crls_present) &&
                    !ICMS_OutputEncoded(
                            pcmi,
                            SetOfAny_PDU,
                            ICM_TAG_CONSTRUCTED | ICM_TAG_CONTEXT_1,
                            &psd->crls,
                            FALSE))
            goto OutputCrlsError;

#ifdef CMS_PKCS7
        if (pcmi->rgSignerEncodeDataInfo) {
            if (!ICM_FillSignerEncodeEncryptedDigests(
                            pcmi,
                            fDefinite))         // fMaxLength
                    goto FillSignerEncodeEncryptedDigestsError;
        }
#else
        if (pcmi->pHashList) {
            if (!ICM_FillSignerEncryptedDigest(
                            psd->signerInfos.value,
                            pcmi->pszInnerContentObjID,
                            pcmi->pHashList->Head(),
                            pcmi->dwKeySpec,
                            fDefinite))         // fMaxLength
                goto FillSignerEncryptedDigestError;
        }
#endif  // CMS_PKCS7

        if (!ICMS_OutputEncoded(
                            pcmi,
                            SignerInfos_PDU, 
                            0,                      // bTag
                            &psd->signerInfos,
                            fDefinite))
            goto OutputSignerInfosError;

        if (!fDefinite) {
            // End of indefinite-length encoding, so emit some NULL pairs
            cNullPairs = 1;         // SignedData
            if (0 == (pcmi->dwFlags & CMSG_BARE_CONTENT_FLAG))
                cNullPairs += 2;
            if (!ICMS_OutputNullPairs( pcmi, cNullPairs, TRUE))
                goto OutputNullPairsError;
        }
    }

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(HashContentError)                   // error already set
TRACE_ERROR(UpdateDigestError)                  // error already set
TRACE_ERROR(OutputOctetStringError)             // error already set
TRACE_ERROR(OutputError)                        // error already set
TRACE_ERROR(OutputCertsError)                   // error already set
TRACE_ERROR(OutputCrlsError)                    // error already set
#ifdef CMS_PKCS7
TRACE_ERROR(FillSignerEncodeEncryptedDigestsError)  // error already set
#else
TRACE_ERROR(FillSignerEncryptedDigestError)     // error already set
#endif  // CMS_PKCS7
TRACE_ERROR(OutputSignerInfosError)             // error already set
TRACE_ERROR(OutputNullPairsError)               // error already set
}

//+-------------------------------------------------------------------------
//  Encode and copy out the part of the enveloped message up to the inner
//  content.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_OpenToEncodeEnvelopedData(
    IN PCRYPT_MSG_INFO              pcmi,
    IN PCMSG_ENVELOPED_ENCODE_INFO  pemei)
{
    DWORD           dwError = ERROR_SUCCESS;
    BOOL            fRet;
#ifdef CMS_PKCS7
    CmsEnvelopedData   *ped = (CmsEnvelopedData *)pcmi->pvMsg;
#else
    EnvelopedData   *ped = (EnvelopedData *)pcmi->pvMsg;
#endif  // CMS_PKCS7
    DWORD           cbData = pcmi->pStreamInfo->cbContent;
    LPSTR           pszInnerContentObjID = pcmi->pszInnerContentObjID;
    DWORD           cbEnveloped;
    DWORD           cbEnvelopedDataContent;

    if (!ICMS_CreateEnvelopedBuffer( pcmi))
        goto CreateEnvelopedBufferError;

    // Output ContentInfo, if appropriate
    if (CMSG_INDEFINITE_LENGTH == cbData) {
        cbEnveloped            = CMSG_INDEFINITE_LENGTH;
        cbEnvelopedDataContent = CMSG_INDEFINITE_LENGTH;
    } else {
        // NOTE: for nonData, either encapsulated or cbData excludes the
        // outer tag and length octets.

        if (INVALID_ENCODING_SIZE == (cbEnveloped = ICM_LengthEnveloped(
                pemei,
                pcmi->dwFlags,
                pszInnerContentObjID,
                cbData,
                &cbEnvelopedDataContent)))
            goto LengthEnvelopedError;
    }
    if (0 == (pcmi->dwFlags & CMSG_BARE_CONTENT_FLAG)) {
        if (!ICMS_OutputEncodedPrefixContentInfo(
                    pcmi,
                    szOID_RSA_envelopedData,
                    cbEnveloped))
            goto OutputContentInfoError;
    }
    if (!ICMS_OutputEncodedPrefix(
                pcmi,
                ICM_TAG_SEQ,
                cbEnvelopedDataContent))
        goto OutputEnvelopedDataError;

    // version
    if (!ICMS_OutputEncoded(
                pcmi,
                IntegerType_PDU,
                0,                          // bTag
                &ped->version,
                FALSE))
        goto OutputIntegerError;

#ifdef CMS_PKCS7
    // originatorInfo OPTIONAL
    if (ped->bit_mask & originatorInfo_present) {
        if (!ICMS_OutputEncoded(
                pcmi,
                OriginatorInfo_PDU,
                ICM_TAG_CONSTRUCTED | ICM_TAG_CONTEXT_0,
                &ped->originatorInfo,
                FALSE))
            goto OutputOriginatorInfoError;
    }
#endif  // CMS_PKCS7

    // recipientInfos
    if (!ICMS_OutputEncoded(
                pcmi,
#ifdef CMS_PKCS7
                CmsRecipientInfos_PDU,
#else
                RecipientInfos_PDU,
#endif  // CMS_PKCS7
                0,                          // bTag
                &ped->recipientInfos,
                FALSE))
        goto OutputRecipientInfosError;

    // encryptedContentInfo
    if (!ICMS_OutputEncodedPrefixEncryptedContentInfo(
                pcmi,
                pcmi->pszInnerContentObjID,
                &ped->encryptedContentInfo.contentEncryptionAlgorithm,
                cbData))
        goto OutputInnerContentInfoError;

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(CreateEnvelopedBufferError)     // error already set
TRACE_ERROR(LengthEnvelopedError)           // error already set
TRACE_ERROR(OutputContentInfoError)         // error already set
TRACE_ERROR(OutputEnvelopedDataError)       // error already set
TRACE_ERROR(OutputIntegerError)             // error already set
#ifdef CMS_PKCS7
TRACE_ERROR(OutputOriginatorInfoError)      // error already set
#endif  // CMS_PKCS7
TRACE_ERROR(OutputRecipientInfosError)      // error already set
TRACE_ERROR(OutputInnerContentInfoError)    // error already set
}

//+-------------------------------------------------------------------------
//  Encrypt and copy out some bytes.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_EncodeEncryptAndOutput(
    IN PCRYPT_MSG_INFO  pcmi,
    IN const BYTE       *pbPlainOrg,
    IN DWORD            cbPlainOrg,
    IN BOOL             fFinal)
{
    DWORD       dwError = ERROR_SUCCESS;
    BOOL        fRet;
    BOOL        fDefinite = (CMSG_INDEFINITE_LENGTH != pcmi->pStreamInfo->cbContent);
    BOOL        fBlockCipher = pcmi->fBlockCipher;
    PICM_BUFFER pbufCrypt = &pcmi->bufCrypt;
    PBYTE       pbPlain;
    DWORD       cbPlainRemain;
    DWORD       cb;

    for (cbPlainRemain = cbPlainOrg, pbPlain = (PBYTE)pbPlainOrg;
            cbPlainRemain > 0;) {
        cb = min( cbPlainRemain, pbufCrypt->cbSize - pbufCrypt->cbUsed); // must fit
        CopyMemory(
                pbufCrypt->pbData  + pbufCrypt->cbUsed,
                pbPlain,
                cb);
        pbufCrypt->cbUsed  += cb;
        pbPlain            += cb;
        cbPlainRemain      -= cb;
        if (pbufCrypt->cbSize == pbufCrypt->cbUsed) {
            // Encrypt and copy out the buffer
            cb = pbufCrypt->cbSize;
            if (fBlockCipher) {
                // Leave the last block
                cb -= pcmi->cbBlockSize;
            }
            if (!CryptEncrypt(
                        pcmi->hkeyContentCrypt,
                        NULL,                           // hHash
                        FALSE,                          // fFinal
                        0,                              // dwFlags
                        pbufCrypt->pbData,
                        &cb,
                        pbufCrypt->cbSize + pcmi->cbBlockSize))
                goto EncryptError;
            if (!fDefinite) {
                // The ciphertext is indefinite-length, so make each
                // output chunk definite-length.
                if (!ICMS_OutputEncodedPrefix(
                            pcmi,
                            ICM_TAG_OCTETSTRING,
                            cb))
                    goto OutputOctetStringError;
            }
            if (!ICMS_Output(
                        pcmi,
                        pbufCrypt->pbData,
                        cb,
                        FALSE))                         // fFinal
                goto OutputError;

            if (fBlockCipher) {
                // Move the last block to the beginning of the buffer
                // and reset the count to start after this block.
                // Since we are sure the src and dst do not overlap,
                // use CopyMemory (faster than MoveMemory).
                cb = pbufCrypt->cbSize - pcmi->cbBlockSize;
                CopyMemory(
                    pbufCrypt->pbData,
                    pbufCrypt->pbData + cb,
                    pcmi->cbBlockSize);
                pbufCrypt->cbUsed = pcmi->cbBlockSize;
            } else {
                pbufCrypt->cbUsed = 0;
            }
        }
    }

    if (fFinal) {
#ifdef CMS_PKCS7
        CmsEnvelopedData *ped = (CmsEnvelopedData *)pcmi->pvMsg;
#else
        EnvelopedData *ped = (EnvelopedData *)pcmi->pvMsg;
#endif  // CMS_PKCS7

        if (cb = pbufCrypt->cbUsed) {
            if (!CryptEncrypt(
                        pcmi->hkeyContentCrypt,
                        NULL,                           // hHash
                        TRUE,                           // fFinal
                        0,                              // dwFlags
                        pbufCrypt->pbData,
                        &cb,
                        pbufCrypt->cbSize + pcmi->cbBlockSize))
                goto FinalEncryptError;
        }
        if (!fDefinite && cb) {
            // The ciphertext is indefinite-length, so make each
            // output chunk definite-length.
            if (!ICMS_OutputEncodedPrefix(
                        pcmi,
                        ICM_TAG_OCTETSTRING,
                        cb))
                goto OutputOctetStringError;
        }
        if (!ICMS_Output(
                    pcmi,
                    pbufCrypt->pbData,
                    cb,
                    fDefinite &&
                        0 == (ped->bit_mask & unprotectedAttrs_present) // fFinal
                    ))
            goto FinalOutputError;
    }

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(EncryptError)           // error already set
TRACE_ERROR(FinalEncryptError)      // error already set
TRACE_ERROR(OutputOctetStringError) // error already set
TRACE_ERROR(OutputError)            // error already set
TRACE_ERROR(FinalOutputError)       // error already set
}


//+-------------------------------------------------------------------------
//  Encode encrypt callback for octet string.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_EncryptCallback(
    IN const void       *pvArg,
    IN OUT PICM_BUFFER  pbuf,
    IN OUT PDWORD       pcbPending,
    IN BOOL             fFinal)
{
    DWORD       dwError = ERROR_SUCCESS;
    BOOL        fRet;
    PBYTE       pbData = pbuf->pbData + pbuf->cbDead;
    DWORD       cbData = min( *pcbPending, pbuf->cbUsed - pbuf->cbDead);

    if (!ICMS_EncodeEncryptAndOutput(
                (PCRYPT_MSG_INFO)pvArg,
                pbData,
                cbData,
                fFinal))
        goto EncodeEncryptAndOutputError;

    pbuf->cbDead += cbData;
    *pcbPending  -= cbData;

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(EncodeEncryptAndOutputError)        // error already set
}


//+-------------------------------------------------------------------------
//  Encode and copy out the part of the enveloped message after the inner content.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_UpdateEncodingEnvelopedData(
    IN PCRYPT_MSG_INFO  pcmi,
    IN const BYTE       *pbPlain,
    IN DWORD            cbPlain,
    IN BOOL             fFinal)
{
    DWORD       dwError = ERROR_SUCCESS;
    BOOL        fRet;
    BOOL        fDefinite = (CMSG_INDEFINITE_LENGTH != pcmi->pStreamInfo->cbContent);
    DWORD       cNullPairs;

    if (!pcmi->fStreamCallbackOutput) {
        pcmi->fStreamCallbackOutput = TRUE;             // Enable the callback
        if (!ICMS_Output( pcmi, NULL, 0, FALSE))        // Flush the header
            goto FlushOutputError;
    }

    if (pcmi->pszInnerContentObjID
#ifdef CMS_PKCS7
            && 0 == (pcmi->dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG)
#endif  // CMS_PKCS7
            ) {
        if (!ICMS_QueueToBuffer( &pcmi->bufEncode, (PBYTE)pbPlain, cbPlain))
            goto QueueToBufferError;

        if (!ICMS_ProcessStringContent(
                    &pcmi->bufEncode,
                    &pcmi->aflStream,
                    &pcmi->cbDefiniteRemain,
                    &pcmi->cLevelIndefiniteInner,
                    ICMS_EncryptCallback,
                    pcmi))
            goto ProcessContentError;
    } else {
        if (!ICMS_EncodeEncryptAndOutput(
                    pcmi,
                    pbPlain,
                    cbPlain,
                    fFinal))
            goto EncodeEncryptAndOutputError;
    }


    if (fFinal) {
#ifdef CMS_PKCS7
        CmsEnvelopedData *ped = (CmsEnvelopedData *)pcmi->pvMsg;
#else
        EnvelopedData *ped = (EnvelopedData *)pcmi->pvMsg;
#endif  // CMS_PKCS7

        if (!fDefinite) {
            // End of indefinite-length encoding, so emit some NULL pairs,
            // one each for encryptedContent, encryptedContentInfo
            if (!ICMS_OutputNullPairs( pcmi, 2, FALSE))
                goto OutputNullPairsError;
        }

        if (ped->bit_mask & unprotectedAttrs_present) {
#ifdef CMS_PKCS7
            if (!ICMS_OutputEncoded(
                    pcmi,
                    Attributes_PDU,
                    ICM_TAG_CONSTRUCTED | ICM_TAG_CONTEXT_1,
                    &ped->unprotectedAttrs,
                    fDefinite))         // fFinal
                goto OutputAttributesError;
#endif  // CMS_PKCS7
        }

        if (!fDefinite) {
            // End of indefinite-length encoding, so emit some NULL pairs
            cNullPairs = 1;         // EnvelopedData
            if (0 == (pcmi->dwFlags & CMSG_BARE_CONTENT_FLAG))
                cNullPairs += 2;
            if (!ICMS_OutputNullPairs( pcmi, cNullPairs, TRUE))
                goto OutputNullPairsError;
        }
    }

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(FlushOutputError)               // error already set
TRACE_ERROR(QueueToBufferError)             // error already set
TRACE_ERROR(ProcessContentError)            // error already set
TRACE_ERROR(EncodeEncryptAndOutputError)    // error already set
TRACE_ERROR(OutputNullPairsError)           // error already set
#ifdef CMS_PKCS7
TRACE_ERROR(OutputAttributesError)          // error already set
#endif  // CMS_PKCS7
}


//+-------------------------------------------------------------------------
//  Decode a PDU from the decode buffer.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodePDU(
    IN PCRYPT_MSG_INFO  pcmi,
    IN ASN1decoding_t   pDec,
    IN ASN1uint32_t     pdunum,
    OUT PVOID           *ppvPDU,
    OUT OPTIONAL PDWORD pcbConsumed = NULL)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    ASN1error_e         Asn1Err;
    PICM_BUFFER         pbuf = &pcmi->bufDecode;
    PVOID               pvPDU = NULL;
    DWORD               cbBufSizeOrg;
    PBYTE               pbData = pbuf->pbData + pbuf->cbDead;
    DWORD               cbData = pbuf->cbUsed - pbuf->cbDead;

#if DBG && defined(OSS_CRYPT_ASN1)
    DWORD   dwDecodingFlags;

    dwDecodingFlags = ossGetDecodingFlags((OssGlobal *) pDec);
    ossSetDecodingFlags( (OssGlobal *) pDec, RELAXBER); // turn off squirties
#endif

    cbBufSizeOrg = cbData;
    if (0 != (Asn1Err = PkiAsn1Decode2(
            pDec,
            &pvPDU,
            pdunum,
            &pbData,
            &cbData))) {
        if (ASN1_ERR_EOD != Asn1Err)
            goto DecodeError;
    }
#if DBG && defined(OSS_CRYPT_ASN1)
    ossSetDecodingFlags( (OssGlobal *) pDec, dwDecodingFlags);     // restore
#endif

    if (ASN1_ERR_EOD == Asn1Err ||
            (cbData > pbuf->cbUsed - pbuf->cbDead)) {
        PkiAsn1FreeInfo(pDec, pdunum, pvPDU);
        pvPDU = NULL;
        cbData = cbBufSizeOrg;
    }
    pbuf->cbDead += cbBufSizeOrg - cbData;
    if (pcbConsumed)
        *pcbConsumed = cbBufSizeOrg - cbData;

    fRet = TRUE;
CommonReturn:
    *ppvPDU = pvPDU;
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    if (pcbConsumed)
        *pcbConsumed = 0;
    pvPDU = NULL;
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(DecodeError, PkiAsn1ErrToHr(Asn1Err))
}


//+-------------------------------------------------------------------------
//  Decode a ContentInfo prefix
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodePrefixContentInfo(
    IN PCRYPT_MSG_INFO      pcmi,
    OUT ObjectIdentifierType **ppooidContentType,
    IN OUT PDWORD           pcTrailingNullPairs,
    IN OUT PDWORD           pafl,
    OUT BOOL                *pfNoContent)
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    ASN1decoding_t          pDec = ICM_GetDecoder();
    DWORD                   dwToken;

    // ContentInfo sequence, step into it
    if (0 == (*pafl & ICMS_DECODED_CONTENTINFO_SEQ)) {
        if (!ICMS_GetToken( &pcmi->bufDecode, &dwToken, &pcmi->cbContentInfo))
            goto ContentInfoGetTokenError;
        switch (dwToken) {
        case ICMS_TOKEN_INDEFINITE:     ++*pcTrailingNullPairs; break;
        case ICMS_TOKEN_DEFINITE:                               break;
        case ICMS_TOKEN_INCOMPLETE:     goto SuccessReturn;
        default:                        goto InvalidTokenError;
        }
        *pafl |= ICMS_DECODED_CONTENTINFO_SEQ;
    }

    // contentType, decode it
    if (NULL == *ppooidContentType) {
        DWORD cbConsumed;

        if (!ICMS_DecodePDU(
                pcmi,
                pDec,
                ObjectIdentifierType_PDU,
                (void **)ppooidContentType,
                &cbConsumed))
            goto DecodeContentTypeError;

        if (NULL != *ppooidContentType &&
                CMSG_INDEFINITE_LENGTH != pcmi->cbContentInfo &&
                cbConsumed == pcmi->cbContentInfo) {
            // Only has contentType. The optional content has
            // been omitted.
            *pfNoContent = TRUE;
            *pafl |= ICMS_DECODED_CONTENTINFO_CONTENT;
            goto SuccessReturn;
        }
    }
    if (NULL == *ppooidContentType)
        goto SuccessReturn;         // not enough data

    // [0] EXPLICIT, step into it
    if (0 == (*pafl & ICMS_DECODED_CONTENTINFO_CONTENT)) {
        if (CMSG_INDEFINITE_LENGTH == pcmi->cbContentInfo) {
            PICM_BUFFER pbuf = &pcmi->bufDecode;

            if (pbuf->cbUsed > pbuf->cbDead) {
                // Check for trailing Null Pairs (00, 00)
                if (ICM_TAG_NULL == *(pbuf->pbData + pbuf->cbDead)) {
                    // Only has contentType. The optional content has
                    // been omitted.
                    *pfNoContent = TRUE;
                    *pafl |= ICMS_DECODED_CONTENTINFO_CONTENT;
                    goto SuccessReturn;
                }
            } else
                goto SuccessReturn;         // not enough data
        }

        
        if (!ICMS_GetToken( &pcmi->bufDecode, &dwToken, NULL))
            goto ContentGetTokenError;
        switch (dwToken) {
        case ICMS_TOKEN_INDEFINITE:     ++*pcTrailingNullPairs; break;
        case ICMS_TOKEN_DEFINITE:                               break;
        case ICMS_TOKEN_INCOMPLETE:     goto SuccessReturn;
        default:                        goto InvalidTokenError;
        }
        *pfNoContent = FALSE;
        *pafl |= ICMS_DECODED_CONTENTINFO_CONTENT;
    }

SuccessReturn:
    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(DecodeContentTypeError)             // error already set
TRACE_ERROR(ContentGetTokenError)               // error already set
TRACE_ERROR(InvalidTokenError)                  // error already set
TRACE_ERROR(ContentInfoGetTokenError)           // error already set
}


//+-------------------------------------------------------------------------
//  Consume the NULL pairs which terminate the indefinite-length encoding.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_ConsumeTrailingNulls(
    IN PCRYPT_MSG_INFO  pcmi,
    IN OUT PDWORD       pcNullPairs,
    IN BOOL             fFinal)
{
    BOOL        fRet;
    DWORD       dwToken;

    for (; *pcNullPairs; (*pcNullPairs)--) {
        if (!ICMS_GetToken( &pcmi->bufDecode, &dwToken, NULL))
            goto GetTokenError;
        if ((ICMS_TOKEN_INCOMPLETE == dwToken) && !fFinal)
            goto SuccessReturn;
        if (ICMS_TOKEN_NULLPAIR != dwToken)
            goto WrongTokenError;
    }

SuccessReturn:
    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetTokenError)                      // error already set
TRACE_ERROR(WrongTokenError)                    // error already set
}


//+-------------------------------------------------------------------------
//  Handle incremental suffix data to be decoded, for a data message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodeSuffixData(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fFinal)
{
    BOOL                fRet;

    if (!ICMS_ConsumeTrailingNulls( pcmi, &pcmi->cEndNullPairs, fFinal))
        goto ConsumeTrailingNullsError;
    if (0 == pcmi->cEndNullPairs)
        pcmi->aflStream |= ICMS_DECODED_SUFFIX;

    if (fFinal && (pcmi->bufDecode.cbUsed > pcmi->bufDecode.cbDead))
        goto ExcessDataError;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(ConsumeTrailingNullsError)          // error already set
TRACE_ERROR(ExcessDataError)                    // error already set
}


//+-------------------------------------------------------------------------
//  Handle incremental suffix data to be decoded, for a signed message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodeSuffixSigned(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fFinal)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    ASN1decoding_t      pDec = ICM_GetDecoder();
    PSIGNED_DATA_INFO   psdi = pcmi->psdi;
    PICM_BUFFER         pbuf = &pcmi->bufDecode;
    CertificatesNC      *pCertificates = NULL;
    CrlsNC              *pCrls = NULL;
    SignerInfosNC       *pSignerInfos = NULL;
    Any                 *pAny;
    DWORD               i;

    if (!ICMS_ConsumeTrailingNulls( pcmi, &pcmi->cInnerNullPairs, fFinal))
        goto ConsumeInnerNullsError;
    if (pcmi->cInnerNullPairs)
        goto SuccessReturn;

    // certificates
    if (0 == (pcmi->aflDecode & ICMS_DECODED_SIGNED_CERTIFICATES)) {
        if (pbuf->cbUsed > pbuf->cbDead) {
            if (ICM_TAG_CONSTRUCTED_CONTEXT_0 ==
                                    *(pbuf->pbData + pbuf->cbDead)) {
                // Detected the [0] IMPLICIT indicating certificates.
                // Change the identifier octet so it will decode properly.
                *(pbuf->pbData + pbuf->cbDead) = ICM_TAG_SET;
                if (!ICMS_DecodePDU(
                        pcmi,
                        pDec,
                        CertificatesNC_PDU,
                        (void **)&pCertificates))
                    goto DecodeCertificatesError;
                if (pCertificates) {
                    for (i=pCertificates->count,
#ifdef OSS_CRYPT_ASN1
                                pAny=pCertificates->certificates;
#else
                                pAny=pCertificates->value;
#endif  // OSS_CRYPT_ASN1
                            i>0;
                            i--, pAny++) {
                        if (!ICM_InsertTailBlob( psdi->pCertificateList, pAny))
                            goto CertInsertTailBlobError;
                    }
                    pcmi->aflDecode |= ICMS_DECODED_SIGNED_CERTIFICATES;
                } else {
                    // The decode failed, presumably due to insufficient data.
                    // Restore the original tag, so we will enter this block
                    // and try again on the next call.
                    *(pbuf->pbData + pbuf->cbDead) = ICM_TAG_CONSTRUCTED_CONTEXT_0;
                }
            } else {
                // Certificates not present. Mark them as decoded.
                pcmi->aflDecode |= ICMS_DECODED_SIGNED_CERTIFICATES;
            }
        }
    }
    if (0 == (pcmi->aflDecode & ICMS_DECODED_SIGNED_CERTIFICATES))
        goto SuccessReturn;


    // crls
    if (0 == (pcmi->aflDecode & ICMS_DECODED_SIGNED_CRLS)) {
        if (pbuf->cbUsed > pbuf->cbDead) {
            if (ICM_TAG_CONSTRUCTED_CONTEXT_1 ==
                                    *(pbuf->pbData + pbuf->cbDead)) {
                // Detected the [1] IMPLICIT indicating crls.
                // Change the identifier octet so it will decode properly.
                *(pbuf->pbData + pbuf->cbDead) = ICM_TAG_SET;
                if (!ICMS_DecodePDU(
                        pcmi,
                        pDec,
                        CrlsNC_PDU,
                        (void **)&pCrls))
                    goto DecodeCrlsError;
                if (pCrls) {
                    for (i=pCrls->count,
#ifdef OSS_CRYPT_ASN1
                                pAny=pCrls->crls;
#else
                                pAny=pCrls->value;
#endif  // OSS_CRYPT_ASN1
                            i>0;
                            i--, pAny++) {
                        if (!ICM_InsertTailBlob( psdi->pCrlList, pAny))
                            goto CrlInsertTailBlobError;
                    }
                    pcmi->aflDecode |= ICMS_DECODED_SIGNED_CRLS;
                } else {
                    // The decode failed, presumably due to insufficient data.
                    // Restore the original tag, so we will enter this block
                    // and try again on the next call.
                    *(pbuf->pbData + pbuf->cbDead) = ICM_TAG_CONSTRUCTED_CONTEXT_1;
                }
            } else {
                // Crls not present. Mark them as decoded.
                pcmi->aflDecode |= ICMS_DECODED_SIGNED_CRLS;
            }
        }
    }
    if (0 == (pcmi->aflDecode & ICMS_DECODED_SIGNED_CRLS))
        goto SuccessReturn;


    // signerInfos
    if (0 == (pcmi->aflDecode & ICMS_DECODED_SIGNED_SIGNERINFOS)) {
        if (!ICMS_DecodePDU(
                pcmi,
                pDec,
                SignerInfosNC_PDU,
                (void **)&pSignerInfos))
            goto DecodeSignerInfosError;
        if (pSignerInfos) {
            for (i=pSignerInfos->count, pAny=pSignerInfos->value;
                    i>0;
                    i--, pAny++) {
                if (!ICM_InsertTailSigner( psdi->pSignerList, pAny))
                    goto SignerInfoInsertTailBlobError;
            }
            pcmi->aflDecode |= ICMS_DECODED_SIGNED_SIGNERINFOS;
        }
    }
    if (0 == (pcmi->aflDecode & ICMS_DECODED_SIGNED_SIGNERINFOS))
        goto SuccessReturn;

    if (!ICMS_ConsumeTrailingNulls( pcmi, &pcmi->cEndNullPairs, fFinal))
        goto ConsumeEndNullsError;
    if (0 == pcmi->cEndNullPairs)
        pcmi->aflStream |= ICMS_DECODED_SUFFIX;

SuccessReturn:
    fRet = TRUE;
CommonReturn:
    PkiAsn1FreeInfo( pDec, CertificatesNC_PDU, pCertificates);
    PkiAsn1FreeInfo( pDec, CrlsNC_PDU, pCrls);
    PkiAsn1FreeInfo( pDec, SignerInfosNC_PDU, pSignerInfos);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(ConsumeInnerNullsError)            // error already set
TRACE_ERROR(DecodeCertificatesError)           // error already set
TRACE_ERROR(CertInsertTailBlobError)           // error already set
TRACE_ERROR(DecodeCrlsError)                   // error already set
TRACE_ERROR(CrlInsertTailBlobError)            // error already set
TRACE_ERROR(DecodeSignerInfosError)            // error already set
TRACE_ERROR(SignerInfoInsertTailBlobError)     // error already set
TRACE_ERROR(ConsumeEndNullsError)              // error already set
}


//+-------------------------------------------------------------------------
//  Handle incremental suffix data to be decoded, for an enveloped message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodeSuffixEnveloped(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fFinal)
{
    BOOL                fRet;
    ASN1decoding_t      pDec = ICM_GetDecoder();
    PICM_BUFFER         pbuf = &pcmi->bufDecode;
    Attributes          *pAttributes = NULL;
#ifdef CMS_PKCS7
    CmsEnvelopedData    *ped = (CmsEnvelopedData *)pcmi->pvMsg;
#endif  // CMS_PKCS7
    OSS_DECODE_INFO     odi;
    COssDecodeInfoNode  *pnOssDecodeInfo;

    if (!ICMS_ConsumeTrailingNulls( pcmi, &pcmi->cInnerNullPairs, fFinal))
        goto ConsumeInnerNullsError;
    if (pcmi->cInnerNullPairs)
        goto SuccessReturn;

    // unprotectedAttrs[1] IMPLICIT UnprotectedAttributes OPTIONAL
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_ATTR)) {
        if (pbuf->cbUsed > pbuf->cbDead) {
            if (ICM_TAG_CONSTRUCTED_CONTEXT_1 ==
                                    *(pbuf->pbData + pbuf->cbDead)) {
                // Detected the [1] IMPLICIT indicating unprotectedAttrs.
                // Change the identifier octet so it will decode properly.
                *(pbuf->pbData + pbuf->cbDead) = ICM_TAG_SET;

                if (!ICMS_DecodePDU(
                        pcmi,
                        pDec,
                        Attributes_PDU,
                        (void **)&pAttributes))
                    goto DecodeAttributesError;
                if (pAttributes) {
#ifdef CMS_PKCS7
                    ped->unprotectedAttrs = *pAttributes;
                    ped->bit_mask |= unprotectedAttrs_present;
#endif  // CMS_PKCS7
                    odi.iPDU  = Attributes_PDU;
                    odi.pvPDU = pAttributes;
                    if (NULL == (pnOssDecodeInfo =
                            new COssDecodeInfoNode( &odi))) {
                        PkiAsn1FreeInfo( pDec, odi.iPDU, odi.pvPDU);
                        goto NewOssDecodeInfoNodeError;
                    }
                    pcmi->aflDecode |= ICMS_DECODED_ENVELOPED_ATTR;
                    pcmi->plDecodeInfo->InsertTail( pnOssDecodeInfo);
                } else {
                    // The decode failed, presumably due to insufficient data.
                    // Restore the original tag, so we will enter this block
                    // and try again on the next call.
                    *(pbuf->pbData + pbuf->cbDead) =
                        ICM_TAG_CONSTRUCTED_CONTEXT_1;
                }
            } else {
                // unprotectedAttrs not present. Mark them as decoded.
                pcmi->aflDecode |= ICMS_DECODED_ENVELOPED_ATTR;
            }
        } else if (fFinal)
            // unprotectedAttrs not present. Mark them as decoded.
            pcmi->aflDecode |= ICMS_DECODED_ENVELOPED_ATTR;

    }
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_ATTR))
        goto SuccessReturn;


    if (!ICMS_ConsumeTrailingNulls( pcmi, &pcmi->cEndNullPairs, fFinal))
        goto ConsumeEndNullsError;
    if (0 == pcmi->cEndNullPairs)
        pcmi->aflStream |= ICMS_DECODED_SUFFIX;
SuccessReturn:
    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(ConsumeInnerNullsError)            // error already set
TRACE_ERROR(DecodeAttributesError)             // error already set
TRACE_ERROR(NewOssDecodeInfoNodeError)         // error already set
TRACE_ERROR(ConsumeEndNullsError)              // error already set

}


//+-------------------------------------------------------------------------
//  Handle incremental suffix data to be decoded.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodeSuffix(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fFinal)
{
    DWORD       dwError = ERROR_SUCCESS;
    BOOL        fRet;

    switch (pcmi->dwMsgType) {
    case CMSG_DATA:
        fRet = ICMS_DecodeSuffixData( pcmi, fFinal);
        break;
    case CMSG_SIGNED:
        fRet = ICMS_DecodeSuffixSigned( pcmi, fFinal);
        break;
    case CMSG_ENVELOPED:
        fRet = ICMS_DecodeSuffixEnveloped( pcmi, fFinal);
        break;
    case CMSG_HASHED:
        // fRet = ICMS_DecodeSuffixDigested( pcmi, fFinal);
        // break;
    case CMSG_SIGNED_AND_ENVELOPED:
    case CMSG_ENCRYPTED:
        goto MessageTypeNotSupportedYet;
    default:
        goto InvalidMsgType;
    }

    if (!fRet)
        goto ErrorReturn;

CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(MessageTypeNotSupportedYet,CRYPT_E_INVALID_MSG_TYPE)
TRACE_ERROR(InvalidMsgType)                     // error already set
}


//+-------------------------------------------------------------------------
//  Decrypt and output pending decode data.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodeDecryptAndOutput(
    IN PCRYPT_MSG_INFO  pcmi,
    IN OUT PICM_BUFFER  pbufDecode,
    IN OUT PDWORD       pcbPending,
    IN BOOL             fFinal)
{
    DWORD       dwError = ERROR_SUCCESS;
    BOOL        fRet;
    BOOL        fBlockCipher = pcmi->fBlockCipher;
    PICM_BUFFER pbufCrypt  = &pcmi->bufCrypt;
    DWORD       cbCipher;
    DWORD       cb;

    for (cbCipher = min( *pcbPending, pbufDecode->cbUsed - pbufDecode->cbDead);
            cbCipher > 0;) {
        cb = min( cbCipher, pbufCrypt->cbSize - pbufCrypt->cbUsed); // must fit
        CopyMemory(
                pbufCrypt->pbData  + pbufCrypt->cbUsed,
                pbufDecode->pbData + pbufDecode->cbDead,
                cb);
        pbufCrypt->cbUsed  += cb;
        pbufDecode->cbDead += cb;
        *pcbPending        -= cb;
        cbCipher           -= cb;
        if (pbufCrypt->cbSize == pbufCrypt->cbUsed) {
            // Decrypt and copy out the buffer
            cb = pbufCrypt->cbSize;
            if (fBlockCipher) {
                // Keep the last block
                cb -= pcmi->cbBlockSize;
            }
            if (!CryptDecrypt(
                        pcmi->hkeyContentCrypt,
                        NULL,                           // hHash
                        FALSE,                          // fFinal
                        0,                              // dwFlags
                        pbufCrypt->pbData,
                        &cb))
                goto DecryptError;
            if (!ICMS_Output(
                        pcmi,
                        pbufCrypt->pbData,
                        cb,
                        FALSE))                         // fFinal
                goto OutputError;

            if (fBlockCipher) {
                // Move the last block to the beginning of the buffer
                // and reset the count to start after this block.
                // Since we are sure the src and dst do not overlap,
                // use CopyMemory (faster than MoveMemory).
                cb = pbufCrypt->cbSize - pcmi->cbBlockSize;
                CopyMemory(
                    pbufCrypt->pbData,
                    pbufCrypt->pbData + cb,
                    pcmi->cbBlockSize);
                pbufCrypt->cbUsed = pcmi->cbBlockSize;
            } else {
                pbufCrypt->cbUsed = 0;
            }
        }
    }

    if (fFinal) {
        if (cb = pbufCrypt->cbUsed) {
            if (!CryptDecrypt(
                        pcmi->hkeyContentCrypt,
                        NULL,                           // hHash
                        TRUE,                           // fFinal
                        0,                              // dwFlags
                        pbufCrypt->pbData,
                        &cb))
                goto FinalDecryptError;
        }
        if (!ICMS_Output(
                    pcmi,
                    pbufCrypt->pbData,
                    cb,
                    TRUE))                          // fFinal
            goto FinalOutputError;
    }

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(DecryptError)           // error already set
TRACE_ERROR(FinalDecryptError)      // error already set
TRACE_ERROR(OutputError)            // error already set
TRACE_ERROR(FinalOutputError)       // error already set
}

//+-------------------------------------------------------------------------
//  Given a key for decryption, prepare for the decryption to proceed.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_SetDecryptKey(
    IN PCRYPT_MSG_INFO  pcmi,
    IN HCRYPTKEY        hkeyDecrypt)
{
    BOOL            fRet;
    DWORD           cbPending;
    PICM_BUFFER     pbufPendingCrypt  = &pcmi->bufPendingCrypt;

    if (pcmi->hkeyContentCrypt) {
        SetLastError((DWORD) CRYPT_E_ALREADY_DECRYPTED);
        return FALSE;
    }

    pcmi->hkeyContentCrypt = hkeyDecrypt;

    if (!ICMS_CreateEnvelopedBuffer( pcmi))
        goto CreateEnvelopedBufferError;
    pcmi->bufCrypt.cbSize += pcmi->cbBlockSize; // use whole thing for decode

    // Decrypt any pending ciphertext
    cbPending = pbufPendingCrypt->cbUsed - pbufPendingCrypt->cbDead;
    if (!ICMS_DecodeDecryptAndOutput(
            pcmi,
            pbufPendingCrypt,
            &cbPending,
            0 != (pcmi->aflStream & (ICMS_DECODED_CONTENT | ICMS_FINAL))))
        goto DecryptAndOutputError;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    pcmi->hkeyContentCrypt = 0;             // caller closes hkeyDecrypt on
                                            // error
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(CreateEnvelopedBufferError)     // error already set
TRACE_ERROR(DecryptAndOutputError)          // error already set
}


//+-------------------------------------------------------------------------
//  Decode callback.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodeCallback(
    IN const void       *pvArg,
    IN OUT PICM_BUFFER  pbuf,
    IN OUT PDWORD       pcbPending,
    IN BOOL             fFinal)
{
    DWORD           dwError = ERROR_SUCCESS;
    BOOL            fRet;
    PCRYPT_MSG_INFO pcmi = (PCRYPT_MSG_INFO)pvArg;
    PBYTE           pbData = pbuf->pbData + pbuf->cbDead;
    DWORD           cbData = min( *pcbPending, pbuf->cbUsed - pbuf->cbDead);

    if (CMSG_ENVELOPED == pcmi->dwMsgType) {
        if (NULL == pcmi->hkeyContentCrypt) {
            // Allow ciphertext to pile up until the decrypt key is set via
            // CryptMsgControl(... CMSG_CTRL_DECRYPT ...)
            if (!ICMS_QueueToBuffer(&pcmi->bufPendingCrypt, pbData, cbData))
                goto QueuePendingCryptError;

            pbuf->cbDead += cbData;
            *pcbPending  -= cbData;
        } else if (!ICMS_DecodeDecryptAndOutput(
                    pcmi,
                    pbuf,
                    pcbPending,
                    fFinal))
            goto DecryptAndOutputError;
    } else {
        if (cbData && pcmi->pHashList) {
            if (!ICM_UpdateListDigest( pcmi->pHashList, pbData, cbData))
                goto UpdateDigestError;
        }

        pbuf->cbDead += cbData;
        *pcbPending  -= cbData;
        if (!ICMS_Output( pcmi, pbData, cbData, fFinal))
            goto OutputError;
    }

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(QueuePendingCryptError)         // error already set
TRACE_ERROR(DecryptAndOutputError)          // error already set
TRACE_ERROR(UpdateDigestError)              // error already set
TRACE_ERROR(OutputError)                    // error already set
}


//+-------------------------------------------------------------------------
//  Hash callback.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_HashCallback(
    IN const void       *pvArg,
    IN OUT PICM_BUFFER  pbuf,
    IN OUT PDWORD       pcbPending,
    IN BOOL             fFinal)
{
    DWORD           dwError = ERROR_SUCCESS;
    BOOL            fRet;
    PBYTE           pbData = pbuf->pbData + pbuf->cbDead;
    DWORD           cbData = min( *pcbPending, pbuf->cbUsed - pbuf->cbDead);

    if (pvArg) {
        if (!ICM_UpdateListDigest( (CHashList *)pvArg, pbData, cbData))
            goto UpdateDigestError;
    }

    pbuf->cbDead += cbData;
    *pcbPending  -= cbData;

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(UpdateDigestError)               // error already set
fFinal;
}


//+-------------------------------------------------------------------------
//  Hash incremental content data to be encoded, for an octet string.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_HashContent(
    IN PCRYPT_MSG_INFO  pcmi,
    IN PBYTE            pbData,
    IN DWORD            cbData)
{
    BOOL        fRet;

    if (!ICMS_QueueToBuffer( &pcmi->bufEncode, (PBYTE)pbData, cbData))
        goto QueueToBufferError;

    if (!ICMS_ProcessStringContent(
                &pcmi->bufEncode,
                &pcmi->aflStream,
                &pcmi->cbDefiniteRemain,
                &pcmi->cLevelIndefiniteInner,
                ICMS_HashCallback,
                pcmi->pHashList))
        goto ProcessStringContentError;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(QueueToBufferError)                // error already set
TRACE_ERROR(ProcessStringContentError)         // error already set
}


//+-------------------------------------------------------------------------
//  Handle incremental content data to be decoded, for an octet string.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodeContentOctetString(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fFinal)
{
    BOOL        fRet;

    if (!ICMS_ProcessStringContent(
                &pcmi->bufDecode,
                &pcmi->aflStream,
                &pcmi->cbDefiniteRemain,
                &pcmi->cLevelIndefiniteInner,
                ICMS_DecodeCallback,
                pcmi))
        goto ProcessStringContentError;

    if (pcmi->aflStream & ICMS_PROCESS_CONTENT_DONE)
        pcmi->aflStream |= ICMS_DECODED_CONTENT;

    if (fFinal &&
            (pcmi->cbDefiniteRemain ||
             pcmi->cLevelIndefiniteInner ||
             (0 == (pcmi->aflStream & ICMS_DECODED_CONTENT)))) {
        goto PrematureFinalError;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(PrematureFinalError,CRYPT_E_STREAM_INSUFFICIENT_DATA)
TRACE_ERROR(ProcessStringContentError)         // error already set
}


//+-------------------------------------------------------------------------
//  Handle incremental content data to be decoded, for a sequence.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodeContentSequence(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fFinal)
{
    BOOL        fRet;
    PICM_BUFFER pbuf = &pcmi->bufDecode;
    PBYTE       pbData = pbuf->pbData + pbuf->cbDead;
    DWORD       cbData = pbuf->cbUsed - pbuf->cbDead;
    LONG        lSkipped;
    DWORD       cbContent;
    const BYTE  *pbContent;

    if (pcmi->aflStream & ICMS_PROCESS_CONTENT_BEGUN)
        goto MultipleContentSequenceError;

    // Get the tag and length for the inner content
    if (0 > (lSkipped = Asn1UtilExtractContent(
                        pbData,
                        cbData,
                        &cbContent,
                        &pbContent))) {
        if (ASN1UTIL_INSUFFICIENT_DATA != lSkipped)
            goto ExtractContentError;
        else
            goto SuccessReturn;
    }

    if (CMSG_INDEFINITE_LENGTH == cbContent)
        goto IndefiniteLengthInnerContentNotImplemented;

    // Output the tag and length octets for the encoded inner content.
    // Note, not included in the content to be verified in a signature.
    if (!ICMS_Output( pcmi, pbData, (DWORD) lSkipped, FALSE))
        goto OutputError;

    pcmi->aflStream |= ICMS_INNER_OCTETSTRING;
    // Decode as an octet string. Will skip the tag and length octets
    fRet = ICMS_DecodeContentOctetString(pcmi, fFinal);

CommonReturn:
    return fRet;

SuccessReturn:
    fRet = TRUE;
    goto CommonReturn;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(MultipleContentSequenceError, CRYPT_E_MSG_ERROR)
TRACE_ERROR(ExtractContentError)
SET_ERROR(IndefiniteLengthInnerContentNotImplemented, E_NOTIMPL)
TRACE_ERROR(OutputError)
}


//+-------------------------------------------------------------------------
//  Handle incremental prefix data to be decoded.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodeContent(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fFinal)
{
    DWORD       dwError = ERROR_SUCCESS;
    BOOL        fRet;
    PICM_BUFFER pbuf = &pcmi->bufDecode;

    if (pcmi->aflStream & ICMS_RAW_DATA) {
        // Should be able to skip bufDecode for this case.
        if (!ICMS_Output(
                pcmi,
                pbuf->pbData + pbuf->cbDead,
                pbuf->cbUsed - pbuf->cbDead,
                fFinal))
            goto RawOutputError;
        pbuf->cbDead = pbuf->cbUsed;

        if (fFinal)
            pcmi->aflStream |= ICMS_DECODED_CONTENT | ICMS_DECODED_SUFFIX;

    } else if (pcmi->aflStream & ICMS_INNER_OCTETSTRING) {
        if (!ICMS_DecodeContentOctetString( pcmi, fFinal))
            goto DecodeContentOctetStringError;

    } else {
        if (!ICMS_DecodeContentSequence( pcmi, fFinal))
            goto DecodeContentSequenceError;
    }

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(RawOutputError)                     // error already set
TRACE_ERROR(DecodeContentOctetStringError)      // error already set
TRACE_ERROR(DecodeContentSequenceError)         // error already set
}


//+-------------------------------------------------------------------------
//  Handle incremental prefix data to be decoded, for a data message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodePrefixData(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fFinal)
{
    if (0 ==(pcmi->aflStream & ICMS_NONBARE))
        pcmi->aflStream |= ICMS_RAW_DATA;
    pcmi->aflStream |= ICMS_DECODED_PREFIX | ICMS_INNER_OCTETSTRING;
    return TRUE;
}


//+-------------------------------------------------------------------------
//  Handle incremental prefix data to be decoded, for a signed message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodePrefixSigned(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fFinal)
{
    DWORD                           dwError = ERROR_SUCCESS;
    BOOL                            fRet;
    ASN1decoding_t                  pDec = ICM_GetDecoder();
    PSIGNED_DATA_INFO               psdi = pcmi->psdi;
    DWORD                           dwToken;
    int                             *piVersion = NULL;
    DigestAlgorithmIdentifiersNC    *pDigestAlgorithms = NULL;
    Any                             *pAny;
    DWORD                           cb;
    DWORD                           i;
    BOOL                            fNoContent;

    if (NULL == psdi) {
        if (NULL == (psdi = (PSIGNED_DATA_INFO)ICM_AllocZero(
                                sizeof(SIGNED_DATA_INFO))))
            goto SdiAllocError;
        pcmi->psdi = psdi;

        if (NULL == (psdi->pAlgidList = new CBlobList))
            goto NewAlgidListError;
        if (NULL == (psdi->pCertificateList = new CBlobList))
            goto NewCertificateListError;
        if (NULL == (psdi->pCrlList = new CBlobList))
            goto NewCrlListError;
        if (NULL == (psdi->pSignerList = new CSignerList))
            goto NewSignerListError;
    }

    // SignedData sequence
    if (0 == (pcmi->aflDecode & ICMS_DECODED_SIGNED_SEQ)) {
        if (!ICMS_GetToken( &pcmi->bufDecode, &dwToken, NULL))
            goto GetTokenError;
        switch(dwToken) {
        case ICMS_TOKEN_INDEFINITE:     pcmi->cEndNullPairs++; break;
        case ICMS_TOKEN_DEFINITE:                              break;
        case ICMS_TOKEN_INCOMPLETE:     goto SuccessReturn;
        default:                        goto InvalidTokenError;
        }
        pcmi->aflDecode |= ICMS_DECODED_SIGNED_SEQ;
    }
    if (0 == (pcmi->aflDecode & ICMS_DECODED_SIGNED_SEQ))
        goto SuccessReturn;


    // version
    if (0 == (pcmi->aflDecode & ICMS_DECODED_SIGNED_VERSION)) {
        if (!ICMS_DecodePDU(
                pcmi,
                pDec,
                IntegerType_PDU,
                (void **)&piVersion))
            goto DecodeVersionError;
        if (piVersion) {
            psdi->version = *piVersion;
            pcmi->aflDecode |= ICMS_DECODED_SIGNED_VERSION;
        }
    }
    if (0 == (pcmi->aflDecode & ICMS_DECODED_SIGNED_VERSION))
        goto SuccessReturn;


    // digestAlgorithms
    if (0 == (pcmi->aflDecode & ICMS_DECODED_SIGNED_DIGESTALGOS)) {
        if (!ICMS_DecodePDU(
                pcmi,
                pDec,
                DigestAlgorithmIdentifiersNC_PDU,
                (void **)&pDigestAlgorithms))
            goto DecodeDigestAlgorithmsError;
        if (pDigestAlgorithms) {
            for (i=pDigestAlgorithms->count, pAny=pDigestAlgorithms->value;
                    i>0;
                    i--, pAny++) {
                if (!ICM_InsertTailBlob( psdi->pAlgidList, pAny))
                    goto DigestAlgorithmInsertTailBlobError;
            }
            // We have the algorithms. Now create the hash handles.
            if (!ICM_CreateHashList(
                    pcmi->hCryptProv,
                    &pcmi->pHashList,
                    pcmi->psdi->pAlgidList))
                goto CreateHashListError;
            pcmi->aflDecode |= ICMS_DECODED_SIGNED_DIGESTALGOS;
        }
    }
    if (0 == (pcmi->aflDecode & ICMS_DECODED_SIGNED_DIGESTALGOS))
        goto SuccessReturn;


    // contentInfo
    if (0 == (pcmi->aflDecode & ICMS_DECODED_SIGNED_CONTENTINFO)) {
        if (!ICMS_DecodePrefixContentInfo(
                    pcmi,
                    &pcmi->pooid,
                    &pcmi->cInnerNullPairs,
                    &pcmi->aflInner,
                    &fNoContent))
            goto DecodePrefixSignedContentInfoError;
        if (pcmi->aflInner & ICMS_DECODED_CONTENTINFO_CONTENT) {
            // We cracked the whole header.
            // Translate the inner contentType oid into a string.
            if (!PkiAsn1FromObjectIdentifier(
                    pcmi->pooid->count,
                    pcmi->pooid->value,
                    NULL,
                    &cb))
                goto PkiAsn1FromObjectIdentifierSizeError;
            if (NULL == (psdi->pci = (PCONTENT_INFO)ICM_Alloc(
                                        cb + INFO_LEN_ALIGN(sizeof(CONTENT_INFO)))))
                goto AllocContentInfoError;
            psdi->pci->pszContentType = (LPSTR)(psdi->pci) +
                                        INFO_LEN_ALIGN(sizeof(CONTENT_INFO));
            psdi->pci->content.cbData = 0;
            psdi->pci->content.pbData = NULL;
            if (!PkiAsn1FromObjectIdentifier(
                    pcmi->pooid->count,
                    pcmi->pooid->value,
                    psdi->pci->pszContentType,
                    &cb))
                goto PkiAsn1FromObjectIdentifierError;
            PkiAsn1FreeDecoded(pDec, pcmi->pooid, ObjectIdentifierType_PDU);
            pcmi->pooid = NULL;
            pcmi->aflDecode |= ICMS_DECODED_SIGNED_CONTENTINFO;

            if (fNoContent) {
                // No content. Output final flag with no content.
                if (!ICMS_Output(pcmi, NULL, 0, TRUE))
                    goto OutputError;
                pcmi->aflStream |= ICMS_DECODED_CONTENT;
            } else {
                if (0 == strcmp( psdi->pci->pszContentType, pszObjIdDataType)
#ifdef CMS_PKCS7
                        || psdi->version >= CMSG_SIGNED_DATA_V3 
#endif  // CMS_PKCS7
                        )
                    pcmi->aflStream |= ICMS_INNER_OCTETSTRING;
            }
            pcmi->aflStream |= ICMS_DECODED_PREFIX;
        }
    }

SuccessReturn:
    fRet = TRUE;
CommonReturn:
    PkiAsn1FreeInfo( pDec, IntegerType_PDU, piVersion);
    PkiAsn1FreeInfo( pDec, DigestAlgorithmIdentifiersNC_PDU, pDigestAlgorithms);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    // note, pcmi->psdi and pcmi->pooid are freed in CryptMsgClose
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(SdiAllocError)                              // error already set
TRACE_ERROR(NewAlgidListError)                          // error already set
TRACE_ERROR(NewCertificateListError)                    // error already set
TRACE_ERROR(NewCrlListError)                            // error already set
TRACE_ERROR(NewSignerListError)                         // error already set
TRACE_ERROR(GetTokenError)                              // error already set
TRACE_ERROR(InvalidTokenError)                          // error already set
TRACE_ERROR(DecodeVersionError)                         // error already set
TRACE_ERROR(DecodeDigestAlgorithmsError)                // error already set
TRACE_ERROR(DigestAlgorithmInsertTailBlobError)         // error already set
TRACE_ERROR(CreateHashListError)                        // error already set
TRACE_ERROR(DecodePrefixSignedContentInfoError)         // error already set
TRACE_ERROR(PkiAsn1FromObjectIdentifierSizeError)       // error already set
TRACE_ERROR(AllocContentInfoError)                      // error already set
TRACE_ERROR(PkiAsn1FromObjectIdentifierError)           // error already set
TRACE_ERROR(OutputError)                                // error already set
}

//+-------------------------------------------------------------------------
//  Handle incremental prefix data to be decoded, for an enveloped message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodePrefixEnveloped(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fFinal)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    ASN1decoding_t      pDec = ICM_GetDecoder();
    PICM_BUFFER         pbuf = &pcmi->bufDecode;
#ifdef CMS_PKCS7
    CmsEnvelopedData    *ped = (CmsEnvelopedData *)pcmi->pvMsg;
#else
    EnvelopedData       *ped = (EnvelopedData *)pcmi->pvMsg;
#endif  // CMS_PKCS7
    DWORD               dwToken;
    int                 *piVersion = NULL;
#ifdef CMS_PKCS7
    CmsRecipientInfos   *pRecipientInfos = NULL;
#else
    RecipientInfos      *pRecipientInfos = NULL;
#endif  // CMS_PKCS7
    ObjectIdentifierType *pooidContentType = NULL;
    AlgorithmIdentifier *poaidContentEncryption = NULL;
    COssDecodeInfoNode  *pnOssDecodeInfo;
    OSS_DECODE_INFO     odi;
    DWORD               cbConsumed;

#ifdef CMS_PKCS7
    OriginatorInfoNC    *pOriginatorInfo = NULL;
    Any                 *pAny;
    DWORD               i;
#endif  // CMS_PKCS7

    if (NULL == ped) {
#ifdef CMS_PKCS7
        if (NULL == (ped = (CmsEnvelopedData *)ICM_AllocZero(
                                sizeof(CmsEnvelopedData))))
#else
        if (NULL == (ped = (EnvelopedData *)ICM_AllocZero(
                                sizeof(EnvelopedData))))
#endif  // CMS_PKCS7
            goto AllocEnvelopedDataError;
        pcmi->pvMsg = ped;
        if (NULL == (pcmi->plDecodeInfo = new COssDecodeInfoList))
            goto NewCOssDecodeInfoListError;

#ifdef CMS_PKCS7
        if (NULL == (pcmi->pCertificateList = new CBlobList))
            goto NewCertificateListError;
        if (NULL == (pcmi->pCrlList = new CBlobList))
            goto NewCrlListError;
#endif  // CMS_PKCS7
    }

    // EnvelopedData SEQ
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_SEQ)) {
        if (!ICMS_GetToken( &pcmi->bufDecode, &dwToken, NULL))
            goto EnvelopedDataSeqGetTokenError;
        switch(dwToken) {
        case ICMS_TOKEN_INDEFINITE:     pcmi->cEndNullPairs++; break;
        case ICMS_TOKEN_DEFINITE:                              break;
        case ICMS_TOKEN_INCOMPLETE:     goto SuccessReturn;
        default:                        goto InvalidTokenError;
        }
        pcmi->aflDecode |= ICMS_DECODED_ENVELOPED_SEQ;
    }
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_SEQ))
        goto SuccessReturn;


    // version
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_VERSION)) {
        if (!ICMS_DecodePDU(
                pcmi,
                pDec,
                IntegerType_PDU,
                (void **)&piVersion))
            goto DecodeVersionError;
        if (piVersion) {
            ped->version = *piVersion;
            pcmi->aflDecode |= ICMS_DECODED_ENVELOPED_VERSION;
        }
    }
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_VERSION))
        goto SuccessReturn;

#ifdef CMS_PKCS7
    // originatorInfo OPTIONAL
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_ORIGINATOR)) {
        if (pbuf->cbUsed > pbuf->cbDead) {
            if (ICM_TAG_CONSTRUCTED_CONTEXT_0 ==
                                    *(pbuf->pbData + pbuf->cbDead)) {
                // Detected the [0] IMPLICIT indicating originatorInfo.
                // Change the identifier octet so it will decode properly.
                *(pbuf->pbData + pbuf->cbDead) = ICM_TAG_SEQ;
                if (!ICMS_DecodePDU(
                        pcmi,
                        pDec,
                        OriginatorInfoNC_PDU,
                        (void **)&pOriginatorInfo))
                    goto DecodeOriginatorInfoError;
                if (pOriginatorInfo) {
                    if (pOriginatorInfo->bit_mask & certificates_present) {
                        for (i=pOriginatorInfo->certificates.count,
#ifdef OSS_CRYPT_ASN1
                                pAny=pOriginatorInfo->certificates.certificates;
#else
                                pAny=pOriginatorInfo->certificates.value;
#endif  // OSS_CRYPT_ASN1
                                i>0;
                                i--, pAny++) {
                            if (!ICM_InsertTailBlob( pcmi->pCertificateList,
                                    pAny))
                                goto CertInsertTailBlobError;
                        }
                    }

                    if (pOriginatorInfo->bit_mask & crls_present) {
                        for (i=pOriginatorInfo->crls.count,
#ifdef OSS_CRYPT_ASN1
                                pAny=pOriginatorInfo->crls.crls;
#else
                                pAny=pOriginatorInfo->crls.value;
#endif  // OSS_CRYPT_ASN1
                                i>0;
                                i--, pAny++) {
                            if (!ICM_InsertTailBlob( pcmi->pCrlList, pAny))
                                goto CrlInsertTailBlobError;
                        }
                    }
                    pcmi->aflDecode |= ICMS_DECODED_ENVELOPED_ORIGINATOR;
                } else {
                    // The decode failed, presumably due to insufficient data.
                    // Restore the original tag, so we will enter this block
                    // and try again on the next call.
                    *(pbuf->pbData + pbuf->cbDead) =
                        ICM_TAG_CONSTRUCTED_CONTEXT_0;
                }
            } else {
                // originatorInfo not present. Mark as decoded.
                pcmi->aflDecode |= ICMS_DECODED_ENVELOPED_ORIGINATOR;
            }
        }
    }
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_ORIGINATOR))
        goto SuccessReturn;
#endif  // CMS_PKCS7

    // recipientInfos
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_RECIPINFOS)) {
        if (!ICMS_DecodePDU(
                pcmi,
                pDec,
#ifdef CMS_PKCS7
                CmsRecipientInfos_PDU,
#else
                RecipientInfos_PDU,
#endif  // CMS_PKCS7
                (void **)&pRecipientInfos))
            goto DecodeRecipientInfosError;
        if (pRecipientInfos) {
            ped->recipientInfos = *pRecipientInfos;
#ifdef CMS_PKCS7
            odi.iPDU  = CmsRecipientInfos_PDU;
#else
            odi.iPDU  = RecipientInfos_PDU;
#endif  // CMS_PKCS7
            odi.pvPDU = pRecipientInfos;
            if (NULL == (pnOssDecodeInfo = new COssDecodeInfoNode( &odi))) {
                PkiAsn1FreeInfo( pDec, odi.iPDU, odi.pvPDU);
                goto NewOssDecodeInfoNodeError;
            }
            pcmi->plDecodeInfo->InsertTail( pnOssDecodeInfo);
            pcmi->aflDecode |= ICMS_DECODED_ENVELOPED_RECIPINFOS;
        }
    }
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_RECIPINFOS))
        goto SuccessReturn;


    // encryptedContentInfo SEQ
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_ECISEQ)) {
        if (!ICMS_GetToken( &pcmi->bufDecode, &dwToken, &pcmi->cbContentInfo))
            goto EncryptedContentInfoSeqGetTokenError;
        switch(dwToken) {
        case ICMS_TOKEN_INDEFINITE:     pcmi->cInnerNullPairs++; break;
        case ICMS_TOKEN_DEFINITE:                              break;
        case ICMS_TOKEN_INCOMPLETE:     goto SuccessReturn;
        default:                        goto InvalidTokenError;
        }
        pcmi->aflDecode |= ICMS_DECODED_ENVELOPED_ECISEQ;
    }
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_ECISEQ))
        goto SuccessReturn;


    // contentType
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_ECITYPE)) {
        if (!ICMS_DecodePDU(
                pcmi,
                pDec,
                ObjectIdentifierType_PDU,
                (void **)&pooidContentType,
                &cbConsumed))
            goto DecodeContentTypeError;
        if (pooidContentType) {
            ICM_CopyOssObjectIdentifier(&ped->encryptedContentInfo.contentType,
                pooidContentType);
            // NB- Since ContentType is self-contained and we have saved
            // a copy, we can always free pooidContentType when this 
            // routine exits.
            pcmi->aflDecode |= ICMS_DECODED_ENVELOPED_ECITYPE;

            if (CMSG_INDEFINITE_LENGTH != pcmi->cbContentInfo) {
                if (cbConsumed > pcmi->cbContentInfo)
                    goto InvalidEncryptedContentInfoLength;
                pcmi->cbContentInfo -= cbConsumed;
            }
        }
    }
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_ECITYPE))
        goto SuccessReturn;


    // contentEncryptionAlgorithm
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_ECIALGID)) {
        if (!ICMS_DecodePDU(
                pcmi,
                pDec,
                AlgorithmIdentifier_PDU,
                (void **)&poaidContentEncryption,
                &cbConsumed))
            goto DecodeContentEncryptionAlgorithmError;
        if (poaidContentEncryption) {
            ped->encryptedContentInfo.contentEncryptionAlgorithm =
                                                    *poaidContentEncryption;
            odi.iPDU  = AlgorithmIdentifier_PDU;
            odi.pvPDU = poaidContentEncryption;
            if (NULL == (pnOssDecodeInfo = new COssDecodeInfoNode( &odi))) {
                PkiAsn1FreeInfo( pDec, AlgorithmIdentifier_PDU,
                    poaidContentEncryption);
                goto NewOssDecodeInfoNodeError;
            }
            pcmi->plDecodeInfo->InsertTail( pnOssDecodeInfo);
            pcmi->aflDecode |= ICMS_DECODED_ENVELOPED_ECIALGID;

            if (CMSG_INDEFINITE_LENGTH != pcmi->cbContentInfo &&
                    cbConsumed == pcmi->cbContentInfo) {
                // The encryptedContent has been omitted
                pcmi->aflDecode |= ICMS_DECODED_ENVELOPED_ECICONTENT;
                pcmi->aflStream |= ICMS_DECODED_PREFIX | ICMS_DECODED_CONTENT;

                if (pcmi->hkeyContentCrypt) {
                    if (!ICMS_Output(
                            pcmi,
                            NULL,                           // pbData
                            0,                              // cbData
                            TRUE))                          // fFinal
                        goto FinalOutputError;
                }
            }
        }
    }
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_ECIALGID))
        goto SuccessReturn;


    // encryptedContent [0] IMPLICIT OPTIONAL
    //
    // Only support DATA or encapsulated encrypted content.
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_ECICONTENT)) {
        BOOL fNoEncryptedContent = FALSE;
        if (pbuf->cbUsed > pbuf->cbDead) {
            BYTE bTag = *(pbuf->pbData + pbuf->cbDead);
            if (ICM_TAG_CONTEXT_0 == (bTag & ~ICM_TAG_CONSTRUCTED)) {
                // Detected the [0] IMPLICIT indicating encryptedContent.
                // Change the identifier octet so it will decode properly.
                *(pbuf->pbData + pbuf->cbDead) = ICM_TAG_OCTETSTRING |
                    (bTag & ICM_TAG_CONSTRUCTED);

                pcmi->aflDecode |= ICMS_DECODED_ENVELOPED_ECICONTENT;
                // The inner type is always OCTET STRING
                pcmi->aflStream |= ICMS_DECODED_PREFIX | ICMS_INNER_OCTETSTRING;
            } else
                fNoEncryptedContent = TRUE;
        } else if (fFinal)
            fNoEncryptedContent = TRUE;

        if (fNoEncryptedContent) {
            // The encryptedContent has been omitted
            pcmi->aflDecode |= ICMS_DECODED_ENVELOPED_ECICONTENT;
            pcmi->aflStream |= ICMS_DECODED_PREFIX | ICMS_DECODED_CONTENT;

            if (pcmi->hkeyContentCrypt) {
                if (!ICMS_Output(
                        pcmi,
                        NULL,                           // pbData
                        0,                              // cbData
                        TRUE))                          // fFinal
                    goto FinalOutputError;
            }
        }
    }


SuccessReturn:
    fRet = TRUE;
CommonReturn:
    PkiAsn1FreeInfo( pDec, IntegerType_PDU, piVersion);
#ifdef CMS_PKCS7
    PkiAsn1FreeInfo( pDec, OriginatorInfoNC_PDU, pOriginatorInfo);
#endif  // CMS_PKCS7
    PkiAsn1FreeInfo( pDec, ObjectIdentifierType_PDU, pooidContentType);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(EnvelopedDataSeqGetTokenError)              // error already set
TRACE_ERROR(EncryptedContentInfoSeqGetTokenError)       // error already set
TRACE_ERROR(InvalidTokenError)                          // error already set
TRACE_ERROR(DecodeVersionError)                         // error already set
TRACE_ERROR(AllocEnvelopedDataError)                    // error already set
TRACE_ERROR(NewCOssDecodeInfoListError)                 // error already set
#ifdef CMS_PKCS7
TRACE_ERROR(NewCertificateListError)                    // error already set
TRACE_ERROR(NewCrlListError)                            // error already set
TRACE_ERROR(DecodeOriginatorInfoError)                  // error already set
TRACE_ERROR(CertInsertTailBlobError)                    // error already set
TRACE_ERROR(CrlInsertTailBlobError)                     // error already set
#endif  // CMS_PKCS7
TRACE_ERROR(DecodeRecipientInfosError)                  // error already set
TRACE_ERROR(DecodeContentTypeError)                     // error already set
SET_ERROR(InvalidEncryptedContentInfoLength, CRYPT_E_MSG_ERROR)
TRACE_ERROR(DecodeContentEncryptionAlgorithmError)      // error already set
TRACE_ERROR(NewOssDecodeInfoNodeError)                  // error already set
TRACE_ERROR(FinalOutputError)                           // error already set
}


//+-------------------------------------------------------------------------
//  Handle incremental prefix data to be decoded.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodePrefix(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fFinal)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    LONG                lth;
    BOOL                fNoContent;

    if (0 == pcmi->dwMsgType) {
        pcmi->aflStream |= ICMS_NONBARE;
        if (!ICMS_DecodePrefixContentInfo(
                    pcmi,
                    &pcmi->pooid,
                    &pcmi->cEndNullPairs,
                    &pcmi->aflOuter,
                    &fNoContent))
            goto DecodePrefixContentInfoError;

        if (pcmi->aflOuter & ICMS_DECODED_CONTENTINFO_CONTENT) {
            // We cracked the whole header.
            // Translate the contentType oid into a message type.
            if (0 == (lth = ICM_ObjIdToIndex( pcmi->pooid)))
                goto UnknownContentTypeError;
            pcmi->dwMsgType = (DWORD)lth;
            PkiAsn1FreeDecoded(ICM_GetDecoder(), pcmi->pooid,
                ObjectIdentifierType_PDU);
            pcmi->pooid = NULL;


            // Address case of no content
        }
    }

    switch (pcmi->dwMsgType) {
    case 0:
        if (fFinal)
            goto FinalWithoutMessageTypeError;
        break;
    case CMSG_DATA:
        if (!ICMS_DecodePrefixData( pcmi, fFinal))
            goto DecodePrefixDataError;
        break;
    case CMSG_SIGNED:
        if (!ICMS_DecodePrefixSigned( pcmi, fFinal))
            goto DecodePrefixSignedError;
        break;
    case CMSG_ENVELOPED:
        if (!ICMS_DecodePrefixEnveloped( pcmi, fFinal))
            goto DecodePrefixEnvelopedError;
        break;
    case CMSG_HASHED:
        // if (!ICMS_DecodePrefixDigested( pcmi, fFinal))
        //     goto DecodePrefixDigestedError;
        // break;
    case CMSG_SIGNED_AND_ENVELOPED:
    case CMSG_ENCRYPTED:
        goto MessageTypeNotSupportedYet;
    default:
        goto InvalidMsgType;
    }

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(FinalWithoutMessageTypeError,CRYPT_E_STREAM_INSUFFICIENT_DATA)
TRACE_ERROR(UnknownContentTypeError)            // error already set
TRACE_ERROR(DecodePrefixContentInfoError)       // error already set
TRACE_ERROR(DecodePrefixDataError)              // error already set
TRACE_ERROR(DecodePrefixSignedError)            // error already set
TRACE_ERROR(DecodePrefixEnvelopedError)         // error already set
SET_ERROR(MessageTypeNotSupportedYet,CRYPT_E_INVALID_MSG_TYPE)
TRACE_ERROR(InvalidMsgType)                     // error already set
}


//+-------------------------------------------------------------------------
//  Handle incremental data to be decoded (work done here).
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_UpdateDecodingInner(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fFinal)
{
    DWORD       dwError = ERROR_SUCCESS;
    BOOL        fRet;

    if (0 == (pcmi->aflStream & ICMS_DECODED_PREFIX)) {
        if (!ICMS_DecodePrefix( pcmi, fFinal))
            goto DecodePrefixError;
    }
    if (0 == (pcmi->aflStream & ICMS_DECODED_PREFIX))
        goto SuccessReturn;


    if (0 == (pcmi->aflStream & ICMS_DECODED_CONTENT)) {
        if (!ICMS_DecodeContent( pcmi, fFinal))
            goto DecodeContentError; // NB- Do not trash err from callback!
    }
    if (0 == (pcmi->aflStream & ICMS_DECODED_CONTENT))
        goto SuccessReturn;


    if (0 == (pcmi->aflStream & ICMS_DECODED_SUFFIX)) {
        if (!ICMS_DecodeSuffix( pcmi, fFinal))
            goto DecodeSuffixError;
    }
    if (0 == (pcmi->aflStream & ICMS_DECODED_SUFFIX))
        goto SuccessReturn;

SuccessReturn:
    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(DecodePrefixError)                      // error already set
TRACE_ERROR(DecodeContentError)                     // error already set
TRACE_ERROR(DecodeSuffixError)                      // error already set
}


//+-------------------------------------------------------------------------
//  Handle incremental data to be decoded.
//
//  Note, the buffer to be decoded may have some of its tags modified.
//  Therefore, we always need to copy to our own decode buffer.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_UpdateDecoding(
    IN PCRYPT_MSG_INFO  pcmi,
    IN const BYTE       *pbData,
    IN DWORD            cbData,
    IN BOOL             fFinal)
{
    DWORD       dwError = ERROR_SUCCESS;
    BOOL        fRet;

    pcmi->fStreamCallbackOutput = TRUE;

    if (!ICMS_QueueToBuffer( &pcmi->bufDecode, (PBYTE)pbData, cbData))
        goto QueueToBufferError;

    if (!ICMS_UpdateDecodingInner( pcmi, fFinal))
        goto UpdateDecodingInnerError;

    if (fFinal) {
        if (pcmi->bufDecode.cbUsed > pcmi->bufDecode.cbDead)
            goto ExcessDataError;
        pcmi->aflStream |= ICMS_FINAL;
    }

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(QueueToBufferError)                     // error already set
TRACE_ERROR(UpdateDecodingInnerError)               // error already set
SET_ERROR(ExcessDataError, CRYPT_E_MSG_ERROR)
}

#if 0
// When we fix the decoding of [0] Certificates and [1] Crls not to modify
// the encoded data we can replace the above with the following:

//+-------------------------------------------------------------------------
//  Handle incremental data to be decoded.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_UpdateDecoding(
    IN PCRYPT_MSG_INFO  pcmi,
    IN const BYTE       *pbData,
    IN DWORD            cbData,
    IN BOOL             fFinal)
{
    DWORD       dwError = ERROR_SUCCESS;
    BOOL        fRet;
    PICM_BUFFER pbuf = &pcmi->bufDecode;
    BOOL        fNoCopy;

    pcmi->fStreamCallbackOutput = TRUE;
    if (fFinal && NULL == pbuf->pbData) {
        // We're able to use the input buffer without copying
        fNoCopy = TRUE;
        assert(0 == pbuf->cbSize && 0 == pbuf->cbUsed && 0 == pbuf->cbDead);
        pbuf->pbData = (PBYTE) pbData;
        pbuf->cbSize = cbData;
        pbuf->cbUsed = cbData;
        pbuf->cbDead = 0;
    } else {
        fNoCopy = FALSE;
        if (!ICMS_QueueToBuffer( pbuf, (PBYTE)pbData, cbData))
            goto QueueToBufferError;
    }

    if (!ICMS_UpdateDecodingInner( pcmi, fFinal))
        goto UpdateDecodingInnerError;

    if (fFinal) {
        if (pcmi->bufDecode.cbUsed > pcmi->bufDecode.cbDead)
            goto ExcessDataError;
        pcmi->aflStream |= ICMS_FINAL;
    }

    fRet = TRUE;
CommonReturn:
    if (fNoCopy)
        memset(pbuf, 0, sizeof(*pbuf));
        
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(QueueToBufferError)                     // error already set
TRACE_ERROR(UpdateDecodingInnerError)               // error already set
SET_ERROR(ExcessDataError, CRYPT_E_MSG_ERROR)
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\wincrmsg\pkcs.h ===
/* Copyright (C) Microsoft Corporation, 1996 - 1999 All rights reserved. */
/* ASN.1 definitions for GlobalDirectives */

#ifndef _PKCS_Module_H_
#define _PKCS_Module_H_

#include "msber.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef ASN1open_t SignerInfosNC_Set;

typedef ASN1open_t SetOfAny_Set;

typedef ASN1open_t AttributeSetValueNC_Set;

typedef ASN1open_t AttributeSetValue_Set;

typedef ASN1objectidentifier2_t ObjectID;
#define ObjectID_PDU 0
#define SIZE_PKCS_Module_PDU_0 sizeof(ObjectID)

typedef ASN1open_t Any;

typedef ObjectID ObjectIdentifierType;
#define ObjectIdentifierType_PDU 1
#define SIZE_PKCS_Module_PDU_1 sizeof(ObjectIdentifierType)

typedef ASN1octetstring_t OctetStringType;
#define OctetStringType_PDU 2
#define SIZE_PKCS_Module_PDU_2 sizeof(OctetStringType)

typedef ASN1int32_t IntegerType;
#define IntegerType_PDU 3
#define SIZE_PKCS_Module_PDU_3 sizeof(IntegerType)

typedef ASN1intx_t HugeIntegerType;
#define HugeIntegerType_PDU 4
#define SIZE_PKCS_Module_PDU_4 sizeof(HugeIntegerType)

typedef ASN1bitstring_t BitStringType;

typedef ASN1octetstring_t Digest;

typedef ASN1open_t CertificateRevocationList;

typedef ASN1open_t CertificateRevocationListNC;

typedef HugeIntegerType CertificateSerialNumber;

typedef ASN1open_t Name;

typedef ASN1open_t Certificate;

typedef ASN1open_t CertificateNC;

typedef ASN1open_t AlgorithmIdentifierNC;

typedef AlgorithmIdentifierNC DigestAlgorithmIdentifierNC;

typedef ASN1open_t AttributeNC;

typedef AlgorithmIdentifierNC ContentEncryptionAlgIdNC;

typedef ObjectID ContentType;

typedef ASN1octetstring_t Data;

typedef ASN1open_t DigestAlgorithmBlob;

typedef ASN1octetstring_t EncryptedDigest;

typedef ASN1octetstring_t EncryptedDigestNC;

typedef ASN1octetstring_t EncryptedContent;

typedef OctetStringType EncryptedKey;

typedef ASN1open_t CertIdentifierNC;

typedef OctetStringType SubjectKeyIdentifier;

typedef OctetStringType UserKeyingMaterial;

typedef struct AlgorithmIdentifier {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ObjectID algorithm;
#   define AlgorithmIdentifier_parameters_present 0x80
    ASN1open_t parameters;
} AlgorithmIdentifier;
#define AlgorithmIdentifier_PDU 5
#define SIZE_PKCS_Module_PDU_5 sizeof(AlgorithmIdentifier)

typedef struct AlgorithmIdentifierNC2 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ObjectID algorithm;
#   define AlgorithmIdentifierNC2_parameters_present 0x80
    ASN1open_t parameters;
} AlgorithmIdentifierNC2;
#define AlgorithmIdentifierNC2_PDU 6
#define SIZE_PKCS_Module_PDU_6 sizeof(AlgorithmIdentifierNC2)

typedef AlgorithmIdentifier DigestAlgorithmIdentifier;

typedef struct AlgorithmIdentifiers {
    ASN1uint32_t count;
    struct AlgorithmIdentifier *value;
} AlgorithmIdentifiers;
#define AlgorithmIdentifiers_PDU 7
#define SIZE_PKCS_Module_PDU_7 sizeof(AlgorithmIdentifiers)

typedef struct AttributeSetValue {
    ASN1uint32_t count;
    AttributeSetValue_Set *value;
} AttributeSetValue;
#define AttributeSetValue_PDU 8
#define SIZE_PKCS_Module_PDU_8 sizeof(AttributeSetValue)

typedef struct AttributeSetValueNC {
    ASN1uint32_t count;
    AttributeSetValueNC_Set *value;
} AttributeSetValueNC;
#define AttributeSetValueNC_PDU 9
#define SIZE_PKCS_Module_PDU_9 sizeof(AttributeSetValueNC)

typedef struct SetOfAny {
    ASN1uint32_t count;
    SetOfAny_Set *value;
} SetOfAny;
#define SetOfAny_PDU 10
#define SIZE_PKCS_Module_PDU_10 sizeof(SetOfAny)

typedef struct Attribute {
    ObjectID attributeType;
    AttributeSetValue attributeValue;
} Attribute;

typedef struct AttributeNC2 {
    ObjectID attributeType;
    AttributeSetValueNC attributeValue;
} AttributeNC2;
#define AttributeNC2_PDU 11
#define SIZE_PKCS_Module_PDU_11 sizeof(AttributeNC2)

typedef struct Attributes {
    ASN1uint32_t count;
    struct Attribute *value;
} Attributes;
#define Attributes_PDU 12
#define SIZE_PKCS_Module_PDU_12 sizeof(Attributes)

typedef struct AttributesNC {
    ASN1uint32_t count;
    AttributeNC *value;
} AttributesNC;
#define AttributesNC_PDU 13
#define SIZE_PKCS_Module_PDU_13 sizeof(AttributesNC)

typedef struct AttributesNC2 {
    ASN1uint32_t count;
    struct AttributeNC2 *value;
} AttributesNC2;
#define AttributesNC2_PDU 14
#define SIZE_PKCS_Module_PDU_14 sizeof(AttributesNC2)

typedef struct Crls {
    ASN1uint32_t count;
    CertificateRevocationList *value;
} Crls;

typedef struct CrlsNC {
    ASN1uint32_t count;
    CertificateRevocationListNC *value;
} CrlsNC;
#define CrlsNC_PDU 15
#define SIZE_PKCS_Module_PDU_15 sizeof(CrlsNC)

typedef AlgorithmIdentifier ContentEncryptionAlgId;

typedef AlgorithmIdentifier DigestEncryptionAlgId;

typedef AlgorithmIdentifierNC2 DigestEncryptionAlgIdNC;

typedef struct Certificates {
    ASN1uint32_t count;
    Certificate *value;
} Certificates;

typedef struct CertificatesNC {
    ASN1uint32_t count;
    CertificateNC *value;
} CertificatesNC;
#define CertificatesNC_PDU 16
#define SIZE_PKCS_Module_PDU_16 sizeof(CertificatesNC)

typedef struct IssuerAndSerialNumber {
    Name issuer;
    CertificateSerialNumber serialNumber;
} IssuerAndSerialNumber;
#define IssuerAndSerialNumber_PDU 17
#define SIZE_PKCS_Module_PDU_17 sizeof(IssuerAndSerialNumber)

typedef AlgorithmIdentifier KeyEncryptionAlgId;

typedef struct ContentInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ContentType contentType;
#   define ContentInfo_content_present 0x80
    ASN1open_t content;
} ContentInfo;
#define ContentInfo_PDU 18
#define SIZE_PKCS_Module_PDU_18 sizeof(ContentInfo)

typedef struct ContentInfoNC {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ContentType contentType;
#   define ContentInfoNC_content_present 0x80
    ASN1open_t content;
} ContentInfoNC;
#define ContentInfoNC_PDU 19
#define SIZE_PKCS_Module_PDU_19 sizeof(ContentInfoNC)

typedef struct DigestAlgorithmIdentifiers {
    ASN1uint32_t count;
    DigestAlgorithmIdentifier *value;
} DigestAlgorithmIdentifiers;

typedef struct DigestAlgorithmIdentifiersNC {
    ASN1uint32_t count;
    DigestAlgorithmIdentifierNC *value;
} DigestAlgorithmIdentifiersNC;
#define DigestAlgorithmIdentifiersNC_PDU 20
#define SIZE_PKCS_Module_PDU_20 sizeof(DigestAlgorithmIdentifiersNC)

typedef struct SignerInfos {
    ASN1uint32_t count;
    struct SignerInfo *value;
} SignerInfos;
#define SignerInfos_PDU 21
#define SIZE_PKCS_Module_PDU_21 sizeof(SignerInfos)

typedef struct DigestAlgorithmBlobs {
    ASN1uint32_t count;
    DigestAlgorithmBlob *value;
} DigestAlgorithmBlobs;
#define DigestAlgorithmBlobs_PDU 22
#define SIZE_PKCS_Module_PDU_22 sizeof(DigestAlgorithmBlobs)

typedef struct SignerInfosNC {
    ASN1uint32_t count;
    SignerInfosNC_Set *value;
} SignerInfosNC;
#define SignerInfosNC_PDU 23
#define SIZE_PKCS_Module_PDU_23 sizeof(SignerInfosNC)

typedef struct SignerInfoWithAABlobs {
    ASN1uint32_t count;
    struct SignerInfoWithAABlob *value;
} SignerInfoWithAABlobs;
#define SignerInfoWithAABlobs_PDU 24
#define SIZE_PKCS_Module_PDU_24 sizeof(SignerInfoWithAABlobs)

typedef struct SignerInfoWithAABlob {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1open_t version;
    ASN1open_t sid;
    ASN1open_t digestAlgorithm;
    ASN1open_t authenticatedAttributes;
    ASN1open_t digestEncryptionAlgorithm;
    ASN1open_t encryptedDigest;
#   define dummyUAAs_present 0x80
    AttributesNC dummyUAAs;
} SignerInfoWithAABlob;
#define SignerInfoWithAABlob_PDU 25
#define SIZE_PKCS_Module_PDU_25 sizeof(SignerInfoWithAABlob)

typedef struct SignerInfoWithAttrBlobs {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1open_t version;
    ASN1open_t sid;
    ASN1open_t digestAlgorithm;
#   define SignerInfoWithAttrBlobs_authAttributes_present 0x80
    AttributesNC authAttributes;
    DigestEncryptionAlgIdNC digestEncryptionAlgorithm;
    ASN1open_t encryptedDigest;
#   define SignerInfoWithAttrBlobs_unauthAttributes_present 0x40
    AttributesNC unauthAttributes;
} SignerInfoWithAttrBlobs;
#define SignerInfoWithAttrBlobs_PDU 26
#define SIZE_PKCS_Module_PDU_26 sizeof(SignerInfoWithAttrBlobs)

typedef struct SignerInfoWithBlobs {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    CertIdentifierNC sid;
    DigestAlgorithmIdentifierNC digestAlgorithm;
#   define SignerInfoWithBlobs_authAttributes_present 0x80
    AttributesNC2 authAttributes;
    DigestEncryptionAlgIdNC digestEncryptionAlgorithm;
    EncryptedDigestNC encryptedDigest;
#   define SignerInfoWithBlobs_unauthAttributes_present 0x40
    AttributesNC2 unauthAttributes;
} SignerInfoWithBlobs;
#define SignerInfoWithBlobs_PDU 27
#define SIZE_PKCS_Module_PDU_27 sizeof(SignerInfoWithBlobs)

typedef struct RecipientInfos {
    ASN1uint32_t count;
    struct RecipientInfo *value;
} RecipientInfos;
#define RecipientInfos_PDU 28
#define SIZE_PKCS_Module_PDU_28 sizeof(RecipientInfos)

typedef struct EncryptedContentInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ContentType contentType;
    ContentEncryptionAlgId contentEncryptionAlgorithm;
#   define encryptedContent_present 0x80
    EncryptedContent encryptedContent;
} EncryptedContentInfo;
#define EncryptedContentInfo_PDU 29
#define SIZE_PKCS_Module_PDU_29 sizeof(EncryptedContentInfo)

typedef struct RecipientInfo {
    ASN1int32_t version;
    IssuerAndSerialNumber issuerAndSerialNumber;
    KeyEncryptionAlgId keyEncryptionAlgorithm;
    EncryptedKey encryptedKey;
} RecipientInfo;
#define RecipientInfo_PDU 30
#define SIZE_PKCS_Module_PDU_30 sizeof(RecipientInfo)

typedef struct SignedAndEnvelopedData {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    RecipientInfos recipientInfos;
    DigestAlgorithmIdentifiers digestAlgorithms;
    EncryptedContentInfo encryptedContentInfo;
#   define SignedAndEnvelopedData_certificates_present 0x80
    Certificates certificates;
#   define SignedAndEnvelopedData_crls_present 0x40
    Crls crls;
    SignerInfos signerInfos;
} SignedAndEnvelopedData;
#define SignedAndEnvelopedData_PDU 31
#define SIZE_PKCS_Module_PDU_31 sizeof(SignedAndEnvelopedData)

typedef struct DigestedData {
    ASN1int32_t version;
    DigestAlgorithmIdentifier digestAlgorithm;
    ContentInfo contentInfo;
    Digest digest;
} DigestedData;
#define DigestedData_PDU 32
#define SIZE_PKCS_Module_PDU_32 sizeof(DigestedData)

typedef struct EncryptedData {
    ASN1int32_t version;
    EncryptedContentInfo encryptedContentInfo;
} EncryptedData;
#define EncryptedData_PDU 33
#define SIZE_PKCS_Module_PDU_33 sizeof(EncryptedData)

typedef struct CertIdentifier {
    ASN1choice_t choice;
    union {
#	define CertIdentifier_issuerAndSerialNumber_chosen 1
	IssuerAndSerialNumber issuerAndSerialNumber;
#	define CertIdentifier_subjectKeyIdentifier_chosen 2
	SubjectKeyIdentifier subjectKeyIdentifier;
    } u;
} CertIdentifier;
#define CertIdentifier_PDU 34
#define SIZE_PKCS_Module_PDU_34 sizeof(CertIdentifier)

typedef struct OriginatorInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define OriginatorInfo_certificates_present 0x80
    Certificates certificates;
#   define OriginatorInfo_crls_present 0x40
    Crls crls;
} OriginatorInfo;
#define OriginatorInfo_PDU 35
#define SIZE_PKCS_Module_PDU_35 sizeof(OriginatorInfo)

typedef struct OriginatorInfoNC {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define OriginatorInfoNC_certificates_present 0x80
    CertificatesNC certificates;
#   define OriginatorInfoNC_crls_present 0x40
    CrlsNC crls;
} OriginatorInfoNC;
#define OriginatorInfoNC_PDU 36
#define SIZE_PKCS_Module_PDU_36 sizeof(OriginatorInfoNC)

typedef struct CmsRecipientInfos {
    ASN1uint32_t count;
    struct CmsRecipientInfo *value;
} CmsRecipientInfos;
#define CmsRecipientInfos_PDU 37
#define SIZE_PKCS_Module_PDU_37 sizeof(CmsRecipientInfos)

typedef struct KeyTransRecipientInfo {
    ASN1int32_t version;
    CertIdentifier rid;
    KeyEncryptionAlgId keyEncryptionAlgorithm;
    EncryptedKey encryptedKey;
} KeyTransRecipientInfo;
#define KeyTransRecipientInfo_PDU 38
#define SIZE_PKCS_Module_PDU_38 sizeof(KeyTransRecipientInfo)

typedef struct OriginatorPublicKey {
    AlgorithmIdentifier algorithm;
    BitStringType publicKey;
} OriginatorPublicKey;

typedef struct RecipientEncryptedKeys {
    ASN1uint32_t count;
    struct RecipientEncryptedKey *value;
} RecipientEncryptedKeys;

typedef struct OtherKeyAttribute {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ObjectID keyAttrId;
#   define keyAttr_present 0x80
    ASN1open_t keyAttr;
} OtherKeyAttribute;

typedef struct MailListKeyIdentifier {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    OctetStringType kekIdentifier;
#   define MailListKeyIdentifier_date_present 0x80
    ASN1generalizedtime_t date;
#   define MailListKeyIdentifier_other_present 0x40
    OtherKeyAttribute other;
} MailListKeyIdentifier;

typedef struct DigestInfo {
    DigestAlgorithmIdentifier digestAlgorithm;
    Digest digest;
} DigestInfo;
#define DigestInfo_PDU 39
#define SIZE_PKCS_Module_PDU_39 sizeof(DigestInfo)

typedef struct SignedData {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    DigestAlgorithmIdentifiers digestAlgorithms;
    ContentInfo contentInfo;
#   define SignedData_certificates_present 0x80
    Certificates certificates;
#   define SignedData_crls_present 0x40
    Crls crls;
    SignerInfos signerInfos;
} SignedData;
#define SignedData_PDU 40
#define SIZE_PKCS_Module_PDU_40 sizeof(SignedData)

typedef struct SignerInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    CertIdentifier sid;
    DigestAlgorithmIdentifier digestAlgorithm;
#   define authenticatedAttributes_present 0x80
    Attributes authenticatedAttributes;
    DigestEncryptionAlgId digestEncryptionAlgorithm;
    EncryptedDigest encryptedDigest;
#   define SignerInfo_unauthAttributes_present 0x40
    Attributes unauthAttributes;
} SignerInfo;
#define SignerInfo_PDU 41
#define SIZE_PKCS_Module_PDU_41 sizeof(SignerInfo)

typedef struct SignedDataWithBlobs {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    DigestAlgorithmIdentifiersNC digestAlgorithms;
    ContentInfoNC contentInfo;
#   define SignedDataWithBlobs_certificates_present 0x80
    CertificatesNC certificates;
#   define SignedDataWithBlobs_crls_present 0x40
    CrlsNC crls;
    SignerInfosNC signerInfos;
} SignedDataWithBlobs;
#define SignedDataWithBlobs_PDU 42
#define SIZE_PKCS_Module_PDU_42 sizeof(SignedDataWithBlobs)

typedef struct EnvelopedData {
    ASN1int32_t version;
    RecipientInfos recipientInfos;
    EncryptedContentInfo encryptedContentInfo;
} EnvelopedData;
#define EnvelopedData_PDU 43
#define SIZE_PKCS_Module_PDU_43 sizeof(EnvelopedData)

typedef struct CmsEnvelopedData {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
#   define originatorInfo_present 0x80
    OriginatorInfo originatorInfo;
    CmsRecipientInfos recipientInfos;
    EncryptedContentInfo encryptedContentInfo;
#   define unprotectedAttrs_present 0x40
    Attributes unprotectedAttrs;
} CmsEnvelopedData;
#define CmsEnvelopedData_PDU 44
#define SIZE_PKCS_Module_PDU_44 sizeof(CmsEnvelopedData)

typedef struct OriginatorIdentifierOrKey {
    ASN1choice_t choice;
    union {
#	define OriginatorIdentifierOrKey_issuerAndSerialNumber_chosen 1
	IssuerAndSerialNumber issuerAndSerialNumber;
#	define OriginatorIdentifierOrKey_subjectKeyIdentifier_chosen 2
	SubjectKeyIdentifier subjectKeyIdentifier;
#	define originatorKey_chosen 3
	OriginatorPublicKey originatorKey;
    } u;
} OriginatorIdentifierOrKey;

typedef struct RecipientKeyIdentifier {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    SubjectKeyIdentifier subjectKeyIdentifier;
#   define RecipientKeyIdentifier_date_present 0x80
    ASN1generalizedtime_t date;
#   define RecipientKeyIdentifier_other_present 0x40
    OtherKeyAttribute other;
} RecipientKeyIdentifier;

typedef struct MailListRecipientInfo {
    ASN1int32_t version;
    MailListKeyIdentifier mlid;
    KeyEncryptionAlgId keyEncryptionAlgorithm;
    EncryptedKey encryptedKey;
} MailListRecipientInfo;
#define MailListRecipientInfo_PDU 45
#define SIZE_PKCS_Module_PDU_45 sizeof(MailListRecipientInfo)

typedef struct KeyAgreeRecipientInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    OriginatorIdentifierOrKey originator;
#   define ukm_present 0x80
    UserKeyingMaterial ukm;
    KeyEncryptionAlgId keyEncryptionAlgorithm;
    RecipientEncryptedKeys recipientEncryptedKeys;
} KeyAgreeRecipientInfo;
#define KeyAgreeRecipientInfo_PDU 46
#define SIZE_PKCS_Module_PDU_46 sizeof(KeyAgreeRecipientInfo)

typedef struct RecipientIdentifier {
    ASN1choice_t choice;
    union {
#	define RecipientIdentifier_issuerAndSerialNumber_chosen 1
	IssuerAndSerialNumber issuerAndSerialNumber;
#	define rKeyId_chosen 2
	RecipientKeyIdentifier rKeyId;
    } u;
} RecipientIdentifier;

typedef struct CmsRecipientInfo {
    ASN1choice_t choice;
    union {
#	define keyTransRecipientInfo_chosen 1
	KeyTransRecipientInfo keyTransRecipientInfo;
#	define keyAgreeRecipientInfo_chosen 2
	KeyAgreeRecipientInfo keyAgreeRecipientInfo;
#	define mailListRecipientInfo_chosen 3
	MailListRecipientInfo mailListRecipientInfo;
    } u;
} CmsRecipientInfo;
#define CmsRecipientInfo_PDU 47
#define SIZE_PKCS_Module_PDU_47 sizeof(CmsRecipientInfo)

typedef struct RecipientEncryptedKey {
    RecipientIdentifier rid;
    EncryptedKey encryptedKey;
} RecipientEncryptedKey;


extern ASN1module_t PKCS_Module;
extern void ASN1CALL PKCS_Module_Startup(void);
extern void ASN1CALL PKCS_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _PKCS_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\wincrmsg\wincrmsg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       wincrmsg.cpp
//
//  Contents:   Cryptographic Message APIs
//
//  APIs:
//
//  History:    14-Feb-96   kevinr    created
//
//--------------------------------------------------------------------------

#include "global.hxx"

HCRYPTASN1MODULE  ICM_hAsn1Module;

COssDecodeInfoNode::~COssDecodeInfoNode()
{
    PkiAsn1FreeInfo( ICM_GetDecoder(), m_data.iPDU, m_data.pvPDU);
}

CBlobNode::~CBlobNode()
{
    ICM_Free( m_data.pbData);
}

CSignerNode::~CSignerNode()
{
    ICM_Free( m_data.blob.pbData);
    delete m_data.pUnauthAttrList;
}

CHashNode::~CHashNode()
{
    ICM_Free( m_data.HashBlob.pbData);
    if (m_data.hHash)
        CryptDestroyHash( m_data.hHash);
}

inline
BOOL
ICM_IsAddInnerContentOctetWrapper(
    IN PCRYPT_MSG_INFO  pcmi
    )
{
#ifdef CMS_PKCS7
    return NULL == pcmi->pszInnerContentObjID ||
        (pcmi->dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG);
#else
    return NULL == pcmi->pszInnerContentObjID;
#endif  // CMS_PKCS7
}


DWORD
ICM_GetTaggedBlobCount(
    IN CBlobList *pBlobList,
    IN BYTE bTag
    )
{
    DWORD dwCount = 0;
    CBlobNode *pBlobNode;

    for (pBlobNode=pBlobList->Head(); pBlobNode; pBlobNode=pBlobNode->Next()) {
        if (bTag == *(pBlobNode->Data()->pbData))
            dwCount++;
    }

    return dwCount;
}

// Advances index past other Tags
CBlobNode *
ICM_GetTaggedBlobAndAdvanceIndex(
    IN CBlobList *pBlobList,
    IN BYTE bTag,               // 0 => any
    IN OUT DWORD *pdwIndex
    )
{
    DWORD dwIndex = *pdwIndex;
    CBlobNode *pBlobNode;
    DWORD i;

    for (i=dwIndex, pBlobNode=pBlobList->Head();
            pBlobNode;
            pBlobNode=pBlobNode->Next()) {
        if (bTag && bTag != *(pBlobNode->Data()->pbData)) {
            // Advance index past other tags
            dwIndex++;
        } else {
            if (0 == i)
                break;
            else
                i--;
        }
    }

    *pdwIndex = dwIndex;
    return pBlobNode;
}


ObjectID aoidMessages[] = {
    { 7, {1,2,840,113549,1,7,1}}, // data
    { 7, {1,2,840,113549,1,7,2}}, // signed
    { 7, {1,2,840,113549,1,7,3}}, // enveloped
    { 7, {1,2,840,113549,1,7,4}}, // signed and enveloped
    { 7, {1,2,840,113549,1,7,5}}, // digested
    { 7, {1,2,840,113549,1,7,6}}, // encrypted
    { 7, {1,2,840,113549,1,7,7}}  // dual-signed
};
#define  COUNTOF_aoidMessages  (sizeof(aoidMessages)/sizeof(aoidMessages[0]))

ObjectID oidMessageDigest = { 7, {1,2,840,113549,1,9,4}};

const LPSTR apszObjIdPKCS7[] = {
    szOID_RSA_data              ,
    szOID_RSA_signedData        ,
    szOID_RSA_envelopedData     ,
    szOID_RSA_signEnvData       ,
    szOID_RSA_digestedData      ,
    szOID_RSA_encryptedData
};
const DWORD COUNTOF_apszObjIdPKCS7 = (sizeof(apszObjIdPKCS7)/sizeof(apszObjIdPKCS7[0]));
//#if  COUNTOF_apszObjIdPKCS7 - (sizeof(apszObjIdPKCS7)/sizeof(apszObjIdPKCS7[0]))
//#error COUNTOF_apszObjIdPKCS7 wrong
//#endif

const LPSTR pszObjIdDataType        = szOID_RSA_data;
const LPSTR pszObjIdContentType     = szOID_RSA_contentType;
const LPSTR pszObjIdMessageDigest   = szOID_RSA_messageDigest;


int aiPduNum[] = {
    OctetStringType_PDU,
    SignedData_PDU,
#ifdef CMS_PKCS7
    CmsEnvelopedData_PDU,
#else
    EnvelopedData_PDU,
#endif  // CMS_PKCS7
    SignedAndEnvelopedData_PDU,
    DigestedData_PDU,
    EncryptedData_PDU
};

/*
// Should be able to use aiPduNum, but first entry of aiPduNum
// seems to need to be 0. ????
int aiPduNum2[] = {
    OctetStringType_PDU,
    SignedData_PDU,
#ifdef CMS_PKCS7
    CmsEnvelopedData_PDU,
#else
    EnvelopedData_PDU,
#endif  // CMS_PKCS7
    SignedAndEnvelopedData_PDU,
    DigestedData_PDU,
    EncryptedData_PDU
};
*/

typedef struct _CRYPT_ABLOB {
    DWORD               cBlob;
    PCRYPT_DATA_BLOB    pBlob;
} CRYPT_ABLOB, *PCRYPT_ABLOB;


// Here is a table for keeping straight which phases are legal in which
// situations:
//
//          detached    !detached
//  encode  FO,FF       FF
//  decode  FF,SO,SF    FF
//
enum Phases {
    PHASE_FIRST_ONGOING     = 1,
    PHASE_FIRST_FINAL       = 2,
    PHASE_SECOND_ONGOING    = 3,
    PHASE_SECOND_FINAL      = 4
};


BOOL
WINAPI
ICM_GetAnyData(
    IN Any *pAny,
    OUT void *pvData,
    IN OUT DWORD *pcbData);


WINAPI
ICM_GetOssContentInfoData(
    IN ContentInfo *poci,
    OUT void *pvData,
    IN OUT DWORD *pcbData);

BOOL
WINAPI
ICM_GetSignerParamEncoding(
    IN PCRYPT_MSG_INFO  pcmi,
    IN DWORD            dwIndex,
    IN DWORD            dwParamType,
    OUT PVOID           pvData,
    IN OUT PDWORD       pcbData);

BOOL
WINAPI
ICM_GetALGORITHM_IDENTIFIER(
    IN AlgorithmIdentifier *paiOss,
    OUT void *pvData,
    IN OUT DWORD *pcbData);

//+-------------------------------------------------------------------------
//  Lock and unlock HCRYPTMSG functions
//--------------------------------------------------------------------------
inline
void
ICM_Lock(
    IN PCRYPT_MSG_INFO  pcmi
    )
{
    EnterCriticalSection( &pcmi->CriticalSection);
}
inline
void
ICM_Unlock(
    IN PCRYPT_MSG_INFO  pcmi
    )
{
    LeaveCriticalSection( &pcmi->CriticalSection);
}


//+-------------------------------------------------------------------------
//  allocation and free routines
//--------------------------------------------------------------------------
void *
WINAPI
ICM_Alloc(
    IN size_t cb)
{
    void *pv;
    if (NULL == (pv = malloc(cb)))
        goto mallocError;
ErrorReturn:
    return pv;
SET_ERROR(mallocError,E_OUTOFMEMORY)
}

void *
WINAPI
ICM_AllocZero(
    IN size_t cb)
{
    void *pv;
    // Should map to LocalAlloc( ZERO_INIT).
    if (NULL != (pv = ICM_Alloc(cb)))
        memset( pv, 0, cb);
    return pv;
}

void *
WINAPI
ICM_ReAlloc(
    IN void     *pvOrg,
    IN size_t   cb)
{
    void *pv;
    if (NULL == (pv = pvOrg ? realloc( pvOrg, cb) : malloc( cb)))
        goto allocError;
ErrorReturn:
    return pv;
SET_ERROR(allocError,E_OUTOFMEMORY)
}

void
WINAPI
ICM_Free(
    IN void *pv)
{
    if (pv)
        free(pv);
}

// Stack allocations
// NB: Use heap allocs on DBG so we can more easily catch buffer over-runs, etc.
#if DBG
#define ICM_AllocA      ICM_Alloc
#define ICM_FreeA       ICM_Free
#else
#define ICM_AllocA      ICM_Alloc
#define ICM_FreeA       ICM_Free
// The following defines work fine on NT, but seem to have problems on Win95
// REASON: unknown
//#define ICM_AllocA(s)   alloca(((s)+7))
//#define ICM_FreeA(p)   
#endif

void *
WINAPI
ICM_AllocZeroA(
    IN size_t cbBytes)
{
    void *pv;
    if (NULL != (pv = ICM_AllocA(cbBytes)))
        memset( pv, 0, cbBytes);
    return pv;
}

void *ICM_DupMem(
    IN void     *pvIn,
    IN size_t   cb)
{
    void *pv = NULL;
    if (pvIn)
        if (NULL != (pv = ICM_Alloc(cb)))
            memcpy( pv, pvIn, cb);
    return pv;
}

size_t ICM_StrLen(const char *pszIn)
{
    return pszIn ? strlen(pszIn) : 0;
}


BOOL
WINAPI
ICM_AppendBlob(
    PCRYPT_DATA_BLOB    pblob,
    const BYTE          *pbIn,
    DWORD               cbIn)
{
    BOOL        fRet;
    PBYTE       pb = NULL;

    if (NULL == (pb = (PBYTE)ICM_ReAlloc(
                                pblob->pbData,
                                pblob->cbData + cbIn)))
        goto AllocError;
    memcpy( pb + pblob->cbData, pbIn, cbIn);
    pblob->pbData = pb;
    pblob->cbData += cbIn;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(AllocError)
}

#ifdef CMS_PKCS7
STATIC
BOOL
WINAPI
ICM_InsertMsgAlloc(
    IN PCRYPT_MSG_INFO pcmi,
    IN void *pv
    )
{
    BOOL                    fRet;
    CBlobNode               *pnBlob = NULL;
    CRYPT_DATA_BLOB         blob;

    if (NULL == pcmi->pFreeList) {
        if (NULL == (pcmi->pFreeList = new CBlobList))
            goto OutOfMemory;
    }

    if (NULL == (pnBlob = new CBlobNode))
        goto OutOfMemory;

    blob.cbData = 0;
    blob.pbData = (BYTE *) pv;
    pnBlob->SetData(&blob);
    pcmi->pFreeList->InsertTail(pnBlob);

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(OutOfMemory,E_OUTOFMEMORY)
}
#endif  // CMS_PKCS7

// Allocates algorithm parameters and inserts into the message's free
// list before doing the ICM_Asn1ToAlgorithmIdentifier
STATIC
BOOL
WINAPI
ICM_MsgAsn1ToAlgorithmIdentifier(
    IN PCRYPT_MSG_INFO pcmi,
    IN PCRYPT_ALGORITHM_IDENTIFIER pai,
    IN OUT AlgorithmIdentifier *pOssAlgId
    )
{
#ifdef CMS_PKCS7
    CRYPT_ALGORITHM_IDENTIFIER ai;

    if (pcmi && 0 < pai->Parameters.cbData) {
        ai = *pai;
        if (NULL == (ai.Parameters.pbData = (BYTE *) ICM_DupMem(
                ai.Parameters.pbData, ai.Parameters.cbData)))
            return FALSE;
        if (!ICM_InsertMsgAlloc(pcmi, ai.Parameters.pbData)) {
            ICM_Free(ai.Parameters.pbData);
            return FALSE;
        }
        pai = &ai;
    }
#endif  // CMS_PKCS7

    return ICM_Asn1ToAlgorithmIdentifier(pai, pOssAlgId);
}

//+-------------------------------------------------------------------------
//
//--------------------------------------------------------------------------
STATIC BOOL WINAPI
ICM_PkcsSignerInfoEncode(
    IN DWORD                dwCertEncodingType,
    IN LPCSTR               lpszStructType,
    IN PCMSG_SIGNER_INFO    pInfo,
    OUT PBYTE               pbEncoded,
    IN OUT PDWORD           pcbEncoded);

STATIC BOOL WINAPI
ICM_PkcsSignerInfoDecode(
        IN DWORD dwEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCMSG_SIGNER_INFO pInfo,
        IN OUT DWORD *pcbInfo);

STATIC BOOL WINAPI
ICM_CmsSignerInfoEncode(
    IN DWORD                dwCertEncodingType,
    IN LPCSTR               lpszStructType,
    IN PCMSG_CMS_SIGNER_INFO pInfo,
    OUT PBYTE               pbEncoded,
    IN OUT PDWORD           pcbEncoded);

STATIC BOOL WINAPI
ICM_CmsSignerInfoDecode(
        IN DWORD dwEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCMSG_CMS_SIGNER_INFO pInfo,
        IN OUT DWORD *pcbInfo);

#ifdef OSS_CRYPT_ASN1
#define ASN1_OID_OFFSET         10000 +
#define ASN1_OID_PREFIX         "OssCryptAsn1."
#else
#define ASN1_OID_OFFSET
#define ASN1_OID_PREFIX
#endif  // OSS_CRYPT_ASN1

STATIC
const
CRYPT_OID_FUNC_ENTRY
ICM_EncodeFuncTable[] = {
    ASN1_OID_OFFSET PKCS7_SIGNER_INFO, ICM_PkcsSignerInfoEncode,
    ASN1_OID_OFFSET CMS_SIGNER_INFO, ICM_CmsSignerInfoEncode,
};

#define ICM_ENCODE_FUNC_COUNT \
    (sizeof(ICM_EncodeFuncTable) / sizeof(ICM_EncodeFuncTable[0]))

STATIC
const
CRYPT_OID_FUNC_ENTRY
ICM_DecodeFuncTable[] = {
    ASN1_OID_OFFSET PKCS7_SIGNER_INFO, ICM_PkcsSignerInfoDecode,
    ASN1_OID_OFFSET CMS_SIGNER_INFO, ICM_CmsSignerInfoDecode,
};

#define ICM_DECODE_FUNC_COUNT \
    (sizeof(ICM_DecodeFuncTable) / sizeof(ICM_DecodeFuncTable[0]))

#ifdef CMS_PKCS7

static HCRYPTOIDFUNCSET hOldStyleGenEncryptKeyFuncSet;
static HCRYPTOIDFUNCSET hOldStyleExportEncryptKeyFuncSet;
static HCRYPTOIDFUNCSET hOldStyleImportEncryptKeyFuncSet;

static HCRYPTOIDFUNCSET hGenContentEncryptKeyFuncSet;
static HCRYPTOIDFUNCSET hExportKeyTransFuncSet;
static HCRYPTOIDFUNCSET hExportKeyAgreeFuncSet;
static HCRYPTOIDFUNCSET hExportMailListFuncSet;
static HCRYPTOIDFUNCSET hImportKeyTransFuncSet;
static HCRYPTOIDFUNCSET hImportKeyAgreeFuncSet;
static HCRYPTOIDFUNCSET hImportMailListFuncSet;

//+-------------------------------------------------------------------------
//  GenContentEncryptKey OID Installable Functions
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultGenContentEncryptKey(
    IN OUT PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved
    );
static const CRYPT_OID_FUNC_ENTRY GenContentEncryptKeyFuncTable[] = {
    CMSG_DEFAULT_INSTALLABLE_FUNC_OID, ICM_DefaultGenContentEncryptKey
};

//+-------------------------------------------------------------------------
//  ExportKeyTrans OID Installable Functions
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultExportKeyTrans(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO pKeyTransEncodeInfo,
    IN OUT PCMSG_KEY_TRANS_ENCRYPT_INFO pKeyTransEncryptInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved
    );
static const CRYPT_OID_FUNC_ENTRY ExportKeyTransFuncTable[] = {
    CMSG_DEFAULT_INSTALLABLE_FUNC_OID, ICM_DefaultExportKeyTrans
};

//+-------------------------------------------------------------------------
//  ExportKeyAgree OID Installable Functions
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultExportKeyAgree(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO pKeyAgreeEncodeInfo,
    IN OUT PCMSG_KEY_AGREE_ENCRYPT_INFO pKeyAgreeEncryptInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved
    );
static const CRYPT_OID_FUNC_ENTRY ExportKeyAgreeFuncTable[] = {
    CMSG_DEFAULT_INSTALLABLE_FUNC_OID, ICM_DefaultExportKeyAgree
};

//+-------------------------------------------------------------------------
//  ExportMailList OID Installable Functions
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultExportMailList(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN PCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO pMailListEncodeInfo,
    IN OUT PCMSG_MAIL_LIST_ENCRYPT_INFO pMailListEncryptInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved
    );
static const CRYPT_OID_FUNC_ENTRY ExportMailListFuncTable[] = {
    CMSG_DEFAULT_INSTALLABLE_FUNC_OID, ICM_DefaultExportMailList
};

//+-------------------------------------------------------------------------
//  ImportKeyTrans OID Installable Functions
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultImportKeyTrans(
    IN PCRYPT_ALGORITHM_IDENTIFIER pContentEncryptionAlgorithm,
    IN PCMSG_CTRL_KEY_TRANS_DECRYPT_PARA pKeyTransDecryptPara,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT HCRYPTKEY *phContentEncryptKey
    );
static const CRYPT_OID_FUNC_ENTRY ImportKeyTransFuncTable[] = {
    CMSG_DEFAULT_INSTALLABLE_FUNC_OID, ICM_DefaultImportKeyTrans
};

//+-------------------------------------------------------------------------
//  ImportKeyAgree OID Installable Functions
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultImportKeyAgree(
    IN PCRYPT_ALGORITHM_IDENTIFIER pContentEncryptionAlgorithm,
    IN PCMSG_CTRL_KEY_AGREE_DECRYPT_PARA pKeyAgreeDecryptPara,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT HCRYPTKEY *phContentEncryptKey
    );
static const CRYPT_OID_FUNC_ENTRY ImportKeyAgreeFuncTable[] = {
    CMSG_DEFAULT_INSTALLABLE_FUNC_OID, ICM_DefaultImportKeyAgree
};

//+-------------------------------------------------------------------------
//  ImportMailList OID Installable Functions
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultImportMailList(
    IN PCRYPT_ALGORITHM_IDENTIFIER pContentEncryptionAlgorithm,
    IN PCMSG_CTRL_MAIL_LIST_DECRYPT_PARA pMailListDecryptPara,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT HCRYPTKEY *phContentEncryptKey
    );
static const CRYPT_OID_FUNC_ENTRY ImportMailListFuncTable[] = {
    CMSG_DEFAULT_INSTALLABLE_FUNC_OID, ICM_DefaultImportMailList
};

#else

static HCRYPTOIDFUNCSET hGenEncryptKeyFuncSet;
static HCRYPTOIDFUNCSET hExportEncryptKeyFuncSet;
static HCRYPTOIDFUNCSET hImportEncryptKeyFuncSet;

#endif  // CMS_PKCS7

//+-------------------------------------------------------------------------
//  GenEncryptKey OID Installable Functions (OldStyle)
//--------------------------------------------------------------------------

// rgcbEncryptParameters[1] contains the dwEncryptFlags passed to
// ICM_DefaultExportEncryptKey
BOOL
WINAPI
ICM_DefaultGenEncryptKey(
    IN OUT HCRYPTPROV               *phCryptProv,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    IN PVOID                        pvEncryptAuxInfo,
    IN PCERT_PUBLIC_KEY_INFO        pPublicKeyInfo,
    IN PFN_CMSG_ALLOC               pfnAlloc,
    OUT HCRYPTKEY                   *phEncryptKey,
    OUT PBYTE                       *ppbEncryptParameters,
    OUT DWORD                       rgcbEncryptParameters[2]);

static const CRYPT_OID_FUNC_ENTRY GenEncryptKeyFuncTable[] = {
    szOID_OIWSEC_desCBC, ICM_DefaultGenEncryptKey,
    szOID_RSA_DES_EDE3_CBC, ICM_DefaultGenEncryptKey,
    szOID_RSA_RC2CBC, ICM_DefaultGenEncryptKey,
    szOID_RSA_RC4, ICM_DefaultGenEncryptKey
};
#define GEN_ENCRYPT_KEY_FUNC_COUNT (sizeof(GenEncryptKeyFuncTable) / \
                                        sizeof(GenEncryptKeyFuncTable[0]))

//+-------------------------------------------------------------------------
//  ExportEncryptKey OID Installable Functions (OldStyle)
//--------------------------------------------------------------------------

// rgcbData[1] is the dwEncryptFlags passed from ICM_DefaultGenEncryptKey
BOOL
WINAPI
ICM_DefaultExportEncryptKey(
    IN HCRYPTPROV                   hCryptProv,
    IN HCRYPTKEY                    hEncryptKey,
    IN PCERT_PUBLIC_KEY_INFO        pPublicKeyInfo,
    OUT PBYTE                       pbData,
    IN OUT DWORD                    rgcbData[2]);

static const CRYPT_OID_FUNC_ENTRY ExportEncryptKeyFuncTable[] = {
    szOID_RSA_RSA, ICM_DefaultExportEncryptKey
};
#define EXPORT_ENCRYPT_KEY_FUNC_COUNT (sizeof(ExportEncryptKeyFuncTable) / \
                                        sizeof(ExportEncryptKeyFuncTable[0]))

//+-------------------------------------------------------------------------
//  ImportEncryptKey OID Installable Functions (OldStyle)
//--------------------------------------------------------------------------

BOOL
WINAPI
ICM_DefaultImportEncryptKey(
    IN HCRYPTPROV                   hCryptProv,
    IN DWORD                        dwKeySpec,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiPubKey,
    IN PBYTE                        pbEncodedKey,
    IN DWORD                        cbEncodedKey,
    OUT HCRYPTKEY                   *phEncryptKey);

static const CRYPT_OID_FUNC_ENTRY ImportEncryptKeyFuncTable[] = {
    szOID_OIWSEC_desCBC, ICM_DefaultImportEncryptKey,
    szOID_RSA_DES_EDE3_CBC, ICM_DefaultImportEncryptKey,
    szOID_RSA_RC2CBC, ICM_DefaultImportEncryptKey,
    szOID_RSA_RC4, ICM_DefaultImportEncryptKey
};
#define IMPORT_ENCRYPT_KEY_FUNC_COUNT (sizeof(ImportEncryptKeyFuncTable) / \
                                        sizeof(ImportEncryptKeyFuncTable[0]))

#ifdef DEBUG_CRYPT_ASN1_MASTER
static HMODULE hOssCryptDll = NULL;
#endif  // DEBUG_CRYPT_ASN1_MASTER

#ifdef DEBUG_CRYPT_ASN1

#define DEBUG_OSS_CRYPT_ASN1_CMSG_FLAG              0x010
#define DEBUG_OSS_CRYPT_ASN1_CMSG_COMPARE_FLAG      0x020
#define DEBUG_OSS_CRYPT_ASN1_SAME_ENCRYPT_FLAG      0x100

static BOOL fGotDebugCryptAsn1Flags = FALSE;
static int iDebugCryptAsn1Flags = 0;

int
WINAPI
ICMTest_GetDebugCryptAsn1Flags();

#endif  // DEBUG_CRYPT_ASN1

//+-------------------------------------------------------------------------
//  Function:  CryptMsgDllMain
//
//  Synopsis:  Initialize the CryptMsg module
//
//  Returns:   FALSE iff failed
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptMsgDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    BOOL        fRet;

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CRYPT_OID_ENCODE_OBJECT_FUNC,
                ICM_ENCODE_FUNC_COUNT,
                ICM_EncodeFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError; 
        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CRYPT_OID_DECODE_OBJECT_FUNC,
                ICM_DECODE_FUNC_COUNT,
                ICM_DecodeFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError; 

#ifdef CMS_PKCS7
        if (NULL == (hOldStyleGenEncryptKeyFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_GEN_ENCRYPT_KEY_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;
        if (NULL == (hOldStyleExportEncryptKeyFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_EXPORT_ENCRYPT_KEY_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;
        if (NULL == (hOldStyleImportEncryptKeyFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_IMPORT_ENCRYPT_KEY_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;

        if (NULL == (hGenContentEncryptKeyFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_GEN_CONTENT_ENCRYPT_KEY_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;

        if (NULL == (hExportKeyTransFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_EXPORT_KEY_TRANS_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;
        if (NULL == (hExportKeyAgreeFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_EXPORT_KEY_AGREE_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;
        if (NULL == (hExportMailListFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_EXPORT_MAIL_LIST_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;

        if (NULL == (hImportKeyTransFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_IMPORT_KEY_TRANS_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;
        if (NULL == (hImportKeyAgreeFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_IMPORT_KEY_AGREE_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;
        if (NULL == (hImportMailListFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_IMPORT_MAIL_LIST_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;

        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CMSG_OID_GEN_CONTENT_ENCRYPT_KEY_FUNC,
                1,
                GenContentEncryptKeyFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError; 

        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CMSG_OID_EXPORT_KEY_TRANS_FUNC,
                1,
                ExportKeyTransFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError; 
        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CMSG_OID_EXPORT_KEY_AGREE_FUNC,
                1,
                ExportKeyAgreeFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError; 
        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CMSG_OID_EXPORT_MAIL_LIST_FUNC,
                1,
                ExportMailListFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError; 

        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CMSG_OID_IMPORT_KEY_TRANS_FUNC,
                1,
                ImportKeyTransFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError; 
        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CMSG_OID_IMPORT_KEY_AGREE_FUNC,
                1,
                ImportKeyAgreeFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError; 
        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CMSG_OID_IMPORT_MAIL_LIST_FUNC,
                1,
                ImportMailListFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError; 
#else

        if (NULL == (hGenEncryptKeyFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_GEN_ENCRYPT_KEY_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;
        if (NULL == (hExportEncryptKeyFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_EXPORT_ENCRYPT_KEY_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;
        if (NULL == (hImportEncryptKeyFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_IMPORT_ENCRYPT_KEY_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;
#endif  // CMS_PKCS7

        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CMSG_OID_GEN_ENCRYPT_KEY_FUNC,
                GEN_ENCRYPT_KEY_FUNC_COUNT,
                GenEncryptKeyFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError; 
        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CMSG_OID_EXPORT_ENCRYPT_KEY_FUNC,
                EXPORT_ENCRYPT_KEY_FUNC_COUNT,
                ExportEncryptKeyFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError; 
        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CMSG_OID_IMPORT_ENCRYPT_KEY_FUNC,
                IMPORT_ENCRYPT_KEY_FUNC_COUNT,
                ImportEncryptKeyFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError; 

#ifdef OSS_CRYPT_ASN1
        if (0 == (ICM_hAsn1Module = I_CryptInstallAsn1Module(pkcs, 0, NULL)))
            goto CryptInstallAsn1ModuleError;
#else
        PKCS_Module_Startup();
        if (0 == (ICM_hAsn1Module = I_CryptInstallAsn1Module(
                PKCS_Module, 0, NULL))) {
            PKCS_Module_Cleanup();
            goto CryptInstallAsn1ModuleError;
        }
#endif  // OSS_CRYPT_ASN1

        break;

    case DLL_PROCESS_DETACH:
#ifdef DEBUG_CRYPT_ASN1_MASTER
        if (hOssCryptDll) {
            FreeLibrary(hOssCryptDll);
            hOssCryptDll = NULL;
        }
#endif  // DEBUG_CRYPT_ASN1_MASTER
        I_CryptUninstallAsn1Module(ICM_hAsn1Module);
#ifndef OSS_CRYPT_ASN1
        PKCS_Module_Cleanup();
#endif  // OSS_CRYPT_ASN1
    case DLL_THREAD_DETACH:
    default:
        break;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(CryptInstallAsn1ModuleError)
TRACE_ERROR(CryptInstallOIDFunctionAddressError)
TRACE_ERROR(CryptInitOIDFunctionSetError)
lpReserved;
hInst;
}

//+-------------------------------------------------------------------------
//  Utility routines
//--------------------------------------------------------------------------
LONG
WINAPI
ICM_PszOidToIndex(
    IN LPSTR pszOID)
{
    LONG    i;

    for (i=COUNTOF_apszObjIdPKCS7; i>0; i--)
        if (0 == strcmp( apszObjIdPKCS7[i-1], pszOID))
            break;

    return i;
}


LONG
WINAPI
ICM_ObjIdToIndex(
    IN ObjectID *poi)
{
    LONG    i;
    LONG    j;

    for (i=COUNTOF_aoidMessages; i>0; i--) {
        if (aoidMessages[i-1].count == poi->count) {
            for (j=poi->count; j>0; j--)
                if (poi->value[j-1] != aoidMessages[i-1].value[j-1])
                    goto next;
            break;
        }
        next:
        ;
    }

    return i;
}


BOOL
WINAPI
ICM_CopyOssObjectIdentifier(
    OUT ObjectID    *poiDst,
    IN  ObjectID    *poiSrc)
{
    USHORT  i;
    ULONG   *pulDst;
    ULONG   *pulSrc;

    poiDst->count = poiSrc->count;
    for (i=poiSrc->count, pulDst=poiDst->value, pulSrc=poiSrc->value;
            i>0;
            i--, pulDst++, pulSrc++)
        *pulDst = *pulSrc;

    return TRUE;
}


BOOL
WINAPI
ICM_IsData(
    IN  LPSTR   pszContentType)
{
    return !pszContentType || (0 == strcmp( pszContentType, pszObjIdDataType));
}


BOOL
WINAPI
ICM_ReverseInPlace(
    IN OUT PBYTE    pbIn,
    IN const ULONG  cbIn)
{
    PBYTE   pbLo;
    PBYTE   pbHi;
    BYTE    bTmp;

    for (pbLo = pbIn, pbHi = pbIn + cbIn - 1; pbLo < pbHi; pbHi--, pbLo++) {
        bTmp = *pbHi;
        *pbHi = *pbLo;
        *pbLo = bTmp;
    }

    return TRUE;
}


BOOL
WINAPI
ICM_ReverseCopy(
    OUT PBYTE   pbOut,
    IN PBYTE    pbInOrg,
    IN ULONG    cbIn)
{
    PBYTE   pbIn = pbInOrg + cbIn - 1;

    while (cbIn-- > 0)
        *pbOut++ = *pbIn--;

    return TRUE;
}


//
// return FALSE iff equal
//
BOOL
WINAPI
ICM_ReverseCompare(
    IN PBYTE    pbInOrg1,
    IN PBYTE    pbInOrg2,
    IN ULONG    cb)
{
    PBYTE   pbIn1 = pbInOrg1;
    PBYTE   pbIn2 = pbInOrg2 + cb - 1;

    while (cb-- > 0)
        if (*pbIn1++ != *pbIn2--)
            return TRUE;

    return FALSE;
}


BOOL
WINAPI
ICM_CopyOut(
    IN PBYTE        pbData,
    IN DWORD        cbData,
    OUT PBYTE       pbOut,
    IN OUT PDWORD   pcbOut)
{
    BOOL            fRet = TRUE;

    if (pbOut) {
        if (*pcbOut < cbData) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fRet = FALSE;
        } else {
            memcpy(pbOut, pbData, cbData);
        }
    }
    *pcbOut = cbData;

    return fRet;
}


//+-------------------------------------------------------------------------
//  Copy out the encoding of the length octets for a specified content length.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetLengthOctets(
    IN DWORD            cbContent,
    OUT OPTIONAL PBYTE  pbOut,
    IN OUT PDWORD       pcbOut)
{
    BOOL            fRet;
    BYTE            rgbLength[5];
    DWORD           cbLength;

    if (cbContent < 0x80) {
        rgbLength[0] = (BYTE)cbContent;
        cbLength = 0;
    } else {
        if (cbContent > 0xffffff)
            cbLength = 4;
        else if (cbContent > 0xffff)
            cbLength = 3;
        else if (cbContent > 0xff)
            cbLength = 2;
        else
            cbLength = 1;
        if (pbOut) {
            rgbLength[0] = (BYTE)cbLength | 0x80;
            ICM_ReverseCopy( (PBYTE)(rgbLength+1), (PBYTE)&cbContent, cbLength);
        }
    }

    if (pbOut) {
        fRet = ICM_CopyOut( (PBYTE)rgbLength, cbLength+1, pbOut, pcbOut);
    } else {
        fRet = TRUE;
    }
    *pcbOut = cbLength + 1;

    assert(fRet);
    return fRet;
}


//+-------------------------------------------------------------------------
//  Copy out a buffer, prepending the identifier and length octets for a
//  DER encoding.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_CopyOutAddDERPrefix(
    IN PBYTE            pbContent,
    IN DWORD            cbContent,
    IN OPTIONAL BYTE    bTag,
    OUT PBYTE           pbOut,
    IN OUT PDWORD       pcbOut)
{
    BOOL            fRet;
    BYTE            rgbLength[5];
    DWORD           cbLength;
    DWORD           cbData;

    cbLength = sizeof(rgbLength);
    if (!ICM_GetLengthOctets( cbContent, (PBYTE)rgbLength, &cbLength))
        goto GetLengthOctetsError;

    fRet = TRUE;
    cbData = 1 + cbLength + cbContent;
    if (pbOut) {
        if (*pcbOut < cbData) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fRet = FALSE;
        } else {
            *pbOut++ = bTag;
            memcpy(pbOut, rgbLength, cbLength);
            pbOut += cbLength;
            memcpy(pbOut, pbContent, cbContent);
        }
    }

CommonReturn:
    *pcbOut = cbData;
    return fRet;

ErrorReturn:
    cbData = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetLengthOctetsError)    // error already set
}


BOOL
WINAPI
ICM_GetSizeFromExtra(
    IN LONG         lRemainExtra,
    OUT PVOID       pOut,
    IN OUT DWORD    *pcbOut)
{
    BOOL            fRet = TRUE;

    if ((lRemainExtra < 0) && pOut) {
        SetLastError((DWORD) ERROR_MORE_DATA);
        fRet = FALSE;
    }
    *pcbOut = (DWORD)((LONG)*pcbOut - lRemainExtra);

    return fRet;
}


VOID
WINAPI
ICM_SetLastError(
    IN DWORD    dwError)
{
    if (dwError != ERROR_SUCCESS)
        SetLastError( dwError);
}


//+-------------------------------------------------------------------------
//  Encode an OSS struct to a blob, internally allocated
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_Asn1Encode(
    ASN1uint32_t            pdunum,
    IN PVOID                pOssInfo,
    OUT PCRYPT_DATA_BLOB    pBlob)
{
    BOOL            fRet;
    PBYTE           pbEncoded = NULL;
    DWORD           cbEncoded;
    ASN1encoding_t  pEnc = ICM_GetEncoder();
    DWORD           dwError = ERROR_SUCCESS;

    if (!PkiAsn1EncodeInfo(
            pEnc,
            pdunum,
            pOssInfo,
            NULL,           // pbEncoded
            &cbEncoded))
        goto EncodeSizeError;
    if (NULL == (pbEncoded = (PBYTE)ICM_Alloc( cbEncoded)))
        goto AllocError;
    if (!PkiAsn1EncodeInfo(
            pEnc,
            pdunum,
            pOssInfo,
            pbEncoded,
            &cbEncoded))
        goto EncodeError;

    fRet = TRUE;
CommonReturn:
    pBlob->pbData = pbEncoded;
    pBlob->cbData = cbEncoded;
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    ICM_Free(pbEncoded);
    pbEncoded = NULL;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(EncodeSizeError)    // error already set
TRACE_ERROR(AllocError)         // error already set
TRACE_ERROR(EncodeError)        // error already set
}

//+-------------------------------------------------------------------------
//  Given an OID, return the CAPI algorithm
//
//  Caller sets error.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetCAPIFromOID(
    IN DWORD                        dwGroupId,
    IN LPSTR                        pszObjId,
    OUT PDWORD                      pdwAlgId)
{
    BOOL            fRet;
    PCCRYPT_OID_INFO pOIDInfo;

    if (NULL == (pOIDInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            pszObjId,
            dwGroupId))) goto ErrorReturn;
    *pdwAlgId = pOIDInfo->Algid;
    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    *pdwAlgId = 0;
    fRet = FALSE;
    goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  Given an CRYPT_ALGORITHM_IDENTIFIER, return the CAPI algorithm
//
//  Caller sets error.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetCAPI(
    IN DWORD                        dwGroupId,
    IN PCRYPT_ALGORITHM_IDENTIFIER  pai,
    OUT PDWORD                      pdwAlgId)
{
    return ICM_GetCAPIFromOID(dwGroupId, pai->pszObjId, pdwAlgId);
}

//+-------------------------------------------------------------------------
//  Given an OSS AlgorithmIdentifier, return the OID Info
//
//  Caller sets error.
//--------------------------------------------------------------------------
PCCRYPT_OID_INFO
WINAPI
ICM_GetOssOIDInfo(
    IN DWORD                    dwGroupId,
    IN AlgorithmIdentifier      *poai)
{
    PCCRYPT_OID_INFO            pInfo;
    CRYPT_ALGORITHM_IDENTIFIER  ai;   ZEROSTRUCT( ai);

    if (!ICM_Asn1FromAlgorithmIdentifier( poai, &ai))
        goto Asn1FromAlgorithmIdentifierError;

    pInfo = CryptFindOIDInfo(
        CRYPT_OID_INFO_OID_KEY,
        ai.pszObjId,
        dwGroupId);
CommonReturn:
    ICM_Free( ai.pszObjId);
    return pInfo;

ErrorReturn:
    pInfo = NULL;
    goto CommonReturn;
TRACE_ERROR(Asn1FromAlgorithmIdentifierError)
}


//+-------------------------------------------------------------------------
//  Given an OSS AlgorithmIdentifier, return the CAPI algorithm
//
//  Caller sets error.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssCAPI(
    IN DWORD                    dwGroupId,
    IN AlgorithmIdentifier      *poai,
    OUT PDWORD                  pdwAlgId)
{
    BOOL                        fRet;
    CRYPT_ALGORITHM_IDENTIFIER  ai;   ZEROSTRUCT( ai);

    if (!ICM_Asn1FromAlgorithmIdentifier( poai, &ai))
        goto Asn1FromAlgorithmIdentifierError;

    fRet = ICM_GetCAPI( dwGroupId, &ai, pdwAlgId);
CommonReturn:
    ICM_Free( ai.pszObjId);
    return fRet;

ErrorReturn:
    *pdwAlgId = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(Asn1FromAlgorithmIdentifierError)
}

//+-------------------------------------------------------------------------
//  Allocate and NOCOPY decode
//--------------------------------------------------------------------------
PVOID
WINAPI
ICM_AllocAndDecodeObject(
    IN LPCSTR lpszStructType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded
    )
{
    void *pvStructInfo = NULL;
    DWORD cbStructInfo;
    
    if (!CryptDecodeObject(
            X509_ASN_ENCODING,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            CRYPT_DECODE_NOCOPY_FLAG,
            NULL,                   // pvStructInfo
            &cbStructInfo
            ) || 0 == cbStructInfo)
        goto DecodeError;
    if (NULL == (pvStructInfo = ICM_Alloc(cbStructInfo)))
        goto OutOfMemory;
    if (!CryptDecodeObject(
            X509_ASN_ENCODING,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            CRYPT_DECODE_NOCOPY_FLAG,
            pvStructInfo,
            &cbStructInfo
            ))
        goto DecodeError;

CommonReturn:
    return pvStructInfo;
ErrorReturn:
    ICM_Free(pvStructInfo);
    pvStructInfo = NULL;
    goto CommonReturn;
TRACE_ERROR(DecodeError)
TRACE_ERROR(OutOfMemory)
}

PCRYPT_ALGORITHM_IDENTIFIER
WINAPI
ICM_AllocAndGetALGORITHM_IDENTIFIER(
    IN AlgorithmIdentifier *paiOss)
{
    PCRYPT_ALGORITHM_IDENTIFIER pai = NULL;
    DWORD cbData;

    if (!ICM_GetALGORITHM_IDENTIFIER(
            paiOss,
            NULL,               // pvData
            &cbData) || 0 == cbData)
        goto GetAlgorithmError;
    if (NULL == (pai = (PCRYPT_ALGORITHM_IDENTIFIER)ICM_Alloc(cbData)))
        goto OutOfMemory;;
    if (!ICM_GetALGORITHM_IDENTIFIER(
            paiOss,
            pai,
            &cbData))
        goto GetAlgorithmError;

CommonReturn:
    return pai;
ErrorReturn:
    ICM_Free(pai);
    pai = NULL;
    goto CommonReturn;
TRACE_ERROR(GetAlgorithmError);
TRACE_ERROR(OutOfMemory)

}

#ifdef CMS_PKCS7

void *
WINAPI
ICM_AllocAndGetParam(
    IN PCRYPT_MSG_INFO pcmi,
    IN DWORD dwParamType,
    IN DWORD dwIndex,
    OUT OPTIONAL DWORD *pcbData = NULL
    )
{
    void *pvData = NULL;
    DWORD cbData;

    if (!CryptMsgGetParam(
            (HCRYPTMSG) pcmi,
            dwParamType,
            dwIndex,
            NULL,                   // pvData
            &cbData))
        goto CryptMsgGetParamError;
    if (0 == cbData)
        goto NoParamData;
    if (NULL == (pvData = ICM_Alloc(cbData)))
        goto OutOfMemory;
    if (!CryptMsgGetParam(
            (HCRYPTMSG) pcmi,
            dwParamType,
            dwIndex,
            pvData,
            &cbData))
        goto CryptMsgGetParamError;

CommonReturn:
    if (pcbData)
        *pcbData = cbData;
    return pvData;
ErrorReturn:
    if (pvData) {
        ICM_Free(pvData);
        pvData = NULL;
    }
    cbData = 0;
    goto CommonReturn;
TRACE_ERROR(CryptMsgGetParamError)
TRACE_ERROR(OutOfMemory)
SET_ERROR(NoParamData, CRYPT_E_INVALID_MSG_TYPE)
}

#endif  // CMS_PKCS7

BOOL
WINAPI
ICM_RC2VersionToBitLength(
    IN DWORD        dwVersion,
    OUT PDWORD      pdwBitLen
    )
{
    BOOL fRet;
    DWORD dwBitLen;

    switch (dwVersion) {
        case CRYPT_RC2_40BIT_VERSION:
            dwBitLen = 40;
            break;
        case CRYPT_RC2_56BIT_VERSION:
            dwBitLen = 56;
            break;
        case CRYPT_RC2_64BIT_VERSION:
            dwBitLen = 64;
            break;
        case CRYPT_RC2_128BIT_VERSION:
            dwBitLen = 128;
            break;
        default:
            goto InvalidRC2VersionError;
    }

    fRet = TRUE;
CommonReturn:
    *pdwBitLen = dwBitLen;
    return fRet;

ErrorReturn:
    dwBitLen = 0;
    fRet = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidRC2VersionError, CRYPT_E_BAD_ENCODE)
}

BOOL
WINAPI
ICM_BitLengthToRC2Version(
    IN DWORD        dwBitLen,
    OUT PDWORD      pdwVersion
    )
{
    BOOL fRet;
    DWORD dwVersion;

    switch (dwBitLen) {
        case 40:
            dwVersion = CRYPT_RC2_40BIT_VERSION;
            break;
        case 56:
            dwVersion = CRYPT_RC2_56BIT_VERSION;
            break;
        case 64:
            dwVersion = CRYPT_RC2_64BIT_VERSION;
            break;
        case 128:
            dwVersion = CRYPT_RC2_128BIT_VERSION;
            break;
        default:
            goto InvalidArg;
    }

    fRet = TRUE;
CommonReturn:
    *pdwVersion = dwVersion;
    return fRet;

ErrorReturn:
    dwVersion = 0xFFFFFFFF;
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidArg, E_INVALIDARG)
}

#define IV_LENGTH                   8

// For RC4, the maximum salt length, (128 - 40)/8 = 11.
#define IV_MAX_LENGTH               11

#define AUX_INFO_BIT_LENGTH_MASK    0xFFFF

//+-------------------------------------------------------------------------
//  Get the CAPI ALG_ID corresponding to the encryption OID. If the
//  ASN.1 encryption algorithm has any parameters, decode to get IV and
//  key bit length.
//
//  Note, for RC4, the IV is its salt.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetEncryptParameters(
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    OUT PDWORD                      pdwAlgIdEncrypt,
    OUT PDWORD                      pdwBitLen,          // 0 => default length
    OUT BYTE                        rgbIV[IV_MAX_LENGTH],
    OUT PDWORD                      pcbIV
    )
{
    BOOL fRet;
    PCRYPT_DATA_BLOB pIVBlob = NULL;
    PCRYPT_RC2_CBC_PARAMETERS pRC2Para = NULL;

    *pdwBitLen = 0;
    *pcbIV = 0;

    if (!ICM_GetCAPI(
            CRYPT_ENCRYPT_ALG_OID_GROUP_ID,
            paiEncrypt,
            pdwAlgIdEncrypt))
        goto GetCAPIError;

    // Check if more than just the NULL parameters
    if (2 < paiEncrypt->Parameters.cbData) {
        PBYTE pbIV = NULL;
        DWORD cbIV = 0;
        PBYTE pbEncoded = paiEncrypt->Parameters.pbData;
        DWORD cbEncoded = paiEncrypt->Parameters.cbData;

        if (CALG_RC2 == *pdwAlgIdEncrypt) {
            // Try to decode as RC2_CBC parameters
            if (pRC2Para =
                    (PCRYPT_RC2_CBC_PARAMETERS) ICM_AllocAndDecodeObject(
                        PKCS_RC2_CBC_PARAMETERS,
                        pbEncoded,
                        cbEncoded)) {
                if (!ICM_RC2VersionToBitLength(pRC2Para->dwVersion, pdwBitLen))
                    goto RC2VersionToBitLengthError;
                if (pRC2Para->fIV) {
                    pbIV = pRC2Para->rgbIV;
                    cbIV = sizeof(pRC2Para->rgbIV);
                }
            }
        }

        if (NULL == pRC2Para) {
            // Try to decode as an OctetString containing the IV or the
            // salt for RC4
            if (pIVBlob = (PCRYPT_DATA_BLOB) ICM_AllocAndDecodeObject(
                    X509_OCTET_STRING,
                    pbEncoded,
                    cbEncoded)) {
                pbIV = pIVBlob->pbData;
                cbIV = pIVBlob->cbData;
            } else
                goto DecodeError;
        }

        if (0 != cbIV) {
            if (IV_LENGTH != cbIV &&
                    (CALG_RC4 != *pdwAlgIdEncrypt ||
                        IV_MAX_LENGTH < cbIV))
                goto InvalidIVLengthError;
            memcpy(rgbIV, pbIV, cbIV);
            *pcbIV = cbIV;
        }
    }
    fRet = TRUE;
CommonReturn:
    ICM_Free(pIVBlob);
    ICM_Free(pRC2Para);
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

SET_ERROR(GetCAPIError, CRYPT_E_UNKNOWN_ALGO)
TRACE_ERROR(DecodeError)
TRACE_ERROR(RC2VersionToBitLengthError)
SET_ERROR(InvalidIVLengthError, CRYPT_E_BAD_ENCODE)
}

#ifdef CMS_PKCS7

//+-------------------------------------------------------------------------
//  Get the CAPI ALG_ID corresponding to the encryption OID. Generate
//  default parameters for and encode. For RC2, encode as RC2_CBC parameters.
//  For all others encode as an IV octet string. The IV is initialized by
//  calling CryptGenRandom. For RC4, the IV is really its salt.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_CreateDefaultEncryptParameters(
    IN OUT PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    OUT PDWORD pdwAlgIdEncrypt,
    OUT PDWORD pdwBitLen,          // 0 => default length
    OUT BYTE rgbIV[IV_MAX_LENGTH],
    OUT PDWORD pcbIV
    )
{
    BOOL fRet;
    HCRYPTPROV hCryptProv;      // doesn't need to be released
    CRYPT_RC2_CBC_PARAMETERS RC2Para;
    CRYPT_DATA_BLOB IVPara;
    void *pvPara;
    LPCSTR pszStructType;
    PCRYPT_ALGORITHM_IDENTIFIER paiEncrypt =
        &pContentEncryptInfo->ContentEncryptionAlgorithm;
    DWORD dwBitLen = 0;
    DWORD cbIV = IV_LENGTH;

    CRYPT_ENCODE_PARA EncodePara;

    // Get provider to use for generating the random IV or RC4 salt
    hCryptProv = I_CryptGetDefaultCryptProv(0);
    if (0 == hCryptProv)
        goto GetDefaultCryptProvError;

    if (!ICM_GetCAPI(
            CRYPT_ENCRYPT_ALG_OID_GROUP_ID,
            paiEncrypt,
            pdwAlgIdEncrypt))
        goto GetCAPIError;


    if (CALG_RC2 == *pdwAlgIdEncrypt) {
        PCMSG_RC2_AUX_INFO pAuxInfo =
            (PCMSG_RC2_AUX_INFO) pContentEncryptInfo->pvEncryptionAuxInfo;

        if (pAuxInfo && pAuxInfo->cbSize >= sizeof(CMSG_RC2_AUX_INFO)) {
            dwBitLen = pAuxInfo->dwBitLen & AUX_INFO_BIT_LENGTH_MASK;
            if (!ICM_BitLengthToRC2Version(dwBitLen, &RC2Para.dwVersion))
                goto BitLengthToRC2VersionError;
        } else {
            // Default to 40 bits;
            dwBitLen = 40;
            RC2Para.dwVersion = CRYPT_RC2_40BIT_VERSION;
        }

        // Generate the random IV.
        if (!CryptGenRandom(hCryptProv, IV_LENGTH, rgbIV))
            goto GenRandomError;

        // Encode as RC2_CBC parameters
        RC2Para.fIV = TRUE;
        assert(sizeof(RC2Para.rgbIV) == IV_LENGTH);
        memcpy(RC2Para.rgbIV, rgbIV, sizeof(RC2Para.rgbIV));

        pvPara = &RC2Para;
        pszStructType = PKCS_RC2_CBC_PARAMETERS;
    } else {
        if (CALG_RC4 == *pdwAlgIdEncrypt) {
            // For RC4, the IV is really the RC4 salt. There are
            // (128 - dwBitLen)/8 bytes of RC4 salt.

            PCMSG_RC4_AUX_INFO pAuxInfo =
                (PCMSG_RC4_AUX_INFO) pContentEncryptInfo->pvEncryptionAuxInfo;

            // Default to no salt
            cbIV = 0;

            if (pAuxInfo && pAuxInfo->cbSize >= sizeof(CMSG_RC4_AUX_INFO)) {
                dwBitLen = pAuxInfo->dwBitLen & AUX_INFO_BIT_LENGTH_MASK;
                if (0 == (pAuxInfo->dwBitLen & CMSG_RC4_NO_SALT_FLAG) &&
                        128 > dwBitLen) {
                    cbIV = (128 - dwBitLen)/ 8;
                    if (IV_MAX_LENGTH < cbIV)
                        cbIV = IV_MAX_LENGTH;
                }
            }

            if (0 == cbIV)
                // No salt
                goto SuccessReturn;
        }

        // Generate the random IV or RC4 salt
        assert(0 < cbIV && IV_MAX_LENGTH >= cbIV);
        if (!CryptGenRandom(hCryptProv, cbIV, rgbIV))
            goto GenRandomError;

        IVPara.pbData = rgbIV;
        IVPara.cbData = cbIV;
        pvPara = &IVPara;
        pszStructType = X509_OCTET_STRING;
    }


    ZEROSTRUCT(EncodePara);
    EncodePara.cbSize = sizeof(EncodePara);
    EncodePara.pfnAlloc = pContentEncryptInfo->pfnAlloc;
    EncodePara.pfnFree = pContentEncryptInfo->pfnFree;
    if (!CryptEncodeObjectEx(
            X509_ASN_ENCODING,
            pszStructType,
            pvPara,
            CRYPT_ENCODE_ALLOC_FLAG,
            &EncodePara,
            (void *) &paiEncrypt->Parameters.pbData,
            &paiEncrypt->Parameters.cbData
            )) goto EncodeError;
    pContentEncryptInfo->dwFlags |= CMSG_CONTENT_ENCRYPT_FREE_PARA_FLAG;

SuccessReturn:
    fRet = TRUE;
CommonReturn:
    *pdwBitLen = dwBitLen;
    *pcbIV = cbIV;
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetDefaultCryptProvError)
SET_ERROR(GetCAPIError, CRYPT_E_UNKNOWN_ALGO)
TRACE_ERROR(BitLengthToRC2VersionError)
TRACE_ERROR(GenRandomError)
TRACE_ERROR(EncodeError)
}


BOOL
WINAPI
ICM_IsSP3CompatibleEncrypt(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo
    )
{
    void *pvEncryptAuxInfo = pContentEncryptInfo->pvEncryptionAuxInfo;
    BOOL fSP3CompatibleEncrypt = FALSE;

    if (pvEncryptAuxInfo) {
        PCMSG_SP3_COMPATIBLE_AUX_INFO pSP3AuxInfo =
            (PCMSG_SP3_COMPATIBLE_AUX_INFO) pvEncryptAuxInfo;
        if (sizeof(CMSG_SP3_COMPATIBLE_AUX_INFO) <= pSP3AuxInfo->cbSize &&
                (pSP3AuxInfo->dwFlags & CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG)) {
            fSP3CompatibleEncrypt = TRUE;
        }
    }

    return fSP3CompatibleEncrypt;
}

//+-------------------------------------------------------------------------
//  Default generation of the encryption key using the ASN.1 Encryption
//  algorithm OID and optional parameters.
//--------------------------------------------------------------------------
BOOL
WINAPI
#ifdef DEBUG_CRYPT_ASN1
ICMTest_DefaultGenContentEncryptKey(
#else
ICM_DefaultGenContentEncryptKey(
#endif
    IN OUT PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved
    )
{
    BOOL fRet;
    PCRYPT_ALGORITHM_IDENTIFIER paiEncrypt =
        &pContentEncryptInfo->ContentEncryptionAlgorithm;
    DWORD dwAlgIdEncrypt;
    BYTE rgbIV[IV_MAX_LENGTH];
    DWORD cbIV;
    DWORD dwBitLen;
    HCRYPTPROV hCryptProv;
    DWORD dwGenFlags;

    BOOL fSP3CompatibleEncrypt;

    fSP3CompatibleEncrypt = ICM_IsSP3CompatibleEncrypt(pContentEncryptInfo);
    if (fSP3CompatibleEncrypt) {
        cbIV = 0;
        dwBitLen = 0;

        if (!ICM_GetCAPI(
                CRYPT_ENCRYPT_ALG_OID_GROUP_ID,
                paiEncrypt,
                &dwAlgIdEncrypt))
            goto GetCAPIError;

    } else if (0 == paiEncrypt->Parameters.cbData) {
        if (!ICM_CreateDefaultEncryptParameters(
                pContentEncryptInfo,
                &dwAlgIdEncrypt,
                &dwBitLen,
                rgbIV,
                &cbIV))
            goto CreateDefaultEncryptParametersError;
    } else {
        if (!ICM_GetEncryptParameters(
                paiEncrypt,
                &dwAlgIdEncrypt,
                &dwBitLen,
                rgbIV,
                &cbIV))
            goto GetEncryptParametersError;
    }

    hCryptProv = pContentEncryptInfo->hCryptProv;
    if (0 == hCryptProv) {
        DWORD dwAlgIdPubKey = 0;

        if (0 < pContentEncryptInfo->cRecipients) {
            PCMSG_RECIPIENT_ENCODE_INFO prei;
            PCRYPT_ALGORITHM_IDENTIFIER paiPubKey;

            // Get pointer to public key algorithm associated with the first
            // recipient
            prei = &pContentEncryptInfo->rgCmsRecipients[0];
            switch (prei->dwRecipientChoice) {
                case CMSG_KEY_TRANS_RECIPIENT:
                    paiPubKey = &prei->pKeyTrans->KeyEncryptionAlgorithm;
                    break;
                case CMSG_KEY_AGREE_RECIPIENT:
                    paiPubKey = &prei->pKeyAgree->KeyEncryptionAlgorithm;
                    break;
                case CMSG_MAIL_LIST_RECIPIENT:
                default:
                    paiPubKey = NULL;
            }

            if (paiPubKey)
                ICM_GetCAPI(
                    CRYPT_PUBKEY_ALG_OID_GROUP_ID,
                    paiPubKey,
                    &dwAlgIdPubKey);
        }

        hCryptProv = I_CryptGetDefaultCryptProvForEncrypt(
            dwAlgIdPubKey, dwAlgIdEncrypt, dwBitLen);
        if (0 == hCryptProv)
            goto GetDefaultCryptProvError;
        else
            pContentEncryptInfo->hCryptProv = hCryptProv;
    }

    if (fSP3CompatibleEncrypt)
        dwGenFlags = CRYPT_EXPORTABLE;
    else
        dwGenFlags = CRYPT_EXPORTABLE | CRYPT_NO_SALT;
    dwGenFlags |= dwBitLen << 16;

    fRet = CryptGenKey(
            hCryptProv,
            dwAlgIdEncrypt,
            dwGenFlags,
            &pContentEncryptInfo->hContentEncryptKey);

    if (!fRet) {
        // Only need to provide backwards compatibility for
        // key transport recipients
        if (0 < pContentEncryptInfo->cRecipients) {
            PCMSG_RECIPIENT_ENCODE_INFO prei;

            prei = &pContentEncryptInfo->rgCmsRecipients[0];
            if (CMSG_KEY_TRANS_RECIPIENT != prei->dwRecipientChoice)
                goto GenKeyError;
        }

        if (dwBitLen) {
            // Try without setting key length
            dwGenFlags &= 0xFFFF;
            fRet = CryptGenKey(
                    hCryptProv,
                    dwAlgIdEncrypt,
                    dwGenFlags,
                    &pContentEncryptInfo->hContentEncryptKey);
        }

        if (!fRet && NTE_BAD_FLAGS == GetLastError())
            // Previous versions didn't support CRYPT_NO_SALT flag
            fRet = CryptGenKey(
                    hCryptProv,
                    dwAlgIdEncrypt,
                    CRYPT_EXPORTABLE,       // dwFlags
                    &pContentEncryptInfo->hContentEncryptKey);
        if (!fRet) {
            pContentEncryptInfo->hContentEncryptKey = 0;
            goto GenKeyError;
        }
    }

    if (CALG_RC2 == dwAlgIdEncrypt && 0 != dwBitLen)
        // Silently ignore any errors. Not supported in earlier versions
        CryptSetKeyParam(
            pContentEncryptInfo->hContentEncryptKey,
            KP_EFFECTIVE_KEYLEN,
            (PBYTE) &dwBitLen,
            0);                 // dwFlags

    if (0 != cbIV) {
        if (CALG_RC4 == dwAlgIdEncrypt) {
            // For RC4, set the SALT, not the IV

            CRYPT_DATA_BLOB SaltBlob;
            SaltBlob.pbData = rgbIV;
            SaltBlob.cbData = cbIV;

            if (!CryptSetKeyParam(
                    pContentEncryptInfo->hContentEncryptKey,
                    KP_SALT_EX,
                    (PBYTE) &SaltBlob,
                    0))                 // dwFlags
                goto SetSaltExError;
        } else {
            if (!CryptSetKeyParam(
                    pContentEncryptInfo->hContentEncryptKey,
                    KP_IV,
                    rgbIV,
                    0))                 // dwFlags
                goto SetIVError;
        }
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(GetCAPIError, CRYPT_E_UNKNOWN_ALGO)
TRACE_ERROR(CreateDefaultEncryptParametersError)
TRACE_ERROR(GetEncryptParametersError)
TRACE_ERROR(GetDefaultCryptProvError)
TRACE_ERROR(GenKeyError)
TRACE_ERROR(SetSaltExError)
TRACE_ERROR(SetIVError)
}


BOOL
WINAPI
ICM_GenContentEncryptKey(
    IN OUT PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo
    )
{
    BOOL fRet;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr = NULL;

    LPCSTR pszContentEncryptOID =
        pContentEncryptInfo->ContentEncryptionAlgorithm.pszObjId;

    if (CryptGetOIDFunctionAddress(
            hGenContentEncryptKeyFuncSet,
            X509_ASN_ENCODING,
            pszContentEncryptOID,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr)) {
        fRet = ((PFN_CMSG_GEN_CONTENT_ENCRYPT_KEY) pvFuncAddr)(
            pContentEncryptInfo,
            0,                      // dwFlags
            NULL                    // pvReserved
            );
    } else {
        if (pContentEncryptInfo->cRecipients
                        &&
                CMSG_KEY_TRANS_RECIPIENT ==
                    pContentEncryptInfo->rgCmsRecipients[0].dwRecipientChoice
                        &&
                CryptGetOIDFunctionAddress(
                    hOldStyleGenEncryptKeyFuncSet,
                    X509_ASN_ENCODING,
                    pszContentEncryptOID,
                    0,                      // dwFlags
                    &pvFuncAddr,
                    &hFuncAddr)
                        &&
#ifdef DEBUG_CRYPT_ASN1
                0 == (ICMTest_GetDebugCryptAsn1Flags() &
                            DEBUG_OSS_CRYPT_ASN1_SAME_ENCRYPT_FLAG)
                        &&
#endif // DEBUG_CRYPT_ASN1
                (void *) ICM_DefaultGenEncryptKey != pvFuncAddr) {
            PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO pKeyTrans =
                pContentEncryptInfo->rgCmsRecipients[0].pKeyTrans;
            CERT_PUBLIC_KEY_INFO PublicKeyInfo;
            PBYTE pbEncryptParameters = NULL;
            DWORD rgcbEncryptParameters[2] = {0, 0};

            PublicKeyInfo.Algorithm = pKeyTrans->KeyEncryptionAlgorithm;
            PublicKeyInfo.PublicKey = pKeyTrans->RecipientPublicKey;

            fRet = ((PFN_CMSG_GEN_ENCRYPT_KEY) pvFuncAddr)(
                &pContentEncryptInfo->hCryptProv,
                &pContentEncryptInfo->ContentEncryptionAlgorithm,
                pContentEncryptInfo->pvEncryptionAuxInfo,
                &PublicKeyInfo,
                pContentEncryptInfo->pfnAlloc,
                &pContentEncryptInfo->hContentEncryptKey,
                &pbEncryptParameters,
                rgcbEncryptParameters);
            if (pbEncryptParameters) {
                pContentEncryptInfo->ContentEncryptionAlgorithm.Parameters.pbData =
                    pbEncryptParameters;
                pContentEncryptInfo->ContentEncryptionAlgorithm.Parameters.cbData =
                    rgcbEncryptParameters[0];
                pContentEncryptInfo->dwFlags |=
                    CMSG_CONTENT_ENCRYPT_FREE_PARA_FLAG;
            }
        } else {
            fRet = ICM_DefaultGenContentEncryptKey(
                pContentEncryptInfo,
                0,                      // dwFlags
                NULL                    // pvReserved
                );
        }
    }

    if (hFuncAddr)
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    return fRet;
}

//+-------------------------------------------------------------------------
//  Default generation of the encryption key using the ASN.1 Encryption
//  algorithm OID and optional parameters.
//
//  rgcbEncryptParameters[1] is the dwEncryptFlags passed to
//  ICM_DefaultExportEncryptKey
//
//  OldStyle.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultGenEncryptKey(
    IN OUT HCRYPTPROV               *phCryptProv,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    IN PVOID                        pvEncryptAuxInfo,
    IN PCERT_PUBLIC_KEY_INFO        pPublicKeyInfo,
    IN PFN_CMSG_ALLOC               pfnAlloc,
    OUT HCRYPTKEY                   *phEncryptKey,
    OUT PBYTE                       *ppbEncryptParameters,
    OUT DWORD                       rgcbEncryptParameters[2])
{
    BOOL fRet;

    CMSG_CONTENT_ENCRYPT_INFO ContentEncryptInfo;
        ZEROSTRUCT(ContentEncryptInfo);
    CMSG_RECIPIENT_ENCODE_INFO CmsRecipientEncodeInfo;
        ZEROSTRUCT(CmsRecipientEncodeInfo);
    CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO KeyTransEncodeInfo;
        ZEROSTRUCT(KeyTransEncodeInfo);

    ContentEncryptInfo.cbSize = sizeof(ContentEncryptInfo);
    ContentEncryptInfo.hCryptProv = *phCryptProv;
    ContentEncryptInfo.ContentEncryptionAlgorithm = *paiEncrypt;
    ContentEncryptInfo.pvEncryptionAuxInfo = pvEncryptAuxInfo;
    ContentEncryptInfo.cRecipients = 1;
    ContentEncryptInfo.rgCmsRecipients = &CmsRecipientEncodeInfo;
    ContentEncryptInfo.pfnAlloc = pfnAlloc;
    ContentEncryptInfo.pfnFree = ICM_Free;
    // ContentEncryptInfo.hContentEncryptKey =
    // ContentEncryptInfo.dwFlags =

    CmsRecipientEncodeInfo.dwRecipientChoice = CMSG_KEY_TRANS_RECIPIENT;
    CmsRecipientEncodeInfo.pKeyTrans = &KeyTransEncodeInfo;

    KeyTransEncodeInfo.cbSize = sizeof(KeyTransEncodeInfo);
    KeyTransEncodeInfo.KeyEncryptionAlgorithm = pPublicKeyInfo->Algorithm;
    // KeyTransEncodeInfo.pvKeyEncryptionAuxInfo =
    // KeyTransEncodeInfo.hCryptProv =
    KeyTransEncodeInfo.RecipientPublicKey = pPublicKeyInfo->PublicKey;
    // KeyTransEncodeInfo.RecipientId =

    // dwEncryptFlags
    if (ICM_IsSP3CompatibleEncrypt(&ContentEncryptInfo))
        rgcbEncryptParameters[1] = CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG;
    else
        rgcbEncryptParameters[1] = 0;

    fRet = ICM_DefaultGenContentEncryptKey(
        &ContentEncryptInfo,
        0,                      // dwFlags
        NULL                    // pvReserved
        );

    assert(0 == (ContentEncryptInfo.dwFlags &
         CMSG_CONTENT_ENCRYPT_RELEASE_CONTEXT_FLAG));

    if (fRet) {
        if (ContentEncryptInfo.dwFlags & CMSG_CONTENT_ENCRYPT_FREE_PARA_FLAG) {
            *ppbEncryptParameters =
                ContentEncryptInfo.ContentEncryptionAlgorithm.Parameters.pbData;
            rgcbEncryptParameters[0] =
                ContentEncryptInfo.ContentEncryptionAlgorithm.Parameters.cbData;
        }

        *phCryptProv = ContentEncryptInfo.hCryptProv;
        *phEncryptKey = ContentEncryptInfo.hContentEncryptKey;
    } else {
        if (ContentEncryptInfo.dwFlags & CMSG_CONTENT_ENCRYPT_FREE_PARA_FLAG)
            ICM_Free(ContentEncryptInfo.ContentEncryptionAlgorithm.Parameters.pbData);
        if (ContentEncryptInfo.hContentEncryptKey) {
            DWORD dwErr = GetLastError();
            CryptDestroyKey(ContentEncryptInfo.hContentEncryptKey);
            SetLastError(dwErr);
        }
        *phEncryptKey = 0;
    }

    return fRet;
}

#else

//+-------------------------------------------------------------------------
//  Get the CAPI ALG_ID corresponding to the encryption OID. Generate
//  default parameters for and encode. For RC2, encode as RC2_CBC parameters.
//  For all others encode as an IV octet string. The IV is initialized by
//  calling CryptGenRandom.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_CreateDefaultEncryptParameters(
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    IN PVOID                        pvEncryptAuxInfo,
    IN PFN_CMSG_ALLOC               pfnAlloc,
    OUT PBYTE                       *ppbEncryptParameters,
    OUT PDWORD                      pcbEncryptParameters,
    OUT PDWORD                      pdwAlgIdEncrypt,
    OUT PDWORD                      pdwBitLen,          // 0 => default length
    OUT BYTE                        rgbIV[IV_LENGTH],
    OUT PDWORD                      pcbIV
    )
{
    BOOL fRet;
    HCRYPTPROV hCryptProv;      // doesn't need to be released
    CRYPT_RC2_CBC_PARAMETERS RC2Para;
    CRYPT_DATA_BLOB IVPara;
    void *pvPara;
    LPCSTR pszStructType;

    *ppbEncryptParameters = NULL;
    *pcbEncryptParameters = 0;
    *pdwBitLen = 0;
    *pcbIV = IV_LENGTH;

    if (!ICM_GetCAPI(
            CRYPT_ENCRYPT_ALG_OID_GROUP_ID,
            paiEncrypt,
            pdwAlgIdEncrypt))
        goto GetCAPIError;

    // Generate the random IV.
    hCryptProv = I_CryptGetDefaultCryptProv(0);
    if (0 == hCryptProv)
        goto GetDefaultCryptProvError;
    if (!CryptGenRandom(hCryptProv, IV_LENGTH, rgbIV))
        goto GenRandomError;

    if (CALG_RC2 == *pdwAlgIdEncrypt) {
        PCMSG_RC2_AUX_INFO pAuxInfo = (PCMSG_RC2_AUX_INFO) pvEncryptAuxInfo;

        if (pAuxInfo && pAuxInfo->cbSize >= sizeof(CMSG_RC2_AUX_INFO)) {
            *pdwBitLen = pAuxInfo->dwBitLen & ~CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG;
            if (!ICM_BitLengthToRC2Version(*pdwBitLen, &RC2Para.dwVersion))
                goto BitLengthToRC2VersionError;
        } else {
            // Default to 40 bits;
            *pdwBitLen = 40;
            RC2Para.dwVersion = CRYPT_RC2_40BIT_VERSION;
        }

        // Encode as RC2_CBC parameters
        RC2Para.fIV = TRUE;
        assert(sizeof(RC2Para.rgbIV) == IV_LENGTH);
        memcpy(RC2Para.rgbIV, rgbIV, sizeof(RC2Para.rgbIV));

        pvPara = &RC2Para;
        pszStructType = PKCS_RC2_CBC_PARAMETERS;
    } else {
        IVPara.pbData = rgbIV;
        IVPara.cbData = IV_LENGTH;
        pvPara = &IVPara;
        pszStructType = X509_OCTET_STRING;
    }

    if (!CryptEncodeObject(
            X509_ASN_ENCODING,
            pszStructType,
            pvPara,
            NULL,                   // pbEncoded
            pcbEncryptParameters
            )) goto EncodeError;
    if (NULL == (*ppbEncryptParameters = (PBYTE) pfnAlloc(
            *pcbEncryptParameters)))
        goto OutOfMemory;
    if (!CryptEncodeObject(
            X509_ASN_ENCODING,
            pszStructType,
            pvPara,
            *ppbEncryptParameters,
            pcbEncryptParameters
            )) goto EncodeError;
    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

SET_ERROR(GetCAPIError, CRYPT_E_UNKNOWN_ALGO)
TRACE_ERROR(BitLengthToRC2VersionError)
TRACE_ERROR(GetDefaultCryptProvError)
TRACE_ERROR(GenRandomError)
TRACE_ERROR(EncodeError)
TRACE_ERROR(OutOfMemory)
}


//+-------------------------------------------------------------------------
//  Default generation of the encryption key using the ASN.1 Encryption
//  algorithm OID and optional parameters.
//
//  rgcbEncryptParameters[1] is the dwEncryptFlags passed to
//  ICM_DefaultExportEncryptKey
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultGenEncryptKey(
    IN OUT HCRYPTPROV               *phCryptProv,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    IN PVOID                        pvEncryptAuxInfo,
    IN PCERT_PUBLIC_KEY_INFO        pPublicKeyInfo,
    IN PFN_CMSG_ALLOC               pfnAlloc,
    OUT HCRYPTKEY                   *phEncryptKey,
    OUT PBYTE                       *ppbEncryptParameters,
    OUT DWORD                       rgcbEncryptParameters[2])
{
    BOOL        fRet;
    DWORD       dwAlgIdEncrypt;
    HCRYPTPROV  hCryptProv;
    BYTE        rgbIV[IV_LENGTH];
    DWORD       cbIV;
    DWORD       dwBitLen;
    DWORD       dwEncryptFlags;

    *phEncryptKey = 0;

    dwEncryptFlags = 0;
    rgcbEncryptParameters[1] = 0;    // dwEncryptFlags
    if (pvEncryptAuxInfo) {
        PCMSG_SP3_COMPATIBLE_AUX_INFO pSP3AuxInfo =
            (PCMSG_SP3_COMPATIBLE_AUX_INFO) pvEncryptAuxInfo;
        if (sizeof(CMSG_SP3_COMPATIBLE_AUX_INFO) <= pSP3AuxInfo->cbSize &&
                (pSP3AuxInfo->dwFlags & CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG)) {
            dwEncryptFlags = CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG;
            rgcbEncryptParameters[1] = CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG;
        }
    }

    if (dwEncryptFlags & CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG) {
        cbIV = 0;
        dwBitLen = 0;

        if (!ICM_GetCAPI(
                CRYPT_ENCRYPT_ALG_OID_GROUP_ID,
                paiEncrypt,
                &dwAlgIdEncrypt))
            goto GetCAPIError;

    } else if (0 == paiEncrypt->Parameters.cbData) {
        if (!ICM_CreateDefaultEncryptParameters(
                paiEncrypt,
                pvEncryptAuxInfo,
                pfnAlloc,
                ppbEncryptParameters,
                rgcbEncryptParameters,
                &dwAlgIdEncrypt,
                &dwBitLen,
                rgbIV,
                &cbIV))
            goto CreateDefaultEncryptParametersError;
    } else {
        if (!ICM_GetEncryptParameters(
                paiEncrypt,
                &dwAlgIdEncrypt,
                &dwBitLen,
                rgbIV,
                &cbIV))
            goto GetEncryptParametersError;
    }

    hCryptProv = *phCryptProv;
    if (0 == hCryptProv) {
        DWORD dwAlgIdPubKey = 0;
        ICM_GetCAPI(
            CRYPT_PUBKEY_ALG_OID_GROUP_ID,
            &pPublicKeyInfo->Algorithm,
            &dwAlgIdPubKey);

        hCryptProv = I_CryptGetDefaultCryptProvForEncrypt(
            dwAlgIdPubKey, dwAlgIdEncrypt, dwBitLen);
        if (0 == hCryptProv)
            goto GetDefaultCryptProvError;
        else
            *phCryptProv = hCryptProv;
    }

    fRet = CryptGenKey(
            hCryptProv,
            dwAlgIdEncrypt,
            (dwEncryptFlags & CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG) ?
                CRYPT_EXPORTABLE :
                CRYPT_EXPORTABLE | CRYPT_NO_SALT,       // dwFlags
            phEncryptKey);
    if (!fRet) {
        if (NTE_BAD_FLAGS == GetLastError())
            // Previous versions didn't support CRYPT_NO_SALT flag
            fRet = CryptGenKey(
                    hCryptProv,
                    dwAlgIdEncrypt,
                    CRYPT_EXPORTABLE,       // dwFlags
                    phEncryptKey);
        if (!fRet) {
            *phEncryptKey = 0;    
            goto GenKeyError;
        }
    }

    if (CALG_RC2 == dwAlgIdEncrypt && 0 != dwBitLen)
        // Silently ignore any errors. Not supported in earlier versions
        CryptSetKeyParam(
            *phEncryptKey,
            KP_EFFECTIVE_KEYLEN,
            (PBYTE) &dwBitLen,
            0);                 // dwFlags

    if (0 != cbIV) {
        if (!CryptSetKeyParam(
                *phEncryptKey,
                KP_IV,
                rgbIV,
                0))                 // dwFlags
            goto SetKeyParamError;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    if (*phEncryptKey) {
        DWORD dwErr = GetLastError();
        CryptDestroyKey(*phEncryptKey);
        *phEncryptKey = 0;
        SetLastError(dwErr);
    }
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(GetCAPIError, CRYPT_E_UNKNOWN_ALGO)
TRACE_ERROR(CreateDefaultEncryptParametersError)
TRACE_ERROR(GetEncryptParametersError)
TRACE_ERROR(GetDefaultCryptProvError)
TRACE_ERROR(GenKeyError)
TRACE_ERROR(SetKeyParamError)
}

//+-------------------------------------------------------------------------
//  Get an hkey for content encryption for a particular algorithm
//
//  rgcbEncryptParameters[1] is the dwEncryptFlags passed to
//  ICM_ExportEncryptKey
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GenEncryptKey(
    IN OUT HCRYPTPROV               *phCryptProv,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    IN PVOID                        pvEncryptAuxInfo,
    IN PCERT_PUBLIC_KEY_INFO        pPublicKeyInfo,
    IN PFN_CMSG_ALLOC               pfnAlloc,
    OUT HCRYPTKEY                   *phEncryptKey,
    OUT PBYTE                       *ppbEncryptParameters,
    OUT DWORD                       rgcbEncryptParameters[2])
{
    BOOL fResult;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr;

    if (CryptGetOIDFunctionAddress(
            hGenEncryptKeyFuncSet,
            X509_ASN_ENCODING,
            paiEncrypt->pszObjId,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr)) {
        fResult = ((PFN_CMSG_GEN_ENCRYPT_KEY) pvFuncAddr)(
            phCryptProv,
            paiEncrypt,
            pvEncryptAuxInfo,
            pPublicKeyInfo,
            pfnAlloc,
            phEncryptKey,
            ppbEncryptParameters,
            rgcbEncryptParameters);
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    } else
        fResult = ICM_DefaultGenEncryptKey(
            phCryptProv,
            paiEncrypt,
            pvEncryptAuxInfo,
            pPublicKeyInfo,
            pfnAlloc,
            phEncryptKey,
            ppbEncryptParameters,
            rgcbEncryptParameters);
    return fResult;
}

#endif  // CMS_PKCS7


//+-------------------------------------------------------------------------
//  Advance the phase of a message
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_AdvanceMsgPhase(
    IN OUT PDWORD   pdwPhase,
    IN BOOL         fFinal)
{
    BOOL    fRet;
    DWORD   dwPhase = *pdwPhase;

    switch (dwPhase) {
    case PHASE_FIRST_ONGOING:
        dwPhase = fFinal ? PHASE_FIRST_FINAL : PHASE_FIRST_ONGOING;
        break;
    case PHASE_FIRST_FINAL:
        dwPhase = fFinal ? PHASE_SECOND_FINAL : PHASE_SECOND_ONGOING;
        break;
    case PHASE_SECOND_ONGOING:
        dwPhase = fFinal ? PHASE_SECOND_FINAL : PHASE_SECOND_ONGOING;
        break;
    case PHASE_SECOND_FINAL:
        goto TransitionFromSecondFinalError;
    default:
        goto InvalidPhaseError;
    }
    *pdwPhase = dwPhase;
    fRet = TRUE;

CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(TransitionFromSecondFinalError,CRYPT_E_MSG_ERROR)
SET_ERROR(InvalidPhaseError,CRYPT_E_MSG_ERROR)
}


//+-------------------------------------------------------------------------
//  Return the (cached) value of the hash
//
//  Returns FALSE iff conversion failed.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetListHashValue(
    IN CHashNode    *pnHash,
    OUT DWORD       *pcbHash,
    OUT PBYTE       *ppbHash)
{
    BOOL            fRet;
    PICM_HASH_INFO  pHashInfo;

    pHashInfo = pnHash->Data();

    if (0 == pHashInfo->HashBlob.cbData) {
        pHashInfo->HashBlob.pbData = NULL;
        if (!CryptGetHashParam(
                pHashInfo->hHash,
                HP_HASHVAL,
                NULL,                   // pbHash
                &pHashInfo->HashBlob.cbData,
                0))                     // dwFlags
            goto GetHashParamSizeError;
        pHashInfo->HashBlob.pbData = (PBYTE)ICM_Alloc(
                    pHashInfo->HashBlob.cbData);
        if (NULL == pHashInfo->HashBlob.pbData)
            goto HashAllocError;
        if (!CryptGetHashParam(
                pHashInfo->hHash,
                HP_HASHVAL,
                pHashInfo->HashBlob.pbData,
                &pHashInfo->HashBlob.cbData,
                0))                     // dwFlags
            goto GetHashParamError;
    }
    *pcbHash = pHashInfo->HashBlob.cbData;
    *ppbHash = pHashInfo->HashBlob.pbData;
    fRet = TRUE;

CommonReturn:
    return fRet;

ErrorReturn:
    if(pHashInfo->HashBlob.pbData != NULL) {
        ICM_Free(pHashInfo->HashBlob.pbData);
        pHashInfo->HashBlob.pbData = NULL;
    }
    *pcbHash = 0;
#if DBG
    *ppbHash = NULL;
#endif
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetHashParamSizeError)  // error already set
TRACE_ERROR(HashAllocError)         // error already set
TRACE_ERROR(GetHashParamError)      // error already set
}


//+-------------------------------------------------------------------------
//  Return a new hash handle equivalent to the original
//
//  Returns FALSE iff creation failed.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DupListHash(
    IN CHashNode    *pnHash,
    IN HCRYPTPROV   hCryptProv,
    OUT HCRYPTHASH  *phHash)
{
    DWORD           dwError = ERROR_SUCCESS;
    BOOL            fRet;
    PICM_HASH_INFO  pHashInfo = pnHash->Data();
    HCRYPTHASH      hHash = NULL;
    DWORD           cbHash;
    PBYTE           pbHash;

    if (!ICM_GetListHashValue(
            pnHash,
            &cbHash,
            &pbHash))
        goto GetListHashValueError;
    if (!CryptCreateHash(
            hCryptProv,
            pHashInfo->dwAlgoCAPI,
            NULL,               // hKey - optional for MAC
            0,                  // dwFlags
            &hHash))
        goto CreateHashError;
    if (!CryptSetHashParam(
            hHash,
            HP_HASHVAL,
            pbHash,
            0))                     // dwFlags
        goto SetHashParamError;

    fRet = TRUE;
CommonReturn:
    *phHash = hHash;
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    if (hHash)
        CryptDestroyHash( hHash);
    hHash = NULL;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetListHashValueError)  // error already set
TRACE_ERROR(CreateHashError)        // error already set
TRACE_ERROR(SetHashParamError)      // error already set
}

#ifndef CMS_PKCS7
//+-------------------------------------------------------------------------
//  Set a DigestAlgorithmIdentifiers
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_SetAsnDigestAlgorithmIdentifiers(
    OUT DigestAlgorithmIdentifiers  *podais,
    OUT PCRYPT_ALGORITHM_IDENTIFIER pai,
    IN DWORD                        cSigners,
    IN PCMSG_SIGNER_ENCODE_INFO     rgSigners,
    OUT HCRYPTPROV                  *phCryptProv,
    OUT DWORD                       *pdwKeySpec)
{
    DWORD                       dwError = ERROR_SUCCESS;
    BOOL                        fRet;
    DWORD                       i;
    PCMSG_SIGNER_ENCODE_INFO    psei;
    DigestAlgorithmIdentifier   *podai;

    *phCryptProv = NULL;


    // This code does not remove duplicates from the list of
    // algorithms. It is not wrong, but the output message is
    // unnecessarily bulky.
    if (cSigners) {
        podai = (DigestAlgorithmIdentifier *)ICM_AllocZero(
                        cSigners * sizeof( DigestAlgorithmIdentifier));
        if (NULL == podai)
            goto DigestAlgorithmIdentifierAllocError;
    } else {
        podai = NULL;
    }
    podais->count = cSigners;
    podais->value = podai;
    for (i=cSigners, psei=rgSigners; i>0; i--, psei++, podai++) {
        assert( psei->cbSize >= STRUCT_CBSIZE(CMSG_SIGNER_ENCODE_INFO,
            rgUnauthAttr));
        assert( psei->pvHashAuxInfo == NULL);
        if (psei->cbSize <
                    STRUCT_CBSIZE(CMSG_SIGNER_ENCODE_INFO, rgUnauthAttr) ||
                psei->pvHashAuxInfo != NULL)
            goto InvalidArg;
        *phCryptProv = psei->hCryptProv; // s/b array, one for each algo
        *pdwKeySpec = psei->dwKeySpec; // s/b array, one for each algo
        *pai = psei->HashAlgorithm;    // s/b array, one for each algo
        if (!ICM_Asn1ToAlgorithmIdentifier( &psei->HashAlgorithm, podai))
            goto Asn1ToAlgorithmIdentifierError;
    }

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    ICM_Free( podai);
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(DigestAlgorithmIdentifierAllocError)    // error already set
TRACE_ERROR(Asn1ToAlgorithmIdentifierError)      // error already set
SET_ERROR(InvalidArg,E_INVALIDARG)
}
#endif  // not defined CMS_PKCS7


//+-------------------------------------------------------------------------
//  Fill digestEncryptionAlgorithm
//--------------------------------------------------------------------------
STATIC
BOOL
WINAPI
ICM_FillAsnDigestEncryptionAlgorithm(
    IN PCRYPT_MSG_INFO pcmi,
    IN PCRYPT_ALGORITHM_IDENTIFIER pDigestEncryptAlg,
    IN OUT DigestEncryptionAlgId *pdea
    )
{
    BOOL fRet;
    CRYPT_ALGORITHM_IDENTIFIER DigestEncryptAlg;
    DWORD dwFlags;
    PCCRYPT_OID_INFO pOIDInfo;

    dwFlags = 0;

    if (pOIDInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            pDigestEncryptAlg->pszObjId,
            CRYPT_PUBKEY_ALG_OID_GROUP_ID)) {
        if (1 <= pOIDInfo->ExtraInfo.cbData / sizeof(DWORD)) {
            DWORD *pdwExtra = (DWORD *) pOIDInfo->ExtraInfo.pbData;
            dwFlags = pdwExtra[0];
        }

        // Check if more than just the NULL parameters
        if (2 < pDigestEncryptAlg->Parameters.cbData) {
            // Check if we should use the public key parameters
            if (0 == (dwFlags & CRYPT_OID_USE_PUBKEY_PARA_FOR_PKCS7_FLAG)) {
                memset(&DigestEncryptAlg, 0, sizeof(DigestEncryptAlg));
                DigestEncryptAlg.pszObjId = pDigestEncryptAlg->pszObjId;
                pDigestEncryptAlg = &DigestEncryptAlg;
            }
        }
    } else if (pOIDInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            pDigestEncryptAlg->pszObjId,
            CRYPT_SIGN_ALG_OID_GROUP_ID)) {
        if (2 <= pOIDInfo->ExtraInfo.cbData / sizeof(DWORD)) {
            DWORD *pdwExtra = (DWORD *) pOIDInfo->ExtraInfo.pbData;
            dwFlags = pdwExtra[1];
        }
    }

    if (!ICM_MsgAsn1ToAlgorithmIdentifier(
            pcmi,
            pDigestEncryptAlg,
            pdea))
        goto DigestEncryptionAsn1ToAlgorithmIdentifierError;

    if (0 == pDigestEncryptAlg->Parameters.cbData &&
            0 != (dwFlags & CRYPT_OID_NO_NULL_ALGORITHM_PARA_FLAG)) {
        // NO NULL parameters
        pdea->bit_mask &= ~parameters_present;
        pdea->parameters.length = 0;
        pdea->parameters.value = NULL;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(DigestEncryptionAsn1ToAlgorithmIdentifierError)  // error already set
}

void
WINAPI
ICM_GetCertIdFromCertInfo(
    IN PCERT_INFO               pCertInfo,
    OUT PCERT_ID                pCertId)
{
#ifndef _XBOX
    if (Asn1UtilExtractKeyIdFromCertInfo(pCertInfo, &pCertId->KeyId)) {
        pCertId->dwIdChoice = CERT_ID_KEY_IDENTIFIER;
    }
    else
#endif
    {
        pCertId->dwIdChoice = CERT_ID_ISSUER_SERIAL_NUMBER;
        pCertId->IssuerSerialNumber.Issuer = pCertInfo->Issuer;
        pCertId->IssuerSerialNumber.SerialNumber = pCertInfo->SerialNumber;
    }
}

BOOL
WINAPI
ICM_GetSignerIdFromSignerEncodeInfo(
    IN PCMSG_SIGNER_ENCODE_INFO psei,
    OUT PCERT_ID                pSignerId)
{
    BOOL fRet;
    if (STRUCT_CBSIZE(CMSG_SIGNER_ENCODE_INFO, SignerId) <= psei->cbSize &&
            psei->SignerId.dwIdChoice) {
        *pSignerId = psei->SignerId;
        if (!(CERT_ID_ISSUER_SERIAL_NUMBER == pSignerId->dwIdChoice ||
                CERT_ID_KEY_IDENTIFIER == pSignerId->dwIdChoice))
            goto InvalidSignerIdChoice;
    } else
        ICM_GetCertIdFromCertInfo(psei->pCertInfo, pSignerId);

    fRet = TRUE;
CommonReturn:
    return fRet;
ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidSignerIdChoice, E_INVALIDARG)
}

BOOL
WINAPI
ICM_SetOssCertIdentifier(
    IN PCERT_ID pCertId,
    IN OUT CertIdentifier *pOssCertId
    );

void
WINAPI
ICM_FreeOssCertIdentifier(
    IN OUT CertIdentifier *pOssCertId
    );

//+-------------------------------------------------------------------------
//  Fill a single SignerInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_FillAsnSignerInfo(
    IN PCMSG_SIGNER_ENCODE_INFO psei,
    IN PCRYPT_MSG_INFO          pcmi,
    IN DWORD                    dwFlags,
    IN OPTIONAL LPSTR           pszInnerContentObjID,
    IN OUT SignerInfo           *psi,
    IN OUT Attribute            **ppAuthAttr,
    IN OUT Attribute            **ppUnauthAttr)
{
    BOOL                fRet;
    Attribute           *pAuthAttr;
    Attribute           *pUnauthAttr;
    int                 i;
    PCRYPT_ATTRIBUTE    patr;
    PCRYPT_ALGORITHM_IDENTIFIER pDigestEncryptAlg;
    CERT_ID             SignerId;

    // psi->bit_mask = 0;

    if (!ICM_GetSignerIdFromSignerEncodeInfo(psei, &SignerId))
        goto GetSignerIdError;

    // version
    if (CERT_ID_ISSUER_SERIAL_NUMBER == SignerId.dwIdChoice)
        psi->version = CMSG_SIGNER_INFO_PKCS_1_5_VERSION;
    else
        psi->version = CMSG_SIGNER_INFO_CMS_VERSION;

    // sid
    if (!ICM_SetOssCertIdentifier(
            &SignerId,
            &psi->sid
            ))
        goto SetOssCertIdentifierError;

    // digestAlgorithm
    if (!ICM_MsgAsn1ToAlgorithmIdentifier(
            pcmi,
            &psei->HashAlgorithm,
            &psi->digestAlgorithm))
        goto DigestAsn1ToAlgorithmIdentifierError;

    // authenticatedAttributes
    if (!ICM_IsData( pszInnerContentObjID) ||
            psei->cAuthAttr ||
            (dwFlags & CMSG_AUTHENTICATED_ATTRIBUTES_FLAG)) {
        psi->bit_mask |= authenticatedAttributes_present;
        // NB - The actual number of authenticated attributes will be
        //      2 larger than requested, because of the 2 required
        //      attributes (if authenticated attributes are present).
        //      Leave room at the beginning of the attribute array.
        pAuthAttr = *ppAuthAttr;
        psi->authenticatedAttributes.count = psei->cAuthAttr + 2;
        psi->authenticatedAttributes.value = pAuthAttr;
        for (i=psei->cAuthAttr, patr=psei->rgAuthAttr, pAuthAttr+=2;
                i>0;
                i--, patr++, pAuthAttr++) {
            if (!ICM_Asn1ToAttribute( patr, pAuthAttr))
                goto Asn1AuthenticatedAttributeError;
        }
        *ppAuthAttr = pAuthAttr;
    }

    // digestEncryptionAlgorithm
#ifdef CMS_PKCS7
    if (STRUCT_CBSIZE(CMSG_SIGNER_ENCODE_INFO, HashEncryptionAlgorithm) <=
            psei->cbSize && psei->HashEncryptionAlgorithm.pszObjId)
        pDigestEncryptAlg = &psei->HashEncryptionAlgorithm;
    else
#endif  // CMS_PKCS7
        pDigestEncryptAlg = &psei->pCertInfo->SubjectPublicKeyInfo.Algorithm;
    if (!ICM_FillAsnDigestEncryptionAlgorithm(
            pcmi, pDigestEncryptAlg, &psi->digestEncryptionAlgorithm))
        goto FillAsnDigestEncryptionAlgorithmError;

    // encryptedDigest is filled in later, when we see the content

    // unauthenticatedAttributes
    if (0 != psei->cUnauthAttr) {
        psi->bit_mask |= unauthAttributes_present;
        pUnauthAttr = *ppUnauthAttr;
        psi->unauthAttributes.count = psei->cUnauthAttr;
        psi->unauthAttributes.value = pUnauthAttr;
        for (i=psei->cUnauthAttr, patr=psei->rgUnauthAttr;
                i>0;
                i--, patr++, pUnauthAttr++) {
            if (!ICM_Asn1ToAttribute( patr, pUnauthAttr))
                goto Asn1UnauthenticatedAttributeError;
        }
        *ppUnauthAttr = pUnauthAttr;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetSignerIdError)
TRACE_ERROR(SetOssCertIdentifierError)
TRACE_ERROR(DigestAsn1ToAlgorithmIdentifierError)
TRACE_ERROR(Asn1AuthenticatedAttributeError)
TRACE_ERROR(FillAsnDigestEncryptionAlgorithmError)
TRACE_ERROR(Asn1UnauthenticatedAttributeError)
}

//+-------------------------------------------------------------------------
//  Free SignerInfo allocated memory
//--------------------------------------------------------------------------
void
WINAPI
ICM_FreeAsnSignerInfo(
    IN OUT SignerInfo           *psi)
{
    Attribute   *poatr;
    DWORD       i;

    ICM_Free(psi->encryptedDigest.value);
    ICM_FreeOssCertIdentifier(&psi->sid);

    for (i=psi->authenticatedAttributes.count,
            poatr = psi->authenticatedAttributes.value;
            i>0;
            i--, poatr++)
        ICM_Free(poatr->attributeValue.value);
    for (i=psi->unauthAttributes.count,
            poatr=psi->unauthAttributes.value;
            i>0;
            i--, poatr++)
        ICM_Free( poatr->attributeValue.value);
}


//+-------------------------------------------------------------------------
//  Set a SignerInfos
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_SetAsnSignerInfos(
    IN PCMSG_SIGNED_ENCODE_INFO psmei,
    IN PCRYPT_MSG_INFO          pcmi,
    IN DWORD                    dwFlags,
    IN OPTIONAL LPSTR           pszInnerContentObjID,
    OUT SignerInfos             *psis,
    OUT BOOL                    *pfHasCmsSignerId)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    DWORD               i;
    DWORD               cAuthAttr;
    DWORD               cUnauthAttr;
    PCMSG_SIGNER_ENCODE_INFO psei;
    SignerInfo          *psi = NULL;
    Attribute           *pAuthAttr;
    Attribute           *pUnauthAttr;
    DWORD               cSigners  = psmei->cSigners;
    PCMSG_SIGNER_ENCODE_INFO rgSigners = psmei->rgSigners;

    *pfHasCmsSignerId = FALSE;
    psis->value = NULL;
    psis->count = 0;
    if (0 == cSigners)
        goto SuccessReturn;
    // NB - Each SignerInfo gets a non-empty authenticatedAttributes
    //      if the inner contentType is not data (passed in) or if
    //      there are authenticated attributes passed in. In this case,
    //      we reserve two Attribute slots at the beginning of the array
    //      for the content-type and message-digest Attribute values.
    for (i=cSigners, psei=rgSigners, cAuthAttr=0, cUnauthAttr=0;
            i>0;
            i--,
#ifdef CMS_PKCS7
            psei = (PCMSG_SIGNER_ENCODE_INFO) ((BYTE *) psei + psei->cbSize)) {
#else
            psei++) {
#endif  // CMS_PKCS7
        if (!ICM_IsData( pszInnerContentObjID) ||
                psei->cAuthAttr ||
                (dwFlags & CMSG_AUTHENTICATED_ATTRIBUTES_FLAG))
            cAuthAttr += psei->cAuthAttr + 2;    // reserve 2
        cUnauthAttr += psei->cUnauthAttr;
    }
    psi = (SignerInfo *)ICM_AllocZero(  cSigners    * sizeof( SignerInfo) +
                                        cAuthAttr   * sizeof( Attribute) +
                                        cUnauthAttr * sizeof( Attribute)
                                     );
    if (NULL == psi)
        goto SignerInfoAllocError;
    psis->count = cSigners;
    psis->value = psi;
    pAuthAttr = (Attribute *)(psis->value + cSigners);
    pUnauthAttr = pAuthAttr + cAuthAttr;

    for (i=cSigners, psei=rgSigners, psi=psis->value; i>0; i--,
#ifdef CMS_PKCS7
            psei = (PCMSG_SIGNER_ENCODE_INFO) ((BYTE *) psei + psei->cbSize),
#else
            psei++,
#endif  // CMS_PKCS7
            psi++) {
        if (!ICM_FillAsnSignerInfo(
                psei,
                pcmi,
                dwFlags,
                pszInnerContentObjID,
                psi,
                &pAuthAttr,
                &pUnauthAttr))
            goto FillAsnSignerInfoError;

        if (CMSG_SIGNER_INFO_CMS_VERSION <= psi->version)
            *pfHasCmsSignerId = TRUE;
    }
SuccessReturn:
    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(SignerInfoAllocError)       // error already set
TRACE_ERROR(FillAsnSignerInfoError)     // error already set
}

#ifdef CMS_PKCS7

BOOL
WINAPI
ICM_IsDuplicateSignerEncodeHashAlgorithm(
    IN PCMSG_SIGNER_ENCODE_INFO rgSigners,
    IN PCMSG_SIGNER_ENCODE_INFO pNewSigner,
    OUT OPTIONAL DWORD *pdwPrevIndex
    )
{
    PCRYPT_ALGORITHM_IDENTIFIER pNewHashAlg = &pNewSigner->HashAlgorithm;
    PCMSG_SIGNER_ENCODE_INFO pPrevSigner;
    DWORD dwPrevIndex;

    pPrevSigner = rgSigners;
    dwPrevIndex = 0;
    while (pPrevSigner < pNewSigner) {
        PCRYPT_ALGORITHM_IDENTIFIER pPrevHashAlg = &pPrevSigner->HashAlgorithm;
        if (0 == strcmp(pNewHashAlg->pszObjId, pPrevHashAlg->pszObjId)
                        &&
                pNewHashAlg->Parameters.cbData ==
                    pPrevHashAlg->Parameters.cbData
                        &&
                (0 == pNewHashAlg->Parameters.cbData ||
                    0 == memcmp(pNewHashAlg->Parameters.pbData,
                            pPrevHashAlg->Parameters.pbData,
                            pNewHashAlg->Parameters.cbData))) {
            break;
        }

        assert(STRUCT_CBSIZE(CMSG_SIGNER_ENCODE_INFO, rgUnauthAttr) <=
            pPrevSigner->cbSize);
        assert(pPrevSigner->cbSize == pNewSigner->cbSize);
        pPrevSigner = (PCMSG_SIGNER_ENCODE_INFO) ((BYTE *) pPrevSigner +
            pPrevSigner->cbSize);
        dwPrevIndex++;
    }

    if (pdwPrevIndex)
        *pdwPrevIndex = dwPrevIndex;
    return pPrevSigner < pNewSigner;
}

//+-------------------------------------------------------------------------
//  Set Signer DigestAlgorithmIdentifiers and create the SignerEncode and
//  Hash lists
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_SetAsnSignerDigestInfo(
    IN PCMSG_SIGNED_ENCODE_INFO psmei,
    IN OUT PCRYPT_MSG_INFO pcmi,
    IN OUT DigestAlgorithmIdentifiers *podais
    )
{
    BOOL fRet;
    DigestAlgorithmIdentifier *podai = NULL;
    DWORD cDigests = 0;
    DWORD cSigners = psmei->cSigners;

    if (cSigners) {
        DWORD i;
        PCMSG_SIGNER_ENCODE_INFO psei;
        PSIGNER_ENCODE_DATA_INFO rgSignerEncodeDataInfo;

        podai = (DigestAlgorithmIdentifier *) ICM_AllocZero(
            cSigners * sizeof(DigestAlgorithmIdentifier));
        if (NULL == podai)
            goto OutOfMemory;

        rgSignerEncodeDataInfo = (PSIGNER_ENCODE_DATA_INFO) ICM_AllocZero(
            cSigners * sizeof(SIGNER_ENCODE_DATA_INFO));
        if (NULL == rgSignerEncodeDataInfo)
            goto OutOfMemory;
        pcmi->cSignerEncodeDataInfo = cSigners;
        pcmi->rgSignerEncodeDataInfo = rgSignerEncodeDataInfo;

        if (NULL == (pcmi->pHashList = new CHashList))
            goto OutOfMemory;

        for (i = 0, psei = psmei->rgSigners; i < cSigners; i++,
                psei = (PCMSG_SIGNER_ENCODE_INFO) ((BYTE *) psei + psei->cbSize)) {
            DWORD dwPrevIndex;
            ICM_HASH_INFO HashInfo;     ZEROSTRUCT(HashInfo);
            CHashNode *pHashNode;

            assert(STRUCT_CBSIZE(CMSG_SIGNER_ENCODE_INFO, rgUnauthAttr) <=
                psei->cbSize);
            assert(psei->hCryptProv);
            if (STRUCT_CBSIZE(CMSG_SIGNER_ENCODE_INFO, rgUnauthAttr) >
                    psei->cbSize || 0 == psei->hCryptProv)
                goto InvalidArg;

            if (ICM_IsDuplicateSignerEncodeHashAlgorithm(
                    psmei->rgSigners,
                    psei,
                    &dwPrevIndex
                    )) {
                assert(dwPrevIndex < i);
                pHashNode = rgSignerEncodeDataInfo[dwPrevIndex].pHashNode;
            } else {
                if (!ICM_MsgAsn1ToAlgorithmIdentifier(
                        pcmi,
                        &psei->HashAlgorithm,
                        &podai[cDigests]))
                    goto MsgAsn1ToAlgorithmIdentifierError;
                cDigests++;

                if (!(ICM_GetCAPI(
                        CRYPT_HASH_ALG_OID_GROUP_ID,
                        &psei->HashAlgorithm,
                        &HashInfo.dwAlgoCAPI) ||
                      ICM_GetCAPI(
                        CRYPT_SIGN_ALG_OID_GROUP_ID,
                        &psei->HashAlgorithm,
                        &HashInfo.dwAlgoCAPI)))
                    goto GetCAPIError;
                if (!CryptCreateHash(
                                psei->hCryptProv,
                                HashInfo.dwAlgoCAPI,
                                NULL,               // hKey - optional for MAC
                                0,                  // dwFlags
                                &HashInfo.hHash))
                    goto CreateHashError;
                if (NULL == (pHashNode = new CHashNode)) {
                    DWORD dwErr = GetLastError();
                    CryptDestroyHash(HashInfo.hHash);
                    SetLastError(dwErr);
                    goto OutOfMemory;
                }
                pHashNode->SetData(&HashInfo);
                pcmi->pHashList->InsertTail(pHashNode);
            }

            rgSignerEncodeDataInfo[i].hCryptProv = psei->hCryptProv;
            rgSignerEncodeDataInfo[i].dwKeySpec = psei->dwKeySpec;
            rgSignerEncodeDataInfo[i].pHashNode = pHashNode;
        }
        assert(cDigests);
    }

    podais->count = cDigests;
    podais->value = podai;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    ICM_Free(podai);
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(MsgAsn1ToAlgorithmIdentifierError)
SET_ERROR(InvalidArg, E_INVALIDARG)
SET_ERROR(GetCAPIError, CRYPT_E_UNKNOWN_ALGO)
TRACE_ERROR(CreateHashError)
}

//+-------------------------------------------------------------------------
//  Open a signed message for encoding
//--------------------------------------------------------------------------
HCRYPTMSG
WINAPI
ICM_OpenToEncodeSignedData(
    IN DWORD                        dwEncodingType,
    IN DWORD                        dwFlags,
    IN void const                   *pvMsgEncodeInfo,
    IN OPTIONAL LPSTR               pszInnerContentObjID,
    IN OPTIONAL PCMSG_STREAM_INFO   pStreamInfo)
{
    DWORD                       dwError = ERROR_SUCCESS;
    PCRYPT_MSG_INFO             pcmi = NULL;
    PCMSG_SIGNED_ENCODE_INFO    psmei;
    PCERT_BLOB                  pcert;
    PCRL_BLOB                   pcrl;
    SignedData                  *psd = NULL;
    Certificate                 *pOssCert;
    CertificateRevocationList   *pOssCrl;
    DWORD                       i;
    DWORD                       cbCert;
    PBYTE                       pbCert;
    DWORD                       cbCrl;
    PBYTE                       pbCrl;
    DWORD                       cAttrCertEncoded;
    BOOL                        fHasCmsSignerId;

    psmei = (PCMSG_SIGNED_ENCODE_INFO)pvMsgEncodeInfo;
    assert( psmei->cbSize >= STRUCT_CBSIZE(CMSG_SIGNED_ENCODE_INFO,
        rgCrlEncoded));
    if (psmei->cbSize < STRUCT_CBSIZE(CMSG_SIGNED_ENCODE_INFO, rgCrlEncoded))
        goto InvalidArg;

    for (i=psmei->cCertEncoded, pcert=psmei->rgCertEncoded, cbCert=0;
            i>0;
            i--, pcert++)
        cbCert += pcert->cbData;

    for (i=psmei->cCrlEncoded, pcrl=psmei->rgCrlEncoded, cbCrl=0;
            i>0;
            i--, pcrl++)
        cbCrl += pcrl->cbData;

    if (psmei->cbSize >= STRUCT_CBSIZE(CMSG_SIGNED_ENCODE_INFO,
            rgAttrCertEncoded)) {
        cAttrCertEncoded = psmei->cAttrCertEncoded;

        for (i=cAttrCertEncoded, pcert=psmei->rgAttrCertEncoded;
                i>0;
                i--, pcert++)
            cbCert += pcert->cbData;
    } else
        cAttrCertEncoded = 0;

    psd = (SignedData *)ICM_AllocZero(
                sizeof( SignedData) +
                psmei->cCertEncoded * sizeof( Certificate) +
                cAttrCertEncoded * sizeof( Certificate) +
                psmei->cCrlEncoded * sizeof( CertificateRevocationList) +
                cbCert +
                cbCrl);
    if (NULL == psd)
        goto SignedDataAllocError;

    // digest algorithms filled in as part of ICM_SetAsnSignerDigestInfo

    // contentInfo filled in later, when we see the content

    // certificates
    if (0 != psmei->cCertEncoded || 0 != cAttrCertEncoded) {
        psd->bit_mask |= certificates_present;
        psd->certificates.count = psmei->cCertEncoded;
        psd->certificates.count += cAttrCertEncoded;
#ifdef OSS_CRYPT_ASN1
        psd->certificates.certificates = (Certificate *)(psd + 1);
#else
        psd->certificates.value = (Certificate *)(psd + 1);
#endif  // OSS_CRYPT_ASN1
        pbCert = (PBYTE)psd +
                sizeof( SignedData) +
                psmei->cCertEncoded * sizeof( Certificate) +
                cAttrCertEncoded * sizeof( Certificate) +
                psmei->cCrlEncoded * sizeof( CertificateRevocationList);
        for (i=psmei->cCertEncoded, pcert=psmei->rgCertEncoded,
#ifdef OSS_CRYPT_ASN1
                    pOssCert=psd->certificates.certificates;
#else
                    pOssCert=psd->certificates.value;
#endif  // OSS_CRYPT_ASN1
                i>0;
                i--, pcert++, pOssCert++) {
            pOssCert->length = pcert->cbData;
            memcpy( pbCert, pcert->pbData, pcert->cbData);
            pOssCert->value = pbCert;
            pbCert += pcert->cbData;
        }

        for (i=cAttrCertEncoded, pcert=psmei->rgAttrCertEncoded;
                i>0;
                i--, pcert++, pOssCert++) {
            pOssCert->length = pcert->cbData;
            memcpy( pbCert, pcert->pbData, pcert->cbData);
            if (pcert->cbData)
                // Change tag from SEQUENCE to [1] IMPLICIT
                *pbCert = ICM_TAG_CONSTRUCTED_CONTEXT_1;
            pOssCert->value = pbCert;
            pbCert += pcert->cbData;
        }
    }

    // crls
    if (0 != psmei->cCrlEncoded) {
        psd->bit_mask |= crls_present;
        psd->crls.count = psmei->cCrlEncoded;
        if (0 != psmei->cCertEncoded || 0 != cAttrCertEncoded)
#ifdef OSS_CRYPT_ASN1
            psd->crls.crls  = (CertificateRevocationList *)
                                (psd->certificates.certificates +
#else
            psd->crls.value  = (CertificateRevocationList *)
                                (psd->certificates.value +
#endif  // OSS_CRYPT_ASN1
                                    (psmei->cCertEncoded + cAttrCertEncoded));
        else
#ifdef OSS_CRYPT_ASN1
            psd->crls.crls  = (CertificateRevocationList *) (psd + 1);
#else
            psd->crls.value  = (CertificateRevocationList *) (psd + 1);
#endif  // OSS_CRYPT_ASN1
        pbCrl = (PBYTE)psd +
                sizeof( SignedData) +
                psmei->cCertEncoded * sizeof( Certificate) +
                cAttrCertEncoded * sizeof( Certificate) +
                psmei->cCrlEncoded * sizeof( CertificateRevocationList) +
                cbCert;
#ifdef OSS_CRYPT_ASN1
        for (i=psmei->cCrlEncoded, pcrl=psmei->rgCrlEncoded, pOssCrl=psd->crls.crls;
#else
        for (i=psmei->cCrlEncoded, pcrl=psmei->rgCrlEncoded, pOssCrl=psd->crls.value;
#endif  // OSS_CRYPT_ASN1
                i>0;
                i--, pcrl++, pOssCrl++) {
            pOssCrl->length = pcrl->cbData;
            memcpy( pbCrl, pcrl->pbData, pcrl->cbData);
            pOssCrl->value = pbCrl;
            pbCrl += pcrl->cbData;
        }
    }


    if (NULL == (pcmi = (PCRYPT_MSG_INFO)ICM_AllocZero(
            sizeof( CRYPT_MSG_INFO))))
        goto OutOfMemory;

    // signerInfos
    if (!ICM_SetAsnSignerInfos(psmei, pcmi, dwFlags, pszInnerContentObjID,
            &psd->signerInfos, &fHasCmsSignerId))
        goto SetAsnSignerInfosError;

    // version
    if (0 < cAttrCertEncoded || fHasCmsSignerId) {
        if (ICM_IsData(pszInnerContentObjID))
            dwFlags &= ~CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
        else
            dwFlags |= CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
    } else if (dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG) {
        if (ICM_IsData(pszInnerContentObjID))
            dwFlags &= ~CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
    }

    // If encapsulated other than id-data or has attribute certs or has
    // CMS signers, then, CMS version
    if ((dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG) ||
            0 < cAttrCertEncoded || fHasCmsSignerId)
        psd->version = CMSG_SIGNED_DATA_CMS_VERSION;
    else
        psd->version = CMSG_SIGNED_DATA_PKCS_1_5_VERSION;

    pcmi->dwEncodingType = dwEncodingType;
    pcmi->dwMsgType = CMSG_SIGNED;
    pcmi->dwFlags = dwFlags;
    pcmi->pvMsg = psd;
    pcmi->fEncoding = TRUE;
    pcmi->dwPhase = PHASE_FIRST_ONGOING;
    if (pszInnerContentObjID &&
            (NULL == (pcmi->pszInnerContentObjID = (LPSTR)ICM_DupMem(
                                    pszInnerContentObjID,
                                    ICM_StrLen(pszInnerContentObjID) + 1))))
        goto DupInnerContentObjIDError;
    if (pStreamInfo &&
            (NULL == (pcmi->pStreamInfo = (PCMSG_STREAM_INFO)ICM_DupMem(
                                    pStreamInfo,
                                    sizeof(*pStreamInfo)))))
        goto DupStreamInfoError;

    if (!ICM_SetAsnSignerDigestInfo(
            psmei,
            pcmi,
            &psd->digestAlgorithms
            ))
        goto SetAsnSignerDigestInfoError;

    if (pcmi->pStreamInfo && !ICMS_OpenToEncodeSignedData( pcmi, psmei))
        goto StreamOpenToEncodeSignedDataError;

CommonReturn:
    ICM_SetLastError(dwError);
    return (HCRYPTMSG)pcmi;

ErrorReturn:
    dwError = GetLastError();
    if (psd) {
        if (psd->signerInfos.value) {
            SignerInfo  *psi;

            for (i=psd->signerInfos.count, psi=psd->signerInfos.value;
                    i>0;
                    i--, psi++)
                ICM_FreeAsnSignerInfo(psi);
            ICM_Free(psd->signerInfos.value);
        }
        ICM_Free(psd);
    }
    if (pcmi) {
        if (pcmi->pFreeList)
            delete pcmi->pFreeList;
        if (pcmi->pHashList)
            delete pcmi->pHashList;
        ICM_Free(pcmi->rgSignerEncodeDataInfo);
        ICM_Free(pcmi->pszInnerContentObjID);
        ICM_Free(pcmi->pStreamInfo);
        ICM_Free(pcmi);
        pcmi = NULL;
    }
    goto CommonReturn;
SET_ERROR(InvalidArg,E_INVALIDARG)
TRACE_ERROR(DupInnerContentObjIDError)              // error already set
TRACE_ERROR(DupStreamInfoError)                     // error already set
TRACE_ERROR(SetAsnSignerInfosError)                 // error already set
TRACE_ERROR(SetAsnSignerDigestInfoError)            // error already set
TRACE_ERROR(SignedDataAllocError)                   // error already set
TRACE_ERROR(OutOfMemory)                            // error already set
TRACE_ERROR(StreamOpenToEncodeSignedDataError)      // error already set
}

#else

//+-------------------------------------------------------------------------
//  Open a signed message for encoding
//--------------------------------------------------------------------------
HCRYPTMSG
WINAPI
ICM_OpenToEncodeSignedData(
    IN DWORD                        dwEncodingType,
    IN DWORD                        dwFlags,
    IN void const                   *pvMsgEncodeInfo,
    IN OPTIONAL LPSTR               pszInnerContentObjID,
    IN OPTIONAL PCMSG_STREAM_INFO   pStreamInfo)
{
    DWORD                       dwError = ERROR_SUCCESS;
    PCRYPT_MSG_INFO             pcmi = NULL;
    PCMSG_SIGNED_ENCODE_INFO    psmei;
    PCERT_BLOB                  pcert;
    PCRL_BLOB                   pcrl;
    SignedData                  *psd = NULL;
    Certificate                 *pOssCert;
    CertificateRevocationList   *pOssCrl;
    DWORD                       i;
    DWORD                       cDigestAlgorithms;
    HCRYPTPROV                  hCryptProv;
    DWORD                       dwKeySpec;
    CRYPT_ALGORITHM_IDENTIFIER  aiDigest;
    ICM_HASH_INFO               HashInfo;       ZEROSTRUCT(HashInfo);
    CHashNode                   *pHashNode;
    DWORD                       cbCert;
    PBYTE                       pbCert;
    DWORD                       cbCrl;
    PBYTE                       pbCrl;
    BOOL                        fHasCmsSignerId;

#ifdef CMS_PKCS7
    DWORD                       cAttrCertEncoded;
#endif  // CMS_PKCS7

    psmei = (PCMSG_SIGNED_ENCODE_INFO)pvMsgEncodeInfo;
    assert( 2 > psmei->cSigners);
    if (!( 2 > psmei->cSigners))
        goto TooManySignersError;
#ifdef CMS_PKCS7
    assert( psmei->cbSize >= offsetof(CMSG_SIGNED_ENCODE_INFO,
        cAttrCertEncoded));
    if (psmei->cbSize < offsetof(CMSG_SIGNED_ENCODE_INFO, cAttrCertEncoded))
#else
    assert( psmei->cbSize >= sizeof(CMSG_SIGNED_ENCODE_INFO));
    if (psmei->cbSize < sizeof(CMSG_SIGNED_ENCODE_INFO))
#endif
        goto InvalidArg;

    for (i=psmei->cCertEncoded, pcert=psmei->rgCertEncoded, cbCert=0;
            i>0;
            i--, pcert++)
        cbCert += pcert->cbData;

    for (i=psmei->cCrlEncoded, pcrl=psmei->rgCrlEncoded, cbCrl=0;
            i>0;
            i--, pcrl++)
        cbCrl += pcrl->cbData;

#ifdef CMS_PKCS7
    if (psmei->cbSize > offsetof(CMSG_SIGNED_ENCODE_INFO, rgAttrCertEncoded)) {
        cAttrCertEncoded = psmei->cAttrCertEncoded;

        for (i=cAttrCertEncoded, pcert=psmei->rgAttrCertEncoded;
                i>0;
                i--, pcert++)
            cbCert += pcert->cbData;
    } else
        cAttrCertEncoded = 0;
#endif  // CMS_PKCS7

    psd = (SignedData *)ICM_AllocZero(
                sizeof( SignedData) +
                psmei->cCertEncoded * sizeof( Certificate) +
#ifdef CMS_PKCS7
                cAttrCertEncoded * sizeof( Certificate) +
#endif  // CMS_PKCS7
                psmei->cCrlEncoded * sizeof( CertificateRevocationList) +
                cbCert +
                cbCrl);
    if (NULL == psd)
        goto SignedDataAllocError;
    psd->bit_mask = 0;
    psd->signerInfos.value = NULL;
    psd->contentInfo.content.value = NULL;

    // version
#ifdef CMS_PKCS7
    if (0 < cAttrCertEncoded) {
        if (ICM_IsData(pszInnerContentObjID))
            dwFlags &= ~CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
        else
            dwFlags |= CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
    } else if (dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG) {
        if (ICM_IsData(pszInnerContentObjID))
            dwFlags &= ~CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
    }

    // If encapsulated other than id-data or has attribute certs, then,
    // version = 3
    if ((dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG) ||
            0 < cAttrCertEncoded)
        psd->version = CMSG_SIGNED_DATA_CMS_VERSION;
    else
        psd->version = CMSG_SIGNED_DATA_PKCS_1_5_VERSION;
#else
    psd->version = 1;
#endif  // CMS_PKCS7

    // digest algorithms
    if (!ICM_SetAsnDigestAlgorithmIdentifiers(
                &psd->digestAlgorithms,
                &aiDigest,
                psmei->cSigners,
                psmei->rgSigners,
                &hCryptProv,
                &dwKeySpec))
        goto SetAsnDigestAlgorithmIdentifiersError;

    // contentInfo filled in later, when we see the content

    // certificates
    if (0 != psmei->cCertEncoded
#ifdef CMS_PKCS7
            || 0 != cAttrCertEncoded
#endif  // CMS_PKCS7
            ) {
        psd->bit_mask |= certificates_present;
        psd->certificates.count = psmei->cCertEncoded;
#ifdef CMS_PKCS7
        psd->certificates.count += cAttrCertEncoded;
#endif  // CMS_PKCS7
#ifdef OSS_CRYPT_ASN1
        psd->certificates.certificates = (Certificate *)(psd + 1);
#else
        psd->certificates.value = (Certificate *)(psd + 1);
#endif  // OSS_CRYPT_ASN1
        pbCert = (PBYTE)psd +
                sizeof( SignedData) +
                psmei->cCertEncoded * sizeof( Certificate) +
#ifdef CMS_PKCS7
                cAttrCertEncoded * sizeof( Certificate) +
#endif  // CMS_PKCS7
                psmei->cCrlEncoded * sizeof( CertificateRevocationList);
        for (i=psmei->cCertEncoded, pcert=psmei->rgCertEncoded,
#ifdef OSS_CRYPT_ASN1
                    pOssCert=psd->certificates.certificates;
#else
                    pOssCert=psd->certificates.value;
#endif  // OSS_CRYPT_ASN1
                i>0;
                i--, pcert++, pOssCert++) {
            pOssCert->length = pcert->cbData;
            memcpy( pbCert, pcert->pbData, pcert->cbData);
            pOssCert->value = pbCert;
            pbCert += pcert->cbData;
        }

#ifdef CMS_PKCS7
        for (i=cAttrCertEncoded, pcert=psmei->rgAttrCertEncoded;
                i>0;
                i--, pcert++, pOssCert++) {
            pOssCert->length = pcert->cbData;
            memcpy( pbCert, pcert->pbData, pcert->cbData);
            if (pcert->cbData)
                // Change tag from SEQUENCE to [1] IMPLICIT
                *pbCert = ICM_TAG_CONSTRUCTED_CONTEXT_1;
            pOssCert->value = pbCert;
            pbCert += pcert->cbData;
        }
#endif  // CMS_PKCS7
    }

    // crls
    if (0 != psmei->cCrlEncoded) {
        psd->bit_mask |= crls_present;
        psd->crls.count = psmei->cCrlEncoded;
        if (0 != psmei->cCertEncoded
#ifdef CMS_PKCS7
                || 0 != cAttrCertEncoded
#endif  // CMS_PKCS7
                )
#ifdef OSS_CRYPT_ASN1
            psd->crls.crls  = (CertificateRevocationList *)
                                (psd->certificates.certificates +
#else
            psd->crls.value  = (CertificateRevocationList *)
                                (psd->certificates.value +
#endif  // OSS_CRYPT_ASN1
                                    (psmei->cCertEncoded
#ifdef CMS_PKCS7
                                        + cAttrCertEncoded
#endif  // CMS_PKCS7
                                    ));
        else
#ifdef OSS_CRYPT_ASN1
            psd->crls.crls  = (CertificateRevocationList *) (psd + 1);
#else
            psd->crls.value  = (CertificateRevocationList *) (psd + 1);
#endif  // OSS_CRYPT_ASN1
        pbCrl = (PBYTE)psd +
                sizeof( SignedData) +
                psmei->cCertEncoded * sizeof( Certificate) +
#ifdef CMS_PKCS7
                cAttrCertEncoded * sizeof( Certificate) +
#endif  // CMS_PKCS7
                psmei->cCrlEncoded * sizeof( CertificateRevocationList) +
                cbCert;
#ifdef OSS_CRYPT_ASN1
        for (i=psmei->cCrlEncoded, pcrl=psmei->rgCrlEncoded, pOssCrl=psd->crls.crls;
#else
        for (i=psmei->cCrlEncoded, pcrl=psmei->rgCrlEncoded, pOssCrl=psd->crls.value;
#endif  // OSS_CRYPT_ASN1
                i>0;
                i--, pcrl++, pOssCrl++) {
            pOssCrl->length = pcrl->cbData;
            memcpy( pbCrl, pcrl->pbData, pcrl->cbData);
            pOssCrl->value = pbCrl;
            pbCrl += pcrl->cbData;
        }
    }

    // signerInfos
    // psd->signerInfos.count = psmei->cSigners;
    // psd->signerInfos.value = (SignerInfo *)
    //                         (psd->crls.crls + psmei->cCrlEncoded);
    if (!ICM_SetAsnSignerInfos( psmei, pcmi, dwFlags, pszInnerContentObjID,
            &psd->signerInfos, &fHasCmsSignerId))
        goto SetAsnSignerInfosError;

    cDigestAlgorithms = psmei->cSigners;
    if (NULL == (pcmi = (PCRYPT_MSG_INFO)ICM_AllocZero( sizeof( CRYPT_MSG_INFO))))
        goto OutOfMemory;

    pcmi->hCryptProv = hCryptProv;
    if (0 == hCryptProv)
        pcmi->fDefaultCryptProv = TRUE;
    pcmi->dwKeySpec = dwKeySpec;
    pcmi->dwEncodingType = dwEncodingType;
    pcmi->dwMsgType = CMSG_SIGNED;
    pcmi->dwFlags = dwFlags;
    pcmi->pvMsg = psd;
    pcmi->fEncoding = TRUE;
    pcmi->dwPhase = PHASE_FIRST_ONGOING;
    if (pszInnerContentObjID &&
            (NULL == (pcmi->pszInnerContentObjID = (LPSTR)ICM_DupMem(
                                    pszInnerContentObjID,
                                    ICM_StrLen(pszInnerContentObjID) + 1))))
        goto DupInnerContentObjIDError;
    if (pStreamInfo &&
            (NULL == (pcmi->pStreamInfo = (PCMSG_STREAM_INFO)ICM_DupMem(
                                    pStreamInfo,
                                    sizeof(*pStreamInfo)))))
        goto DupStreamInfoError;

    if (psmei->cSigners) {
        if (!(ICM_GetCAPI(
                CRYPT_HASH_ALG_OID_GROUP_ID,
                &aiDigest,
                &HashInfo.dwAlgoCAPI) ||
              ICM_GetCAPI(
                CRYPT_SIGN_ALG_OID_GROUP_ID,
                &aiDigest,
                &HashInfo.dwAlgoCAPI)))
            goto GetCAPIError;
        HashInfo.hCryptProv = hCryptProv;
        if (!CryptCreateHash(
                        HashInfo.hCryptProv,
                        HashInfo.dwAlgoCAPI,
                        NULL,               // hKey - optional for MAC
                        0,                  // dwFlags
                        &HashInfo.hHash))
            goto CreateHashError;
        if (NULL == (pcmi->pHashList = new CHashList))
            goto NewHashListError;
        if (NULL == (pHashNode = new CHashNode))
            goto NewHashNodeError;
        pHashNode->SetData( &HashInfo);
        pcmi->pHashList->InsertTail( pHashNode);
    }

    if (pcmi->pStreamInfo && !ICMS_OpenToEncodeSignedData( pcmi, psmei))
        goto StreamOpenToEncodeSignedDataError;

CommonReturn:
    ICM_SetLastError(dwError);
    return (HCRYPTMSG)pcmi;

ErrorReturn:
    dwError = GetLastError();
    ICM_Free( psd);
    ICM_Free( pcmi);
    pcmi = NULL;
    goto CommonReturn;
SET_ERROR(TooManySignersError,E_INVALIDARG)
SET_ERROR(NewHashListError,E_OUTOFMEMORY)
SET_ERROR(NewHashNodeError,E_OUTOFMEMORY)
SET_ERROR(InvalidArg,E_INVALIDARG)
SET_ERROR(GetCAPIError,CRYPT_E_UNKNOWN_ALGO)
TRACE_ERROR(DupInnerContentObjIDError)              // error already set
TRACE_ERROR(DupStreamInfoError)                     // error already set
TRACE_ERROR(SetAsnSignerInfosError)                 // error already set
TRACE_ERROR(SetAsnDigestAlgorithmIdentifiersError)  // error already set
TRACE_ERROR(SignedDataAllocError)                   // error already set
TRACE_ERROR(OutOfMemory)                            // error already set
TRACE_ERROR(CreateHashError)                        // error already set
TRACE_ERROR(StreamOpenToEncodeSignedDataError)      // error already set
}

#endif  // CMS_PKCS7


//+-------------------------------------------------------------------------
//  Open a data message for encoding
//--------------------------------------------------------------------------
HCRYPTMSG
WINAPI
ICM_OpenToEncodeData(
    IN DWORD                        dwEncodingType,
    IN DWORD                        dwFlags,
    IN void const                   *pvMsgEncodeInfo,
    IN OPTIONAL PCMSG_STREAM_INFO   pStreamInfo)
{
    DWORD                       dwError = ERROR_SUCCESS;
    PCRYPT_MSG_INFO             pcmi = NULL;
    OctetStringType             *poos = NULL;

    if (pvMsgEncodeInfo)
        goto EncodeInfoPresentError;

    if (NULL == (poos = (OctetStringType *)ICM_AllocZero( sizeof( OctetStringType))))
        goto AllocOctetStringTypeError;

    if (NULL == (pcmi = (PCRYPT_MSG_INFO)ICM_AllocZero( sizeof( CRYPT_MSG_INFO))))
        goto AllocMsgInfoError;

    pcmi->dwEncodingType    = dwEncodingType;
    pcmi->dwMsgType         = CMSG_DATA;
//  pcmi->hCryptProv        = 0;
    pcmi->fDefaultCryptProv = TRUE;
    pcmi->dwFlags           = dwFlags;
    pcmi->pvMsg             = poos;
    pcmi->fEncoding         = TRUE;
    pcmi->dwPhase           = PHASE_FIRST_ONGOING;
    pcmi->pStreamInfo       = (PCMSG_STREAM_INFO)ICM_DupMem(
                                    pStreamInfo,
                                    sizeof(*pStreamInfo));

    if (pcmi->pStreamInfo && !ICMS_OpenToEncodeData( pcmi))
        goto StreamOpenToEncodeDataError;

CommonReturn:
    ICM_SetLastError(dwError);
    return (HCRYPTMSG)pcmi;

ErrorReturn:
    dwError = GetLastError();
    ICM_Free( poos);
    if (pcmi) {
        ICM_Free(pcmi->pStreamInfo);
        ICM_Free( pcmi);
    }
    pcmi = NULL;
    goto CommonReturn;
SET_ERROR(EncodeInfoPresentError,E_INVALIDARG)
TRACE_ERROR(AllocMsgInfoError)                  // error already set
TRACE_ERROR(AllocOctetStringTypeError)          // error already set
TRACE_ERROR(StreamOpenToEncodeDataError)        // error already set
}


//+-------------------------------------------------------------------------
//  Open a digested message for encoding
//--------------------------------------------------------------------------
HCRYPTMSG
WINAPI
ICM_OpenToEncodeDigestedData(
    IN DWORD dwEncodingType,
    IN DWORD dwFlags,
    IN void const *pvMsgEncodeInfo,
    IN OPTIONAL LPSTR pszInnerContentObjID,
    IN OPTIONAL PCMSG_STREAM_INFO pStreamInfo)
{
    DWORD                       dwError = ERROR_SUCCESS;
    PCRYPT_MSG_INFO             pcmi = NULL;
    PCMSG_HASHED_ENCODE_INFO     pdmei;
    DigestedData                *pdd = NULL;
    ICM_HASH_INFO               HashInfo;       ZEROSTRUCT(HashInfo);
    CHashNode                   *pHashNode;

    pdmei = (PCMSG_HASHED_ENCODE_INFO)pvMsgEncodeInfo;
    assert( pdmei->cbSize >= sizeof(CMSG_HASHED_ENCODE_INFO));
    assert( pdmei->pvHashAuxInfo == NULL);
    if (pdmei->cbSize < sizeof(CMSG_HASHED_ENCODE_INFO) ||
            pdmei->pvHashAuxInfo != NULL)
        goto InvalidArg;

    pcmi = (PCRYPT_MSG_INFO)ICM_AllocZero( sizeof( CRYPT_MSG_INFO));
    if (NULL == pcmi)
        goto OutOfMemory;

    pdd = (DigestedData *)ICM_AllocZero( sizeof( DigestedData));
    if (NULL == pdd)
        goto DigestedDataAllocError;

    // version
#ifdef CMS_PKCS7
    if (dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG) {
        if (ICM_IsData(pszInnerContentObjID))
            dwFlags &= ~CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
    }

    // If encapsulated other than id-data, then, version = 2
    if (dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG)
        pdd->version = CMSG_HASHED_DATA_V2;
    else
        pdd->version = CMSG_HASHED_DATA_V0;
#else
    pdd->version = 0;
#endif  // CMS_PKCS7

    // digest algorithm
    if (!ICM_MsgAsn1ToAlgorithmIdentifier(
            pcmi,
            &pdmei->HashAlgorithm,
            &pdd->digestAlgorithm))
        goto MsgAsn1ToAlgorithmIdentifierError;


    // contentInfo filled in later, when we see the content

    if (pdmei->hCryptProv)
        pcmi->hCryptProv        = pdmei->hCryptProv;
    else {
        pcmi->fDefaultCryptProv = TRUE;
        pcmi->hCryptProv = I_CryptGetDefaultCryptProv(0);
        if (0 == pcmi->hCryptProv)
            goto GetDefaultCryptProvError;
    }
    pcmi->dwEncodingType    = dwEncodingType;
    pcmi->dwMsgType         = CMSG_HASHED;
    pcmi->dwFlags           = dwFlags;
    pcmi->pvMsg             = pdd;
    pcmi->fEncoding         = TRUE;
    pcmi->dwPhase           = PHASE_FIRST_ONGOING;
    pcmi->pszInnerContentObjID = (LPSTR)ICM_DupMem(
                                    pszInnerContentObjID,
                                    ICM_StrLen(pszInnerContentObjID) + 1);
    pcmi->pStreamInfo = (PCMSG_STREAM_INFO)ICM_DupMem(
                                    pStreamInfo,
                                    sizeof(*pStreamInfo));

    if (!ICM_GetCAPI(
            CRYPT_HASH_ALG_OID_GROUP_ID,
            &pdmei->HashAlgorithm,
            &HashInfo.dwAlgoCAPI))
        goto GetCAPIError;
#ifndef CMS_PKCS7
    HashInfo.hCryptProv = pcmi->hCryptProv;
#endif  // CMS_PKCS7
    if (!CryptCreateHash(
                    pcmi->hCryptProv,
                    HashInfo.dwAlgoCAPI,
                    NULL,               // hKey - optional for MAC
                    0,                  // dwFlags
                    &HashInfo.hHash))
        goto CreateHashError;

    if (NULL == (pcmi->pHashList = new CHashList) ||
            NULL == (pHashNode = new CHashNode)) {
        DWORD dwErr = GetLastError();
        CryptDestroyHash(HashInfo.hHash);
        SetLastError(dwErr);
        goto NewHashListOrNodeError;
    }
    pHashNode->SetData( &HashInfo);
    pcmi->pHashList->InsertTail( pHashNode);

CommonReturn:
    ICM_SetLastError(dwError);
    return (HCRYPTMSG)pcmi;

ErrorReturn:
    dwError = GetLastError();
    ICM_Free( pdd);
    if (pcmi) {
#ifdef CMS_PKCS7
        if (pcmi->pFreeList)
            delete pcmi->pFreeList;
#endif  // CMS_PKCS7
        if (pcmi->pHashList)
            delete pcmi->pHashList;
        ICM_Free(pcmi->pszInnerContentObjID);
        ICM_Free(pcmi->pStreamInfo);
        ICM_Free( pcmi);
        pcmi = NULL;
    }
    goto CommonReturn;
SET_ERROR(InvalidArg,E_INVALIDARG)
TRACE_ERROR(GetDefaultCryptProvError)
SET_ERROR(GetCAPIError,CRYPT_E_UNKNOWN_ALGO)
SET_ERROR(NewHashListOrNodeError,E_OUTOFMEMORY)
TRACE_ERROR(MsgAsn1ToAlgorithmIdentifierError)       // error already set
TRACE_ERROR(DigestedDataAllocError)                     // error already set
TRACE_ERROR(CreateHashError)                            // error already set
TRACE_ERROR(OutOfMemory)                                // error already set
}

#ifdef CMS_PKCS7

//+-------------------------------------------------------------------------
//  Export the hContentEncryptKey from the ContentEncrypt
//  provider and import into the specified provider
//--------------------------------------------------------------------------
HCRYPTKEY
WINAPI
ICM_ExportContentEncryptKeyAndImport(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN HCRYPTPROV hImportProv
    )
{
    DWORD dwError = ERROR_SUCCESS;

    HCRYPTPROV hExportProv = pContentEncryptInfo->hCryptProv;
    HCRYPTHASH hHash = 0;
    HCRYPTKEY hDeriveKey = 0;
    HCRYPTKEY hImportContentEncryptKey = 0;
#define BASE_DATA_LENGTH    8
    BYTE rgbBaseData[BASE_DATA_LENGTH];
    PBYTE pbContentKey = NULL;
    DWORD cbContentKey = 0;

    DWORD dwImportFlags;
    DWORD dwAlgIdEncrypt;
    DWORD dwBitLen;
    BYTE rgbIV[IV_MAX_LENGTH];
    DWORD cbIV;
    const DWORD dw40BitLen = 40;

    // Generate derive key to use to encrypt and export the content encrypt key
    if (!CryptGenRandom(hExportProv, BASE_DATA_LENGTH, rgbBaseData))
        goto GenRandomError;
    if (!CryptCreateHash(hExportProv, CALG_SHA1, 0, 0, &hHash))
        goto ExportCreateHashError;
    if (!CryptHashData(hHash, rgbBaseData, BASE_DATA_LENGTH, 0))
        goto ExportHashDataError;
    if (!CryptDeriveKey(
            hExportProv,
            CALG_RC2,
            hHash,
            40 << 16,               // dwFlags, dwBitLen in upper WORD
            &hDeriveKey))
        goto ExportDeriveKeyError;

    CryptSetKeyParam(
        hDeriveKey,
        KP_EFFECTIVE_KEYLEN,
        (PBYTE) &dw40BitLen,
        0);                 // dwFlags

    // Export the content encrypt key
    if (!CryptExportKey(
            pContentEncryptInfo->hContentEncryptKey,
            hDeriveKey,
            SYMMETRICWRAPKEYBLOB,
            0,                                          // dwFlags
            NULL,
            &cbContentKey))
        goto ExportKeyError;
    if (NULL == (pbContentKey = (PBYTE) ICM_Alloc(cbContentKey)))
        goto AllocError;
    if (!CryptExportKey(
            pContentEncryptInfo->hContentEncryptKey,
            hDeriveKey,
            SYMMETRICWRAPKEYBLOB,
            0,                                          // dwFlags
            pbContentKey,
            &cbContentKey))
        goto ExportKeyError;

    // Generate derive key to use to decrypt and import the content encrypt key
    CryptDestroyKey(hDeriveKey);
    hDeriveKey = 0;
    CryptDestroyHash(hHash);
    hHash = 0;

    if (!CryptCreateHash(hImportProv, CALG_SHA1, 0, 0, &hHash))
        goto ImportCreateHashError;
    if (!CryptHashData(hHash, rgbBaseData, BASE_DATA_LENGTH, 0))
        goto ImportHashDataError;
    if (!CryptDeriveKey(
            hImportProv,
            CALG_RC2,
            hHash,
            40 << 16,               // dwFlags, dwBitLen in upper WORD
            &hDeriveKey))
        goto ImportDeriveKeyError;

    CryptSetKeyParam(
        hDeriveKey,
        KP_EFFECTIVE_KEYLEN,
        (PBYTE) &dw40BitLen,
        0);                 // dwFlags

    // Decrypt and import the content encrypt key
    dwImportFlags = CRYPT_EXPORTABLE;
    if (!ICM_IsSP3CompatibleEncrypt(pContentEncryptInfo))
        dwImportFlags |= CRYPT_NO_SALT;
    if (!CryptImportKey(
            hImportProv,
            pbContentKey,
            cbContentKey,
            hDeriveKey,
            dwImportFlags,
            &hImportContentEncryptKey))
        goto ImportKeyError;

    // Need to re-set effective key length and IV

    if (!ICM_GetEncryptParameters(
            &pContentEncryptInfo->ContentEncryptionAlgorithm,
            &dwAlgIdEncrypt,
            &dwBitLen,
            rgbIV,
            &cbIV))
        goto GetEncryptParametersError;

    if (CALG_RC2 == dwAlgIdEncrypt && 0 != dwBitLen)
        // Silently ignore any errors. Not supported in earlier versions
        CryptSetKeyParam(
            hImportContentEncryptKey,
            KP_EFFECTIVE_KEYLEN,
            (PBYTE) &dwBitLen,
            0);                 // dwFlags

    if (0 != cbIV) {
        if (CALG_RC4 == dwAlgIdEncrypt) {
            // For RC4, set the SALT, not the IV

            CRYPT_DATA_BLOB SaltBlob;
            SaltBlob.pbData = rgbIV;
            SaltBlob.cbData = cbIV;

            if (!CryptSetKeyParam(
                    hImportContentEncryptKey,
                    KP_SALT_EX,
                    (PBYTE) &SaltBlob,
                    0))                 // dwFlags
                goto SetSaltExError;
        } else {
            if (!CryptSetKeyParam(
                    hImportContentEncryptKey,
                    KP_IV,
                    rgbIV,
                    0))                 // dwFlags
                goto SetIVError;
        }
    }

CommonReturn:
    if (hDeriveKey)
        CryptDestroyKey(hDeriveKey);
    if (hHash)
        CryptDestroyHash(hHash);
    ICM_Free(pbContentKey);
    ICM_SetLastError(dwError);
    return hImportContentEncryptKey;
ErrorReturn:
    dwError = GetLastError();
    if (hImportContentEncryptKey) {
        CryptDestroyKey(hImportContentEncryptKey);
        hImportContentEncryptKey = 0;
    }
    goto CommonReturn;

TRACE_ERROR(GenRandomError)
TRACE_ERROR(ExportCreateHashError)
TRACE_ERROR(ExportHashDataError)
TRACE_ERROR(ExportDeriveKeyError)
TRACE_ERROR(ExportKeyError)
TRACE_ERROR(AllocError)
TRACE_ERROR(ImportCreateHashError)
TRACE_ERROR(ImportHashDataError)
TRACE_ERROR(ImportDeriveKeyError)
TRACE_ERROR(ImportKeyError)
TRACE_ERROR(GetEncryptParametersError)
TRACE_ERROR(SetSaltExError)
TRACE_ERROR(SetIVError)
}


//+-------------------------------------------------------------------------
//  Export the encrypted content encrypt key using the KeyTrans or KeyAgree
//  key.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ExportEncryptedKey(
    IN HCRYPTKEY hContentEncryptKey,
    IN HCRYPTKEY hPubKey,
    IN DWORD dwBlobType,
    IN BOOL fSP3CompatibleEncrypt,
    OUT PCRYPT_DATA_BLOB pEncryptedKey
    )
{
    BOOL fRet;
    PBYTE pbCspEncryptedKey = NULL;
    DWORD cbCspEncryptedKey;

    if (!CryptExportKey(
            hContentEncryptKey,
            hPubKey,
            dwBlobType,
            0,                  // dwFlags
            NULL,
            &cbCspEncryptedKey))
        goto ExportEncryptedKeyError;
    if (NULL == (pbCspEncryptedKey = (PBYTE) ICM_AllocA(cbCspEncryptedKey)))
        goto AllocError;
    if (!CryptExportKey(
            hContentEncryptKey,
            hPubKey,
            dwBlobType,
            0,                  // dwFlags
            pbCspEncryptedKey,
            &cbCspEncryptedKey))
        goto ExportEncryptedKeyError;
    assert(cbCspEncryptedKey >
        (sizeof(PUBLICKEYSTRUC) + sizeof(SIMPLEBLOBHEADER)));
    cbCspEncryptedKey -= sizeof(PUBLICKEYSTRUC) + sizeof(SIMPLEBLOBHEADER);

    if (NULL == (pEncryptedKey->pbData = (PBYTE) ICM_Alloc(cbCspEncryptedKey)))
        goto AllocError;
    pEncryptedKey->cbData = cbCspEncryptedKey;


    if (SYMMETRICWRAPKEYBLOB == dwBlobType || fSP3CompatibleEncrypt)
        // Don't byte reverse
        memcpy(pEncryptedKey->pbData,
            pbCspEncryptedKey +
                (sizeof(PUBLICKEYSTRUC) + sizeof(SIMPLEBLOBHEADER)),
            cbCspEncryptedKey);
    else
        ICM_ReverseCopy(pEncryptedKey->pbData,
            pbCspEncryptedKey +
                (sizeof(PUBLICKEYSTRUC) + sizeof(SIMPLEBLOBHEADER)),
            cbCspEncryptedKey);

    fRet = TRUE;

CommonReturn:
    ICM_FreeA(pbCspEncryptedKey);
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(AllocError)
TRACE_ERROR(ExportEncryptedKeyError)
}

BOOL
WINAPI
ICM_IsSameRecipientPublicKeyAlgorithm(
    IN PCRYPT_ALGORITHM_IDENTIFIER paiPubKey1,
    IN PCRYPT_ALGORITHM_IDENTIFIER paiPubKey2
    )
{
    DWORD dwAlgIdPubKey1;
    DWORD dwAlgIdPubKey2;

    if (0 == strcmp(paiPubKey1->pszObjId, paiPubKey2->pszObjId))
        return TRUE;

    ICM_GetCAPI(
        CRYPT_PUBKEY_ALG_OID_GROUP_ID,
        paiPubKey1,
        &dwAlgIdPubKey1);
    ICM_GetCAPI(
        CRYPT_PUBKEY_ALG_OID_GROUP_ID,
        paiPubKey2,
        &dwAlgIdPubKey2);

    if (dwAlgIdPubKey1 == dwAlgIdPubKey2)
        return TRUE;

    // If we don't know about either public key, default to being the same.
    if (0 == dwAlgIdPubKey1 || 0 == dwAlgIdPubKey2)
        return TRUE;
    
    return FALSE;
}

//+-------------------------------------------------------------------------
//  Default export of the encryption key for key transport recipient
//--------------------------------------------------------------------------
BOOL
WINAPI
#ifdef DEBUG_CRYPT_ASN1
ICMTest_DefaultExportKeyTrans(
#else
ICM_DefaultExportKeyTrans(
#endif
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO pKeyTransEncodeInfo,
    IN OUT PCMSG_KEY_TRANS_ENCRYPT_INFO pKeyTransEncryptInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved
    )
{
    BOOL fRet;
    DWORD dwError = ERROR_SUCCESS;

    HCRYPTPROV hKeyTransProv = 0;
    HCRYPTKEY hContentEncryptKey = 0;
    CERT_PUBLIC_KEY_INFO PublicKeyInfo;
    HCRYPTKEY hPubKey = 0;

    hKeyTransProv = pKeyTransEncodeInfo->hCryptProv;

    if (0 == hKeyTransProv) {
        if (0 == pKeyTransEncryptInfo->dwRecipientIndex)
            hKeyTransProv = pContentEncryptInfo->hCryptProv;
        else {
            // Check if the type of and public key algorithm for this
            // recipient is the same as the first recipient's.

            PCMSG_RECIPIENT_ENCODE_INFO prei;

            prei = &pContentEncryptInfo->rgCmsRecipients[0];
            if (CMSG_KEY_TRANS_RECIPIENT == prei->dwRecipientChoice &&
                    ICM_IsSameRecipientPublicKeyAlgorithm(
                        &prei->pKeyTrans->KeyEncryptionAlgorithm,
                        &pKeyTransEncryptInfo->KeyEncryptionAlgorithm))
                hKeyTransProv = pContentEncryptInfo->hCryptProv;
            else {
                // Get default provider associated with the encryption
                // and public key algorithms

                DWORD dwAlgIdPubKey;
                DWORD dwAlgIdEncrypt;
                BYTE rgbIV[IV_MAX_LENGTH];
                DWORD cbIV;
                DWORD dwBitLen;

                if (!ICM_GetEncryptParameters(
                        &pContentEncryptInfo->ContentEncryptionAlgorithm,
                        &dwAlgIdEncrypt,
                        &dwBitLen,
                        rgbIV,
                        &cbIV))
                    goto GetEncryptParametersError;

                ICM_GetCAPI(
                    CRYPT_PUBKEY_ALG_OID_GROUP_ID,
                    &pKeyTransEncryptInfo->KeyEncryptionAlgorithm,
                    &dwAlgIdPubKey);

                hKeyTransProv = I_CryptGetDefaultCryptProvForEncrypt(
                    dwAlgIdPubKey, dwAlgIdEncrypt, dwBitLen);
                if (0 == hKeyTransProv)
                    goto GetDefaultCryptProvError;
            }
        }
    }

    if (hKeyTransProv != pContentEncryptInfo->hCryptProv) {
        // Need to export the hContentEncryptKey from the ContentEncrypt
        // provider and import into the KeyTrans provider
        hContentEncryptKey = ICM_ExportContentEncryptKeyAndImport(
            pContentEncryptInfo,
            hKeyTransProv);
        if (0 == hContentEncryptKey)
            goto ImportContentKeyError;
    } else
        hContentEncryptKey = pContentEncryptInfo->hContentEncryptKey;

    PublicKeyInfo.Algorithm = pKeyTransEncryptInfo->KeyEncryptionAlgorithm;
    PublicKeyInfo.PublicKey = pKeyTransEncodeInfo->RecipientPublicKey;

    if (!CryptImportPublicKeyInfo(
            hKeyTransProv,
            X509_ASN_ENCODING,
            &PublicKeyInfo,
            &hPubKey))
        goto ImportPubKeyError;

    if (!ICM_ExportEncryptedKey(
            hContentEncryptKey,
            hPubKey,
            SIMPLEBLOB,
            ICM_IsSP3CompatibleEncrypt(pContentEncryptInfo),
            &pKeyTransEncryptInfo->EncryptedKey))
        goto ExportEncryptedKeyError;

    fRet = TRUE;

CommonReturn:
    if (hKeyTransProv != pContentEncryptInfo->hCryptProv &&
            hContentEncryptKey)
            CryptDestroyKey(hContentEncryptKey);

    if (hPubKey)
        CryptDestroyKey(hPubKey);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetEncryptParametersError)
TRACE_ERROR(GetDefaultCryptProvError)
TRACE_ERROR(ImportContentKeyError)
TRACE_ERROR(ImportPubKeyError)
TRACE_ERROR(ExportEncryptedKeyError)
}

BOOL
WINAPI
ICM_ExportKeyTrans(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO pKeyTransEncodeInfo,
    IN OUT PCMSG_KEY_TRANS_ENCRYPT_INFO pKeyTransEncryptInfo
    )
{
    BOOL fRet;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr = NULL;

    LPCSTR pszKeyEncryptOID =
        pKeyTransEncryptInfo->KeyEncryptionAlgorithm.pszObjId;

    if (CryptGetOIDFunctionAddress(
            hExportKeyTransFuncSet,
            X509_ASN_ENCODING,
            pszKeyEncryptOID,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr)) {
        fRet = ((PFN_CMSG_EXPORT_KEY_TRANS) pvFuncAddr)(
            pContentEncryptInfo,
            pKeyTransEncodeInfo,
            pKeyTransEncryptInfo,
            0,                      // dwFlags
            NULL                    // pvReserved
            );
    } else if ((NULL == pKeyTransEncodeInfo->hCryptProv ||
            pKeyTransEncodeInfo->hCryptProv ==
                pContentEncryptInfo->hCryptProv)
                        &&
            CryptGetOIDFunctionAddress(
                hOldStyleExportEncryptKeyFuncSet,
                X509_ASN_ENCODING,
                pszKeyEncryptOID,
                0,                      // dwFlags
                &pvFuncAddr,
                &hFuncAddr)
                        &&
#ifdef DEBUG_CRYPT_ASN1
                0 == (ICMTest_GetDebugCryptAsn1Flags() &
                            DEBUG_OSS_CRYPT_ASN1_SAME_ENCRYPT_FLAG)
                        &&
#endif // DEBUG_CRYPT_ASN1
            (void *) ICM_DefaultExportEncryptKey != pvFuncAddr) {
        CERT_PUBLIC_KEY_INFO PublicKeyInfo;
        PBYTE pbData;
        DWORD rgcbData[2] = {0, 0};

        if (ICM_IsSP3CompatibleEncrypt(pContentEncryptInfo))
            rgcbData[1] = CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG;

        PublicKeyInfo.Algorithm = pKeyTransEncryptInfo->KeyEncryptionAlgorithm;
        PublicKeyInfo.PublicKey = pKeyTransEncodeInfo->RecipientPublicKey;
        fRet = ((PFN_CMSG_EXPORT_ENCRYPT_KEY) pvFuncAddr)(
            pContentEncryptInfo->hCryptProv,
            pContentEncryptInfo->hContentEncryptKey,
            &PublicKeyInfo,
            NULL,                       // pbData
            rgcbData);
        if (fRet) {
            if (NULL == (pbData = (PBYTE) ICM_Alloc(rgcbData[0])))
                fRet = FALSE;
            else {
                fRet = ((PFN_CMSG_EXPORT_ENCRYPT_KEY) pvFuncAddr)(
                    pContentEncryptInfo->hCryptProv,
                    pContentEncryptInfo->hContentEncryptKey,
                    &PublicKeyInfo,
                    pbData,
                    rgcbData);
                if (fRet) {
                    pKeyTransEncryptInfo->EncryptedKey.pbData = pbData;
                    pKeyTransEncryptInfo->EncryptedKey.cbData = rgcbData[0];
                } else
                    ICM_Free(pbData);
            }
        }
    } else
        fRet = ICM_DefaultExportKeyTrans(
            pContentEncryptInfo,
            pKeyTransEncodeInfo,
            pKeyTransEncryptInfo,
            0,                      // dwFlags
            NULL                    // pvReserved
            );

    if (hFuncAddr)
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    return fRet;
}


//+-------------------------------------------------------------------------
//  Get the CAPI ALG_ID corresponding to the wrap encryption OID.
//
//  For RC2, if the ASN.1 encryption algorithm has any parameters, decode to
//  get the key bit length.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetWrapEncryptParameters(
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    OUT PDWORD                      pdwAlgIdEncrypt,
    OUT PDWORD                      pdwBitLen           // 0 => default length
    )
{
    BOOL fRet;

    *pdwBitLen = 0;

    if (!ICM_GetCAPI(
            CRYPT_ENCRYPT_ALG_OID_GROUP_ID,
            paiEncrypt,
            pdwAlgIdEncrypt))
        goto GetCAPIError;

    if (CALG_RC2 == *pdwAlgIdEncrypt) {
        // Check if more than just the NULL parameters
        if (2 < paiEncrypt->Parameters.cbData) {
            PBYTE pbEncoded = paiEncrypt->Parameters.pbData;
            DWORD cbEncoded = paiEncrypt->Parameters.cbData;

            // Try to decode as an integer containing the RC2 version
            int iVersion = 0;
            DWORD cbStructInfo = sizeof(iVersion);

            if (!CryptDecodeObject(
                    X509_ASN_ENCODING,
                    X509_INTEGER,
                    pbEncoded,
                    cbEncoded,
                    0,                          // dwFlags
                    &iVersion,
                    &cbStructInfo))
                goto RC2VersionDecodeError;
            if (!ICM_RC2VersionToBitLength(iVersion, pdwBitLen))
                goto RC2VersionToBitLengthError;
        } else
            *pdwBitLen = 40;
    }
    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

SET_ERROR(GetCAPIError, CRYPT_E_UNKNOWN_ALGO)
TRACE_ERROR(RC2VersionDecodeError)
TRACE_ERROR(RC2VersionToBitLengthError)
}


//+-------------------------------------------------------------------------
//  Get the CAPI ALG_ID and bit length by decoding the DH Encryption Parameters
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetDhWrapEncryptParameters(
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    OUT LPSTR                       *ppszAllocWrapOID,
    OUT PDWORD                      pdwAlgIdWrap,
    OUT PDWORD                      pdwBitLen           // 0 => default length
    )
{
    DWORD dwError = ERROR_SUCCESS;
    BOOL fRet;
    ASN1error_e Asn1Err;
    ASN1decoding_t pDec = ICM_GetDecoder();
    AlgorithmIdentifier *poai = NULL;
    CRYPT_ALGORITHM_IDENTIFIER ai;   ZEROSTRUCT(ai);

    // Decode the DH KeyEncryption Parameters to get the Wrap Encryption
    // Algorithm
    if (0 == paiEncrypt->Parameters.cbData)
        goto NoDhWrapParametersError;

    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&poai,
            AlgorithmIdentifier_PDU,
            paiEncrypt->Parameters.pbData,
            paiEncrypt->Parameters.cbData)))
        goto Asn1DecodeAlgorithmIdentifierError;

    if (!ICM_Asn1FromAlgorithmIdentifier(poai, &ai))
        goto Asn1FromAlgorithmIdentifierError;

    if (!ICM_GetWrapEncryptParameters(&ai, pdwAlgIdWrap, pdwBitLen))
        goto GetWrapEncryptParametersError;
    *ppszAllocWrapOID = ai.pszObjId;
    fRet = TRUE;
CommonReturn:
    PkiAsn1FreeInfo(pDec, AlgorithmIdentifier_PDU, poai);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    ICM_Free(ai.pszObjId);
    *ppszAllocWrapOID = NULL;
    *pdwBitLen = 0;
    *pdwAlgIdWrap = 0;
    fRet = FALSE;
    goto CommonReturn;

SET_ERROR(NoDhWrapParametersError, CRYPT_E_UNKNOWN_ALGO)
SET_ERROR_VAR(Asn1DecodeAlgorithmIdentifierError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(Asn1FromAlgorithmIdentifierError)
TRACE_ERROR(GetWrapEncryptParametersError)
}


//+-------------------------------------------------------------------------
//  Get the CAPI ALG_ID corresponding to the wrap encryption OID. Generate
//  default parameters for and encode. For RC2, encode as RC2ParameterVersion
//  integer.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_CreateDefaultWrapEncryptParameters(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN OUT PCRYPT_ALGORITHM_IDENTIFIER paiEncrypt,
    IN PVOID pvEncryptAuxInfo,
    OUT PDWORD pdwAlgIdEncrypt,
    OUT PDWORD pdwBitLen           // 0 => default length
    )
{
    BOOL fRet;

    assert(0 == paiEncrypt->Parameters.cbData);
    *pdwBitLen = 0;
    if (!ICM_GetCAPI(
            CRYPT_ENCRYPT_ALG_OID_GROUP_ID,
            paiEncrypt,
            pdwAlgIdEncrypt))
        goto GetCAPIError;

    if (CALG_RC2 == *pdwAlgIdEncrypt) {
        PCMSG_RC2_AUX_INFO pAuxInfo =
            (PCMSG_RC2_AUX_INFO) pvEncryptAuxInfo;
        CRYPT_ENCODE_PARA EncodePara;
        int iVersion;

        if (pAuxInfo && pAuxInfo->cbSize >= sizeof(CMSG_RC2_AUX_INFO)) {
            DWORD dwVersion;
            *pdwBitLen = pAuxInfo->dwBitLen & AUX_INFO_BIT_LENGTH_MASK;

            if (!ICM_BitLengthToRC2Version(*pdwBitLen, &dwVersion))
                goto BitLengthToRC2VersionError;
            iVersion = dwVersion;
        } else {
            iVersion = CRYPT_RC2_40BIT_VERSION;
            *pdwBitLen = 40;
        }

        ZEROSTRUCT(EncodePara);
        EncodePara.cbSize = sizeof(EncodePara);
        EncodePara.pfnAlloc = pContentEncryptInfo->pfnAlloc;
        EncodePara.pfnFree = pContentEncryptInfo->pfnFree;
        if (!CryptEncodeObjectEx(
                X509_ASN_ENCODING,
                X509_INTEGER,
                &iVersion,
                CRYPT_ENCODE_ALLOC_FLAG,
                &EncodePara,
                (void *) &paiEncrypt->Parameters.pbData,
                &paiEncrypt->Parameters.cbData
                )) goto EncodeError;
    }
    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

SET_ERROR(GetCAPIError, CRYPT_E_UNKNOWN_ALGO)
TRACE_ERROR(BitLengthToRC2VersionError)
TRACE_ERROR(EncodeError)
}

//+-------------------------------------------------------------------------
//  Get the CAPI ALG_ID corresponding to the wrap encryption OID. 
//  Encode the DH EncryptionAlgorithmIdentifier parameters which is the encoded
//  WrapAlgorithmIdentifier.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_CreateDefaultDhWrapEncryptParameters(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN OUT PCRYPT_ALGORITHM_IDENTIFIER paiEncrypt,
    IN PCRYPT_ALGORITHM_IDENTIFIER paiWrap,
    IN PVOID pvWrapAuxInfo,
    OUT PDWORD pdwAlgIdWrap,
    OUT PDWORD pdwBitLen           // 0 => default length
    )
{
    BOOL fRet;

    CRYPT_ALGORITHM_IDENTIFIER aiWrap;  ZEROSTRUCT(aiWrap);
    AlgorithmIdentifier oaiWrap;

    assert(0 == paiEncrypt->Parameters.cbData);

    if (0 == paiWrap->Parameters.cbData) {
        aiWrap = *paiWrap;
        if (!ICM_CreateDefaultWrapEncryptParameters(
                pContentEncryptInfo,
                &aiWrap,
                pvWrapAuxInfo,
                pdwAlgIdWrap,
                pdwBitLen))
            goto CreateDefaultWrapEncryptParametersError;
        paiWrap = &aiWrap;
    } else {
        if (!ICM_GetWrapEncryptParameters(
                paiWrap,
                pdwAlgIdWrap,
                pdwBitLen))
            goto GetWrapEncryptParametersError;
    }

    // Encode the Wrap Algorithm Identifier
    if (!ICM_Asn1ToAlgorithmIdentifier(
            paiWrap,
            &oaiWrap))
        goto Asn1ToAlgorithmIdentifierError;
    if (!ICM_Asn1Encode(
            AlgorithmIdentifier_PDU,
            &oaiWrap,
            &paiEncrypt->Parameters))
        goto EncodeAlgorithmIdentifierError;

    fRet = TRUE;
CommonReturn:
    ICM_Free(aiWrap.Parameters.pbData);
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(CreateDefaultWrapEncryptParametersError)
TRACE_ERROR(GetWrapEncryptParametersError)
TRACE_ERROR(Asn1ToAlgorithmIdentifierError)
TRACE_ERROR(EncodeAlgorithmIdentifierError)
}

BOOL
WINAPI
ICM_PadEncodedOctets(
    IN DWORD cbMaxContents,
    IN OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    BOOL fRet;
    DWORD cbEncoded = *pcbEncoded;
    DWORD cbMaxEncoded;
    DWORD cbLength;

    ICM_GetLengthOctets(cbMaxContents, NULL, &cbLength);
    cbMaxEncoded = 1 + cbLength + cbMaxContents;
    if (cbMaxEncoded > cbEncoded) {
        BYTE *pbMaxEncoded;
        BYTE *pbEncoded;

        if (NULL == (pbMaxEncoded = (BYTE *) ICM_Alloc(cbMaxEncoded)))
            goto OutOfMemory;

        pbEncoded = *ppbEncoded;
        memcpy(pbMaxEncoded, pbEncoded, cbEncoded);
        memset(pbMaxEncoded + cbEncoded, 0, cbMaxEncoded - cbEncoded);
        ICM_Free(pbEncoded);
        *ppbEncoded = pbMaxEncoded;
        *pcbEncoded = cbMaxEncoded;
    } else if (cbMaxEncoded < cbEncoded)
        goto InvalidMaxEncodedLength;

    fRet = TRUE;
CommonReturn:
    return fRet;
ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
SET_ERROR(InvalidMaxEncodedLength, ERROR_INVALID_DATA)
}


#ifndef DH1
#define DH1 (((DWORD)'D'<<8)+((DWORD)'H'<<16)+((DWORD)'1'<<24))
#endif

HCRYPTKEY
WINAPI
ICM_GenerateEphemeralDh(
    IN HCRYPTPROV hProv,
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO pKeyAgreeEncodeInfo,
    IN OUT PCMSG_KEY_AGREE_ENCRYPT_INFO pKeyAgreeEncryptInfo,
    OUT DWORD *pcbP
    )
{
    DWORD dwError = ERROR_SUCCESS;
    HCRYPTKEY hEphemeralKey = 0;
    PCRYPT_ALGORITHM_IDENTIFIER paiEphemeral =
        pKeyAgreeEncodeInfo->pEphemeralAlgorithm;
    PCERT_PUBLIC_KEY_INFO pPubKeyInfo =
        &pKeyAgreeEncryptInfo->OriginatorPublicKeyInfo;
    PCERT_X942_DH_PARAMETERS pDhParameters = NULL;
    PUBLICKEYSTRUC *pPubKeyStruc = NULL;
    DWORD cbPubKeyStruc;
    BYTE *pbKeyBlob;
    DHPUBKEY *pCspPubKey;
    DWORD cbP;
    PCRYPT_UINT_BLOB pGBlob;
    BYTE *pbY;
    DWORD cbY;
    CRYPT_UINT_BLOB YBlob;
    CRYPT_ENCODE_PARA EncodePara;

    assert(CMSG_KEY_AGREE_EPHEMERAL_KEY_CHOICE ==
        pKeyAgreeEncodeInfo->dwKeyChoice);
    if (NULL == (pDhParameters =
            (PCERT_X942_DH_PARAMETERS) ICM_AllocAndDecodeObject(
                X942_DH_PARAMETERS,
                paiEphemeral->Parameters.pbData,
                paiEphemeral->Parameters.cbData)))
        goto DhParametersDecodeError;

    cbP = pDhParameters->p.cbData;
    *pcbP = cbP;
    
    if (!CryptGenKey(
            hProv,
            CALG_DH_EPHEM,
            ((cbP * 8) << 16) | CRYPT_EXPORTABLE | CRYPT_PREGEN,
            &hEphemeralKey))
        goto GenEphemeralKeyError;

    if (!CryptSetKeyParam(
            hEphemeralKey,
            KP_P,
            (PBYTE) &pDhParameters->p,
            0))                 // dwFlags
        goto SetPError;

    // Note, the length of G can be less than length P. Pad with leading
    // zeroes in little endian form.
    if (pDhParameters->g.cbData >= cbP)
        pGBlob = &pDhParameters->g;
    else {
        DWORD cbG = pDhParameters->g.cbData;

        // We are done using P parameter. Overwrite with the G parameter and
        // pad with leading zeroes in little endian form.
        pGBlob = &pDhParameters->p;
        memcpy(pGBlob->pbData, pDhParameters->g.pbData, cbG);
        memset(pGBlob->pbData + cbG, 0, cbP - cbG);
    }
    if (!CryptSetKeyParam(
            hEphemeralKey,
            KP_G,
            (PBYTE) pGBlob,
            0))                 // dwFlags
        goto SetGError;

    if (0 < pDhParameters->q.cbData) {
        if (!CryptSetKeyParam(
                hEphemeralKey,
                KP_Q,
                (PBYTE) &pDhParameters->q,
                0))                 // dwFlags
            goto SetQError;
    }

    if (!CryptSetKeyParam(
            hEphemeralKey,
            KP_X,
            NULL,               // pbData
            0))                 // dwFlags
        goto SetXError;

    // Export the public key to get Y
    cbPubKeyStruc = 0;
    if (!CryptExportKey(
            hEphemeralKey,
            0,              // hPubKey
            PUBLICKEYBLOB,
            0,              // dwFlags
            NULL,           // pbData
            &cbPubKeyStruc
            ) || (cbPubKeyStruc == 0))
        goto ExportPublicKeyBlobError;
    if (NULL == (pPubKeyStruc = (PUBLICKEYSTRUC *) ICM_Alloc(cbPubKeyStruc)))
        goto OutOfMemory;
    if (!CryptExportKey(
            hEphemeralKey,
            0,              // hPubKey
            PUBLICKEYBLOB,
            0,              // dwFlags
            (BYTE *) pPubKeyStruc,
            &cbPubKeyStruc
            ))
        goto ExportPublicKeyBlobError;


    // The CAPI public key representation consists of the following sequence:
    //  - PUBLICKEYSTRUC
    //  - DHPUBKEY
    //  - rgbY[cbKey]
    pbKeyBlob = (BYTE *) pPubKeyStruc;
    pCspPubKey = (DHPUBKEY *) (pbKeyBlob + sizeof(PUBLICKEYSTRUC));
    pbY = pbKeyBlob + sizeof(PUBLICKEYSTRUC) + sizeof(DHPUBKEY);
    cbY = pCspPubKey->bitlen / 8;

    if (cbPubKeyStruc < sizeof(PUBLICKEYSTRUC) + sizeof(DHPUBKEY) + cbY)
        goto InvalidEphemeralKey;
    if (pPubKeyStruc->bType != PUBLICKEYBLOB)
        goto InvalidEphemeralKey;
    if (pCspPubKey->magic != DH1)
        goto InvalidEphemeralKey;
    if (cbY != cbP)
        goto InvalidEphemeralKey;

    ZEROSTRUCT(EncodePara);
    EncodePara.cbSize = sizeof(EncodePara);
    EncodePara.pfnAlloc = pContentEncryptInfo->pfnAlloc;
    EncodePara.pfnFree = pContentEncryptInfo->pfnFree;
    YBlob.pbData = pbY;
    YBlob.cbData = cbY;
    if (!CryptEncodeObjectEx(
            X509_ASN_ENCODING,
            X509_DH_PUBLICKEY,
            &YBlob,
            CRYPT_ENCODE_ALLOC_FLAG,
            &EncodePara,
            (void *) &pPubKeyInfo->PublicKey.pbData,
            &pPubKeyInfo->PublicKey.cbData
            ))
        goto EncodeDHPublicKeyError;

    pKeyAgreeEncryptInfo->dwOriginatorChoice =
        CMSG_KEY_AGREE_ORIGINATOR_PUBLIC_KEY;
    pPubKeyInfo->Algorithm.pszObjId = paiEphemeral->pszObjId;
    pKeyAgreeEncryptInfo->dwFlags |=
        CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_BITS_FLAG;

    if (pContentEncryptInfo->dwEncryptFlags &
            CMSG_CONTENT_ENCRYPT_PAD_ENCODED_LEN_FLAG) {
        if (!ICM_PadEncodedOctets(
                cbY + 1,
                &pPubKeyInfo->PublicKey.pbData,
                &pPubKeyInfo->PublicKey.cbData
                ))
            goto PadEncodedOctetsError;
    }


CommonReturn:
    ICM_Free(pDhParameters);
    ICM_Free(pPubKeyStruc);
    ICM_SetLastError(dwError);
    return hEphemeralKey;

ErrorReturn:
    dwError = GetLastError();
    if (hEphemeralKey) {
        CryptDestroyKey(hEphemeralKey);
        hEphemeralKey = 0;
    }
    goto CommonReturn;

TRACE_ERROR(DhParametersDecodeError)
TRACE_ERROR(GenEphemeralKeyError)
TRACE_ERROR(SetPError)
TRACE_ERROR(SetGError)
TRACE_ERROR(SetQError)
TRACE_ERROR(SetXError)
TRACE_ERROR(ExportPublicKeyBlobError)
SET_ERROR(InvalidEphemeralKey, NTE_BAD_PUBLIC_KEY)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(EncodeDHPublicKeyError)
TRACE_ERROR(PadEncodedOctetsError)
}

HCRYPTKEY
WINAPI
ICM_ImportDhAgreeKey(
    IN HCRYPTPROV hKeyAgreeProv,
    IN HCRYPTKEY hMyKey,
    IN DWORD cbP,
    IN PCRYPT_BIT_BLOB pPublicKey,
    IN LPSTR pszWrapOID,
    IN ALG_ID AlgidWrap,
    IN DWORD dwBitLen,
    IN PCRYPT_DATA_BLOB pUserKeyingMaterial
    )
{
    DWORD dwError = ERROR_SUCCESS;
    HCRYPTKEY hAgreeKey = 0;
    PCRYPT_UINT_BLOB pDhPubKey = NULL;
    PBYTE pbKeyBlob = NULL;
    DWORD cbKeyBlob;
    PUBLICKEYSTRUC *pPubKeyStruc;
    DHPUBKEY *pCspPubKey;
    DWORD cbY;
    PBYTE pbKey;

    CMS_DH_KEY_INFO CmsDhKeyInfo;    ZEROSTRUCT(CmsDhKeyInfo);

    if (NULL == (pDhPubKey = (PCRYPT_UINT_BLOB) ICM_AllocAndDecodeObject(
            X509_DH_PUBLICKEY,
            pPublicKey->pbData,
            pPublicKey->cbData)))
        goto DecodePubKeyError;

    // The CAPI public key representation consists of the following sequence:
    //  - PUBLICKEYSTRUC
    //  - DHPUBKEY
    //  - rgbY[cbP]

    cbY = pDhPubKey->cbData;
    if (0 == cbY || cbY > cbP)
        goto InvalidDhPubKeyError;
    cbKeyBlob = sizeof(PUBLICKEYSTRUC) + sizeof(DHPUBKEY) + cbP;
    if (NULL == (pbKeyBlob = (PBYTE) ICM_Alloc(cbKeyBlob)))
        goto OutOfMemory;

    pPubKeyStruc = (PUBLICKEYSTRUC *) pbKeyBlob;
    pCspPubKey = (DHPUBKEY *) (pbKeyBlob + sizeof(PUBLICKEYSTRUC));
    pbKey = pbKeyBlob + sizeof(PUBLICKEYSTRUC) + sizeof(DHPUBKEY);
    
    // PUBLICKEYSTRUC
    pPubKeyStruc->bType = PUBLICKEYBLOB;
    pPubKeyStruc->bVersion = CUR_BLOB_VERSION;
    pPubKeyStruc->reserved = 0;
    pPubKeyStruc->aiKeyAlg = CALG_DH_SF;
    // DHPUBKEY
    pCspPubKey->magic = DH1;
    pCspPubKey->bitlen = cbP * 8;
    // rgbY[cbP]
    memcpy(pbKey, pDhPubKey->pbData, cbY);
    if (cbP > cbY)
        memset(pbKey + cbY, 0, cbP - cbY);

    if (!CryptImportKey(
            hKeyAgreeProv,
            pbKeyBlob,
            cbKeyBlob,
            hMyKey,
            0,                      // dwFlags
            &hAgreeKey)) {
        hAgreeKey = 0;
        goto ImportKeyError;
    }

    CmsDhKeyInfo.dwVersion = sizeof(CmsDhKeyInfo);
    CmsDhKeyInfo.Algid = AlgidWrap;
    CmsDhKeyInfo.pszContentEncObjId = pszWrapOID;
    CmsDhKeyInfo.PubInfo = *pUserKeyingMaterial;
    // CmsDhKeyInfo.pReserved

    if (!CryptSetKeyParam(
            hAgreeKey,
            KP_CMS_DH_KEY_INFO,
            (PBYTE) &CmsDhKeyInfo,
            (CALG_RC2 == AlgidWrap) ? (dwBitLen << 16) : 0))     // dwFlags
        goto SetCmsDhKeyInfoError;

    if (CALG_RC2 == AlgidWrap && 0 != dwBitLen) {
        if (!CryptSetKeyParam(
                hAgreeKey,
                KP_EFFECTIVE_KEYLEN,
                (PBYTE) &dwBitLen,
                0))                     // dwFlags
            goto SetEffectiveKeyLenError;
    }

CommonReturn:
    ICM_Free(pDhPubKey);
    ICM_Free(pbKeyBlob);
    ICM_SetLastError(dwError);
    return hAgreeKey;

ErrorReturn:
    dwError = GetLastError();
    if (hAgreeKey) {
        CryptDestroyKey(hAgreeKey);
        hAgreeKey = 0;
    }
    goto CommonReturn;

TRACE_ERROR(DecodePubKeyError)
SET_ERROR(InvalidDhPubKeyError, E_INVALIDARG)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(ImportKeyError)
TRACE_ERROR(SetCmsDhKeyInfoError)
TRACE_ERROR(SetEffectiveKeyLenError)
}

BOOL
WINAPI
ICM_DefaultExportKeyAgree(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO pKeyAgreeEncodeInfo,
    IN OUT PCMSG_KEY_AGREE_ENCRYPT_INFO pKeyAgreeEncryptInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved
    )
{
    BOOL fRet;
    DWORD dwError = ERROR_SUCCESS;
    HCRYPTPROV hKeyAgreeProv = 0;           // Doesn't need to be released
    HCRYPTKEY hContentEncryptKey = 0;
    HCRYPTKEY hEphemeralKey = 0;
    HCRYPTKEY hAgreeKey = 0;
    DWORD cbP;
    PCRYPT_ALGORITHM_IDENTIFIER paiEncrypt =
        &pKeyAgreeEncryptInfo->KeyEncryptionAlgorithm;
    LPSTR pszAllocWrapOID = NULL;
    LPSTR pszWrapOID;
    DWORD dwAlgIdWrap;
    DWORD dwBitLen;

    DWORD cRecipient;
    PCMSG_KEY_AGREE_KEY_ENCRYPT_INFO *ppRecipientEncryptInfo;
    PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO *ppRecipientEncodeInfo;

    assert(CMSG_KEY_AGREE_EPHEMERAL_KEY_CHOICE ==
        pKeyAgreeEncodeInfo->dwKeyChoice);
    if (CMSG_KEY_AGREE_EPHEMERAL_KEY_CHOICE != pKeyAgreeEncodeInfo->dwKeyChoice)
        goto InvalidKeyAgreeKeyChoice;

    if (0 == paiEncrypt->Parameters.cbData) {
        PCRYPT_ALGORITHM_IDENTIFIER paiWrap =
            &pKeyAgreeEncodeInfo->KeyWrapAlgorithm;

        if (!ICM_CreateDefaultDhWrapEncryptParameters(
                pContentEncryptInfo,
                paiEncrypt,
                paiWrap,
                pKeyAgreeEncodeInfo->pvKeyWrapAuxInfo,
                &dwAlgIdWrap,
                &dwBitLen))
            goto CreateDefaultDhWrapEncryptParametersError;
        assert(paiEncrypt->Parameters.cbData);
        pKeyAgreeEncryptInfo->dwFlags |= CMSG_KEY_AGREE_ENCRYPT_FREE_PARA_FLAG;
        pszWrapOID = paiWrap->pszObjId;
    } else {
        if (!ICM_GetDhWrapEncryptParameters(
                paiEncrypt,
                &pszAllocWrapOID,
                &dwAlgIdWrap,
                &dwBitLen))
            goto GetDhWrapEncryptParametersError;
        pszWrapOID = pszAllocWrapOID;
    }

    hKeyAgreeProv = pKeyAgreeEncodeInfo->hCryptProv;
    if (0 == hKeyAgreeProv) {
        if (0 == pKeyAgreeEncryptInfo->dwRecipientIndex)
            hKeyAgreeProv = pContentEncryptInfo->hCryptProv;
        else {
            // Check if the type of and public key algorithm for this
            // recipient is the same as the first recipient's.

            PCMSG_RECIPIENT_ENCODE_INFO prei;

            prei = &pContentEncryptInfo->rgCmsRecipients[0];
            if (CMSG_KEY_AGREE_RECIPIENT == prei->dwRecipientChoice &&
                    ICM_IsSameRecipientPublicKeyAlgorithm(
                        &prei->pKeyAgree->KeyEncryptionAlgorithm,
                        paiEncrypt))
                hKeyAgreeProv = pContentEncryptInfo->hCryptProv;
            else {
                // Get default provider associated with the
                // key encryption algorithm
                DWORD dwAlgIdPubKey;

                if (!ICM_GetCAPI(
                        CRYPT_PUBKEY_ALG_OID_GROUP_ID,
                        paiEncrypt,
                        &dwAlgIdPubKey))
                    goto GetPublicKeyAlgIdError;

                hKeyAgreeProv = I_CryptGetDefaultCryptProvForEncrypt(
                    dwAlgIdPubKey, dwAlgIdWrap, dwBitLen);
                if (0 == hKeyAgreeProv)
                    goto GetDefaultCryptProvError;
            }
        }
    }

    if (hKeyAgreeProv != pContentEncryptInfo->hCryptProv) {
        // Need to export the hContentEncryptKey from the ContentEncrypt
        // provider and import into the KeyAgree provider
        hContentEncryptKey = ICM_ExportContentEncryptKeyAndImport(
            pContentEncryptInfo,
            hKeyAgreeProv);
        if (0 == hContentEncryptKey)
            goto ImportContentKeyError;
    } else
        hContentEncryptKey = pContentEncryptInfo->hContentEncryptKey;

    if (0 == (hEphemeralKey = ICM_GenerateEphemeralDh(
            hKeyAgreeProv,
            pContentEncryptInfo,
            pKeyAgreeEncodeInfo,
            pKeyAgreeEncryptInfo,
            &cbP)))
        goto GenerateEphemeralDhError;

    cRecipient = pKeyAgreeEncryptInfo->cKeyAgreeKeyEncryptInfo;
    ppRecipientEncryptInfo = pKeyAgreeEncryptInfo->rgpKeyAgreeKeyEncryptInfo;
    ppRecipientEncodeInfo = pKeyAgreeEncodeInfo->rgpRecipientEncryptedKeys;
    for ( ; 0 < cRecipient;
                    cRecipient--,
                    ppRecipientEncryptInfo++,
                    ppRecipientEncodeInfo++) {
        if (0 == (hAgreeKey = ICM_ImportDhAgreeKey(
                hKeyAgreeProv,
                hEphemeralKey,
                cbP,
                &(*ppRecipientEncodeInfo)->RecipientPublicKey,
                pszWrapOID,
                dwAlgIdWrap,
                dwBitLen,
                &pKeyAgreeEncodeInfo->UserKeyingMaterial
                )))
            goto ImportDhAgreeKeyError;

        if (!ICM_ExportEncryptedKey(
                hContentEncryptKey,
                hAgreeKey,
                SYMMETRICWRAPKEYBLOB,
                FALSE,                  // fAllowSP3CompatibleEncrypt
                &(*ppRecipientEncryptInfo)->EncryptedKey))
            goto ExportEncryptedKeyError;

        CryptDestroyKey(hAgreeKey);
        hAgreeKey = 0;
    }

    fRet = TRUE;

CommonReturn:
    ICM_Free(pszAllocWrapOID);

    if (hKeyAgreeProv != pContentEncryptInfo->hCryptProv &&
            hContentEncryptKey)
        CryptDestroyKey(hContentEncryptKey);
    if (hAgreeKey)
        CryptDestroyKey(hAgreeKey);
    if (hEphemeralKey)
        CryptDestroyKey(hEphemeralKey);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidKeyAgreeKeyChoice, E_INVALIDARG)
TRACE_ERROR(CreateDefaultDhWrapEncryptParametersError)
TRACE_ERROR(GetDhWrapEncryptParametersError)
TRACE_ERROR(GetPublicKeyAlgIdError)
TRACE_ERROR(GetDefaultCryptProvError)
TRACE_ERROR(ImportContentKeyError)
TRACE_ERROR(GenerateEphemeralDhError)
TRACE_ERROR(ImportDhAgreeKeyError)
TRACE_ERROR(ExportEncryptedKeyError)
}

BOOL
WINAPI
ICM_ExportKeyAgree(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO pKeyAgreeEncodeInfo,
    IN OUT PCMSG_KEY_AGREE_ENCRYPT_INFO pKeyAgreeEncryptInfo
    )
{
    BOOL fRet;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr;

    if (CryptGetOIDFunctionAddress(
            hExportKeyAgreeFuncSet,
            X509_ASN_ENCODING,
            pKeyAgreeEncryptInfo->KeyEncryptionAlgorithm.pszObjId,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr)) {
        fRet = ((PFN_CMSG_EXPORT_KEY_AGREE) pvFuncAddr)(
            pContentEncryptInfo,
            pKeyAgreeEncodeInfo,
            pKeyAgreeEncryptInfo,
            0,                      // dwFlags
            NULL                    // pvReserved
            );
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    } else
        fRet = ICM_DefaultExportKeyAgree(
            pContentEncryptInfo,
            pKeyAgreeEncodeInfo,
            pKeyAgreeEncryptInfo,
            0,                      // dwFlags
            NULL                    // pvReserved
            );

    return fRet;
}

BOOL
WINAPI
ICM_DefaultExportMailList(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN PCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO pMailListEncodeInfo,
    IN OUT PCMSG_MAIL_LIST_ENCRYPT_INFO pMailListEncryptInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved
    )
{
    BOOL fRet;
    DWORD dwError = ERROR_SUCCESS;

    HCRYPTPROV hMailListProv = 0;           // not released
    HCRYPTKEY hContentEncryptKey = 0;       // destroy if exported/imported
    HCRYPTKEY hKeyEncryptionKey = 0;        // not destroyed
    PCRYPT_ALGORITHM_IDENTIFIER paiEncrypt =
        &pMailListEncryptInfo->KeyEncryptionAlgorithm;
    DWORD dwAlgIdEncrypt;
    DWORD dwBitLen;

    hMailListProv = pMailListEncodeInfo->hCryptProv;
    switch (pMailListEncodeInfo->dwKeyChoice) {
        case CMSG_MAIL_LIST_HANDLE_KEY_CHOICE:
            hKeyEncryptionKey = pMailListEncodeInfo->hKeyEncryptionKey;
            assert(hMailListProv && hKeyEncryptionKey);
            if (0 == hMailListProv || 0 == hKeyEncryptionKey)
                goto InvalidMailListHandleKeyPara;
            break;
        default:
            goto InvalidMailListKeyChoice;
    }

    if (0 == paiEncrypt->Parameters.cbData) {
        if (!ICM_CreateDefaultWrapEncryptParameters(
                pContentEncryptInfo,
                paiEncrypt,
                pMailListEncodeInfo->pvKeyEncryptionAuxInfo,
                &dwAlgIdEncrypt,
                &dwBitLen))
            goto CreateDefaultWrapEncryptParametersError;
        if (paiEncrypt->Parameters.cbData)
            pMailListEncryptInfo->dwFlags |=
                CMSG_MAIL_LIST_ENCRYPT_FREE_PARA_FLAG;
    } else {
        if (!ICM_GetWrapEncryptParameters(
                paiEncrypt,
                &dwAlgIdEncrypt,
                &dwBitLen))
            goto GetWrapEncryptParametersError;
    }


    if (hMailListProv != pContentEncryptInfo->hCryptProv) {
        // Need to export the hContentEncryptKey from the ContentEncrypt
        // provider and import into the MailList provider
        hContentEncryptKey = ICM_ExportContentEncryptKeyAndImport(
            pContentEncryptInfo,
            hMailListProv);
        if (0 == hContentEncryptKey)
            goto ImportContentKeyError;
    } else
        hContentEncryptKey = pContentEncryptInfo->hContentEncryptKey;

    if (CALG_RC2 == dwAlgIdEncrypt && 0 != dwBitLen)
        // Silently ignore any errors. Not supported in earlier versions
        CryptSetKeyParam(
            hKeyEncryptionKey,
            KP_EFFECTIVE_KEYLEN,
            (PBYTE) &dwBitLen,
            0);                 // dwFlags

    if (!ICM_ExportEncryptedKey(
            hContentEncryptKey,
            hKeyEncryptionKey,
            SYMMETRICWRAPKEYBLOB,
            FALSE,                  // fAllowSP3CompatibleEncrypt
            &pMailListEncryptInfo->EncryptedKey))
        goto ExportEncryptedKeyError;

    fRet = TRUE;

CommonReturn:
    if (hMailListProv != pContentEncryptInfo->hCryptProv &&
            hContentEncryptKey)
        CryptDestroyKey(hContentEncryptKey);

    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidMailListHandleKeyPara, E_INVALIDARG)
SET_ERROR(InvalidMailListKeyChoice, E_INVALIDARG)
TRACE_ERROR(CreateDefaultWrapEncryptParametersError)
TRACE_ERROR(GetWrapEncryptParametersError)
TRACE_ERROR(ImportContentKeyError)
TRACE_ERROR(ExportEncryptedKeyError)
}

BOOL
WINAPI
ICM_ExportMailList(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN PCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO pMailListEncodeInfo,
    IN OUT PCMSG_MAIL_LIST_ENCRYPT_INFO pMailListEncryptInfo
    )
{
    BOOL fRet;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr;

    if (CryptGetOIDFunctionAddress(
            hExportMailListFuncSet,
            X509_ASN_ENCODING,
            pMailListEncryptInfo->KeyEncryptionAlgorithm.pszObjId,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr)) {
        fRet = ((PFN_CMSG_EXPORT_MAIL_LIST) pvFuncAddr)(
            pContentEncryptInfo,
            pMailListEncodeInfo,
            pMailListEncryptInfo,
            0,                      // dwFlags
            NULL                    // pvReserved
            );
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    } else
        fRet = ICM_DefaultExportMailList(
            pContentEncryptInfo,
            pMailListEncodeInfo,
            pMailListEncryptInfo,
            0,                      // dwFlags
            NULL                    // pvReserved
            );

    return fRet;
}

//+-------------------------------------------------------------------------
//  Default export of the encryption key
//
//  Note, pcbData[1] contains dwEncryptFlags, where,
//  CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG may be set to disable the reversing
//  of the encoded, encrypted symmetric key.
//
//  rgcbData[1] is the dwEncryptFlags passed from ICM_DefaultGenEncryptKey
//
//  OldStyle
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultExportEncryptKey(
    IN HCRYPTPROV                   hCryptProv,
    IN HCRYPTKEY                    hEncryptKey,
    IN PCERT_PUBLIC_KEY_INFO        pPublicKeyInfo,
    OUT PBYTE                       pbData,
    IN OUT DWORD                    rgcbData[2])
{
    BOOL            fRet;
    DWORD           dwError = ERROR_SUCCESS;
    HCRYPTKEY       hPubKey = NULL;
    CRYPT_DATA_BLOB EncryptedKey;       ZEROSTRUCT(EncryptedKey);
    DWORD           cb;

    if (!CryptImportPublicKeyInfo(
            hCryptProv,
            X509_ASN_ENCODING,
            pPublicKeyInfo,
            &hPubKey))
        goto ImportKeyError;

    if (!ICM_ExportEncryptedKey(
            hEncryptKey,
            hPubKey,
            SIMPLEBLOB,
            0 != (rgcbData[1] & CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG),
            &EncryptedKey))
        goto ExportEncryptedKeyError;

    fRet = TRUE;
    cb = EncryptedKey.cbData;
    if (pbData) {
        if (rgcbData[0] < cb) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fRet = FALSE;
        } else
            memcpy(pbData, EncryptedKey.pbData, cb);
    }

CommonReturn:
    rgcbData[0] = cb;
    ICM_Free(EncryptedKey.pbData);
    if (hPubKey)
        CryptDestroyKey(hPubKey);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    cb = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(ImportKeyError)
TRACE_ERROR(ExportEncryptedKeyError)
}

//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
PCMSG_RECIPIENT_ENCODE_INFO
WINAPI
ICM_CreateCmsRecipientEncodeInfos(
    IN DWORD cRecipients,
    IN PCERT_INFO *rgpCertInfoRecipients
    )
{
    PCMSG_RECIPIENT_ENCODE_INFO rgCmsRecipients = NULL;
    PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO rgKeyTrans;
    DWORD cbCmsRecipients;
    DWORD i;

    assert(cRecipients && rgpCertInfoRecipients);
    cbCmsRecipients = sizeof(CMSG_RECIPIENT_ENCODE_INFO) * cRecipients +
        sizeof(CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO) * cRecipients;

    if (NULL == (rgCmsRecipients = (PCMSG_RECIPIENT_ENCODE_INFO) ICM_AllocZero(
            cbCmsRecipients)))
        return NULL;

    rgKeyTrans = (PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO)
        (((PBYTE) rgCmsRecipients) +
            sizeof(CMSG_RECIPIENT_ENCODE_INFO) * cRecipients);

    for (i = 0; i < cRecipients; i++) {
        rgCmsRecipients[i].dwRecipientChoice = CMSG_KEY_TRANS_RECIPIENT;
        rgCmsRecipients[i].pKeyTrans = &rgKeyTrans[i];
        rgKeyTrans[i].cbSize = sizeof(CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO);
        rgKeyTrans[i].KeyEncryptionAlgorithm =
            rgpCertInfoRecipients[i]->SubjectPublicKeyInfo.Algorithm;
        // rgKeyTrans[i].pvKeyEncryptionAuxInfo =
        // rgKeyTrans[i].hCryptProv =
        rgKeyTrans[i].RecipientPublicKey =
            rgpCertInfoRecipients[i]->SubjectPublicKeyInfo.PublicKey;

        ICM_GetCertIdFromCertInfo(rgpCertInfoRecipients[i],
            &rgKeyTrans[i].RecipientId);
    }

    return rgCmsRecipients;
}

void
WINAPI
ICM_FreeContentEncryptInfo(
    IN PCMSG_ENVELOPED_ENCODE_INFO pEnvelopedEncodeInfo,
    IN OUT PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo
    )
{
    DWORD dwErr = GetLastError();

    if (pEnvelopedEncodeInfo->rgpRecipients) {
        ICM_Free(pContentEncryptInfo->rgCmsRecipients);
        pContentEncryptInfo->rgCmsRecipients = NULL;
    }

    if (pContentEncryptInfo->hContentEncryptKey) {
        CryptDestroyKey(pContentEncryptInfo->hContentEncryptKey);
        pContentEncryptInfo->hContentEncryptKey = 0;
    }

    if (pContentEncryptInfo->dwFlags &
            CMSG_CONTENT_ENCRYPT_RELEASE_CONTEXT_FLAG) {
        pContentEncryptInfo->dwFlags &=
            ~CMSG_CONTENT_ENCRYPT_RELEASE_CONTEXT_FLAG;
        assert(pContentEncryptInfo->hCryptProv);
        CryptReleaseContext(pContentEncryptInfo->hCryptProv, 0);
        pContentEncryptInfo->hCryptProv = 0;
    }

    if (pContentEncryptInfo->dwFlags &
            CMSG_CONTENT_ENCRYPT_FREE_PARA_FLAG) {
        pContentEncryptInfo->dwFlags &=
            ~CMSG_CONTENT_ENCRYPT_FREE_PARA_FLAG;
        assert(
            pContentEncryptInfo->ContentEncryptionAlgorithm.Parameters.cbData
                &&
            pContentEncryptInfo->ContentEncryptionAlgorithm.Parameters.pbData);
        ICM_Free(
            pContentEncryptInfo->ContentEncryptionAlgorithm.Parameters.pbData);
        pContentEncryptInfo->ContentEncryptionAlgorithm.Parameters.cbData = 0;
        pContentEncryptInfo->ContentEncryptionAlgorithm.Parameters.pbData = NULL;
    }

    SetLastError(dwErr);
}



BOOL
WINAPI
ICM_InitializeContentEncryptInfo(
    IN PCMSG_ENVELOPED_ENCODE_INFO pEnvelopedEncodeInfo,
    OUT PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo
    )
{
    BOOL fRet;
    DWORD cRecipients;

    memset(pContentEncryptInfo, 0, sizeof(*pContentEncryptInfo));
    pContentEncryptInfo->cbSize = sizeof(*pContentEncryptInfo);
    pContentEncryptInfo->hCryptProv =
        pEnvelopedEncodeInfo->hCryptProv;
    pContentEncryptInfo->ContentEncryptionAlgorithm =
        pEnvelopedEncodeInfo->ContentEncryptionAlgorithm;
    pContentEncryptInfo->pvEncryptionAuxInfo =
        pEnvelopedEncodeInfo->pvEncryptionAuxInfo;
    pContentEncryptInfo->pfnAlloc = ICM_Alloc;
    pContentEncryptInfo->pfnFree = ICM_Free;
    // pContentEncryptInfo->dwEncryptFlags =
    // pContentEncryptInfo->hContentEncryptKey =
    // pContentEncryptInfo->dwFlags =

    cRecipients = pEnvelopedEncodeInfo->cRecipients;
    pContentEncryptInfo->cRecipients = cRecipients;

    if (0 == cRecipients)
        ;
    else if (pEnvelopedEncodeInfo->rgpRecipients) {
        if (NULL == (pContentEncryptInfo->rgCmsRecipients =
                ICM_CreateCmsRecipientEncodeInfos(
                    cRecipients, pEnvelopedEncodeInfo->rgpRecipients)))
            goto CreateCmsRecipientEncodeInfosError;
    } else {
        if (sizeof(CMSG_ENVELOPED_ENCODE_INFO) > pEnvelopedEncodeInfo->cbSize)
            goto MissingCmsRecipients;
        pContentEncryptInfo->rgCmsRecipients =
            pEnvelopedEncodeInfo->rgCmsRecipients;
        if (NULL == pContentEncryptInfo->rgCmsRecipients)
            goto MissingCmsRecipients;
    }

    if (!ICM_GenContentEncryptKey(pContentEncryptInfo))
        goto GenContentEncryptKeyError;

    fRet = TRUE;

CommonReturn:
    return fRet;
ErrorReturn:
    ICM_FreeContentEncryptInfo(pEnvelopedEncodeInfo, pContentEncryptInfo);
    fRet = FALSE;
    goto CommonReturn;

SET_ERROR(MissingCmsRecipients, E_INVALIDARG)
TRACE_ERROR(CreateCmsRecipientEncodeInfosError)
TRACE_ERROR(GenContentEncryptKeyError)
}


//+-------------------------------------------------------------------------
//  Oss set/free functions
//
//  Assumption: upon entry to the set functions, the Oss data structure has
//  already been zeroed.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_SetOssAny(
    IN PCRYPT_DATA_BLOB pAny,
    IN OUT Any *pOssAny
    )
{
    if (NULL == (pOssAny->value =
            (unsigned char *) ICM_DupMem(pAny->pbData, pAny->cbData)))
        return FALSE;
    pOssAny->length = pAny->cbData;
    return TRUE;
}

void
WINAPI
ICM_FreeOssAny(
    IN OUT Any *pOssAny
    )
{
    if (pOssAny->value) {
        ICM_Free(pOssAny->value);
        pOssAny->value = NULL;
    }
}

BOOL
WINAPI
ICM_SetOssHugeInteger(
    IN PCRYPT_INTEGER_BLOB pHugeInteger,
    IN OUT HugeIntegerType *pOssHugeInteger
    )
{
    return PkiAsn1SetHugeInteger(
        pHugeInteger,
        &pOssHugeInteger->length,
        &pOssHugeInteger->value
        );
}

void
WINAPI
ICM_FreeOssHugeInteger(
    IN OUT HugeIntegerType *pOssHugeInteger
    )
{
    if (pOssHugeInteger->value) {
        PkiAsn1FreeHugeInteger(pOssHugeInteger->value);
        pOssHugeInteger->value = NULL;
    }
}

BOOL
WINAPI
ICM_SetOssOctetString(
    IN PCRYPT_DATA_BLOB pOctetString,
    IN OUT OctetStringType *pOssOctetString
    )
{
    if (NULL == (pOssOctetString->value =
            (unsigned char *) ICM_DupMem(
                pOctetString->pbData, pOctetString->cbData)))
        return FALSE;
    pOssOctetString->length = pOctetString->cbData;
    return TRUE;
}

void
WINAPI
ICM_FreeOssOctetString(
    IN OUT OctetStringType *pOssOctetString
    )
{
    if (pOssOctetString->value) {
        ICM_Free(pOssOctetString->value);
        pOssOctetString->value = NULL;
    }
}

BOOL
WINAPI
ICM_SetOssBitString(
    IN PCRYPT_BIT_BLOB pBitString,
    IN OUT BitStringType *pOssBitString
    )
{
    CRYPT_BIT_BLOB BitString = *pBitString;
    if (NULL == (BitString.pbData = (PBYTE) ICM_DupMem(
            BitString.pbData, BitString.cbData)))
        return FALSE;

    PkiAsn1SetBitString(&BitString, &pOssBitString->length,
        &pOssBitString->value);
    return TRUE;
}

void
WINAPI
ICM_FreeOssBitString(
    IN OUT BitStringType *pOssBitString
    )
{
    if (pOssBitString->value) {
        ICM_Free(pOssBitString->value);
        pOssBitString->value = NULL;
    }
}

static BYTE abDerNULL[] = {5, 0};

BOOL
WINAPI
ICM_SetOssAlgorithmIdentifier(
    IN PCRYPT_ALGORITHM_IDENTIFIER pai,
    IN OUT AlgorithmIdentifier *pOssAlgId
    )
{
    BOOL fRet;
    PBYTE pbData;
    DWORD cbData;

    pOssAlgId->algorithm.count = SIZE_OSS_OID;
    if (!PkiAsn1ToObjectIdentifier(
            pai->pszObjId,
            &pOssAlgId->algorithm.count,
            pOssAlgId->algorithm.value))
        goto PkiAsn1ToObjectIdentifierError;
    pOssAlgId->bit_mask = parameters_present;

    pbData = pai->Parameters.pbData;
    cbData = pai->Parameters.cbData;
    if (0 == cbData) {
        pOssAlgId->parameters.length = sizeof(abDerNULL);
        pOssAlgId->parameters.value = abDerNULL;
    } else {
        if (NULL == (pOssAlgId->parameters.value =
                (unsigned char *) ICM_DupMem(pbData, cbData)))
            goto OutOfMemory;
        pOssAlgId->parameters.length = cbData;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(PkiAsn1ToObjectIdentifierError, CRYPT_E_OID_FORMAT)
TRACE_ERROR(OutOfMemory)
}

void
WINAPI
ICM_FreeOssAlgorithmIdentifier(
    IN OUT AlgorithmIdentifier *pOssAlgId
    )
{
    unsigned char *value;

#ifdef OSS_CRYPT_ASN1
    value = pOssAlgId->parameters.value;
#else
    value = (unsigned char *) pOssAlgId->parameters.value;
#endif  // OSS_CRYPT_ASN1
    if (value && value != abDerNULL) {
        ICM_Free(value);
        pOssAlgId->parameters.value = NULL;
    }
}

BOOL
WINAPI
ICM_SetOssOtherKeyAttribute(
    IN PCRYPT_ATTRIBUTE_TYPE_VALUE pOtherAttr,
    IN OUT OtherKeyAttribute *pOssOtherAttr
    )
{
    BOOL fRet;

    pOssOtherAttr->keyAttrId.count = SIZE_OSS_OID;
    if (!PkiAsn1ToObjectIdentifier(
            pOtherAttr->pszObjId,
            &pOssOtherAttr->keyAttrId.count,
            pOssOtherAttr->keyAttrId.value))
        goto PkiAsn1ToObjectIdentifierError;

    if (pOtherAttr->Value.cbData) {
        if (!ICM_SetOssAny(&pOtherAttr->Value, &pOssOtherAttr->keyAttr))
            goto SetOssAnyError;

        pOssOtherAttr->bit_mask |= keyAttr_present;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(PkiAsn1ToObjectIdentifierError, CRYPT_E_OID_FORMAT)
TRACE_ERROR(SetOssAnyError)
}

void
WINAPI
ICM_FreeOssOtherKeyAttribute(
    OUT OtherKeyAttribute *pOssOtherAttr
    )
{
    ICM_FreeOssAny(&pOssOtherAttr->keyAttr);
}

void
WINAPI
ICM_FreeOssIssuerAndSerialNumber(
    IN OUT IssuerAndSerialNumber *pOssIssuerAndSerialNumber
    )
{
    ICM_FreeOssAny(&pOssIssuerAndSerialNumber->issuer);
    ICM_FreeOssHugeInteger(&pOssIssuerAndSerialNumber->serialNumber);
}

BOOL
WINAPI
ICM_SetOssIssuerAndSerialNumber(
    IN PCERT_ISSUER_SERIAL_NUMBER pIssuerAndSerialNumber,
    IN OUT IssuerAndSerialNumber *pOssIssuerAndSerialNumber
    )
{
    BOOL fRet;

    if (!ICM_SetOssAny(&pIssuerAndSerialNumber->Issuer,
            &pOssIssuerAndSerialNumber->issuer))
        goto SetOssAnyError;

    if (!ICM_SetOssHugeInteger(&pIssuerAndSerialNumber->SerialNumber,
            &pOssIssuerAndSerialNumber->serialNumber))
        goto SetOssHugeIntegerError;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    ICM_FreeOssIssuerAndSerialNumber(pOssIssuerAndSerialNumber);
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(SetOssAnyError)
TRACE_ERROR(SetOssHugeIntegerError)
}



BOOL
WINAPI
ICM_SetOssCertIdentifier(
    IN PCERT_ID pCertId,
    IN OUT CertIdentifier *pOssCertId
    )
{
    BOOL fRet;

    switch (pCertId->dwIdChoice) {
        case CERT_ID_ISSUER_SERIAL_NUMBER:
            if (!ICM_SetOssIssuerAndSerialNumber(
                    &pCertId->IssuerSerialNumber,
                    &pOssCertId->u.issuerAndSerialNumber
                    ))
                goto SetOssIssuerAndSerialNumberError;
            break;
        case CERT_ID_KEY_IDENTIFIER:
            if (!ICM_SetOssOctetString(
                    &pCertId->KeyId,
                    &pOssCertId->u.subjectKeyIdentifier
                    ))
                goto SetOssOctetStringError;
            break;
        default:
            goto InvalidIdChoice;
    }

    assert(CERT_ID_ISSUER_SERIAL_NUMBER == issuerAndSerialNumber_chosen);
    assert(CERT_ID_KEY_IDENTIFIER == subjectKeyIdentifier_chosen);

    pOssCertId->choice = (unsigned short) pCertId->dwIdChoice;

    fRet = TRUE;
CommonReturn:
    return fRet;
ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(SetOssIssuerAndSerialNumberError)
TRACE_ERROR(SetOssOctetStringError)
SET_ERROR(InvalidIdChoice, E_INVALIDARG)
}

void
WINAPI
ICM_FreeOssCertIdentifier(
    IN OUT CertIdentifier *pOssCertId
    )
{
    switch (pOssCertId->choice) {
        case issuerAndSerialNumber_chosen:
            ICM_FreeOssIssuerAndSerialNumber(
                &pOssCertId->u.issuerAndSerialNumber);
            break;
        case subjectKeyIdentifier_chosen:
            ICM_FreeOssOctetString(&pOssCertId->u.subjectKeyIdentifier);
            break;
        default:
            break;
    }
    pOssCertId->choice = 0;
}

void
WINAPI
ICM_FreeOssOriginatorCertIdentifierOrKey(
    IN OUT OriginatorIdentifierOrKey *pOssOriginator
    )
{
    switch (pOssOriginator->choice) {
        case issuerAndSerialNumber_chosen:
            ICM_FreeOssIssuerAndSerialNumber(
                &pOssOriginator->u.issuerAndSerialNumber);
            break;
        case subjectKeyIdentifier_chosen:
            ICM_FreeOssOctetString(
                &pOssOriginator->u.subjectKeyIdentifier);
            break;
        case originatorKey_chosen:
            ICM_FreeOssAlgorithmIdentifier(
                &pOssOriginator->u.originatorKey.algorithm);
            ICM_FreeOssBitString(
                &pOssOriginator->u.originatorKey.publicKey);
            break;
        default:
            break;
    }
    pOssOriginator->choice = 0;
}

BOOL
WINAPI
ICM_SetOssOriginatorCertIdentifier(
    IN PCERT_ID pCertId,
    IN OUT OriginatorIdentifierOrKey *pOssOriginator
    )
{
    BOOL fRet;

    switch (pCertId->dwIdChoice) {
        case CERT_ID_ISSUER_SERIAL_NUMBER:
            if (!ICM_SetOssIssuerAndSerialNumber(
                    &pCertId->IssuerSerialNumber,
                    &pOssOriginator->u.issuerAndSerialNumber
                    ))
                goto SetOssIssuerAndSerialNumberError;
            pOssOriginator->choice = issuerAndSerialNumber_chosen;
            break;
        case CERT_ID_KEY_IDENTIFIER:
            if (!ICM_SetOssOctetString(
                    &pCertId->KeyId,
                    &pOssOriginator->u.subjectKeyIdentifier
                    ))
                goto SetOssOctetStringError;
            pOssOriginator->choice = subjectKeyIdentifier_chosen;
            break;
        default:
            goto InvalidIdChoice;
    }


    fRet = TRUE;
CommonReturn:
    return fRet;
ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(SetOssIssuerAndSerialNumberError)
TRACE_ERROR(SetOssOctetStringError)
SET_ERROR(InvalidIdChoice, E_INVALIDARG)
}

BOOL
WINAPI
ICM_SetOssOriginatorPublicKey(
    IN PCERT_PUBLIC_KEY_INFO pPublicKeyInfo,
    IN OUT OriginatorIdentifierOrKey *pOssOriginator
    )
{
    BOOL fRet;
    PCRYPT_ALGORITHM_IDENTIFIER pai = &pPublicKeyInfo->Algorithm;
    AlgorithmIdentifier *pOssAlgId = &pOssOriginator->u.originatorKey.algorithm;

    pOssOriginator->choice = originatorKey_chosen;
    if (!ICM_SetOssAlgorithmIdentifier(
            pai,
            pOssAlgId
            ))
        goto SetOssAlgorithmIdentifierError;

    if (0 == pai->Parameters.cbData) {
        DWORD dwFlags;
        PCCRYPT_OID_INFO pOIDInfo;

        dwFlags = 0;
        if (pOIDInfo = CryptFindOIDInfo(
                CRYPT_OID_INFO_OID_KEY,
                pai->pszObjId,
                CRYPT_PUBKEY_ALG_OID_GROUP_ID)) {
            if (1 <= pOIDInfo->ExtraInfo.cbData / sizeof(DWORD)) {
                DWORD *pdwExtra = (DWORD *) pOIDInfo->ExtraInfo.pbData;
                dwFlags = pdwExtra[0];
            }
        }

        if (dwFlags & CRYPT_OID_NO_NULL_ALGORITHM_PARA_FLAG) {
            // NO NULL parameters

            pOssAlgId->bit_mask &= ~parameters_present;
            pOssAlgId->parameters.length = 0;
            pOssAlgId->parameters.value = NULL;
        }
    }

    if (!ICM_SetOssBitString(
            &pPublicKeyInfo->PublicKey,
            &pOssOriginator->u.originatorKey.publicKey
            ))
        goto SetOssBitStringError;

    fRet = TRUE;
CommonReturn:
    return fRet;
ErrorReturn:
    ICM_FreeOssOriginatorCertIdentifierOrKey(pOssOriginator);
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(SetOssAlgorithmIdentifierError)
TRACE_ERROR(SetOssBitStringError)
}

//+-------------------------------------------------------------------------
//  Free the Oss KeyTransRecipientInfo
//--------------------------------------------------------------------------
void
WINAPI
ICM_FreeOssKeyTransRecipientInfo(
    IN OUT KeyTransRecipientInfo *pori
    )
{
    ICM_FreeOssCertIdentifier(&pori->rid);
    ICM_FreeOssAlgorithmIdentifier(&pori->keyEncryptionAlgorithm);
    ICM_Free(pori->encryptedKey.value);
    pori->encryptedKey.value = NULL;
}

//+-------------------------------------------------------------------------
//  Fill the Oss KeyTransRecipientInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_FillOssKeyTransRecipientInfo(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO pKeyTransEncodeInfo,
    IN DWORD dwRecipientIndex,
    IN OUT KeyTransRecipientInfo *pori,
#ifdef OSS_CRYPT_ASN1
    IN OUT int *pEnvelopedDataVersion
#else
    IN OUT ASN1int32_t *pEnvelopedDataVersion
#endif  // OSS_CRYPT_ASN1
    )
{
    BOOL fRet;
    CMSG_KEY_TRANS_ENCRYPT_INFO KeyTransEncryptInfo;

    memset(&KeyTransEncryptInfo, 0, sizeof(KeyTransEncryptInfo));
    KeyTransEncryptInfo.cbSize = sizeof(KeyTransEncryptInfo);
    KeyTransEncryptInfo.dwRecipientIndex = dwRecipientIndex;
    KeyTransEncryptInfo.KeyEncryptionAlgorithm =
        pKeyTransEncodeInfo->KeyEncryptionAlgorithm;
    // KeyTransEncryptInfo.EncryptedKey =
    // KeyTransEncryptInfo.dwFlags =

    if (!ICM_ExportKeyTrans(
            pContentEncryptInfo,
            pKeyTransEncodeInfo,
            &KeyTransEncryptInfo
            ))
        goto ExportKeyTransError;
    pori->encryptedKey.length = KeyTransEncryptInfo.EncryptedKey.cbData;
    pori->encryptedKey.value = KeyTransEncryptInfo.EncryptedKey.pbData;

    if (CERT_ID_ISSUER_SERIAL_NUMBER ==
            pKeyTransEncodeInfo->RecipientId.dwIdChoice)
        pori->version = CMSG_KEY_TRANS_PKCS_1_5_VERSION;
    else {
        pori->version = CMSG_KEY_TRANS_CMS_VERSION;
        *pEnvelopedDataVersion = CMSG_ENVELOPED_DATA_CMS_VERSION;
    }

    if (!ICM_SetOssCertIdentifier(
            &pKeyTransEncodeInfo->RecipientId,
            &pori->rid
            ))
        goto SetOssCertIdentifierError;

    if (!ICM_SetOssAlgorithmIdentifier(
            &KeyTransEncryptInfo.KeyEncryptionAlgorithm,
            &pori->keyEncryptionAlgorithm
            ))
        goto SetOssAlgorithmIdentifierError;

    fRet = TRUE;
CommonReturn:
    if (KeyTransEncryptInfo.dwFlags & CMSG_KEY_TRANS_ENCRYPT_FREE_PARA_FLAG)
        ICM_Free(KeyTransEncryptInfo.KeyEncryptionAlgorithm.Parameters.pbData);
    return fRet;

ErrorReturn:
    ICM_FreeOssKeyTransRecipientInfo(pori);
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(ExportKeyTransError)
TRACE_ERROR(SetOssCertIdentifierError)
TRACE_ERROR(SetOssAlgorithmIdentifierError)
}


//+-------------------------------------------------------------------------
//  Free the Oss KeyAgreeRecipientInfo
//--------------------------------------------------------------------------
void
WINAPI
ICM_FreeOssKeyAgreeRecipientInfo(
    IN OUT KeyAgreeRecipientInfo *pori
    )
{
    RecipientEncryptedKey *porek;
    unsigned int count;

    ICM_FreeOssOriginatorCertIdentifierOrKey(&pori->originator);
    ICM_FreeOssOctetString(&pori->ukm);
    ICM_FreeOssAlgorithmIdentifier(&pori->keyEncryptionAlgorithm);

    porek = pori->recipientEncryptedKeys.value;
    if (NULL == porek)
        return;

    for (count = pori->recipientEncryptedKeys.count;
                                                0 < count; count--, porek++) {
        switch (porek->rid.choice) {
            case issuerAndSerialNumber_chosen:
                ICM_FreeOssIssuerAndSerialNumber(
                    &porek->rid.u.issuerAndSerialNumber);
                break;
            case rKeyId_chosen:
                ICM_FreeOssOctetString(
                    &porek->rid.u.rKeyId.subjectKeyIdentifier);
                ICM_FreeOssOtherKeyAttribute(&porek->rid.u.rKeyId.other);
                break;
        }

        ICM_Free(porek->encryptedKey.value);
        porek->encryptedKey.value = NULL;
    }

    ICM_Free(pori->recipientEncryptedKeys.value);
}


//+-------------------------------------------------------------------------
//  Fill the Oss KeyAgreeRecipientInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_FillOssKeyAgreeRecipientInfo(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO pKeyAgreeEncodeInfo,
    IN DWORD dwRecipientIndex,
    IN OUT KeyAgreeRecipientInfo *pori
    )
{
    BOOL fRet;
    DWORD i;
    CMSG_KEY_AGREE_ENCRYPT_INFO KeyAgreeEncryptInfo;
    DWORD cKeyAgreeKeyEncryptInfo;
    PCMSG_KEY_AGREE_KEY_ENCRYPT_INFO *rgpKeyAgreeKeyEncryptInfo = NULL;
    PCMSG_KEY_AGREE_KEY_ENCRYPT_INFO pKeyAgreeKeyEncryptInfo;

    RecipientEncryptedKey *porek;

    memset(&KeyAgreeEncryptInfo, 0, sizeof(KeyAgreeEncryptInfo));
    KeyAgreeEncryptInfo.cbSize = sizeof(KeyAgreeEncryptInfo);
    KeyAgreeEncryptInfo.dwRecipientIndex = dwRecipientIndex;
    KeyAgreeEncryptInfo.KeyEncryptionAlgorithm =
        pKeyAgreeEncodeInfo->KeyEncryptionAlgorithm;
    KeyAgreeEncryptInfo.UserKeyingMaterial =
        pKeyAgreeEncodeInfo->UserKeyingMaterial;
    // KeyAgreeEncryptInfo.dwOriginatorChoice =
    // union
    //    KeyAgreeEncryptInfo.OriginatorCertId =
    //    KeyAgreeEncryptInfo.OriginatorPublicKeyInfo =
    // KeyAgreeEncryptInfo.cKeyAgreeKeyEncryptInfo =
    // KeyAgreeEncryptInfo.rgpKeyAgreeKeyEncryptInfo =
    // KeyAgreeEncryptInfo.dwFlags =

    cKeyAgreeKeyEncryptInfo = pKeyAgreeEncodeInfo->cRecipientEncryptedKeys;
    if (0 == cKeyAgreeKeyEncryptInfo)
        goto NoKeyAgreeKeys;

    if (NULL == (pori->recipientEncryptedKeys.value =
            (RecipientEncryptedKey *) ICM_AllocZero(
                cKeyAgreeKeyEncryptInfo * sizeof(RecipientEncryptedKey))))
        goto OutOfMemory;
    pori->recipientEncryptedKeys.count = cKeyAgreeKeyEncryptInfo;

    if (NULL == (rgpKeyAgreeKeyEncryptInfo =
            (PCMSG_KEY_AGREE_KEY_ENCRYPT_INFO *) ICM_AllocZero(
                cKeyAgreeKeyEncryptInfo *
                    sizeof(PCMSG_KEY_AGREE_KEY_ENCRYPT_INFO) +
                cKeyAgreeKeyEncryptInfo *
                    sizeof(CMSG_KEY_AGREE_KEY_ENCRYPT_INFO))))
        goto OutOfMemory;

    pKeyAgreeKeyEncryptInfo =
        PCMSG_KEY_AGREE_KEY_ENCRYPT_INFO (((PBYTE) rgpKeyAgreeKeyEncryptInfo) +
            cKeyAgreeKeyEncryptInfo * sizeof(PCMSG_KEY_AGREE_KEY_ENCRYPT_INFO));
    for (i = 0; i < cKeyAgreeKeyEncryptInfo; i++, pKeyAgreeKeyEncryptInfo++) {
        rgpKeyAgreeKeyEncryptInfo[i] = pKeyAgreeKeyEncryptInfo;
        pKeyAgreeKeyEncryptInfo->cbSize =
            sizeof(CMSG_KEY_AGREE_KEY_ENCRYPT_INFO);
    }

    KeyAgreeEncryptInfo.cKeyAgreeKeyEncryptInfo = cKeyAgreeKeyEncryptInfo;
    KeyAgreeEncryptInfo.rgpKeyAgreeKeyEncryptInfo = rgpKeyAgreeKeyEncryptInfo;

    if (!ICM_ExportKeyAgree(
            pContentEncryptInfo,
            pKeyAgreeEncodeInfo,
            &KeyAgreeEncryptInfo
            ))
        goto ExportKeyAgreeError;

    for (i = 0, porek = pori->recipientEncryptedKeys.value;
                                 i < cKeyAgreeKeyEncryptInfo; i++, porek++) {
        porek->encryptedKey.length =
            rgpKeyAgreeKeyEncryptInfo[i]->EncryptedKey.cbData;
        porek->encryptedKey.value =
            rgpKeyAgreeKeyEncryptInfo[i]->EncryptedKey.pbData;
    }

    pori->version = CMSG_KEY_AGREE_VERSION;

    switch (KeyAgreeEncryptInfo.dwOriginatorChoice) {
        case CMSG_KEY_AGREE_ORIGINATOR_CERT:
            if (!ICM_SetOssOriginatorCertIdentifier(
                    &KeyAgreeEncryptInfo.OriginatorCertId,
                    &pori->originator
                    ))
                goto SetOssOriginatorCertIdentifierError;
            break;
        case CMSG_KEY_AGREE_ORIGINATOR_PUBLIC_KEY:
            if (!ICM_SetOssOriginatorPublicKey(
                    &KeyAgreeEncryptInfo.OriginatorPublicKeyInfo,
                    &pori->originator
                    ))
                goto SetOssOriginatorPublicKeyError;
            break;
        default:
            goto InvalidOriginatorChoice;
    }

    if (KeyAgreeEncryptInfo.UserKeyingMaterial.cbData) {
        if (!ICM_SetOssOctetString(
                &KeyAgreeEncryptInfo.UserKeyingMaterial,
                &pori->ukm
                ))
            goto SetOssUserKeyingMaterialError;
        pori->bit_mask |= ukm_present;
    }

    if (!ICM_SetOssAlgorithmIdentifier(
            &KeyAgreeEncryptInfo.KeyEncryptionAlgorithm,
            &pori->keyEncryptionAlgorithm
            ))
        goto SetOssAlgorithmIdentifierError;

    for (i = 0, porek = pori->recipientEncryptedKeys.value;
                                 i < cKeyAgreeKeyEncryptInfo; i++, porek++) {
        PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO pEncryptedKeyEncodeInfo =
            pKeyAgreeEncodeInfo->rgpRecipientEncryptedKeys[i];
            

        switch (pEncryptedKeyEncodeInfo->RecipientId.dwIdChoice) {
            case CERT_ID_ISSUER_SERIAL_NUMBER:
                if (!ICM_SetOssIssuerAndSerialNumber(
                        &pEncryptedKeyEncodeInfo->RecipientId.IssuerSerialNumber,
                        &porek->rid.u.issuerAndSerialNumber
                        ))
                    goto SetOssIssuerAndSerialNumberError;
                porek->rid.choice = issuerAndSerialNumber_chosen;
                break;
            case CERT_ID_KEY_IDENTIFIER:
                if (!ICM_SetOssOctetString(
                        &pEncryptedKeyEncodeInfo->RecipientId.KeyId,
                        &porek->rid.u.rKeyId.subjectKeyIdentifier
                        ))
                    goto SetOssOctetStringError;
                porek->rid.choice = rKeyId_chosen;

                if (pEncryptedKeyEncodeInfo->Date.dwLowDateTime ||
                        pEncryptedKeyEncodeInfo->Date.dwHighDateTime) {
                    if (!PkiAsn1ToGeneralizedTime(
                            &pEncryptedKeyEncodeInfo->Date,
                            &porek->rid.u.rKeyId.date
                            ))
                        goto ConvToGeneralizedTimeError;
                    porek->rid.u.rKeyId.bit_mask |= date_present;
                }

                if (pEncryptedKeyEncodeInfo->pOtherAttr) {
                    if (!ICM_SetOssOtherKeyAttribute(
                            pEncryptedKeyEncodeInfo->pOtherAttr,
                            &porek->rid.u.rKeyId.other
                            ))
                        goto SetOssOtherKeyAttributeError;
                    porek->rid.u.rKeyId.bit_mask |= other_present;
                }
                break;
            default:
                goto InvalidRecipientIdChoice;
        }
    }

    fRet = TRUE;
CommonReturn:
    ICM_Free(rgpKeyAgreeKeyEncryptInfo);

    if (KeyAgreeEncryptInfo.dwFlags & CMSG_KEY_AGREE_ENCRYPT_FREE_PARA_FLAG)
        ICM_Free(KeyAgreeEncryptInfo.KeyEncryptionAlgorithm.Parameters.pbData);
    if (KeyAgreeEncryptInfo.dwFlags &
            CMSG_KEY_AGREE_ENCRYPT_FREE_MATERIAL_FLAG)
        ICM_Free(KeyAgreeEncryptInfo.UserKeyingMaterial.pbData);
    if (KeyAgreeEncryptInfo.dwFlags & 
            CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_ALG_FLAG)
        ICM_Free(
            KeyAgreeEncryptInfo.OriginatorPublicKeyInfo.Algorithm.pszObjId);
    if (KeyAgreeEncryptInfo.dwFlags & 
            CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_PARA_FLAG)
        ICM_Free(
            KeyAgreeEncryptInfo.OriginatorPublicKeyInfo.Algorithm.Parameters.pbData);
    if (KeyAgreeEncryptInfo.dwFlags & 
            CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_BITS_FLAG)
        ICM_Free(KeyAgreeEncryptInfo.OriginatorPublicKeyInfo.PublicKey.pbData);

    return fRet;

ErrorReturn:
    ICM_FreeOssKeyAgreeRecipientInfo(pori);
    fRet = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidOriginatorChoice, E_INVALIDARG)
SET_ERROR(NoKeyAgreeKeys, E_INVALIDARG)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(ExportKeyAgreeError)
TRACE_ERROR(SetOssOriginatorCertIdentifierError)
TRACE_ERROR(SetOssOriginatorPublicKeyError)
TRACE_ERROR(SetOssUserKeyingMaterialError)
TRACE_ERROR(SetOssAlgorithmIdentifierError)
TRACE_ERROR(SetOssIssuerAndSerialNumberError)
TRACE_ERROR(SetOssOctetStringError)
TRACE_ERROR(ConvToGeneralizedTimeError)
TRACE_ERROR(SetOssOtherKeyAttributeError)
SET_ERROR(InvalidRecipientIdChoice, E_INVALIDARG)
}

//+-------------------------------------------------------------------------
//  Free the Oss MailListRecipientInfo
//--------------------------------------------------------------------------
void
WINAPI
ICM_FreeOssMailListRecipientInfo(
    IN OUT MailListRecipientInfo *pori
    )
{
    ICM_FreeOssOctetString(&pori->mlid.kekIdentifier);
    ICM_FreeOssOtherKeyAttribute(&pori->mlid.other);
    ICM_FreeOssAlgorithmIdentifier(&pori->keyEncryptionAlgorithm);
    ICM_Free(pori->encryptedKey.value);
    pori->encryptedKey.value = NULL;
}

//+-------------------------------------------------------------------------
//  Fill the Oss MailListRecipientInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_FillOssMailListRecipientInfo(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN PCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO pMailListEncodeInfo,
    IN DWORD dwRecipientIndex,
    IN OUT MailListRecipientInfo *pori
    )
{
    BOOL fRet;
    CMSG_MAIL_LIST_ENCRYPT_INFO MailListEncryptInfo;

    memset(&MailListEncryptInfo, 0, sizeof(MailListEncryptInfo));
    MailListEncryptInfo.cbSize = sizeof(MailListEncryptInfo);
    MailListEncryptInfo.dwRecipientIndex = dwRecipientIndex;
    MailListEncryptInfo.KeyEncryptionAlgorithm =
        pMailListEncodeInfo->KeyEncryptionAlgorithm;
    // MailListEncryptInfo.EncryptedKey =
    // MailListEncryptInfo.dwFlags =

    if (!ICM_ExportMailList(
            pContentEncryptInfo,
            pMailListEncodeInfo,
            &MailListEncryptInfo
            ))
        goto ExportMailListError;
    pori->encryptedKey.length = MailListEncryptInfo.EncryptedKey.cbData;
    pori->encryptedKey.value = MailListEncryptInfo.EncryptedKey.pbData;

    pori->version = CMSG_MAIL_LIST_VERSION;

    if (!ICM_SetOssOctetString(
            &pMailListEncodeInfo->KeyId,
            &pori->mlid.kekIdentifier
            ))
        goto SetOssOctetStringError;

    if (pMailListEncodeInfo->Date.dwLowDateTime ||
            pMailListEncodeInfo->Date.dwHighDateTime) {
        if (!PkiAsn1ToGeneralizedTime(
                &pMailListEncodeInfo->Date,
                &pori->mlid.date
                ))
            goto ConvToGeneralizedTimeError;
        pori->mlid.bit_mask |= date_present;
    }

    if (pMailListEncodeInfo->pOtherAttr) {
        if (!ICM_SetOssOtherKeyAttribute(
                pMailListEncodeInfo->pOtherAttr,
                &pori->mlid.other
                ))
            goto SetOssOtherKeyAttributeError;
        pori->mlid.bit_mask |= other_present;
    }

    if (!ICM_SetOssAlgorithmIdentifier(
            &MailListEncryptInfo.KeyEncryptionAlgorithm,
            &pori->keyEncryptionAlgorithm
            ))
        goto SetOssAlgorithmIdentifierError;

    fRet = TRUE;
CommonReturn:
    if (MailListEncryptInfo.dwFlags & CMSG_MAIL_LIST_ENCRYPT_FREE_PARA_FLAG)
        ICM_Free(MailListEncryptInfo.KeyEncryptionAlgorithm.Parameters.pbData);
    return fRet;

ErrorReturn:
    ICM_FreeOssMailListRecipientInfo(pori);
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(ExportMailListError)
TRACE_ERROR(SetOssOctetStringError)
TRACE_ERROR(ConvToGeneralizedTimeError)
TRACE_ERROR(SetOssOtherKeyAttributeError)
TRACE_ERROR(SetOssAlgorithmIdentifierError)
}

//+-------------------------------------------------------------------------
//  Free the Oss CmsRecipientInfos
//--------------------------------------------------------------------------
void
WINAPI
ICM_FreeOssCmsRecipientInfos(
    IN OUT CmsRecipientInfos *poris
    )
{
    DWORD i;
    CmsRecipientInfo *pori;

    if (NULL == poris->value)
        return;

    for (i = 0, pori = poris->value; i < poris->count; i++, pori++) {
        switch (pori->choice) {
            case keyTransRecipientInfo_chosen:
                ICM_FreeOssKeyTransRecipientInfo(
                    &pori->u.keyTransRecipientInfo);
                break;
            case keyAgreeRecipientInfo_chosen:
                ICM_FreeOssKeyAgreeRecipientInfo(
                    &pori->u.keyAgreeRecipientInfo);
                break;
            case mailListRecipientInfo_chosen:
                ICM_FreeOssMailListRecipientInfo(
                    &pori->u.mailListRecipientInfo);
                break;
            case 0:
            default:
                break;
        }
    }

    ICM_Free(poris->value);
    poris->value = NULL;
}


//+-------------------------------------------------------------------------
//  Fill the Oss CmsRecipientInfos
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_FillOssCmsRecipientInfos(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN OUT CmsRecipientInfos *poris,
#ifdef OSS_CRYPT_ASN1
    IN OUT int *pEnvelopedDataVersion
#else
    IN OUT ASN1int32_t *pEnvelopedDataVersion
#endif  // OSS_CRYPT_ASN1
    )
{
    BOOL fRet;
    DWORD cRecipients;
    PCMSG_RECIPIENT_ENCODE_INFO rgCmsRecipients;
    CmsRecipientInfo *pori = NULL;
    DWORD i;

    cRecipients = pContentEncryptInfo->cRecipients;
    if (0 == cRecipients)
        goto SuccessReturn;
    rgCmsRecipients = pContentEncryptInfo->rgCmsRecipients;
    assert(cRecipients && rgCmsRecipients);

    if (NULL == (poris->value = (CmsRecipientInfo *) ICM_AllocZero(
            cRecipients * sizeof(CmsRecipientInfo))))
        goto OutOfMemory;
    poris->count = cRecipients;

    for (i = 0, pori = poris->value; i < cRecipients; i++, pori++) {
        switch (rgCmsRecipients[i].dwRecipientChoice) {
            case CMSG_KEY_TRANS_RECIPIENT:
                if (!ICM_FillOssKeyTransRecipientInfo(
                        pContentEncryptInfo,
                        rgCmsRecipients[i].pKeyTrans,
                        i,
                        &pori->u.keyTransRecipientInfo,
                        pEnvelopedDataVersion
                        ))
                    goto FillOssKeyTransRecipientInfoError;
                pori->choice = keyTransRecipientInfo_chosen;
                break;
            case CMSG_KEY_AGREE_RECIPIENT:
                if (!ICM_FillOssKeyAgreeRecipientInfo(
                        pContentEncryptInfo,
                        rgCmsRecipients[i].pKeyAgree,
                        i,
                        &pori->u.keyAgreeRecipientInfo
                        ))
                    goto FillOssKeyAgreeRecipientInfoError;
                pori->choice = keyAgreeRecipientInfo_chosen;
                *pEnvelopedDataVersion = CMSG_ENVELOPED_DATA_CMS_VERSION;
                break;
            case CMSG_MAIL_LIST_RECIPIENT:
                if (!ICM_FillOssMailListRecipientInfo(
                        pContentEncryptInfo,
                        rgCmsRecipients[i].pMailList,
                        i,
                        &pori->u.mailListRecipientInfo
                        ))
                    goto FillOssMailLIstRecipientInfoError;
                pori->choice = mailListRecipientInfo_chosen;
                *pEnvelopedDataVersion = CMSG_ENVELOPED_DATA_CMS_VERSION;
                break;
            default:
                goto InvalidRecipientChoice;
        }
    }

SuccessReturn:
    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    ICM_FreeOssCmsRecipientInfos(poris);

    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(FillOssKeyTransRecipientInfoError)
TRACE_ERROR(FillOssKeyAgreeRecipientInfoError)
TRACE_ERROR(FillOssMailLIstRecipientInfoError)
SET_ERROR(InvalidRecipientChoice, E_INVALIDARG)
}


//+-------------------------------------------------------------------------
//  Open an enveloped message for encoding
//--------------------------------------------------------------------------
HCRYPTMSG
WINAPI
ICM_OpenToEncodeEnvelopedData(
    IN DWORD dwEncodingType,
    IN DWORD dwFlags,
    IN void const *pvMsgEncodeInfo,
    IN OPTIONAL LPSTR pszInnerContentObjID,
    IN OPTIONAL PCMSG_STREAM_INFO pStreamInfo)
{
    DWORD                       dwError = ERROR_SUCCESS;
    PCRYPT_MSG_INFO             pcmi = NULL;
    PCMSG_ENVELOPED_ENCODE_INFO pemei =
        (PCMSG_ENVELOPED_ENCODE_INFO) pvMsgEncodeInfo;
    CmsEnvelopedData            *ped = NULL;
    EncryptedContentInfo        *peci;

    CMSG_CONTENT_ENCRYPT_INFO   ContentEncryptInfo;
        ZEROSTRUCT(ContentEncryptInfo);

    DWORD                       i;
    PCERT_BLOB                  pcert;
    PCRL_BLOB                   pcrl;
    Certificate                 *pOssCert;
    CertificateRevocationList   *pOssCrl;
    DWORD                       cbCert = 0;
    PBYTE                       pbCert;
    DWORD                       cbCrl;
    PBYTE                       pbCrl;
    DWORD                       cbOriginatorInfo;
    DWORD                       cUnprotectedAttr;

    assert(pemei->cbSize >= STRUCT_CBSIZE(CMSG_ENVELOPED_ENCODE_INFO,
        rgpRecipients));
    if (pemei->cbSize <
                STRUCT_CBSIZE(CMSG_ENVELOPED_ENCODE_INFO, rgpRecipients))
        goto InvalidArg;

    if (pemei->cbSize >= sizeof(CMSG_ENVELOPED_ENCODE_INFO)) {
        for (i=pemei->cCertEncoded, pcert=pemei->rgCertEncoded, cbCert=0;
                i>0;
                i--, pcert++)
            cbCert += pcert->cbData;

        for (i=pemei->cAttrCertEncoded, pcert=pemei->rgAttrCertEncoded;
                i>0;
                i--, pcert++)
            cbCert += pcert->cbData;

        for (i=pemei->cCrlEncoded, pcrl=pemei->rgCrlEncoded, cbCrl=0;
                i>0;
                i--, pcrl++)
            cbCrl += pcrl->cbData;

        cbOriginatorInfo =
                pemei->cCertEncoded * sizeof(Certificate) +
                pemei->cAttrCertEncoded * sizeof(Certificate) +
                pemei->cCrlEncoded * sizeof(CertificateRevocationList) +
                cbCert + cbCrl;

        cUnprotectedAttr = pemei->cUnprotectedAttr;
    } else {
        cbOriginatorInfo = 0;
        cUnprotectedAttr = 0;
    }

    ped = (CmsEnvelopedData *)ICM_AllocZero(
            sizeof(CmsEnvelopedData) + cbOriginatorInfo);
    if (NULL == ped)
        goto CmsEnvelopedDataAllocError;

    // pcmi
    pcmi = (PCRYPT_MSG_INFO)ICM_AllocZero(sizeof(CRYPT_MSG_INFO));
    if (NULL == pcmi)
        goto PcmiAllocError;

    // pcmi->hCryptProv
    // pcmi->fDefaultCryptProv
    pcmi->dwEncodingType = dwEncodingType;
    pcmi->dwMsgType = CMSG_ENVELOPED;
    pcmi->dwFlags = dwFlags;
    pcmi->pvMsg = ped;
    pcmi->fEncoding = TRUE;
    pcmi->dwPhase = PHASE_FIRST_ONGOING;
    if (pszInnerContentObjID &&
            (NULL == (pcmi->pszInnerContentObjID = (LPSTR)ICM_DupMem(
                                    pszInnerContentObjID,
                                    ICM_StrLen(pszInnerContentObjID) + 1))))
        goto DupInnerContentObjIDError;
    if (pStreamInfo &&
            (NULL == (pcmi->pStreamInfo = (PCMSG_STREAM_INFO)ICM_DupMem(
                                    pStreamInfo,
                                    sizeof(*pStreamInfo)))))
        goto DupStreamInfoError;

    // version
    if (0 < cbOriginatorInfo || 0 < cUnprotectedAttr)
        ped->version = CMSG_ENVELOPED_DATA_CMS_VERSION;
    else
        ped->version = CMSG_ENVELOPED_DATA_PKCS_1_5_VERSION;

    if (0 < cbOriginatorInfo) {
        OriginatorInfo *poi = &ped->originatorInfo;

        // originatorInfo
        ped->bit_mask |= originatorInfo_present;

        // certificates
        if (0 != pemei->cCertEncoded || 0 != pemei->cAttrCertEncoded) {
            poi->bit_mask |= certificates_present;
            poi->certificates.count = pemei->cCertEncoded +
                pemei->cAttrCertEncoded;
#ifdef OSS_CRYPT_ASN1
            poi->certificates.certificates = (Certificate *)(ped + 1);
#else
            poi->certificates.value = (Certificate *)(ped + 1);
#endif  // OSS_CRYPT_ASN1
            pbCert = (PBYTE)ped +
                    sizeof( CmsEnvelopedData) +
                    pemei->cCertEncoded * sizeof( Certificate) +
                    pemei->cAttrCertEncoded * sizeof( Certificate) +
                    pemei->cCrlEncoded * sizeof( CertificateRevocationList);
            for (i=pemei->cCertEncoded, pcert=pemei->rgCertEncoded,
#ifdef OSS_CRYPT_ASN1
                        pOssCert=poi->certificates.certificates;
#else
                        pOssCert=poi->certificates.value;
#endif  // OSS_CRYPT_ASN1
                    i>0;
                    i--, pcert++, pOssCert++) {
                pOssCert->length = pcert->cbData;
                memcpy( pbCert, pcert->pbData, pcert->cbData);
                pOssCert->value = pbCert;
                pbCert += pcert->cbData;
            }

            for (i=pemei->cAttrCertEncoded, pcert=pemei->rgAttrCertEncoded;
                    i>0;
                    i--, pcert++, pOssCert++) {
                pOssCert->length = pcert->cbData;
                memcpy( pbCert, pcert->pbData, pcert->cbData);
                if (pcert->cbData)
                    // Change tag from SEQUENCE to [1] IMPLICIT
                    *pbCert = ICM_TAG_CONSTRUCTED_CONTEXT_1;
                pOssCert->value = pbCert;
                pbCert += pcert->cbData;
            }
        }

        // crls
        if (0 != pemei->cCrlEncoded) {
            poi->bit_mask |= crls_present;
            poi->crls.count = pemei->cCrlEncoded;
            if (0 != pemei->cCertEncoded || 0 != pemei->cAttrCertEncoded)
#ifdef OSS_CRYPT_ASN1
                poi->crls.crls  = (CertificateRevocationList *)
                    (poi->certificates.certificates +
#else
                poi->crls.value  = (CertificateRevocationList *)
                    (poi->certificates.value +
#endif  // OSS_CRYPT_ASN1
                        (pemei->cCertEncoded + pemei->cAttrCertEncoded));
            else
#ifdef OSS_CRYPT_ASN1
                poi->crls.crls  = (CertificateRevocationList *) (ped + 1);
#else
                poi->crls.value  = (CertificateRevocationList *) (ped + 1);
#endif  // OSS_CRYPT_ASN1
            pbCrl = (PBYTE)ped +
                    sizeof( CmsEnvelopedData) +
                    pemei->cCertEncoded * sizeof( Certificate) +
                    pemei->cAttrCertEncoded * sizeof( Certificate) +
                    pemei->cCrlEncoded * sizeof( CertificateRevocationList) +
                    cbCert;
#ifdef OSS_CRYPT_ASN1
            for (i=pemei->cCrlEncoded, pcrl=pemei->rgCrlEncoded, pOssCrl=poi->crls.crls;
#else
            for (i=pemei->cCrlEncoded, pcrl=pemei->rgCrlEncoded, pOssCrl=poi->crls.value;
#endif  // OSS_CRYPT_ASN1
                    i>0;
                    i--, pcrl++, pOssCrl++) {
                pOssCrl->length = pcrl->cbData;
                memcpy( pbCrl, pcrl->pbData, pcrl->cbData);
                pOssCrl->value = pbCrl;
                pbCrl += pcrl->cbData;
            }
        }
    }

    if (0 < cUnprotectedAttr) {
        Attribute *poatr;
        PCRYPT_ATTRIBUTE patr;

        if (NULL == (poatr = (Attribute *) ICM_AllocZero(
                cUnprotectedAttr * sizeof(Attribute))))
            goto UnprotectedAttrsAllocError;
        ped->unprotectedAttrs.value = poatr;
        ped->unprotectedAttrs.count = cUnprotectedAttr;
        ped->bit_mask |= unprotectedAttrs_present;

        for (i=cUnprotectedAttr, patr=pemei->rgUnprotectedAttr;
                i>0;
                i--, patr++, poatr++) {
            if (!ICM_Asn1ToAttribute(patr, poatr))
                goto Asn1ToAttributeError;
        }
    }


    if (!ICM_InitializeContentEncryptInfo(pemei, &ContentEncryptInfo))
        goto InitializeContentEncryptInfoError;
//    assert(ContentEncryptInfo.hCryptProv);
    pcmi->hCryptProv = ContentEncryptInfo.hCryptProv;
    assert(ContentEncryptInfo.hContentEncryptKey);
    pcmi->hkeyContentCrypt = ContentEncryptInfo.hContentEncryptKey;

    if (pStreamInfo && CMSG_INDEFINITE_LENGTH != pStreamInfo->cbContent)
        ContentEncryptInfo.dwEncryptFlags |=
            CMSG_CONTENT_ENCRYPT_PAD_ENCODED_LEN_FLAG;

    if (!ICM_FillOssCmsRecipientInfos(
            &ContentEncryptInfo,
            &ped->recipientInfos,
            &ped->version
            ))
        goto FillOssCmsRecipientInfosError;

    // Is encryptedContent encapsulated ???
    if (ped->version > CMSG_ENVELOPED_DATA_PKCS_1_5_VERSION) {
        if (ICM_IsData(pszInnerContentObjID))
            pcmi->dwFlags &= ~CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
        else
            pcmi->dwFlags |= CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
    } else if (pcmi->dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG) {
        if (ICM_IsData(pszInnerContentObjID))
            pcmi->dwFlags &= ~CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
        else
            ped->version = CMSG_ENVELOPED_DATA_CMS_VERSION;
    }

    // encryptedContentInfo
    // (.encryptedContent filled in during update)
    peci = &ped->encryptedContentInfo;
    peci->bit_mask = encryptedContent_present;
    peci->contentType.count =
        sizeof(peci->contentType.value)/sizeof(peci->contentType.value[0]);
    if (!PkiAsn1ToObjectIdentifier(
            pszInnerContentObjID ? pszInnerContentObjID : pszObjIdDataType,
            &peci->contentType.count,
            peci->contentType.value))
        goto PkiAsn1ToObjectIdentifierError;

    if (!ICM_MsgAsn1ToAlgorithmIdentifier(
            pcmi,
            &ContentEncryptInfo.ContentEncryptionAlgorithm,
            &peci->contentEncryptionAlgorithm))
        goto MsgAsn1ToAlgorithmIdentifierError;

    if (pStreamInfo && !ICMS_OpenToEncodeEnvelopedData( pcmi, pemei))
        goto StreamOpenToEncodeEnvelopedDataError;

    // From here to CommonReturn, NO Errors
    if (ContentEncryptInfo.hCryptProv == pemei->hCryptProv) {
//        assert(ContentEncryptInfo.hCryptProv);
        assert(0 == (ContentEncryptInfo.dwFlags &
            CMSG_CONTENT_ENCRYPT_RELEASE_CONTEXT_FLAG));
    } else {
        if (pcmi->dwFlags & CMSG_CRYPT_RELEASE_CONTEXT_FLAG) {
            pcmi->dwFlags &= ~CMSG_CRYPT_RELEASE_CONTEXT_FLAG;
            CryptReleaseContext(pemei->hCryptProv, 0);
        }
    }

    if (ContentEncryptInfo.dwFlags &
            CMSG_CONTENT_ENCRYPT_RELEASE_CONTEXT_FLAG) {
        pcmi->dwFlags |= CMSG_CRYPT_RELEASE_CONTEXT_FLAG;
        ContentEncryptInfo.dwFlags &=
            ~CMSG_CONTENT_ENCRYPT_RELEASE_CONTEXT_FLAG;
    }

    ContentEncryptInfo.hContentEncryptKey = 0;

CommonReturn:
    ICM_FreeContentEncryptInfo(pemei, &ContentEncryptInfo);
    ICM_SetLastError(dwError);
    return (HCRYPTMSG) pcmi;

ErrorReturn:
    dwError = GetLastError();
    if (ped) {
        ICM_FreeOssCmsRecipientInfos(&ped->recipientInfos);

        if (ped->unprotectedAttrs.value) {
            Attribute *poatr;

            for (i=ped->unprotectedAttrs.count,
                    poatr=ped->unprotectedAttrs.value;
                    i>0;
                    i--, poatr++) {
                ICM_Free(poatr->attributeValue.value);
            }
            ICM_Free(ped->unprotectedAttrs.value);
        }

        ICM_Free(ped);
    }
    if (pcmi) {
        if (pcmi->pFreeList)
            delete pcmi->pFreeList;
        ICM_Free(pcmi->pszInnerContentObjID);
        ICM_Free(pcmi->pStreamInfo);
        ICM_Free(pcmi);
        pcmi = NULL;
    }
    goto CommonReturn;
SET_ERROR(InvalidArg,E_INVALIDARG)
SET_ERROR(PkiAsn1ToObjectIdentifierError,CRYPT_E_OID_FORMAT)
TRACE_ERROR(DupInnerContentObjIDError)
TRACE_ERROR(DupStreamInfoError)
TRACE_ERROR(CmsEnvelopedDataAllocError)
TRACE_ERROR(PcmiAllocError)
TRACE_ERROR(UnprotectedAttrsAllocError)
TRACE_ERROR(Asn1ToAttributeError)
TRACE_ERROR(InitializeContentEncryptInfoError)
TRACE_ERROR(FillOssCmsRecipientInfosError)
TRACE_ERROR(MsgAsn1ToAlgorithmIdentifierError)
TRACE_ERROR(StreamOpenToEncodeEnvelopedDataError)
}
#else

//+-------------------------------------------------------------------------
//  Default export of the encryption key
//
//  Note, pcbData[1] contains dwEncryptFlags, where,
//  CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG may be set to disable the reversing
//  of the encoded, encrypted symmetric key.
//
//  rgcbData[1] is the dwEncryptFlags passed from ICM_DefaultGenEncryptKey
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultExportEncryptKey(
    IN HCRYPTPROV                   hCryptProv,
    IN HCRYPTKEY                    hEncryptKey,
    IN PCERT_PUBLIC_KEY_INFO        pPublicKeyInfo,
    OUT PBYTE                       pbData,
    IN OUT DWORD                    rgcbData[2])
{
    BOOL            fRet;
    DWORD           dwError = ERROR_SUCCESS;
    HCRYPTKEY       hPubKey = NULL;
    PBYTE           pb = NULL;
    DWORD           cb;

    if (!CryptImportPublicKeyInfo(
            hCryptProv,
            X509_ASN_ENCODING,
            pPublicKeyInfo,
            &hPubKey))
        goto ImportKeyError;
    if (!CryptExportKey(
            hEncryptKey,
            hPubKey,
            SIMPLEBLOB,
            0,                  // dwFlags
            NULL,
            &cb))
        goto ExportKeySizeError;
    if (NULL == (pb = (PBYTE)ICM_AllocA( cb)))
        goto ExportKeyAllocError;
    if (!CryptExportKey(
            hEncryptKey,
            hPubKey,
            SIMPLEBLOB,
            0,                  // dwFlags
            pb,
            &cb))
        goto ExportKeyError;
    assert( cb > (sizeof(PUBLICKEYSTRUC) + sizeof(SIMPLEBLOBHEADER)));
    cb -= sizeof(PUBLICKEYSTRUC) + sizeof(SIMPLEBLOBHEADER);

    fRet = TRUE;
    if (pbData) {
        if (rgcbData[0] < cb) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fRet = FALSE;
        } else if (0 < cb) {
            if (rgcbData[1] & CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG)
                // Don't byte reverse
                memcpy(pbData,
                    pb + (sizeof(PUBLICKEYSTRUC) + sizeof(SIMPLEBLOBHEADER)),
                    cb);
            else
                ICM_ReverseCopy(pbData,
                    pb + (sizeof(PUBLICKEYSTRUC) + sizeof(SIMPLEBLOBHEADER)),
                    cb);
        }
    }

CommonReturn:
    rgcbData[0] = cb;
    ICM_FreeA(pb);
    if (hPubKey)
        CryptDestroyKey(hPubKey);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    cb = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(ImportKeyError)
TRACE_ERROR(ExportKeySizeError)
TRACE_ERROR(ExportKeyAllocError)
TRACE_ERROR(ExportKeyError)
}

//+-------------------------------------------------------------------------
//  Export of the encryption key
//
//  rgcbData[1] is the dwEncryptFlags passed from ICM_GenEncryptKey
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ExportEncryptKey(
    IN HCRYPTPROV                   hCryptProv,
    IN HCRYPTKEY                    hEncryptKey,
    IN PCERT_PUBLIC_KEY_INFO        pPublicKeyInfo,
    OUT PBYTE                       pbData,
    IN OUT DWORD                    rgcbData[2])
{
    BOOL fResult;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr;

    if (CryptGetOIDFunctionAddress(
            hExportEncryptKeyFuncSet,
            X509_ASN_ENCODING,
            pPublicKeyInfo->Algorithm.pszObjId,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr)) {
        fResult = ((PFN_CMSG_EXPORT_ENCRYPT_KEY) pvFuncAddr)(
            hCryptProv,
            hEncryptKey,
            pPublicKeyInfo,
            pbData,
            rgcbData);
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    } else
        fResult = ICM_DefaultExportEncryptKey(
            hCryptProv,
            hEncryptKey,
            pPublicKeyInfo,
            pbData,
            rgcbData);
    return fResult;
}

// This size is good up through a 2048 bit exchange key
#define EXPORT_ENCRYPT_KEY_LENGTH   256

//+-------------------------------------------------------------------------
//  Fill the RecipientInfos
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_FillRecipientInfos(
    IN HCRYPTPROV           hCryptProv,
    IN HCRYPTKEY            hKeyContent,
    IN DWORD                cRecipients,
    IN PCERT_INFO           *rgpRecipients,
    IN OUT RecipientInfos   *pris,
    IN DWORD                dwEncryptFlags)
{
    BOOL            fRet;
    PCERT_INFO      *ppci;
    RecipientInfo   *pri;
    PBYTE           pb = NULL;
    DWORD           rgcb[2];        // rgcb[1] is updated with dwEncryptFlags
    DWORD           cTryAgain;
    DWORD           i;
    PBYTE           pbSerialNumber;
    DWORD           cbSerialNumber = 0;

    for (i=cRecipients, ppci=rgpRecipients; i>0; i--, ppci++)
        cbSerialNumber += (*ppci)->SerialNumber.cbData;
    pris->value = (RecipientInfo *)ICM_AllocZero(
                cRecipients * sizeof( RecipientInfo) +
                cbSerialNumber);
    if (NULL == pris->value)
        goto RecipientInfoAllocError;
    pris->count = cRecipients;
    pbSerialNumber = (PBYTE)(pris->value + cRecipients);

    for (i=cRecipients, ppci=rgpRecipients, pri=pris->value;
            i>0;
            i--, ppci++, pri++) {
        // version
        pri->version = 0;

        // issuerAndSerialNumber
        pri->issuerAndSerialNumber.issuer.length = (*ppci)->Issuer.cbData;
        pri->issuerAndSerialNumber.issuer.value = (*ppci)->Issuer.pbData;
        pri->issuerAndSerialNumber.serialNumber.length = (*ppci)->SerialNumber.cbData;
        pb = pbSerialNumber;
        pbSerialNumber += (*ppci)->SerialNumber.cbData;
        ICM_ReverseCopy(
            pb,
            (*ppci)->SerialNumber.pbData,
            (*ppci)->SerialNumber.cbData);
        pri->issuerAndSerialNumber.serialNumber.value = pb;

        // keyEncryptionAlgorithm
        if (!ICM_Asn1ToAlgorithmIdentifier(
                &(*ppci)->SubjectPublicKeyInfo.Algorithm,
                &pri->keyEncryptionAlgorithm))
            goto Asn1ToAlgorithmIdentifierError;

        rgcb[0] = EXPORT_ENCRYPT_KEY_LENGTH;
        rgcb[1] = dwEncryptFlags;
        cTryAgain = 1;
        while (TRUE) {
            if (NULL == (pb = (PBYTE)ICM_Alloc(rgcb[0])))
                goto ExportKeyAllocError;
            if (ICM_ExportEncryptKey(
                    hCryptProv,
                    hKeyContent,
                    &(*ppci)->SubjectPublicKeyInfo,
                    pb,
                    rgcb))
                break;
            ICM_Free(pb);
            if (rgcb[0] && cTryAgain--)
                continue;
            else
                goto ExportKeyError;
        }

        pri->encryptedKey.length = rgcb[0];
        pri->encryptedKey.value = pb;
        pb = NULL;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
// Need to free EncrytedKey for each recipient
    ICM_Free( pris->value);

    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(RecipientInfoAllocError)
TRACE_ERROR(Asn1ToAlgorithmIdentifierError)
TRACE_ERROR(ExportKeyAllocError)
TRACE_ERROR(ExportKeyError)
}


//+-------------------------------------------------------------------------
//  Open an enveloped message for encoding
//--------------------------------------------------------------------------
HCRYPTMSG
WINAPI
ICM_OpenToEncodeEnvelopedData(
    IN DWORD dwEncodingType,
    IN DWORD dwFlags,
    IN void const *pvMsgEncodeInfo,
    IN OPTIONAL LPSTR pszInnerContentObjID,
    IN OPTIONAL PCMSG_STREAM_INFO pStreamInfo)
{
    DWORD                       dwError = ERROR_SUCCESS;
    PCRYPT_MSG_INFO             pcmi = NULL;
    PCMSG_ENVELOPED_ENCODE_INFO pemei = (PCMSG_ENVELOPED_ENCODE_INFO)pvMsgEncodeInfo;
    EnvelopedData               *ped = NULL;
    EncryptedContentInfo        *peci;
    DWORD                       dwAlgoCAPI;
    CRYPT_ALGORITHM_IDENTIFIER  ContentEncryptionAlgorithm;
    PBYTE                       pbEncryptParameters = NULL;

    // rgcbEncryptParameters[1] contains dwEncryptFlags
    DWORD                       rgcbEncryptParameters[2];

    assert( pemei->cbSize >= sizeof(CMSG_ENVELOPED_ENCODE_INFO));
    assert( 0 != pemei->cRecipients);
    if (pemei->cbSize < sizeof(CMSG_ENVELOPED_ENCODE_INFO) ||
            0 == pemei->cRecipients)
        goto InvalidArg;

    ped = (EnvelopedData *)ICM_AllocZero( sizeof( EnvelopedData));
    if (NULL == ped)
        goto EnvelopedDataAllocError;

    // pcmi
    pcmi = (PCRYPT_MSG_INFO)ICM_AllocZero( sizeof( CRYPT_MSG_INFO));
    if (NULL == pcmi)
        goto PcmiAllocError;

    pcmi->hCryptProv = pemei->hCryptProv;
    if (0 == pcmi->hCryptProv)
        pcmi->fDefaultCryptProv = TRUE;
    pcmi->dwEncodingType = dwEncodingType;
    pcmi->dwMsgType = CMSG_ENVELOPED;
    pcmi->dwFlags = dwFlags;
    pcmi->pvMsg = ped;
    pcmi->fEncoding = TRUE;
    pcmi->dwPhase = PHASE_FIRST_ONGOING;
    if (pszInnerContentObjID &&
            (NULL == (pcmi->pszInnerContentObjID = (LPSTR)ICM_DupMem(
                                    pszInnerContentObjID,
                                    ICM_StrLen(pszInnerContentObjID) + 1))))
        goto DupInnerContentObjIDError;
    if (pStreamInfo &&
            (NULL == (pcmi->pStreamInfo = (PCMSG_STREAM_INFO)ICM_DupMem(
                                    pStreamInfo,
                                    sizeof(*pStreamInfo)))))
        goto DupStreamInfoError;

    // version
    ped->version = 0;

    // recipientInfos
    // Use first recipients public key info
    ContentEncryptionAlgorithm = pemei->ContentEncryptionAlgorithm;
    rgcbEncryptParameters[0] = 0;
    rgcbEncryptParameters[1] = 0;
    if (!ICM_GenEncryptKey(
            &pcmi->hCryptProv,
            &ContentEncryptionAlgorithm,
            pemei->pvEncryptionAuxInfo,
            &pemei->rgpRecipients[0]->SubjectPublicKeyInfo,
            ICM_Alloc,
            &pcmi->hkeyContentCrypt,    // not freed for an error
            &pbEncryptParameters,
            rgcbEncryptParameters))
        goto GenKeyError;
    if (rgcbEncryptParameters[0] && pbEncryptParameters) {
        pcmi->pbEncryptParameters = pbEncryptParameters;
        ContentEncryptionAlgorithm.Parameters.pbData = pbEncryptParameters;
        ContentEncryptionAlgorithm.Parameters.cbData = rgcbEncryptParameters[0];
    } else if (pbEncryptParameters) {
        ICM_Free(pbEncryptParameters);
        pbEncryptParameters = NULL;
    }

    if (!ICM_FillRecipientInfos(
                pcmi->hCryptProv,
                pcmi->hkeyContentCrypt,
                pemei->cRecipients,
                pemei->rgpRecipients,
                &ped->recipientInfos,
                rgcbEncryptParameters[1]))      // dwEncryptFlags
        goto FillRecipientInfosError;

    // encryptedContentInfo
    // (.encryptedContent filled in during update)
    peci = &ped->encryptedContentInfo;
    peci->bit_mask = encryptedContent_present;
    peci->contentType.count = sizeof(peci->contentType.value)/sizeof(peci->contentType.value[0]);
    if (!PkiAsn1ToObjectIdentifier(
            pszInnerContentObjID ? pszInnerContentObjID : pszObjIdDataType,
            &peci->contentType.count,
            peci->contentType.value))
        goto PkiAsn1ToObjectIdentifierError;

    if (!ICM_Asn1ToAlgorithmIdentifier(
            &ContentEncryptionAlgorithm,
            &peci->contentEncryptionAlgorithm))
        goto Asn1ToAlgorithmIdentifierError;

    if (pStreamInfo && !ICMS_OpenToEncodeEnvelopedData( pcmi, pemei))
        goto StreamOpenToEncodeEnvelopedDataError;

CommonReturn:
    ICM_SetLastError(dwError);
    return (HCRYPTMSG)pcmi;

ErrorReturn:
    dwError = GetLastError();
    ICM_Free( pbEncryptParameters);
    ICM_Free( ped);
    ICM_Free( pcmi);
    pcmi = NULL;
    goto CommonReturn;
SET_ERROR(PkiAsn1ToObjectIdentifierError,CRYPT_E_OID_FORMAT)
SET_ERROR(InvalidArg,E_INVALIDARG)
TRACE_ERROR(DupInnerContentObjIDError)              // error already set
TRACE_ERROR(DupStreamInfoError)                     // error already set
TRACE_ERROR(EnvelopedDataAllocError)                // error already set
TRACE_ERROR(PcmiAllocError)                         // error already set
TRACE_ERROR(GenKeyError)                            // error already set
TRACE_ERROR(FillRecipientInfosError)                // error already set
TRACE_ERROR(Asn1ToAlgorithmIdentifierError)      // error already set
TRACE_ERROR(StreamOpenToEncodeEnvelopedDataError)   // error already set
}

#endif  // CMS_PKCS7


//+-------------------------------------------------------------------------
//  Open a signed and enveloped message for encoding
//--------------------------------------------------------------------------
#if 0
HCRYPTMSG
WINAPI
ICM_OpenToEncodeSignedAndEnvelopedData(
    IN DWORD dwEncodingType,
    IN DWORD dwFlags,
    IN void *pvMsgEncodeInfo,
    IN OPTIONAL LPSTR pszInnerContentObjID,
    IN OPTIONAL PCMSG_STREAM_INFO pStreamInfo)
{
    DWORD                       dwError = ERROR_SUCCESS;
    HCRYPTPROV                  hCryptProv;
    DWORD                       dwKeySpec;
    PCRYPT_MSG_INFO             pcmi = NULL;
    PCMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO  psemei;
    SignedAndEnvelopedData      *psed = NULL;
    ContentEncryptionAlgorithmIdentifier *pceai;
    DWORD                       dwVersion = 1;
    HCRYPTKEY                   hkeyContentEncryption;
    PCERT_BLOB                  pcert;
    PCRL_BLOB                   pcrl;
    DWORD                       i;
    CRYPT_ALGORITHM_IDENTIFIER        aiDigest;
    DWORD                       dwAlgoCAPISign;
    DWORD                       dwAlgoCAPIEncrypt;

    psemei = (PCMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO)pvMsgEncodeInfo;
    psed = new SignedAndEnvelopedData;

    assert( 1 == psemei->SignedInfo.cSigners);       // just for now
    assert( psemei->cbSize >= sizeof(CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO));
    if (psemei->cbSize < sizeof(CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO))
        goto InvalidArg;

    // version
    psed->version.Write( &dwVersion);

    // recipientInfos
    if (!ICM_GetCAPI(
            CRYPT_ENCRYPT_ALG_OID_GROUP_ID,
            &psemei->ContentEncryptionAlgorithm,
            &dwAlgoCAPIEncrypt))
        goto GetCAPIEncryptError;
    if (!CryptGenKey(
                psemei->EnvelopedInfo.hCryptProv,
                dwAlgoCAPIEncrypt,
                CRYPT_EXPORTABLE,       // dwFlags
                &hkeyContentEncryption))
        goto GenKeyError;
    if (!ICM_FillRecipientInfos(
                psemei->EnvelopedInfo.hCryptProv,
                hkeyContentEncryption,
                psemei->EnvelopedInfo.cRecipients,
                psemei->EnvelopedInfo.rgpRecipients,
                psed->recipientInfos,
                dwEncryptFlags))
        goto FillRecipientInfosError;

    // digestAlgorithms
    if (!ICM_SetAsnDigestAlgorithmIdentifiers(
                psed->digestAlgorithms,
                &aiDigest,
                psemei->SignedInfo.cSigners,
                psemei->SignedInfo.rgSigners,
                &hCryptProv,
                &dwKeySpec))
        goto SetAsnDigestAlgorithmIdentifiersError;

    // encryptedContentInfo.contentEncryptionAlgorithm
    // (.encryptedContent and .encryptedContent filled in during update)
    pceai = &psed->encryptedContentInfo.contentEncryptionAlgorithm;
    pceai->algorithm = psemei->EnvelopedInfo.ContentEncryptionAlgorithm.pszObjId;
    if (0 != psemei->EnvelopedInfo.ContentEncryptionAlgorithm.Parameters.cbData) {
        if (0 > pceai->parameters.Decode(
                psemei->EnvelopedInfo.ContentEncryptionAlgorithm.Parameters.pbData))
            goto ContentEncryptionAlgorithmParametersDecodeError;
    }

    // certificates
    for (i=psemei->SignedInfo.cCertEncoded, pcert=psemei->SignedInfo.rgCertEncoded;
            i>0;
            i--, pcert++) {
        if (0 > psed->certificates[ psed->certificates.Add()].Decode( pcert->pbData))
            goto BadParameter;
    }

    // crls
    for (i=psemei->SignedInfo.cCrlEncoded, pcrl=psemei->SignedInfo.rgCrlEncoded;
            i>0;
            i--, pcrl++) {
        if (0 > psed->crls[ psed->crls.Add()].Decode( pcrl->pbData))
            goto BadParameter;
    }

    // signerInfos
    if (!ICM_SetAsnSignerInfos(
            psed->signerInfos,
            dwFlags,
            psemei->SignedInfo.cSigners,
            psemei->SignedInfo.rgSigners))
        goto SetAsnSignerInfosError;

    // pcmi
    pcmi = (PCRYPT_MSG_INFO)ICM_AllocZero( sizeof( CRYPT_MSG_INFO));
    if (NULL == pcmi)
        goto OutOfMemory;

    pcmi->hCryptProv = hCryptProv;
    if (0 == hCryptProv)
        pcmi->fDefaultCryptProv = TRUE;
    pcmi->dwKeySpec = dwKeySpec;
    pcmi->dwEncodingType = dwEncodingType;
    pcmi->dwMsgType = CMSG_SIGNED_AND_ENVELOPED;
    pcmi->dwFlags = dwFlags;
    pcmi->pvMsg = psed;
    pcmi->fEncoding = TRUE;
    pcmi->dwPhase = PHASE_FIRST_ONGOING;
    pcmi->pszInnerContentObjID = ICM_DupMem(
                                    pszInnerContentObjID,
                                    ICM_StrLen(pszInnerContentObjID) + 1);
    pcmi->pStreamInfo = ICM_DupMem( pStreamInfo, sizeof(*pStreamInfo));
//    pcmi->cDigestAlgorithms = 1;                        // temp
    if (!(ICM_GetCAPI(
            CRYPT_HASH_ALG_OID_GROUP_ID,
            &aiDigest,
            &dwAlgoCAPISign) ||
          ICM_GetCAPI(
            CRYPT_SIGN_ALG_OID_GROUP_ID,
            &aiDigest,
            &dwAlgoCAPISign)))
        goto GetCAPISignError;
    pcmi->adwDigestAlgorithms[0] = dwAlgoCAPISign;
    pcmi->hkeyContentCrypt = hkeyContentEncryption;
    if (!CryptCreateHash(
                    hCryptProv,         // s/b various per array
                    dwAlgoCAPISign,     // s/b various per array
                    NULL,               // hKey - optional for MAC
                    0,                  // dwFlags
                    &pcmi->ahHash[0]))
        goto CreateHashError;

CommonReturn:
    ICM_SetLastError(dwError);
    return (HCRYPTMSG)pcmi;

ErrorReturn:
    dwError = GetLastError();
    if (psed)
        delete psed;
    ICM_Free( pcmi);
    pcmi = NULL;
    goto CommonReturn;
SET_ERROR(InvalidArg,E_INVALIDARG)
TRACE_ERROR(FillRecipientInfosError)                // error already set
TRACE_ERROR(SetAsnDigestAlgorithmIdentifiersError)  // error already set
TRACE_ERROR(OutOfMemory)                            // error already set
SET_ERROR(GetCAPIEncryptError,CRYPT_E_UNKNOWN_ALGO)
TRACE_ERROR(GenKeyError)                            // error already set
TRACE_ERROR(BadParameter)
TRACE_ERROR(ContentEncryptionAlgorithmParametersDecodeError)
TRACE_ERROR(SetAsnSignerInfosError)
TRACE_ERROR(GetCAPISignError)
TRACE_ERROR(CreateHashError)
}
#endif


//+-------------------------------------------------------------------------
//  Open a cryptographic message for encoding
//
//  If CMSG_BARE_CONTENT_FLAG is specified for a streamed message,
//  the streamed output will not have an outer ContentInfo wrapper. This
//  makes it suitable to be streamed into an enclosing message.
//
//  The pStreamInfo parameter needs to be set to stream the encoded message
//  output.
//--------------------------------------------------------------------------
HCRYPTMSG
WINAPI
#ifdef DEBUG_CRYPT_ASN1_MASTER
ICMTest_NewCryptMsgOpenToEncode(
#else
CryptMsgOpenToEncode(
#endif
    IN DWORD dwEncodingType,
    IN DWORD dwFlags,
    IN DWORD dwMsgType,
    IN void const *pvMsgEncodeInfo,
    IN OPTIONAL LPSTR pszInnerContentObjID,
    IN OPTIONAL PCMSG_STREAM_INFO pStreamInfo)
{
    HCRYPTMSG   hcrmsg = NULL;

    if (GET_CMSG_ENCODING_TYPE(dwEncodingType) != PKCS_7_ASN_ENCODING)
        goto InvalidEncoding;

    switch (dwMsgType) {
    case CMSG_DATA:
        hcrmsg = ICM_OpenToEncodeData(
                            dwEncodingType,
                            dwFlags,
                            pvMsgEncodeInfo,
                            pStreamInfo);
        break;

    case CMSG_SIGNED:
        hcrmsg = ICM_OpenToEncodeSignedData(
                            dwEncodingType,
                            dwFlags,
                            pvMsgEncodeInfo,
                            pszInnerContentObjID,
                            pStreamInfo);
        break;

    case CMSG_ENVELOPED:
        hcrmsg = ICM_OpenToEncodeEnvelopedData(
                            dwEncodingType,
                            dwFlags,
                            pvMsgEncodeInfo,
                            pszInnerContentObjID,
                            pStreamInfo);
        break;

    case CMSG_SIGNED_AND_ENVELOPED:
#if 0
        hcrmsg = ICM_OpenToEncodeSignedAndEnvelopedData(
                            dwEncodingType,
                            dwFlags,
                            pvMsgEncodeInfo,
                            pszInnerContentObjID,
                            pStreamInfo);
        break;
#endif
        goto MessageTypeNotSupportedYet;

    case CMSG_HASHED:
        hcrmsg = ICM_OpenToEncodeDigestedData(
                            dwEncodingType,
                            dwFlags,
                            pvMsgEncodeInfo,
                            pszInnerContentObjID,
                            pStreamInfo);
        break;

    case CMSG_ENCRYPTED:
        goto MessageTypeNotSupportedYet;

    default:
        goto InvalidMsgType;
    }

CommonReturn:
    if (hcrmsg) {
        PCRYPT_MSG_INFO pcmi = (PCRYPT_MSG_INFO) hcrmsg;
        pcmi->lRefCnt = 1;
#ifdef _XBOX        
        InitializeCriticalSection(&pcmi->CriticalSection);
#else
        if (!Pki_InitializeCriticalSection( &pcmi->CriticalSection)) {
            CryptMsgClose(hcrmsg);
            hcrmsg = NULL;
        }
#endif
    }
    return hcrmsg;

ErrorReturn:
    hcrmsg = NULL;
    goto CommonReturn;
SET_ERROR(InvalidEncoding,E_INVALIDARG)
SET_ERROR(MessageTypeNotSupportedYet,CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(InvalidMsgType,CRYPT_E_INVALID_MSG_TYPE)
}


//+-------------------------------------------------------------------------
//  Open a cryptographic message for decoding
//
//  hCryptProv specifies the crypto provider to use for hashing and/or
//  decrypting the message. If hCryptProv is NULL, a default crypt provider
//  is used.
//
//  Currently pRecipientInfo isn't used and should be set to NULL.
//
//  The pStreamInfo parameter needs to be set to stream the decoded content
//  output.
//--------------------------------------------------------------------------
HCRYPTMSG
WINAPI
#ifdef DEBUG_CRYPT_ASN1_MASTER
ICMTest_NewCryptMsgOpenToDecode(
#else
CryptMsgOpenToDecode(
#endif
    IN DWORD dwEncodingType,
    IN DWORD dwFlags,
    IN DWORD dwMsgType,
    IN HCRYPTPROV hCryptProv,
    IN PCERT_INFO pRecipientInfo,
    IN OPTIONAL PCMSG_STREAM_INFO pStreamInfo)
{
    DWORD                   dwError = ERROR_SUCCESS;
    HCRYPTMSG               hcrmsg;
    PCRYPT_MSG_INFO         pcmi = NULL;

    if (GET_CMSG_ENCODING_TYPE(dwEncodingType) != PKCS_7_ASN_ENCODING)
        goto InvalidEncodingTypeError;

    if (NULL != pRecipientInfo)
        goto RecipientInfoNotSupportedYet;

    if (NULL == (pcmi = (PCRYPT_MSG_INFO)ICM_AllocZero( sizeof( CRYPT_MSG_INFO))))
        goto AllocCmsgError;

    if (0 == hCryptProv) {
        pcmi->fDefaultCryptProv = TRUE;
        pcmi->hCryptProv = I_CryptGetDefaultCryptProv(0);
        if (0 == pcmi->hCryptProv)
            goto GetDefaultCryptProvError;
    } else
        pcmi->hCryptProv        = hCryptProv;

    pcmi->dwEncodingType    = dwEncodingType;
    pcmi->dwMsgType         = dwMsgType;
    pcmi->dwFlags           = dwFlags;
    pcmi->dwPhase           = PHASE_FIRST_ONGOING;
    if (pStreamInfo &&
            (NULL == (pcmi->pStreamInfo = (PCMSG_STREAM_INFO)ICM_DupMem(
                                            pStreamInfo,
                                            sizeof(*pStreamInfo)))))
        goto DupStreamInfoError;

#ifdef _XBOX        
    InitializeCriticalSection(&pcmi->CriticalSection);
#else
    if (!Pki_InitializeCriticalSection( &pcmi->CriticalSection))
        goto InitializeCriticalSectionError;
#endif
    pcmi->lRefCnt = 1;
    hcrmsg = (HCRYPTMSG)pcmi;

CommonReturn:
    ICM_SetLastError(dwError);
    return hcrmsg;

ErrorReturn:
    dwError = GetLastError();
    ICM_Free( pcmi);
    hcrmsg = NULL;
    goto CommonReturn;
SET_ERROR(InvalidEncodingTypeError,E_INVALIDARG)
SET_ERROR(RecipientInfoNotSupportedYet,E_INVALIDARG)
TRACE_ERROR(AllocCmsgError)                         // error already set
TRACE_ERROR(GetDefaultCryptProvError)               // error already set
TRACE_ERROR(DupStreamInfoError)                     // error already set
#ifndef _XBOX
TRACE_ERROR(InitializeCriticalSectionError)         // error already set
#endif
}

//+-------------------------------------------------------------------------
//  Duplicate a cryptographic message handle
//--------------------------------------------------------------------------
HCRYPTMSG
WINAPI
#ifdef DEBUG_CRYPT_ASN1_MASTER
ICMTest_NewCryptMsgDuplicate(
#else
CryptMsgDuplicate(
#endif
    IN HCRYPTMSG hCryptMsg
    )
{
    PCRYPT_MSG_INFO     pcmi = (PCRYPT_MSG_INFO)hCryptMsg;
    if (pcmi)
        InterlockedIncrement(&pcmi->lRefCnt);
    return hCryptMsg;
}


//+-------------------------------------------------------------------------
//  Close a cryptographic message handle
//
//  NB- Must preserve LastError.
//--------------------------------------------------------------------------
BOOL
WINAPI
#ifdef DEBUG_CRYPT_ASN1_MASTER
ICMTest_NewCryptMsgClose(
#else
CryptMsgClose(
#endif
    IN HCRYPTMSG hCryptMsg)
{
    DWORD               dwError;
    BOOL                fRet;
    PCRYPT_MSG_INFO     pcmi = (PCRYPT_MSG_INFO)hCryptMsg;
    PCMSG_STREAM_INFO   pcsi;

    if (NULL == hCryptMsg)
        return TRUE;
    if (0 != InterlockedDecrement(&pcmi->lRefCnt))
        return TRUE;

    // Preserve LastError
    dwError = GetLastError();

    pcsi = pcmi->pStreamInfo;

    switch (pcmi->dwMsgType) {
    case CMSG_DATA:
    {
        OctetStringType *poos = (OctetStringType *)pcmi->pvMsg;

        if (!poos)
            break;
        if (pcmi->fEncoding) {
            ICM_Free( poos->value);
            ICM_Free( poos);
        } else {
            PkiAsn1FreeInfo( ICM_GetDecoder(), OctetStringType_PDU, poos);
        }
        break;
    }
    case CMSG_SIGNED:
    {
        SignedData  *psd = (SignedData *)pcmi->pvMsg;

        if (!(psd || pcmi->psdi))
            break;
        if (pcmi->fEncoding) {
            if (psd->signerInfos.value) {
                SignerInfo  *psi;
                DWORD       i;

                for (i=psd->signerInfos.count, psi=psd->signerInfos.value;
                        i>0;
                        i--, psi++)
                    ICM_FreeAsnSignerInfo(psi);
                ICM_Free( psd->signerInfos.value);
            }

            if (ICM_IsAddInnerContentOctetWrapper(pcmi) &&
                    psd->contentInfo.content.length &&
                    psd->contentInfo.content.value)
                PkiAsn1FreeEncoded( ICM_GetEncoder(),
                    psd->contentInfo.content.value);
            if (psd->digestAlgorithms.count && psd->digestAlgorithms.value)
                ICM_Free( psd->digestAlgorithms.value);
            ICM_Free( psd);
            ICM_Free( pcmi->pszInnerContentObjID);

        } else {
            // decoding
            delete pcmi->psdi->pAlgidList;
            delete pcmi->psdi->pCertificateList;
            delete pcmi->psdi->pCrlList;
            delete pcmi->psdi->pSignerList;
            ICM_Free( pcmi->psdi->pci);
            ICM_Free( pcmi->psdi);
        }
        if (pcmi->pHashList)
            delete pcmi->pHashList;
#ifdef CMS_PKCS7
        if (pcmi->rgSignerEncodeDataInfo) {
            assert(pcmi->cSignerEncodeDataInfo);
            if (pcmi->dwFlags & CMSG_CRYPT_RELEASE_CONTEXT_FLAG) {
                DWORD       i;

                for (i = 0; i < pcmi->cSignerEncodeDataInfo; i++) {
                    if (pcmi->rgSignerEncodeDataInfo[i].hCryptProv)
                        CryptReleaseContext(
                            pcmi->rgSignerEncodeDataInfo[i].hCryptProv, 0);
                }
            }
            ICM_Free(pcmi->rgSignerEncodeDataInfo);
        }
#endif  // CMS_PKCS7
        break;
    }

    case CMSG_ENVELOPED:
    {
#ifdef CMS_PKCS7
        CmsEnvelopedData   *ped = (CmsEnvelopedData *)pcmi->pvMsg;
#else
        EnvelopedData   *ped = (EnvelopedData *)pcmi->pvMsg;
        RecipientInfo   *pri;
#endif  // CMS_PKCS7
        DWORD           i;

        if (pcmi->hkeyContentCrypt)
            CryptDestroyKey( pcmi->hkeyContentCrypt);
        ICM_Free( pcmi->Plaintext.pbData);
#ifndef CMS_PKCS7
        ICM_Free( pcmi->pbEncryptParameters);
#endif  // CMS_PKCS7
        if (pcmi->fEncoding) {
#ifdef CMS_PKCS7
            ICM_FreeOssCmsRecipientInfos(&ped->recipientInfos);

            if (ped->unprotectedAttrs.value) {
                Attribute *poatr;

                for (i=ped->unprotectedAttrs.count,
                        poatr=ped->unprotectedAttrs.value;
                        i>0;
                        i--, poatr++) {
                    ICM_Free(poatr->attributeValue.value);
                }
                ICM_Free(ped->unprotectedAttrs.value);
            }
    
#else
            for (i=ped->recipientInfos.count, pri=ped->recipientInfos.value;
                    i>0;
                    i--, pri++)
                ICM_Free( pri->encryptedKey.value);
            ICM_Free( ped->recipientInfos.value);
#endif  // CMS_PKCS7
            ICM_Free( ped->encryptedContentInfo.encryptedContent.value);
            ICM_Free( ped);
            ICM_Free( pcmi->pszInnerContentObjID);
        } else {
            // decoding
#ifdef CMS_PKCS7
            if (NULL != pcmi->pCertificateList)
                delete pcmi->pCertificateList;
            if (NULL != pcmi->pCrlList)
                delete pcmi->pCrlList;
#endif  // CMS_PKCS7
            if (pcsi) {
                ICM_Free( ped);
            } else {
#ifdef CMS_PKCS7
                PkiAsn1FreeInfo( ICM_GetDecoder(), CmsEnvelopedData_PDU, ped);
#else
                PkiAsn1FreeInfo( ICM_GetDecoder(), EnvelopedData_PDU, ped);
#endif  // CMS_PKCS7
            }
        }
        break;
    }

    case CMSG_HASHED:
    {
        DigestedData  *pdd = (DigestedData *)pcmi->pvMsg;
        if (pcmi->fEncoding) {
            if (ICM_IsAddInnerContentOctetWrapper(pcmi) &&
                    pdd->contentInfo.content.length &&
                    pdd->contentInfo.content.value)
                PkiAsn1FreeEncoded( ICM_GetEncoder(),
                    pdd->contentInfo.content.value);
            ICM_Free ((DigestedData *)pcmi->pvMsg);
            ICM_Free( pcmi->pszInnerContentObjID);
        } else {
            // decoding
            PkiAsn1FreeInfo( ICM_GetDecoder(), DigestedData_PDU,
                (DigestedData *)pcmi->pvMsg);
        }
        if (pcmi->pHashList)
            delete pcmi->pHashList;
        break;
    }

    case CMSG_SIGNED_AND_ENVELOPED:
    case CMSG_ENCRYPTED:
        goto MessageTypeNotSupportedYet;

    default:
        goto InvalidMsgType;
    }

    fRet = TRUE;
CommonReturn:
#ifdef CMS_PKCS7
    if (pcmi->pFreeList)
        delete pcmi->pFreeList;
#endif  // CMS_PKCS7
    if (pcmi->plDecodeInfo)
        delete pcmi->plDecodeInfo;
    ICM_Free( pcmi->pStreamInfo);
    ICM_Free( pcmi->bufOutput.pbData);
    ICM_Free( pcmi->bufCrypt.pbData);
    ICM_Free( pcmi->bufPendingCrypt.pbData);
    ICM_Free( pcmi->bufDecode.pbData);
    ICM_Free( pcmi->bufEncode.pbData);

    if (pcmi->pooid)
        PkiAsn1FreeDecoded(ICM_GetDecoder(), pcmi->pooid,
            ObjectIdentifierType_PDU);

    if ((pcmi->dwFlags & CMSG_CRYPT_RELEASE_CONTEXT_FLAG) &&
            !pcmi->fDefaultCryptProv && pcmi->hCryptProv)
        CryptReleaseContext(pcmi->hCryptProv, 0);
    if (pcmi->hCryptProvContentCrypt)
        CryptReleaseContext(pcmi->hCryptProvContentCrypt, 0);
    DeleteCriticalSection( &pcmi->CriticalSection);

    ICM_Free( hCryptMsg);
    SetLastError(dwError);              // Preserve LastError
    return fRet;

ErrorReturn:
    fRet = TRUE;
    goto CommonReturn;
SET_ERROR(MessageTypeNotSupportedYet,CRYPT_E_INVALID_MSG_TYPE)
TRACE_ERROR(InvalidMsgType)
}


//+-------------------------------------------------------------------------
// Since the encoding might be indefinite-length encoded,
// decode and re-encode as DER.
//
// Returns:    FALSE iff fails
//
// NB: The caller of this routine needs to call
//          PkiAsn1FreeEncoded( ICM_GetEncoder(), pbOut);
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ReEncodeAsOctetDER(
    IN PBYTE    pbIn,
    IN DWORD    cbIn,
    OUT PBYTE   *ppbOut,
    OUT DWORD   *pcbOut)
{
    DWORD       dwError = ERROR_SUCCESS;
    BOOL        fRet;
    ASN1error_e Asn1Err;
    ASN1decoding_t pDec = ICM_GetDecoder();
    PVOID       pvMsg = NULL;

    DWORD dwExceptionCode;

  // Handle MappedFile Exceptions
  __try {

    if (0 != (Asn1Err = PkiAsn1Decode(pDec, (void **)&pvMsg,
            OctetStringType_PDU, pbIn, cbIn)))
        goto DecodeInnerContentError;
    if (0 != (Asn1Err = PkiAsn1Encode(ICM_GetEncoder(), pvMsg,
             OctetStringType_PDU, ppbOut, pcbOut)))
        goto EncodeInnerContentError;
    fRet = TRUE;

  } __except(EXCEPTION_EXECUTE_HANDLER) {
    dwExceptionCode = GetExceptionCode();
    goto ExceptionError;
  }

CommonReturn:
    PkiAsn1FreeInfo(pDec, OctetStringType_PDU, pvMsg);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    *ppbOut = NULL;
    *pcbOut = 0;
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(DecodeInnerContentError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR_VAR(EncodeInnerContentError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR_VAR(ExceptionError, dwExceptionCode)
}


//+-------------------------------------------------------------------------
//  Update the digest
//
//  Returns:
//          FALSE iff error
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_UpdateDigest(
    IN HCRYPTHASH hHash,
    IN const BYTE *pbData,
    IN DWORD cbData)
{
    BOOL    fRet;

    if (0 != cbData)
        fRet = CryptHashData(
                    hHash,
                    pbData,
                    cbData,
                    0);                     // dwFlags
    else
        fRet = TRUE;

    if (!fRet)
        goto HashDataError;

CommonReturn:
    return fRet;

ErrorReturn:
    goto CommonReturn;
TRACE_ERROR(HashDataError)      // error already set
}


//+-------------------------------------------------------------------------
//  Update the digests in a list
//
//  Returns:
//          FALSE iff error
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_UpdateListDigest(
    IN CHashList    *pHashList,
    IN const BYTE   *pbData,
    IN DWORD        cbData)
{
    BOOL        fRet;
    CHashNode   *pnHash;

    if (pHashList) {
        for (pnHash=pHashList->Head(); pnHash; pnHash=pnHash->Next()) {
            if (!ICM_UpdateDigest( pnHash->Data()->hHash, pbData, cbData))
                goto UpdateDigestError;
        }
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(UpdateDigestError)  // error already set
}


//+-------------------------------------------------------------------------
//  Alloc and sign a hash.
//
//  Returns:    FALSE iff failed
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_AllocAndSignHash(
    IN HCRYPTHASH   hHash,
    IN DWORD        dwKeySpec,
    IN DWORD        dwAlgIdPubKey,
    IN DWORD        dwPubKeyFlags,
    IN BOOL         fMaxLength,
    OUT PBYTE       *ppbSignature,
    OUT DWORD       *pcbSignature)
{
    DWORD   dwError = ERROR_SUCCESS;
    BOOL    fRet;
    PBYTE   pbSignature = NULL;
    DWORD   cbSignature;

    if (dwKeySpec == 0)
        dwKeySpec = AT_SIGNATURE;

    if (CALG_DSS_SIGN == dwAlgIdPubKey &&
            0 == (dwPubKeyFlags & CRYPT_OID_INHIBIT_SIGNATURE_FORMAT_FLAG)) {
        DWORD cbData;
        BYTE rgbDssSignature[CERT_DSS_SIGNATURE_LEN];

        cbData = sizeof(rgbDssSignature);
        if (!CryptSignHash(
                hHash,
                dwKeySpec,
                NULL,               // sDescription
                0,                  // dwFlags
                rgbDssSignature,
                &cbData
                )) goto SignHashError;
        assert(cbData == sizeof(rgbDssSignature));

        if (NULL == (pbSignature = (PBYTE)ICM_Alloc(
                CERT_MAX_ASN_ENCODED_DSS_SIGNATURE_LEN)))
            goto AllocSignatureError;
        // Convert from the CSP signature format to an ASN.1 sequence of
        // two integers
        cbSignature = CERT_MAX_ASN_ENCODED_DSS_SIGNATURE_LEN;
        if (!CryptEncodeObject(
                X509_ASN_ENCODING,
                X509_DSS_SIGNATURE,
                rgbDssSignature,
                pbSignature,
                &cbSignature
                )) goto EncodeDssSignatureError;
        if (fMaxLength) {
            int cbRemain;
            assert(CERT_MAX_ASN_ENCODED_DSS_SIGNATURE_LEN >= cbSignature);
            cbRemain = CERT_MAX_ASN_ENCODED_DSS_SIGNATURE_LEN - cbSignature;
            if (cbRemain > 0) {
                memset(pbSignature + cbSignature, 0, cbRemain);
                cbSignature = CERT_MAX_ASN_ENCODED_DSS_SIGNATURE_LEN;
            }
        }
    } else {
        if (!CryptSignHash(
                hHash,
                dwKeySpec,
                NULL,               // description ?
                0,                  // dwFlags
                NULL,               // pbSignature
                &cbSignature))
            goto SignHashSizeError;
        if (NULL == (pbSignature = (PBYTE)ICM_Alloc( cbSignature)))
            goto AllocSignatureError;
        if (!CryptSignHash(
                hHash,
                dwKeySpec,
                NULL,               // description ?
                0,                  // dwFlags
                pbSignature,
                &cbSignature))
            goto SignHashError;
        ICM_ReverseInPlace( pbSignature, cbSignature);
    }

    fRet = TRUE;
CommonReturn:
    *ppbSignature = pbSignature;
    *pcbSignature = cbSignature;
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    ICM_Free( pbSignature);
    pbSignature = NULL;
    cbSignature = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(SignHashSizeError)      // error already set
TRACE_ERROR(AllocSignatureError)    // error already set
TRACE_ERROR(SignHashError)          // error already set
TRACE_ERROR(EncodeDssSignatureError) // error already set
}


//+-------------------------------------------------------------------------
//  Get the hash of a blob.
//
//  Returns:    FALSE iff failed
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetBlobHash(
    IN HCRYPTPROV       hCryptProv,
    IN DWORD            dwDigestAlgorithm,
    IN PBYTE            pb,
    IN DWORD            cb,
    OUT HCRYPTHASH      *phHash)
{
    BOOL                fRet;
    HCRYPTHASH          hHash;

    if (!CryptCreateHash(
            hCryptProv,
            dwDigestAlgorithm,
            NULL,               // hKey - optional for MAC
            0,                  // dwFlags
            &hHash))
        goto CreateHashError;
    if (!ICM_UpdateDigest( hHash, pb, cb))
        goto UpdateDigestError;

    fRet = TRUE;
CommonReturn:
    *phHash = hHash;
    return fRet;

ErrorReturn:
    hHash = NULL;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(CreateHashError)    // error already set
TRACE_ERROR(UpdateDigestError)  // error already set
}


//+-------------------------------------------------------------------------
//  Get the hash of an OSS Attributes. This is used to hash the authenticated
//  attributes for a Signed or SignedAndEnveloped message.
//
//  Returns:    FALSE iff failed
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetAttrsHash(
    IN DWORD            dwDigestAlgorithm,
    IN HCRYPTPROV       hCryptProv,
    IN Attributes       *possAttrs,
    OUT HCRYPTHASH      *phHash)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    ASN1error_e         Asn1Err;
    ASN1encoding_t      pEnc = ICM_GetEncoder();
    PBYTE               pbEncoded = NULL;
    DWORD               cbEncoded;
    HCRYPTHASH          hHash;

    if (!CryptCreateHash(
            hCryptProv,
            dwDigestAlgorithm,
            NULL,               // hKey - optional for MAC
            0,                  // dwFlags
            &hHash))
        goto CreateHashError;
    if (0 != (Asn1Err = PkiAsn1Encode(
            pEnc,
            possAttrs,
            Attributes_PDU,
            &pbEncoded,
            &cbEncoded)))
        goto EncodeAttributesError;
    if (!ICM_UpdateDigest(
            hHash,
            pbEncoded,
            cbEncoded))
        goto UpdateDigestAttributesError;

    fRet = TRUE;
CommonReturn:
    PkiAsn1FreeEncoded(pEnc, pbEncoded);
    *phHash = hHash;
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    hHash = NULL;
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(EncodeAttributesError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(CreateHashError)                // error already set
TRACE_ERROR(UpdateDigestAttributesError)    // error already set
}


//+-------------------------------------------------------------------------
//  Compare 2 OSS object id's.
//
//  Returns:    FALSE iff !equal
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_EqualObjectIDs(
    IN ObjectID     *poid1,
    IN ObjectID     *poid2)
{
    BOOL        fRet;
    DWORD       i;
    PDWORD      pdw1;
    PDWORD      pdw2;

    if (poid1->count != poid2->count)
        goto Unequal;
    for (i=poid1->count, pdw1=poid1->value, pdw2=poid2->value;
            (i>0) && (*pdw1==*pdw2);
            i--, pdw1++, pdw2++)
        ;
    if (i>0)
        goto Unequal;

    fRet = TRUE;        // equal
CommonReturn:
    return fRet;

Unequal:
    fRet = FALSE;       // !equal
    goto CommonReturn;
}


//+-------------------------------------------------------------------------
//  Get the value of an Attribute of a given type.
//
//  Returns:    FALSE iff fails
//
//  NB- Does not set error
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetAttrValue(
    IN Attributes   *poatrs,
    IN ObjectID     *poid,
    OUT Any         *panyValue)
{
    BOOL        fRet;
    DWORD       i;
    Attribute   *poatr;

    for (i=poatrs->count, poatr=poatrs->value; i>0; i--, poatr++) {
        if (ICM_EqualObjectIDs( &poatr->attributeType, poid))
            break;
    }
    if (0 == i)
        goto AttributeNotFoundError;

    *panyValue = *poatr->attributeValue.value;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    panyValue->length = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(AttributeNotFoundError)
}


//+-------------------------------------------------------------------------
//  Fill in the content-type and message-digest authenticated attributes,
//  which are required in a SignedData or SignedAndEnvelopedData message.
//
//  Returns:    FALSE iff failed
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_FillReqAuthAttrs(
    IN OPTIONAL LPSTR   pszInnerContentObjID,
    IN CHashNode        *pnHash,
    IN OUT Attribute    *possAttr)
{
    BOOL                fRet;
    CRYPT_ATTRIBUTE     atr;
    CRYPT_ATTR_BLOB     atrblob;
    ASN1error_e         Asn1Err;
    ASN1encoding_t      pEnc = ICM_GetEncoder();
    PBYTE               pbEncoded;
    DWORD               cbEncoded;
    ObjectID            ossObjID;
    OctetStringType     ost;

    // NB - When psi->authenticatedAttributes was created,
    //      the first 2 slots were reserved for the
    //      content-type and message-digest attributes.

    // content-type attribute
    ossObjID.count = sizeof(ossObjID.value)/sizeof(ossObjID.value[0]);
    if (!PkiAsn1ToObjectIdentifier(
            pszInnerContentObjID ? pszInnerContentObjID : pszObjIdDataType,
            &ossObjID.count,
            ossObjID.value))
        goto ConvToObjectIdentifierError;
    if (0 != (Asn1Err = PkiAsn1Encode(
            pEnc,
            &ossObjID,
            ObjectIdentifierType_PDU,
            &pbEncoded,
            &cbEncoded)))
        goto EncodeObjectIdentifierError;
    atr.pszObjId = pszObjIdContentType;
    atr.cValue = 1;
    atr.rgValue = &atrblob;
    atrblob.cbData = cbEncoded;
    atrblob.pbData = pbEncoded;
    fRet = ICM_Asn1ToAttribute( &atr, possAttr);
    PkiAsn1FreeEncoded(pEnc, pbEncoded);
    if (!fRet)
        goto ContentTypeAsn1ToAttributeError;

    // message-digest attribute
    if (!ICM_GetListHashValue( pnHash, (DWORD*)&ost.length, &ost.value))
        goto GetHashValueError;
    if (0 != (Asn1Err = PkiAsn1Encode(
            pEnc,
            &ost,
            OctetStringType_PDU,
            &pbEncoded,
            &cbEncoded)))
        goto EncodeOctetStringError;
    atr.pszObjId = pszObjIdMessageDigest;
    atr.cValue = 1;
    atr.rgValue = &atrblob;
    atrblob.cbData = cbEncoded;
    atrblob.pbData = pbEncoded;
    fRet = ICM_Asn1ToAttribute( &atr, possAttr + 1);
    PkiAsn1FreeEncoded(pEnc, pbEncoded);
    if (!fRet)
        goto MsgDigestAsn1ToAttributeError;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(EncodeObjectIdentifierError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR_VAR(EncodeOctetStringError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(ConvToObjectIdentifierError,CRYPT_E_OID_FORMAT)
TRACE_ERROR(ContentTypeAsn1ToAttributeError)     // error already set
TRACE_ERROR(GetHashValueError)                      // error already set
TRACE_ERROR(MsgDigestAsn1ToAttributeError)       // error already set
}


//+-------------------------------------------------------------------------
//  Fill the inner ContentInfo.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_FillInnerContentInfo(
    OUT ContentInfo     *pci,
    IN OPTIONAL LPSTR   pszInnerID,
    IN DWORD            cbData,
    IN const BYTE       *pbData,
    IN BOOL             fAddInnerContentOctetWrapper    // CMS_PKCS7
    )
{
    BOOL                fRet;
    ASN1error_e         Asn1Err;
    PBYTE               pbEncoded;
    DWORD               cbEncoded;
    OctetStringType     ost;

    pci->contentType.count = sizeof(pci->contentType.value)/sizeof(pci->contentType.value[0]);
    if (!PkiAsn1ToObjectIdentifier(
            pszInnerID ? pszInnerID : pszObjIdDataType,
            &pci->contentType.count,
            pci->contentType.value))
        goto PkiAsn1ToObjectIdentifierError;
    if (0 != cbData) {
        pci->bit_mask |= content_present;
        if (!fAddInnerContentOctetWrapper) {
            pci->content.length = cbData;
            pci->content.value  = (PBYTE)pbData;
        } else {
            ost.length = cbData;
            ost.value  = (PBYTE)pbData;
            if (0 != (Asn1Err = PkiAsn1Encode(
                    ICM_GetEncoder(),
                    &ost,
                    OctetStringType_PDU,
                    &pbEncoded,
                    &cbEncoded)))
                goto EncodeOctetStringError;
            pci->content.length = cbEncoded;
            pci->content.value  = pbEncoded;
        }
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(PkiAsn1ToObjectIdentifierError,CRYPT_E_OID_FORMAT)
SET_ERROR_VAR(EncodeOctetStringError, PkiAsn1ErrToHr(Asn1Err))
}

#ifdef CMS_PKCS7

//+-------------------------------------------------------------------------
//  Fill in the encrypted digest in a signer info.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_FillSignerEncryptedDigest(
    IN SignerInfo       *psi,
    IN OPTIONAL LPSTR   pszInnerContentObjID,
    IN PSIGNER_ENCODE_DATA_INFO pSignerEncodeDataInfo,
    IN BOOL             fMaxLength)
{
    DWORD           dwError = ERROR_SUCCESS;
    BOOL            fRet;
    HCRYPTHASH      hHash;
    HCRYPTHASH      hHashAttr = NULL;
    HCRYPTHASH      hHashDup = NULL;
    PBYTE           pbSignature = NULL;
    DWORD           cbSignature;
    CHashNode       *pnHash = pSignerEncodeDataInfo->pHashNode;
    PICM_HASH_INFO  pHashInfo = pnHash->Data();

    PCCRYPT_OID_INFO pOIDInfo;
    DWORD           dwAlgIdPubKey;
    DWORD           dwPubKeyFlags;

    if (psi->bit_mask & authenticatedAttributes_present) {
        if (!ICM_FillReqAuthAttrs(
                pszInnerContentObjID,
                pSignerEncodeDataInfo->pHashNode,
                psi->authenticatedAttributes.value))
            goto FillReqAuthAttrsError;
        if (!ICM_GetAttrsHash(
                pHashInfo->dwAlgoCAPI,
                pSignerEncodeDataInfo->hCryptProv,
                &psi->authenticatedAttributes,
                &hHashAttr))
            goto GetAuthAttrsHashError;
        hHash = hHashAttr;
    } else {
        if (!ICM_DupListHash( pnHash, pSignerEncodeDataInfo->hCryptProv,
                &hHashDup))
            goto DupListHashError;
        hHash = hHashDup;
    }

    dwAlgIdPubKey = 0;
    dwPubKeyFlags = 0;
    if (pOIDInfo = ICM_GetOssOIDInfo(CRYPT_PUBKEY_ALG_OID_GROUP_ID,
            &psi->digestEncryptionAlgorithm)) {
        dwAlgIdPubKey = pOIDInfo->Algid;
        if (1 <= pOIDInfo->ExtraInfo.cbData / sizeof(DWORD)) {
            DWORD *pdwExtra = (DWORD *) pOIDInfo->ExtraInfo.pbData;
            dwPubKeyFlags = pdwExtra[0];
        }
    } else if (pOIDInfo = ICM_GetOssOIDInfo(CRYPT_SIGN_ALG_OID_GROUP_ID,
            &psi->digestEncryptionAlgorithm)) {
        DWORD cExtra = pOIDInfo->ExtraInfo.cbData / sizeof(DWORD);
        DWORD *pdwExtra = (DWORD *) pOIDInfo->ExtraInfo.pbData;

        if (1 <= cExtra) {
            dwAlgIdPubKey = pdwExtra[0];
            if (2 <= cExtra)
                dwPubKeyFlags = pdwExtra[1];
        }
    }

    if (!ICM_AllocAndSignHash( hHash, pSignerEncodeDataInfo->dwKeySpec,
            dwAlgIdPubKey, dwPubKeyFlags, fMaxLength,
            &pbSignature, &cbSignature))
        goto AllocAndSignHashError;
    psi->encryptedDigest.length = cbSignature;
    psi->encryptedDigest.value  = pbSignature;
    pbSignature = NULL;

    fRet = TRUE;
CommonReturn:
    if (hHashAttr)
        CryptDestroyHash( hHashAttr);
    if (hHashDup)
        CryptDestroyHash( hHashDup);
    ICM_Free(pbSignature);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(FillReqAuthAttrsError)      // error already set
TRACE_ERROR(GetAuthAttrsHashError)      // error already set
TRACE_ERROR(DupListHashError)           // error already set
TRACE_ERROR(AllocAndSignHashError)      // error already set
}

BOOL
WINAPI
ICM_FillSignerEncodeEncryptedDigests(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fMaxLength)
{
    LPSTR pszInnerContentObjID = pcmi->pszInnerContentObjID;
    DWORD cSignerEncodeDataInfo = pcmi->cSignerEncodeDataInfo;
    PSIGNER_ENCODE_DATA_INFO pSignerEncodeDataInfo =
        pcmi->rgSignerEncodeDataInfo;
    SignedData *psd = (SignedData *)pcmi->pvMsg;
    SignerInfo *psi = psd->signerInfos.value;

    assert(psd->signerInfos.count == cSignerEncodeDataInfo);

    for ( ; 0 < cSignerEncodeDataInfo;
                                cSignerEncodeDataInfo--,
                                pSignerEncodeDataInfo++,
                                psi++) {
        if (!ICM_FillSignerEncryptedDigest(
                psi,
                pszInnerContentObjID,
                pSignerEncodeDataInfo,
                fMaxLength))
            return FALSE;
    }

    return TRUE;
}
#else

//+-------------------------------------------------------------------------
//  Fill in the encrypted digest in a signer info.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_FillSignerEncryptedDigest(
    IN SignerInfo       *psi,
    IN OPTIONAL LPSTR   pszInnerContentObjID,
    IN CHashNode        *pnHash,
    IN DWORD            dwKeySpec,
    IN BOOL             fMaxLength)
{
    DWORD           dwError = ERROR_SUCCESS;
    BOOL            fRet;
    HCRYPTHASH      hHash;
    HCRYPTHASH      hHashAttr = NULL;
    HCRYPTHASH      hHashDup = NULL;
    PBYTE           pbSignature = NULL;
    DWORD           cbSignature;
    PICM_HASH_INFO  pHashInfo = pnHash->Data();

    PCCRYPT_OID_INFO pOIDInfo;
    DWORD           dwAlgIdPubKey;
    DWORD           dwPubKeyFlags;

    if (psi->bit_mask & authenticatedAttributes_present) {
        if (!ICM_FillReqAuthAttrs(
                pszInnerContentObjID,
                pnHash,
                psi->authenticatedAttributes.value))
            goto FillReqAuthAttrsError;
        if (!ICM_GetAttrsHash(
                pHashInfo->dwAlgoCAPI,
                pHashInfo->hCryptProv,
                &psi->authenticatedAttributes,
                &hHashAttr))
            goto GetAuthAttrsHashError;
        hHash = hHashAttr;
    } else {
        if (!ICM_DupListHash( pnHash, pHashInfo->hCryptProv, &hHashDup))
            goto DupListHashError;
        hHash = hHashDup;
    }

    dwAlgIdPubKey = 0;
    dwPubKeyFlags = 0;
    if (pOIDInfo = ICM_GetOssOIDInfo(CRYPT_PUBKEY_ALG_OID_GROUP_ID,
            &psi->digestEncryptionAlgorithm)) {
        dwAlgIdPubKey = pOIDInfo->Algid;
        if (1 <= pOIDInfo->ExtraInfo.cbData / sizeof(DWORD)) {
            DWORD *pdwExtra = (DWORD *) pOIDInfo->ExtraInfo.pbData;
            dwPubKeyFlags = pdwExtra[0];
        }
    }

    if (!ICM_AllocAndSignHash( hHash, dwKeySpec,
            dwAlgIdPubKey, dwPubKeyFlags, fMaxLength,
            &pbSignature, &cbSignature))
        goto AllocAndSignHashError;
    psi->encryptedDigest.length = cbSignature;
    psi->encryptedDigest.value  = pbSignature;
    pbSignature = NULL;

    fRet = TRUE;
CommonReturn:
    if (hHashAttr)
        CryptDestroyHash( hHashAttr);
    if (hHashDup)
        CryptDestroyHash( hHashDup);
    ICM_Free(pbSignature);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(FillReqAuthAttrsError)      // error already set
TRACE_ERROR(GetAuthAttrsHashError)      // error already set
TRACE_ERROR(DupListHashError)           // error already set
TRACE_ERROR(AllocAndSignHashError)      // error already set
}
#endif  // CMS_PKCS7


//+-------------------------------------------------------------------------
//  Update the content of a signed message.
//
//  Assume all more-deeply-nested messages are DER-encoded.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_UpdateEncodingSignedData(
    IN PCRYPT_MSG_INFO  pcmi,
    IN const BYTE       *pbData,
    IN DWORD            cbData,
    IN BOOL             fFinal)
{
    BOOL                fRet;
    SignedData          *psd = (SignedData *)pcmi->pvMsg;
    LPSTR               pszInnerContentObjID = pcmi->pszInnerContentObjID;
    PBYTE               pb;
    DWORD               cb;
    PCMSG_STREAM_INFO   pcsi = pcmi->pStreamInfo;

    BOOL                fAddInnerContentOctetWrapper;   // CMS_PKCS7

    if (pcsi) {
        if (!ICMS_UpdateEncodingSignedData( pcmi, (PBYTE)pbData, cbData, fFinal))
            goto StreamUpdateEncodingSignedDataError;
    } else {
        psd->contentInfo.bit_mask = 0;

        fAddInnerContentOctetWrapper = ICM_IsAddInnerContentOctetWrapper(pcmi);
        if (0 == (pcmi->dwFlags & CMSG_DETACHED_FLAG) &&
                !fAddInnerContentOctetWrapper && pbData) {
            // must be encoded, hash only the contents octets
            if (0 > Asn1UtilExtractContent(
                        (PBYTE)pbData,
                        cbData,
                        &cb,
                        (const BYTE **)&pb))
                goto ExtractContentError;
        } else {
            cb = cbData;
            pb = (PBYTE)pbData;
        }
        if (!ICM_UpdateListDigest( pcmi->pHashList, pb, cb))
            goto UpdateDigestError;

        if (fFinal) {
            if (pcmi->dwFlags & CMSG_DETACHED_FLAG) {
                if (!ICM_FillInnerContentInfo(
                        &psd->contentInfo,
                        pszInnerContentObjID,
                        0,                      // cbData
                        NULL,                   // pbData
                        FALSE))                 // fAddInnerContentOctetWrapper
                    goto DetachedFillInnerContentInfoError;
            } else {
                if (!ICM_FillInnerContentInfo(
                        &psd->contentInfo,
                        pszInnerContentObjID,
                        cbData,
                        (PBYTE)pbData,
                        fAddInnerContentOctetWrapper
                        ))
                    goto FillInnerContentInfoError;
            }

#ifdef CMS_PKCS7
            if (pcmi->rgSignerEncodeDataInfo) {
                BOOL fMaxLength =
                    (0 != (pcmi->dwFlags & CMSG_MAX_LENGTH_FLAG));
                if (!ICM_FillSignerEncodeEncryptedDigests(
                        pcmi,
                        fMaxLength))
                    goto FillSignerEncodeEncryptedDigestsError;
            }
#else
            if (pcmi->pHashList) {
                BOOL fMaxLength =
                    (0 != (pcmi->dwFlags & CMSG_MAX_LENGTH_FLAG));
                if (!ICM_FillSignerEncryptedDigest(
                                psd->signerInfos.value,
                                pszInnerContentObjID,
                                pcmi->pHashList->Head(),
                                pcmi->dwKeySpec,
                                fMaxLength))
                    goto FillSignerEncryptedDigestError;
            }
#endif  // CMS_PKCS7
        }
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(ExtractContentError,CRYPT_E_UNEXPECTED_ENCODING)
TRACE_ERROR(UpdateDigestError)                      // error already set
TRACE_ERROR(DetachedFillInnerContentInfoError)      // error already set
TRACE_ERROR(FillInnerContentInfoError)              // error already set
TRACE_ERROR(StreamUpdateEncodingSignedDataError)    // error already set
#ifdef CMS_PKCS7
TRACE_ERROR(FillSignerEncodeEncryptedDigestsError)  // error already set
#else
TRACE_ERROR(FillSignerEncryptedDigestError)         // error already set
#endif  // CMS_PKCS7
}


//+-------------------------------------------------------------------------
//  Update the content of a data message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_UpdateEncodingData(
    IN PCRYPT_MSG_INFO  pcmi,
    IN const BYTE       *pbData,
    IN DWORD            cbData,
    IN BOOL             fFinal)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    OctetStringType     *poos = (OctetStringType *)pcmi->pvMsg;
    PCMSG_STREAM_INFO   pcsi = pcmi->pStreamInfo;

    if (!pcsi) {
        if (!fFinal)
            goto NotFinalNotSupportedError;

        poos->length = cbData;
        if (NULL == (poos->value = (PBYTE)ICM_DupMem( (PBYTE)pbData, cbData)))
            goto AllocOctetStringError;
    }

    if (pcsi && !ICMS_UpdateEncodingData( pcmi, (PBYTE)pbData, cbData, fFinal))
        goto StreamUpdateEncodingDataError;

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    ICM_Free( poos->value);
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(NotFinalNotSupportedError,E_INVALIDARG)
TRACE_ERROR(AllocOctetStringError)                  // error already set
TRACE_ERROR(StreamUpdateEncodingDataError)          // error already set
}


//+-------------------------------------------------------------------------
//  Update the content of a digested message.
//
//  Assume all more-deeply-nested messages are DER-encoded.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_UpdateEncodingDigestedData(
    IN PCRYPT_MSG_INFO pcmi,
    IN const BYTE *pbData,
    IN DWORD cbData,
    IN BOOL fFinal)
{
    BOOL                fRet;
    DigestedData        *pdd = (DigestedData *)pcmi->pvMsg;
    PBYTE               pb;
    DWORD               cb;
    LPSTR               pszInnerContentObjID = pcmi->pszInnerContentObjID;
    BOOL                fAddInnerContentOctetWrapper;   // CMS_PKCS7

    pdd->contentInfo.bit_mask = 0;
    if (pcmi->dwFlags & CMSG_DETACHED_FLAG) {
        // must be non-encoded
        if (!ICM_UpdateListDigest( pcmi->pHashList, pbData, cbData))
            goto DetachedUpdateDigestError;
        if (!ICM_FillInnerContentInfo(
                &pdd->contentInfo,
                pszInnerContentObjID,
                0,                      // cbData
                NULL,                   // pbData
                FALSE                   // fAddInnerContentOctetWrapper
                ))
            goto DetachedFillInnerContentInfoError;
    } else {
        fAddInnerContentOctetWrapper = ICM_IsAddInnerContentOctetWrapper(pcmi);
        if (!fAddInnerContentOctetWrapper && pbData) {
            // must be encoded, hash only the contents octets
            if (0 > Asn1UtilExtractContent( (PBYTE)pbData, cbData, &cb,
                    (const BYTE **)&pb))
                goto ExtractContentError;
        } else {
            cb = cbData;
            pb = (PBYTE)pbData;
        }
        if (!ICM_UpdateListDigest( pcmi->pHashList, pb, cb))
            goto UpdateDigestError;
        if (!ICM_FillInnerContentInfo(
                &pdd->contentInfo,
                pszInnerContentObjID,
                cbData,
                (PBYTE)pbData,
                fAddInnerContentOctetWrapper
                ))
            goto FillInnerContentInfoError;
    }
    if (PHASE_FIRST_FINAL == pcmi->dwPhase) {
        if (!ICM_GetListHashValue(
                pcmi->pHashList->Head(),
                (DWORD*)&pdd->digest.length,
                &pdd->digest.value))
            goto GetHashValueError;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(ExtractContentError,CRYPT_E_UNEXPECTED_ENCODING)
TRACE_ERROR(DetachedUpdateDigestError)          // error already set
TRACE_ERROR(UpdateDigestError)                  // error already set
TRACE_ERROR(DetachedFillInnerContentInfoError)  // error already set
TRACE_ERROR(FillInnerContentInfoError)          // error already set
TRACE_ERROR(GetHashValueError)                  // error already set
fFinal;
}


//+-------------------------------------------------------------------------
//  Get the block size for an encryption algorithm
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetKeyBlockSize(
    IN HCRYPTKEY        hkeyEncrypt,
    OUT PDWORD          pcbBlockSize,
    OUT OPTIONAL PBOOL  pfBlockCipher)
{
    BOOL            fRet;
    BOOL            fBlockCipher;
    DWORD           cbBlockSize;
    DWORD           cbKeyParamLen;

    // Get key's blocksize.
    // Encryption will pad the output data to be blocksize aligned,
    // in the case of a block cipher.
    cbBlockSize = 0;
    cbKeyParamLen = sizeof( cbBlockSize);
    if (!CryptGetKeyParam(
            hkeyEncrypt,
            KP_BLOCKLEN,
            (PBYTE)&cbBlockSize,
            &cbKeyParamLen,
            0))                     // dwFlags
        goto GetKeyParamError;

    if (0 == cbBlockSize) {
        // stream cipher
        fBlockCipher = FALSE;
        cbBlockSize  = 8;       // convenient size
    } else {
        // block cipher
        fBlockCipher = TRUE;
        cbBlockSize /= 8;       // convert from bits to bytes
    }

    fRet = TRUE;
CommonReturn:
    *pcbBlockSize = cbBlockSize;
    if (pfBlockCipher)
        *pfBlockCipher = fBlockCipher;
    return fRet;

ErrorReturn:
    cbBlockSize = 0;
    fBlockCipher = FALSE;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetKeyParamError)   // error already set
}


//+-------------------------------------------------------------------------
//  Encrypt a buffer
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_EncryptBuffer(
    IN HCRYPTKEY hkeyEncrypt,
    HCRYPTHASH   hHash,
    IN const BYTE *pbPlain,
    IN DWORD    cbPlain,
    OUT PBYTE   *ppbCipher,
    OUT PDWORD  pcbCipher)
{
    BOOL            fRet;
    const BYTE      *pbIn;
    DWORD           cbIn;
    PBYTE           pbOut;
    DWORD           cbOut;
    PBYTE           pbOutBuf = NULL;
    DWORD           cbPlainRemain;
    DWORD           cbBufRemain;
    DWORD           cbBlockLen;
    BOOL            fBlockCipher;

    if (!ICM_GetKeyBlockSize( hkeyEncrypt, &cbBlockLen, &fBlockCipher))
        goto GetKeyBlockSizeError;

    // encrypt
    cbBufRemain = cbPlain;
    if (fBlockCipher) {
        cbBufRemain += cbBlockLen;
        cbBufRemain -= cbBufRemain % cbBlockLen;
    }
    if (NULL == (pbOutBuf = (PBYTE)ICM_Alloc( cbBufRemain)))
        goto OutOfMemory;
    for (pbIn=pbPlain, pbOut=pbOutBuf, cbPlainRemain=cbPlain;
            (cbIn = min( cbBlockLen, cbPlainRemain)) > 0;
            pbIn += cbIn, pbOut += cbOut,
                cbPlainRemain -= cbIn, cbBufRemain -= cbOut) {

        memcpy( pbOut, pbIn, cbIn);
        cbOut = cbIn;
        if (!CryptEncrypt(
                    hkeyEncrypt,
                    hHash,
                    cbPlainRemain <= cbBlockLen,    // fFinal
                    0,                              // dwFlags
                    pbOut,
                    &cbOut,
                    cbBufRemain))
            goto EncryptError;
    }

    *ppbCipher = pbOutBuf;
    *pcbCipher = (DWORD)(pbOut - pbOutBuf);

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    if(NULL != pbOutBuf)
        ICM_Free(pbOutBuf);
    *ppbCipher = NULL;
    *pcbCipher = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetKeyBlockSizeError)       // error already set
TRACE_ERROR(EncryptError)               // error already set
TRACE_ERROR(OutOfMemory)                // error already set
}


//+-------------------------------------------------------------------------
//  Encrypt and store the content of a message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_EncryptContent(
    IN HCRYPTKEY                hkeyContentEncryption,
    HCRYPTHASH                  hHash,
    OUT EncryptedContentInfo    *peci,
    IN const BYTE               *pbPlain,
    IN DWORD                    cbPlain)
{
    BOOL    fRet;
    PBYTE   pbCipher = NULL;
    DWORD   cbCipher;

    if (!ICM_EncryptBuffer(
            hkeyContentEncryption,
            hHash,
            pbPlain,
            cbPlain,
            &pbCipher,
            &cbCipher))
        goto EncryptBufferError;

    if (0 != cbCipher) {
        peci->bit_mask |= encryptedContent_present;
        peci->encryptedContent.length = cbCipher;
        peci->encryptedContent.value = pbCipher;
    } else
        ICM_Free(pbCipher);

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(EncryptBufferError)     // error already set
}


//+-------------------------------------------------------------------------
//  Update the content of a signed and enveloped message.
//
//  Assume all more-deeply-nested messages are DER-encoded.
//--------------------------------------------------------------------------
#if 0
BOOL
WINAPI
ICM_UpdateEncodingSignedAndEnvelopedData(
    IN PCRYPT_MSG_INFO pcmi,
    IN const BYTE *pbData,
    IN DWORD cbData,
    IN BOOL fFinal)
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    EncryptedContentInfo    *peci;
    SignedAndEnvelopedData  *psed;
    DWORD                   i;
    DWORD                   iMax;
    PBYTE                   pbSignature;
    DWORD                   cbSignature;
    PBYTE                   pbEncryptedSignature;
    DWORD                   cbEncryptedSignature;

    psed = (SignedAndEnvelopedData *)(pcmi->pvMsg);
    peci = &psed->encryptedContentInfo;

    // Require inner type to be Data for now
    peci->contentType = aoidMessages[ CMSG_DATA - 1];

    // Alloc a bigger buffer with padding and copy input to it

    // encrypt the content and store it
    if (!ICM_EncryptContent(
            pcmi->hkeyContentCrypt,
            pcmi->ahHash[0],        // select the right hHash
            peci,
            pbData,
            cbData))
        goto EncryptError;

    assert( 1 == psed->signerInfos.Count());
    for (i=0, iMax=psed->signerInfos.Count(); i<iMax; i++) {
        // Should use a stack buffer, unless it is too small
        if (!CryptSignHash(
                pcmi->ahHash[i],
                (pcmi->dwKeySpec == 0) ? AT_SIGNATURE : pcmi->dwKeySpec,
                NULL,               // description ?
                0,                  // dwFlags
                NULL,               // pbSignature
                &cbSignature))
            goto GetSignatureSizeError;
        pbSignature = (PBYTE)ICM_AllocA( cbSignature);
        if (NULL == pbSignature)
            goto AllocSignatureError;
        if (!CryptSignHash(
                pcmi->ahHash[i],
                (pcmi->dwKeySpec == 0) ? AT_SIGNATURE : pcmi->dwKeySpec,
                NULL,               // description ?
                0,                  // dwFlags
                pbSignature,
                &cbSignature))
            goto SignHashError;
        // encrypt the signature
        if (!ICM_EncryptBuffer(
                pcmi->hkeyContentCrypt,
                NULL,
                pbSignature,
                cbSignature,
                &pbEncryptedSignature,
                &cbEncryptedSignature))
            goto EncryptError;
        ICM_FreeA( pbSignature);
        pbSignature = NULL;
        if (0 > psed->signerInfos[i].encryptedDigest.Write(
                pbEncryptedSignature,
                cbEncryptedSignature))
            goto EncryptedDigestWriteError;
        ICM_Free( pbEncryptedSignature);
        pbEncryptedSignature = NULL;
    }

    fRet = TRUE;
CommonReturn:
    ICM_FreeA( pbSignature);
    ICM_Free( pbEncryptedSignature);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(EncryptError)
TRACE_ERROR(GetSignatureSizeError)
TRACE_ERROR(AllocSignatureError)
TRACE_ERROR(SignHashError)
TRACE_ERROR(EncryptedDigestWriteError)
}
#endif


//+-------------------------------------------------------------------------
//  Update the content of an enveloped message.
//
//  Assume all more-deeply-nested messages are DER-encoded.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_UpdateEncodingEnvelopedData(
    IN PCRYPT_MSG_INFO pcmi,
    IN const BYTE *pbData,
    IN DWORD cbData,
    IN BOOL fFinal)
{
    BOOL                    fRet;
    PBYTE                   pb;
    DWORD                   cb;
#ifdef CMS_PKCS7
    EncryptedContentInfo    *peci = &((CmsEnvelopedData *)pcmi->pvMsg)->encryptedContentInfo;
#else
    EncryptedContentInfo    *peci = &((EnvelopedData *)pcmi->pvMsg)->encryptedContentInfo;
#endif  // CMS_PKCS7
    PCMSG_STREAM_INFO       pcsi = pcmi->pStreamInfo;

    if (pcsi) {
        if (!ICMS_UpdateEncodingEnvelopedData(
                            pcmi,
                            pbData,
                            cbData,
                            fFinal))
            goto StreamUpdateEncodingEnvelopedDataError;
    } else {
        if (!fFinal)
            goto InvalidArg;

        // encrypt the content
        if (!ICM_IsAddInnerContentOctetWrapper(pcmi)) {
            if (0 > Asn1UtilExtractContent( (PBYTE)pbData, cbData, &cb, (const BYTE **)&pb))
                goto ExtractContentError;
        } else {
            pb = (PBYTE)pbData;
            cb = cbData;
        }

        if (!ICM_EncryptContent(
                pcmi->hkeyContentCrypt,
                NULL,           // hHash
                peci,
                pb,
                cb))
            goto EncryptError;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidArg,E_INVALIDARG)
SET_ERROR(ExtractContentError,CRYPT_E_UNEXPECTED_ENCODING)
TRACE_ERROR(EncryptError)                               // error already set
TRACE_ERROR(StreamUpdateEncodingEnvelopedDataError)     // error already set
}


//+-------------------------------------------------------------------------
//  Convert Any to blob and insert at the tail of a blob list
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_InsertTailBlob(
    IN OUT CBlobList    *pBlobList,
    IN Any              *pAny)
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    CBlobNode               *pnBlob = NULL;
    PBYTE                   pb = NULL;
    DWORD                   cb;
    CRYPT_DATA_BLOB         blob;

    if (NULL == (pnBlob = new CBlobNode))
        goto NewCBlobNodeError;
    cb = pAny->length;
    if (NULL == (pb = (PBYTE)ICM_Alloc( cb)))
        goto AllocError;
    memcpy( pb, pAny->value, cb);
    blob.cbData = cb;
    blob.pbData = pb;
    pnBlob->SetData( &blob);
    pBlobList->InsertTail( pnBlob);

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    ICM_Free( pb);
    goto CommonReturn;
SET_ERROR(NewCBlobNodeError,E_OUTOFMEMORY)
TRACE_ERROR(AllocError)                 // error already set
}


//+-------------------------------------------------------------------------
//  Use a 0-based index to delete a blob from a list
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DelBlobByIndex(
    IN OUT CBlobList    *pBlobList,
    IN DWORD            dwIndex)
{
    BOOL                fRet;
    CBlobNode           *pnBlob = pBlobList->Nth( dwIndex);

    if (NULL == pnBlob)
        goto IndexTooLargeError;

    pBlobList->Remove( pnBlob);
    delete pnBlob;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(IndexTooLargeError,CRYPT_E_INVALID_INDEX)
}


//+-------------------------------------------------------------------------
//  Convert Any to blob and insert at the tail of a signer list
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_InsertTailSigner(
    IN OUT CSignerList  *pSignerList,
    IN Any              *pAny)
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    CSignerNode             *pnSigner = NULL;
    PBYTE                   pb = NULL;
    DWORD                   cb;
    SIGNER_DATA_INFO        sdi;    ZEROSTRUCT(sdi);

    if (NULL == (pnSigner = new CSignerNode))
        goto NewCSignerNodeError;
    cb = pAny->length;
    if (NULL == (pb = (PBYTE)ICM_Alloc( cb)))
        goto AllocError;
    memcpy( pb, pAny->value, cb);
    sdi.blob.cbData = cb;
    sdi.blob.pbData = pb;
    pnSigner->SetData( &sdi);
    pSignerList->InsertTail( pnSigner);

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    ICM_Free( pb);
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(NewCSignerNodeError,E_OUTOFMEMORY)
TRACE_ERROR(AllocError)                 // error already set
}


//+-------------------------------------------------------------------------
//  Convert a signed message to list form
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetListSignedData(
    IN OUT PCRYPT_MSG_INFO pcmi,
    IN SignedDataWithBlobs *psdb)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    Any                 *pAny;
    DWORD               cb;
    DWORD               i;
    PSIGNED_DATA_INFO   psdi = NULL;

    if (NULL == (psdi = (PSIGNED_DATA_INFO)ICM_AllocZero(
                            sizeof(SIGNED_DATA_INFO))))
        goto SdiAllocError;

    if (NULL == (psdi->pAlgidList = new CBlobList))
        goto NewAlgidListError;
    if (NULL == (psdi->pCertificateList = new CBlobList))
        goto NewCertificateListError;
    if (NULL == (psdi->pCrlList = new CBlobList))
        goto NewCrlListError;
    if (NULL == (psdi->pSignerList = new CSignerList))
        goto NewSignerListError;

    // version
    psdi->version = psdb->version;

    // digestAlgorithms
    for (i=psdb->digestAlgorithms.count, pAny=psdb->digestAlgorithms.value;
            i>0;
            i--, pAny++) {
        if (!ICM_InsertTailBlob( psdi->pAlgidList, pAny))
            goto DigestAlgorithmInsertTailBlobError;
    }

    // contentInfo
    cb = 0;
    ICM_GetOssContentInfoData(
            (ContentInfo *)&psdb->contentInfo,  // same, except for NOCOPY
            NULL,
            &cb);
    if (cb == 0)
        goto GetContentInfoDataSizeError;
    if (NULL == (psdi->pci = (PCONTENT_INFO)ICM_Alloc(cb)))
        goto AllocContentInfoError;
    if (!ICM_GetOssContentInfoData(
            (ContentInfo *)&psdb->contentInfo,  // same, except for NOCOPY
            psdi->pci,
            &cb))
        goto GetContentInfoDataError;

    // certificates
    if (psdb->bit_mask & certificates_present) {
#ifdef OSS_CRYPT_ASN1
        for (i=psdb->certificates.count, pAny=psdb->certificates.certificates;
#else
        for (i=psdb->certificates.count, pAny=psdb->certificates.value;
#endif  // OSS_CRYPT_ASN1
                i>0;
                i--, pAny++) {
            if (!ICM_InsertTailBlob( psdi->pCertificateList, pAny))
                goto CertInsertTailBlobError;
        }
    }

    // crls
    if (psdb->bit_mask & crls_present) {
#ifdef OSS_CRYPT_ASN1
        for (i=psdb->crls.count, pAny=psdb->crls.crls;
#else
        for (i=psdb->crls.count, pAny=psdb->crls.value;
#endif  // OSS_CRYPT_ASN1
                i>0;
                i--, pAny++) {
            if (!ICM_InsertTailBlob( psdi->pCrlList, pAny))
                goto CrlInsertTailBlobError;
        }
    }

    // signerInfos
    for (i=psdb->signerInfos.count, pAny=psdb->signerInfos.value;
            i>0;
            i--, pAny++) {
        if (!ICM_InsertTailSigner( psdi->pSignerList, pAny))
            goto SignerInfoInsertTailBlobError;
    }

    fRet = TRUE;
CommonReturn:
    pcmi->psdi = psdi;
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();

    if(NULL != psdi->pSignerList)
        delete psdi->pSignerList;

    if(NULL != psdi->pCrlList)
        delete psdi->pCrlList;

    if(NULL != psdi->pCertificateList)
        delete psdi->pCertificateList;

    if(NULL != psdi->pAlgidList)
        delete psdi->pAlgidList;

    ICM_Free( psdi);
    psdi = NULL;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(DigestAlgorithmInsertTailBlobError)     // error already set
TRACE_ERROR(GetContentInfoDataSizeError)            // error already set
TRACE_ERROR(AllocContentInfoError)                  // error already set
TRACE_ERROR(GetContentInfoDataError)                // error already set
TRACE_ERROR(CertInsertTailBlobError)                // error already set
TRACE_ERROR(CrlInsertTailBlobError)                 // error already set
TRACE_ERROR(SignerInfoInsertTailBlobError)          // error already set
SET_ERROR(NewSignerListError,E_OUTOFMEMORY)
SET_ERROR(NewCrlListError,E_OUTOFMEMORY)
SET_ERROR(NewCertificateListError,E_OUTOFMEMORY)
SET_ERROR(NewAlgidListError,E_OUTOFMEMORY)
SET_ERROR(SdiAllocError,E_OUTOFMEMORY)
}


//+-------------------------------------------------------------------------
//  Get the CAPI algid from an encoded AlgidBlob
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetCapiFromAlgidBlob(
    IN PCRYPT_DATA_BLOB pAlgidBlob,
    OUT PDWORD          pdwAlgidCapi)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    ASN1error_e         Asn1Err;
    ASN1decoding_t      pDec = ICM_GetDecoder();
    AlgorithmIdentifier *poai = NULL;

    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&poai,
            AlgorithmIdentifier_PDU,
            pAlgidBlob->pbData,
            pAlgidBlob->cbData)))
        goto Asn1DecodeAlgorithmIdentifierError;
    if (!(ICM_GetOssCAPI( CRYPT_HASH_ALG_OID_GROUP_ID, poai, pdwAlgidCapi) ||
            ICM_GetOssCAPI( CRYPT_SIGN_ALG_OID_GROUP_ID, poai, pdwAlgidCapi)))
        goto GetCAPIError;

    fRet = TRUE;
CommonReturn:
    PkiAsn1FreeInfo(pDec, AlgorithmIdentifier_PDU, poai);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    *pdwAlgidCapi = 0;
    goto CommonReturn;
SET_ERROR_VAR(Asn1DecodeAlgorithmIdentifierError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(GetCAPIError,CRYPT_E_UNKNOWN_ALGO)
}


//+-------------------------------------------------------------------------
//  Create a hash list from a list of hash algid's
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_CreateHashList(
    IN HCRYPTPROV       hCryptProv,
    IN OUT CHashList    **ppHashList,
    IN CBlobList        *pAlgidList)
{
    DWORD           dwError = ERROR_SUCCESS;
    BOOL            fRet;
    CHashList       *pHashList;
    CBlobNode       *pBlobNode;
    CHashNode       *pHashNode;
    ICM_HASH_INFO   HashInfo;       ZEROSTRUCT(HashInfo);

    if (NULL == (pHashList = new CHashList))
        goto NewHashListError;
    if (hCryptProv) {
        for (pBlobNode=pAlgidList->Head();
                pBlobNode;
                pBlobNode=pBlobNode->Next()) {
            if (!ICM_GetCapiFromAlgidBlob(
                    pBlobNode->Data(),
                    &HashInfo.dwAlgoCAPI))
                goto GetCAPIError;
#ifndef CMS_PKCS7
            HashInfo.hCryptProv = hCryptProv;
#endif  // CMS_PKCS7
            if (!CryptCreateHash(
                            hCryptProv,
                            HashInfo.dwAlgoCAPI,
                            NULL,               // hKey - optional for MAC
                            0,                  // dwFlags
                            &HashInfo.hHash))
                goto CreateHashError;
            if (NULL == (pHashNode = new CHashNode))
                goto NewHashNodeError;
            pHashNode->SetData( &HashInfo);
            pHashList->InsertTail( pHashNode);
        }
    }

    fRet = TRUE;
CommonReturn:
    *ppHashList = pHashList;
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    pHashList = NULL;
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(NewHashListError,E_OUTOFMEMORY)
SET_ERROR(NewHashNodeError,E_OUTOFMEMORY)
TRACE_ERROR(GetCAPIError)                           // error already set
TRACE_ERROR(CreateHashError)                        // error already set
}


//+-------------------------------------------------------------------------
//  Update for decoding a signed message
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_UpdateDecodingSignedData(
    IN OUT PCRYPT_MSG_INFO pcmi,
    IN const BYTE *pbData,
    IN DWORD cbData)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    SignedDataWithBlobs *psdb = NULL;
    PBYTE               pb = NULL;
    DWORD               cb;
    ASN1error_e         Asn1Err;
    ASN1decoding_t      pDec = ICM_GetDecoder();
    PBYTE               pbDER = NULL;
    DWORD               cbDER;
    ICM_HASH_INFO       HashInfo;       ZEROSTRUCT(HashInfo);

    DWORD dwExceptionCode;

  // Handle MappedFile Exceptions
  __try {

    if (PHASE_FIRST_FINAL == pcmi->dwPhase) {
        if (0 != (Asn1Err = PkiAsn1Decode(
                pDec,
                (void **)&psdb,
                SignedDataWithBlobs_PDU,
                pbData,
                cbData)))
            goto Asn1DecodeSignedDataError;
        if (!ICM_GetListSignedData( pcmi, psdb))
            goto GetListSignedDataError;
        if (!ICM_CreateHashList(
                pcmi->hCryptProv,
                &pcmi->pHashList,
                pcmi->psdi->pAlgidList))
            goto CreateHashListError;
        if (pcmi->psdi->pci->content.cbData) {
            // Get the address & count of the contents octets of the DER
            // encoding of the content. Since the content might be
            // indefinite-length encoded, decode and re-encode as DER.
            pb = pcmi->psdi->pci->content.pbData;
            cb = pcmi->psdi->pci->content.cbData;

            if (0 == strcmp(pszObjIdDataType,
                        pcmi->psdi->pci->pszContentType)
#ifdef CMS_PKCS7
                    ||  pcmi->psdi->version >= CMSG_SIGNED_DATA_CMS_VERSION 
#endif  // CMS_PKCS7
                    ) {
                if (!ICM_ReEncodeAsOctetDER(
                        pb,
                        cb,
                        &pbDER,
                        &cbDER
                        ))
                    goto ReEncodeAsOctetDERError;
                if (pbDER) {
                    pb = pbDER;
                    cb = cbDER;
                }
            }
            if (0 > Asn1UtilExtractContent( pb, cb, &cb, (const BYTE **)&pb))
                goto ExtractContentError;
        } else {
            cb = 0;
        }
    } else {
        assert (pcmi->dwFlags & CMSG_DETACHED_FLAG);
        if (!(pcmi->dwFlags & CMSG_DETACHED_FLAG))
            goto NonFinalNotDetachedError;
        pb = (PBYTE)pbData;
        cb = cbData;
    }

    if (!ICM_UpdateListDigest( pcmi->pHashList, pb, cb))
        goto UpdateDigestError;

    fRet = TRUE;

  } __except(EXCEPTION_EXECUTE_HANDLER) {
    dwExceptionCode = GetExceptionCode();
    goto ExceptionError;
  }

CommonReturn:
    PkiAsn1FreeEncoded(ICM_GetEncoder(), pbDER);
    PkiAsn1FreeInfo(pDec, SignedDataWithBlobs_PDU, psdb);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(Asn1DecodeSignedDataError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(ExtractContentError,CRYPT_E_UNEXPECTED_ENCODING)
SET_ERROR(NonFinalNotDetachedError,CRYPT_E_MSG_ERROR)
TRACE_ERROR(GetListSignedDataError)                 // error already set
TRACE_ERROR(CreateHashListError)                    // error already set
TRACE_ERROR(ReEncodeAsOctetDERError)                // error already set
TRACE_ERROR(UpdateDigestError)                      // error already set
SET_ERROR_VAR(ExceptionError, dwExceptionCode)
}

#ifdef CMS_PKCS7

//+-------------------------------------------------------------------------
//  Update for decoding an enveloped message
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_UpdateDecodingEnvelopedData(
    IN PCRYPT_MSG_INFO pcmi,
    IN const BYTE *pbData,
    IN DWORD cbData)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    CmsEnvelopedData    *ped = NULL;
    ASN1error_e         Asn1Err;
    ASN1decoding_t      pDec = ICM_GetDecoder();

    assert (PHASE_FIRST_FINAL == pcmi->dwPhase);
    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **) &ped,
            CmsEnvelopedData_PDU,
            pbData,
            cbData)))
        goto Asn1DecodeError;
    pcmi->pvMsg = ped;

    if (NULL == (pcmi->pCertificateList = new CBlobList))
        goto NewCertificateListError;
    if (NULL == (pcmi->pCrlList = new CBlobList))
        goto NewCrlListError;

    if (ped->bit_mask & originatorInfo_present) {
        OriginatorInfo *poi = &ped->originatorInfo;
        DWORD i;
        Any *pAny;

        // certificates
        if (poi->bit_mask & certificates_present) {
#ifdef OSS_CRYPT_ASN1
            for (i=poi->certificates.count, pAny=poi->certificates.certificates;
#else
            for (i=poi->certificates.count, pAny=poi->certificates.value;
#endif  // OSS_CRYPT_ASN1
                    i>0;
                    i--, pAny++) {
                if (!ICM_InsertTailBlob( pcmi->pCertificateList, pAny))
                    goto CertInsertTailBlobError;
            }
        }

        // crls
        if (poi->bit_mask & crls_present) {
#ifdef OSS_CRYPT_ASN1
            for (i=poi->crls.count, pAny=poi->crls.crls;
#else
            for (i=poi->crls.count, pAny=poi->crls.value;
#endif  // OSS_CRYPT_ASN1
                    i>0;
                    i--, pAny++) {
                if (!ICM_InsertTailBlob( pcmi->pCrlList, pAny))
                    goto CrlInsertTailBlobError;
            }
        }
    }

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;

    if (NULL != pcmi->pCertificateList) {
        delete pcmi->pCertificateList;
        pcmi->pCertificateList = NULL;
    }

    if (NULL != pcmi->pCrlList) {
        delete pcmi->pCrlList;
        pcmi->pCrlList = NULL;
    }

    goto CommonReturn;
SET_ERROR_VAR(Asn1DecodeError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(NewCertificateListError,E_OUTOFMEMORY)
SET_ERROR(NewCrlListError,E_OUTOFMEMORY)
TRACE_ERROR(CertInsertTailBlobError)
TRACE_ERROR(CrlInsertTailBlobError)
}

#else

//+-------------------------------------------------------------------------
//  Update for decoding an enveloped message
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_UpdateDecodingEnvelopedData(
    IN PCRYPT_MSG_INFO pcmi,
    IN const BYTE *pbData,
    IN DWORD cbData)
{
    BOOL                fRet;
    EnvelopedData       *ped = NULL;
    ASN1error_e         Asn1Err;
    ASN1decoding_t      pDec = ICM_GetDecoder();

    assert (PHASE_FIRST_FINAL == pcmi->dwPhase);
    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&ped,
            EnvelopedData_PDU,
            pbData,
            cbData)))
        goto Asn1DecodeError;
    pcmi->pvMsg = ped;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(Asn1DecodeError, PkiAsn1ErrToHr(Asn1Err))
}

#endif  // CMS_PKCS7


//+-------------------------------------------------------------------------
//  Find the HashNode corresponding to a CAPI Algid
//
// NB- Does not fail.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_FindHashNodeFromCapiAlgid(
    IN CHashList    *pHashList,
    IN DWORD        dwAlgoCAPI,
    OUT CHashNode   **ppnHash)
{
    CHashNode   *pnHash;

    for (pnHash=pHashList->Head(); pnHash; pnHash=pnHash->Next()) {
        if (dwAlgoCAPI == pnHash->Data()->dwAlgoCAPI)
            break;
    }

    *ppnHash = pnHash;

    if(pnHash == NULL) {
        SetLastError((DWORD) CRYPT_E_UNKNOWN_ALGO);
        return FALSE;
    }
    
    return TRUE;
}


//+-------------------------------------------------------------------------
//  Find the HashNode corresponding to an encoded Algid
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_FindHashNodeFromEncodedAlgo(
    IN CHashList            *pHashList,
    IN PCRYPT_DATA_BLOB     pblobEncodedAlgorithm,
    OUT CHashNode           **ppnHash)
{
    BOOL        fRet;
    DWORD       dwAlgoCAPI;

    if (!ICM_GetCapiFromAlgidBlob(
            pblobEncodedAlgorithm,
            &dwAlgoCAPI))
        goto GetCAPIError;
    fRet = ICM_FindHashNodeFromCapiAlgid( pHashList, dwAlgoCAPI, ppnHash);

CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    *ppnHash = NULL;
    goto CommonReturn;
TRACE_ERROR(GetCAPIError)       // error already set
}


//+-------------------------------------------------------------------------
//  Update for decoding a digested message
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_UpdateDecodingDigestedData(
    IN PCRYPT_MSG_INFO pcmi,
    IN const BYTE *pbData,
    IN DWORD cbData)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    DigestedData        *pdd = NULL;
    PBYTE               pb = NULL;
    DWORD               cb;
    PBYTE               pbDER = NULL;
    DWORD               cbDER;
    ASN1error_e         Asn1Err;
    ASN1decoding_t      pDec = ICM_GetDecoder();
    ICM_HASH_INFO       HashInfo;       ZEROSTRUCT(HashInfo);
    CHashNode           *pHashNode;

    if (PHASE_FIRST_FINAL == pcmi->dwPhase) {
        if (0 != (Asn1Err = PkiAsn1Decode(
                pDec,
                (void **)&pdd,
                DigestedData_PDU,
                pbData,
                cbData)))
            goto Asn1DecodeError;
        pcmi->pvMsg = pdd;
        if (!ICM_GetOssCAPI(
                CRYPT_HASH_ALG_OID_GROUP_ID,
                &pdd->digestAlgorithm,
                &HashInfo.dwAlgoCAPI))
            goto GetCAPIError;
#ifndef CMS_PKCS7
        HashInfo.hCryptProv = pcmi->hCryptProv;
#endif  // CMS_PKCS7
        if (!CryptCreateHash(
                        pcmi->hCryptProv,
                        HashInfo.dwAlgoCAPI,
                        NULL,               // hKey - optional for MAC
                        0,                  // dwFlags
                        &HashInfo.hHash))
            goto CreateHashError;
        if (NULL == (pcmi->pHashList = new CHashList))
            goto NewHashListError;
        if (NULL == (pHashNode = new CHashNode))
            goto NewHashNodeError;
        pHashNode->SetData( &HashInfo);
        pcmi->pHashList->InsertTail( pHashNode);
        if (pdd->contentInfo.bit_mask & content_present) {
            // Get the address & count of the contents octets of the DER
            // encoding of the content. Since the content might be
            // indefinite-length encoded, decode and re-encode as DER.
            pb = (PBYTE)pdd->contentInfo.content.value;
            cb = (DWORD)pdd->contentInfo.content.length;

            if (ICM_EqualObjectIDs(
                        &pdd->contentInfo.contentType,
                        &aoidMessages[ CMSG_DATA - 1])
#ifdef CMS_PKCS7
                    || pdd->version >= CMSG_HASHED_DATA_V2 
#endif  // CMS_PKCS7
                    ) {
                if (!ICM_ReEncodeAsOctetDER(
                        pb,
                        cb,
                        &pbDER,
                        &cbDER
                        ))
                    goto ReEncodeAsOctetDERError;
                if (pbDER) {
                    pb = pbDER;
                    cb = cbDER;
                }
            }
            if (0 > Asn1UtilExtractContent( pb, cb, &cb, (const BYTE **)&pb))
                goto ExtractContentError;
        } else {
            cb = 0;
        }
    } else {
        assert (pcmi->dwFlags & CMSG_DETACHED_FLAG);
        if (!(pcmi->dwFlags & CMSG_DETACHED_FLAG))
            goto NonFinalNotDetachedError;
        pb = (PBYTE)pbData;
        cb = cbData;
    }
    if (!ICM_UpdateListDigest( pcmi->pHashList, pb, cb))
        goto UpdateDigestError;

    fRet = TRUE;
CommonReturn:
    PkiAsn1FreeEncoded(ICM_GetEncoder(), pbDER);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    PkiAsn1FreeInfo(pDec, DigestedData_PDU, pdd);
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(Asn1DecodeError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(GetCAPIError,CRYPT_E_UNKNOWN_ALGO)
SET_ERROR(NewHashListError,E_OUTOFMEMORY)
SET_ERROR(NewHashNodeError,E_OUTOFMEMORY)
SET_ERROR(ExtractContentError,CRYPT_E_UNEXPECTED_ENCODING)
SET_ERROR(NonFinalNotDetachedError,CRYPT_E_MSG_ERROR)
TRACE_ERROR(CreateHashError)                // error already set
TRACE_ERROR(UpdateDigestError)              // error already set
TRACE_ERROR(ReEncodeAsOctetDERError)        // error already set
}


//+-------------------------------------------------------------------------
//  Update for decoding a data message
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_UpdateDecodingData(
    IN PCRYPT_MSG_INFO  pcmi,
    IN const BYTE       *pbData,
    IN DWORD            cbData)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    OctetStringType     *poos = NULL;
    ASN1error_e         Asn1Err;
    ASN1decoding_t      pDec = ICM_GetDecoder();

    if (PHASE_FIRST_FINAL != pcmi->dwPhase)
        goto NonFirstFinalError;

    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&poos,
            OctetStringType_PDU,
            pbData,
            cbData)))
        goto Asn1DecodeError;
    pcmi->pvMsg = poos;

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    PkiAsn1FreeInfo(pDec, OctetStringType_PDU, poos);
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(Asn1DecodeError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(NonFirstFinalError,CRYPT_E_MSG_ERROR)
}


//+-------------------------------------------------------------------------
//  Write a buffer to a file
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_WriteBufToFile(
    LPCSTR      pszFileName,
    PBYTE       pbData,
    DWORD       cbData)
{
    BOOL        fRet;
    HANDLE      hFile;
    DWORD       cbWritten;

    if( INVALID_HANDLE_VALUE == (hFile = CreateFile( pszFileName, GENERIC_WRITE,
            0, NULL, CREATE_ALWAYS, 0, NULL))) {
        goto CreateFileError;
    }

    if (!WriteFile( hFile, pbData, cbData, &cbWritten, NULL) ||
            (cbWritten != cbData)) {
        goto WriteFileError;
    }

    CloseHandle( hFile);
    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(CreateFileError)
TRACE_ERROR(WriteFileError)
}


//+-------------------------------------------------------------------------
//  Update the content of a cryptographic message. Depending on how the
//  message was opened, the content is either encoded or decoded.
//
//  This function is repetitively called to append to the message content.
//  fFinal is set to identify the last update. On fFinal, the encode/decode
//  is completed. The encoded/decoded content and the decoded parameters
//  are valid until the open and all duplicated handles are closed.
//--------------------------------------------------------------------------
BOOL
WINAPI
#ifdef DEBUG_CRYPT_ASN1_MASTER
ICMTest_NewCryptMsgUpdate(
#else
CryptMsgUpdate(
#endif
    IN HCRYPTMSG    hCryptMsg,
    IN const BYTE   *pbData,
    IN DWORD        cbData,
    IN BOOL         fFinal)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    PCRYPT_MSG_INFO     pcmi = (PCRYPT_MSG_INFO)hCryptMsg;
    ContentInfo         *pci = NULL;
    ASN1error_e         Asn1Err;
    PCMSG_STREAM_INFO   pcsi = pcmi->pStreamInfo;

    DWORD dwExceptionCode;

    ICM_Lock( pcmi);        // Single thread access to HCRYPTMSG

  // Handle MappedFile Exceptions
  __try {

    if (!ICM_AdvanceMsgPhase( &pcmi->dwPhase, fFinal))
        goto AdvancePhaseError;

    if (pcmi->fEncoding) {
        if (!(((pcmi->dwFlags & CMSG_DETACHED_FLAG) &&
                    (PHASE_FIRST_ONGOING == pcmi->dwPhase)) ||
                (pcsi && (pcmi->dwPhase < PHASE_SECOND_ONGOING)) ||
                (PHASE_FIRST_FINAL == pcmi->dwPhase)))
            goto EncodingPhaseError;

        switch (pcmi->dwMsgType) {
        case CMSG_DATA:
            fRet = ICM_UpdateEncodingData(
                                pcmi,
                                pbData,
                                cbData,
                                fFinal);
            break;
        case CMSG_SIGNED:
            fRet = ICM_UpdateEncodingSignedData(
                                pcmi,
                                pbData,
                                cbData,
                                fFinal);
            break;
        case CMSG_ENVELOPED:
            fRet = ICM_UpdateEncodingEnvelopedData(
                                pcmi,
                                pbData,
                                cbData,
                                fFinal);
            break;
        case CMSG_HASHED:
            fRet = ICM_UpdateEncodingDigestedData(
                                pcmi,
                                pbData,
                                cbData,
                                fFinal);
            break;
        case CMSG_SIGNED_AND_ENVELOPED:
#if 0
            fRet = ICM_UpdateEncodingSignedAndEnvelopedData(
                                pcmi,
                                pbData,
                                cbData,
                                fFinal);
            break;
#endif
        case CMSG_ENCRYPTED:
            goto MessageTypeNotSupportedYet;
        default:
            goto InvalidMsgType;
        }
    } else {
        // decode
        ASN1decoding_t  pDec = ICM_GetDecoder();
        LONG            lth;
        PBYTE           pb;
        DWORD           cb;

        if (pcsi) {
            if (pcmi->dwPhase < PHASE_SECOND_ONGOING) {
                fRet = ICMS_UpdateDecoding( pcmi, pbData, cbData, fFinal);
                if (fRet)
                    goto CommonReturn;
                else
                    goto ErrorReturn;
            }
            // else
            //  streaming detached
        }

        if (PHASE_FIRST_ONGOING == pcmi->dwPhase)
            goto FirstOngoingDecodeError;

        if ((0 == (pcmi->dwFlags & CMSG_DETACHED_FLAG)) &&
                (PHASE_FIRST_FINAL != pcmi->dwPhase))
            goto SecondOngoingNonDetachedError;

        if ((PHASE_FIRST_FINAL == pcmi->dwPhase) &&
                (0 == pcmi->dwMsgType)) {
            if (0 != (Asn1Err = PkiAsn1Decode(
                    pDec,
                    (void **)&pci,
                    ContentInfoNC_PDU,
                    pbData,
                    cbData)))
                goto Asn1DecodeContentInfoError;
            if (0 == (lth = ICM_ObjIdToIndex( &pci->contentType)))
                goto InvalidMsgType;
            pcmi->dwMsgType = (DWORD)lth;
            pb = (PBYTE)pci->content.value;
            cb = pci->content.length;
        } else {
            pb = (PBYTE)pbData;
            cb = cbData;
        }
        switch (pcmi->dwMsgType) {
        case CMSG_DATA:
            fRet = ICM_UpdateDecodingData( pcmi, pb, cb);
            break;
        case CMSG_SIGNED:
            fRet = ICM_UpdateDecodingSignedData( pcmi, pb, cb);
            break;
        case CMSG_ENVELOPED:
            fRet = ICM_UpdateDecodingEnvelopedData( pcmi, pb, cb);
            break;
        case CMSG_HASHED:
            fRet = ICM_UpdateDecodingDigestedData( pcmi, pb, cb);
            break;
        case CMSG_SIGNED_AND_ENVELOPED:
        case CMSG_ENCRYPTED:
            goto MessageTypeNotSupportedYet;
        default:
            goto InvalidMsgType;
        }
    }

    if (!fRet)
        goto ErrorReturn;

  } __except(EXCEPTION_EXECUTE_HANDLER) {
    dwExceptionCode = GetExceptionCode();
    goto ExceptionError;
  }

CommonReturn:
    if (pci)
        PkiAsn1FreeInfo(ICM_GetDecoder(), ContentInfoNC_PDU, pci);

    ICM_Unlock( pcmi);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(EncodingPhaseError,CRYPT_E_MSG_ERROR)
SET_ERROR(FirstOngoingDecodeError,CRYPT_E_MSG_ERROR)
SET_ERROR(SecondOngoingNonDetachedError,CRYPT_E_MSG_ERROR)
SET_ERROR(MessageTypeNotSupportedYet,CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(InvalidMsgType,CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR_VAR(Asn1DecodeContentInfoError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(AdvancePhaseError)              // error already set
SET_ERROR_VAR(ExceptionError, dwExceptionCode)
}


BOOL
WINAPI
ICM_VerifySignature(
    IN HCRYPTHASH       hHash,
    IN HCRYPTKEY        hPubKey,
    IN DWORD            dwPubKeyAlgId,
    IN DWORD            dwPubKeyFlags,
    IN PBYTE            pbEncryptedDigest,
    IN DWORD            cbEncryptedDigest)
{
    BOOL fRet;
    BYTE rgbDssSignature[CERT_DSS_SIGNATURE_LEN];
    PBYTE pb = NULL;

    if (CALG_DSS_SIGN == dwPubKeyAlgId &&
            0 == (dwPubKeyFlags & CRYPT_OID_INHIBIT_SIGNATURE_FORMAT_FLAG)) {
        DWORD cbData;

        // Convert from ASN.1 sequence of two integers to the CSP signature
        // format.
        cbData = sizeof(rgbDssSignature);
        if (!CryptDecodeObject(
                X509_ASN_ENCODING,
                X509_DSS_SIGNATURE,
                pbEncryptedDigest,
                cbEncryptedDigest,
                0,                                  // dwFlags
                rgbDssSignature,
                &cbData
                ))
            goto DecodeError;
        pbEncryptedDigest = rgbDssSignature;
        assert(cbData == sizeof(rgbDssSignature));
        cbEncryptedDigest = sizeof(rgbDssSignature);
    } else {
        if (NULL == (pb = (PBYTE)ICM_AllocA( cbEncryptedDigest)))
            goto AllocError;
        ICM_ReverseCopy( pb, pbEncryptedDigest, cbEncryptedDigest);
        pbEncryptedDigest = pb;
    }

    fRet = CryptVerifySignature(
                hHash,
                pbEncryptedDigest,
                cbEncryptedDigest,
                hPubKey,
                NULL,           // pwszDescription
                0);             // dwFlags
CommonReturn:
    ICM_FreeA(pb);
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(DecodeError)
TRACE_ERROR(AllocError)
}


//+-------------------------------------------------------------------------
//  Verify a signature using the authenticated attributes blob
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_VerifySignatureAuthAttrBlob(
    IN PCRYPT_MSG_INFO  pcmi,
    IN CSignerNode      *pSignerNode,
    IN HCRYPTPROV       hCryptProv,
    IN HCRYPTKEY        hPubKey,
    IN DWORD            dwDigestAlgorithm,
    IN DWORD            dwPubKeyAlgorithm,
    IN DWORD            dwPubKeyFlags,
    IN PBYTE            pbEncryptedDigest,
    IN DWORD            cbEncryptedDigest)
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    SignerInfoWithAABlob    *psiaab = NULL;
    ASN1error_e             Asn1Err;
    ASN1decoding_t          pDec = ICM_GetDecoder();
    CRYPT_DATA_BLOB         DataBlob;
    HCRYPTHASH              hHashAttrBlob = NULL;
    PBYTE                   pb = NULL;
    DWORD                   cb;

    DataBlob = pSignerNode->Data()->blob;
    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&psiaab,
            SignerInfoWithAABlob_PDU,
            DataBlob.pbData,
            DataBlob.cbData)))
        goto Asn1DecodeSignerInfoWithAABlobError;

    cb = psiaab->authenticatedAttributes.length;
    if (NULL == (pb = (PBYTE)ICM_AllocA(cb)))
        goto AuthenticatedAttributesAllocError;
    memcpy( pb, psiaab->authenticatedAttributes.value, cb);
    // The encoded blob should contain 0xa0 ([0] IMPLICIT) as the tag,
    // but the tag needs to be 0x31 (SET OF) for the hash computation.
    if (*pb != (ICM_TAG_CONTEXT_0 | ICM_TAG_CONSTRUCTED))   // [0] IMPLICIT
        goto AuthAttrsTagError;
    *pb = ICM_TAG_SET;          // SET OF

    if (!ICM_GetBlobHash(
            hCryptProv,
            dwDigestAlgorithm,
            pb,
            cb,
            &hHashAttrBlob))
        goto HashAttrBlobError;

    if (!ICM_VerifySignature(
            hHashAttrBlob,
            hPubKey,
            dwPubKeyAlgorithm,
            dwPubKeyFlags,
            pbEncryptedDigest,
            cbEncryptedDigest))
        goto VerifySignatureError;
    fRet = TRUE;

CommonReturn:
    PkiAsn1FreeInfo(pDec, SignerInfoWithAABlob_PDU, psiaab);
    if (hHashAttrBlob)
        CryptDestroyHash( hHashAttrBlob);
    ICM_FreeA(pb);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(Asn1DecodeSignerInfoWithAABlobError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(AuthAttrsTagError,CRYPT_E_BAD_ENCODE)
TRACE_ERROR(AuthenticatedAttributesAllocError)      // error already set
TRACE_ERROR(HashAttrBlobError)                      // error already set
TRACE_ERROR(VerifySignatureError)                   // error already set
}


#ifdef CMS_PKCS7

BOOL
WINAPI
ICM_GetVerifySignatureStuff(
    IN DWORD            dwSignerType,
    void                *pvSigner,
    IN OUT HCRYPTPROV   *phCryptProv,
    OUT HCRYPTKEY       *phPubKey,
    OUT DWORD           *pdwPubKeyAlgId,
    OUT DWORD           *pdwPubKeyFlags)
{
    BOOL                    fRet;
    PCCRYPT_OID_INFO        pOIDInfo;
    HCRYPTPROV              hCryptProv;

    PCERT_PUBLIC_KEY_INFO   pPubKeyInfo;    // not allocated
    CERT_PUBLIC_KEY_INFO    PubKeyInfo;
    BYTE                    *pbAllocPubKeyPara = NULL;

    *pdwPubKeyAlgId = 0;
    *pdwPubKeyFlags = 0;

    switch (dwSignerType) {
        case CMSG_VERIFY_SIGNER_PUBKEY:
            pPubKeyInfo = (PCERT_PUBLIC_KEY_INFO) pvSigner;
            break;
        case CMSG_VERIFY_SIGNER_CHAIN:
            {
                PCCERT_CHAIN_CONTEXT pChain = (PCCERT_CHAIN_CONTEXT) pvSigner;

                // All chains have at least the leaf certificate context
                assert(pChain->cChain && pChain->rgpChain[0]->cElement);
                pvSigner =
                    (void *) pChain->rgpChain[0]->rgpElement[0]->pCertContext;
                dwSignerType = CMSG_VERIFY_SIGNER_CERT;
            }
            // fall through
        case CMSG_VERIFY_SIGNER_CERT:
            {
                PCCERT_CONTEXT pSigner = (PCCERT_CONTEXT) pvSigner;
                PCRYPT_OBJID_BLOB pPara;

                pPubKeyInfo = &pSigner->pCertInfo->SubjectPublicKeyInfo;
                pPara = &pPubKeyInfo->Algorithm.Parameters;

                // Check if the public key parameters were omitted
                // from the encoded certificate. If omitted, try
                // to use the certificate's CERT_PUBKEY_ALG_PARA_PROP_ID
                // property.
                if (0 == pPara->cbData ||
                        ICM_TAG_NULL_OCTETS == *pPara->pbData) {
                    DWORD cbData;

                    if (CertGetCertificateContextProperty(
                            pSigner,
                            CERT_PUBKEY_ALG_PARA_PROP_ID,
                            NULL,                       // pvData
                            &cbData) && 0 < cbData
                                    &&
                        (pbAllocPubKeyPara = (BYTE *) ICM_Alloc(
                            cbData))
                                    &&
                        CertGetCertificateContextProperty(
                            pSigner,
                            CERT_PUBKEY_ALG_PARA_PROP_ID,
                            pbAllocPubKeyPara,
                            &cbData)) {

                        PubKeyInfo = *pPubKeyInfo;
                        PubKeyInfo.Algorithm.Parameters.pbData =
                            pbAllocPubKeyPara;
                        PubKeyInfo.Algorithm.Parameters.cbData = cbData;
                        pPubKeyInfo = &PubKeyInfo;
                    }
                }
            }
            break;
        default:
            goto InvalidSignerType;
    }

    if (pOIDInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            pPubKeyInfo->Algorithm.pszObjId,
            CRYPT_PUBKEY_ALG_OID_GROUP_ID
            )) {
        DWORD cExtra = pOIDInfo->ExtraInfo.cbData / sizeof(DWORD);
        DWORD *pdwExtra = (DWORD *) pOIDInfo->ExtraInfo.pbData;

        *pdwPubKeyAlgId = pOIDInfo->Algid;
        if (1 <= cExtra)
            *pdwPubKeyFlags = pdwExtra[0];
    }

    hCryptProv = *phCryptProv;
    if (0 == hCryptProv) {
        hCryptProv = I_CryptGetDefaultCryptProv(*pdwPubKeyAlgId);
        if (0 == hCryptProv)
            goto GetDefaultCryptProvError;
        *phCryptProv = hCryptProv;
    }

    // import the signer's public key
    if (!CryptImportPublicKeyInfo(
            hCryptProv,
            X509_ASN_ENCODING,
            pPubKeyInfo,
            phPubKey))
        goto ImportKeyFailed;
    fRet = TRUE;
CommonReturn:
    ICM_Free(pbAllocPubKeyPara);
    return fRet;

ErrorReturn:
    fRet = FALSE;
    *phPubKey = 0;
    goto CommonReturn;
SET_ERROR(InvalidSignerType, E_INVALIDARG)
TRACE_ERROR(GetDefaultCryptProvError)           // error already set
TRACE_ERROR(ImportKeyFailed)                    // error already set
}

BOOL
WINAPI
ICM_FindSignerInfo(
    IN PCRYPT_MSG_INFO  pcmi,
    IN DWORD            dwIndex,
    OUT PVOID           *ppv);


//+-------------------------------------------------------------------------
//  Verify a signature
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ControlVerifySignatureEx(
    IN PCRYPT_MSG_INFO pcmi,
    IN DWORD dwFlags,
    IN PCMSG_CTRL_VERIFY_SIGNATURE_EX_PARA pPara
    )
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    SignerInfoWithBlobs     *psib = NULL;
    CSignerNode             *pSignerNode = NULL;
    HCRYPTHASH              hHashAttr = NULL;
    HCRYPTHASH              hHashDup = NULL;
    HCRYPTHASH              hHash = NULL;
    HCRYPTKEY               hPubKey = NULL;
    HCRYPTPROV              hCryptProv;         // doen't need to be released
    DWORD                   dwPubKeyAlgId;
    DWORD                   dwPubKeyFlags;
    PBYTE                   pbHash;
    ULONG                   cb;
    Any                     anyValue;
    DWORD                   cbMessageDigest;
    PBYTE                   pbMessageDigest;
    ASN1error_e             Asn1Err;
    ASN1decoding_t          pDec = ICM_GetDecoder();
    CRYPT_DATA_BLOB         DataBlob;
    CHashNode               *pnHash;
    PICM_HASH_INFO          pHashInfo;

    if (!ICM_FindSignerInfo(pcmi, pPara->dwSignerIndex, (PVOID *)&pSignerNode))
        goto FindSignerInfoError;

    DataBlob = pSignerNode->Data()->blob;
    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&psib,
            SignerInfoWithBlobs_PDU,
            DataBlob.pbData,
            DataBlob.cbData)))
        goto DecodeSignerInfoWithBlobsError;

    if (!ICM_FindHashNodeFromEncodedAlgo(
            pcmi->pHashList,
            (PCRYPT_DATA_BLOB)&psib->digestAlgorithm,
            &pnHash))
        goto GetHashNodeFromEncodedAlgoError;
    pHashInfo = pnHash->Data();

    if (pPara->hCryptProv)
        hCryptProv = pPara->hCryptProv;
    else if (pcmi->fDefaultCryptProv)
        hCryptProv = 0;
    else
        hCryptProv = pcmi->hCryptProv;

    if (!ICM_GetVerifySignatureStuff(
            pPara->dwSignerType,
            pPara->pvSigner,
            &hCryptProv,
            &hPubKey,
            &dwPubKeyAlgId,
            &dwPubKeyFlags)) goto GetSignatureStuffError;

    if (psib->bit_mask & authAttributes_present) {
        // find the message digest attr value
        if (!ICM_GetAttrValue(
                (Attributes *)&psib->authAttributes,    // same, except for NOCOPY
                &oidMessageDigest,
                &anyValue))
            goto FindAttrError;
        // find the message digest octets
        if (!Asn1UtilExtractContent(
#ifdef OSS_CRYPT_ASN1
                anyValue.value,
#else
                (const BYTE *) anyValue.value,
#endif  // OSS_CRYPT_ASN1
                anyValue.length,
                &cbMessageDigest,
                (const BYTE **)&pbMessageDigest))
            goto ExtractContentError;
        // get the hash value computed on the data
        if (!ICM_GetListHashValue( pnHash, &cb, &pbHash))
            goto GetHashValueError;
        // hash sizes equal?
        if (cb != cbMessageDigest)
            goto HashCompareSizeError;
        // hash octets equal?
        if (memcmp( pbMessageDigest, pbHash, cb))
            goto HashCompareValueError;
        // Now that we have verified the message digest octets,
        // get the hash of the authenticated attributes.
        // Should check the content type attribute as well.
        if (!ICM_GetAttrsHash(
                pHashInfo->dwAlgoCAPI,
                hCryptProv,
                (Attributes *)&psib->authAttributes,    // same, except for NOCOPY
                &hHashAttr))
            goto GetAuthAttrsHashError;
        hHash = hHashAttr;
    } else {
        if (!ICM_DupListHash( pnHash, hCryptProv, &hHashDup))
            goto DupListHashError;
        hHash = hHashDup;
    }

    // verify the hash, signature, and public key are consistent
    fRet = ICM_VerifySignature(
                hHash,
                hPubKey,
                dwPubKeyAlgId,
                dwPubKeyFlags,
                psib->encryptedDigest.value,
                psib->encryptedDigest.length);

    if (!fRet && hHashAttr) {
        // The hash of the authenticated attributes failed.
        // Maybe they hashed incorrectly-DER-encoded authenticated attributes
        // and gave us that encoding. Hash and verify the actual encoding of
        // the authattrs that they gave us. There is a bug in IE3.0 which hits
        // this path, due to a bug in the then-current OSS libraries.
        fRet = ICM_VerifySignatureAuthAttrBlob(
                        pcmi,
                        pSignerNode,
                        hCryptProv,
                        hPubKey,
                        pHashInfo->dwAlgoCAPI,
                        dwPubKeyAlgId,
                        dwPubKeyFlags,
                        psib->encryptedDigest.value,
                        psib->encryptedDigest.length);
    }
    if (!fRet)
        goto VerifySignatureError;

CommonReturn:
    PkiAsn1FreeInfo(pDec, SignerInfoWithBlobs_PDU, psib);

    if (hPubKey)
        CryptDestroyKey(hPubKey);
    if (hHashAttr)
        CryptDestroyHash( hHashAttr);
    if (hHashDup)
        CryptDestroyHash( hHashDup);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
//    if (hHash && (0 == (pcmi->dwFlags & CMSG_DETACHED_FLAG)))
//        CryptDestroyHash( hHash);
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(FindSignerInfoError)            // error already set

SET_ERROR(FindAttrError,CRYPT_E_AUTH_ATTR_MISSING)
SET_ERROR(HashCompareSizeError,CRYPT_E_HASH_VALUE)
SET_ERROR(HashCompareValueError,CRYPT_E_HASH_VALUE)
SET_ERROR(ExtractContentError,CRYPT_E_UNEXPECTED_ENCODING)
SET_ERROR_VAR(DecodeSignerInfoWithBlobsError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(GetHashValueError)                  // error already set
TRACE_ERROR(GetAuthAttrsHashError)              // error already set
TRACE_ERROR(GetSignatureStuffError)             // error already set
TRACE_ERROR(GetHashNodeFromEncodedAlgoError)    // error already set
TRACE_ERROR(DupListHashError)                   // error already set
TRACE_ERROR(VerifySignatureError)               // error already set
dwFlags;
}

//+-------------------------------------------------------------------------
//  Verify a signature
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ControlVerifySignature(
    IN PCRYPT_MSG_INFO pcmi,
    IN DWORD dwFlags,
    IN PCERT_INFO pci)
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    SignerInfoWithBlobs     *psib = NULL;
    CSignerNode             *pSignerNode = NULL;
    ULONG                   cbIssuer;
    PBYTE                   pb = NULL;
    ULONG                   cb;
    ASN1error_e             Asn1Err;
    ASN1decoding_t          pDec = ICM_GetDecoder();
    CRYPT_DATA_BLOB         DataBlob;
    CertIdentifier          *pOssCertId = NULL;
    IssuerAndSerialNumber   *pisn;              // not allocated
    DWORD                   dwSignerIndex;
    CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA ExPara;

    ZEROSTRUCT(ExPara);
    ExPara.cbSize = sizeof(ExPara);
    // ExPara.hCryptProv = 
    // ExPara.dwSignerIndex =
    ExPara.dwSignerType = CMSG_VERIFY_SIGNER_PUBKEY;
    ExPara.pvSigner = (void *) &pci->SubjectPublicKeyInfo;

    cb = pci->SerialNumber.cbData;
    if (NULL == (pb = (PBYTE)ICM_AllocA( cb)))
        goto SerialNumberAllocError;
    cbIssuer = pci->Issuer.cbData;

    switch (pcmi->dwMsgType) {
    case CMSG_SIGNED:
        {
            for (pSignerNode=pcmi->psdi->pSignerList->Head(), dwSignerIndex = 0;
                    pSignerNode;
                    pSignerNode = pSignerNode->Next(), dwSignerIndex++) {
                PkiAsn1FreeInfo(pDec, SignerInfoWithBlobs_PDU, psib);
                psib = NULL;
                PkiAsn1FreeInfo(pDec, CertIdentifier_PDU, pOssCertId);
                pOssCertId = NULL;
                DataBlob = pSignerNode->Data()->blob;
                if (0 != (Asn1Err = PkiAsn1Decode(
                        pDec,
                        (void **)&psib,
                        SignerInfoWithBlobs_PDU,
                        DataBlob.pbData,
                        DataBlob.cbData)))
                    goto DecodeSignerInfoWithBlobsError;
                if (0 != (Asn1Err = PkiAsn1Decode(
                        pDec,
                        (void **)&pOssCertId,
                        CertIdentifier_PDU,
                        (BYTE *) psib->sid.value,
                        psib->sid.length)))
                    goto DecodeCertIdentifierError;

                switch (pOssCertId->choice) {
                    case issuerAndSerialNumber_chosen:
                        pisn = &pOssCertId->u.issuerAndSerialNumber;
                        if (pisn->issuer.length != cbIssuer)
                            break;
                        if (0 != memcmp( pci->Issuer.pbData,
                                pisn->issuer.value, cbIssuer))
                            break;
                        // We need to add an integer method to compare
                        // big-endian internal to a little-endian external
                        // value.
                        if (pisn->serialNumber.length != cb)
                            break;
                        ICM_ReverseCopy( pb, pisn->serialNumber.value, cb);
                        if (0 == memcmp( pb, pci->SerialNumber.pbData, cb))
                            goto VerifyFoundSigner;
                        break;
                    case subjectKeyIdentifier_chosen:
                        // Go for it. See if we are able to verify using
                        // the public key for this signer
                        ExPara.dwSignerIndex = dwSignerIndex;
                        fRet = ICM_ControlVerifySignatureEx(
                            pcmi,
                            dwFlags,
                            &ExPara
                            );
                        if (fRet)
                            goto CommonReturn;
                        break;
                }
            }
            // No signer was found
            break;
        }

    case CMSG_SIGNED_AND_ENVELOPED:
        goto MessageTypeNotSupportedYet;

    default:
        goto InvalidMsgType;
    }

    assert(NULL == pSignerNode);
    goto SignerNotFound;

VerifyFoundSigner:
    ExPara.dwSignerIndex = dwSignerIndex;
    fRet = ICM_ControlVerifySignatureEx(
        pcmi,
        dwFlags,
        &ExPara
        );
    if (!fRet)
        goto ErrorReturn;

CommonReturn:
    ICM_FreeA( pb);
    PkiAsn1FreeInfo(pDec, SignerInfoWithBlobs_PDU, psib);
    PkiAsn1FreeInfo(pDec, CertIdentifier_PDU, pOssCertId);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(MessageTypeNotSupportedYet,CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(InvalidMsgType,CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR_VAR(DecodeCertIdentifierError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR_VAR(DecodeSignerInfoWithBlobsError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(SignerNotFound,CRYPT_E_SIGNER_NOT_FOUND)
TRACE_ERROR(SerialNumberAllocError)             // error already set
}

#else

BOOL
WINAPI
ICM_GetVerifySignatureStuff(
    IN PCERT_INFO       pci,
    IN OUT HCRYPTPROV   *phCryptProv,
    OUT HCRYPTKEY       *phPubKey,
    OUT DWORD           *pdwPubKeyAlgId,
    OUT DWORD           *pdwPubKeyFlags)
{
    BOOL                    fRet;
    PCCRYPT_OID_INFO        pOIDInfo;
    HCRYPTPROV              hCryptProv;

    *pdwPubKeyAlgId = 0;
    *pdwPubKeyFlags = 0;
    if (pOIDInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            pci->SubjectPublicKeyInfo.Algorithm.pszObjId,
            CRYPT_PUBKEY_ALG_OID_GROUP_ID
            )) {
        DWORD cExtra = pOIDInfo->ExtraInfo.cbData / sizeof(DWORD);
        DWORD *pdwExtra = (DWORD *) pOIDInfo->ExtraInfo.pbData;

        *pdwPubKeyAlgId = pOIDInfo->Algid;
        if (1 <= cExtra)
            *pdwPubKeyFlags = pdwExtra[0];
    }

    hCryptProv = *phCryptProv;
    if (0 == hCryptProv) {
        hCryptProv = I_CryptGetDefaultCryptProv(*pdwPubKeyAlgId);
        if (0 == hCryptProv)
            goto GetDefaultCryptProvError;
        *phCryptProv = hCryptProv;
    }

    // import the signer's public key
    if (!CryptImportPublicKeyInfo(
            hCryptProv,
            X509_ASN_ENCODING,
            &pci->SubjectPublicKeyInfo,
            phPubKey))
        goto ImportKeyFailed;
    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    *phPubKey = 0;
    goto CommonReturn;
TRACE_ERROR(GetDefaultCryptProvError)           // error already set
TRACE_ERROR(ImportKeyFailed)                    // error already set
}


//+-------------------------------------------------------------------------
//  Verify a signature
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ControlVerifySignature(
    IN PCRYPT_MSG_INFO pcmi,
    IN DWORD dwFlags,
    IN PCERT_INFO pci)
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    SignerInfoWithBlobs     *psib = NULL;
    CSignerNode             *pSignerNode = NULL;
    SignerInfo              *psi = NULL;
    Any                     *pc;            // &content
    HCRYPTHASH              hHashAttr = NULL;
    HCRYPTHASH              hHashDup = NULL;
    HCRYPTHASH              hHash = NULL;
    HCRYPTKEY               hPubKey = NULL;

    HCRYPTPROV              hCryptProv;
    DWORD                   dwPubKeyAlgId;
    DWORD                   dwPubKeyFlags;

    ULONG                   cbIssuer;
    PBYTE                   pbHash;
    PBYTE                   pb = NULL;
    ULONG                   cb;
    Any                     anyValue;
    DWORD                   cbMessageDigest;
    PBYTE                   pbMessageDigest;
    ASN1error_e             Asn1Err;
    ASN1decoding_t          pDec = ICM_GetDecoder();
    CRYPT_DATA_BLOB         DataBlob;
    IssuerAndSerialNumber   *pisn = NULL;
    CHashNode               *pnHash;
    PICM_HASH_INFO          pHashInfo;


    switch (pcmi->dwMsgType) {
    case CMSG_SIGNED:
        {
            pc = (Any *)&pcmi->psdi->pci->content;
            cb = pci->SerialNumber.cbData;
            if (NULL == (pb = (PBYTE)ICM_AllocA( cb)))
                goto SerialNumberAllocError;
            cbIssuer = pci->Issuer.cbData;
            for (pSignerNode=pcmi->psdi->pSignerList->Head();
                    pSignerNode;
                    pSignerNode = pSignerNode->Next()) {
                PkiAsn1FreeInfo(pDec, SignerInfoWithBlobs_PDU, psib);
                psib = NULL;
                PkiAsn1FreeInfo(pDec, IssuerAndSerialNumber_PDU, pisn);
                pisn = NULL;

                DataBlob = pSignerNode->Data()->blob;
                if (0 != (Asn1Err = PkiAsn1Decode(
                        pDec,
                        (void **)&psib,
                        SignerInfoWithBlobs_PDU,
                        DataBlob.pbData,
                        DataBlob.cbData)))
                    goto DecodeSignerInfoWithBlobsError;
                if (0 != (Asn1Err = PkiAsn1Decode(
                        pDec,
                        (void **)&pisn,
                        IssuerAndSerialNumber_PDU,
                        (BYTE *) psib->issuerAndSerialNumber.value,
                        psib->issuerAndSerialNumber.length)))
                    goto DecodeIssuerAndSerialNumberError;
                if (pisn->issuer.length != cbIssuer)
                    continue;
                if (0 != memcmp( pci->Issuer.pbData, pisn->issuer.value, cbIssuer))
                    continue;
                // We need to add an integer method to compare big-endian
                // internal to a little-endian external value.
                if (pisn->serialNumber.length != cb)
                    continue;
                ICM_ReverseCopy( pb, pisn->serialNumber.value, cb);
                if (0 != memcmp( pb, pci->SerialNumber.pbData, cb))
                    continue;
                break;
            }
            // The matching signer (if found) is in psib
            // If no signer found, pSignerNode == NULL
            ICM_FreeA( pb);
            pb = NULL;
            break;
        }

    case CMSG_SIGNED_AND_ENVELOPED:
        goto MessageTypeNotSupportedYet;

    default:
        goto InvalidMsgType;
    }

    if (NULL == pSignerNode)
        goto SignerNotFound;
    if (!ICM_FindHashNodeFromEncodedAlgo(
            pcmi->pHashList,
            (PCRYPT_DATA_BLOB)&psib->digestAlgorithm,
            &pnHash))
        goto GetHashNodeFromEncodedAlgoError;
    pHashInfo = pnHash->Data();


    if (pcmi->fDefaultCryptProv)
        hCryptProv = 0;
    else
        hCryptProv = pcmi->hCryptProv;
    if (!ICM_GetVerifySignatureStuff(
            pci,
            &hCryptProv,
            &hPubKey,
            &dwPubKeyAlgId,
            &dwPubKeyFlags)) goto GetSignatureStuffError;

    if (psib->bit_mask & authAttributes_present) {
        // find the message digest attr value
        if (!ICM_GetAttrValue(
                (Attributes *)&psib->authAttributes,    // same, except for NOCOPY
                &oidMessageDigest,
                &anyValue))
            goto FindAttrError;
        // find the message digest octets
        if (!Asn1UtilExtractContent(
                (BYTE *) anyValue.value,
                anyValue.length,
                &cbMessageDigest,
                (const BYTE **)&pbMessageDigest))
            goto ExtractContentError;
        // get the hash value computed on the data
        if (!ICM_GetListHashValue( pnHash, &cb, &pbHash))
            goto GetHashValueError;
        // hash sizes equal?
        if (cb != cbMessageDigest)
            goto HashCompareSizeError;
        // hash octets equal?
        if (memcmp( pbMessageDigest, pbHash, cb))
            goto HashCompareValueError;
        // Now that we have verified the message digest octets,
        // get the hash of the authenticated attributes.
        // Should check the content type attribute as well.
        if (!ICM_GetAttrsHash(
                pHashInfo->dwAlgoCAPI,
                hCryptProv,
                (Attributes *)&psib->authAttributes,    // same, except for NOCOPY
                &hHashAttr))
            goto GetAuthAttrsHashError;
        hHash = hHashAttr;
    } else {
        if (!ICM_DupListHash( pnHash, hCryptProv, &hHashDup))
            goto DupListHashError;
        hHash = hHashDup;
    }

    // verify the hash, signature, and public key are consistent
    fRet = ICM_VerifySignature(
                hHash,
                hPubKey,
                dwPubKeyAlgId,
                dwPubKeyFlags,
                psib->encryptedDigest.value,
                psib->encryptedDigest.length);

    if (!fRet && hHashAttr) {
        // The hash of the authenticated attributes failed.
        // Maybe they hashed incorrectly-DER-encoded authenticated attributes
        // and gave us that encoding. Hash and verify the actual encoding of
        // the authattrs that they gave us. There is a bug in IE3.0 which hits
        // this path, due to a bug in the then-current OSS libraries.
        fRet = ICM_VerifySignatureAuthAttrBlob(
                        pcmi,
                        pSignerNode,
                        hCryptProv,
                        hPubKey,
                        pHashInfo->dwAlgoCAPI,
                        dwPubKeyAlgId,
                        dwPubKeyFlags,
                        psib->encryptedDigest.value,
                        psib->encryptedDigest.length);
    }
    if (!fRet)
        goto VerifySignatureError;

CommonReturn:
    ICM_FreeA( pb);
    PkiAsn1FreeInfo(pDec, SignerInfoWithBlobs_PDU, psib);
    PkiAsn1FreeInfo(pDec, IssuerAndSerialNumber_PDU, pisn);
    if (hPubKey)
        CryptDestroyKey(hPubKey);
    if (hHashAttr)
        CryptDestroyHash( hHashAttr);
    if (hHashDup)
        CryptDestroyHash( hHashDup);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
//    if (hHash && (0 == (pcmi->dwFlags & CMSG_DETACHED_FLAG)))
//        CryptDestroyHash( hHash);
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(FindAttrError,CRYPT_E_AUTH_ATTR_MISSING)
SET_ERROR(HashCompareSizeError,CRYPT_E_HASH_VALUE)
SET_ERROR(HashCompareValueError,CRYPT_E_HASH_VALUE)
SET_ERROR(MessageTypeNotSupportedYet,CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(InvalidMsgType,CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(ExtractContentError,CRYPT_E_UNEXPECTED_ENCODING)
SET_ERROR_VAR(DecodeSignerInfoWithBlobsError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR_VAR(DecodeIssuerAndSerialNumberError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(SignerNotFound,CRYPT_E_SIGNER_NOT_FOUND)
TRACE_ERROR(SerialNumberAllocError)             // error already set
TRACE_ERROR(GetHashValueError)                  // error already set
TRACE_ERROR(GetAuthAttrsHashError)              // error already set
TRACE_ERROR(GetSignatureStuffError)             // error already set
TRACE_ERROR(GetHashNodeFromEncodedAlgoError)    // error already set
TRACE_ERROR(DupListHashError)                   // error already set
TRACE_ERROR(VerifySignatureError)               // error already set
dwFlags;
}
#endif  // CMS_PKCS7


//+-------------------------------------------------------------------------
//  Verify a digest
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ControlVerifyDigest(
    IN PCRYPT_MSG_INFO pcmi,
    IN DWORD dwFlags)
{
    DWORD           dwError = ERROR_SUCCESS;
    BOOL            fRet;
    BYTE            *pbComputedDigest = NULL;
    DWORD           cbComputedDigest = 0;
    BYTE            *pbDigest = NULL;
    DWORD           cbDigest = 0;

    if (CMSG_HASHED != pcmi->dwMsgType)
        goto InvalidMsgTypeError;

    // get the computed digest
    CryptMsgGetParam(
                    (HCRYPTMSG)pcmi,
                    CMSG_COMPUTED_HASH_PARAM,
                    0,                      // dwIndex
                    NULL,                   // pvData
                    &cbComputedDigest);
    if (0 == cbComputedDigest)
        goto EmptyComputedDigestError;
    if (NULL == (pbComputedDigest = (PBYTE)ICM_AllocA( cbComputedDigest)))
        goto ComputedDigestAllocError;
    if (!CryptMsgGetParam(
                    (HCRYPTMSG)pcmi,
                    CMSG_COMPUTED_HASH_PARAM,
                    0,                      // dwIndex
                    pbComputedDigest,
                    &cbComputedDigest))
        goto GetComputedDigestError;

    // get the digest from the message
    CryptMsgGetParam(
                    (HCRYPTMSG)pcmi,
                    CMSG_HASH_DATA_PARAM,
                    0,                      // dwIndex
                    NULL,                   // pvData
                    &cbDigest);
    if (0 == cbDigest)
        goto EmptyDigestError;
    if (NULL == (pbDigest = (PBYTE)ICM_AllocA( cbDigest)))
        goto DigestAllocError;
    if (!CryptMsgGetParam(
                    (HCRYPTMSG)pcmi,
                    CMSG_HASH_DATA_PARAM,
                    0,                      // dwIndex
                    pbDigest,
                    &cbDigest))
        goto GetDigestError;

    // compare the computed digest to the digest from the message
    if (cbComputedDigest != cbDigest)
        goto DigestSizesUnequalError;
    if (0 != memcmp( pbDigest, pbComputedDigest, cbDigest))
        goto DigestsDifferError;

    fRet = TRUE;

CommonReturn:
    ICM_FreeA( pbComputedDigest);
    ICM_FreeA( pbDigest);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(EmptyComputedDigestError)   // error already set
TRACE_ERROR(ComputedDigestAllocError)   // error already set
TRACE_ERROR(GetComputedDigestError)     // error already set
TRACE_ERROR(EmptyDigestError)           // error already set
TRACE_ERROR(DigestAllocError)           // error already set
TRACE_ERROR(GetDigestError)             // error already set
SET_ERROR(DigestSizesUnequalError,CRYPT_E_HASH_VALUE)
SET_ERROR(DigestsDifferError,CRYPT_E_HASH_VALUE)
SET_ERROR(InvalidMsgTypeError,CRYPT_E_INVALID_MSG_TYPE)
dwFlags;
}

#ifdef CMS_PKCS7

CmsRecipientInfos *
WINAPI
ICM_GetDecodedCmsRecipientInfos(
    IN PCRYPT_MSG_INFO pcmi
    )
{
    PCMSG_STREAM_INFO pcsi = pcmi->pStreamInfo;
    CmsRecipientInfos *pris = NULL;

    if (pcmi->fEncoding)
        goto InvalidMsgType;
    if (pcsi && (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_RECIPINFOS)))
        goto StreamMsgNotReadyError;
    if (NULL == pcmi->pvMsg)
        goto NotUpdated;

    switch (pcmi->dwMsgType) {
        case CMSG_ENVELOPED:
            pris = &((CmsEnvelopedData *)pcmi->pvMsg)->recipientInfos;
            break;

        case CMSG_SIGNED_AND_ENVELOPED:
            goto MessageTypeNotSupportedYet;

        default:
            goto InvalidMsgType;
    }

CommonReturn:
    return pris;

ErrorReturn:
    goto CommonReturn;

SET_ERROR(InvalidMsgType, CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(NotUpdated, CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(StreamMsgNotReadyError, CRYPT_E_STREAM_MSG_NOT_READY)
SET_ERROR(MessageTypeNotSupportedYet, CRYPT_E_INVALID_MSG_TYPE)
}

BOOL
WINAPI
ICM_ConvertPkcsToCmsRecipientIndex(
    IN PCRYPT_MSG_INFO pcmi,
    IN DWORD dwPkcsIndex,
    OUT DWORD *pdwCmsIndex
    )
{
    BOOL fRet;
    CmsRecipientInfos *pris;
    CmsRecipientInfo *pri;
    DWORD dwCount;
    DWORD dwCmsIndex;
    DWORD i;

    if (NULL == (pris = ICM_GetDecodedCmsRecipientInfos(pcmi)))
        goto GetDecodedCmsRecipientsError;

    dwCount = pris->count;
    pri = pris->value;
    dwCmsIndex = dwPkcsIndex;
    i = 0;
    for ( ; 0 < dwCount; dwCount--, pri++) {
        if (keyTransRecipientInfo_chosen != pri->choice) {
            // Advance past non KeyTrans recipients
            dwCmsIndex++;
        } else {
            if (i == dwPkcsIndex)
                goto SuccessReturn;
            else
                i++;
        }
    }

    goto IndexTooBig;

SuccessReturn:
    fRet = TRUE;
CommonReturn:
    *pdwCmsIndex = dwCmsIndex;
    return fRet;

ErrorReturn:
    fRet = FALSE;
    dwCmsIndex = 0xFFFFFFFF;
    goto CommonReturn;
TRACE_ERROR(GetDecodedCmsRecipientsError)
SET_ERROR(IndexTooBig, CRYPT_E_INVALID_INDEX)
}

BOOL
WINAPI
ICM_ConvertCmsToPkcsRecipientIndex(
    IN PCRYPT_MSG_INFO pcmi,
    IN DWORD dwCmsIndex,
    OUT DWORD *pdwPkcsIndex
    )
{
    BOOL fRet;
    CmsRecipientInfos *pris;
    CmsRecipientInfo *pri;
    DWORD dwCount;
    DWORD dwPkcsIndex;
    DWORD i;

    if (NULL == (pris = ICM_GetDecodedCmsRecipientInfos(pcmi)))
        goto GetDecodedCmsRecipientsError;

    dwCount = pris->count;
    if (dwCmsIndex >= dwCount)
        goto InvalidCmsIndex;
    pri = &pris->value[dwCmsIndex];
    if (keyTransRecipientInfo_chosen != pri->choice)
        goto InvalidPkcsIndex;

    pri = pris->value;
    dwPkcsIndex = 0;
    for (i = 0; i < dwCmsIndex; i++, pri++) {
        if (keyTransRecipientInfo_chosen == pri->choice)
            dwPkcsIndex++;
    }

    fRet = TRUE;
CommonReturn:
    *pdwPkcsIndex = dwPkcsIndex;
    return fRet;

ErrorReturn:
    fRet = FALSE;
    dwPkcsIndex = 0xFFFFFFFF;
    goto CommonReturn;

TRACE_ERROR(GetDecodedCmsRecipientsError)
SET_ERROR(InvalidCmsIndex, CRYPT_E_INVALID_INDEX)
SET_ERROR(InvalidPkcsIndex, CRYPT_E_INVALID_INDEX)
}

BOOL
WINAPI
ICM_GetPkcsRecipientCount(
    IN PCRYPT_MSG_INFO pcmi,
    OUT DWORD *pdwPkcsCount
    )
{
    BOOL fRet;
    CmsRecipientInfos *pris;
    CmsRecipientInfo *pri;
    DWORD dwCount;
    DWORD dwPkcsCount;

    if (NULL == (pris = ICM_GetDecodedCmsRecipientInfos(pcmi)))
        goto GetDecodedCmsRecipientsError;

    dwCount = pris->count;
    pri = pris->value;
    dwPkcsCount = 0;
    for ( ; 0 < dwCount; dwCount--, pri++) {
        if (keyTransRecipientInfo_chosen == pri->choice)
            dwPkcsCount++;
    }

    fRet = TRUE;
CommonReturn:
    *pdwPkcsCount = dwPkcsCount;
    return fRet;

ErrorReturn:
    dwPkcsCount = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetDecodedCmsRecipientsError)
}


typedef BOOL (WINAPI *PFN_ICM_IMPORT_CONTENT_ENCRYPT_KEY) (
    IN PCRYPT_ALGORITHM_IDENTIFIER pContentEncryptionAlgorithm,
    IN void *pvDecryptPara,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT HCRYPTKEY *phContentEncryptKey
    );

BOOL
WINAPI
ICM_ImportContentEncryptKey(
    IN PCRYPT_ALGORITHM_IDENTIFIER pContentEncryptionAlgorithm,
    IN void *pvDecryptPara,
    IN HCRYPTOIDFUNCADDR hImportContentEncryptKeyFuncSet,
    IN LPSTR pszKeyEncryptionOID,
    IN PFN_ICM_IMPORT_CONTENT_ENCRYPT_KEY pDefaultImportContentEncryptKey,
    OUT HCRYPTKEY *phContentEncryptKey
    )
{

    BOOL fRet;
    DWORD i;

#define IMPORT_CONTENT_ENCRYPT_OID_CNT  3
    LPSTR rgpszOID[IMPORT_CONTENT_ENCRYPT_OID_CNT] = {
        NULL,                       // pszKeyEncryptOID!pszContentEncryptOID
        pszKeyEncryptionOID,
        pContentEncryptionAlgorithm->pszObjId
    };

    DWORD cch;
    LPSTR psz;

    cch = strlen(rgpszOID[1]) + 1 + strlen(rgpszOID[2]) + 1;

    if (NULL == (psz = (LPSTR) ICM_Alloc(cch))) {
        *phContentEncryptKey = 0;
        return FALSE;
    }
    strcpy(psz, rgpszOID[1]);
    strcat(psz, "!");
    strcat(psz, rgpszOID[2]);
    rgpszOID[0] = psz;

    for (i = 0; i < IMPORT_CONTENT_ENCRYPT_OID_CNT; i++) {
        void *pvFuncAddr;
        HCRYPTOIDFUNCADDR hFuncAddr;

        if (CryptGetOIDFunctionAddress(
                hImportContentEncryptKeyFuncSet,
                X509_ASN_ENCODING,
                rgpszOID[i],
                0,                      // dwFlags
                &pvFuncAddr,
                &hFuncAddr)) {
            fRet = ((PFN_ICM_IMPORT_CONTENT_ENCRYPT_KEY) pvFuncAddr)(
                pContentEncryptionAlgorithm,
                pvDecryptPara,
                0,                              // dwFlags
                NULL,                           // pvReserved
                phContentEncryptKey
                );
            CryptFreeOIDFunctionAddress(hFuncAddr, 0);

            if (fRet || E_NOTIMPL != GetLastError())
                goto CommonReturn;
        }
    }

    fRet = pDefaultImportContentEncryptKey(
        pContentEncryptionAlgorithm,
        pvDecryptPara,
        0,                              // dwFlags
        NULL,                           // pvReserved
        phContentEncryptKey
        );

CommonReturn:
    ICM_Free(rgpszOID[0]);
    return fRet;
}

HCRYPTKEY
WINAPI
ICM_ImportEncryptedKey(
    IN PCRYPT_ALGORITHM_IDENTIFIER pContentEncryptionAlgorithm,
    IN HCRYPTPROV hCryptProv,
    IN HCRYPTKEY hUserKey,
    IN ALG_ID aiEncAlg,
    IN BYTE bType,
    IN PCRYPT_DATA_BLOB pEncryptedKey
    )
{
    BOOL fRet;
    DWORD dwError;
    HCRYPTKEY hEncryptKey = 0;
    DWORD dwAlgIdEncrypt;
    DWORD dwBitLen;
    BYTE rgbIV[IV_MAX_LENGTH];
    DWORD cbIV;

    PBYTE pbCspKey = NULL;
    DWORD cbCspKey;
    PUBLICKEYSTRUC *ppks;
    PSIMPLEBLOBHEADER psbh;

    if (!ICM_GetEncryptParameters(
            pContentEncryptionAlgorithm,
            &dwAlgIdEncrypt,
            &dwBitLen,
            rgbIV,
            &cbIV))
        goto GetEncryptParametersError;

    cbCspKey = sizeof(PUBLICKEYSTRUC) + sizeof(SIMPLEBLOBHEADER) +
        pEncryptedKey->cbData;
    if (NULL == (pbCspKey = (PBYTE)ICM_AllocA( cbCspKey)))
        goto CspKeyAllocError;
    ppks = (PUBLICKEYSTRUC *)pbCspKey;
    ppks->bType = bType;
    ppks->bVersion = CUR_BLOB_VERSION;
    ppks->reserved = 0;
    ppks->aiKeyAlg = dwAlgIdEncrypt;
    psbh = (PSIMPLEBLOBHEADER)(ppks + 1);
    psbh->aiEncAlg = aiEncAlg;
    if (SYMMETRICWRAPKEYBLOB == bType)
        memcpy( (PBYTE)(psbh+1), pEncryptedKey->pbData,
            pEncryptedKey->cbData);
    else
        ICM_ReverseCopy( (PBYTE)(psbh+1), pEncryptedKey->pbData,
            pEncryptedKey->cbData);

    fRet = CryptImportKey(
            hCryptProv,
            pbCspKey,
            cbCspKey,
            hUserKey,
            CRYPT_NO_SALT,       // dwFlags
            &hEncryptKey);
    if (!fRet && SYMMETRICWRAPKEYBLOB != bType) {
        dwError = GetLastError();
        if (hUserKey) {
            if (NTE_BAD_FLAGS == dwError)
                // Try without salt. Previous versions didn't support
                // CRYPT_NO_SALT flag
                fRet = CryptImportKey(
                    hCryptProv,
                    pbCspKey,
                    cbCspKey,
                    hUserKey,
                    0,       // dwFlags
                    &hEncryptKey);
            if (!fRet) {
                // Try without using the specified user key. Many versions of
                // the CSP don't allow a non-null hUserKey parameter.
                fRet = CryptImportKey(
                    hCryptProv,
                    pbCspKey,
                    cbCspKey,
                    0,                  // hUserKey
                    CRYPT_NO_SALT,      // dwFlags
                    &hEncryptKey);
                if (!fRet)
                    dwError = GetLastError();
            }
        }

        if (!fRet && NTE_BAD_FLAGS == dwError)
            // Try without user key and without CRYPT_NO_SALT flag
            fRet = CryptImportKey(
                hCryptProv,
                pbCspKey,
                cbCspKey,
                0,          // hUserKey
                0,          // dwFlags
                &hEncryptKey);

        if (!fRet && 2 >= pContentEncryptionAlgorithm->Parameters.cbData) {
            // Try importing as an NT4.0 SP3 encypted key that wasn't byte
            // reversed and with zero salt.
            memcpy( (PBYTE)(psbh+1), pEncryptedKey->pbData,
                pEncryptedKey->cbData);
            fRet = CryptImportKey(
                hCryptProv,
                pbCspKey,
                cbCspKey,
                hUserKey,
                0,          // dwFlags
                &hEncryptKey);
            if (!fRet && hUserKey) {
                // Try without using the specified user key.
                fRet = CryptImportKey(
                    hCryptProv,
                    pbCspKey,
                    cbCspKey,
                    0,          // hUserKey
                    0,          // dwFlags
                    &hEncryptKey);
            }
        }
    }

    if (!fRet) {
        hEncryptKey = 0;
        goto ImportKeyFailed;
    }

    if (CALG_RC2 == dwAlgIdEncrypt && 0 != dwBitLen)
        // Silently ignore any errors. Not supported in earlier versions
        CryptSetKeyParam(
            hEncryptKey,
            KP_EFFECTIVE_KEYLEN,
            (PBYTE) &dwBitLen,
            0);                 // dwFlags

    if (0 != cbIV) {
        if (CALG_RC4 == dwAlgIdEncrypt) {
            // For RC4, set the SALT, not the IV
            BOOL fRC4Salt = TRUE;

            if (IV_LENGTH == cbIV) {
                // Old implementations of 40 bit or 128 bit RC4 set the
                // IV which was ignored and didn't set the salt.

                // Get the bit length of the imported key and don't
                // set the salt for 40 or 128 bit RC4.

                DWORD dwRC4BitLen;
                DWORD cbKeyParamLen;

                dwRC4BitLen = 0;
                cbKeyParamLen = sizeof(dwRC4BitLen);
                if (!CryptGetKeyParam(
                        hEncryptKey,
                        KP_KEYLEN,
                        (PBYTE) &dwRC4BitLen,
                        &cbKeyParamLen,
                        0                       // dwFlags
                        ) || 40 == dwRC4BitLen || 128 == dwRC4BitLen)
                    fRC4Salt = FALSE;
            }

            if (fRC4Salt) {
                CRYPT_DATA_BLOB SaltBlob;
                SaltBlob.pbData = rgbIV;
                SaltBlob.cbData = cbIV;

                if (!CryptSetKeyParam(
                        hEncryptKey,
                        KP_SALT_EX,
                        (PBYTE) &SaltBlob,
                        0))                 // dwFlags
                    goto SetSaltExError;
            }
        } else {
            if (!CryptSetKeyParam(
                    hEncryptKey,
                    KP_IV,
                    rgbIV,
                    0))                 // dwFlags
                goto SetIVError;
        }
    }

CommonReturn:
    ICM_FreeA(pbCspKey);
    return hEncryptKey;

ErrorReturn:
    if (hEncryptKey) {
        dwError = GetLastError();
        CryptDestroyKey(hEncryptKey);
        SetLastError(dwError);
        hEncryptKey = 0;
    }
    goto CommonReturn;
TRACE_ERROR(GetEncryptParametersError)
TRACE_ERROR(ImportKeyFailed)
TRACE_ERROR(CspKeyAllocError)
TRACE_ERROR(SetSaltExError)
TRACE_ERROR(SetIVError)
}

//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
BOOL
WINAPI
#ifdef DEBUG_CRYPT_ASN1
ICMTest_DefaultImportKeyTrans(
#else
ICM_DefaultImportKeyTrans(
#endif
    IN PCRYPT_ALGORITHM_IDENTIFIER pContentEncryptionAlgorithm,
    IN PCMSG_CTRL_KEY_TRANS_DECRYPT_PARA pKeyTransDecryptPara,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT HCRYPTKEY *phContentEncryptKey
    )
{
    DWORD dwError = ERROR_SUCCESS;
    BOOL fRet;
    HCRYPTKEY hUserKey = 0;
    PCMSG_KEY_TRANS_RECIPIENT_INFO pri = pKeyTransDecryptPara->pKeyTrans;
    HCRYPTPROV hCryptProv = pKeyTransDecryptPara->hCryptProv;

    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr;

    if (CryptGetOIDFunctionAddress(
            hOldStyleImportEncryptKeyFuncSet,
            X509_ASN_ENCODING,
            pContentEncryptionAlgorithm->pszObjId,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr)) {
        if ((void *) ICM_DefaultImportEncryptKey == pvFuncAddr)
            fRet = FALSE;
#ifdef DEBUG_CRYPT_ASN1
        else if (0 == (ICMTest_GetDebugCryptAsn1Flags() &
                            DEBUG_OSS_CRYPT_ASN1_SAME_ENCRYPT_FLAG))
            fRet = FALSE;
#endif // DEBUG_CRYPT_ASN1
        else
            fRet = ((PFN_CMSG_IMPORT_ENCRYPT_KEY) pvFuncAddr)(
                hCryptProv,
                pKeyTransDecryptPara->dwKeySpec,
                pContentEncryptionAlgorithm,
                &pri->KeyEncryptionAlgorithm,
                pri->EncryptedKey.pbData,
                pri->EncryptedKey.cbData,
                phContentEncryptKey);
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);

        if (fRet)
            return TRUE;
    }

    if (0 != pKeyTransDecryptPara->dwKeySpec) {
        // Get private key to use.
        if (!CryptGetUserKey(
                hCryptProv,
                pKeyTransDecryptPara->dwKeySpec,
                &hUserKey)) {
            hUserKey = 0;
            goto GetUserKeyFailed;
        }
    }
    // else
    //  Use the provider's default private key for decrypting

    if (0 == (*phContentEncryptKey = ICM_ImportEncryptedKey(
            pContentEncryptionAlgorithm,
            hCryptProv,
            hUserKey,
            CALG_RSA_KEYX,
            SIMPLEBLOB,
            &pri->EncryptedKey
            )))
        goto ImportEncryptedKeyError;

    fRet = TRUE;
CommonReturn:
    if (hUserKey)
        CryptDestroyKey(hUserKey);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetUserKeyFailed)
TRACE_ERROR(ImportEncryptedKeyError)
}

//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultImportKeyAgree(
    IN PCRYPT_ALGORITHM_IDENTIFIER pContentEncryptionAlgorithm,
    IN PCMSG_CTRL_KEY_AGREE_DECRYPT_PARA pKeyAgreeDecryptPara,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT HCRYPTKEY *phContentEncryptKey
    )
{
    BOOL fRet;
    DWORD dwError = ERROR_SUCCESS;
    HCRYPTPROV hKeyAgreeProv = 0;           // Doesn't need to be released
    HCRYPTKEY hMyKey = 0;
    HCRYPTKEY hAgreeKey = 0;
    DWORD cbP;
    DWORD dwKeySpec;
    LPSTR pszWrapOID = NULL;
    DWORD dwAlgIdWrap;
    DWORD dwBitLen;
    PCMSG_KEY_AGREE_RECIPIENT_INFO pri = pKeyAgreeDecryptPara->pKeyAgree;

    hKeyAgreeProv = pKeyAgreeDecryptPara->hCryptProv;

    dwKeySpec = pKeyAgreeDecryptPara->dwKeySpec;
    if (0 == dwKeySpec)
        dwKeySpec = AT_KEYEXCHANGE;

    // Get my private Diffie Hellman key
    if (!CryptGetUserKey(
            hKeyAgreeProv,
            pKeyAgreeDecryptPara->dwKeySpec,
            &hMyKey)) {
        hMyKey = 0;
        goto GetMyKeyFailed;
    }

    // Get the length of P
    cbP = 0;
    if (!CryptGetKeyParam(
            hMyKey,
            KP_P,
            NULL,               // pbData
            &cbP,
            0                   // dwFlags
            ) || 0 == cbP)
        goto GetPLengthError;

    if (!ICM_GetDhWrapEncryptParameters(
            &pri->KeyEncryptionAlgorithm,
            &pszWrapOID,                    // allocated
            &dwAlgIdWrap,
            &dwBitLen))
        goto GetDhWrapEncryptParametersError;

    if (0 == (hAgreeKey = ICM_ImportDhAgreeKey(
            hKeyAgreeProv,
            hMyKey,
            cbP,
            &pKeyAgreeDecryptPara->OriginatorPublicKey,
            pszWrapOID,
            dwAlgIdWrap,
            dwBitLen,
            &pri->UserKeyingMaterial
            )))
        goto ImportDhAgreeKeyError;

    if (0 == (*phContentEncryptKey = ICM_ImportEncryptedKey(
            pContentEncryptionAlgorithm,
            hKeyAgreeProv,
            hAgreeKey,
            dwAlgIdWrap,
            SYMMETRICWRAPKEYBLOB,
            &pri->rgpRecipientEncryptedKeys[
                pKeyAgreeDecryptPara->dwRecipientEncryptedKeyIndex]->EncryptedKey
            )))
        goto ImportEncryptedKeyError;

    fRet = TRUE;
CommonReturn:
    ICM_Free(pszWrapOID);
    if (hAgreeKey)
        CryptDestroyKey(hAgreeKey);
    if (hMyKey)
        CryptDestroyKey(hMyKey);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetMyKeyFailed)
TRACE_ERROR(GetPLengthError)
TRACE_ERROR(GetDhWrapEncryptParametersError)
TRACE_ERROR(ImportDhAgreeKeyError)
TRACE_ERROR(ImportEncryptedKeyError)
}

//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultImportMailList(
    IN PCRYPT_ALGORITHM_IDENTIFIER pContentEncryptionAlgorithm,
    IN PCMSG_CTRL_MAIL_LIST_DECRYPT_PARA pMailListDecryptPara,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT HCRYPTKEY *phContentEncryptKey
    )
{
    BOOL fRet;
    DWORD dwError = ERROR_SUCCESS;

    HCRYPTPROV hMailListProv = 0;           // not released
    HCRYPTKEY hKeyEncryptionKey = 0;        // not destroyed
    PCMSG_MAIL_LIST_RECIPIENT_INFO pri = pMailListDecryptPara->pMailList;

    DWORD dwAlgIdEncrypt;
    DWORD dwBitLen;

    hMailListProv = pMailListDecryptPara->hCryptProv;
    switch (pMailListDecryptPara->dwKeyChoice) {
        case CMSG_MAIL_LIST_HANDLE_KEY_CHOICE:
            hKeyEncryptionKey = pMailListDecryptPara->hKeyEncryptionKey;
            assert(hMailListProv && hKeyEncryptionKey);
            if (0 == hMailListProv || 0 == hKeyEncryptionKey)
                goto InvalidMailListHandleKeyPara;
            break;
        default:
            goto InvalidMailListKeyChoice;
    }

    if (!ICM_GetWrapEncryptParameters(
            &pri->KeyEncryptionAlgorithm,
            &dwAlgIdEncrypt,
            &dwBitLen))
        goto GetWrapEncryptParametersError;

    if (CALG_RC2 == dwAlgIdEncrypt && 0 != dwBitLen)
        // Silently ignore any errors. Not supported in earlier versions
        CryptSetKeyParam(
            hKeyEncryptionKey,
            KP_EFFECTIVE_KEYLEN,
            (PBYTE) &dwBitLen,
            0);                 // dwFlags

    if (0 == (*phContentEncryptKey = ICM_ImportEncryptedKey(
            pContentEncryptionAlgorithm,
            hMailListProv,
            hKeyEncryptionKey,
            dwAlgIdEncrypt,
            SYMMETRICWRAPKEYBLOB,
            &pri->EncryptedKey
            )))
        goto ImportEncryptedKeyError;

    fRet = TRUE;

CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidMailListHandleKeyPara, E_INVALIDARG)
SET_ERROR(InvalidMailListKeyChoice, E_INVALIDARG)
TRACE_ERROR(GetWrapEncryptParametersError)
TRACE_ERROR(ImportEncryptedKeyError)
}

//+-------------------------------------------------------------------------
//  Default import of the encryption key (OldStyle)
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultImportEncryptKey(
    IN HCRYPTPROV                   hCryptProv,
    IN DWORD                        dwKeySpec,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiPubKey,
    IN PBYTE                        pbEncodedKey,
    IN DWORD                        cbEncodedKey,
    OUT HCRYPTKEY                   *phEncryptKey)
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    HCRYPTKEY               hUserKey = 0;
    CRYPT_DATA_BLOB         EncryptedKey;

    if (0 != dwKeySpec) {
        // Get private key to use.
        if (!CryptGetUserKey(
                hCryptProv,
                dwKeySpec,
                &hUserKey)) {
            hUserKey = 0;
            goto GetUserKeyFailed;
        }
    }
    // else
    //  Use the provider's default private key for decrypting

    EncryptedKey.cbData = cbEncodedKey;
    EncryptedKey.pbData = pbEncodedKey;
    if (0 == (*phEncryptKey = ICM_ImportEncryptedKey(
            paiEncrypt,
            hCryptProv,
            hUserKey,
            CALG_RSA_KEYX,
            SIMPLEBLOB,
            &EncryptedKey
            )))
        goto ImportEncryptedKeyError;

    fRet = TRUE;
CommonReturn:
    if (hUserKey)
        CryptDestroyKey(hUserKey);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetUserKeyFailed)
TRACE_ERROR(ImportEncryptedKeyError)
}


//+-------------------------------------------------------------------------
//  Decrypt the content using any CMS recipient type
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ControlCmsDecrypt(
    IN PCRYPT_MSG_INFO pcmi,
    IN DWORD dwFlags,
    IN void *pvDecryptPara,
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwRecipientIndex,
    IN HCRYPTOIDFUNCADDR hImportContentEncryptKeyFuncSet,
    IN LPSTR pszKeyEncryptionOID,
    IN PFN_ICM_IMPORT_CONTENT_ENCRYPT_KEY pDefaultImportContentEncryptKey
    )
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    EncryptedContentInfo    *peci = NULL;
    HCRYPTKEY               hkeySeal = NULL;
    PBYTE                   pbData = NULL;
    LONG                    cbData;
    AlgorithmIdentifier     *paiOssContentEncryption;
    PCRYPT_ALGORITHM_IDENTIFIER paiContentEncryption = NULL;
    PCMSG_STREAM_INFO       pcsi = pcmi->pStreamInfo;

    if( pcmi->Plaintext.pbData)
        goto MessageAlreadyDecrypted;

    switch (pcmi->dwMsgType) {
    case CMSG_ENVELOPED:
        {
            CmsEnvelopedData   *ped;

            ped = (CmsEnvelopedData *)pcmi->pvMsg;
            if (NULL == ped)
                goto NotUpdated;
            if (dwRecipientIndex >= ped->recipientInfos.count)
                goto RecipientIndexTooLarge;
            peci = &ped->encryptedContentInfo;
            paiOssContentEncryption =
                    &ped->encryptedContentInfo.contentEncryptionAlgorithm;
            break;
        }
    case CMSG_SIGNED_AND_ENVELOPED:
        goto MessageTypeNotSupportedYet;

    default:
        goto InvalidMsgType;
    }

    if (NULL == (paiContentEncryption = ICM_AllocAndGetALGORITHM_IDENTIFIER(
            paiOssContentEncryption)))
        goto GetEncryptAlgorithmError;

    if (!ICM_ImportContentEncryptKey(
            paiContentEncryption,
            pvDecryptPara,
            hImportContentEncryptKeyFuncSet,
            pszKeyEncryptionOID,
            pDefaultImportContentEncryptKey,
            &hkeySeal))
        goto ImportKeyError;

    if (pcsi) {
        if (!ICMS_SetDecryptKey( pcmi, hkeySeal))
            goto SetDecryptKeyError; // NB- Do not trash err from callback!
        hkeySeal = NULL;
    } else {
        // NB- For common bulk encryption algos,
        // sizeof(plaintext)<=sizeof(ciphertext)
        if (peci->bit_mask & encryptedContent_present)
            cbData = peci->encryptedContent.length;
        else
            cbData = 0;
        if (NULL == (pbData = (PBYTE)ICM_Alloc( cbData)))
            goto EncryptedContentAllocError;
        if (cbData ) {
            memcpy( pbData, peci->encryptedContent.value, cbData);
            if (!CryptDecrypt(
                    hkeySeal,
                    NULL,
                    TRUE,               // fFinal
                    0,                  // dwFlags
                    pbData,
                    (PDWORD)&cbData))
                goto DecryptError;
        }
        CryptDestroyKey( hkeySeal);
        hkeySeal = NULL;

        pcmi->Plaintext.cbData = cbData;
        pcmi->Plaintext.pbData = pbData;
        pbData = NULL;
    }

    if (dwFlags & CMSG_CRYPT_RELEASE_CONTEXT_FLAG)
        pcmi->hCryptProvContentCrypt = hCryptProv;
    pcmi->dwDecryptedRecipientIndex = dwRecipientIndex;

    fRet = TRUE;
CommonReturn:
    ICM_Free(paiContentEncryption);
    ICM_Free(pbData);
    if (hkeySeal)
        CryptDestroyKey( hkeySeal);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;

SET_ERROR(MessageAlreadyDecrypted,CRYPT_E_ALREADY_DECRYPTED)
SET_ERROR(RecipientIndexTooLarge, CRYPT_E_INVALID_INDEX)
SET_ERROR(NotUpdated, CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(InvalidMsgType, CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(MessageTypeNotSupportedYet,CRYPT_E_INVALID_MSG_TYPE)
TRACE_ERROR(GetEncryptAlgorithmError)
TRACE_ERROR(ImportKeyError)
TRACE_ERROR(EncryptedContentAllocError)
TRACE_ERROR(SetDecryptKeyError)
TRACE_ERROR(DecryptError)
}


//+-------------------------------------------------------------------------
//  Decrypt the content using only a PKCS 1.5 recipient type
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ControlPkcsDecrypt(
    IN PCRYPT_MSG_INFO pcmi,
    IN DWORD dwFlags,
    IN PCMSG_CTRL_DECRYPT_PARA pmcdp
    )
{
    BOOL fRet;
    CMSG_CTRL_KEY_TRANS_DECRYPT_PARA KeyTransDecryptPara;
    PCMSG_CMS_RECIPIENT_INFO pRecipientInfo = NULL;
    DWORD dwCmsIndex;

    assert( pmcdp->cbSize >= sizeof(*pmcdp));
    if (pmcdp->cbSize < sizeof(*pmcdp))
        goto InvalidArg;

    if (!ICM_ConvertPkcsToCmsRecipientIndex(
            pcmi, pmcdp->dwRecipientIndex, &dwCmsIndex))
        goto ConvertPkcsToCmsRecipientIndexError;

    if (NULL == (pRecipientInfo =
        (PCMSG_CMS_RECIPIENT_INFO) ICM_AllocAndGetParam(
            pcmi, CMSG_CMS_RECIPIENT_INFO_PARAM, dwCmsIndex)))
        goto GetCmsRecipientInfoParamError;

    assert(CMSG_KEY_TRANS_RECIPIENT == pRecipientInfo->dwRecipientChoice);

    memset(&KeyTransDecryptPara, 0, sizeof(KeyTransDecryptPara));
    KeyTransDecryptPara.cbSize = sizeof(KeyTransDecryptPara);
    KeyTransDecryptPara.hCryptProv = pmcdp->hCryptProv;
    KeyTransDecryptPara.dwKeySpec = pmcdp->dwKeySpec;
    KeyTransDecryptPara.pKeyTrans = pRecipientInfo->pKeyTrans;
    KeyTransDecryptPara.dwRecipientIndex = dwCmsIndex;

    fRet = ICM_ControlCmsDecrypt(
        pcmi,
        dwFlags,
        &KeyTransDecryptPara,
        KeyTransDecryptPara.hCryptProv,
        dwCmsIndex,
        hImportKeyTransFuncSet,
        KeyTransDecryptPara.pKeyTrans->KeyEncryptionAlgorithm.pszObjId,
        (PFN_ICM_IMPORT_CONTENT_ENCRYPT_KEY) ICM_DefaultImportKeyTrans
        );

CommonReturn:
    ICM_Free(pRecipientInfo);
    return fRet;
ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(ConvertPkcsToCmsRecipientIndexError)
TRACE_ERROR(GetCmsRecipientInfoParamError)
}

#else
//+-------------------------------------------------------------------------
//  Default import of the encryption key
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultImportEncryptKey(
    IN HCRYPTPROV                   hCryptProv,
    IN DWORD                        dwKeySpec,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiPubKey,
    IN PBYTE                        pbEncodedKey,
    IN DWORD                        cbEncodedKey,
    OUT HCRYPTKEY                   *phEncryptKey)
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    HCRYPTKEY               hEncryptKey = 0;
    HCRYPTKEY               hUserKey = 0;
    DWORD                   dwAlgIdEncrypt;
    DWORD                   dwAlgIdPubKey;
    PBYTE                   pbCspKey = NULL;
    DWORD                   cbCspKey;
    PUBLICKEYSTRUC          *ppks;
    PSIMPLEBLOBHEADER       psbh;

    BYTE                    rgbIV[IV_LENGTH];
    DWORD                   cbIV;
    DWORD                   dwBitLen;

    if (!ICM_GetEncryptParameters(
            paiEncrypt,
            &dwAlgIdEncrypt,
            &dwBitLen,
            rgbIV,
            &cbIV))
        goto GetEncryptParametersError;
#if 0
    if (!ICM_GetOssCAPI(
            CRYPT_PUBKEY_ALG_OID_GROUP_ID,
            paiPubKey,
            &dwAlgIdPubKey))
        goto PubKeyGetCAPIError;
#else
    // We have no idea what the right values are for the alg id's here.
    dwAlgIdPubKey = CALG_RSA_KEYX;
#endif
    cbCspKey = cbEncodedKey + sizeof(PUBLICKEYSTRUC) + sizeof(SIMPLEBLOBHEADER);
    if (NULL == (pbCspKey = (PBYTE)ICM_AllocA( cbCspKey)))
        goto CspKeyAllocError;
    ppks = (PUBLICKEYSTRUC *)pbCspKey;
    ppks->bType = SIMPLEBLOB;
    ppks->bVersion = CUR_BLOB_VERSION;
    ppks->reserved = 0;
    ppks->aiKeyAlg = dwAlgIdEncrypt;
    psbh = (PSIMPLEBLOBHEADER)(ppks + 1);
    psbh->aiEncAlg = dwAlgIdPubKey;
    ICM_ReverseCopy( (PBYTE)(psbh+1), pbEncodedKey, cbEncodedKey);

    if (0 != dwKeySpec) {
        // Get private key to use.
        if (!CryptGetUserKey(
                hCryptProv,
                dwKeySpec,
                &hUserKey)) {
            hUserKey = 0;
            goto GetUserKeyFailed;
        }
    }
    // else
    //  Use the provider's default private key for decrypting

    fRet = CryptImportKey(
            hCryptProv,
            pbCspKey,
            cbCspKey,
            hUserKey,
            CRYPT_NO_SALT,       // dwFlags
            &hEncryptKey);
    if (!fRet) {
        dwError = GetLastError();
        if (hUserKey) {
            if (NTE_BAD_FLAGS == dwError)
                // Try without salt. Previous versions didn't support
                // CRYPT_NO_SALT flag
                fRet = CryptImportKey(
                    hCryptProv,
                    pbCspKey,
                    cbCspKey,
                    hUserKey,
                    0,       // dwFlags
                    &hEncryptKey);
            if (!fRet) {
                // Try without using the specified user key. Many versions of
                // the CSP don't allow a non-null hUserKey parameter.
                fRet = CryptImportKey(
                    hCryptProv,
                    pbCspKey,
                    cbCspKey,
                    0,                  // hUserKey
                    CRYPT_NO_SALT,      // dwFlags
                    &hEncryptKey);
                if (!fRet)
                    dwError = GetLastError();

            }
        }

        if (!fRet && NTE_BAD_FLAGS == dwError)
            // Try without user key and without CRYPT_NO_SALT flag
            fRet = CryptImportKey(
                hCryptProv,
                pbCspKey,
                cbCspKey,
                0,          // hUserKey
                0,          // dwFlags
                &hEncryptKey);

        if (!fRet && 2 >= paiEncrypt->Parameters.cbData) {
            // Try importing as an NT4.0 SP3 encypted key that wasn't byte
            // reversed and with zero salt.
            memcpy( (PBYTE)(psbh+1), pbEncodedKey, cbEncodedKey);
            fRet = CryptImportKey(
                hCryptProv,
                pbCspKey,
                cbCspKey,
                hUserKey,
                0,          // dwFlags
                &hEncryptKey);
            if (!fRet && hUserKey) {
                // Try without using the specified user key.
                fRet = CryptImportKey(
                    hCryptProv,
                    pbCspKey,
                    cbCspKey,
                    0,          // hUserKey
                    0,          // dwFlags
                    &hEncryptKey);
            }
        }

        if (!fRet) {
            hEncryptKey = 0;
            goto ImportKeyFailed;
        }
    }

    if (CALG_RC2 == dwAlgIdEncrypt && 0 != dwBitLen)
        // Silently ignore any errors. Not supported in earlier versions
        CryptSetKeyParam(
            hEncryptKey,
            KP_EFFECTIVE_KEYLEN,
            (PBYTE) &dwBitLen,
            0);                 // dwFlags

    if (0 != cbIV) {
        if (!CryptSetKeyParam(
                hEncryptKey,
                KP_IV,
                rgbIV,
                0))                 // dwFlags
            goto SetKeyParamError;
    }

    fRet = TRUE;
CommonReturn:
    ICM_FreeA(pbCspKey);
    if (hUserKey)
        CryptDestroyKey(hUserKey);
    ICM_SetLastError(dwError);
    *phEncryptKey = hEncryptKey;
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    if (hEncryptKey) {
        CryptDestroyKey(hEncryptKey);
        hEncryptKey = 0;
    }
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetEncryptParametersError)
//SET_ERROR(PubKeyGetCAPIError,CRYPT_E_UNKNOWN_ALGO)
TRACE_ERROR(GetUserKeyFailed)
TRACE_ERROR(ImportKeyFailed)
TRACE_ERROR(CspKeyAllocError)
TRACE_ERROR(SetKeyParamError)
}


//+-------------------------------------------------------------------------
//  Import the encryption key
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ImportEncryptKey(
    IN HCRYPTPROV                   hCryptProv,
    IN DWORD                        dwKeySpec,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiPubKey,
    IN PBYTE                        pbEncodedKey,
    IN DWORD                        cbEncodedKey,
    OUT HCRYPTKEY                   *phEncryptKey)
{
    BOOL fResult;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr;

    if (CryptGetOIDFunctionAddress(
            hImportEncryptKeyFuncSet,
            X509_ASN_ENCODING,
            paiEncrypt->pszObjId,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr)) {
        fResult = ((PFN_CMSG_IMPORT_ENCRYPT_KEY) pvFuncAddr)(
            hCryptProv,
            dwKeySpec,
            paiEncrypt,
            paiPubKey,
            pbEncodedKey,
            cbEncodedKey,
            phEncryptKey);
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    } else
        fResult = ICM_DefaultImportEncryptKey(
            hCryptProv,
            dwKeySpec,
            paiEncrypt,
            paiPubKey,
            pbEncodedKey,
            cbEncodedKey,
            phEncryptKey);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Decrypt the content
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ControlDecrypt(
    IN PCRYPT_MSG_INFO pcmi,
    IN DWORD dwFlags,
    IN void *pvCtrlPara)
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    PCMSG_CTRL_DECRYPT_PARA  pmcdp;
    RecipientInfo           *pri = NULL;
    EncryptedContentInfo    *peci = NULL;
    HCRYPTKEY               hkeySeal = NULL;
    PBYTE                   pbData = NULL;
    LONG                    cbData;
    AlgorithmIdentifier     *paiOssContentEncryption;
    PCRYPT_ALGORITHM_IDENTIFIER paiContentEncryption = NULL;
    AlgorithmIdentifier     *paiOssKeyEncryption;
    PCRYPT_ALGORITHM_IDENTIFIER paiKeyEncryption = NULL;
    PCMSG_STREAM_INFO       pcsi = pcmi->pStreamInfo;

    pmcdp = (PCMSG_CTRL_DECRYPT_PARA)pvCtrlPara;
    assert( pmcdp->cbSize >= sizeof(CMSG_CTRL_DECRYPT_PARA));
    if (pmcdp->cbSize < sizeof(CMSG_CTRL_DECRYPT_PARA))
        goto InvalidArg;

    if (dwFlags & CMSG_CRYPT_RELEASE_CONTEXT_FLAG)
        pcmi->hCryptProvContentCrypt = pmcdp->hCryptProv;

    if( pcmi->Plaintext.pbData)
        goto MessageAlreadyDecrypted;

    switch (pcmi->dwMsgType) {
    case CMSG_ENVELOPED:
        {
            EnvelopedData   *ped;

            ped = (EnvelopedData *)pcmi->pvMsg;
            peci = &ped->encryptedContentInfo;
            if (pmcdp->dwRecipientIndex >= ped->recipientInfos.count)
                goto RecipientIndexTooLarge;
            pri = ped->recipientInfos.value + pmcdp->dwRecipientIndex;
            paiOssContentEncryption =
                    &ped->encryptedContentInfo.contentEncryptionAlgorithm;
            paiOssKeyEncryption = &pri->keyEncryptionAlgorithm;
            break;
        }
    case CMSG_SIGNED_AND_ENVELOPED:
        goto MessageTypeNotSupportedYet;

    default:
        goto InvalidMsgType;
    }

    if (NULL == pri)
        goto RecipientNotFound;         // really NULL if not found?

    if (NULL == (paiContentEncryption = ICM_AllocAndGetALGORITHM_IDENTIFIER(
            paiOssContentEncryption)))
        goto GetEncryptAlgorithmError;
    if (NULL == (paiKeyEncryption = ICM_AllocAndGetALGORITHM_IDENTIFIER(
            paiOssKeyEncryption)))
        goto GetKeyAlgorithmError;
    if (!ICM_ImportEncryptKey(
            pmcdp->hCryptProv,
            pmcdp->dwKeySpec,
            paiContentEncryption,
            paiKeyEncryption,
            pri->encryptedKey.value,
            pri->encryptedKey.length,
            &hkeySeal))
        goto ImportKeyError;

    if (pcsi) {
        if (!ICMS_SetDecryptKey( pcmi, hkeySeal))
            goto SetDecryptKeyError; // NB- Do not trash err from callback!
        hkeySeal = NULL;
    } else {
        // NB- For common bulk encryption algos,
        // sizeof(plaintext)<=sizeof(ciphertext)
        cbData = peci->encryptedContent.length;
        if (NULL == (pbData = (PBYTE)ICM_Alloc( cbData)))
            goto EncryptedContentAllocError;
        memcpy( pbData, peci->encryptedContent.value, cbData);
        if (!CryptDecrypt(
                hkeySeal,
                NULL,
                TRUE,               // fFinal
                0,                  // dwFlags
                pbData,
                (PDWORD)&cbData))
            goto DecryptError;
        CryptDestroyKey( hkeySeal);
        hkeySeal = NULL;

        pcmi->Plaintext.cbData = cbData;
        pcmi->Plaintext.pbData = pbData;
        pbData = NULL;
    }

    pcmi->dwDecryptedRecipientIndex = pmcdp->dwRecipientIndex;

    fRet = TRUE;
CommonReturn:
    ICM_Free(paiContentEncryption);
    ICM_Free(paiKeyEncryption);
    ICM_Free( pbData);
    if (hkeySeal)
        CryptDestroyKey( hkeySeal);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidArg,E_INVALIDARG)
SET_ERROR(MessageAlreadyDecrypted,CRYPT_E_ALREADY_DECRYPTED)
SET_ERROR(RecipientIndexTooLarge,CRYPT_E_INVALID_INDEX)
SET_ERROR(MessageTypeNotSupportedYet,CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(InvalidMsgType,CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(RecipientNotFound,CRYPT_E_RECIPIENT_NOT_FOUND)
TRACE_ERROR(GetEncryptAlgorithmError)
TRACE_ERROR(GetKeyAlgorithmError)
TRACE_ERROR(ImportKeyError)
TRACE_ERROR(EncryptedContentAllocError)
TRACE_ERROR(SetDecryptKeyError)
TRACE_ERROR(DecryptError)
}

#endif  // CMS_PKCS7


//+-------------------------------------------------------------------------
//  Hash the content of a message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_HashContent(
    IN PCRYPT_MSG_INFO  pcmi,
    IN OUT HCRYPTHASH   hHash)
{
    DWORD       dwError = ERROR_SUCCESS;
    BOOL        fRet;
    HCRYPTMSG   hCryptMsg = (HCRYPTMSG)pcmi;
    PBYTE       pbAllocData = NULL;
    PBYTE       pbData;
    DWORD       cbData;

    cbData = 0;
    CryptMsgGetParam(
            hCryptMsg,
            CMSG_CONTENT_PARAM,
            0,                      // dwIndex
            NULL,
            &cbData);
    if (0 == cbData)
        goto GetContentSizeError;
    if (NULL == (pbAllocData = (PBYTE)ICM_Alloc(cbData)))
        goto AllocContentError;
    if (!CryptMsgGetParam(
            hCryptMsg,
            CMSG_CONTENT_PARAM,
            0,                      // dwIndex
            pbAllocData,
            &cbData))
        goto GetContentError;

    pbData = pbAllocData;

    if (0 != strcmp(pszObjIdDataType, pcmi->psdi->pci->pszContentType)
#ifdef CMS_PKCS7
            &&  pcmi->psdi->version < CMSG_SIGNED_DATA_CMS_VERSION 
#endif  // CMS_PKCS7
                ) {
        // Leading tag and length octets aren't included in the digest
        if (0 > Asn1UtilExtractContent( pbData, cbData, &cbData,
                    (const BYTE **)&pbData))
            goto ExtractContentError;
    }

    if (!ICM_UpdateDigest( hHash, pbData, cbData))
        goto UpdateDigestError;

    fRet = TRUE;
CommonReturn:
    ICM_Free( pbAllocData);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetContentSizeError)    // error already set
TRACE_ERROR(AllocContentError)      // error already set
TRACE_ERROR(GetContentError)        // error already set
SET_ERROR(ExtractContentError,CRYPT_E_UNEXPECTED_ENCODING)
TRACE_ERROR(UpdateDigestError)      // error already set
}


//+-------------------------------------------------------------------------
//  Add a signer to a signed-data or signed-and-enveloped-data message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ControlAddSigner(
    IN OUT PCRYPT_MSG_INFO      pcmi,
    IN DWORD                    dwFlags,
    IN PCMSG_SIGNER_ENCODE_INFO psei)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    CHashNode           *pnHash;
    CSignerNode         *pnSigner;
    DWORD               dwAlgoCAPI;
    SignerInfo          *psi = NULL;
    Attribute           *pAuthAttr;
    DWORD               cAuthAttr;
    Attribute           *pUnauthAttr;
    DWORD               cUnauthAttr;
    LPSTR               pszInnerContentObjID;
    ICM_HASH_INFO       HashInfo;               ZEROSTRUCT(HashInfo);
    AlgorithmIdentifier oaiHash;
    CBlobNode           *pnBlob;
    CRYPT_DATA_BLOB     blobHashAlgo;           ZEROSTRUCT(blobHashAlgo);
    SIGNER_DATA_INFO    sdi;                    ZEROSTRUCT(sdi);

#ifdef CMS_PKCS7
    SIGNER_ENCODE_DATA_INFO SignerEncodeDataInfo;
#endif  // CMS_PKCS7

    // if the hash algorithm matches one of the ones already in use,
    //      get that hash and encrypt it
    // else
    //      hash the data again and add hash algo to top-level list
    //      [NB- must access data again]

    // Search for a hash node with a matching hash algorithm
    if (!(ICM_GetCAPI(
            CRYPT_HASH_ALG_OID_GROUP_ID,
            &psei->HashAlgorithm,
            &dwAlgoCAPI) ||
          ICM_GetCAPI(
            CRYPT_SIGN_ALG_OID_GROUP_ID,
            &psei->HashAlgorithm,
            &dwAlgoCAPI)))
        goto GetCAPIError;

    // before, this could have never failed, but now it can
    // only create a hash node if the hash didn't exists.
    if (!ICM_FindHashNodeFromCapiAlgid( pcmi->pHashList, dwAlgoCAPI, &pnHash)  &&
        GetLastError() != CRYPT_E_UNKNOWN_ALGO)
        goto FindHashNodeFromCapiAlgidError;

    if (!pnHash) {
        // New hash.
        // 1. Create hash node
        // 2. Hash the data
        // 3. Add hash node to pcmi->pHashList
        // 4. Encode this hash algo and add to pcmi->psdi->pAlgidList
        HashInfo.dwAlgoCAPI = dwAlgoCAPI;
#ifndef CMS_PKCS7
        HashInfo.hCryptProv = psei->hCryptProv;
#endif  // CMS_PKCS7
        if (!CryptCreateHash(
                        psei->hCryptProv,
                        HashInfo.dwAlgoCAPI,
                        NULL,               // hKey - optional for MAC
                        0,                  // dwFlags
                        &HashInfo.hHash))
            goto CreateHashError;
        if (!ICM_HashContent( pcmi, HashInfo.hHash))    // hash content
            goto HashContentError;
        if (NULL == (pnHash = new CHashNode))
            goto NewHashNodeError;
        pnHash->SetData( &HashInfo);
        pcmi->pHashList->InsertTail( pnHash);

        // Convert the hash algorithm to a blob and
        // add to pcmi->psdi->pAlgidList.
        if (!ICM_MsgAsn1ToAlgorithmIdentifier(
                pcmi,
                &psei->HashAlgorithm,
                &oaiHash))
            goto MsgAsn1ToAlgorithmIdentifierError;
        if (!ICM_Asn1Encode(
                AlgorithmIdentifier_PDU,
                &oaiHash,
                &blobHashAlgo))
            goto EncodeHashAlgorithmError;
        if (NULL == (pnBlob = new CBlobNode))
            goto NewBlobNodeError;
        pnBlob->SetData( &blobHashAlgo);
        pcmi->psdi->pAlgidList->InsertTail( pnBlob);
    }

    // Alloc and fill in a SignerInfo

    pszInnerContentObjID = pcmi->psdi->pci->pszContentType;
    if (!strcmp( pszInnerContentObjID, pszObjIdDataType))
        pszInnerContentObjID = NULL;

    // NB - Each SignerInfo gets a non-empty authenticatedAttributes
    //      if the inner contentType is not data (passed in) or if
    //      there are authenticated attributes passed in. In this case,
    //      we reserve two Attribute slots at the beginning of the array
    //      for the content-type and message-digest Attribute values.
    cAuthAttr = 0;
    if (pszInnerContentObjID ||
            psei->cAuthAttr ||
            (dwFlags & CMSG_AUTHENTICATED_ATTRIBUTES_FLAG)) {
        cAuthAttr = psei->cAuthAttr + 2;        // reserve 2
    }
    cUnauthAttr = psei->cUnauthAttr;
    psi = (SignerInfo *)ICM_AllocZero(                sizeof( SignerInfo) +
                                        cAuthAttr   * sizeof( Attribute) +
                                        cUnauthAttr * sizeof( Attribute)
                                     );
    if (NULL == psi)
        goto SignerInfoAllocError;
    pAuthAttr = (Attribute *)(psi + 1);
    pUnauthAttr = pAuthAttr + cAuthAttr;

    if (!ICM_FillAsnSignerInfo(
            psei,
            pcmi,
            dwFlags,
            pszInnerContentObjID,
            psi,
            &pAuthAttr,
            &pUnauthAttr))
        goto FillAsnSignerInfoError;

#ifdef CMS_PKCS7
    SignerEncodeDataInfo.hCryptProv = psei->hCryptProv;
    SignerEncodeDataInfo.dwKeySpec = psei->dwKeySpec;
    SignerEncodeDataInfo.pHashNode = pnHash;
    if (!ICM_FillSignerEncryptedDigest(
            psi,
            pszInnerContentObjID,
            &SignerEncodeDataInfo,
            FALSE))             // fMaxLength
        goto FillSignerEncryptedDigestError;
#else
    if (!ICM_FillSignerEncryptedDigest(
            psi,
            pszInnerContentObjID,
            pnHash,
            psei->dwKeySpec,
            FALSE))             // fMaxLength
        goto FillSignerEncryptedDigestError;
#endif  // CMS_PKCS7

    // Encode the signer and add to pcmi->psdi->pSignerList.
    if (!ICM_Asn1Encode(
            SignerInfo_PDU,
            psi,
            &sdi.blob))
        goto EncodeSignerInfoError;
    if (NULL == (pnSigner = new CSignerNode))
        goto NewSignerInfoBlobNodeError;
    pnSigner->SetData( &sdi);
    pcmi->psdi->pSignerList->InsertTail( pnSigner);

    fRet = TRUE;
CommonReturn:
    if (psi) {
        ICM_FreeAsnSignerInfo(psi);
        ICM_Free(psi);
    }
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    ICM_Free(blobHashAlgo.pbData);
    ICM_Free(sdi.blob.pbData);
    if (HashInfo.hHash)
        CryptDestroyHash(HashInfo.hHash);
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(GetCAPIError,CRYPT_E_UNKNOWN_ALGO)
SET_ERROR(NewHashNodeError,E_OUTOFMEMORY)
SET_ERROR(NewBlobNodeError,E_OUTOFMEMORY)
SET_ERROR(NewSignerInfoBlobNodeError,E_OUTOFMEMORY)
TRACE_ERROR(FindHashNodeFromCapiAlgidError)     // error already set
TRACE_ERROR(CreateHashError)                    // error already set
TRACE_ERROR(HashContentError)                   // error already set
TRACE_ERROR(MsgAsn1ToAlgorithmIdentifierError) // error already set
TRACE_ERROR(EncodeHashAlgorithmError)           // error already set
TRACE_ERROR(SignerInfoAllocError)               // error already set
TRACE_ERROR(FillAsnSignerInfoError)             // error already set
TRACE_ERROR(FillSignerEncryptedDigestError)     // error already set
TRACE_ERROR(EncodeSignerInfoError)              // error already set
}

//+-------------------------------------------------------------------------
//  Add a CMS signer info to a signed-data message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ControlAddCmsSignerInfo(
    IN OUT PCRYPT_MSG_INFO      pcmi,
    IN DWORD                    dwFlags,
    IN PCMSG_CMS_SIGNER_INFO    psi)
{
    BOOL                fRet;
    CSignerNode         *pnSigner;
    SIGNER_DATA_INFO    sdi;                    ZEROSTRUCT(sdi);


    // Encode the signer
    if (!ICM_CmsSignerInfoEncode(
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            CMS_SIGNER_INFO,
            psi,
            NULL,               // pbEncoded
            &sdi.blob.cbData
            ))
        goto EncodeSignerInfoError;
    if (NULL == (sdi.blob.pbData = (PBYTE) ICM_Alloc(sdi.blob.cbData)))
        goto OutOfMemory;
    if (!ICM_CmsSignerInfoEncode(
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            CMS_SIGNER_INFO,
            psi,
            sdi.blob.pbData,
            &sdi.blob.cbData
            ))
        goto EncodeSignerInfoError;

    // Add to pcmi->psdi->pSignerList.
    if (NULL == (pnSigner = new CSignerNode))
        goto NewSignerInfoBlobNodeError;
    pnSigner->SetData( &sdi);
    pcmi->psdi->pSignerList->InsertTail( pnSigner);

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    ICM_Free(sdi.blob.pbData);
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(EncodeSignerInfoError)
SET_ERROR(NewSignerInfoBlobNodeError,E_OUTOFMEMORY)
}

//+-------------------------------------------------------------------------
//  Remove a signer from a signed-data or signed-and-enveloped-data message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ControlDelSigner(
    IN OUT PCRYPT_MSG_INFO      pcmi,
    IN DWORD                    dwFlags,
    IN DWORD                    dwIndex)
{
    BOOL                fRet;
    CSignerNode         *pnSigner = pcmi->psdi->pSignerList->Nth( dwIndex);

    if (NULL == pnSigner)
        goto IndexTooLargeError;

    pcmi->psdi->pSignerList->Remove( pnSigner);
    delete pnSigner;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(IndexTooLargeError,CRYPT_E_INVALID_INDEX)
dwFlags;
}


//+-------------------------------------------------------------------------
//  Initialize the unauthenticated attributes list. Called before doing an
//  add or delete.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_InitUnauthAttrList(
    IN CSignerNode          *pnSigner
    )
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    CBlobList               *plBlob = NULL;
    DWORD                   i;
    SIGNER_DATA_INFO        sdi;
    SignerInfoWithAttrBlobs *posib = NULL;
    Any                     *pAny;
    ASN1error_e             Asn1Err;
    ASN1decoding_t          pDec = ICM_GetDecoder();

    assert(pnSigner);
    sdi = *pnSigner->Data();
    if (NULL == sdi.pUnauthAttrList) {
        if (NULL == (plBlob = new CBlobList))
            goto NewUnauthAttrListError;
        if (0 != (Asn1Err = PkiAsn1Decode(
                pDec,
                (void **)&posib,
                SignerInfoWithAttrBlobs_PDU,
                sdi.blob.pbData,
                sdi.blob.cbData)))
            goto DecodeSignerInfoError;
        if (posib->bit_mask & unauthAttributes_present) {
            for (i=posib->unauthAttributes.count, pAny=posib->unauthAttributes.value;
                    i>0;
                    i--, pAny++)
                if (!ICM_InsertTailBlob( plBlob, pAny))
                    goto InsertOldUnauthAttrBlobError;
        }
        sdi.pUnauthAttrList = plBlob;

        pnSigner->SetData( &sdi);
    }

    fRet = TRUE;
CommonReturn:
    PkiAsn1FreeInfo(pDec, SignerInfoWithAttrBlobs_PDU, posib);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    if (plBlob)
        delete plBlob;
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(DecodeSignerInfoError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(NewUnauthAttrListError,E_OUTOFMEMORY)
TRACE_ERROR(InsertOldUnauthAttrBlobError)   // error already set
}

//+-------------------------------------------------------------------------
//  Add an unauthenticated attribute to a SignerInfo of a signed-data or
//  signed-and-enveloped-data message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ControlAddUnauthAttr(
    IN PCRYPT_MSG_INFO      pcmi,
    IN DWORD                dwFlags,
    IN PCMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA pmcasuap)
{
    BOOL                    fRet;
    CSignerNode             *pnSigner;
    DWORD                   i;

    for (i=pmcasuap->dwSignerIndex,
                pnSigner=pcmi->psdi->pSignerList->Head();
            (i>0) && pnSigner;
            i--, pnSigner = pnSigner->Next())
        ;
    if (NULL == pnSigner)
        goto IndexTooLargeError;

    if (!ICM_InitUnauthAttrList(pnSigner))
        goto InitUnauthAttrListError;

    assert(pnSigner->Data()->pUnauthAttrList);
    if (!ICM_InsertTailBlob( pnSigner->Data()->pUnauthAttrList,
            (Any *)&pmcasuap->blob))
        goto InsertUnauthAttrBlobError;


    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(IndexTooLargeError,CRYPT_E_INVALID_INDEX)
TRACE_ERROR(InitUnauthAttrListError)        // error already set
TRACE_ERROR(InsertUnauthAttrBlobError)      // error already set
dwFlags;
}


//+-------------------------------------------------------------------------
//  Delete an unauthenticated attribute from a SignerInfo of a signed-data or
//  signed-and-enveloped-data message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ControlDelUnauthAttr(
    IN PCRYPT_MSG_INFO      pcmi,
    IN DWORD                dwFlags,
    IN PCMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA pmcdsuap)
{
    BOOL                    fRet;
    CSignerNode             *pnSigner;
    DWORD                   i;

    for (i=pmcdsuap->dwSignerIndex,
                pnSigner=pcmi->psdi->pSignerList->Head();
            (i>0) && pnSigner;
            i--, pnSigner = pnSigner->Next())
        ;
    if (NULL == pnSigner)
        goto IndexTooLargeError;

    if (!ICM_InitUnauthAttrList(pnSigner))
        goto InitUnauthAttrListError;

    assert(pnSigner->Data()->pUnauthAttrList);
    if (!ICM_DelBlobByIndex(
            pnSigner->Data()->pUnauthAttrList,
            pmcdsuap->dwUnauthAttrIndex))
        goto DelBlobByIndexError;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(IndexTooLargeError,CRYPT_E_INVALID_INDEX)
TRACE_ERROR(InitUnauthAttrListError)        // error already set
TRACE_ERROR(DelBlobByIndexError)            // error already set
dwFlags;
}


//+-------------------------------------------------------------------------
//  Perform a special "control" function after the final CryptMsgUpdate of a
//  encoded/decoded cryptographic message.
//
//  The dwCtrlType parameter specifies the type of operation to be performed.
//
//  The pvCtrlPara definition depends on the dwCtrlType value.
//
//  See below for a list of the control operations and their pvCtrlPara
//  type definition.
//--------------------------------------------------------------------------
BOOL
WINAPI
#ifdef DEBUG_CRYPT_ASN1_MASTER
ICMTest_NewCryptMsgControl(
#else
CryptMsgControl(
#endif
    IN HCRYPTMSG hCryptMsg,
    IN DWORD dwFlags,
    IN DWORD dwCtrlType,
    IN void const *pvCtrlPara)
{
    BOOL                fRet;
    PCRYPT_MSG_INFO     pcmi = (PCRYPT_MSG_INFO)hCryptMsg;

    ICM_Lock( pcmi);    // Single thread access to HCRYPTMSG

    // Only support control for decoding
    if (pcmi->fEncoding)
        goto ControlForEncodingNotSupported;

    switch (dwCtrlType) {
    case CMSG_CTRL_VERIFY_SIGNATURE:
        fRet = ICM_ControlVerifySignature(
                        pcmi,
                        dwFlags,
                        (PCERT_INFO)pvCtrlPara);
        break;

#ifdef CMS_PKCS7
    case CMSG_CTRL_VERIFY_SIGNATURE_EX:
        fRet = ICM_ControlVerifySignatureEx(
                        pcmi,
                        dwFlags,
                        (PCMSG_CTRL_VERIFY_SIGNATURE_EX_PARA)pvCtrlPara);
        break;
#endif  // CMS_PKCS7

    case CMSG_CTRL_DECRYPT:
#ifdef CMS_PKCS7
        fRet = ICM_ControlPkcsDecrypt(
#else
        fRet = ICM_ControlDecrypt(
#endif  // CMS_PKCS7
                        pcmi,
                        dwFlags,
                        (PCMSG_CTRL_DECRYPT_PARA) pvCtrlPara);
        break;
    case CMSG_CTRL_VERIFY_HASH:
        fRet = ICM_ControlVerifyDigest(
                        pcmi,
                        dwFlags);
        break;
    case CMSG_CTRL_ADD_SIGNER:
        fRet = ICM_ControlAddSigner(
                        pcmi,
                        dwFlags,
                        (PCMSG_SIGNER_ENCODE_INFO)pvCtrlPara);
        break;
    case CMSG_CTRL_ADD_CMS_SIGNER_INFO:
        fRet = ICM_ControlAddCmsSignerInfo(
                        pcmi,
                        dwFlags,
                        (PCMSG_CMS_SIGNER_INFO)pvCtrlPara);
        break;
    case CMSG_CTRL_DEL_SIGNER:
        fRet = ICM_ControlDelSigner(
                        pcmi,
                        dwFlags,
                        *(PDWORD)pvCtrlPara);
        break;
    case CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR:
        fRet = ICM_ControlAddUnauthAttr(
                        pcmi,
                        dwFlags,
                        (PCMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA)pvCtrlPara);
        break;
    case CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR:
        fRet = ICM_ControlDelUnauthAttr(
                        pcmi,
                        dwFlags,
                        (PCMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA)pvCtrlPara);
        break;
    case CMSG_CTRL_ADD_CERT:
        fRet = ICM_InsertTailBlob(
                        pcmi->psdi->pCertificateList,
                        (Any *)pvCtrlPara);
        break;
    case CMSG_CTRL_DEL_CERT:
        {
            DWORD dwIndex = *(PDWORD)pvCtrlPara;
#ifdef CMS_PKCS7
            if (pcmi->psdi->version >= CMSG_SIGNED_DATA_CMS_VERSION)
                // Advance index past attribute certs.
                ICM_GetTaggedBlobAndAdvanceIndex(
                    pcmi->psdi->pCertificateList,
                    ICM_TAG_SEQ,
                    &dwIndex
                    );
#endif  // CMS_PKCS7
            fRet = ICM_DelBlobByIndex(
                        pcmi->psdi->pCertificateList,
                        dwIndex);
        }
        break;

#ifdef CMS_PKCS7
    case CMSG_CTRL_ADD_ATTR_CERT:
        {
            Any *pAny = (Any *) pvCtrlPara;
            Any AnyAttrCert;
            BOOL fV3;

            fV3 = (pcmi->psdi->version >= CMSG_SIGNED_DATA_CMS_VERSION);
            if (!(fV3 || 0 != strcmp(pszObjIdDataType,
                    pcmi->psdi->pci->pszContentType)))
                goto InvalidMsgTypeToAddAttrCert;
            
            AnyAttrCert.length = pAny->length;
            if (0 == AnyAttrCert.length)
                goto InvalidParamError;
            if (NULL == (AnyAttrCert.value = (unsigned char*) ICM_Alloc(
                    AnyAttrCert.length)))
                goto AllocError;
            memcpy(AnyAttrCert.value, pAny->value, AnyAttrCert.length);
#ifdef OSS_CRYPT_ASN1
            *AnyAttrCert.value = ICM_TAG_CONSTRUCTED_CONTEXT_1;
#else
            *((BYTE *) AnyAttrCert.value) = ICM_TAG_CONSTRUCTED_CONTEXT_1;
#endif  // OSS_CRYPT_ASN1
            fRet = ICM_InsertTailBlob(
                        pcmi->psdi->pCertificateList,
                        &AnyAttrCert);
            if (fRet && !fV3)
                pcmi->psdi->version = CMSG_SIGNED_DATA_CMS_VERSION;
            ICM_Free(AnyAttrCert.value);
        }
        break;
    case CMSG_CTRL_DEL_ATTR_CERT:
        if (pcmi->psdi->version < CMSG_SIGNED_DATA_CMS_VERSION)
            goto NoAttrCerts;
        else {
            DWORD dwIndex = *(PDWORD)pvCtrlPara;

            // Advance index past certs.
            ICM_GetTaggedBlobAndAdvanceIndex(
                pcmi->psdi->pCertificateList,
                ICM_TAG_CONSTRUCTED_CONTEXT_1,
                &dwIndex
                );

            fRet = ICM_DelBlobByIndex(
                        pcmi->psdi->pCertificateList,
                        dwIndex);
        }
        break;
#endif  // CMS_PKCS7

    case CMSG_CTRL_ADD_CRL:
        fRet = ICM_InsertTailBlob(
                        pcmi->psdi->pCrlList,
                        (Any *)pvCtrlPara);
        break;
    case CMSG_CTRL_DEL_CRL:
        fRet = ICM_DelBlobByIndex(
                        pcmi->psdi->pCrlList,
                        *(PDWORD)pvCtrlPara);
        break;

#ifdef CMS_PKCS7
    case CMSG_CTRL_KEY_TRANS_DECRYPT:
        {
            PCMSG_CTRL_KEY_TRANS_DECRYPT_PARA pmcdp =
                (PCMSG_CTRL_KEY_TRANS_DECRYPT_PARA) pvCtrlPara;

            assert(pmcdp->cbSize >= sizeof(*pmcdp));
            if (pmcdp->cbSize < sizeof(*pmcdp))
                goto InvalidArg;

            fRet = ICM_ControlCmsDecrypt(
                    pcmi,
                    dwFlags,
                    pmcdp,
                    pmcdp->hCryptProv,
                    pmcdp->dwRecipientIndex,
                    hImportKeyTransFuncSet,
                    pmcdp->pKeyTrans->KeyEncryptionAlgorithm.pszObjId,
                    (PFN_ICM_IMPORT_CONTENT_ENCRYPT_KEY) ICM_DefaultImportKeyTrans
                    );
        }
        break;
    case CMSG_CTRL_KEY_AGREE_DECRYPT:
        {
            PCMSG_CTRL_KEY_AGREE_DECRYPT_PARA pmcdp =
                (PCMSG_CTRL_KEY_AGREE_DECRYPT_PARA) pvCtrlPara;

            assert(pmcdp->cbSize >= sizeof(*pmcdp));
            if (pmcdp->cbSize < sizeof(*pmcdp))
                goto InvalidArg;

            fRet = ICM_ControlCmsDecrypt(
                    pcmi,
                    dwFlags,
                    pmcdp,
                    pmcdp->hCryptProv,
                    pmcdp->dwRecipientIndex,
                    hImportKeyAgreeFuncSet,
                    pmcdp->pKeyAgree->KeyEncryptionAlgorithm.pszObjId,
                    (PFN_ICM_IMPORT_CONTENT_ENCRYPT_KEY) ICM_DefaultImportKeyAgree
                    );
            if (fRet)
                pcmi->dwDecryptedRecipientEncryptedKeyIndex =
                    pmcdp->dwRecipientEncryptedKeyIndex;
        }
        break;
    case CMSG_CTRL_MAIL_LIST_DECRYPT:
        {
            PCMSG_CTRL_MAIL_LIST_DECRYPT_PARA pmcdp =
                (PCMSG_CTRL_MAIL_LIST_DECRYPT_PARA) pvCtrlPara;

            assert(pmcdp->cbSize >= sizeof(*pmcdp));
            if (pmcdp->cbSize < sizeof(*pmcdp))
                goto InvalidArg;

            fRet = ICM_ControlCmsDecrypt(
                    pcmi,
                    dwFlags,
                    pmcdp,
                    pmcdp->hCryptProv,
                    pmcdp->dwRecipientIndex,
                    hImportMailListFuncSet,
                    pmcdp->pMailList->KeyEncryptionAlgorithm.pszObjId,
                    (PFN_ICM_IMPORT_CONTENT_ENCRYPT_KEY) ICM_DefaultImportMailList
                    );
        }
        break;
#endif  // CMS_PKCS7

    default:
        goto InvalidCtrlType;
    }

CommonReturn:
    ICM_Unlock( pcmi);
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(ControlForEncodingNotSupported,E_INVALIDARG)
SET_ERROR(InvalidCtrlType,CRYPT_E_CONTROL_TYPE)
#ifdef CMS_PKCS7
SET_ERROR(InvalidMsgTypeToAddAttrCert,CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(InvalidParamError,E_INVALIDARG)
TRACE_ERROR(AllocError)
SET_ERROR(NoAttrCerts,CRYPT_E_INVALID_INDEX)
SET_ERROR(InvalidArg,E_INVALIDARG)
#endif  // CMS_PKCS7
}


//+-------------------------------------------------------------------------
//  Copy out a DWORD
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetDWORD(
    IN DWORD dwValue,
    OUT void *pvData,
    IN OUT DWORD *pcbData)
{
    return ICM_CopyOut(
                (PBYTE)&dwValue,
                sizeof(DWORD),
                (PBYTE)pvData,
                pcbData);
}


//+-------------------------------------------------------------------------
//  Get Any
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssAny(
        IN Any          *pany,
        OUT PCRYPT_DATA_BLOB pInfo,
        IN OUT BYTE     **ppbExtra,
        IN OUT LONG     *plRemainExtra)
{
    BOOL fResult = TRUE;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    LONG lData;
    BOOL fNULL = FALSE;
    PBYTE pbValue;

    pbValue = (PBYTE) pany->value;
    if ((pany->length == 2) &&
            (pbValue[0] == 0x05) &&
            (pbValue[1] == 0x00)) {
        // Detected NULL encoding. Map to NULL blob.
        fNULL = TRUE;
    }

    lData = fNULL ? 0 : pany->length;
    lAlignExtra = INFO_LEN_ALIGN(lData);
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if ((lData > 0) && !fNULL) {
            pInfo->pbData = pbExtra;
            pInfo->cbData = (DWORD) lData;
            memcpy( pbExtra, pany->value, lData);
        } else {
            memset(pInfo, 0, sizeof(*pInfo));
        }
        pbExtra += lAlignExtra;
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;

    return fResult;
}


//+-------------------------------------------------------------------------
//  Get the data for an Attributes
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetAnyData(
        IN Any *pAny,
        OUT void *pvData,
        IN OUT DWORD *pcbData)
{
    BOOL        fRet;
    LONG        lData;
    LONG        lRemainExtra;
    PBYTE       pbExtra;
    PCRYPT_DATA_BLOB pBlob = (PCRYPT_DATA_BLOB)pvData;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lData = INFO_LEN_ALIGN( sizeof(CRYPT_DATA_BLOB));
    lRemainExtra = (LONG)*pcbData - lData;
    if (0 > lRemainExtra) {
        pBlob = NULL;
        pbExtra = NULL;
    } else {
        pbExtra = (PBYTE)pBlob + lData;
    }
    if (!ICM_GetOssAny( pAny, pBlob, &pbExtra, &lRemainExtra))
        goto GetOssAnyError;
    fRet = ICM_GetSizeFromExtra( lRemainExtra, pvData, pcbData);

CommonReturn:
    return fRet;

ErrorReturn:
    *pcbData = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetOssAnyError)         // error already set
}


//+-------------------------------------------------------------------------
//  Get Object Identifier string
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssObjId(
        IN ObjectID *poi,
        OUT LPSTR   *ppszObjId,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra)
{
    BOOL fRet;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    LONG lObjId;

    if (!PkiAsn1FromObjectIdentifier(
            poi->count,
            poi->value,
            NULL,
            (PDWORD)&lObjId))
        goto PkiAsn1FromObjectIdentifierSizeError;
    lAlignExtra = INFO_LEN_ALIGN(lObjId);
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if(lObjId > 0) {
            *ppszObjId = (LPSTR) pbExtra;
            if (!PkiAsn1FromObjectIdentifier(
                    poi->count,
                    poi->value,
                    (LPSTR)pbExtra,
                    (PDWORD)&lObjId))
                goto PkiAsn1FromObjectIdentifierError;
        } else
            *ppszObjId = NULL;
        pbExtra += lAlignExtra;
    }
    fRet = TRUE;

CommonReturn:
    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
    return fRet;

ErrorReturn:
    *ppszObjId = NULL;
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(PkiAsn1FromObjectIdentifierSizeError,CRYPT_E_OID_FORMAT)
SET_ERROR(PkiAsn1FromObjectIdentifierError,CRYPT_E_OID_FORMAT)
}



//+-------------------------------------------------------------------------
//  Get Oss HugeInteger
//--------------------------------------------------------------------------
void
inline
WINAPI
ICM_GetOssHugeInteger(
    IN HugeIntegerType *pOssHugeInteger,
    OUT PCRYPT_INTEGER_BLOB pHugeInteger,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra
    )
{
    PkiAsn1GetHugeInteger(pOssHugeInteger->length, pOssHugeInteger->value, 0,
        pHugeInteger, ppbExtra, plRemainExtra);
}


//+-------------------------------------------------------------------------
//  Get an Attribute
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssAttribute(
        IN Attribute *poatr,
        OUT PCRYPT_ATTRIBUTE patr,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra)
{
    BOOL        fRet;
    LONG        lData;
    DWORD       i;
    Any         *pAny;
    PCRYPT_ATTR_BLOB  patrbl = NULL;

    if (!ICM_GetOssObjId(&poatr->attributeType, &patr->pszObjId,
            ppbExtra, plRemainExtra))
        goto GetOssObjIdError;

    lData = INFO_LEN_ALIGN( poatr->attributeValue.count * sizeof(CRYPT_ATTR_BLOB));
    *plRemainExtra -= lData;
    if (0 < *plRemainExtra) {
        patr->cValue = poatr->attributeValue.count;
        patr->rgValue = patrbl = (PCRYPT_ATTR_BLOB)*ppbExtra;
        *ppbExtra += lData;
    }
    for (i=poatr->attributeValue.count, pAny=poatr->attributeValue.value;
            i>0;
            i--, pAny++, patrbl++) {
        if (!ICM_GetOssAny(pAny, patrbl, ppbExtra, plRemainExtra))
            goto GetOssAnyError;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetOssObjIdError)   // error already set
TRACE_ERROR(GetOssAnyError)     // error already set
}


//+-------------------------------------------------------------------------
//  Get an CRYPT_ATTRIBUTE
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetATTRIBUTE(
        IN Attribute *poatr,
        OUT void *pvData,
        IN OUT DWORD *pcbData)
{
    BOOL        fRet;
    LONG        lData;
    LONG        lRemainExtra;
    PBYTE       pbExtra;
    PCRYPT_ATTRIBUTE  patr = (PCRYPT_ATTRIBUTE)pvData;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lData = INFO_LEN_ALIGN( sizeof(CRYPT_ATTRIBUTE));
    lRemainExtra = (LONG)*pcbData - lData;
    if (0 > lRemainExtra) {
        patr = NULL;
        pbExtra = NULL;
    } else {
        pbExtra = (PBYTE)patr + lData;
    }
    if (!ICM_GetOssAttribute( poatr, patr, &pbExtra, &lRemainExtra))
        goto GetOssAttributeError;
    fRet = ICM_GetSizeFromExtra( lRemainExtra, pvData, pcbData);

CommonReturn:
    return fRet;

ErrorReturn:
    *pcbData = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetOssAttributeError)   // error already set
}


//+-------------------------------------------------------------------------
//  Get an Attributes
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssAttributes(
        IN Attributes *poatrs,
        OUT PCRYPT_ATTRIBUTES patrs,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra)
{
    BOOL        fRet;
    LONG        lData;
    DWORD       i;
    Attribute   *poatr;
    PCRYPT_ATTRIBUTE  patr;

    lData = INFO_LEN_ALIGN( poatrs->count * sizeof(CRYPT_ATTRIBUTE));
    *plRemainExtra -= lData;
    if (0 < *plRemainExtra) {
        patrs->cAttr = poatrs->count;
        patrs->rgAttr = patr = (PCRYPT_ATTRIBUTE)*ppbExtra;
        *ppbExtra += lData;
    } else {
        patr = NULL;
    }
    for (i=poatrs->count, poatr=poatrs->value;
            i>0;
            i--, poatr++, patr++) {
        if (!ICM_GetOssAttribute( poatr, patr, ppbExtra, plRemainExtra))
            goto GetOssAttributeError;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetOssAttributeError)   // error already set
}


//+-------------------------------------------------------------------------
//  Get from an Attributes in CList form
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetCListAttributes(
        IN CBlobList *pBlobList,
        OUT PCRYPT_ATTRIBUTES patrs,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    LONG                lData;
    CBlobNode           *pBlobNode;
    AttributeNC2        *poatr = NULL;
    PCRYPT_ATTRIBUTE    patr;
    ASN1error_e         Asn1Err;
    ASN1decoding_t      pDec = ICM_GetDecoder();
    PCRYPT_DATA_BLOB    pDataBlob;

    lData = INFO_LEN_ALIGN( pBlobList->Length() * sizeof(CRYPT_ATTRIBUTE));
    *plRemainExtra -= lData;
    if (0 < *plRemainExtra) {
        patrs->cAttr = pBlobList->Length();
        patrs->rgAttr = patr = (PCRYPT_ATTRIBUTE)*ppbExtra;
        *ppbExtra += lData;
    } else {
        patr = NULL;
    }
    for (pBlobNode=pBlobList->Head();
            pBlobNode;
            pBlobNode=pBlobNode->Next(), patr++) {
        poatr = NULL;
        pDataBlob = pBlobNode->Data();
        if (0 != (Asn1Err = PkiAsn1Decode(
                pDec,
                (void **)&poatr,
                AttributeNC2_PDU,
                pDataBlob->pbData,
                pDataBlob->cbData)))
            goto DecodeAttributeNC2Error;
        if (!ICM_GetOssAttribute(
                (Attribute *)poatr,     // same, except for NOCOPY
                patr,
                ppbExtra,
                plRemainExtra))
            goto GetOssAttributeError;
        PkiAsn1FreeDecoded(pDec, poatr, AttributeNC2_PDU);
        poatr = NULL;
    }

    fRet = TRUE;
CommonReturn:
    PkiAsn1FreeInfo(pDec, AttributeNC2_PDU, poatr);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(DecodeAttributeNC2Error, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(GetOssAttributeError)       // error already set
}


//+-------------------------------------------------------------------------
//  Get the data for an Attributes
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetAttributesData(
        IN Attributes *poatrs,
        OUT void *pvData,
        IN OUT DWORD *pcbData)
{
    BOOL        fRet;
    LONG        lData;
    LONG        lRemainExtra;
    PBYTE       pbExtra;
    PCRYPT_ATTRIBUTES patrs = (PCRYPT_ATTRIBUTES)pvData;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lData = INFO_LEN_ALIGN( sizeof(CRYPT_ATTRIBUTES));
    lRemainExtra = (LONG)*pcbData - lData;
    if (0 > lRemainExtra) {
        patrs = NULL;
        pbExtra = NULL;
    } else {
        pbExtra = (PBYTE)patrs + lData;
    }
    if (!ICM_GetOssAttributes( poatrs, patrs, &pbExtra, &lRemainExtra))
        goto GetOssAttributesError;
    fRet = ICM_GetSizeFromExtra( lRemainExtra, pvData, pcbData);

CommonReturn:
    return fRet;

ErrorReturn:
    *pcbData = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetOssAttributesError)      // error already set
}


//+-------------------------------------------------------------------------
//  Get an OSS Algorithm
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssAlgorithm(
        IN AlgorithmIdentifier *pai,
        OUT PCRYPT_ALGORITHM_IDENTIFIER pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra)
{
    if (!ICM_GetOssObjId(&pai->algorithm, &pInfo->pszObjId,
            ppbExtra, plRemainExtra))
        return FALSE;
    
    if (pai->bit_mask & parameters_present) {
        if (!ICM_GetOssAny(&pai->parameters, &pInfo->Parameters,
                ppbExtra, plRemainExtra))
            return FALSE;
    } else if (*plRemainExtra >= 0) {
        memset(&pInfo->Parameters, 0, sizeof(pInfo->Parameters));
    }
    return TRUE;
}


//+-------------------------------------------------------------------------
//  Get a ContentInfo (internal)
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssContentInfo(
        IN ContentInfo *poci,
        OUT PCONTENT_INFO pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra)
{
    if (!ICM_GetOssObjId(&poci->contentType, &pInfo->pszContentType,
            ppbExtra, plRemainExtra))
        return FALSE;
    if (poci->bit_mask & content_present) {
        if (!ICM_GetOssAny(&poci->content, &pInfo->content,
                ppbExtra, plRemainExtra))
            return FALSE;
    } else {
        if (pInfo) {
            pInfo->content.cbData = 0;
            pInfo->content.pbData = 0;
        }
    }
    return TRUE;
}


//+-------------------------------------------------------------------------
//  Get a ContentInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssContentInfoData(
        IN ContentInfo *poci,
        OUT void *pvData,
        IN OUT DWORD *pcbData)
{
    BOOL        fRet;
    LONG        lData;
    LONG        lRemainExtra;
    PBYTE       pbExtra;
    PCONTENT_INFO pci = (PCONTENT_INFO)pvData;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lData = INFO_LEN_ALIGN( sizeof(CONTENT_INFO));
    lRemainExtra = (LONG)*pcbData - lData;
    if (0 > lRemainExtra) {
        pci = NULL;
        pbExtra = NULL;
    } else {
        pbExtra = (PBYTE)pci + lData;
    }
    if (!ICM_GetOssContentInfo( poci, pci, &pbExtra, &lRemainExtra))
        goto GetContentInfoError;
    fRet = ICM_GetSizeFromExtra( lRemainExtra, pvData, pcbData);

CommonReturn:
    return fRet;

ErrorReturn:
    *pcbData = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetContentInfoError)        // error already set
}


BOOL
WINAPI
ICM_GetOssIssuerAndSerialNumberFromCertId(
        IN CertIdentifier *pOssCertId,
        OUT PCERT_NAME_BLOB pIssuer,
        OUT PCRYPT_INTEGER_BLOB pSerialNumber,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra);

//+-------------------------------------------------------------------------
//  Get an Special Issuer and SerialNumber from a KeyId.
//
//  Converts the KeyId to a special encoded Issuer name having a RDN with
//  the szOID_KEYID_RDN OID and a CERT_RDN_OCTET_STRING value containing
//  the KeyId. The SerialNumber is set to 0.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssIssuerAndSerialNumberFromKeyId(
	    IN SubjectKeyIdentifier *pOssKeyId,
        OUT PCERT_NAME_BLOB pIssuer,
        OUT PCRYPT_INTEGER_BLOB pSerialNumber,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra)
{
    BOOL fRet;

    CertIdentifier OssCertId;
    ASN1octet_t SerialNumber;
    CERT_RDN_ATTR KeyIdAttr;
    CERT_RDN KeyIdRDN;
    CERT_NAME_INFO IssuerInfo;
    BYTE *pbEncodedIssuer = NULL;
    DWORD cbEncodedIssuer;

    KeyIdAttr.pszObjId = szOID_KEYID_RDN;
    KeyIdAttr.dwValueType = CERT_RDN_OCTET_STRING;
    KeyIdAttr.Value.pbData = pOssKeyId->value;
    KeyIdAttr.Value.cbData = pOssKeyId->length;
    KeyIdRDN.cRDNAttr = 1;
    KeyIdRDN.rgRDNAttr = &KeyIdAttr;
    IssuerInfo.cRDN = 1;
    IssuerInfo.rgRDN = &KeyIdRDN;

    // Encode the special Issuer Name containing the KeyId
    if (!CryptEncodeObjectEx(
            X509_ASN_ENCODING,
            X509_NAME,
            &IssuerInfo,
            CRYPT_ENCODE_ALLOC_FLAG,
            &PkiEncodePara,
            (void *) &pbEncodedIssuer,
            &cbEncodedIssuer
            ))
        goto EncodeError;

    OssCertId.choice = issuerAndSerialNumber_chosen;
    OssCertId.u.issuerAndSerialNumber.serialNumber.length = 1;
    OssCertId.u.issuerAndSerialNumber.serialNumber.value = &SerialNumber;
    SerialNumber = 0;
    OssCertId.u.issuerAndSerialNumber.issuer.length = cbEncodedIssuer;
    OssCertId.u.issuerAndSerialNumber.issuer.value = pbEncodedIssuer;

    fRet = ICM_GetOssIssuerAndSerialNumberFromCertId(
        &OssCertId,
        pIssuer,
        pSerialNumber,
        ppbExtra,
        plRemainExtra
        );

CommonReturn:
    PkiFree(pbEncodedIssuer);
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(EncodeError)
}

//+-------------------------------------------------------------------------
//  Get an Issuer and SerialNumber from a CertIdentifier.
//
//  Converts a KEYID choice to a special encoded Issuer name having a RDN with
//  the szOID_KEYID_RDN OID and a CERT_RDN_OCTET_STRING value containing
//  the KeyId. The SerialNumber is set to 0.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssIssuerAndSerialNumberFromCertId(
        IN CertIdentifier *pOssCertId,
        OUT PCERT_NAME_BLOB pIssuer,
        OUT PCRYPT_INTEGER_BLOB pSerialNumber,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra)
{
    BOOL fRet;

    switch (pOssCertId->choice) {
        case issuerAndSerialNumber_chosen:
            ICM_GetOssHugeInteger(
                &pOssCertId->u.issuerAndSerialNumber.serialNumber,
                pSerialNumber, ppbExtra, plRemainExtra);
            if (!ICM_GetOssAny(&pOssCertId->u.issuerAndSerialNumber.issuer,
                    pIssuer, ppbExtra, plRemainExtra))
                goto GetIssuerError;
            break;
        case subjectKeyIdentifier_chosen:
            if (!ICM_GetOssIssuerAndSerialNumberFromKeyId(
                    &pOssCertId->u.subjectKeyIdentifier,
                    pIssuer, pSerialNumber, ppbExtra, plRemainExtra))
                goto GetKeyIdError;
            break;
        default:
            goto InvalidCertIdChoice;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetIssuerError)
TRACE_ERROR(GetKeyIdError)
SET_ERROR(InvalidCertIdChoice, CRYPT_E_BAD_ENCODE)
}

BOOL
WINAPI
ICM_GetOssIssuerAndSerialNumberForCertInfo(
        IN CertIdentifier *pOssCertId,
        OUT PCERT_INFO pCertInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra)
{
    return ICM_GetOssIssuerAndSerialNumberFromCertId(
        pOssCertId,
        &pCertInfo->Issuer,
        &pCertInfo->SerialNumber,
        ppbExtra,
        plRemainExtra
        );
}


//+-------------------------------------------------------------------------
//  Get an CertInfo with an updated IssuerAndSerialNumber
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetCertInfoIssuerAndSerialNumber(
    IN CertIdentifier *pOssCertIdentifier,
    OUT void *pvData,
    IN OUT DWORD *pcbData)
{
    BOOL         fRet;
    LONG         lData;
    PCERT_INFO   pci = (PCERT_INFO)pvData;
    PBYTE        pbExtra;
    LONG         lRemainExtra;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lData = INFO_LEN_ALIGN( sizeof(CERT_INFO));
    lRemainExtra = (LONG)*pcbData - lData;
    if (0 > lRemainExtra) {
        pci = NULL;
        pbExtra = NULL;
    } else {
        pbExtra = (PBYTE)pci + lData;
    }
    if (!ICM_GetOssIssuerAndSerialNumberForCertInfo(pOssCertIdentifier,
            pci, &pbExtra, &lRemainExtra))
        goto GetOssIssuerAndSerialNumberError;
    fRet = ICM_GetSizeFromExtra( lRemainExtra, pvData, pcbData);

CommonReturn:
    return fRet;

ErrorReturn:
    *pcbData = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetOssIssuerAndSerialNumberError)   // error already set
}

BOOL
WINAPI
ICM_GetOssCertIdentifier(
    IN CertIdentifier *pOssCertId,
    OUT PCERT_ID pCertId,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra
    );

BOOL
WINAPI
ICM_GetCertId(
    IN CertIdentifier *pOssCertIdentifier,
    OUT void *pvData,
    IN OUT DWORD *pcbData)
{
    BOOL         fRet;
    LONG         lData;
    PCERT_ID     pid = (PCERT_ID)pvData;
    PBYTE        pbExtra;
    LONG         lRemainExtra;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lData = INFO_LEN_ALIGN( sizeof(CERT_ID));
    lRemainExtra = (LONG)*pcbData - lData;
    if (0 > lRemainExtra) {
        pid = NULL;
        pbExtra = NULL;
    } else {
        pbExtra = (PBYTE)pid + lData;
    }
    if (!ICM_GetOssCertIdentifier(pOssCertIdentifier,
            pid, &pbExtra, &lRemainExtra))
        goto GetOssCertIdentifierError;
    fRet = ICM_GetSizeFromExtra( lRemainExtra, pvData, pcbData);

CommonReturn:
    return fRet;

ErrorReturn:
    *pcbData = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetOssCertIdentifierError)   // error already set
}


//+-------------------------------------------------------------------------
//  Copy out an CRYPT_ALGORITHM_IDENTIFIER
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetALGORITHM_IDENTIFIER(
    IN AlgorithmIdentifier *paiOss,
    OUT void *pvData,
    IN OUT DWORD *pcbData)
{
    BOOL                    fRet;
    LONG                    lData;
    PCRYPT_ALGORITHM_IDENTIFIER   pai = (PCRYPT_ALGORITHM_IDENTIFIER)pvData;
    PBYTE                   pbExtra;
    LONG                    lRemainExtra;

    if (NULL == pvData)
        *pcbData = 0;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lData = INFO_LEN_ALIGN( sizeof(CRYPT_ALGORITHM_IDENTIFIER));
    lRemainExtra = (LONG)*pcbData - lData;
    if (0 > lRemainExtra) {
        pai = NULL;
        pbExtra = NULL;
    } else {
        pbExtra = (PBYTE)pai + lData;
    }
    if (!ICM_GetOssAlgorithm( paiOss, pai, &pbExtra, &lRemainExtra))
        goto GetOssAlgorithmError;
    fRet = ICM_GetSizeFromExtra( lRemainExtra, pvData, pcbData);

CommonReturn:
    return fRet;

ErrorReturn:
    *pcbData = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetOssAlgorithmError)       // error already set
}


//+-------------------------------------------------------------------------
//  Get the digest in a DIGESTED message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetDigestDataParam(
    IN PCRYPT_MSG_INFO pcmi,
    OUT void *pvData,
    IN OUT DWORD *pcbData)
{
    BOOL            fRet;
    DigestedData    *pdd;

    if (CMSG_HASHED != pcmi->dwMsgType)
        goto InvalidMsgType;
    pdd = (DigestedData *)pcmi->pvMsg;
    fRet = ICM_CopyOut(
                (PBYTE)pdd->digest.value,
                (DWORD)pdd->digest.length,
                (PBYTE)pvData,
                pcbData);

CommonReturn:
    return fRet;

ErrorReturn:
    *pcbData = 0;
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidMsgType,CRYPT_E_INVALID_MSG_TYPE)
}

#ifdef CMS_PKCS7

HCRYPTHASH
WINAPI
ICM_GetEncodedSignerHash(
    IN PCRYPT_MSG_INFO  pcmi,
    IN DWORD            dwSignerIndex
    )
{
    HCRYPTHASH hHash = NULL;
    SignerInfo *psi;
    PSIGNER_ENCODE_DATA_INFO pSignerEncodeDataInfo;
    CHashNode *pnHash;
    PICM_HASH_INFO pHashInfo;

    if (dwSignerIndex >= ((SignedData *)pcmi->pvMsg)->signerInfos.count)
        goto IndexTooBig;
    psi = ((SignedData *)pcmi->pvMsg)->signerInfos.value + dwSignerIndex;
    pSignerEncodeDataInfo = pcmi->rgSignerEncodeDataInfo + dwSignerIndex;
    pnHash = pSignerEncodeDataInfo->pHashNode;
    pHashInfo = pnHash->Data();

    if (psi->bit_mask & authenticatedAttributes_present) {
        if (!ICM_GetAttrsHash(
                pHashInfo->dwAlgoCAPI,
                pSignerEncodeDataInfo->hCryptProv,
                &psi->authenticatedAttributes,
                &hHash))
            goto GetAuthAttrsHashError;
    } else {
        if (!ICM_DupListHash( pnHash, pSignerEncodeDataInfo->hCryptProv,
                &hHash))
            goto DupListHashError;
    }

CommonReturn:
    return hHash;

ErrorReturn:
    hHash = NULL;
    goto CommonReturn;

SET_ERROR(IndexTooBig,CRYPT_E_INVALID_INDEX)
TRACE_ERROR(GetAuthAttrsHashError)      // error already set
TRACE_ERROR(DupListHashError)           // error already set
}


HCRYPTHASH
WINAPI
ICM_GetDecodedSignerHash(
    IN PCRYPT_MSG_INFO  pcmi,
    IN DWORD            dwSignerIndex
    )
{
    HCRYPTHASH              hHash = NULL;
    DWORD                   dwError = ERROR_SUCCESS;
    SignerInfoWithBlobs     *psib = NULL;
    CSignerNode             *pSignerNode = NULL;
    HCRYPTPROV              hCryptProv;         // doen't need to be released
    ASN1error_e             Asn1Err;
    ASN1decoding_t          pDec = ICM_GetDecoder();
    CRYPT_DATA_BLOB         DataBlob;
    CHashNode               *pnHash;
    PICM_HASH_INFO          pHashInfo;

    if (!ICM_FindSignerInfo(pcmi, dwSignerIndex, (PVOID *)&pSignerNode))
        goto FindSignerInfoError;

    DataBlob = pSignerNode->Data()->blob;
    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&psib,
            SignerInfoWithBlobs_PDU,
            DataBlob.pbData,
            DataBlob.cbData)))
        goto DecodeSignerInfoWithBlobsError;

    if (!ICM_FindHashNodeFromEncodedAlgo(
            pcmi->pHashList,
            (PCRYPT_DATA_BLOB)&psib->digestAlgorithm,
            &pnHash))
        goto GetHashNodeFromEncodedAlgoError;
    pHashInfo = pnHash->Data();

    if (pcmi->fDefaultCryptProv)
        hCryptProv = 0;
    else
        hCryptProv = pcmi->hCryptProv;
    if (0 == hCryptProv) {
        hCryptProv = I_CryptGetDefaultCryptProv(0);
        if (0 == hCryptProv)
            goto GetDefaultCryptProvError;
    }

    if (psib->bit_mask & authAttributes_present) {
        if (!ICM_GetAttrsHash(
                pHashInfo->dwAlgoCAPI,
                hCryptProv,
                (Attributes *)&psib->authAttributes,    // same, except for NOCOPY
                &hHash))
            goto GetAuthAttrsHashError;
    } else {
        if (!ICM_DupListHash( pnHash, hCryptProv, &hHash))
            goto DupListHashError;
    }

CommonReturn:
    PkiAsn1FreeInfo(pDec, SignerInfoWithBlobs_PDU, psib);
    ICM_SetLastError(dwError);
    return hHash;

ErrorReturn:
    dwError = GetLastError();
    hHash = NULL;
    goto CommonReturn;

TRACE_ERROR(FindSignerInfoError)                // error already set
SET_ERROR_VAR(DecodeSignerInfoWithBlobsError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(GetHashNodeFromEncodedAlgoError)    // error already set
TRACE_ERROR(GetDefaultCryptProvError)           // error already set
TRACE_ERROR(GetAuthAttrsHashError)              // error already set
TRACE_ERROR(DupListHashError)                   // error already set
}

#endif  // CMS_PKCS7

//+-------------------------------------------------------------------------
//  Get the digest of the content in a DIGESTED message or for one of
//  the signers in a SIGNED message
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetComputedDigestParam(
    IN PCRYPT_MSG_INFO pcmi,
    IN DWORD dwIndex,
    OUT void *pvData,
    IN OUT DWORD *pcbData)
{
    BOOL                fRet;
    DWORD               dwError = ERROR_SUCCESS;
    HCRYPTHASH          hHash = NULL;
    PBYTE               pbAllocHash = NULL;
    DWORD               cbHash;
    PBYTE               pbHash;

    switch (pcmi->dwMsgType) {
    case CMSG_HASHED:
        if (!ICM_GetListHashValue(
                pcmi->pHashList->Head(),
                &cbHash,
                &pbHash))
            goto GetHashValueError;
        break;
#ifdef CMS_PKCS7
    case CMSG_SIGNED:
        if (pcmi->fEncoding)
            hHash = ICM_GetEncodedSignerHash(pcmi, dwIndex);
        else
            hHash = ICM_GetDecodedSignerHash(pcmi, dwIndex);
        if (NULL == hHash)
            goto GetSignerHashError;

        if (!CryptGetHashParam(
                hHash,
                HP_HASHVAL,
                NULL,
                &cbHash,
                0))                     // dwFlags
            goto GetHashParamSizeError;
        if (NULL == (pbAllocHash = (PBYTE)ICM_AllocA(cbHash)))
            goto AllocHashParamError;
        pbHash = pbAllocHash;
        if (!CryptGetHashParam(
                hHash,
                HP_HASHVAL,
                pbHash,
                &cbHash,
                0))                     // dwFlags
            goto GetHashParamError;
        break;
#endif  // CMS_PKCS7
    default:
        goto InvalidMsgType;
    }

    fRet = ICM_CopyOut(
                pbHash,
                cbHash,
                (PBYTE)pvData,
                pcbData);
    if (!fRet)
        dwError = GetLastError();

CommonReturn:
    if (hHash)
        CryptDestroyHash(hHash);
    ICM_FreeA(pbAllocHash);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    *pcbData = 0;
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidMsgType,CRYPT_E_INVALID_MSG_TYPE)
TRACE_ERROR(GetHashValueError)
TRACE_ERROR(GetSignerHashError)
TRACE_ERROR(GetHashParamSizeError)
TRACE_ERROR(AllocHashParamError)
TRACE_ERROR(GetHashParamError)
}


//+-------------------------------------------------------------------------
//  Find the SignerInfo by index, if the message type permits and if the
//  index value is in range.
//
//  Returns:    FALSE iff fails
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_FindSignerInfo(
    IN PCRYPT_MSG_INFO  pcmi,
    IN DWORD            dwIndex,
    OUT PVOID           *ppv)
{
    BOOL        fRet;
    PVOID       pv;
    SignerInfo  *psi = NULL;
    CSignerNode *pSignerNode = NULL;
    DWORD       i;

    if (pcmi->fEncoding) {

        switch (pcmi->dwMsgType) {
        case CMSG_SIGNED:
            if (dwIndex >= ((SignedData *)pcmi->pvMsg)->signerInfos.count)
                goto IndexTooBig;
            psi = ((SignedData *)pcmi->pvMsg)->signerInfos.value + dwIndex;
            break;
        case CMSG_SIGNED_AND_ENVELOPED:
            goto MessageTypeNotSupportedYet;
        default:
            goto InvalidMsgType;
        }

        pv = psi;

    } else {

        switch (pcmi->dwMsgType) {
        case CMSG_SIGNED:
            if (NULL == pcmi->psdi)
                goto InvalidSignedMessageError;
            for (i=dwIndex, pSignerNode=pcmi->psdi->pSignerList->Head();
                    (i>0) && pSignerNode;
                    i--, pSignerNode=pSignerNode->Next())
                ;
            if (NULL == pSignerNode)
                goto IndexTooBig;
            break;
        case CMSG_SIGNED_AND_ENVELOPED:
            goto MessageTypeNotSupportedYet;
        default:
            goto InvalidMsgType;
        }

        pv = pSignerNode;
    }

    fRet = TRUE;
CommonReturn:
    *ppv = pv;
    return fRet;

ErrorReturn:
    pv = NULL;
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidSignedMessageError, ERROR_INVALID_DATA)
SET_ERROR(IndexTooBig,CRYPT_E_INVALID_INDEX)
SET_ERROR(MessageTypeNotSupportedYet,CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(InvalidMsgType,CRYPT_E_INVALID_MSG_TYPE)
}


//+-------------------------------------------------------------------------
//  Countersign an already-existing signature, output an encoded attribute
//--------------------------------------------------------------------------
BOOL
WINAPI
#ifdef DEBUG_CRYPT_ASN1_MASTER
ICMTest_NewCryptMsgCountersignEncoded(
#else
CryptMsgCountersignEncoded(
#endif
    IN DWORD                    dwEncodingType,
    IN PBYTE                    pbSignerInfo,
    IN DWORD                    cbSignerInfo,
    IN DWORD                    cCountersigners,
    IN PCMSG_SIGNER_ENCODE_INFO rgCountersigners,
    OUT PBYTE                   pbCountersignatureAttribute,
    IN OUT PDWORD               pcbCountersignatureAttribute)
{
    DWORD                       dwError = ERROR_SUCCESS;
    BOOL                        fRet;
    HCRYPTMSG                   hCryptMsgCountersign = NULL;
    CMSG_SIGNED_ENCODE_INFO     EncodeInfo;     ZEROSTRUCT(EncodeInfo);
    EncodeInfo.cbSize = sizeof(EncodeInfo);
    CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA   UnauthAttrPara; ZEROSTRUCT(UnauthAttrPara);
    UnauthAttrPara.cbSize = sizeof(UnauthAttrPara);
    Attribute                   oatrCountersignature;   ZEROSTRUCT(oatrCountersignature);
    ASN1error_e                 Asn1Err;
    ASN1decoding_t              pDec = ICM_GetDecoder();
    ASN1encoding_t              pEnc = ICM_GetEncoder();
    PBYTE                       pbEncoded = NULL;
    DWORD                       cbEncoded;
    SignerInfoWithBlobs         *posib = NULL;
    DWORD                       i;
    Any                         *pAny;
    DWORD                       dwFlags;

    if (GET_CMSG_ENCODING_TYPE(dwEncodingType) != PKCS_7_ASN_ENCODING)
        goto InvalidEncodingTypeError;

    // crack the SignerInfo being countersigned
    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&posib,
            SignerInfoWithBlobs_PDU,
            pbSignerInfo,
            cbSignerInfo)))
        goto DecodeSignerInfoError;

    // create a new message
    EncodeInfo.cSigners  = cCountersigners;
    EncodeInfo.rgSigners = rgCountersigners;
    dwFlags = CMSG_AUTHENTICATED_ATTRIBUTES_FLAG;
    if (NULL == pbCountersignatureAttribute ||
            0 == *pcbCountersignatureAttribute)
        dwFlags |= CMSG_MAX_LENGTH_FLAG;
    if (NULL == (hCryptMsgCountersign = CryptMsgOpenToEncode(
            PKCS_7_ASN_ENCODING,
            dwFlags,
            CMSG_SIGNED,
            &EncodeInfo,
            NULL,                       // pszInnerContentObjID
            NULL)))                     // pStreamInfo
        goto OpenToEncodeError;

    // feed encrypted digest into the new message
    if (!CryptMsgUpdate(
            hCryptMsgCountersign,
            posib->encryptedDigest.value,
            posib->encryptedDigest.length,
            TRUE))                      // fFinal
        goto UpdateError;

    oatrCountersignature.attributeType.count = SIZE_OSS_OID;
    if (!PkiAsn1ToObjectIdentifier(
            szOID_RSA_counterSign,
            &oatrCountersignature.attributeType.count,
            oatrCountersignature.attributeType.value))
        goto PkiAsn1ToObjectIdentifierError;
    oatrCountersignature.attributeValue.count = cCountersigners;
    if (NULL == (oatrCountersignature.attributeValue.value = (Any *)ICM_AllocA(
            cCountersigners * sizeof(Any))))
        goto AllocCountersignersError;

    // extract encoded SignerInfo's, and store
    for (i=0, pAny=oatrCountersignature.attributeValue.value;
            i<cCountersigners;
            i++, pAny++) {
        cbSignerInfo = 0;
        CryptMsgGetParam(
                hCryptMsgCountersign,
                CMSG_ENCODED_SIGNER,
                i,
                NULL,
                &cbSignerInfo);
        if (cbSignerInfo == 0)
            goto GetSignerInfoSizeError;
        if (NULL == (pbSignerInfo = (PBYTE)ICM_AllocA( cbSignerInfo)))
            goto AllocSignerInfoError;
        if (!CryptMsgGetParam(
                hCryptMsgCountersign,
                CMSG_ENCODED_SIGNER,
                i,
                pbSignerInfo,
                &cbSignerInfo))
            goto GetSignerInfoError;
        pAny->length = cbSignerInfo;
        pAny->value  = pbSignerInfo;
    }

    // encode the Countersignature attribute
    if (0 != (Asn1Err = PkiAsn1Encode(
            pEnc,
            &oatrCountersignature,
            AttributeNC2_PDU,
            &pbEncoded,
            &cbEncoded)))
        goto Asn1EncodeAttributeError;

    // copy out the Countersignature attribute
    fRet = ICM_CopyOut(
                    pbEncoded,
                    cbEncoded,
                    pbCountersignatureAttribute,
                    pcbCountersignatureAttribute);
    if (!fRet)
        dwError = GetLastError();

CommonReturn:
    PkiAsn1FreeInfo(pDec, SignerInfoWithBlobs_PDU, posib);
    CryptMsgClose( hCryptMsgCountersign);
    if (oatrCountersignature.attributeValue.value) {
        for (i=cCountersigners, pAny=oatrCountersignature.attributeValue.value;
                i>0;
                i--, pAny++)
            ICM_FreeA( pAny->value);
        ICM_FreeA( oatrCountersignature.attributeValue.value);
    }
    PkiAsn1FreeEncoded(pEnc, pbEncoded);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidEncodingTypeError,E_INVALIDARG)
SET_ERROR_VAR(DecodeSignerInfoError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(PkiAsn1ToObjectIdentifierError,CRYPT_E_OID_FORMAT)
SET_ERROR_VAR(Asn1EncodeAttributeError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(OpenToEncodeError)                  // error already set
TRACE_ERROR(UpdateError)                        // error already set
TRACE_ERROR(AllocCountersignersError)           // error already set
TRACE_ERROR(GetSignerInfoSizeError)             // error already set
TRACE_ERROR(AllocSignerInfoError)               // error already set
TRACE_ERROR(GetSignerInfoError)                 // error already set
}


//+-------------------------------------------------------------------------
//  Countersign an already-existing signature in a message
//--------------------------------------------------------------------------
BOOL
WINAPI
#ifdef DEBUG_CRYPT_ASN1_MASTER
ICMTest_NewCryptMsgCountersign(
#else
CryptMsgCountersign(
#endif
    IN OUT HCRYPTMSG            hCryptMsg,
    IN DWORD                    dwIndex,
    IN DWORD                    cCountersigners,
    IN PCMSG_SIGNER_ENCODE_INFO rgCountersigners)
{
    DWORD                       dwError = ERROR_SUCCESS;
    BOOL                        fRet;
    PBYTE                       pbCountersignatureAttribute = NULL;
    DWORD                       cbCountersignatureAttribute;
    PBYTE                       pbSignerInfo = NULL;
    DWORD                       cbSignerInfo;
    CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA   UnauthAttrPara; ZEROSTRUCT(UnauthAttrPara);
    UnauthAttrPara.cbSize = sizeof(UnauthAttrPara);

    if (((PCRYPT_MSG_INFO)hCryptMsg)->fEncoding)
        goto EncodingCountersignNotSupportedError;

    // extract encoded SignerInfo being countersigned from the message
    cbSignerInfo = 0;
    CryptMsgGetParam(
            hCryptMsg,
            CMSG_ENCODED_SIGNER,
            dwIndex,
            NULL,
            &cbSignerInfo);
    if (cbSignerInfo == 0)
        goto GetEncodedSignerSizeError;
    if (NULL == (pbSignerInfo = (PBYTE)ICM_AllocA( cbSignerInfo)))
        goto AllocEncodedSignerError;
    if (!CryptMsgGetParam(
            hCryptMsg,
            CMSG_ENCODED_SIGNER,
            dwIndex,
            pbSignerInfo,
            &cbSignerInfo))
        goto GetEncodedSignerError;

    // create the countersignature blob
    cbCountersignatureAttribute = 0;
    CryptMsgCountersignEncoded(
            PKCS_7_ASN_ENCODING,
            pbSignerInfo,
            cbSignerInfo,
            cCountersigners,
            rgCountersigners,
            NULL,
            &cbCountersignatureAttribute);
    if (cbCountersignatureAttribute == 0)
        goto GetCountersignatureAttributeSizeError;
    if (NULL == (pbCountersignatureAttribute = (PBYTE)ICM_AllocA( cbCountersignatureAttribute)))
        goto AllocCountersignatureAttributeError;
    if (!CryptMsgCountersignEncoded(
            PKCS_7_ASN_ENCODING,
            pbSignerInfo,
            cbSignerInfo,
            cCountersigners,
            rgCountersigners,
            pbCountersignatureAttribute,
            &cbCountersignatureAttribute))
        goto GetCountersignatureAttributeError;

    // add encoded Countersignature attribute to unauth attrs
    UnauthAttrPara.dwSignerIndex = dwIndex;
    UnauthAttrPara.blob.cbData = cbCountersignatureAttribute;
    UnauthAttrPara.blob.pbData = pbCountersignatureAttribute;
    if (!CryptMsgControl(
            hCryptMsg,
            0,                          // dwFlags
            CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR,
            &UnauthAttrPara))
        goto AddUnauthAttrError;

    fRet = TRUE;
CommonReturn:
    ICM_FreeA( pbSignerInfo);
    ICM_FreeA( pbCountersignatureAttribute);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(EncodingCountersignNotSupportedError)   // error already set
TRACE_ERROR(GetEncodedSignerSizeError)              // error already set
TRACE_ERROR(AllocEncodedSignerError)                // error already set
TRACE_ERROR(GetEncodedSignerError)                  // error already set
TRACE_ERROR(GetCountersignatureAttributeSizeError)  // error already set
TRACE_ERROR(AllocCountersignatureAttributeError)    // error already set
TRACE_ERROR(GetCountersignatureAttributeError)      // error already set
TRACE_ERROR(AddUnauthAttrError)                     // error already set
}

#ifdef CMS_PKCS7

//+-------------------------------------------------------------------------
//  Verify a countersignature, at the SignerInfo level.
//  ie. verify that pbSignerInfoCountersignature contains the encrypted
//  hash of the encryptedDigest field of pbSignerInfo.
//
//  hCryptProv is used to hash the encryptedDigest field of pbSignerInfo.
//
//  The signer can be a CERT_PUBLIC_KEY_INFO, certificate context or a
//  chain context. 
//--------------------------------------------------------------------------
BOOL
WINAPI
#ifdef DEBUG_CRYPT_ASN1_MASTER
ICMTest_NewCryptMsgVerifyCountersignatureEncodedEx(
#else
CryptMsgVerifyCountersignatureEncodedEx(
#endif
    IN HCRYPTPROV   hCryptProv,
    IN DWORD        dwEncodingType,
    IN PBYTE        pbSignerInfo,
    IN DWORD        cbSignerInfo,
    IN PBYTE        pbSignerInfoCountersignature,
    IN DWORD        cbSignerInfoCountersignature,
    IN DWORD        dwSignerType,
    IN void         *pvSigner,
    IN DWORD        dwFlags,
    IN OPTIONAL void *pvReserved
    )
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    SignerInfoWithBlobs     *posib = NULL;
    SignerInfoWithBlobs     *posibCS = NULL;
    Any                     anyValue;
    DWORD                   cbMessageDigest;
    PBYTE                   pbMessageDigest;
    DWORD                   dwDigestAlgoCAPI;
    DWORD                   dwPubKeyAlgId;
    DWORD                   dwPubKeyFlags;
    ASN1error_e             Asn1Err;
    ASN1decoding_t          pDec = ICM_GetDecoder();
    HCRYPTKEY               hPubKey = NULL;
    HCRYPTHASH              hHashRaw = NULL;
    HCRYPTHASH              hHashAttr = NULL;
    PBYTE                   pbHash = NULL;
    DWORD                   cbHash;

    if (GET_CMSG_ENCODING_TYPE(dwEncodingType) != PKCS_7_ASN_ENCODING)
        goto InvalidEncodingTypeError;

    // crack the SignerInfo being countersigned
    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&posib,
            SignerInfoWithBlobs_PDU,
            pbSignerInfo,
            cbSignerInfo)))
        goto DecodeSignerInfoError;

    // crack the SignerInfo doing the countersigning
    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&posibCS,
            SignerInfoWithBlobs_PDU,
            pbSignerInfoCountersignature,
            cbSignerInfoCountersignature)))
        goto DecodeSignerInfoCSError;

    if (!ICM_GetVerifySignatureStuff(
            dwSignerType,
            pvSigner,
            &hCryptProv,
            &hPubKey,
            &dwPubKeyAlgId,
            &dwPubKeyFlags)) goto GetSignatureStuffError;

    // hash the encrypted digest
    if (!ICM_GetCapiFromAlgidBlob(
            (PCRYPT_DATA_BLOB)&posibCS->digestAlgorithm,
            &dwDigestAlgoCAPI))
        goto GetCapiFromAlgidBlobError;
    if (!CryptCreateHash(
            hCryptProv,
            dwDigestAlgoCAPI,
            NULL,               // hKey - optional for MAC
            0,                  // dwFlags
            &hHashRaw))
        goto CreateHashError;
    if (!ICM_UpdateDigest(
            hHashRaw,
            posib->encryptedDigest.value,
            posib->encryptedDigest.length))
        goto HashDataError;

    if (0 == (posibCS->bit_mask & authAttributes_present))
        goto CountersignerAuthAttributesMissingError;

    // check that the message digest attr matches the hashed encrypted digest
    if (!CryptGetHashParam(
            hHashRaw,
            HP_HASHVAL,
            NULL,
            &cbHash,
            0))                     // dwFlags
        goto GetHashParamSizeError;
    if (NULL == (pbHash = (PBYTE)ICM_AllocA( cbHash)))
        goto AllocHashParamError;
    if (!CryptGetHashParam(
            hHashRaw,
            HP_HASHVAL,
            pbHash,
            &cbHash,
            0))                     // dwFlags
        goto GetHashParamError;
    // find the message digest attr value
    if (!ICM_GetAttrValue(
            (Attributes *)&posibCS->authAttributes, // same, except for NOCOPY
            &oidMessageDigest,
            &anyValue))
        goto FindAttrError;
    // find the message digest octets
    if (!Asn1UtilExtractContent(
#ifdef OSS_CRYPT_ASN1
            anyValue.value,
#else
            (const BYTE *) anyValue.value,
#endif  // OSS_CRYPT_ASN1
            anyValue.length,
            &cbMessageDigest,
            (const BYTE **)&pbMessageDigest))
        goto ExtractContentError;
    // hash sizes equal?
    if (cbHash != cbMessageDigest)
        goto HashCompareSizeError;
    // hash octets equal?
    if (memcmp( pbMessageDigest, pbHash, cbHash))
        goto HashCompareValueError;
    // Now that we have verified the message digest octets,
    // get the hash of the authenticated attributes.
    if (!ICM_GetAttrsHash(
            dwDigestAlgoCAPI,
            hCryptProv,
            (Attributes *)&posibCS->authAttributes, // same, except for NOCOPY
            &hHashAttr))
        goto GetAuthAttrsHashError;

    // verify the hash, signature, and public key are consistent
    if (!ICM_VerifySignature(
            hHashAttr,
            hPubKey,
            dwPubKeyAlgId,
            dwPubKeyFlags,
            posibCS->encryptedDigest.value,
            posibCS->encryptedDigest.length))
        goto VerifySignatureError;

    fRet = TRUE;

CommonReturn:
    PkiAsn1FreeInfo(pDec, SignerInfoWithBlobs_PDU, posib);
    PkiAsn1FreeInfo(pDec, SignerInfoWithBlobs_PDU, posibCS);
    if (hHashRaw)
        CryptDestroyHash( hHashRaw);
    if (hHashAttr)
        CryptDestroyHash( hHashAttr);
    if (hPubKey)
        CryptDestroyKey( hPubKey);
    ICM_FreeA( pbHash);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidEncodingTypeError,E_INVALIDARG)
SET_ERROR_VAR(DecodeSignerInfoError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR_VAR(DecodeSignerInfoCSError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(CountersignerAuthAttributesMissingError,CRYPT_E_AUTH_ATTR_MISSING)
SET_ERROR(FindAttrError,CRYPT_E_AUTH_ATTR_MISSING)
SET_ERROR(ExtractContentError,CRYPT_E_UNEXPECTED_ENCODING)
SET_ERROR(HashCompareSizeError,CRYPT_E_HASH_VALUE)
SET_ERROR(HashCompareValueError,CRYPT_E_HASH_VALUE)
TRACE_ERROR(GetCapiFromAlgidBlobError)      // error already set
TRACE_ERROR(CreateHashError)                // error already set
TRACE_ERROR(HashDataError)                  // error already set
TRACE_ERROR(GetHashParamSizeError)          // error already set
TRACE_ERROR(AllocHashParamError)            // error already set
TRACE_ERROR(GetHashParamError)              // error already set
TRACE_ERROR(GetAuthAttrsHashError)          // error already set
TRACE_ERROR(GetSignatureStuffError)         // error already set
TRACE_ERROR(VerifySignatureError)           // error already set
}

//+-------------------------------------------------------------------------
//  Verify a countersignature, at the SignerInfo level
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptMsgVerifyCountersignatureEncoded(
    IN HCRYPTPROV   hCryptProv,
    IN DWORD        dwEncodingType,
    IN PBYTE        pbSignerInfo,
    IN DWORD        cbSignerInfo,
    IN PBYTE        pbSignerInfoCountersignature,
    IN DWORD        cbSignerInfoCountersignature,
    IN PCERT_INFO   pciCountersigner)
{
    return CryptMsgVerifyCountersignatureEncodedEx(
        hCryptProv,
        dwEncodingType,
        pbSignerInfo,
        cbSignerInfo,
        pbSignerInfoCountersignature,
        cbSignerInfoCountersignature,
        CMSG_VERIFY_SIGNER_PUBKEY,
        (void *) &pciCountersigner->SubjectPublicKeyInfo,
        0,                                                  // dwFlags
        NULL                                                // pvReserved
        );
}


#else


//+-------------------------------------------------------------------------
//  Verify a countersignature, at the SignerInfo level
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptMsgVerifyCountersignatureEncoded(
    IN HCRYPTPROV   hCryptProv,
    IN DWORD        dwEncodingType,
    IN PBYTE        pbSignerInfo,
    IN DWORD        cbSignerInfo,
    IN PBYTE        pbSignerInfoCountersignature,
    IN DWORD        cbSignerInfoCountersignature,
    IN PCERT_INFO   pciCountersigner)
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    SignerInfoWithBlobs     *posib = NULL;
    SignerInfoWithBlobs     *posibCS = NULL;
    Any                     anyValue;
    DWORD                   cbMessageDigest;
    PBYTE                   pbMessageDigest;
    DWORD                   dwDigestAlgoCAPI;
    DWORD                   dwPubKeyAlgId;
    DWORD                   dwPubKeyFlags;
    ASN1error_e             Asn1Err;
    ASN1decoding_t          pDec = ICM_GetDecoder();
    IssuerAndSerialNumber   *pisn = NULL;
    HCRYPTKEY               hPubKey = NULL;
    HCRYPTHASH              hHashRaw = NULL;
    HCRYPTHASH              hHashAttr = NULL;
    PBYTE                   pbHash = NULL;
    DWORD                   cbHash;

    if (GET_CMSG_ENCODING_TYPE(dwEncodingType) != PKCS_7_ASN_ENCODING)
        goto InvalidEncodingTypeError;

    // crack the SignerInfo being countersigned
    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&posib,
            SignerInfoWithBlobs_PDU,
            pbSignerInfo,
            cbSignerInfo)))
        goto DecodeSignerInfoError;

    // crack the SignerInfo doing the countersigning
    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&posibCS,
            SignerInfoWithBlobs_PDU,
            pbSignerInfoCountersignature,
            cbSignerInfoCountersignature)))
        goto DecodeSignerInfoCSError;

    // verify that the countersignature SignerInfo and the cert info are consistent
    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&pisn,
            IssuerAndSerialNumber_PDU,
            (BYTE *) posibCS->issuerAndSerialNumber.value,
            posibCS->issuerAndSerialNumber.length)))
        goto DecodeIssuerAndSerialNumberError;
    if (pisn->issuer.length != pciCountersigner->Issuer.cbData)
        goto IssuerSizeMismatchError;
    if (0 != memcmp(
            pciCountersigner->Issuer.pbData,
            pisn->issuer.value,
            pciCountersigner->Issuer.cbData))
        goto IssuerValueMismatchError;
    if (pisn->serialNumber.length != pciCountersigner->SerialNumber.cbData)
        goto SerialNumberSizeMismatchError;
    if (ICM_ReverseCompare(
            pisn->serialNumber.value,
            pciCountersigner->SerialNumber.pbData,
            pciCountersigner->SerialNumber.cbData))
        goto SerialNumberValueMismatchError;

    if (!ICM_GetVerifySignatureStuff(
            pciCountersigner,
            &hCryptProv,
            &hPubKey,
            &dwPubKeyAlgId,
            &dwPubKeyFlags)) goto GetSignatureStuffError;

    // hash the encrypted digest
    if (!ICM_GetCapiFromAlgidBlob(
            (PCRYPT_DATA_BLOB)&posibCS->digestAlgorithm,
            &dwDigestAlgoCAPI))
        goto GetCapiFromAlgidBlobError;
    if (!CryptCreateHash(
            hCryptProv,
            dwDigestAlgoCAPI,
            NULL,               // hKey - optional for MAC
            0,                  // dwFlags
            &hHashRaw))
        goto CreateHashError;
    if (!ICM_UpdateDigest(
            hHashRaw,
            posib->encryptedDigest.value,
            posib->encryptedDigest.length))
        goto HashDataError;

    if (0 == (posibCS->bit_mask & authAttributes_present))
        goto CountersignerAuthAttributesMissingError;

    // check that the message digest attr matches the hashed encrypted digest
    if (!CryptGetHashParam(
            hHashRaw,
            HP_HASHVAL,
            NULL,
            &cbHash,
            0))                     // dwFlags
        goto GetHashParamSizeError;
    if (NULL == (pbHash = (PBYTE)ICM_AllocA( cbHash)))
        goto AllocHashParamError;
    if (!CryptGetHashParam(
            hHashRaw,
            HP_HASHVAL,
            pbHash,
            &cbHash,
            0))                     // dwFlags
        goto GetHashParamError;
    // find the message digest attr value
    if (!ICM_GetAttrValue(
            (Attributes *)&posibCS->authAttributes, // same, except for NOCOPY
            &oidMessageDigest,
            &anyValue))
        goto FindAttrError;
    // find the message digest octets
    if (!Asn1UtilExtractContent(
            (BYTE *) anyValue.value,
            anyValue.length,
            &cbMessageDigest,
            (const BYTE **)&pbMessageDigest))
        goto ExtractContentError;
    // hash sizes equal?
    if (cbHash != cbMessageDigest)
        goto HashCompareSizeError;
    // hash octets equal?
    if (memcmp( pbMessageDigest, pbHash, cbHash))
        goto HashCompareValueError;
    // Now that we have verified the message digest octets,
    // get the hash of the authenticated attributes.
    if (!ICM_GetAttrsHash(
            dwDigestAlgoCAPI,
            hCryptProv,
            (Attributes *)&posibCS->authAttributes, // same, except for NOCOPY
            &hHashAttr))
        goto GetAuthAttrsHashError;

    // verify the hash, signature, and public key are consistent
    if (!ICM_VerifySignature(
            hHashAttr,
            hPubKey,
            dwPubKeyAlgId,
            dwPubKeyFlags,
            posibCS->encryptedDigest.value,
            posibCS->encryptedDigest.length))
        goto VerifySignatureError;

    fRet = TRUE;

CommonReturn:
    PkiAsn1FreeInfo(pDec, SignerInfoWithBlobs_PDU, posib);
    PkiAsn1FreeInfo(pDec, SignerInfoWithBlobs_PDU, posibCS);
    PkiAsn1FreeInfo(pDec, IssuerAndSerialNumber_PDU, pisn);
    if (hHashRaw)
        CryptDestroyHash( hHashRaw);
    if (hHashAttr)
        CryptDestroyHash( hHashAttr);
    if (hPubKey)
        CryptDestroyKey( hPubKey);
    ICM_FreeA( pbHash);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidEncodingTypeError,E_INVALIDARG)
SET_ERROR_VAR(DecodeSignerInfoError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR_VAR(DecodeSignerInfoCSError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR_VAR(DecodeIssuerAndSerialNumberError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(IssuerSizeMismatchError,CRYPT_E_ISSUER_SERIALNUMBER)
SET_ERROR(IssuerValueMismatchError,CRYPT_E_ISSUER_SERIALNUMBER)
SET_ERROR(SerialNumberSizeMismatchError,CRYPT_E_ISSUER_SERIALNUMBER)
SET_ERROR(SerialNumberValueMismatchError,CRYPT_E_ISSUER_SERIALNUMBER)
SET_ERROR(CountersignerAuthAttributesMissingError,CRYPT_E_AUTH_ATTR_MISSING)
SET_ERROR(FindAttrError,CRYPT_E_AUTH_ATTR_MISSING)
SET_ERROR(ExtractContentError,CRYPT_E_UNEXPECTED_ENCODING)
SET_ERROR(HashCompareSizeError,CRYPT_E_HASH_VALUE)
SET_ERROR(HashCompareValueError,CRYPT_E_HASH_VALUE)
TRACE_ERROR(GetCapiFromAlgidBlobError)      // error already set
TRACE_ERROR(CreateHashError)                // error already set
TRACE_ERROR(HashDataError)                  // error already set
TRACE_ERROR(GetHashParamSizeError)          // error already set
TRACE_ERROR(AllocHashParamError)            // error already set
TRACE_ERROR(GetHashParamError)              // error already set
TRACE_ERROR(GetAuthAttrsHashError)          // error already set
TRACE_ERROR(GetSignatureStuffError)         // error already set
TRACE_ERROR(VerifySignatureError)           // error already set
}
#endif  // CMS_PKCS7

#ifndef _XBOX
//+-------------------------------------------------------------------------
//  Set an OSS Any
//--------------------------------------------------------------------------
void
WINAPI
ICM_SetOssAny(
        IN PCRYPT_OBJID_BLOB pInfo,
        OUT OpenType *pOss
        )
{
    memset(pOss, 0, sizeof(*pOss));
    pOss->encoded = pInfo->pbData;
    pOss->length = pInfo->cbData;
}
#endif

//+-------------------------------------------------------------------------
//  Encode a CMS SignerInfo
//--------------------------------------------------------------------------
STATIC
BOOL
WINAPI
ICM_CmsSignerInfoEncode(
    IN DWORD                    dwEncodingType,
    IN LPCSTR                   lpszStructType,
    IN PCMSG_CMS_SIGNER_INFO    pInfo,
    OUT PBYTE                   pbEncoded,
    IN OUT PDWORD               pcbEncoded)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    SignerInfo          osi;        ZEROSTRUCT(osi);
    PCMSG_CMS_SIGNER_INFO psi = pInfo;
    DWORD               i;
    Attribute           *poatrAuth = NULL;
    Attribute           *poatrUnauth = NULL;
    Attribute           *poatr;
    PCRYPT_ATTRIBUTE    patr;

    if (GET_CMSG_ENCODING_TYPE(dwEncodingType) != PKCS_7_ASN_ENCODING)
        goto InvalidEncodingTypeError;

    // version
    osi.version = psi->dwVersion;

    // sid
    if (!ICM_SetOssCertIdentifier(
            &psi->SignerId,
            &osi.sid
            ))
        goto SetOssCertIdentifierError;

    // digestAlgorithm
    if (!ICM_Asn1ToAlgorithmIdentifier(
            &psi->HashAlgorithm,
            &osi.digestAlgorithm))
        goto DigestAsn1ToAlgorithmIdentifierError;

    // authenticatedAttributes
    if (psi->AuthAttrs.cAttr) {
        osi.bit_mask |= authenticatedAttributes_present;
        osi.authenticatedAttributes.count = psi->AuthAttrs.cAttr;
        if (NULL == (poatrAuth = (Attribute *)ICM_AllocA(
                psi->AuthAttrs.cAttr * sizeof(Attribute))))
            goto AllocAuthAttrsError;
        osi.authenticatedAttributes.value = poatrAuth;
        for (i=psi->AuthAttrs.cAttr, patr=psi->AuthAttrs.rgAttr, poatr=poatrAuth;
                i>0;
                i--, patr++, poatr++) {
            if (!ICM_Asn1ToAttribute( patr, poatr))
                goto Asn1AuthenticatedAttributeError;
        }
    }

    // digestEncryptionAlgorithm
    if (!ICM_FillAsnDigestEncryptionAlgorithm(
            NULL,                           // pcmi
            &psi->HashEncryptionAlgorithm,
            &osi.digestEncryptionAlgorithm))
        goto FillAsnDigestEncryptionAlgorithmError;

    // encryptedDigest
    osi.encryptedDigest.length = psi->EncryptedHash.cbData;
    osi.encryptedDigest.value  = psi->EncryptedHash.pbData;

    // unauthenticatedAttributes
    if (psi->UnauthAttrs.cAttr) {
        osi.bit_mask |= unauthAttributes_present;
        osi.unauthAttributes.count = psi->UnauthAttrs.cAttr;
        if (NULL == (poatrUnauth = (Attribute *)ICM_AllocA(
                psi->UnauthAttrs.cAttr * sizeof(Attribute))))
            goto AllocUnauthAttrsError;
        osi.unauthAttributes.value = poatrUnauth;
        for (i=psi->UnauthAttrs.cAttr, patr=psi->UnauthAttrs.rgAttr, poatr=poatrUnauth;
                i>0;
                i--, patr++, poatr++) {
            if (!ICM_Asn1ToAttribute( patr, poatr))
                goto Asn1UnauthenticatedAttributeError;
        }
    }

    fRet = PkiAsn1EncodeInfo(
                    ICM_GetEncoder(),
                    SignerInfo_PDU,
                    &osi,
                    pbEncoded,
                    pcbEncoded);
    if (!fRet)
        dwError = GetLastError();

CommonReturn:
    ICM_FreeOssCertIdentifier(&osi.sid);

    if (poatrAuth) {
        for (i=psi->AuthAttrs.cAttr, poatr=poatrAuth;
                i>0;
                i--, poatr++)
            ICM_Free( poatr->attributeValue.value);
    }
    if (poatrUnauth) {
        for (i=psi->UnauthAttrs.cAttr, poatr=poatrUnauth;
                i>0;
                i--, poatr++)
            ICM_Free( poatr->attributeValue.value);
    }
    ICM_FreeA( poatrAuth);
    ICM_FreeA( poatrUnauth);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    *pcbEncoded = 0;
    goto CommonReturn;
SET_ERROR(InvalidEncodingTypeError,E_INVALIDARG)
TRACE_ERROR(SetOssCertIdentifierError)               // error already set
TRACE_ERROR(DigestAsn1ToAlgorithmIdentifierError)    // error already set
TRACE_ERROR(AllocAuthAttrsError)                        // error already set
TRACE_ERROR(Asn1AuthenticatedAttributeError)         // error already set
TRACE_ERROR(FillAsnDigestEncryptionAlgorithmError)      // error already set
TRACE_ERROR(AllocUnauthAttrsError)                      // error already set
TRACE_ERROR(Asn1UnauthenticatedAttributeError)       // error already set
lpszStructType;
}

//+-------------------------------------------------------------------------
//  Encode a Pkcs SignerInfo
//--------------------------------------------------------------------------
STATIC
BOOL
WINAPI
ICM_PkcsSignerInfoEncode(
    IN DWORD                    dwEncodingType,
    IN LPCSTR                   lpszStructType,
    IN PCMSG_SIGNER_INFO        pInfo,
    OUT PBYTE                   pbEncoded,
    IN OUT PDWORD               pcbEncoded)
{
    CMSG_CMS_SIGNER_INFO csi;
    CERT_INFO CertInfo;

    csi.dwVersion = pInfo->dwVersion;

    CertInfo.Issuer = pInfo->Issuer;
    CertInfo.SerialNumber = pInfo->SerialNumber;
    ICM_GetCertIdFromCertInfo(&CertInfo, &csi.SignerId);

    csi.HashAlgorithm = pInfo->HashAlgorithm;
    csi.HashEncryptionAlgorithm = pInfo->HashEncryptionAlgorithm;
    csi.EncryptedHash = pInfo->EncryptedHash;
    csi.AuthAttrs = pInfo->AuthAttrs;
    csi.UnauthAttrs = pInfo->UnauthAttrs;

    return ICM_CmsSignerInfoEncode(
        dwEncodingType,
        lpszStructType,
        &csi,
        pbEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  Get fields shared by PKCS and CMS SignerInfos
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssSharedSignerInfo(
    IN SignerInfo                   *posi,
    IN CBlobList                    *pUnauthAttrList,
    OUT PCRYPT_ALGORITHM_IDENTIFIER  pHashAlgorithm,
    OUT PCRYPT_ALGORITHM_IDENTIFIER  pHashEncryptionAlgorithm,
    OUT PCRYPT_DATA_BLOB             pEncryptedHash,
    OUT PCRYPT_ATTRIBUTES            pAuthAttrs,
    OUT PCRYPT_ATTRIBUTES            pUnauthAttrs,
    IN OUT PBYTE                    *ppbExtra,
    IN OUT LONG                     *plRemainExtra)
{
    BOOL        fRet;

    if (!ICM_GetOssAlgorithm( &posi->digestAlgorithm,
            pHashAlgorithm, ppbExtra, plRemainExtra))
        goto GetOssHashAlgorithmError;
    if (!ICM_GetOssAlgorithm( &posi->digestEncryptionAlgorithm,
            pHashEncryptionAlgorithm, ppbExtra, plRemainExtra))
        goto GetOssHashEncryptionAlgorithmError;
    if (!ICM_GetOssAny( (Any *)&posi->encryptedDigest,
            pEncryptedHash, ppbExtra, plRemainExtra))
        goto GetOssEncryptedHashError;
    if (posi->bit_mask & authenticatedAttributes_present) {
        if (!ICM_GetOssAttributes( &posi->authenticatedAttributes,
                pAuthAttrs, ppbExtra, plRemainExtra))
            goto GetOssAuthAttrsError;
    } else if (0 <= *plRemainExtra)
        pAuthAttrs->cAttr = 0;

    if (posi->bit_mask & unauthAttributes_present || pUnauthAttrList) {
        if (pUnauthAttrList) {
            if (!ICM_GetCListAttributes( pUnauthAttrList,
                    pUnauthAttrs, ppbExtra, plRemainExtra))
                goto GetCListUnauthAttrsError;
        } else {
            if (!ICM_GetOssAttributes( &posi->unauthAttributes,
                    pUnauthAttrs, ppbExtra, plRemainExtra))
                goto GetOssUnauthAttrsError;
        }
    } else if (0 <= *plRemainExtra)
        pUnauthAttrs->cAttr = 0;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetOssHashAlgorithmError)               // error already set
TRACE_ERROR(GetOssHashEncryptionAlgorithmError)     // error already set
TRACE_ERROR(GetOssEncryptedHashError)               // error already set
TRACE_ERROR(GetOssAuthAttrsError)                   // error already set
TRACE_ERROR(GetCListUnauthAttrsError)               // error already set
TRACE_ERROR(GetOssUnauthAttrsError)                 // error already set
}

//+-------------------------------------------------------------------------
//  Get a CMS SignerInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssCmsSignerInfo(
    IN SignerInfo   *posi,
    IN CBlobList    *pUnauthAttrList,
    OUT PCMSG_CMS_SIGNER_INFO psi,
    IN OUT PBYTE    *ppbExtra,
    IN OUT LONG     *plRemainExtra)
{
    BOOL        fRet;

    if (0 <= *plRemainExtra)
        psi->dwVersion = posi->version;

    if (!ICM_GetOssCertIdentifier(&posi->sid, &psi->SignerId,
            ppbExtra, plRemainExtra))
        goto GetOssCertIdentifierError;

    if (!ICM_GetOssSharedSignerInfo(
            posi,
            pUnauthAttrList,
            &psi->HashAlgorithm,
            &psi->HashEncryptionAlgorithm,
            &psi->EncryptedHash,
            &psi->AuthAttrs,
            &psi->UnauthAttrs,
            ppbExtra,
            plRemainExtra))
        goto GetOssSharedSignerInfoError;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetOssCertIdentifierError)              // error already set
TRACE_ERROR(GetOssSharedSignerInfoError)            // error already set
}


//+-------------------------------------------------------------------------
//  Get a PKCS SignerInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssPkcsSignerInfo(
    IN SignerInfo   *posi,
    IN CBlobList    *pUnauthAttrList,
    OUT PCMSG_SIGNER_INFO psi,
    IN OUT PBYTE    *ppbExtra,
    IN OUT LONG     *plRemainExtra)
{
    BOOL        fRet;

    if (0 <= *plRemainExtra)
        psi->dwVersion = posi->version;

    if (!ICM_GetOssIssuerAndSerialNumberFromCertId(&posi->sid,
            &psi->Issuer, &psi->SerialNumber, ppbExtra, plRemainExtra))
        goto GetOssIssuerAndSerialNumberError;

    if (!ICM_GetOssSharedSignerInfo(
            posi,
            pUnauthAttrList,
            &psi->HashAlgorithm,
            &psi->HashEncryptionAlgorithm,
            &psi->EncryptedHash,
            &psi->AuthAttrs,
            &psi->UnauthAttrs,
            ppbExtra,
            plRemainExtra))
        goto GetOssSharedSignerInfoError;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetOssIssuerAndSerialNumberError)       // error already set
TRACE_ERROR(GetOssSharedSignerInfoError)            // error already set
}


//+-------------------------------------------------------------------------
//  Decode a PKCS SignerInfo blob.
//
//  Returns:    FALSE iff fails
//--------------------------------------------------------------------------
STATIC
BOOL
WINAPI
ICM_PkcsSignerInfoDecode(
        IN DWORD dwEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCMSG_SIGNER_INFO pInfo,
        IN OUT DWORD *pcbInfo)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    LONG                lData;
    SignerInfo          *posi = NULL;
    ASN1error_e         Asn1Err;
    ASN1decoding_t      pDec = ICM_GetDecoder();
    PCMSG_SIGNER_INFO   psi = pInfo;
    LONG                lRemainExtra;
    PBYTE               pbExtra;

    if (pInfo == NULL)
        *pcbInfo = 0;

    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&posi,
            SignerInfo_PDU,
            pbEncoded,
            cbEncoded)))
        goto Asn1DecodeSignerInfoError;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lData = INFO_LEN_ALIGN( sizeof(CMSG_SIGNER_INFO));
    lRemainExtra = (LONG)*pcbInfo - lData;
    if (0 > lRemainExtra) {
        psi = NULL;
        pbExtra = NULL;
    } else {
        pbExtra = (PBYTE)psi + lData;
    }
    if (!ICM_GetOssPkcsSignerInfo(
            posi,
            NULL,       // pUnauthAttrList
            psi, &pbExtra, &lRemainExtra))
        goto GetOssSignerInfoError;

    fRet = ICM_GetSizeFromExtra( lRemainExtra, pInfo, pcbInfo);

    if (!fRet)
        dwError = GetLastError();
CommonReturn:
    PkiAsn1FreeInfo(pDec, SignerInfo_PDU, posi);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    *pcbInfo = 0;
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(Asn1DecodeSignerInfoError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(GetOssSignerInfoError)      // error already set
dwFlags;
lpszStructType;
}


//+-------------------------------------------------------------------------
//  Find the Pkcs SignerInfo by index, if the message type permits and if the
//  index value is in range.
//
//  Returns:    FALSE iff fails
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetPkcsSignerInfo(
    IN PCRYPT_MSG_INFO  pcmi,
    IN DWORD            dwIndex,
    OUT PVOID           pvData,
    IN OUT PDWORD       pcbData)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    LONG                lData;
    CSignerNode         *pSignerNode;
    SignerInfo          *posi = NULL;
    ASN1error_e         Asn1Err;
    ASN1decoding_t      pDec = ICM_GetDecoder();
    CRYPT_DATA_BLOB     DataBlob;
    PCMSG_SIGNER_INFO   psi = (PCMSG_SIGNER_INFO)pvData;
    LONG                lRemainExtra;
    PBYTE               pbExtra;

    if (!ICM_FindSignerInfo( pcmi, dwIndex, (PVOID *)&pSignerNode))
        goto FindSignerInfoError;

    DataBlob = pSignerNode->Data()->blob;
    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&posi,
            SignerInfo_PDU,
            DataBlob.pbData,
            DataBlob.cbData)))
        goto Asn1DecodeSignerInfoError;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lData = INFO_LEN_ALIGN( sizeof(CMSG_SIGNER_INFO));
    lRemainExtra = (LONG)*pcbData - lData;
    if (0 > lRemainExtra) {
        psi = NULL;
        pbExtra = NULL;
    } else {
        pbExtra = (PBYTE)psi + lData;
    }
    if (!ICM_GetOssPkcsSignerInfo( posi, pSignerNode->Data()->pUnauthAttrList,
                psi, &pbExtra, &lRemainExtra))
        goto GetOssSignerInfoError;

    fRet = ICM_GetSizeFromExtra( lRemainExtra, pvData, pcbData);

    if (!fRet)
        dwError = GetLastError();
CommonReturn:
    PkiAsn1FreeInfo(pDec, SignerInfo_PDU, posi);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    *pcbData = 0;
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(Asn1DecodeSignerInfoError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(FindSignerInfoError)            // error already set
TRACE_ERROR(GetOssSignerInfoError)          // error already set
}

//+-------------------------------------------------------------------------
//  Decode a CMS SignerInfo blob.
//
//  Returns:    FALSE iff fails
//--------------------------------------------------------------------------
STATIC
BOOL
WINAPI
ICM_CmsSignerInfoDecode(
        IN DWORD dwEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCMSG_CMS_SIGNER_INFO pInfo,
        IN OUT DWORD *pcbInfo)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    LONG                lData;
    SignerInfo          *posi = NULL;
    ASN1error_e         Asn1Err;
    ASN1decoding_t      pDec = ICM_GetDecoder();
    PCMSG_CMS_SIGNER_INFO psi = pInfo;
    LONG                lRemainExtra;
    PBYTE               pbExtra;

    if (pInfo == NULL)
        *pcbInfo = 0;

    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&posi,
            SignerInfo_PDU,
            pbEncoded,
            cbEncoded)))
        goto Asn1DecodeSignerInfoError;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lData = INFO_LEN_ALIGN( sizeof(CMSG_CMS_SIGNER_INFO));
    lRemainExtra = (LONG)*pcbInfo - lData;
    if (0 > lRemainExtra) {
        psi = NULL;
        pbExtra = NULL;
    } else {
        pbExtra = (PBYTE)psi + lData;
    }
    if (!ICM_GetOssCmsSignerInfo(
            posi,
            NULL,       // pUnauthAttrList
            psi, &pbExtra, &lRemainExtra))
        goto GetOssSignerInfoError;

    fRet = ICM_GetSizeFromExtra( lRemainExtra, pInfo, pcbInfo);

    if (!fRet)
        dwError = GetLastError();
CommonReturn:
    PkiAsn1FreeInfo(pDec, SignerInfo_PDU, posi);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    *pcbInfo = 0;
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(Asn1DecodeSignerInfoError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(GetOssSignerInfoError)      // error already set
dwFlags;
lpszStructType;
}


//+-------------------------------------------------------------------------
//  Find the CMS SignerInfo by index, if the message type permits and if the
//  index value is in range.
//
//  Returns:    FALSE iff fails
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetCmsSignerInfo(
    IN PCRYPT_MSG_INFO  pcmi,
    IN DWORD            dwIndex,
    OUT PVOID           pvData,
    IN OUT PDWORD       pcbData)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    LONG                lData;
    CSignerNode         *pSignerNode;
    SignerInfo          *posi = NULL;
    ASN1error_e         Asn1Err;
    ASN1decoding_t      pDec = ICM_GetDecoder();
    CRYPT_DATA_BLOB     DataBlob;
    PCMSG_CMS_SIGNER_INFO psi = (PCMSG_CMS_SIGNER_INFO)pvData;
    LONG                lRemainExtra;
    PBYTE               pbExtra;

    if (!ICM_FindSignerInfo( pcmi, dwIndex, (PVOID *)&pSignerNode))
        goto FindSignerInfoError;

    DataBlob = pSignerNode->Data()->blob;
    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&posi,
            SignerInfo_PDU,
            DataBlob.pbData,
            DataBlob.cbData)))
        goto Asn1DecodeSignerInfoError;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lData = INFO_LEN_ALIGN( sizeof(CMSG_CMS_SIGNER_INFO));
    lRemainExtra = (LONG)*pcbData - lData;
    if (0 > lRemainExtra) {
        psi = NULL;
        pbExtra = NULL;
    } else {
        pbExtra = (PBYTE)psi + lData;
    }
    if (!ICM_GetOssCmsSignerInfo( posi, pSignerNode->Data()->pUnauthAttrList,
                psi, &pbExtra, &lRemainExtra))
        goto GetOssSignerInfoError;

    fRet = ICM_GetSizeFromExtra( lRemainExtra, pvData, pcbData);

    if (!fRet)
        dwError = GetLastError();
CommonReturn:
    PkiAsn1FreeInfo(pDec, SignerInfo_PDU, posi);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    *pcbData = 0;
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(Asn1DecodeSignerInfoError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(FindSignerInfoError)            // error already set
TRACE_ERROR(GetOssSignerInfoError)          // error already set
}


//+-------------------------------------------------------------------------
//  Get the data for a field in a Signer, while encoding a message
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetSignerParamEncoding(
    IN PCRYPT_MSG_INFO  pcmi,
    IN DWORD            dwIndex,
    IN DWORD            dwParamType,
    OUT PVOID           pvData,
    IN OUT PDWORD       pcbData)
{
    DWORD           dwError = ERROR_SUCCESS;
    BOOL            fRet;
    ASN1error_e     Asn1Err;
    ASN1encoding_t  pEnc = ICM_GetEncoder();
    PBYTE           pbEncoded = NULL;
    DWORD           cbEncoded;
    SignerInfo      *posi = NULL;


    if (!ICM_FindSignerInfo( pcmi, dwIndex, (PVOID *)&posi))
        goto FindSignerInfoError;

    switch (dwParamType) {

    case CMSG_ENCODED_SIGNER:
        if (0 != (Asn1Err = PkiAsn1Encode(
                pEnc,
                posi,
                SignerInfo_PDU,
                &pbEncoded,
                &cbEncoded)))
            goto EncodeSignerInfoError;
        break;

    default:
        goto InvalidParamError;
    }

    fRet = ICM_CopyOut(
                pbEncoded,
                cbEncoded,
                (PBYTE)pvData,
                pcbData);
    if (!fRet)
        dwError = GetLastError();
CommonReturn:
    PkiAsn1FreeEncoded(pEnc, pbEncoded);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(FindSignerInfoError)        // error already set
SET_ERROR_VAR(EncodeSignerInfoError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(InvalidParamError,E_INVALIDARG)
}


//+-------------------------------------------------------------------------
//  Get the data for a field in a Signer
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetSignerParam(
    IN PCRYPT_MSG_INFO  pcmi,
    IN DWORD            dwIndex,
    IN DWORD            dwParamType,
    OUT PVOID           pvData,
    IN OUT PDWORD       pcbData)
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    ASN1error_e             Asn1Err;
    ASN1decoding_t          pDec = ICM_GetDecoder();
    CRYPT_DATA_BLOB         DataBlob;
    ASN1uint32_t            pdunumRef = 0;      // invalid
    SignerInfoWithBlobs     *posib = NULL;
    PVOID                   pv = NULL;
    CSignerNode             *pSignerNode;

    if (!ICM_FindSignerInfo( pcmi, dwIndex, (PVOID *)&pSignerNode))
        goto FindSignerInfoError;

    DataBlob = pSignerNode->Data()->blob;
    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&posib,
            SignerInfoWithBlobs_PDU,
            DataBlob.pbData,
            DataBlob.cbData)))
        goto DecodeSignerInfoError;

    switch (dwParamType) {

    case CMSG_SIGNER_INFO_PARAM:
        fRet = ICM_GetPkcsSignerInfo( pcmi, dwIndex, pvData, pcbData);
        break;
    case CMSG_CMS_SIGNER_INFO_PARAM:
        fRet = ICM_GetCmsSignerInfo( pcmi, dwIndex, pvData, pcbData);
        break;

    case CMSG_ENCRYPTED_DIGEST:
        fRet = ICM_CopyOut(
                    (PBYTE)posib->encryptedDigest.value,
                    (DWORD)posib->encryptedDigest.length,
                    (PBYTE)pvData,
                    pcbData);
        break;

    case CMSG_ENCODED_SIGNER:
        if (pSignerNode->Data()->pUnauthAttrList) {
            // Need to re-encode with new unauth attrs
            goto ReEncodedSignerNotImplementedError;
        } else {
            fRet = ICM_CopyOut(
                        pSignerNode->Data()->blob.pbData,
                        pSignerNode->Data()->blob.cbData,
                        (PBYTE)pvData,
                        pcbData);
        }
        break;

    case CMSG_SIGNER_CERT_INFO_PARAM:
    case CMSG_SIGNER_CERT_ID_PARAM:
        pdunumRef = CertIdentifier_PDU;
        if (0 != (Asn1Err = PkiAsn1Decode(
                pDec,
                &pv,
                pdunumRef,
                (BYTE *) posib->sid.value,
                posib->sid.length)))
            goto DecodeCertIdentifierError;
        if (CMSG_SIGNER_CERT_INFO_PARAM == dwParamType)
            fRet = ICM_GetCertInfoIssuerAndSerialNumber(
                    (CertIdentifier *)pv,
                    pvData,
                    pcbData);
        else
            fRet = ICM_GetCertId(
                    (CertIdentifier *)pv,
                    pvData,
                    pcbData);
        break;

    case CMSG_SIGNER_HASH_ALGORITHM_PARAM:
        pdunumRef = AlgorithmIdentifierNC2_PDU;
        if (0 != (Asn1Err = PkiAsn1Decode(
                pDec,
                &pv,
                pdunumRef,
                (BYTE *) posib->digestAlgorithm.value,
                posib->digestAlgorithm.length)))
            goto DecodeAlgorithmIdentifierNC2Error;
        fRet = ICM_GetALGORITHM_IDENTIFIER(
                (AlgorithmIdentifier *)pv,
                pvData,
                pcbData);
        break;

    case CMSG_SIGNER_AUTH_ATTR_PARAM:
        if (posib->bit_mask & authAttributes_present)
            fRet = ICM_GetAttributesData(
                        (Attributes *)&posib->authAttributes,
                        pvData,
                        pcbData);
        else
            goto AuthAttrMissingError;
        break;

    case CMSG_SIGNER_UNAUTH_ATTR_PARAM:
        if (posib->bit_mask & unauthAttributes_present)
            fRet = ICM_GetAttributesData(
                        (Attributes *)&posib->unauthAttributes,
                        pvData,
                        pcbData);
        else
            goto UnauthAttrMissingError;
        break;

    default:
        goto InvalidParamError;
    }
    if (!fRet)
        dwError = GetLastError();

CommonReturn:
    PkiAsn1FreeInfo(pDec, SignerInfoWithBlobs_PDU, posib);
    PkiAsn1FreeInfo(pDec, pdunumRef, pv);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    *pcbData = 0;
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(DecodeSignerInfoError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR_VAR(DecodeCertIdentifierError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR_VAR(DecodeAlgorithmIdentifierNC2Error, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(AuthAttrMissingError,CRYPT_E_ATTRIBUTES_MISSING)
SET_ERROR(UnauthAttrMissingError,CRYPT_E_ATTRIBUTES_MISSING)
SET_ERROR(ReEncodedSignerNotImplementedError,E_INVALIDARG)
SET_ERROR(InvalidParamError,E_INVALIDARG)
TRACE_ERROR(FindSignerInfoError)                    // error already set
}


//+-------------------------------------------------------------------------
//  Get the encoded blob for a SignerInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetEncodedSignerInfo(
    IN DWORD                dwEncodingType,
    IN PSIGNER_DATA_INFO    pSignerInfo,
    OUT PBYTE               pbSignerInfo,
    IN OUT PDWORD           pcbSignerInfo)
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    SignerInfoWithAttrBlobs *posiab = NULL;
    Any                     *pAnyAttr = NULL;
    Any                     *pAny;
    DWORD                   cAnyAttr;
    AttributesNC            unauthAttributesSave;
                                        ZEROSTRUCT(unauthAttributesSave);
#ifdef OSS_CRYPT_ASN1
    BYTE                    bit_maskSave = 0;
#else
    ASN1uint16_t            bit_maskSave = 0;
#endif  // OSS_CRYPT_ASN1
    ASN1error_e             Asn1Err;
    ASN1decoding_t          pDec = ICM_GetDecoder();
    ASN1encoding_t          pEnc = ICM_GetEncoder();
    PBYTE                   pbEncoded = NULL;
    DWORD                   cbEncoded;
    CBlobNode               *pnBlob;
    DWORD                   cbOut;
    PBYTE                   pbOut;

    if (GET_CMSG_ENCODING_TYPE(dwEncodingType) != PKCS_7_ASN_ENCODING)
        goto InvalidEncodingTypeError;

    if (pSignerInfo->pUnauthAttrList) {
        if (0 != (Asn1Err = PkiAsn1Decode(
                pDec,
                (void **)&posiab,
                SignerInfoWithAttrBlobs_PDU,
                pSignerInfo->blob.pbData,
                pSignerInfo->blob.cbData)))
            goto DecodeSignerInfoWithAttrBlobsError;
        // We have to take into account both the case where we have added
        // unauth attrs, and the case where we have removed them. There might
        // have been unauth attrs in the original message, and we removed
        // them all. Or, there might have been none originally, and we added
        // some.
        bit_maskSave = posiab->bit_mask;
        unauthAttributesSave = posiab->unauthAttributes;
        cAnyAttr = pSignerInfo->pUnauthAttrList->Length();
        posiab->bit_mask &= ~unauthAttributes_present;
        posiab->bit_mask |= (cAnyAttr > 0) ? unauthAttributes_present : 0;
        if (NULL == (pAnyAttr = (Any *)ICM_AllocA( cAnyAttr * sizeof(Any))))
            goto AllocAnyAttrError;
        posiab->unauthAttributes.count = cAnyAttr;
        posiab->unauthAttributes.value = pAnyAttr;
        for (pnBlob=pSignerInfo->pUnauthAttrList->Head(), pAny=pAnyAttr;
                pnBlob;
                pnBlob=pnBlob->Next(), pAny++)
            *pAny = *(Any *)pnBlob->Data();
        if (0 != (Asn1Err = PkiAsn1Encode(
                pEnc,
                posiab,
                SignerInfoWithAttrBlobs_PDU,
                &pbEncoded,
                &cbEncoded)))
            goto EncodeSignerInfoWithAttrBlobsError;
        cbOut = cbEncoded;
        pbOut = pbEncoded;
    } else {
        cbOut = pSignerInfo->blob.cbData;
        pbOut = pSignerInfo->blob.pbData;
    }

    fRet = ICM_CopyOut(
                pbOut,
                cbOut,
                pbSignerInfo,
                pcbSignerInfo);
    if (!fRet)
        dwError = GetLastError();

CommonReturn:
    ICM_FreeA( pAnyAttr);
    if (posiab) {
        posiab->bit_mask = bit_maskSave;
        posiab->unauthAttributes = unauthAttributesSave;
        PkiAsn1FreeDecoded(pDec, posiab, SignerInfoWithAttrBlobs_PDU);
    }
    PkiAsn1FreeEncoded(pEnc, pbEncoded);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidEncodingTypeError,E_INVALIDARG)
SET_ERROR_VAR(DecodeSignerInfoWithAttrBlobsError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR_VAR(EncodeSignerInfoWithAttrBlobsError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(AllocAnyAttrError)              // error already set
}


//+-------------------------------------------------------------------------
//  Get the data for a field in a Signer
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetEncodedMessageParam(
    IN PCRYPT_MSG_INFO  pcmi,
    OUT PBYTE           pbEncodedMessage,
    IN OUT PDWORD       pcbEncodedMessage)
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    SignedDataWithBlobs     *posdb = NULL;
    PSIGNED_DATA_INFO       psdi = pcmi->psdi;
    Any                     *pAny;
    PSIGNER_DATA_INFO       pSignerInfo;
    ASN1error_e             Asn1Err;
    ASN1encoding_t          pEnc = ICM_GetEncoder();
    PBYTE                   pbEncodedSignedData = NULL;
    DWORD                   cbEncodedSignedData;
    PBYTE                   pbEncodedContentInfo = NULL;
    DWORD                   cbEncodedContentInfo;
    CSignerNode             *pnSigner;
    CBlobNode               *pnBlob;
    DWORD                   cb;
    PBYTE                   pb;
    DWORD                   i;
    ContentInfo             ci;


    if (NULL == (posdb = (SignedDataWithBlobs *)ICM_AllocZeroA(
                sizeof(SignedDataWithBlobs) +
                sizeof(Any) *
                   (psdi->pAlgidList->Length() +
                    psdi->pCertificateList->Length() +
                    psdi->pCrlList->Length() +
                    psdi->pSignerList->Length()))))
        goto AllocSignedDataWithBlobsError;
    pAny = (Any *)(posdb + 1);

    // version
    posdb->version = psdi->version;

    // digest algorithms
    posdb->digestAlgorithms.count = psdi->pAlgidList->Length();
    posdb->digestAlgorithms.value = pAny;
    for (pnBlob=psdi->pAlgidList->Head();
            pnBlob;
            pnBlob=pnBlob->Next())
        *pAny++ = *(Any *)pnBlob->Data();

    // contentInfo
    posdb->contentInfo.contentType.count = SIZE_OSS_OID;
    if (!PkiAsn1ToObjectIdentifier(
            psdi->pci->pszContentType,
            &posdb->contentInfo.contentType.count,
            posdb->contentInfo.contentType.value))
        goto PkiAsn1ToObjectIdentifierError;
    if (psdi->pci->content.cbData) {
        posdb->contentInfo.bit_mask |= content_present;
        posdb->contentInfo.content.length = psdi->pci->content.cbData;
        posdb->contentInfo.content.value  = psdi->pci->content.pbData;
    }

    // certificates
    posdb->certificates.count = psdi->pCertificateList->Length();
#ifdef OSS_CRYPT_ASN1
    posdb->certificates.certificates = pAny;
#else
    posdb->certificates.value = pAny;
#endif  // OSS_CRYPT_ASN1
    for (pnBlob=psdi->pCertificateList->Head();
            pnBlob;
            pnBlob=pnBlob->Next()) {
        posdb->bit_mask |= certificates_present;
        *pAny++ = *(Any *)pnBlob->Data();
    }

    // crls
    posdb->crls.count = psdi->pCrlList->Length();
#ifdef OSS_CRYPT_ASN1
    posdb->crls.crls  = pAny;
#else
    posdb->crls.value  = pAny;
#endif  // OSS_CRYPT_ASN1
    for (pnBlob=psdi->pCrlList->Head();
            pnBlob;
            pnBlob=pnBlob->Next()) {
        posdb->bit_mask |= crls_present;
        *pAny++ = *(Any *)pnBlob->Data();
    }

    // signerInfos
    posdb->signerInfos.count = psdi->pSignerList->Length();
    posdb->signerInfos.value = pAny;
    for (pnSigner=psdi->pSignerList->Head();
            pnSigner;
            pnSigner=pnSigner->Next()) {
        pSignerInfo = pnSigner->Data();
        if (!ICM_GetEncodedSignerInfo(
                PKCS_7_ASN_ENCODING,
                pnSigner->Data(),
                NULL,
                &cb))
            goto GetEncodedSignerInfoSizeError;
        if (NULL == (pb = (PBYTE)ICM_AllocA( cb)))
            goto AllocEncodedSignerInfoError;
        if (!ICM_GetEncodedSignerInfo(
                PKCS_7_ASN_ENCODING,
                pnSigner->Data(),
                pb,
                &cb))
            goto GetEncodedSignerInfoError;
        pAny->length = cb;
        pAny->value  = pb;
        pAny++;
    }

    if (0 != (Asn1Err = PkiAsn1Encode(
            pEnc,
            posdb,
            SignedDataWithBlobs_PDU,
            &pbEncodedSignedData,
            &cbEncodedSignedData)))
        goto EncodeSignedDataWithBlobsError;

    ci.contentType.count = SIZE_OSS_OID;
    if (!PkiAsn1ToObjectIdentifier(
            szOID_RSA_signedData,
            &ci.contentType.count,
            ci.contentType.value))
        goto ConvSignedDataToOidError;
    ci.bit_mask = content_present;
    ci.content.length = cbEncodedSignedData;
    ci.content.value = pbEncodedSignedData;

    if (0 != (Asn1Err = PkiAsn1Encode(
            pEnc,
            &ci,
            ContentInfo_PDU,
            &pbEncodedContentInfo,
            &cbEncodedContentInfo)))
        goto EncodeContentInfoError;

    fRet = ICM_CopyOut(
                pbEncodedContentInfo,
                cbEncodedContentInfo,
                pbEncodedMessage,
                pcbEncodedMessage);

    if (!fRet)
        dwError = GetLastError();
CommonReturn:
    PkiAsn1FreeEncoded(pEnc, pbEncodedSignedData);
    PkiAsn1FreeEncoded(pEnc, pbEncodedContentInfo);
    for (i=posdb->signerInfos.count, pAny=posdb->signerInfos.value;
            i>0;
            i--, pAny++)
        ICM_FreeA( pAny->value);
    ICM_FreeA(posdb);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(PkiAsn1ToObjectIdentifierError,CRYPT_E_OID_FORMAT)
SET_ERROR_VAR(EncodeSignedDataWithBlobsError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(ConvSignedDataToOidError,CRYPT_E_OID_FORMAT)
SET_ERROR_VAR(EncodeContentInfoError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(AllocSignedDataWithBlobsError)      // error already set
TRACE_ERROR(GetEncodedSignerInfoSizeError)      // error already set
TRACE_ERROR(AllocEncodedSignerInfoError)        // error already set
TRACE_ERROR(GetEncodedSignerInfoError)          // error already set
}

#ifdef CMS_PKCS7

//+-------------------------------------------------------------------------
//  Get Oss OctetString
//--------------------------------------------------------------------------
void
inline
WINAPI
ICM_GetOssOctetString(
    IN OctetStringType *pOssOctetString,
    OUT PCRYPT_DATA_BLOB pOctetString,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra
    )
{
    PkiAsn1GetOctetString(pOssOctetString->length, pOssOctetString->value, 0,
        pOctetString, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Get Oss BitString
//--------------------------------------------------------------------------
void
inline
WINAPI
ICM_GetOssBitString(
    IN BitStringType *pOssBitString,
    OUT PCRYPT_BIT_BLOB pBitString,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra
    )
{
    PkiAsn1GetBitString(pOssBitString->length, pOssBitString->value, 0,
        pBitString, ppbExtra, plRemainExtra);
}


//+-------------------------------------------------------------------------
//  Get an Oss IssuerAndSerialNumber
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssIssuerAndSerialNumber(
    IN IssuerAndSerialNumber *pOssIssuerAndSerialNumber,
    OUT PCERT_ISSUER_SERIAL_NUMBER pIssuerAndSerialNumber,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra)
{
    ICM_GetOssHugeInteger(&pOssIssuerAndSerialNumber->serialNumber,
            &pIssuerAndSerialNumber->SerialNumber, ppbExtra, plRemainExtra);
    return ICM_GetOssAny(&pOssIssuerAndSerialNumber->issuer,
            &pIssuerAndSerialNumber->Issuer, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Get Oss CertIdentifier
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssCertIdentifier(
    IN CertIdentifier *pOssCertId,
    OUT PCERT_ID pCertId,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra
    )
{
    BOOL fRet;

    if (0 <= *plRemainExtra) {
        assert(CERT_ID_ISSUER_SERIAL_NUMBER == issuerAndSerialNumber_chosen);
        assert(CERT_ID_KEY_IDENTIFIER == subjectKeyIdentifier_chosen);
        pCertId->dwIdChoice = pOssCertId->choice;
    }

    switch (pOssCertId->choice) {
        case issuerAndSerialNumber_chosen:
            if (!ICM_GetOssIssuerAndSerialNumber(
                    &pOssCertId->u.issuerAndSerialNumber,
                    &pCertId->IssuerSerialNumber, ppbExtra, plRemainExtra))
                goto GetOssIssuerAndSerialNumberError;
            break;
        case subjectKeyIdentifier_chosen:
            ICM_GetOssOctetString( &pOssCertId->u.subjectKeyIdentifier,
                &pCertId->KeyId, ppbExtra, plRemainExtra);
            break;
        default:
            goto InvalidCertIdChoice;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetOssIssuerAndSerialNumberError)
SET_ERROR(InvalidCertIdChoice, CRYPT_E_BAD_ENCODE)
}

//+-------------------------------------------------------------------------
//  Get Oss OtherKeyAttribute
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssOtherKeyAttribute(
    IN OtherKeyAttribute *pOssOtherAttr,
    OUT PCRYPT_ATTRIBUTE_TYPE_VALUE *ppOtherAttr,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra
    )
{
    BOOL fRet;
    LONG lData;
    PCRYPT_ATTRIBUTE_TYPE_VALUE pOtherAttr;

    lData = INFO_LEN_ALIGN(sizeof(CRYPT_ATTRIBUTE_TYPE_VALUE));
    *plRemainExtra -= lData;
    if (0 <= *plRemainExtra) {
        pOtherAttr = (PCRYPT_ATTRIBUTE_TYPE_VALUE) *ppbExtra;
        memset(pOtherAttr, 0, sizeof(*pOtherAttr));
        *ppOtherAttr = pOtherAttr;

        *ppbExtra += lData;
    } else
        pOtherAttr = NULL;

    if (!ICM_GetOssObjId(&pOssOtherAttr->keyAttrId, &pOtherAttr->pszObjId,
            ppbExtra, plRemainExtra))
        goto GetOssObjIdError;
    if (pOssOtherAttr->bit_mask & keyAttr_present) {
        if (!ICM_GetOssAny(&pOssOtherAttr->keyAttr,
                &pOtherAttr->Value, ppbExtra, plRemainExtra))
            goto GetOssAnyError;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetOssObjIdError)
TRACE_ERROR(GetOssAnyError)
}


//+-------------------------------------------------------------------------
//  Get Oss KeyTransRecipientInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssKeyTransRecipientInfo(
    IN KeyTransRecipientInfo *pori,
    OUT PCMSG_KEY_TRANS_RECIPIENT_INFO *ppri,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra
    )
{
    BOOL fRet;
    LONG lData;
    PCMSG_KEY_TRANS_RECIPIENT_INFO pri;

    lData = INFO_LEN_ALIGN(sizeof(CMSG_KEY_TRANS_RECIPIENT_INFO));
    *plRemainExtra -= lData;
    if (0 <= *plRemainExtra) {
        pri = (PCMSG_KEY_TRANS_RECIPIENT_INFO) *ppbExtra;
        *ppri = pri;
        *ppbExtra += lData;

        pri->dwVersion = pori->version;
    } else {
        pri = NULL;
    }
    
    if (!ICM_GetOssCertIdentifier(&pori->rid, &pri->RecipientId,
            ppbExtra, plRemainExtra))
        goto GetOssCertIdentifierError;

    if (!ICM_GetOssAlgorithm(&pori->keyEncryptionAlgorithm,
            &pri->KeyEncryptionAlgorithm,
            ppbExtra, plRemainExtra))
        goto GetOssKeyEncryptionAlgorithmError;

    ICM_GetOssOctetString(&pori->encryptedKey, &pri->EncryptedKey,
        ppbExtra, plRemainExtra);

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetOssCertIdentifierError)
TRACE_ERROR(GetOssKeyEncryptionAlgorithmError)
}

//+-------------------------------------------------------------------------
//  Get Oss KeyAgreeRecipientInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssKeyAgreeRecipientInfo(
    IN KeyAgreeRecipientInfo *pori,
    OUT PCMSG_KEY_AGREE_RECIPIENT_INFO *ppri,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra
    )
{
    BOOL fRet;
    LONG lData;
    PCMSG_KEY_AGREE_RECIPIENT_INFO pri;
    DWORD count;
    OriginatorIdentifierOrKey *pooriginator;
    OriginatorPublicKey *pooriginatorKey;

    lData = INFO_LEN_ALIGN(sizeof(CMSG_KEY_AGREE_RECIPIENT_INFO));
    *plRemainExtra -= lData;
    if (0 <= *plRemainExtra) {
        pri = (PCMSG_KEY_AGREE_RECIPIENT_INFO) *ppbExtra;
        memset(pri, 0, sizeof(*pri));
        *ppri = pri;
        *ppbExtra += lData;

        pri->dwVersion = pori->version;
    } else {
        pri = NULL;
    }
    
    pooriginator = &pori->originator;
    switch (pooriginator->choice) {
        case issuerAndSerialNumber_chosen:
            if (!ICM_GetOssIssuerAndSerialNumber(
                    &pooriginator->u.issuerAndSerialNumber,
                    &pri->OriginatorCertId.IssuerSerialNumber,
                    ppbExtra, plRemainExtra))
                goto GetOssOriginatorIssuerAndSerialNumberError;
            if (0 <= *plRemainExtra) {
                pri->OriginatorCertId.dwIdChoice =
                    CERT_ID_ISSUER_SERIAL_NUMBER;
                pri->dwOriginatorChoice = CMSG_KEY_AGREE_ORIGINATOR_CERT;
            }
            break;
        case subjectKeyIdentifier_chosen:
            ICM_GetOssOctetString(
                &pooriginator->u.subjectKeyIdentifier,
                &pri->OriginatorCertId.KeyId,
                ppbExtra, plRemainExtra);
            if (0 <= *plRemainExtra) {
                pri->OriginatorCertId.dwIdChoice =
                    CERT_ID_KEY_IDENTIFIER;
                pri->dwOriginatorChoice = CMSG_KEY_AGREE_ORIGINATOR_CERT;
            }
            break;
        case originatorKey_chosen:
            pooriginatorKey = &pooriginator->u.originatorKey;
            if (!ICM_GetOssAlgorithm(&pooriginatorKey->algorithm,
                    &pri->OriginatorPublicKeyInfo.Algorithm,
                    ppbExtra, plRemainExtra
                    ))
                goto GetOssOriginatorPublicKeyAlgorithmError;
            ICM_GetOssBitString(&pooriginatorKey->publicKey,
                &pri->OriginatorPublicKeyInfo.PublicKey,
                ppbExtra, plRemainExtra);
            if (0 <= *plRemainExtra)
                pri->dwOriginatorChoice = CMSG_KEY_AGREE_ORIGINATOR_PUBLIC_KEY;
            break;
        default:
            goto InvalidOriginatorChoice;
    }

    if (pori->bit_mask & ukm_present)
        ICM_GetOssOctetString(&pori->ukm, &pri->UserKeyingMaterial,
            ppbExtra, plRemainExtra);

    if (!ICM_GetOssAlgorithm(&pori->keyEncryptionAlgorithm,
            &pri->KeyEncryptionAlgorithm,
            ppbExtra, plRemainExtra))
        goto GetOssKeyEncryptionAlgorithmError;

    count = pori->recipientEncryptedKeys.count;
    if (0 < count) {
        RecipientEncryptedKey *porek;
        PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO prek;
        PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO *pprek;

        lData = INFO_LEN_ALIGN(
            count * sizeof(PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO) +
            count * sizeof(CMSG_RECIPIENT_ENCRYPTED_KEY_INFO));

        *plRemainExtra -= lData;
        if (0 <= *plRemainExtra) {
            pprek = (PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO *) *ppbExtra;
            prek = (PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO) (((PBYTE) pprek) +
                (count * sizeof(PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO)));
            *ppbExtra += lData;

            pri->cRecipientEncryptedKeys = count;
            pri->rgpRecipientEncryptedKeys = pprek;
        } else {
            pprek = NULL;
            prek = NULL;
        }

        porek = pori->recipientEncryptedKeys.value;
        for ( ; 0 < count; count--, porek++, prek++, pprek++) {
            RecipientIdentifier *porid = &porek->rid;

            if (0 <= *plRemainExtra) {
                memset(prek, 0, sizeof(*prek));
                *pprek = prek;

                assert(issuerAndSerialNumber_chosen ==
                    CERT_ID_ISSUER_SERIAL_NUMBER);
                assert(rKeyId_chosen ==
                    CERT_ID_KEY_IDENTIFIER);
                prek->RecipientId.dwIdChoice = porid->choice;
            }

            ICM_GetOssOctetString(&porek->encryptedKey, &prek->EncryptedKey,
                ppbExtra, plRemainExtra);

            switch (porid->choice) {
                case issuerAndSerialNumber_chosen:
                    if (!ICM_GetOssIssuerAndSerialNumber(
                            &porid->u.issuerAndSerialNumber,
                            &prek->RecipientId.IssuerSerialNumber,
                            ppbExtra, plRemainExtra))
                        goto GetOssIssuerAndSerialNumberError;
                    break;
                case rKeyId_chosen:
                    ICM_GetOssOctetString(
                        &porid->u.rKeyId.subjectKeyIdentifier,
                        &prek->RecipientId.KeyId, ppbExtra, plRemainExtra);

                    if (porid->u.rKeyId.bit_mask & date_present) {
                        if (0 <= *plRemainExtra) {
                            if (!PkiAsn1FromGeneralizedTime(
                                    &porid->u.rKeyId.date, &prek->Date))
                                goto ConvFromGeneralizedTimeError;
                        }
                    }

                    if (porid->u.rKeyId.bit_mask & other_present) {
                        if (!ICM_GetOssOtherKeyAttribute(
                                &porid->u.rKeyId.other,
                                &prek->pOtherAttr,
                                ppbExtra, plRemainExtra))
                            goto GetOssOtherKeyAttributeError;
                    }
                    break;
                default:
                    goto InvalidRecipientChoice;
            }
        }
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetOssOriginatorIssuerAndSerialNumberError)
TRACE_ERROR(GetOssOriginatorPublicKeyAlgorithmError)
TRACE_ERROR(GetOssKeyEncryptionAlgorithmError)
TRACE_ERROR(GetOssIssuerAndSerialNumberError)
TRACE_ERROR(ConvFromGeneralizedTimeError)
TRACE_ERROR(GetOssOtherKeyAttributeError)
SET_ERROR(InvalidOriginatorChoice, CRYPT_E_BAD_ENCODE)
SET_ERROR(InvalidRecipientChoice, CRYPT_E_BAD_ENCODE)
}


//+-------------------------------------------------------------------------
//  Get Oss MailListRecipientInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssMailListRecipientInfo(
    IN MailListRecipientInfo *pori,
    OUT PCMSG_MAIL_LIST_RECIPIENT_INFO *ppri,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra
    )
{
    BOOL fRet;
    LONG lData;
    PCMSG_MAIL_LIST_RECIPIENT_INFO pri;
    MailListKeyIdentifier *pomlid;

    lData = INFO_LEN_ALIGN(sizeof(CMSG_MAIL_LIST_RECIPIENT_INFO));
    *plRemainExtra -= lData;
    if (0 <= *plRemainExtra) {
        pri = (PCMSG_MAIL_LIST_RECIPIENT_INFO) *ppbExtra;
        memset(pri, 0, sizeof(*pri));
        *ppri = pri;
        *ppbExtra += lData;

        pri->dwVersion = pori->version;
    } else {
        pri = NULL;
    }

    pomlid = &pori->mlid;
    ICM_GetOssOctetString(&pomlid->kekIdentifier, &pri->KeyId,
        ppbExtra, plRemainExtra);

    if (!ICM_GetOssAlgorithm(&pori->keyEncryptionAlgorithm,
            &pri->KeyEncryptionAlgorithm,
            ppbExtra, plRemainExtra))
        goto GetOssKeyEncryptionAlgorithmError;

    ICM_GetOssOctetString(&pori->encryptedKey, &pri->EncryptedKey,
        ppbExtra, plRemainExtra);


    if (pomlid->bit_mask & date_present) {
        if (0 <= *plRemainExtra) {
            if (!PkiAsn1FromGeneralizedTime(
                    &pomlid->date, &pri->Date))
                goto ConvFromGeneralizedTimeError;
        }
    }

    if (pomlid->bit_mask & other_present) {
        if (!ICM_GetOssOtherKeyAttribute(
                &pomlid->other,
                &pri->pOtherAttr,
                ppbExtra, plRemainExtra))
            goto GetOssOtherKeyAttributeError;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetOssKeyEncryptionAlgorithmError)
TRACE_ERROR(ConvFromGeneralizedTimeError)
TRACE_ERROR(GetOssOtherKeyAttributeError)
}

//+-------------------------------------------------------------------------
//  Copy out a CMSG_CMS_RECIPIENT_INFO
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetCmsRecipientInfo(
    IN CmsRecipientInfo *pori,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    )
{
    BOOL fRet;
    LONG lData;
    PCMSG_CMS_RECIPIENT_INFO pri = (PCMSG_CMS_RECIPIENT_INFO) pvData;
    PBYTE pbExtra;
    LONG lRemainExtra;

    if (NULL == pvData)
        *pcbData = 0;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lData = INFO_LEN_ALIGN(sizeof(CMSG_CMS_RECIPIENT_INFO));
    lRemainExtra = (LONG)*pcbData - lData;
    if (0 > lRemainExtra) {
        pri = NULL;
        pbExtra = NULL;
    } else {
        assert(CMSG_KEY_TRANS_RECIPIENT == keyTransRecipientInfo_chosen);
        assert(CMSG_KEY_AGREE_RECIPIENT == keyAgreeRecipientInfo_chosen);
        assert(CMSG_MAIL_LIST_RECIPIENT == mailListRecipientInfo_chosen);
        pri->dwRecipientChoice = pori->choice;

        pbExtra = (PBYTE) pri + lData;
    }

    switch (pori->choice) {
        case keyTransRecipientInfo_chosen:
            if (!ICM_GetOssKeyTransRecipientInfo(
                    &pori->u.keyTransRecipientInfo,
                    &pri->pKeyTrans,
                    &pbExtra, &lRemainExtra
                    ))
                goto GetOssKeyTransRecipientInfoError;
            break;
        case keyAgreeRecipientInfo_chosen:
            if (!ICM_GetOssKeyAgreeRecipientInfo(
                    &pori->u.keyAgreeRecipientInfo,
                    &pri->pKeyAgree,
                    &pbExtra, &lRemainExtra
                    ))
                goto GetOssKeyAgreeRecipientInfoError;
            break;
        case mailListRecipientInfo_chosen:
            if (!ICM_GetOssMailListRecipientInfo(
                    &pori->u.mailListRecipientInfo,
                    &pri->pMailList,
                    &pbExtra, &lRemainExtra
                    ))
                goto GetOssMailListRecipientInfoError;
            break;
        default:
            goto InvalidRecipientChoice;

    }

    fRet = ICM_GetSizeFromExtra(lRemainExtra, pvData, pcbData);

CommonReturn:
    return fRet;

ErrorReturn:
    *pcbData = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetOssKeyTransRecipientInfoError)
TRACE_ERROR(GetOssKeyAgreeRecipientInfoError)
TRACE_ERROR(GetOssMailListRecipientInfoError)
SET_ERROR(InvalidRecipientChoice, CRYPT_E_BAD_ENCODE)
}
#endif  // CMS_PKCS7


//+-------------------------------------------------------------------------
//  Get a parameter after encoding/decoding a cryptographic message. Called
//  after the final CryptMsgUpdate. Only the CMSG_CONTENT_PARAM and
//  CMSG_COMPUTED_HASH_PARAM are valid for an encoded message.
//
//  For an encoded HASHED message, the CMSG_COMPUTED_HASH_PARAM can be got
//  before any CryptMsgUpdates to get its length.
//
//  The pvData type definition depends on the dwParamType value.
//
//  Elements pointed to by fields in the pvData structure follow the
//  structure. Therefore, *pcbData may exceed the size of the structure.
//
//  Upon input, if *pcbData == 0, then, *pcbData is updated with the length
//  of the data and the pvData parameter is ignored.
//
//  Upon return, *pcbData is updated with the length of the data.
//
//  The OBJID BLOBs returned in the pvData structures point to
//  their still encoded representation. The appropriate functions
//  must be called to decode the information.
//
//  See wincrypt.h for a list of the parameters to get.
//--------------------------------------------------------------------------
BOOL
WINAPI
#ifdef DEBUG_CRYPT_ASN1_MASTER
ICMTest_NewCryptMsgGetParam(
#else
CryptMsgGetParam(
#endif
    IN HCRYPTMSG hCryptMsg,
    IN DWORD dwParamType,
    IN DWORD dwIndex,
    OUT void *pvData,
    IN OUT DWORD *pcbData)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    PCRYPT_MSG_INFO     pcmi = (PCRYPT_MSG_INFO)hCryptMsg;
    ASN1error_e         Asn1Err;
    PCMSG_STREAM_INFO   pcsi = pcmi->pStreamInfo;
    BOOL                fBER = FALSE;                

    DWORD dwExceptionCode;

    ICM_Lock( pcmi);    // Single thread access to HCRYPTMSG

  // Handle MappedFile Exceptions
  __try {

    if (NULL == pvData)
        *pcbData = 0;

#ifdef CMS_PKCS7
    if (CMSG_VERSION_PARAM == dwParamType) {
        int version = 0;

        switch (pcmi->dwMsgType) {
        case CMSG_SIGNED:
            if (pcmi->fEncoding) {
                if (NULL == pcmi->pvMsg)
                    goto InvalidMessageDataError;
                version = ((SignedData *)pcmi->pvMsg)->version;
            } else {
                if (NULL == pcmi->psdi)
                    goto MessageNotDecodedError;
                version = pcmi->psdi->version;
            }
            break;
        case CMSG_ENVELOPED:
            if (NULL == pcmi->pvMsg)
                goto MessageNotDecodedError;
            version = ((CmsEnvelopedData *)pcmi->pvMsg)->version;
            break;
        case CMSG_HASHED:
            if (NULL == pcmi->pvMsg)
                goto MessageNotDecodedError;
            version = ((DigestedData *)pcmi->pvMsg)->version;
            break;
        case CMSG_SIGNED_AND_ENVELOPED:
            goto MessageTypeNotSupportedYet;
        case CMSG_ENCRYPTED:
        case CMSG_DATA:
        default:
            goto InvalidMsgType;
        }

        fRet = ICM_GetDWORD(version, pvData, pcbData);
        goto PreserveLengthReturn;
    }
#endif  // CMS_PKCS7

    if (pcmi->fEncoding) {
        switch (dwParamType) {
        case CMSG_CONTENT_PARAM:
        case CMSG_BARE_CONTENT_PARAM:
            {
                ContentInfo     ci;
                ASN1encoding_t  pEnc = ICM_GetEncoder();
                PBYTE           pbEncoded = NULL;
                DWORD           cbEncoded;
                PBYTE           pbContent = NULL;

                if (pcsi)
                    goto GetContentParamNotValidForStreaming;

                switch (pcmi->dwMsgType) {
                case CMSG_SIGNED:
                    if (0 == ((SignedData *) pcmi->pvMsg)->signerInfos.count)
                        // For a bag of certs, don't DER order
                        fBER = TRUE;
                    break;
                case CMSG_DATA:
                case CMSG_ENVELOPED:
                case CMSG_HASHED:
                    break;
                case CMSG_SIGNED_AND_ENVELOPED:
                case CMSG_ENCRYPTED:
                    goto MessageTypeNotSupportedYet;
                default:
                    goto InvalidMsgType;
                }

                if (fBER)
                    PkiAsn1SetEncodingRule(ICM_GetEncoder(), ASN1_BER_RULE_BER);

                if (0 != (Asn1Err = PkiAsn1Encode(
                        pEnc,
                        pcmi->pvMsg,
                        aiPduNum[ pcmi->dwMsgType - 1],
                        &pbEncoded,
                        &cbEncoded))) {
                    goto CONTENT_PARAMAsn1EncodeError;
                }

                if (CMSG_CONTENT_PARAM == dwParamType) {
                    if (!ICM_CopyOssObjectIdentifier(
                            &ci.contentType,
                            &aoidMessages[ pcmi->dwMsgType - 1]))
                        goto CopyOssObjectIdentifierContentTypeError;
                    ci.bit_mask = content_present;
                    ci.content.length = cbEncoded;
                    ci.content.value = pbEncoded;
                    pbContent = pbEncoded;

                    if (0 != (Asn1Err = PkiAsn1Encode(
                            pEnc,
                            &ci,
                            ContentInfo_PDU,
                            &pbEncoded,
                            &cbEncoded))) {
                        PkiAsn1FreeEncoded(pEnc, pbContent);
                        goto Asn1EncodeSignedDataError;
                    }
                }

                fRet = ICM_CopyOut(
                            pbEncoded,
                            cbEncoded,
                            (PBYTE)pvData,
                            pcbData);
                if (!fRet)
                    dwError = GetLastError();
                if (pbContent)
                    PkiAsn1FreeEncoded(pEnc, pbContent);
                PkiAsn1FreeEncoded(pEnc, pbEncoded);
                if (!fRet)
                    SetLastError(dwError);
                break;
            }

        case CMSG_COMPUTED_HASH_PARAM:
            fRet = ICM_GetComputedDigestParam( pcmi, dwIndex, pvData, pcbData);
            break;

        case CMSG_ENCODED_SIGNER:
            switch (pcmi->dwMsgType) {
            case CMSG_SIGNED:
                break;
            case CMSG_SIGNED_AND_ENVELOPED:
                goto MessageTypeNotSupportedYet;
            default:
                goto InvalidMsgType;
            }
            fRet = ICM_GetSignerParamEncoding(
                            pcmi,
                            dwIndex,
                            dwParamType,
                            pvData,
                            pcbData);
            break;

        default:
            goto InvalidMsgType;
        }
    } else {
        //
        // Decode
        //
        switch (dwParamType) {
        case CMSG_TYPE_PARAM:
            if (pcsi && (0 == pcmi->dwMsgType))
                goto StreamMsgNotReadyError;
            fRet = ICM_GetDWORD( pcmi->dwMsgType, pvData, pcbData);
            break;
        case CMSG_CONTENT_PARAM:
            {
                ContentInfo     *pci;
                PCONTENT_INFO   pci2;
                PBYTE           pbDER = NULL;
                DWORD           cbDER;
                PBYTE           pb;
                DWORD           cb;

                if (pcsi)
                    goto GetContentParamNotValidForStreaming;

                switch (pcmi->dwMsgType) {
                case CMSG_DATA:
                {
                    OctetStringType *poos = (OctetStringType *)pcmi->pvMsg;

                    pb = (PBYTE)poos->value;
                    cb = poos->length;
                    fRet = ICM_CopyOut( pb, cb, (PBYTE)pvData, pcbData);
                    break;
                }
                case CMSG_SIGNED:
                    if (NULL == pcmi->psdi)
                        goto InvalidSignedMessageError;
                    pci2 = pcmi->psdi->pci;
                    if (pci2->content.cbData) {
                        cb = pci2->content.cbData;
                        pb = pci2->content.pbData;

                        if (0 == strcmp(pszObjIdDataType,
                                pci2->pszContentType)
#ifdef CMS_PKCS7
                                ||  pcmi->psdi->version >= CMSG_SIGNED_DATA_CMS_VERSION 
#endif  // CMS_PKCS7
                                ) {
                            if (!ICM_ReEncodeAsOctetDER(
                                    pb,
                                    cb,
                                    &pbDER,
                                    &cbDER
                                    ))
                                goto ReEncodeAsOctetDERError;
                            if (pbDER) {
                                if (0 > Asn1UtilExtractContent( pbDER, cbDER,
                                        &cb, (const BYTE **)&pb)) {
                                    PkiAsn1FreeEncoded( ICM_GetEncoder(), pbDER);
                                    goto ExtractContentError;
                                }
                            }
                        }

                        fRet = ICM_CopyOut( pb, cb, (PBYTE)pvData, pcbData);
                        if (!fRet)
                            dwError = GetLastError();
                        if (pbDER)
                            PkiAsn1FreeEncoded( ICM_GetEncoder(), pbDER);
                        if (!fRet)
                            SetLastError(dwError);
                    } else {
                        *pcbData = 0;
                        fRet = TRUE;
                    }
                    break;
                case CMSG_ENVELOPED:
                    if (NULL == pcmi->Plaintext.pbData) {
                        // Hasn't been decrypted yet

                        EncryptedContentInfo *peci;
                        PBYTE pbCiphertext;
                        DWORD cbCiphertext;
#ifdef CMS_PKCS7
                        peci = &((CmsEnvelopedData *)pcmi->pvMsg)->encryptedContentInfo;
#else
                        peci = &((EnvelopedData *)pcmi->pvMsg)->encryptedContentInfo;
#endif  // CMS_PKCS7

                        if (peci->bit_mask & encryptedContent_present) {
                            pbCiphertext = peci->encryptedContent.value;
                            cbCiphertext = peci->encryptedContent.length;
                        } else {
                            pbCiphertext = NULL;
                            cbCiphertext = 0;
                        }


                        if (NULL == pvData) {
                            // Assume (sizeof plaintext) <=
                            // (sizeof ciphertext)
                            //
                            // not decrypted yet; return ciphertext size

                            fRet = TRUE;
                            // + 6 => to allow for identifier and length octets
                            *pcbData = cbCiphertext + 6;
                        } else
                            // Return ciphertext
                            fRet = ICM_CopyOut(
                                    pbCiphertext,
                                    cbCiphertext,
                                    (PBYTE)pvData,
                                    pcbData);
                        goto ContentCopiedOut;
                    }

                    if (!ICM_EqualObjectIDs(
#ifdef CMS_PKCS7
                            &((CmsEnvelopedData *)pcmi->pvMsg)->encryptedContentInfo.contentType,
                            &aoidMessages[ CMSG_DATA - 1])
                                    &&
                            CMSG_ENVELOPED_DATA_CMS_VERSION >
                                ((CmsEnvelopedData *)pcmi->pvMsg)->version) {
#else
                            &((EnvelopedData *)pcmi->pvMsg)->encryptedContentInfo.contentType,
                            &aoidMessages[ CMSG_DATA - 1])) {
#endif  // CMS_PKCS7
                        // Not DATA or encapsulated, so must prepend
                        // identifier and length octets
                        fRet = ICM_CopyOutAddDERPrefix(
                                    pcmi->Plaintext.pbData,
                                    pcmi->Plaintext.cbData,
                                    ICM_TAG_SEQ,
                                    (PBYTE)pvData,
                                    pcbData);
                    } else {
                        fRet = ICM_CopyOut(
                                    pcmi->Plaintext.pbData,
                                    pcmi->Plaintext.cbData,
                                    (PBYTE)pvData,
                                    pcbData);
                    }
                    goto ContentCopiedOut;

                case CMSG_HASHED:
                    pci = &((DigestedData *)pcmi->pvMsg)->contentInfo;
                    if (pci->bit_mask & content_present) {
                        cb = (DWORD)pci->content.length;
                        pb = (PBYTE)pci->content.value;

                        if (ICM_EqualObjectIDs(
                                    &pci->contentType,
                                    &aoidMessages[ CMSG_DATA - 1])
#ifdef CMS_PKCS7
                                || ((DigestedData *)pcmi->pvMsg)->version >=
                                    CMSG_HASHED_DATA_V2 
#endif  // CMS_PKCS7
                                ) {
                            if (!ICM_ReEncodeAsOctetDER(
                                    pb,
                                    cb,
                                    &pbDER,
                                    &cbDER
                                    ))
                                goto ReEncodeAsOctetDERError;
                            if (pbDER) {
                                if (0 > Asn1UtilExtractContent( pbDER, cbDER,
                                        &cb, (const BYTE **)&pb)) {
                                    PkiAsn1FreeEncoded( ICM_GetEncoder(), pbDER);
                                    goto ExtractContentError;
                                }
                            }
                        }

                        fRet = ICM_CopyOut( pb, cb, (PBYTE)pvData, pcbData);
                        if (!fRet)
                            dwError = GetLastError();
                        if (pbDER)
                            PkiAsn1FreeEncoded( ICM_GetEncoder(), pbDER);
                        if (!fRet)
                            SetLastError(dwError);
                    } else {
                        *pcbData = 0;
                        fRet = TRUE;
                    }
                    break;
                case CMSG_SIGNED_AND_ENVELOPED:
                case CMSG_ENCRYPTED:
                    goto MessageTypeNotSupportedYet;
                default:
                    goto InvalidMsgType;
                }
ContentCopiedOut:
                break;
            }

        case CMSG_INNER_CONTENT_TYPE_PARAM:
            {
                ContentType     *pct;

                switch (pcmi->dwMsgType) {
                case CMSG_SIGNED:
                    if (NULL == pcmi->psdi)
                        goto InvalidSignedMessageError;
                    fRet = ICM_CopyOut(
                                (PBYTE)pcmi->psdi->pci->pszContentType,
                                strlen( pcmi->psdi->pci->pszContentType) + 1,
                                (PBYTE)pvData,
                                pcbData);
                    goto ContentTypeCopiedOut;
                    break;
                case CMSG_ENVELOPED:
#ifdef CMS_PKCS7
                    pct = &((CmsEnvelopedData *)pcmi->pvMsg)->encryptedContentInfo.contentType;
#else
                    pct = &((EnvelopedData *)pcmi->pvMsg)->encryptedContentInfo.contentType;
#endif  // CMS_PKCS7
                    break;
                case CMSG_HASHED:
                    pct = &((DigestedData *)pcmi->pvMsg)->contentInfo.contentType;
                    break;
                case CMSG_SIGNED_AND_ENVELOPED:
                case CMSG_ENCRYPTED:
                    goto MessageTypeNotSupportedYet;
                default:
                    goto InvalidMsgType;
                }
                fRet = PkiAsn1FromObjectIdentifier(
                            pct->count,
                            pct->value,
                            (LPSTR)pvData,
                            pcbData);
ContentTypeCopiedOut:
                break;
            }

        case CMSG_ENCODED_MESSAGE:
            fRet = ICM_GetEncodedMessageParam(
                            pcmi,
                            (PBYTE)pvData,
                            pcbData);
            break;

        case CMSG_SIGNER_COUNT_PARAM:
            {
                DWORD   cSigner;

                switch (pcmi->dwMsgType) {
                case CMSG_SIGNED:
                    if (NULL == pcmi->psdi)
                        goto InvalidSignedMessageError;
                    cSigner = pcmi->psdi->pSignerList->Length();
                    break;
                case CMSG_SIGNED_AND_ENVELOPED:
                    goto MessageTypeNotSupportedYet;
                default:
                    goto InvalidMsgType;
                }
                fRet = ICM_GetDWORD( cSigner, pvData, pcbData);
                break;
            }

        case CMSG_ENCRYPTED_DIGEST:
        case CMSG_ENCODED_SIGNER:
        case CMSG_SIGNER_INFO_PARAM:
        case CMSG_SIGNER_CERT_INFO_PARAM:
        case CMSG_SIGNER_HASH_ALGORITHM_PARAM:
        case CMSG_SIGNER_AUTH_ATTR_PARAM:
        case CMSG_SIGNER_UNAUTH_ATTR_PARAM:

        case CMSG_CMS_SIGNER_INFO_PARAM:
        case CMSG_SIGNER_CERT_ID_PARAM:

            switch (pcmi->dwMsgType) {
            case CMSG_SIGNED:
                break;
            case CMSG_SIGNED_AND_ENVELOPED:
                goto MessageTypeNotSupportedYet;
            default:
                goto InvalidMsgType;
            }
            fRet = ICM_GetSignerParam(
                            pcmi,
                            dwIndex,
                            dwParamType,
                            pvData,
                            pcbData);
            break;

        case CMSG_CERT_COUNT_PARAM:
            {
                CBlobList *pBlobList;
                DWORD     dwCount;
#ifdef CMS_PKCS7
                BOOL      fPossibleAttrCert = FALSE;
#endif  // CMS_PKCS7

                switch (pcmi->dwMsgType) {
                case CMSG_SIGNED:
                    if (NULL == pcmi->psdi)
                        goto InvalidSignedMessageError;
                    pBlobList = pcmi->psdi->pCertificateList;
#ifdef CMS_PKCS7
                    if (pcmi->psdi->version >= CMSG_SIGNED_DATA_CMS_VERSION)
                        fPossibleAttrCert = TRUE;
#endif  // CMS_PKCS7
                    break;
#ifdef CMS_PKCS7
                case CMSG_ENVELOPED:
                    pBlobList = pcmi->pCertificateList;
                    fPossibleAttrCert = TRUE;
                    break;
#endif  // CMS_PKCS7
                case CMSG_SIGNED_AND_ENVELOPED:
                    goto MessageTypeNotSupportedYet;
                default:
                    goto InvalidMsgType;
                }

                dwCount = pBlobList->Length();

#ifdef CMS_PKCS7
                if (dwCount && fPossibleAttrCert)
                    dwCount = ICM_GetTaggedBlobCount(
                        pBlobList,
                        ICM_TAG_SEQ
                        );
#endif  // CMS_PKCS7

                fRet = ICM_GetDWORD( dwCount, pvData, pcbData);
                break;
            }

        case CMSG_CERT_PARAM:
            {
                CBlobList   *pBlobList;
                CBlobNode   *pBlobNode;
#ifdef CMS_PKCS7
                BOOL        fPossibleAttrCert = FALSE;
#endif  // CMS_PKCS7

                switch (pcmi->dwMsgType) {
                case CMSG_SIGNED:
                    if (NULL == pcmi->psdi)
                        goto InvalidSignedMessageError;
                    pBlobList = pcmi->psdi->pCertificateList;
#ifdef CMS_PKCS7
                    if (pcmi->psdi->version >= CMSG_SIGNED_DATA_CMS_VERSION)
                        fPossibleAttrCert = TRUE;
#endif  // CMS_PKCS7
                    break;
#ifdef CMS_PKCS7
                case CMSG_ENVELOPED:
                    pBlobList = pcmi->pCertificateList;
                    fPossibleAttrCert = TRUE;
                    break;
#endif  // CMS_PKCS7
                case CMSG_SIGNED_AND_ENVELOPED:
                    goto MessageTypeNotSupportedYet;
                default:
                    goto InvalidMsgType;
                }

                // Get blob at specified cert index. Index
                // is advanced to the appropriate blob.
                pBlobNode = ICM_GetTaggedBlobAndAdvanceIndex(
                    pBlobList,
#ifdef CMS_PKCS7
                    fPossibleAttrCert ? ICM_TAG_SEQ : 0,
#else
                    0,                  // bTag
#endif  // CMS_PKCS7
                    &dwIndex
                    );
                    
                if (pBlobNode)
                    fRet = ICM_CopyOut(
                                pBlobNode->Data()->pbData,
                                pBlobNode->Data()->cbData,
                                (PBYTE)pvData,
                                pcbData);
                else
                    fRet = FALSE;
                break;
            }

#ifdef CMS_PKCS7
        case CMSG_ATTR_CERT_COUNT_PARAM:
            {
                CBlobList *pBlobList;
                BOOL      fPossibleAttrCert = FALSE;
                DWORD     dwCount;

                switch (pcmi->dwMsgType) {
                case CMSG_SIGNED:
                    if (NULL == pcmi->psdi)
                        goto InvalidSignedMessageError;
                    pBlobList = pcmi->psdi->pCertificateList;
                    if (pcmi->psdi->version >= CMSG_SIGNED_DATA_CMS_VERSION)
                        fPossibleAttrCert = TRUE;
                    break;
                case CMSG_ENVELOPED:
                    pBlobList = pcmi->pCertificateList;
                    fPossibleAttrCert = TRUE;
                    break;
                default:
                    goto InvalidMsgType;
                }

                if (fPossibleAttrCert)
                    dwCount = ICM_GetTaggedBlobCount(
                        pBlobList,
                        ICM_TAG_CONSTRUCTED_CONTEXT_1
                        );
                else
                    dwCount = 0;

                fRet = ICM_GetDWORD( dwCount, pvData, pcbData);
                break;
            }

        case CMSG_ATTR_CERT_PARAM:
            {
                CBlobList   *pBlobList;
                CBlobNode   *pBlobNode;
                BOOL        fPossibleAttrCert = FALSE;

                switch (pcmi->dwMsgType) {
                case CMSG_SIGNED:
                    if (NULL == pcmi->psdi)
                        goto InvalidSignedMessageError;
                    pBlobList = pcmi->psdi->pCertificateList;
                    if (pcmi->psdi->version >= CMSG_SIGNED_DATA_CMS_VERSION)
                        fPossibleAttrCert = TRUE;
                    break;
                case CMSG_ENVELOPED:
                    pBlobList = pcmi->pCertificateList;
                    fPossibleAttrCert = TRUE;
                    break;
                default:
                    goto InvalidMsgType;
                }

                if (!fPossibleAttrCert)
                    pBlobNode = NULL;
                else
                    // Get blob at specified attribute cert index. Index
                    // is advanced to the appropriate blob
                    pBlobNode = ICM_GetTaggedBlobAndAdvanceIndex(
                        pBlobList,
                        ICM_TAG_CONSTRUCTED_CONTEXT_1,
                        &dwIndex
                        );
                    
                if (pBlobNode) {
                    fRet = ICM_CopyOut(
                                pBlobNode->Data()->pbData,
                                pBlobNode->Data()->cbData,
                                (PBYTE)pvData,
                                pcbData);
                    if (fRet && pvData)
                        *((PBYTE)pvData) = ICM_TAG_SEQ;
                } else
                    fRet = FALSE;
                break;
            }
#endif  // CMS_PKCS7

        case CMSG_CRL_COUNT_PARAM:
            {
                CBlobList *pBlobList;

                switch (pcmi->dwMsgType) {
                case CMSG_SIGNED:
                    if (NULL == pcmi->psdi)
                        goto InvalidSignedMessageError;
                    pBlobList = pcmi->psdi->pCrlList;
                    break;
#ifdef CMS_PKCS7
                case CMSG_ENVELOPED:
                    pBlobList = pcmi->pCrlList;
                    break;
#endif  // CMS_PKCS7
                case CMSG_SIGNED_AND_ENVELOPED:
                    goto MessageTypeNotSupportedYet;
                default:
                    goto InvalidMsgType;
                }
                fRet = ICM_GetDWORD( pBlobList->Length(), pvData, pcbData);
                break;
            }

        case CMSG_CRL_PARAM:
            {
                CBlobList   *pBlobList;
                CBlobNode   *pBlobNode;
                DWORD       i;

                switch (pcmi->dwMsgType) {
                case CMSG_SIGNED:
                    if (NULL == pcmi->psdi)
                        goto InvalidSignedMessageError;
                    pBlobList = pcmi->psdi->pCrlList;
                    break;
#ifdef CMS_PKCS7
                case CMSG_ENVELOPED:
                    pBlobList = pcmi->pCrlList;
                    break;
#endif  // CMS_PKCS7
                case CMSG_SIGNED_AND_ENVELOPED:
                    goto MessageTypeNotSupportedYet;
                default:
                    goto InvalidMsgType;
                }

                // This list-walking should be a class method
                for (i=dwIndex, pBlobNode=pBlobList->Head();
                        (i>0) && pBlobNode;
                        i--, pBlobNode=pBlobNode->Next())
                    ;
                if (pBlobNode)
                    fRet = ICM_CopyOut(
                                pBlobNode->Data()->pbData,
                                pBlobNode->Data()->cbData,
                                (PBYTE)pvData,
                                pcbData);
                else
                    fRet = FALSE;
                break;
            }

        case CMSG_ENVELOPE_ALGORITHM_PARAM:
            {
                ContentEncryptionAlgId  *pceai;

                if (pcsi &&
                        (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_ECIALGID)))
                    goto StreamMsgNotReadyError;

                switch (pcmi->dwMsgType) {
                case CMSG_ENVELOPED:
#ifdef CMS_PKCS7
                    pceai = &((CmsEnvelopedData *)pcmi->pvMsg)->encryptedContentInfo.contentEncryptionAlgorithm;
#else
                    pceai = &((EnvelopedData *)pcmi->pvMsg)->encryptedContentInfo.contentEncryptionAlgorithm;
#endif  // CMS_PKCS7
                    break;

                case CMSG_SIGNED_AND_ENVELOPED:
                    goto MessageTypeNotSupportedYet;

                default:
                    goto InvalidMsgType;
                }

                fRet = ICM_GetALGORITHM_IDENTIFIER( pceai, pvData, pcbData);
                break;
            }

#ifdef CMS_PKCS7
        case CMSG_UNPROTECTED_ATTR_PARAM:
            {
                CmsEnvelopedData *ped;

                ped = (CmsEnvelopedData *)pcmi->pvMsg;
                if (ped && (ped->bit_mask & unprotectedAttrs_present))
                    fRet = ICM_GetAttributesData(
                        &ped->unprotectedAttrs,
                        pvData,
                        pcbData);
                else
                    goto UnprotectedAttrMissingError;
            }
            break;

        case CMSG_RECIPIENT_COUNT_PARAM:
            {
                DWORD dwPkcsCount;
                if (!ICM_GetPkcsRecipientCount(pcmi, &dwPkcsCount))
                    goto GetPkcsRecipientCountError;
                fRet = ICM_GetDWORD(dwPkcsCount, pvData, pcbData);
            }
            break;

        case CMSG_RECIPIENT_INDEX_PARAM:
            {
                DWORD dwPkcsIndex;
                DWORD dwCmsIndex;
                DWORD cbData = sizeof(dwCmsIndex);

                if (!CryptMsgGetParam(
                        hCryptMsg,
                        CMSG_CMS_RECIPIENT_INDEX_PARAM,
                        0,                                  // dwIndex
                        &dwCmsIndex,
                        &cbData))
                    goto GetCmsRecipientIndexError;

                if (!ICM_ConvertCmsToPkcsRecipientIndex(
                        pcmi, dwCmsIndex, &dwPkcsIndex))
                    goto ConvertCmsToPkcsRecipientIndexError;

                fRet = ICM_GetDWORD(
                            dwPkcsIndex,
                            pvData,
                            pcbData);
            }
            break;

        case CMSG_RECIPIENT_INFO_PARAM:
            {
                CmsRecipientInfos *pris;
                KeyTransRecipientInfo *pri;
                DWORD dwCmsIndex;

                if (NULL == (pris = ICM_GetDecodedCmsRecipientInfos(pcmi)))
                    goto GetDecodedCmsRecipientsError;

                if (!ICM_ConvertPkcsToCmsRecipientIndex(
                        pcmi, dwIndex, &dwCmsIndex))
                    goto ConvertPkcsToCmsRecipientIndexError;
                pri = &pris->value[dwCmsIndex].u.keyTransRecipientInfo;

                fRet = ICM_GetCertInfoIssuerAndSerialNumber(
                    &pri->rid, pvData, pcbData);
                break;
            }

        case CMSG_CMS_RECIPIENT_COUNT_PARAM:
            {
                CmsRecipientInfos *pris;

                if (NULL == (pris = ICM_GetDecodedCmsRecipientInfos(pcmi)))
                    goto GetDecodedCmsRecipientsError;
                fRet = ICM_GetDWORD(pris->count, pvData, pcbData);
            }
            break;

        case CMSG_CMS_RECIPIENT_INDEX_PARAM:
            {
                CmsRecipientInfos *pris;

                if (NULL == (pris = ICM_GetDecodedCmsRecipientInfos(pcmi)))
                    goto GetDecodedCmsRecipientsError;
                fRet = ICM_GetDWORD(
                            pcmi->dwDecryptedRecipientIndex,
                            pvData,
                            pcbData);
            }
            break;

        case CMSG_CMS_RECIPIENT_ENCRYPTED_KEY_INDEX_PARAM:
            {
                CmsRecipientInfos *pris;
                CmsRecipientInfo *pri;

                if (NULL == (pris = ICM_GetDecodedCmsRecipientInfos(pcmi)))
                    goto GetDecodedCmsRecipientsError;

                pri = pris->value + pcmi->dwDecryptedRecipientIndex;
                if (keyAgreeRecipientInfo_chosen != pri->choice)
                    goto NotKeyAgreeRecipientIndex;
                
                fRet = ICM_GetDWORD(
                            pcmi->dwDecryptedRecipientEncryptedKeyIndex,
                            pvData,
                            pcbData);
            }
            break;

        case CMSG_CMS_RECIPIENT_INFO_PARAM:
            {
                CmsRecipientInfos *pris;

                if (NULL == (pris = ICM_GetDecodedCmsRecipientInfos(pcmi)))
                    goto GetDecodedCmsRecipientsError;
                if (dwIndex >= pris->count)
                    goto IndexTooBig;
                fRet = ICM_GetCmsRecipientInfo(pris->value + dwIndex,
                    pvData, pcbData);
            }
            break;
#else

        case CMSG_RECIPIENT_COUNT_PARAM:
            {
                RecipientInfos *pris;

                if (pcsi &&
                        (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_RECIPINFOS)))
                    goto StreamMsgNotReadyError;

                switch (pcmi->dwMsgType) {
                case CMSG_ENVELOPED:
                    pris = &((EnvelopedData *)pcmi->pvMsg)->recipientInfos;
                    break;

                case CMSG_SIGNED_AND_ENVELOPED:
                    goto MessageTypeNotSupportedYet;

                default:
                    goto InvalidMsgType;
                }

                fRet = ICM_GetDWORD( pris->count, pvData, pcbData);
                break;
            }

        case CMSG_RECIPIENT_INDEX_PARAM:
            {
                if (pcsi &&
                        (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_RECIPINFOS)))
                    goto StreamMsgNotReadyError;

                switch (pcmi->dwMsgType) {
                case CMSG_ENVELOPED:
                case CMSG_SIGNED_AND_ENVELOPED:
                    break;

                default:
                    goto InvalidMsgType;
                }

                fRet = ICM_GetDWORD(
                            pcmi->dwDecryptedRecipientIndex,
                            pvData,
                            pcbData);
                break;
            }

        case CMSG_RECIPIENT_INFO_PARAM:
            {
                RecipientInfos *pris;
                RecipientInfo  *pri;
                PCERT_INFO      pci = (PCERT_INFO)pvData;

                if (pcsi &&
                        (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_RECIPINFOS)))
                    goto StreamMsgNotReadyError;

                switch (pcmi->dwMsgType) {
                case CMSG_ENVELOPED:
                    pris = &((EnvelopedData *)pcmi->pvMsg)->recipientInfos;
                    if (dwIndex >= pris->count)
                        goto IndexTooBig;
                    pri = pris->value + dwIndex;
                    break;

                case CMSG_SIGNED_AND_ENVELOPED:
                    goto MessageTypeNotSupportedYet;

                default:
                    goto InvalidMsgType;
                }

                // for lRemainExtra < 0, LENGTH_ONLY calculation
                lData = INFO_LEN_ALIGN( sizeof(CERT_INFO));
                lRemainExtra = (LONG)*pcbData - lData;
                if (0 > lRemainExtra) {
                    pci = NULL;
                    pbExtra = NULL;
                } else {
                    pbExtra = (PBYTE)pci + lData;
                }
                if (!ICM_GetOssIssuerAndSerialNumber(
                        &pri->issuerAndSerialNumber,
                        pci, &pbExtra, &lRemainExtra))
                    goto GetOssIssuerAndSerialNumberError;
                fRet = ICM_GetSizeFromExtra( lRemainExtra, pvData, pcbData);
                break;
            }
#endif  // CMS_PKCS7

        case CMSG_HASH_ALGORITHM_PARAM:
            fRet = ICM_GetALGORITHM_IDENTIFIER(
                            &((DigestedData *)pcmi->pvMsg)->digestAlgorithm,
                            pvData,
                            pcbData);
            break;

        case CMSG_HASH_DATA_PARAM:
            fRet = ICM_GetDigestDataParam( pcmi, pvData, pcbData);
            break;

        case CMSG_COMPUTED_HASH_PARAM:
            fRet = ICM_GetComputedDigestParam( pcmi, dwIndex, pvData, pcbData);
            break;

        case CMSG_ENCRYPT_PARAM:
#if 0
            {
                goto ParamTypeNotSupportedYet;
            }
#endif
        default:
            goto InvalidMsgType;
        }
    }

#ifdef CMS_PKCS7
PreserveLengthReturn:
#endif  // CMS_PKCS7

    if (!fRet)
        dwError = GetLastError();

  } __except(EXCEPTION_EXECUTE_HANDLER) {
    dwExceptionCode = GetExceptionCode();
    goto ExceptionError;
  }

CommonReturn:
    if (fBER)
        PkiAsn1SetEncodingRule(ICM_GetEncoder(), ASN1_BER_RULE_DER);

    ICM_Unlock( pcmi);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    *pcbData = 0;
    fRet = FALSE;
    goto CommonReturn;
StreamMsgNotReadyError:
    dwError = (DWORD)CRYPT_E_STREAM_MSG_NOT_READY;
    goto ErrorReturn;
SET_ERROR(GetContentParamNotValidForStreaming, E_INVALIDARG)
SET_ERROR(IndexTooBig,CRYPT_E_INVALID_INDEX)
SET_ERROR(MessageTypeNotSupportedYet,CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(InvalidMsgType,CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(ExtractContentError,CRYPT_E_UNEXPECTED_ENCODING)
SET_ERROR_VAR(CONTENT_PARAMAsn1EncodeError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR_VAR(Asn1EncodeSignedDataError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(CopyOssObjectIdentifierContentTypeError)    // error already set
TRACE_ERROR(ReEncodeAsOctetDERError)                    // error already set
SET_ERROR(InvalidSignedMessageError, ERROR_INVALID_DATA)
#ifdef CMS_PKCS7
SET_ERROR(MessageNotDecodedError, ERROR_INVALID_DATA)
SET_ERROR(InvalidMessageDataError, ERROR_INVALID_DATA)

TRACE_ERROR(GetDecodedCmsRecipientsError)
TRACE_ERROR(GetPkcsRecipientCountError)
TRACE_ERROR(ConvertCmsToPkcsRecipientIndexError)
TR