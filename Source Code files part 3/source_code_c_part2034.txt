ibParam(Stress2Params.PROPERTY_MYINT32PROP2, new XRLXeIntValue(20)), //range
//                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP42, new XRLXeIntValue(20)), //range
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP43, new XRLXeIntValue(20)), //range
*/
//the following are not part of filters
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP44, new XRLXeIntValue(2)), //bool
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP45, new XRLXeIntValue(2)), //bool
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP46, new XRLXeIntValue(2)), //bool
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP47, new XRLXeIntValue(2)), //bool
//                new XRLXeAttribParam(Stress2Params.PROPERTY_, new XRLXeIntValue(2)),  //type
//                new XRLXeAttribParam(Stress2Params.PROPERTY_, new XRLXeIntValue(2)),  //mode
//                new XRLXeAttribParam(Stress2Params.PROPERTY_COUNTRY, new XRLXeIntValue(2)),
            };


//Midddle-sized weighted query--23 title defined.  The 24th here is mu.
            public static XRLXeAttribParamWeighted[] weightedParamsMidsizeWeightedSearchTemplate = new XRLXeAttribParamWeighted [13]{
                new XRLXeAttribParamWeighted(Stress2Params.PROPERTY_MYINT64PROP34, (float) .05, new XRLXeIntValue(2)),
                new XRLXeAttribParamWeighted(Stress2Params.PROPERTY_MYINT64PROP35, (float) .05, new XRLXeIntValue(2)),
                new XRLXeAttribParamWeighted(Stress2Params.PROPERTY_MYINT64PROP36, (float) .05, new XRLXeIntValue(2)),
                new XRLXeAttribParamWeighted(Stress2Params.PROPERTY_MYINT64PROP37, (float) .05, new XRLXeIntValue(2)),
                new XRLXeAttribParamWeighted(Stress2Params.PROPERTY_MYINT64PROP38, (float) .05, new XRLXeIntValue(2)),
                new XRLXeAttribParamWeighted(Stress2Params.PROPERTY_MYINT64PROP39, (float) .05, new XRLXeIntValue(2)),
                new XRLXeAttribParamWeighted(Stress2Params.PROPERTY_MYINT64PROP40, (float) .05, new XRLXeIntValue(2)),
                new XRLXeAttribParamWeighted(Stress2Params.PROPERTY_MYINT64PROP41, (float) .05, new XRLXeIntValue(2)),
                new XRLXeAttribParamWeighted(Stress2Params.PROPERTY_FLOAT64PROP, (float) .05, new XRLXeDoubleValue(1)),
                new XRLXeAttribParamWeighted(Stress2Params.PROPERTY_MYFLOAT64PROP2, (float) .05, new XRLXeDoubleValue(1)),
                new XRLXeAttribParamWeighted(Stress2Params.PROPERTY_MYFLOAT32PROP1, (float) .05, new XRLXeFloatValue(1)), //not
                                                                                                                          //in template!
                new XRLXeAttribParamWeighted(Stress2Params.PROPERTY_MYFLOAT32PROP2, (float) .05, new XRLXeFloatValue(1)),
                new XRLXeAttribParamWeighted(Stress2Params.PROPERTY_MU, (float) (.05 / 6), new XRLXeDoubleValue(6)),
            };

            public static XRLXeAttribParam[] nonWeightedParamsMidsizeWeightedSearchTemplate = new XRLXeAttribParam [11]{
                new XRLXeAttribParam(Stress2Params.PROPERTY_INT64PROP, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP2, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP3, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP4, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP5, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP6, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP7, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP8, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP9, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP10, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP11, new XRLXeIntValue(2)),
//system atts
//                new XRLXeAttribParam(Stress2Params.PROPERTY_, new XRLXeIntValue(2)),  //type
//                new XRLXeAttribParam(Stress2Params.PROPERTY_, new XRLXeIntValue(2)),  //mode
//                new XRLXeAttribParam(Stress2Params.PROPERTY_COUNTRY, new XRLXeIntValue(2)),
            };
//Middle-sized unweighted query--23 title defined.
            public static XRLXeAttribParam[] nonWeightedParamsMidsizeUnweightedSearchTemplate = new XRLXeAttribParam [24]{
                new XRLXeAttribParam(Stress2Params.PROPERTY_INT64PROP, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP2, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP3, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP4, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP5, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP6, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP7, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP8, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP9, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP10, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP11, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP12, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP13, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP14, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP15, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP16, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP17, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP18, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP19, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP20, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP21, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP22, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP23, new XRLXeIntValue(2)),
//system atts               
//                new XRLXeAttribParam(Stress2Params.PROPERTY_, new XRLXeIntValue(2)),  //type
//                new XRLXeAttribParam(Stress2Params.PROPERTY_, new XRLXeIntValue(2)),  //mode
//                new XRLXeAttribParam(Stress2Params.PROPERTY_COUNTRY, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MU, new XRLXeDoubleValue(2)),
            };


		/******************************************************************
		 * All 10 testing titles share the same attribute IDs and query IDs
		 *****************************************************************/
		// context and property attributeIDs
		public const uint			CONTEXT_MYCONTEXT = 1;
		public const uint			PROPERTY_INT32PROP = 0x10000001;
		public const uint			PROPERTY_INT64PROP = 0x20000002;
		public const uint			PROPERTY_FLOAT64PROP = 0x30000004;
		public const uint			PROPERTY_FLOAT32PROP = 0x50000003;
		public const uint			PROPERTY_DATETIMEPROP = 0x70000005;

		// context values
		public const uint			CONTEXT_MYCONTEXT_MYCONTEXTVALUE1 = 0;
		public const uint			CONTEXT_MYCONTEXT_MYCONTEXTVALUE2 = 1;

		public const uint			CONTEXT_GAME_MODE_GAMEMODEA = 0;
		public const uint			CONTEXT_GAME_MODE_GAMEMODEB = 1;
		public const uint			CONTEXT_GAME_MODE_GAMEMODEC = 2;
		// Matchmaking queries.  These exist in the FFFF008... titles.
		public const uint			SESSION_MATCH_QUERY_SORTBYDATETIMEQUERY = 0;
		public const uint			SESSION_MATCH_QUERY_SORTBYINT64QUERY = 1;
		public const uint			SESSION_MATCH_QUERY_SORTBYALLQUERY = 2;
		public const uint			SESSION_MATCH_QUERY_SORTBYFLOAT64QUERY = 3;
                public const uint                       SESSION_MATCH_QUERY_SIMPLE_WEIGHTED_QUERY = 4;
                // This is only for FFFF008B.
                public const uint                       SESSION_MATCH_QUERY_OMAHA_QUERY = 5;
                public const uint                       SESSION_MATCH_QUERY_MID_SIZE_WEIGHTED = 6;
                public const uint                       SESSION_MATCH_QUERY_MID_SIZE_UNWEIGHTED = 7;

            //FFFF008B has a superset of these properties
/*
            public const uint PROPERTY_INT32PROP=0x10000001;
            public const uint PROPERTY_INT64PROP=0x20000002;
            public const uint PROPERTY_FLOAT32PROP=0x50000003;
            public const uint PROPERTY_FLOAT64PROP=0x30000004;
            public const uint PROPERTY_DATETIMEPROP=0x70000005;
*/
            public const uint PROPERTY_MYFLOAT32PROP1=0x50000003;
            public const uint PROPERTY_RANK=0x10008001;
//            public const uint PROPERTY_GAMERNAME=0x40000002;  //what is this?
            public const uint PROPERTY_MYINT32PROP2=0x1000000D;
            public const uint PROPERTY_MYFLOAT32PROP2=0x5000000E;
            public const uint PROPERTY_MYFLOAT64PROP2=0x3000000F;
            public const uint PROPERTY_MYINT64PROP2=0x20000010;
            public const uint PROPERTY_MYDATETIMEPROP2=0x70000011;
            public const uint PROPERTY_MYINT64PROP3=0x20000012;
            public const uint PROPERTY_MYINT64PROP4=0x20000013;
            public const uint PROPERTY_MYINT64PROP5=0x20000014;
            public const uint PROPERTY_MYINT64PROP6=0x20000015;
            public const uint PROPERTY_MYINT64PROP7=0x20000016;
            public const uint PROPERTY_MYINT64PROP8=0x20000017;
            public const uint PROPERTY_MYINT64PROP9=0x20000018;
            public const uint PROPERTY_MYINT64PROP10=0x20000019;
            public const uint PROPERTY_MYINT64PROP11=0x2000001A;
            public const uint PROPERTY_MYINT64PROP12=0x2000001B;
            public const uint PROPERTY_MYINT64PROP13=0x2000001C;
            public const uint PROPERTY_MYINT64PROP14=0x2000001D;
            public const uint PROPERTY_MYINT64PROP15=0x2000001E;
            public const uint PROPERTY_MYINT64PROP16=0x2000001F;
            public const uint PROPERTY_MYINT64PROP17=0x20000020;
            public const uint PROPERTY_MYINT64PROP18=0x20000021;
            public const uint PROPERTY_MYINT64PROP19=0x20000022;
            public const uint PROPERTY_MYINT64PROP20=0x20000023;
            public const uint PROPERTY_MYINT64PROP21=0x20000024;
            public const uint PROPERTY_MYINT64PROP22=0x20000025;
            public const uint PROPERTY_MYINT64PROP23=0x20000026;
            public const uint PROPERTY_MYINT64PROP24=0x20000027;
            public const uint PROPERTY_MYINT64PROP25=0x20000028;
            public const uint PROPERTY_MYINT64PROP26=0x20000029;
            public const uint PROPERTY_MYINT64PROP27=0x2000002A;
            public const uint PROPERTY_MYINT64PROP28=0x2000002B;
            public const uint PROPERTY_MYINT64PROP29=0x2000002C;
            public const uint PROPERTY_MYINT64PROP30=0x2000002D;
            public const uint PROPERTY_MYINT64PROP31=0x2000002E;
            public const uint PROPERTY_MYINT64PROP32=0x2000002F;
            public const uint PROPERTY_MYINT64PROP33=0x20000030;
            public const uint PROPERTY_MYINT64PROP34=0x20000031;
            public const uint PROPERTY_MYINT64PROP35=0x20000032;
            public const uint PROPERTY_MYINT64PROP36=0x20000033;
            public const uint PROPERTY_MYINT64PROP37=0x20000034;
            public const uint PROPERTY_MYINT64PROP38=0x20000035;
            public const uint PROPERTY_MYINT64PROP39=0x20000036;
            public const uint PROPERTY_MYINT64PROP40=0x20000037;
            public const uint PROPERTY_MYINT64PROP41=0x20000038;
            public const uint PROPERTY_MYINT64PROP42=0x20000039;
            public const uint PROPERTY_MYINT64PROP43=0x2000003A;
            public const uint PROPERTY_MYINT64PROP44=0x2000003B;
            public const uint PROPERTY_MYINT64PROP45=0x2000003C;
            public const uint PROPERTY_MYINT64PROP46=0x2000003D;
            public const uint PROPERTY_MYINT64PROP47=0x2000003E;
            public const uint PROPERTY_ZONE=0x10008101;
            public const uint PROPERTY_COUNTRY=0x10008102;
            public const uint PROPERTY_LANGUAGE=0x10008103;
            public const uint PROPERTY_RATING=0x50008104;
            public const uint PROPERTY_MU=0x30008105;
            public const uint PROPERTY_SIGMA=0x30008106;
            public const uint PROPERTY_GAMERPUID=0x20008107;

	}

    public class UserTypeInfo
    {
        public int Count;
        public byte Zone;
        public byte Country;
        public byte Language;

        public void FromString(string str)
        {
            string []elements = str.Split(',');
            if(4 != elements.Length)
            {
                throw new Exception(
                        String.Format("String value: '{0}' does not contain enough elemnts to parse UserTypeInfo", str)
                        );
            }

            Count       = Int32.Parse(elements[0]);
            Zone        = Byte.Parse(elements[1]);
            Country     = Byte.Parse(elements[2]);
            Language    = Byte.Parse(elements[3]);
        }
    }

    public class RatingInfo
    {
        public int Count;
        public float RatingBucket;

        public void FromString(string str)
        {
            string []elements = str.Split(',');
            if(2 != elements.Length)
            {
                throw new Exception(
                        String.Format("String value: '{0}' does not contain enough elemnts to parse RatingInfo", str)
                        );
            }

            Count           = Int32.Parse(elements[0]);
            RatingBucket    = Single.Parse(elements[1]);
        }
    }

    public class Stress2Helpers
    {
        private static List<UserTypeInfo> UserTypes = new List<UserTypeInfo>();
        private static int UserTypesSum;
        private static List<RatingInfo>  Ratings = new List<RatingInfo>();
        private static int RatingsSum;

        public static void LoadConfigs(string userTypeInfo, string ratingInfo)
        {
            StreamReader reader;
            string line;

            UserTypes.Clear();
            UserTypesSum = 0;
            Ratings.Clear();
            RatingsSum = 0;

            reader = File.OpenText(userTypeInfo);
            while(null != (line = reader.ReadLine()))
            {
                UserTypeInfo info = new UserTypeInfo();
                info.FromString(line);
                UserTypes.Add(info);
                UserTypesSum += info.Count;
            }
            
            reader = File.OpenText(ratingInfo);
            while(null != (line = reader.ReadLine()))
            {
                RatingInfo info = new RatingInfo();
                info.FromString(line);
                Ratings.Add(info);
                RatingsSum += info.Count;
            }

            if(0 == UserTypes.Count || 0 == Ratings.Count)
            {
                throw new Exception(
                            String.Format("Failed to load enough user types ({0}) or ratings ({1})",
                            UserTypes.Count,
                            Ratings.Count)
                        );
            }
        }

        //refactoring this out of the stress cases.  This will return whatever title and associated
        //queue that stress things should be hit with a request next.
        public static void GetRandomTitleAndQ(out uint titleID, out Queue sessQ) {            
            int titleIndex;
            int maxTitleNum = Stress2Params.StressTitles.Length - 1;
            if (Stress2Params.mode.Equals("SINGLE_TITLE_TESTING")) {
                titleIndex = maxTitleNum;  //always pick the "popular" title.
            } else { //multi-title testing.  Not really used nowadays.  Give a higher chance of being
                     //the hit title.
                titleIndex = RandomEx.GlobalRandGen.Next(0, ((maxTitleNum) * 2) - 1);
                if (titleIndex > maxTitleNum)
                {
                    titleIndex = maxTitleNum;
                }
            }
            titleID = Stress2Params.StressTitles[titleIndex];
            sessQ = Stress2Params.SessionQs[titleIndex];
        }

        //Return just the first session queue
        public static void GetSingleTitleAndQ(out uint titleID, out Queue sessQ) {            
            titleID = Stress2Params.StressTitles[0];
            sessQ = Stress2Params.SessionQs[0];
        }

        public static UserTypeInfo GetRandomUserType()
        {
            UserTypeInfo userType = null;

            // Didn't load the data, fallback
            if(0 == UserTypes.Count)
            {
                userType = new UserTypeInfo();
                userType.Zone = (byte)RandomEx.GlobalRandGen.Next(1, 5);
                userType.Country = (byte)RandomEx.GlobalRandGen.Next(1, 20);
                userType.Language = (byte)RandomEx.GlobalRandGen.Next(1, 20);

                return userType;
            }

            int select = RandomEx.GlobalRandGen.Next(UserTypesSum);

            foreach(UserTypeInfo i in UserTypes)
            {
                select -= i.Count;
                if(select <= 0)
                {
                    userType = i;
                    break;
                }
            }

            if(null == userType)
            {
                userType = UserTypes[UserTypes.Count-1];
            }

            return userType;
        }

        public static RatingInfo GetRandomRating()
        {
            RatingInfo rating = null;

            // Didn't load the data, fallback
            if(0 == Ratings.Count)
            {
                rating = new RatingInfo();
                rating.RatingBucket = (float)(RandomEx.GlobalRandGen.NextDouble() * 100);

                return rating;
            }

            int select = RandomEx.GlobalRandGen.Next(RatingsSum);

            foreach(RatingInfo i in Ratings)
            {
                select -= i.Count;
                if(select <= 0)
                {
                    rating = i;
                    break;
                }
            }
            
            if(null == rating)
            {
                rating = Ratings[Ratings.Count-1];
            }

            return rating;
        }

        //Adds randomized system attributes into a passed in array.  We don't add it to the
        //XRLCreate here because it would be somewhat slower.  Files in 9 attributes, starting at
        //the offset.  Supplies a random user type if none is specified.
        static public void FillSystemAttributes(bool ranked, XRLXeAttribParam[] attribsToFill, int offset) {
            FillSystemAttributes(ranked, attribsToFill, offset, GetRandomUserType());
        }

        static public void FillSystemAttributes(bool ranked, XRLXeAttribParam[] attribsToFill, int offset, UserTypeInfo userType) {
            RatingInfo rating = GetRandomRating();
            long gamerPUID = (long)RandomEx.GlobalRandGen.Next();
            double gamerMu = RandomEx.GlobalRandGen.NextDouble() * 6;  //any value between 0 and 6.
            double gamerSigma = RandomEx.GlobalRandGen.NextDouble(); // double between 0 and 1.0
            string hostName = "abc\0";

            if (ranked)
            {
                attribsToFill[0 + offset] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE, 
                                                                 new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED));
            }
            else
            {
                attribsToFill[0 + offset] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE, 
                                                                 new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
            }
            if (RandomEx.GlobalRandGen.Next(0, 2) == 0)
            {
                attribsToFill[1 + offset] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
            }
            else
            {
                attribsToFill[1 + offset] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEB));
            }
            attribsToFill[2 + offset] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE, new XRLXeIntValue(userType.Zone));
            attribsToFill[3 + offset] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(userType.Country));
            attribsToFill[4 + offset] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE, new XRLXeIntValue(userType.Language));
            attribsToFill[5 + offset] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(rating.RatingBucket));
            attribsToFill[6 + offset] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU, new XRLXeDoubleValue(gamerMu));
            attribsToFill[7 + offset] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(gamerSigma));
            attribsToFill[8 + offset] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_HOST_NAME, new XRLXeStringValue(hostName));            
        }
        
        //Fill attributes based on a random index into a set of arrays.  Fills in 5 attribs,
        //starting at the offset.
        static public void FillRandomIndexAttributes(bool ranked, XRLXeAttribParam[] attribsToFill, int offset) {
            int randomIndex = RandomEx.GlobalRandGen.Next(0, 4);
            long dateTimeValue = Stress2Params.dateTimeValueArray[randomIndex];
            long int32Value = Stress2Params.int32ValueArray[randomIndex];
            long int64Value = Stress2Params.int64ValueArray[randomIndex];
            float fValue = Stress2Params.float32ValueArray[randomIndex];
            double dValue = Stress2Params.float64ValueArray[randomIndex];

            attribsToFill[0 + offset] = new XRLXeAttribParam(Stress2Params.PROPERTY_DATETIMEPROP, new XRLXeDateTimeValue(dateTimeValue));
            attribsToFill[1 + offset] = new XRLXeAttribParam(Stress2Params.PROPERTY_FLOAT32PROP, new XRLXeFloatValue(fValue));
            attribsToFill[2 + offset] = new XRLXeAttribParam(Stress2Params.PROPERTY_FLOAT64PROP, new XRLXeDoubleValue(dValue));
            attribsToFill[3 + offset] = new XRLXeAttribParam(Stress2Params.PROPERTY_INT32PROP, new XRLXeIntValue(int32Value));
            attribsToFill[4 + offset] = new XRLXeAttribParam(Stress2Params.PROPERTY_INT64PROP, new XRLXeFloatValue(int64Value));
        }

        static public XRL2CreateUpdateSession GetRandomXRL2Create(bool ranked, uint titleID, 
                                                                  Queue sessQ, out SGADDR sgAddr) {
            //If we have a custom schema, use it.
            if (Stress2Params.customTitleSchema != null) {
                return Stress2Params.customTitleSchema.GetCreate(ranked, titleID, sessQ, out sgAddr);
            }
            if (Stress2Params.complexTitleSchema) {
                return Stress2Helpers.GetRandomXRL2CreateViaTemplate(ranked, titleID, sessQ, out sgAddr, 
                                                                     Stress2Params.sessionTemplateComplex);
            } else {
                return Stress2Helpers.GetRandomXRL2CreateNormal(ranked, titleID, sessQ, out sgAddr);
            }            
        }

        static public XRL2CreateUpdateSession GetRandomXRL2CreateNormal(bool ranked, uint titleID, 
                                                                        Queue sessQ, out SGADDR sgAddr)
        {
            XRLXeAttribParam[] Attribs = new XRLXeAttribParam[15];
            FillSystemAttributes(ranked, Attribs, 0);
            FillRandomIndexAttributes(ranked, Attribs, 9);

            if (RandomEx.GlobalRandGen.Next(0, 2) == 0)
            {
                Attribs[14] = new XRLXeAttribParam(Stress2Params.CONTEXT_MYCONTEXT, new XRLXeIntValue(Stress2Params.CONTEXT_MYCONTEXT_MYCONTEXTVALUE1));
            }
            else
            {
                Attribs[14] = new XRLXeAttribParam(Stress2Params.CONTEXT_MYCONTEXT, new XRLXeIntValue(Stress2Params.CONTEXT_MYCONTEXT_MYCONTEXTVALUE2));
            }

            sgAddr = new SGADDR();
            XRL2CreateUpdateSession createReq = new XRL2CreateUpdateSession(Attribs);
            createReq.baseCreateUpdate.baseSession.dwTitleID = titleID;
            sgAddr.CopyTo(createReq.baseCreateUpdate.baseSession.HostAddress.abOnline);

            return createReq;
        }

        //Use a template of attribs, which contain the maximum allowed value for the attribute.
        //Randomize each one, and return a new create with these as the parameters.
        public static XRL2CreateUpdateSession GetRandomXRL2CreateViaTemplate (bool ranked, uint titleID, 
                                                                             Queue sessQ, out SGADDR sgAddr,
                                                                             XRLXeAttribParam [] template) {
            const int NUM_SYSTEM_ATTRIBS = 9;
            XRLXeAttribParam [] randomAtts = new XRLXeAttribParam[template.Length + NUM_SYSTEM_ATTRIBS];

            //initialize the randomAtts array to look like the template.
            FillSystemAttributes(ranked, randomAtts, 0);

            for (int i=0; i<template.Length; i++) {
                randomAtts[i + NUM_SYSTEM_ATTRIBS] = (XRLXeAttribParam) template[i].DeepClone();
            }
            for (int j=0; j<template.Length; j++) {
                if (randomAtts[j+ NUM_SYSTEM_ATTRIBS].aValue is XRLXeDateTimeValue) {
                    int randomIndex = RandomEx.GlobalRandGen.Next(0, 4);
                    long dateTimeValue = Stress2Params.dateTimeValueArray[randomIndex];
                    randomAtts[j+ NUM_SYSTEM_ATTRIBS].aValue = new XRLXeDateTimeValue(dateTimeValue);
                } else {
                    randomAtts[j + NUM_SYSTEM_ATTRIBS].aValue.SetNumericValue(RandomEx.GlobalRandGen.NextDouble() * 
                                                                              template[j].aValue.GetNumericValue());
                }
            }
            sgAddr = new SGADDR();
            XRL2CreateUpdateSession createReq = new XRL2CreateUpdateSession(randomAtts);
            createReq.baseCreateUpdate.baseSession.dwTitleID = titleID;
            sgAddr.CopyTo(createReq.baseCreateUpdate.baseSession.HostAddress.abOnline);

            return createReq;
        }

        //create attributes for a split request.
        static public XRLXeAttribParam[] GetRandomAttribs(bool ranked)
        {
            XRLXeAttribParam[] Attribs = new XRLXeAttribParam[15];

            UserTypeInfo userType = Stress2Helpers.GetRandomUserType();
            FillSystemAttributes(ranked, Attribs, 0, userType);
            FillRandomIndexAttributes(ranked, Attribs, 9);

            //overwrite attributes that are user type specific.
            if (userType.Zone % 2 == 0)
            {
                Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                Attribs[14] = new XRLXeAttribParam(Stress2Params.CONTEXT_MYCONTEXT, new XRLXeIntValue(Stress2Params.CONTEXT_MYCONTEXT_MYCONTEXTVALUE1));
            }
            else
            {
                Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEB));
                Attribs[14] = new XRLXeAttribParam(Stress2Params.CONTEXT_MYCONTEXT, new XRLXeIntValue(Stress2Params.CONTEXT_MYCONTEXT_MYCONTEXTVALUE2));
            }


            return Attribs;
        }
    }

	public class SessIDAndSgAddr
	{
		public byte []	SessID = new byte[8];
		public SGADDR	SgAddr = new SGADDR();
		public bool		ranked = false;

		public SessIDAndSgAddr(byte [] id, SGADDR addr, bool rank)
		{
			Array.Copy(id,SessID,8);
			//SgAddr.abReserved = new byte[4]{0,0,0,0};
			SgAddr.dwSpiSg = addr.dwSpiSg;
			SgAddr.qwXboxID = addr.qwXboxID;
			Array.Copy(addr.inaSg,SgAddr.inaSg,4);
			ranked = rank;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xmatchtest_none_12.4.56.0_none_e31b358ffecdb102
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xmatchtest_no-public-key_12.4.56.0_x-ww_d93a8382
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xmatchtest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xmatchtest_no-public-key_12.4.56.0_x-ww_d93a8382
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xmatchtest_no-public-key_12.4.56.0_x-ww_d93a8382.manifest
XP_MANIFEST_PATH=manifests\msil_xmatchtest_no-public-key_12.4.56.0_x-ww_d93a8382.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xmatchtest_no-public-key_12.4.56.0_x-ww_d93a8382.cat
XP_CATALOG_PATH=manifests\msil_xmatchtest_no-public-key_12.4.56.0_x-ww_d93a8382.cat
XP_PAYLOAD_PATH=msil_xmatchtest_no-public-key_12.4.56.0_x-ww_d93a8382
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xmatchtest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\XPresListener.cs ===
using System;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Matchmaking;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.Utilities;


namespace XMatchTest
{
    /// <summary>
    /// XPresListener: is a presence server emulator that accepts queryAffiliate requests from match front door
    /// </summary>
    public sealed class XPresListener : XHttpListenerIOCP
    {
        object TitleResponsesLock = new object();
        volatile byte[][] TitleResponses = new byte[10][];
        volatile DateTime[] TitleResponsesChanged = new DateTime[10];
        const int REFRESH_TIME_SECS = 30;

        public XPresListener(int listenPort, int delay, int maxConn)
            : base(listenPort, delay, maxConn)
        {
            for (int i = 0; i < 10; i++)
            {
                TitleResponsesChanged[i] = DateTime.Now;
            }
        }

        public override bool ProcessData(byte[] bytes, int bundleIndex, int contentLength, out byte[] resp)
        {
            // get titleID from queryAffiliate request
            uint titleID = 0;
            /*
             *	public class PNMsgHdr : WireData
                {
                    public uint   MsgType; // Unique Msg ID: PMSG_xxx, QMSG_xxx, or MSGTYPE_ACK
                    public uint   MsgLen;  // Amount of data in message following this header
                    public uint   SeqNum;  // Distinguishes individual messages within a session (incremented by client)
                    public SGADDR Sgaddr;  // Unique session identifier (Set up by SG when client connects)
                }	// size is 32.
                public class PQueryAffiliatesMsgData : PNMsgData
                {

                    public ulong            qwSenderID;
                    public uint             dwListFlags;
                    public uint             cdwLimit;
                    public uint             dwOnlineTitleID;
                }
             */
            byte[] data = new byte[contentLength];
            Array.Copy(bytes, bundleIndex + 32, data, 0, contentLength - 32);	// skip PNMsgHdr,only read PQueryAffiliatesMsgData
            PQueryAffiliatesMsgData msgBody = (PQueryAffiliatesMsgData)new PQueryAffiliatesMsgData().ReadBytes(data);

            titleID = msgBody.dwOnlineTitleID;
            int titleIndex = -1;

            for (int i = 0; i < 10; i++)
            {
                if (titleID == Stress2Params.StressTitles[i])
                {
                    titleIndex = i;
                    break;
                }
            }
            if (titleIndex == -1)
            {
                Global.RO.Error("XPresListener::ProcessData: Unknown title ID {0}", titleID);
                resp = null;
                return (false);
            }

            lock (TitleResponsesLock)
            {
                if (TitleResponses[titleIndex] == null || (DateTime.Now - TitleResponsesChanged[titleIndex]).TotalSeconds >= REFRESH_TIME_SECS)
                {

                    /**********************************************************************************************
                         * send PNMsgHdr and PNMsgData back to matchfd
                         **********************************************************************************************/
                    uint affListSize = 120;
                    uint numFriend = (uint)(affListSize * Stress2Params.friendRatio / 100), 
                        numPositive = (uint)(affListSize * Stress2Params.posRatio / 100);
                    uint numComplete = (uint)(affListSize * Stress2Params.compRatio / 100), 
                        numNegative = (uint)(affListSize * Stress2Params.negRatio / 100);

                    long affSessionID = 0;

                    MemoryStream stream = new MemoryStream();
                    BinaryWriter writer = new BinaryWriter(stream);

                    /*
                        PNMsgHdr						affHeader = new PNMsgHdr();
                        affHeader.MsgLen = 0;
                        affHeader.MsgType = 0;
                        affHeader.SeqNum = 0;
                        affHeader.Sgaddr = new ServerTestFramework.LiveService.PresNotiCommon.SGADDR();
                        */
                    writer.Write((uint)0); // MsgLen
                    writer.Write((uint)0); // MsgType
                    writer.Write((uint)0); // SeqNum
                    byte[] sgaddr = new byte[20];
                    writer.Write(sgaddr); // sgaddr

                    /*
                        PQueryAffiliatesReplyMsgData	affList = new PQueryAffiliatesReplyMsgData();
                        affList.hr = HResult.S_OK;
                        affList.cdwResults = affListSize;
                        affList.rgResults = new QueryAffiliatesReplyData[affListSize];
                        */
                    writer.Write((uint)HResult.S_OK); // hr
                    writer.Write(affListSize);

                    byte[] fakeGamerTag = new byte[16];
                    SessIDAndSgAddr hostInfo = null;
                    for (int i = 0; i < affListSize; i++)
                    {
                        try
                        {
                            hostInfo = (SessIDAndSgAddr)Stress2Params.SessionQs[titleIndex].Dequeue();
                            byte[] sessID = (byte[])hostInfo.SessID;
                            affSessionID = Constants.sessionIDConvert(sessID);
                        }
                        catch (InvalidOperationException)
                        {	// sessQ is empty
                            StressParams.Safetw.WriteLine(DateTime.Now.ToString() + ":XPresListener: sessQ is empty.");
                            affSessionID = 0;
                        }
                        if (affSessionID != 0)
                            Stress2Params.SessionQs[titleIndex].Enqueue(hostInfo);

                        //affList.rgResults[i].qwAffiliateID = 8888;
                        writer.Write((ulong)8888);

                        //affList.rgResults[i] = new QueryAffiliatesReplyData();
                        uint dwListFlags = 0;
                        if (i < numFriend)
                            dwListFlags = (uint)AffiliateFlags.Friend;
                        else if (i < (numFriend + numPositive))
                            dwListFlags = (uint)AffiliateFlags.PositiveFeedback;
                        else if (i < (numFriend + numPositive + numComplete))
                            dwListFlags = (uint)AffiliateFlags.CompletedGame;
                        else if (i < (numFriend + numPositive + numComplete + numNegative))
                            dwListFlags = (uint)AffiliateFlags.NegativeFeedback;
                        else
                            dwListFlags = (uint)AffiliateFlags.AvoidingMe;
                        writer.Write(dwListFlags);

                        //affList.rgResults[i].dwTitleID = 8888;	
                        writer.Write((uint)8888);

                        //affList.rgResults[i].qwSessionID = (ulong)affSessionID;
                        writer.Write((ulong)affSessionID);

                        //affList.rgResults[i].mtDateUpdated = 8888;
                        writer.Write((uint)8888);

                        // affList.rgResults[i].szGamerTag = "don't matter";
                        writer.Write(fakeGamerTag);
                    }
                    TitleResponses[titleIndex] = stream.GetBuffer();
                }
                // copy PNMsgHdr and PQueryAffiliatesReplyMsgData back to the http body response
                //byte	[]	msgHeader = (byte [])affHeader;
                //byte	[]	msgData = (byte [])affList;
                //int	msgHeaderLen = msgHeader.Length,msgDataLen = msgData.Length;
                //resp = new byte[msgHeaderLen+msgDataLen];
                //Array.Copy(msgHeader,0,resp,0,msgHeaderLen);
                //Array.Copy(msgData,0,resp,msgHeader.Length,msgDataLen);
                resp = TitleResponses[titleIndex];
            }
            return (true);
        }

        public bool ORIGINAL_ProcessData(byte[] bytes, int bundleIndex, int contentLength, out byte[] resp)
        {
            uint affListSize = 120;
            uint numFriend = (uint)(affListSize * Stress2Params.friendRatio / 100), numPositive = (uint)(affListSize * Stress2Params.posRatio / 100);
            uint numComplete = (uint)(affListSize * Stress2Params.compRatio / 100), numNegative = (uint)(affListSize * Stress2Params.negRatio / 100);
            long affSessionID = 0;

            // get titleID from queryAffiliate request
            uint titleID = 0;
            /*
             *	public class PNMsgHdr : WireData
                {
                    public uint   MsgType; // Unique Msg ID: PMSG_xxx, QMSG_xxx, or MSGTYPE_ACK
                    public uint   MsgLen;  // Amount of data in message following this header
                    public uint   SeqNum;  // Distinguishes individual messages within a session (incremented by client)
                    public SGADDR Sgaddr;  // Unique session identifier (Set up by SG when client connects)
                }	// size is 32.
                public class PQueryAffiliatesMsgData : PNMsgData
                {

                    public ulong            qwSenderID;
                    public uint             dwListFlags;
                    public uint             cdwLimit;
                    public uint             dwOnlineTitleID;
                }
             */
            byte[] data = new byte[contentLength];
            Array.Copy(bytes, bundleIndex + 32, data, 0, contentLength - 32);	// skip PNMsgHdr,only read PQueryAffiliatesMsgData
            PQueryAffiliatesMsgData msgBody = (PQueryAffiliatesMsgData)new PQueryAffiliatesMsgData().ReadBytes(data);

            titleID = msgBody.dwOnlineTitleID;
            int titleIndex = 0;

            for (int i = 0; i < 10; i++)
            {
                if (titleID == Stress2Params.StressTitles[i])
                {
                    titleIndex = i;
                    break;
                }
            }
            byte[] sessID = null;

            /**********************************************************************************************
             * send PNMsgHdr and PNMsgData back to matchfd
             **********************************************************************************************/
            MemoryStream stream = new MemoryStream();
            BinaryWriter writer = new BinaryWriter(stream);

            /*
			PNMsgHdr						affHeader = new PNMsgHdr();
			affHeader.MsgLen = 0;
			affHeader.MsgType = 0;
			affHeader.SeqNum = 0;
			affHeader.Sgaddr = new ServerTestFramework.LiveService.PresNotiCommon.SGADDR();
            */
            writer.Write((uint)0); // MsgLen
            writer.Write((uint)0); // MsgType
            writer.Write((uint)0); // SeqNum
            byte[] sgaddr = new byte[20];
            writer.Write(sgaddr); // sgaddr

            /*
			PQueryAffiliatesReplyMsgData	affList = new PQueryAffiliatesReplyMsgData();
			affList.hr = HResult.S_OK;
			affList.cdwResults = affListSize;
			affList.rgResults = new QueryAffiliatesReplyData[affListSize];
            */
            writer.Write((uint)HResult.S_OK); // hr
            writer.Write(affListSize);

            byte[] fakeGamerTag = new byte[16];
            SessIDAndSgAddr hostInfo = null;
            for (int i = 0; i < affListSize; i++)
            {
                try
                {
                    hostInfo = (SessIDAndSgAddr)Stress2Params.SessionQs[titleIndex].Dequeue();
                    sessID = (byte[])hostInfo.SessID;
                    affSessionID = Constants.sessionIDConvert(sessID);
                }
                catch (InvalidOperationException)
                {	// sessQ is empty
                    StressParams.Safetw.WriteLine(DateTime.Now.ToString() + ":XPresListener: sessQ is empty.");
                    affSessionID = 0;
                }
                if (affSessionID != 0)
                    Stress2Params.SessionQs[titleIndex].Enqueue(hostInfo);

                //affList.rgResults[i].qwAffiliateID = 8888;
                writer.Write((ulong)8888);

                //affList.rgResults[i] = new QueryAffiliatesReplyData();
                uint dwListFlags = 0;
                if (i < numFriend)
                    dwListFlags = (uint)AffiliateFlags.Friend;
                else if (i < (numFriend + numPositive))
                    dwListFlags = (uint)AffiliateFlags.PositiveFeedback;
                else if (i < (numFriend + numPositive + numComplete))
                    dwListFlags = (uint)AffiliateFlags.CompletedGame;
                else if (i < (numFriend + numPositive + numComplete + numNegative))
                    dwListFlags = (uint)AffiliateFlags.NegativeFeedback;
                else
                    dwListFlags = (uint)AffiliateFlags.AvoidingMe;
                writer.Write(dwListFlags);

                //affList.rgResults[i].dwTitleID = 8888;	
                writer.Write((uint)8888);

                //affList.rgResults[i].qwSessionID = (ulong)affSessionID;
                writer.Write((ulong)affSessionID);

                //affList.rgResults[i].mtDateUpdated = 8888;
                writer.Write((uint)8888);

                // affList.rgResults[i].szGamerTag = "don't matter";
                writer.Write(fakeGamerTag);
            }

            // copy PNMsgHdr and PQueryAffiliatesReplyMsgData back to the http body response
            //byte	[]	msgHeader = (byte [])affHeader;
            //byte	[]	msgData = (byte [])affList;
            //int	msgHeaderLen = msgHeader.Length,msgDataLen = msgData.Length;
            //resp = new byte[msgHeaderLen+msgDataLen];
            //Array.Copy(msgHeader,0,resp,0,msgHeaderLen);
            //Array.Copy(msgData,0,resp,msgHeader.Length,msgDataLen);
            resp = stream.GetBuffer();
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xmatchtest_none_12.4.56.0_none_e31b358ffecdb102
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xmatchtest_no-public-key_12.4.56.0_x-ww_d93a8382
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xmatchtest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xmatchtest_no-public-key_12.4.56.0_x-ww_d93a8382
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xmatchtest_no-public-key_12.4.56.0_x-ww_d93a8382.manifest
XP_MANIFEST_PATH=manifests\msil_xmatchtest_no-public-key_12.4.56.0_x-ww_d93a8382.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xmatchtest_no-public-key_12.4.56.0_x-ww_d93a8382.cat
XP_CATALOG_PATH=manifests\msil_xmatchtest_no-public-key_12.4.56.0_x-ww_d93a8382.cat
XP_PAYLOAD_PATH=msil_xmatchtest_no-public-key_12.4.56.0_x-ww_d93a8382
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xmatchtest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\xmgmt\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\xmgmt\Exec.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;

namespace XmgmtServerTest
{
    [TestGroup]
    public class Exec
    {
        [TestCase, Description("Does a blank exec command.")]
        public void NoParams()
        {
            string ret=Util.RunCommandVerbose("kdcsvc", "e");
            ret=ret.Replace("\r", "");
            string []lines=ret.Split(new char[]{'\n'}, System.StringSplitOptions.RemoveEmptyEntries);

            if (lines.Length!=1)
            {
                throw new UnexpectedTestResultException("Expected exactly 1 lines as a response.");
            }

            ValueCheck.Test("1st line", "No command.", lines[0]);
        }

        [TestCase, Description("Runs a command against a specfic component name.")]
        public void ComponentOnly()
        {
            string ret=Util.RunCommandVerbose("kdcsvc", "e :xmacs QueryBlackBox BlackBoxIsHalfFullNotHalfEmpty");
            ret=ret.Replace("\r", "");
            string []lines=ret.Split(new char[]{'\n'}, System.StringSplitOptions.RemoveEmptyEntries);

            if (lines.Length!=1)
            {
                throw new UnexpectedTestResultException("Expected exactly 1 lines as a response.");
            }

            ValueCheck.Test("Response", "name: 'BlackBoxIsHalfFullNotHalfEmpty' not found.", lines[0]);
        }

        [TestCase, Description("Runs a command against a specfic component name and interface name.")]
        public void InterfaceAndComponent()
        {
            string ret=Util.RunCommandVerbose("kdcsvc", "e kdcsvc:xmacs QueryBlackBox BlackBoxIsHalfFullNotHalfEmpty");
            ret=ret.Replace("\r", "");
            string []lines=ret.Split(new char[]{'\n'}, System.StringSplitOptions.RemoveEmptyEntries);

            if (lines.Length!=1)
            {
                throw new UnexpectedTestResultException("Expected exactly 1 lines as a response.");
            }

            ValueCheck.Test("Response", "name: 'BlackBoxIsHalfFullNotHalfEmpty' not found.", lines[0]);
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\XMatchTest.cs ===
using System;
using System.Xml;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using System.Diagnostics;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Matchmaking;
using ServerTestFramework.LiveService.Auth;  //to prop titles
using ServerTestFramework.STFTools; //to prop titles
using System.Globalization; //to read hex #s
using xonline.common.config;
using xonline.common.mgmt;

[assembly: RootNode(typeof(XMatchTest.XMatchTest))]

namespace XMatchTest
{
    /// <summary>
    /// Summary description for Class1.
    /// </summary>
    [TestFrequency("Regression"), TestCasePriority(3), Owner("jeffng")]
    public class XMatchTest : TestNode
    {
        bool sessionsInitialized = false;

        public XMatchTest()
        {
            //functional
            AddChild(new Func2SearchPlatformProperty());
            AddChild(new ConfigDBTest());

            //stress
            foreach (System.Type t in GetStressTests())
            {
                TestNode n=TestNode.ConstructFromType(t);
                AddChild(n, false, true);
            }
        }

        public override void PreRun(RUN_TYPE runType)
        {
            if (runType == RUN_TYPE.FUNCTIONAL)
            {
                Initialize();
            }
            else if (runType == RUN_TYPE.STRESS)
            {
                InitializeStress();
            }
        }

        public override void PostRun(RUN_TYPE runType)
        {
            if (runType == RUN_TYPE.STRESS)
            {
                DeinitializeStress();
            }
        }

        /************************************************************************
         * These are for stress tests
         ************************************************************************/
        public void InitializeStress()
        {
            XmlDocument config = Global.Config;

            DateTime now = DateTime.Now;
            string nowText = now.Year.ToString() + "_" + now.Month.ToString() + "_" + now.Day.ToString() + "_" + 
                now.Hour.ToString() + "_" + now.Minute.ToString() + "_" + now.Second.ToString() + "_";
            StressParams.Safetw = TextWriter.Synchronized(File.CreateText("matchStress_" + nowText + ".err"));
/*  //might be able to get this working now, but comment out for the moment.
            string categoryName = "STFTests.Xmatch.Custom";
            string categoryHelp = "XmatchTests Category";
            string counterName = "NumberOfStandardSessions";

            CounterCreationDataCollection xmatchCounters = new CounterCreationDataCollection();

            // Add the counter.
            CounterCreationData numRankedSessions = new CounterCreationData();
            numRankedSessions.CounterType = PerformanceCounterType.NumberOfItems64;
            numRankedSessions.CounterName = "Number of Ranked Sessions";
            xmatchCounters.Add(numRankedSessions);


            if(!PerformanceCounterCategory.Exists(categoryName))
            {
                PerformanceCounterCategory.Create(categoryName, categoryHelp, PerformanceCounterCategoryType.SingleInstance,
                                                  xmatchCounters );
            }

            if(!PerformanceCounterCategory.CounterExists(counterName, categoryName))
            {
                //add a counter
            }
*/

            if (!sessionsInitialized) { //reuse existing sessions and initialization
                try
                {
                    Stress2Helpers.LoadConfigs("suites\\graw_user_types.csv", "suites\\graw_rating_dist.csv");
                }
                catch(Exception ex)
                {
                    StressParams.Safetw.WriteLine("Failed to load user types and ratings (using uniform dist): " + ex.ToString());
                }

                bool CreateOpenSessions = bool.Parse(
                    config.SelectSingleNode("/stf/config/stress/option[@name='CreateOpenSessions']").Attributes["value"].Value);
                
                Stress2Params.mode = config.SelectSingleNode("/stf/config/stress/option[@name='TestMode']").Attributes["value"].Value;
                
                
                if (Stress2Params.mode.Equals("MIGRATION_TESTING")) { //comprehensive stress, best for testing migration.
                    //reset StressParams titleids
                    uint migrationTitleID = ReadHexUIntFromConfig(config, "StressTitleOverride");
                    Stress2Params.StressTitles = new uint[1];
                    Stress2Params.StressTitles[0] = migrationTitleID;
                    Stress2Params.SessionQs = new Queue[1];
                    Stress2Params.SessionQs[0] = Queue.Synchronized(new Queue());

                    InitializeXbox360Settings(config);

                    if (CreateOpenSessions)
                    {
                        CreateMigrationTestSessions();
                    }                
                    SetTitleToDeferredDeletion(migrationTitleID, true);

                    //do a little something special for the round robined cases.
                    Stress2Params.RoundRobinSearchRetries = ReadUIntFromConfig(config, "RoundRobinSearchRetries");
                } else if (Stress2Params.mode.Equals("SINGLE_TITLE_TESTING")) { //perf stress, best
                                                                                //for one hit title
                                                                                //per stf instance.
                    uint stressTitleID = ReadHexUIntFromConfig(config, "StressTitleOverride");
                    Stress2Params.StressTitles = new uint[1];
                    Stress2Params.StressTitles[0] = stressTitleID;
                    Stress2Params.SessionQs = new Queue[1];
                    Stress2Params.SessionQs[0] = Queue.Synchronized(new Queue());

                    InitializeXbox360Settings(config);

                    if (CreateOpenSessions)
                    {
                        CreateXbox360Sessions();
                    }
                    SetTitleToDeferredDeletion(stressTitleID, true);
                } else if (Stress2Params.mode.Equals("DELAY_TESTING")) {
                    //initialize the settings, but don't do anything else.  The sql side is
                    //completely faked in cases like this.  One day we'll want to read from a file and
                    //load the kinds of stress cases to set up.
                    InitializeXbox360Settings(config);
                } else { //legacy stress
                    InitializeXbox360Settings(config);

                    if (CreateOpenSessions) {
                        CreateXbox1Sessions();
                        CreateXbox360LobbySessions();
                        CreateXbox360Sessions();
                        SetTitlesToDeferredDeletion();
                    }
                }
            }
            // start XPresence listener
            Stress2Params.presListener.Go();
            sessionsInitialized = true;
        }

        //do this a lot more simply than the big stress tests
        private void CreateMigrationTestSessions() {
            uint numOpenRankedSessions = Stress2Params.numOpenRankedSessionsForNonHit;
            uint numOpenSocialSessions = Stress2Params.numOpenSocialSessionsForNonHit;

            //assume that the override was set earlier in the initialize section
            uint title = Stress2Params.StressTitles[0];
            Queue session360Q = Stress2Params.SessionQs[0];

            Global.RO.Info("Pre-populating title 0x" + title.ToString("X") + " with " + numOpenRankedSessions + " ranked and " +
                           numOpenSocialSessions + " social sessions");
            //use normal session creation, unless one day we need to use jobs.
            for (int i=0; i< numOpenRankedSessions; i++) {
                SGADDR sgAddr;
                XRL2CreateUpdateSession createReq = Stress2Helpers.GetRandomXRL2Create(true, title, session360Q, out sgAddr);
                XRLSessionInfo createResp;
                if (createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out createResp)) {
                    session360Q.Enqueue(new MatchSession(title, createReq, createResp));
                } else {
                    Global.RO.Error("Error creating session on title 0x" + title.ToString("X"));
                }
            }
            //repeat creation for the standards
            for (int i=0; i< numOpenSocialSessions; i++) {
                SGADDR sgAddr;
                XRL2CreateUpdateSession createReq = Stress2Helpers.GetRandomXRL2Create(false, title, session360Q, out sgAddr);
                XRLSessionInfo createResp;
                if (createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out createResp)) {
                    session360Q.Enqueue(new MatchSession(title, createReq, createResp));
                } else {
                    Global.RO.Error("Error creating session on title 0x" + title.ToString("X"));
                }
            }

        }

        private void CreateXbox1Sessions() {
            // create 200 open sessions for every xbox1 titles; 4 clients
            for (uint i = 0; i < 50 * 2; i++)
            {
                Queue sessQ;

                XRLCreateUpdateSession createReq = new XRLCreateUpdateSession();
                XRLSessionInfo createResp;
                if (i < 50)
                {
                    createReq.baseSession.dwTitleID = StressParams.STRESS_TITLE_ID1;
                    sessQ = StressParams.sessionQ1;
                }
                else
                {
                    createReq.baseSession.dwTitleID = StressParams.STRESS_TITLE_ID2;
                    sessQ = StressParams.sessionQ2;
                }

                if (createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out createResp))
                {
                    sessQ.Enqueue(createResp.SessionID);
                }
                else
                {
                    StressParams.Safetw.WriteLine("Create Open session failed: " + createReq.XErr.ToString("x"));
                }
            }
        }

        public bool OptionInConfig(XmlDocument config, string name) {
            return config.SelectSingleNode("/stf/config/stress/option[@name='" + name + "']") != null;
        }

        public string ReadStringFromConfig(XmlDocument config, string name) {
            return config.SelectSingleNode("/stf/config/stress/option[@name='" + name + "']").Attributes["value"].Value;
        }
        public uint ReadUIntFromConfig(XmlDocument config, string name) {
            try {
                return UInt32.Parse(
                    config.SelectSingleNode("/stf/config/stress/option[@name='" + name + "']").Attributes["value"].Value);
            } catch (NullReferenceException) {
                Global.RO.Warn("Cannot read the configuration option " + name + " from the xml file!  Using 0 as default.");
                return 0;
            }
        }

        public uint ReadHexUIntFromConfig(XmlDocument config, string name) {
            try {
                return UInt32.Parse(
                    config.SelectSingleNode("/stf/config/stress/option[@name='" + name + "']").Attributes["value"].Value,
                    NumberStyles.HexNumber);
            } catch (NullReferenceException) {
                Global.RO.Warn("Cannot read the configuration option " + name + " from the xml file!  Using 0 as default.");
                return 0;
            }
        }

        public double ReadDoubleFromConfig(XmlDocument config, string name) {
            try {
                return Double.Parse(
                    config.SelectSingleNode("/stf/config/stress/option[@name='" + name + "']").Attributes["value"].Value);
            } catch (NullReferenceException) {
                Global.RO.Warn("Cannot read the configuration option " + name + " from the xml file!  Using 0 as default.");
                return 0;
            }
        }


        /**************************************************************************
         * The following settings are used by xbox360 stress tests only
         **************************************************************************/
        // all search parameters can be null, and the probability is configurable
        // it's value is out of 100. 
        // For example, value 10 shows that out of 100 search requests, 
        // 10 of the request has this search parameter set to null.
        private void InitializeXbox360Settings(XmlDocument config) {
            uint MYCONTEXT_nullProbability = ReadUIntFromConfig(config, "MYCONTEXT_nullProbability");
            uint INT32PROP_nullProbability = ReadUIntFromConfig(config, "INT32PROP_nullProbability");
            uint INT64PROP_nullProbability = ReadUIntFromConfig(config, "INT64PROP_nullProbability");
            uint FLOAT32PROP_nullProbability = ReadUIntFromConfig(config, "FLOAT32PROP_nullProbability");
            uint FLOAT64PROP_nullProbability = ReadUIntFromConfig(config, "FLOAT64PROP_nullProbability");
            uint DATETIMEPROP_nullProbability = ReadUIntFromConfig(config, "DATETIMEPROP_nullProbability");

            // initialize search parameter null probability array
            uint[]	myContextRandomGen = new uint[100];
            uint[]	int32PropRandomGen = new uint[100];
            uint[]	int64PropRandomGen = new uint[100];
            uint[]	float32PropRandomGen = new uint[100];
            uint[]	float64PropRandomGen = new uint[100];
            uint[]	dateTimePropRandomGen = new uint[100];

            RandomEx	randomGen = new RandomEx();
            int			index = 0;

            for(int i = 0; i < MYCONTEXT_nullProbability; i++)
            {
                index = randomGen.Next(0, 100);
                myContextRandomGen[index] = 1;	// do not pass value for myContext for this search request
            }
            for(int i = 0; i < INT32PROP_nullProbability; i++)
            {
                index = randomGen.Next(0, 100);
                int32PropRandomGen[index] = 1;	// do not pass value for int32Prop for this search request
            }
            for(int i = 0; i < INT64PROP_nullProbability; i++)
            {
                index = randomGen.Next(0, 100);
                int64PropRandomGen[index] = 1;	// do not pass value for int64Prop for this search request
            }
            for(int i = 0; i < FLOAT32PROP_nullProbability; i++)
            {
                index = randomGen.Next(0, 100);
                float32PropRandomGen[index] = 1;	// do not pass value for float32Prop for this search request
            }
            for(int i = 0; i < FLOAT64PROP_nullProbability; i++)
            {
                index = randomGen.Next(0, 100);
                float64PropRandomGen[index] = 1;	// do not pass value for float64Prop for this search request
            }
            for(int i = 0; i < DATETIMEPROP_nullProbability; i++)
            {
                index = randomGen.Next(0, 100);
                dateTimePropRandomGen[index] = 1;	// do not pass value for dateTime for this search request
            }
            Array.Copy(myContextRandomGen,Stress2Params.myContextParamValues,100);
            Array.Copy(int32PropRandomGen,Stress2Params.int32PropParamValues,100);
            Array.Copy(int64PropRandomGen,Stress2Params.int64PropParamValues,100);
            Array.Copy(float32PropRandomGen,Stress2Params.float32PropParamValues,100);
            Array.Copy(float64PropRandomGen,Stress2Params.float64PropParamValues,100);
            Array.Copy(dateTimePropRandomGen,Stress2Params.dateTimePropParamValues,100);

            Stress2Params.friendRatio = ReadUIntFromConfig(config, "FriendPercentage");
            Stress2Params.posRatio = ReadUIntFromConfig(config, "PositivePercentage");
            Stress2Params.compRatio = ReadUIntFromConfig(config, "CompletePercentage");
            Stress2Params.negRatio = ReadUIntFromConfig(config, "NegativePercentage");
            Stress2Params.avoidRatio = ReadUIntFromConfig(config, "AvoidMePercentage");

            Stress2Params.percentChanceOfChangingMode = ReadUIntFromConfig(config, "percentChanceOfChangingMode");
            Stress2Params.percentChanceOfClosingSession = ReadUIntFromConfig(config, "percentChanceOfClosingSession");

            //allow override of these variables.  Currently only used in ordinary stress tests.
            if (OptionInConfig(config, "percentChanceFullRankedSessionForHit")) {
                Stress2Params.percentChanceFullRankedSessionForHit = ReadDoubleFromConfig(config, "percentChanceFullRankedSessionForHit");
            }
            if (OptionInConfig(config, "percentChanceFullStandardSessionForHit")) {
                Stress2Params.percentChanceFullStandardSessionForHit = ReadDoubleFromConfig(config, "percentChanceFullStandardSessionForHit");
            }

            // Create open sessions for every xbox360 title
            Stress2Params.numOpenRankedSessionsForNonHit = ReadUIntFromConfig(config, "numOpenRankedSessionsForNonHit");
            Stress2Params.numOpenSocialSessionsForNonHit = ReadUIntFromConfig(config, "numOpenSocialSessionsForNonHit");
            Stress2Params.numOpenRankedSessionsForHit = ReadUIntFromConfig(config, "numOpenRankedSessionsForHit");
            Stress2Params.numOpenSocialSessionsForHit = ReadUIntFromConfig(config, "numOpenSocialSessionsForHit");

            // Create closed sessions.  This is Halo specific.
            if (OptionInConfig(config, "numLobbySessionsForHit")) {
                Stress2Params.numLobbySessionsForHit = ReadUIntFromConfig(config, "numLobbySessionsForHit");
            } else {
                Stress2Params.numLobbySessionsForHit = 0;
            }
            if (OptionInConfig(config, "sessionModeSettings")) {
                Stress2Params.sessionModeSettings = ReadStringFromConfig(config, "sessionModeSettings");
                if ( (!(Stress2Params.sessionModeSettings.Equals("LobbySessions"))) &&
                     !(Stress2Params.sessionModeSettings.Equals("Halo3Sessions")) &&
                     !(Stress2Params.sessionModeSettings.Equals("SingleModeSessions")) && 
                     !(Stress2Params.sessionModeSettings.Equals("ReachSessions"))  )
                    Global.RO.Error("Error!  Session mode setting has incorrect value!");
            }
            //complex title schema--meaning we use more attributes on creates and enable complex
            //weighted searches.  The XLAST must have the appropriate schema in it, however.
            if (OptionInConfig(config, "complexTitleSchema")) {
                Stress2Params.complexTitleSchema = bool.Parse(
                    config.SelectSingleNode("/stf/config/stress/option[@name='complexTitleSchema']").Attributes["value"].Value);
            }
            if (OptionInConfig(config, "customTitleSchema")) {
                if (Stress2Params.complexTitleSchema) {
                    Global.RO.Error("Error!  complexTitleSchema is specified when customTitleSchema is also specified in the xml!  " + 
                                    "Overriding with custom.");
                }
                Stress2Params.customTitleSchema = new ReachTitleSchema();
            }
        }

        private void SetTitlesToDeferredDeletion() {
            // Configure the Xbox 360 stress titles to use defered deletion
            foreach (uint titleId in Stress2Params.StressTitles)
            {
                SetTitleToDeferredDeletion(titleId, false);
            }
            MatchFDs.ReloadTitleInfo();
        }

        //like above, but for a single title.  Boolean controls whether you want to batch up all the
        //reloads outside this method.
        private void SetTitleToDeferredDeletion(uint titleID, bool reload) {
            try {
                MatchTitle matchTitle = MatchTitleMgr.SnapshotMatchTitle(titleID);
                matchTitle.DeleteDelaySeconds = 300;
                MatchTitleMgr.UpdateMatchTitle(matchTitle);
            }
            catch { }
            if (reload) { MatchFDs.ReloadTitleInfo(); }
        }
        
        //HALO 3 ONLY--there are a number of social sessions that are simply created but not used as
        //actual matches.  They allow joining but won't be searched except by ID.  Make this
        //threaded?  it's sloooow...

        private void CreateXbox360LobbySessions() {
            uint numLobbySessions = Stress2Params.numLobbySessionsForHit;

            //the hit title is number 9.  should refactor this some time...create a title class, for instance.
            uint title = Stress2Params.StressTitles[9];
            Queue session360Q = Stress2Params.SessionQs[9];

            Global.RO.Info("Pre-populating title 0x" + title.ToString("X") + " with " +
                           numLobbySessions + " social sessions that will never be used, or lobby sessions.");

            for (int i=0; i< numLobbySessions; i++) {
                SGADDR sgAddr;
                XRL2CreateUpdateSession createReq = Stress2Helpers.GetRandomXRL2Create(false, title, session360Q, out sgAddr);
                XRLSessionInfo createResp;
                createReq.baseCreateUpdate.baseSession.dwPublicOpen=0;  //they're always closed.
                if (createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out createResp)) {
                    //never queue--these last forever
//                    session360Q.Enqueue(new MatchSession(title, createReq, createResp));
                } else {
                    Global.RO.Error("Error creating session on title 0x" + title.ToString("X"));
                }
            }

        }
        private void CreateXbox360Sessions() {
            // Create the specified number of open sessions to start up stress with
            SimpleJobMgr jobs = new SimpleJobMgr();
            SimpleJobMgr.ExecutorDelegate csExector = new SimpleJobMgr.ExecutorDelegate(CreateSessionsExecutor);
            // Non-hit titles share the same number of ranked and social sessions between them
            uint numOpenRankedSessions = Stress2Params.numOpenRankedSessionsForNonHit;
            uint numOpenSocialSessions = Stress2Params.numOpenSocialSessionsForNonHit;
            for (int j = 0; j < Stress2Params.StressTitles.Length; j++)
            {
                uint title = Stress2Params.StressTitles[j];
                Queue session360Q = Stress2Params.SessionQs[j];

                // The last item in the array is the popular one.
                if (j == Stress2Params.StressTitles.Length - 1)
                {
                    numOpenRankedSessions = Stress2Params.numOpenRankedSessionsForHit;
                    numOpenSocialSessions = Stress2Params.numOpenSocialSessionsForHit;
                }
                
                
                
                Global.RO.Info("Pre-populating title 0x" + title.ToString("X") + " with " + numOpenRankedSessions + " ranked and " +
                               numOpenSocialSessions + " social sessions");
                uint rankedSessionsRemaining = numOpenRankedSessions;
                uint socialSessionsRemaining = numOpenSocialSessions;
                int sessionIdentifier = 0;

                //Randomly interleave ranked and standard matches, so that activity isn't
                //all-ranked, followed by all-standard.
                while ((rankedSessionsRemaining > 0) ||
                       (socialSessionsRemaining > 0)) {
                    int sessionToMake = RandomEx.GlobalRandGen.Next(0, (int) (rankedSessionsRemaining + socialSessionsRemaining));
                    if (sessionToMake < rankedSessionsRemaining) {
                        CreateSessionsParams csParams = new CreateSessionsParams(true, sessionIdentifier, title, session360Q);
                        jobs.AddJob(csExector, csParams);
                        rankedSessionsRemaining--;
                    } else {
                        CreateSessionsParams csParams = new CreateSessionsParams(false, sessionIdentifier, title, session360Q);
                        jobs.AddJob(csExector, csParams);
                        socialSessionsRemaining--;
                    }
                    sessionIdentifier++;
                }

            }
            jobs.StartJobs(StressParams.createThreadCount);
            while (!jobs.Empty())
            {
                SimpleJobMgr.Job job = jobs.GetCompletedJob();
                if (job.Exception != null)
                {
                    jobs.Abort();
                    //throw new UnexpectedTestResultException("A CreateSessions job failed: " +
                    //job.Exception.ToString(), job.Exception);
                    Global.RO.Error("A CreateSessions job failed: " + job.Exception.ToString(), job.Exception);
                }
            }
        }


        private class CreateSessionsParams
        {
            public bool Ranked;
            public int Iteration;
            public uint Title;
            public Queue Session360Q;

            public CreateSessionsParams(bool ranked, int iteration, uint title, Queue session360Q)
            {
                Ranked = ranked;
                Iteration = iteration;
                Title = title;
                Session360Q = session360Q;
            }
        }

        private void CreateSessionsExecutor(ref object Parameters)
        {
            CreateSessionsParams csParams = (CreateSessionsParams)Parameters;
            createSessions(csParams.Ranked, csParams.Title, csParams.Session360Q);
        }
        
        //During initialization, say some sessions will be closed.  Close these sessions if it hits
        //the percent chance in the xml(0 by default)
        public static void CloseSessionIfSelected(XRL2CreateUpdateSession createReq, bool ranked) {
            if (ranked) {
//                if (RandomEx.GlobalRandGen.Next(0,100) < Stress2Params.percentChanceFullRankedSessionForHit) {
                if ((RandomEx.GlobalRandGen.NextDouble() * 100) < Stress2Params.percentChanceFullRankedSessionForHit) {
                    createReq.baseCreateUpdate.baseSession.dwPublicOpen=0;
                }
            } else {
//                if (RandomEx.GlobalRandGen.Next(0,100) < Stress2Params.percentChanceFullStandardSessionForHit) {
                if ((RandomEx.GlobalRandGen.NextDouble() * 100) < Stress2Params.percentChanceFullStandardSessionForHit) {
                    createReq.baseCreateUpdate.baseSession.dwPublicOpen=0;
                }
            }
        }
        
        //These request types allow a generic kind of method to govern multiple stress calls, such
        //as what mode to move into, or what 
        public enum RequestType {
            CREATE2,
            UPDATE2,
            SEARCH2,
            DELETE2,
            SPLIT
        };
/*
        //if a queue is 1% larger than it should be, delete a session.  Call this to enforce
        //population control.
        public static bool ActionPermittedOnQueue(Queue sessQ, uint titleID, RequestType type) {
            if (type == RequestType.CREATE2) {
                if (sessQ.Count > 1.01 * (Stress2Params.numOpenRankedSessionsForHit + Stress2Params.numOpenSocialSessionsForHit)) {
                    return true;
                }
            }
        }
*/
        //if a queue is 1% larger than it should be, delete a session.  Call this to enforce
        //population control.
        public static void LimitSessionQueue(Queue sessQ, uint titleID) {
            if (sessQ.Count > 1.01 * (Stress2Params.numOpenRankedSessionsForHit + Stress2Params.numOpenSocialSessionsForHit)) {
                SessIDAndSgAddr hostInfo = (SessIDAndSgAddr)sessQ.Dequeue();
                byte [] sessID = (byte [])(hostInfo.SessID);
                XRL2DeleteSession	delReq = new XRL2DeleteSession(sessID,titleID);
                delReq.dwTitleID = titleID;
                delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }

        //little helper.  Grabs a random element from a long array.
        private static long RandomElementFromArray(long [] theArray) {
            int valueChoice = RandomEx.GlobalRandGen.Next(0, theArray.Length);
            return theArray[valueChoice];
        }

        //given the override mode string and the type of call, return the mode the request should use.
        public static long GetModeForOverride(string overrideMode, RequestType type) {
            if (overrideMode.Equals("LobbySessions")) {
                if (type == RequestType.CREATE2) {
                    //lobby sessions are all mode A on create.
                    long [] modeList = {Constants.CONTEXT_GAME_MODE_MODEA};
                    return RandomElementFromArray(modeList);
                } else {
                    //otherwise we want about 2/5 of the modes to sandwich to matchmaking
                    long [] modeList = {Constants.CONTEXT_GAME_MODE_MODEA,
                                        Constants.CONTEXT_GAME_MODE_MODEA,
                                        Constants.CONTEXT_GAME_MODE_MODEA,
                                        Constants.CONTEXT_GAME_MODE_MODEB,
                                        Constants.CONTEXT_GAME_MODE_MODEC};  
                    return RandomElementFromArray(modeList);
                }
            } else if (overrideMode.Equals("Halo3Sessions")) {
                long [] modeList = {Constants.CONTEXT_GAME_MODE_MODEB, Constants.CONTEXT_GAME_MODE_MODEC};
                return RandomElementFromArray(modeList);
            } else if (overrideMode.Equals("SingleModeSessions")) {
                //This one is like COD4--everything in one mode.
                long [] modeList = {Constants.CONTEXT_GAME_MODE_MODEA};
                return RandomElementFromArray(modeList);
            } else if (overrideMode.Equals("ReachSessions")) {
                //Make two modes.  2/3 in A.  Applies to all cases except search.
                //Reach will make 4 sessions per person(squad/presence, group, target, posse).
                //
                //If we filter out these sessions beforehand, however, then really we should only have
                //sessions in one mode for both search and create.
                if (type != RequestType.SEARCH2) {
//                    long [] modeList = {Constants.CONTEXT_GAME_MODE_MODEA, 
//                                        Constants.CONTEXT_GAME_MODE_MODEA,
//                                        Constants.CONTEXT_GAME_MODE_MODEB};
                    long [] modeList = {Constants.CONTEXT_GAME_MODE_MODEB};
                    return RandomElementFromArray(modeList);
                } else {
                    //searches are all weighted, and only hit the smaller one.  FindByIDs should
                    //really hit the first mode, but we don't segregate sessions like that.
                    long [] modeList = {Constants.CONTEXT_GAME_MODE_MODEB};
                    return RandomElementFromArray(modeList);
                }
            } else {
                return -1;
            }
        }

        //Apply the sessionModeOverride to the given request.  Only requests of the given types in
        //the RequestType enum are valid.  Be sensible when using this--don't pass in mismatched
        //XRLPayloads and RequestTypes.  One day subclass XRLPayload to Match requests?
        public static void ApplySessionModeOverride(XRLPayload request, RequestType type) {
            string overrideMode = Stress2Params.sessionModeSettings;
            long mode = GetModeForOverride(overrideMode, type);
            if (mode == -1) {
                //do nothing if it's an invalid override mode.
                return;
            }
            if ((type == RequestType.CREATE2) || (type == RequestType.UPDATE2)) {
                ((XRL2CreateUpdateSession) request).UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, 
                                                                                      new XRLXeIntValue(mode)));
            } else if (type == RequestType.SEARCH2) {
                ((XRL2SearchSession) request).UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, 
                                                                                new XRLXeIntValue(mode)));
            }
        }

        public static void createSessions(bool ranked, uint title, Queue session360Q)
        {
            SGADDR sgAddr;
            XRL2CreateUpdateSession createReq = Stress2Helpers.GetRandomXRL2Create(ranked, title, session360Q, out sgAddr);
            XRLSessionInfo createResp;

            CloseSessionIfSelected(createReq, ranked);
            ApplySessionModeOverride(createReq, RequestType.CREATE2);
            if (createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out createResp))
            {
                SessIDAndSgAddr hostInfo = new SessIDAndSgAddr(createResp.SessionID, sgAddr, ranked);
                session360Q.Enqueue(hostInfo);
                STFMatchCounters.AddToSessionCount(hostInfo); //for counting purposes
            }
            else
            {
                StressParams.Safetw.WriteLine("Create Open session for xbox360 failed: " + Global.XErrToString(createReq.XErr));
            }
        }

        private void CreateJIPSessionsExecutor(ref object Parameters)
        {
            CreateSessionsParams csParams = (CreateSessionsParams)Parameters;
            createJIPSessions(csParams.Ranked, csParams.Title, csParams.Session360Q);
        }

        public static void createJIPSessions(bool ranked, uint title, Queue session360Q)
        {
            SGADDR sgAddr;
            XRL2CreateUpdateSession createReq = Stress2Helpers.GetRandomXRL2Create(ranked, title, session360Q, out sgAddr);
            createReq.baseCreateUpdate.baseSession.dwPrivateFilled = 1;
            createReq.baseCreateUpdate.baseSession.dwPrivateOpen = 0;
            createReq.baseCreateUpdate.baseSession.dwPublicFilled = 0;
            createReq.baseCreateUpdate.baseSession.dwPublicOpen = 0;
            XRLSessionInfo createResp;
            if (createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out createResp))
            {
                SessIDAndSgAddr hostInfo = new SessIDAndSgAddr(createResp.SessionID, sgAddr, ranked);
                session360Q.Enqueue(hostInfo);
            }
            else
            {
                StressParams.Safetw.WriteLine("Create Open session for xbox360 failed: " + Global.XErrToString(createReq.XErr));
            }
        }

/*
		public static void createSessions(bool ranked, int i, uint title, Queue session360Q)
		{
			XRLXeAttribParam []	attribs = new XRLXeAttribParam[6];
			long	dateValue = Stress2Params.dateTimeValueArray[0],int32Value = Stress2Params.int32ValueArray[0];
			long	int64Value = Stress2Params.int64ValueArray[0];
			float	fValue = Stress2Params.float32ValueArray[0];
			double	dValue = Stress2Params.float64ValueArray[0];

			XRL2CreateUpdateSession	createReq;

			attribs[0] = new XRLXeAttribParam(Stress2Params.PROPERTY_DATETIMEPROP,new XRLXeDateTimeValue(dateValue));
			attribs[1] = new XRLXeAttribParam(Stress2Params.PROPERTY_FLOAT32PROP,new XRLXeFloatValue(fValue));
			attribs[2] = new XRLXeAttribParam(Stress2Params.PROPERTY_FLOAT64PROP,new XRLXeDoubleValue(dValue));
			attribs[3] = new XRLXeAttribParam(Stress2Params.PROPERTY_INT32PROP,new XRLXeIntValue(int32Value));
			attribs[4] = new XRLXeAttribParam(Stress2Params.PROPERTY_INT64PROP,new XRLXeIntValue(int64Value));
			attribs[5] = new XRLXeAttribParam(Stress2Params.CONTEXT_MYCONTEXT,new XRLXeIntValue(Stress2Params.CONTEXT_MYCONTEXT_MYCONTEXTVALUE1));

			if(ranked)	// create ranked session 
			{
				createReq = new XRL2CreateUpdateSession();
			}
			else	// create social session
			{
				// gamerZone could be 1,2,3,4,5
				int		gamerZone = i % 5 + 1;
				XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[8];
				Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
				Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
				Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(gamerZone));
				Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
				Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
				Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
				Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
				Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));
				createReq = new XRL2CreateUpdateSession(Attribs);
			}
			createReq.AddAttribs(attribs);
			createReq.baseCreateUpdate.baseSession.dwTitleID = title;
			SGADDR	sgAddr = new SGADDR();
            sgAddr.CopyTo(createReq.baseCreateUpdate.baseSession.HostAddress.abOnline);

			XRLSessionInfo			createResp;
			if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out createResp))
			{
				SessIDAndSgAddr hostInfo = new SessIDAndSgAddr(createResp.SessionID,sgAddr,ranked);
				session360Q.Enqueue(hostInfo);
			}
			else
			{
				StressParams.Safetw.WriteLine("Create Open session for xbox360 failed: " + Global.XErrToString(createReq.XErr));
			}
		}
*/
        public void DeinitializeStress()
        {
            Stress2Params.presListener.Stop();
            StressParams.Safetw.Close();

            // Restore the Xbox 360 titles to not use deferred deletion.
            foreach (uint titleId in Stress2Params.StressTitles)
            {
                MatchTitleMgr.RestoreMatchTitleFromSnapshot(titleId);
            }
            MatchFDs.ReloadTitleInfo();
        }

        //This loads the stress tests, dependent on the mode.
        public System.Collections.Generic.List<System.Type> GetStressTests()
        {
            System.Collections.Generic.List<System.Type> testList = new System.Collections.Generic.List<System.Type>();
            //Migration-only switch--if present, load a completely separate set
            string mode;
            try {
                mode = 
                    Global.Config.SelectSingleNode("/stf/config/stress/option[@name='TestMode']").Attributes["value"].Value;
            } catch (Exception) {
                Global.RO.Warn("Either no additional XML file specified or no TestMode included to" +
                               " configure Match stress.  Stress tests disabled.");
                return testList;
            }
            switch (mode) {
                case "MIGRATION_TESTING": 
                    //strong verification of NPDB and the match table afterwards.  Sometimes
                    //referred to as "func-y stress."
                    AddComprehensiveTests(testList);
                    break;
                case "DELAY_TESTING":
                    //tests that modify SQL to create an arbitrary delay on a request.  This allows
                    //us to simulate failing SQL servers in a controlled manner.
                    AddFastFailTests(testList);
                    break;
                default:
                    //Performance tests that run as quickly as possible and do not validate results
                    //besides HR.
                    //AddXbox1Tests(testList);
                    AddNormalXbox360StressTests(testList);
                    break;
            }

            if (Global.Config.SelectSingleNode("/stf/config/stress/option[@name='customTitleSchema']") != null) {
                Stress2Params.customTitleSchema = new ReachTitleSchema();                
                Stress2Params.customTitleSchema.AddTests(testList);
            }
            return testList;
        }

/*  Xbox1 tests.  Do these matter anymore? */
        private void AddXbox1Tests(System.Collections.Generic.List<System.Type> testList) {
            testList.Add(typeof(StressHostCreateTitle1));
            testList.Add(typeof(StressHostCreateTitle2));
            testList.Add(typeof(StressHostUpdateTitle1));
            testList.Add(typeof(StressHostUpdateTitle2));
            testList.Add(typeof(StressHostDeleteTitle1));
            testList.Add(typeof(StressHostDeleteTitle2));
            testList.Add(typeof(StressClientNormalQueryTitle1));
            testList.Add(typeof(StressClientNormalQueryTitle2));
            testList.Add(typeof(StressClientSummaryQueryTitle1));
            testList.Add(typeof(StressClientSummaryQueryTitle2));
            testList.Add(typeof(StressClientByIDQueryTitle1));
            testList.Add(typeof(StressClientByIDQueryTitle2));
        }

        //Normal tests that don't care as much about validation and more about speed.
        private void AddNormalXbox360StressTests(System.Collections.Generic.List<System.Type> testList) {
            testList.Add(typeof(Stress2DeadXBox));
            testList.Add(typeof(Stress2TitleChange));
            testList.Add(typeof(Stress2CreateRanked));
            testList.Add(typeof(Stress2CreateStandard));
            testList.Add(typeof(Stress2UpdateTitle));
            testList.Add(typeof(Stress2tDeleteTitle));
            testList.Add(typeof(Stress2SplitSession));
            testList.Add(typeof(Stress2ByIDQueryTitle));
            testList.Add(typeof(Stress2ByIDsQueryTitle10));
            testList.Add(typeof(Stress2ByIDsQueryTitle50));
            testList.Add(typeof(Stress2ByIDsQueryTitle100));
            testList.Add(typeof(Stress2SocialMatch_SortByInt64));
            testList.Add(typeof(Stress2SocialMatch_SortByFloat64));
            testList.Add(typeof(Stress2SocialMatch_SortByDateTime));
            testList.Add(typeof(Stress2SocialMatch_SortByAll));
            testList.Add(typeof(Stress2RankedMatch_SortByInt64));
            testList.Add(typeof(Stress2RankedMatch_SortByFloat64));
            testList.Add(typeof(Stress2RankedMatch_SortByDateTime));
            testList.Add(typeof(Stress2RankedMatch_SortByAll));
            //if we have a custom schema, add customized tests for it.
/*
  //The below are meant to test weighted performance vs. ranked and standard performance.  Normal
            stress will not require this.
            testList.Add(typeof(Stress2SimpleWeightedRanked));  //simple query, weighted search.
            testList.Add(typeof(Stress2SimpleWeightedStandard));
            testList.Add(typeof(Stress2RankedSearchComplexQuery)); //ranked/standard search,
            testList.Add(typeof(Stress2StandardSearchComplexQuery)); //complex query
            testList.Add(typeof(Stress2SearchWeightedComplexRanked));  //complex query, weighted search
            testList.Add(typeof(Stress2SearchWeightedComplexStandard));
            //repeat, but for midsize query
            testList.Add(typeof(Stress2RankedSearchMidQuery)); //ranked/standard search, midsize query
            testList.Add(typeof(Stress2StandardSearchMidQuery)); 
            testList.Add(typeof(Stress2WeightedRankedSearchMidQuery));  //weighted search, midsize query
            testList.Add(typeof(Stress2WeightedStandardSearchMidQuery));
            //simple search, weighted flag on but no weighted attributes.
            testList.Add(typeof(Stress2RankedMatch_SortByAll_WeightedFlag));  //non-weighted attributes,
            testList.Add(typeof(Stress2SocialMatch_SortByAll_WeightedFlag));//weighted flags on.
*/

        }

        //Comprehensive tests that includes logs in each session, and validate which server
        //the session is on..  Note these will make calls to NPDB as well, and are not
        //suitable for high TPS stress.
        private void AddComprehensiveTests(System.Collections.Generic.List<System.Type> testList) {
            testList.Add(typeof(MigrationCreateRanked));
            testList.Add(typeof(MigrationCreateStandard));
            testList.Add(typeof(MigrationSplit));
            testList.Add(typeof(MigrationSearchByID));
            testList.Add(typeof(MigrationSearchByQuery));
            testList.Add(typeof(MigrationUpdate));
            testList.Add(typeof(MigrationDelete));
            testList.Add(typeof(MigrationDeadXbox));
            testList.Add(typeof(MigrationDeadSG));
        }

        private void AddFastFailTests(System.Collections.Generic.List<System.Type> testList) {
            testList.Add(typeof(Insert1_1_ms_async));
            testList.Add(typeof(Insert1_10_ms_async));
            testList.Add(typeof(Insert1_100_ms_async));
            testList.Add(typeof(Insert1_1000_ms_async));
            testList.Add(typeof(Insert1_10000_ms_async));
            testList.Add(typeof(Insert2_1_ms_async));
            testList.Add(typeof(Insert2_10_ms_async));
            testList.Add(typeof(Insert2_100_ms_async));
            testList.Add(typeof(Insert2_1000_ms_async));
            testList.Add(typeof(Insert2_10000_ms_async));

            testList.Add(typeof(Insert1_1_ms_sync));
            testList.Add(typeof(Insert1_10_ms_sync));
            testList.Add(typeof(Insert1_100_ms_sync));
            testList.Add(typeof(Insert1_1000_ms_sync));
            testList.Add(typeof(Insert1_10000_ms_sync));
            testList.Add(typeof(Insert2_1_ms_sync));
            testList.Add(typeof(Insert2_10_ms_sync));
            testList.Add(typeof(Insert2_100_ms_sync));
            testList.Add(typeof(Insert2_1000_ms_sync));
            testList.Add(typeof(Insert2_10000_ms_sync));
        }

        public void Initialize()
        {
            // Let the fake SG know where to send state updates
            ServerTestFramework.LiveService.FakeSG.GlobalFakeSG.FakeSG.SetStateEndpoint(Global.XEnv.GetVirtualInterface(VirtualInterface.xpnfd_presence).ToString());


            // Ensure we have all the necessary titles.
            uint[] XENON_FUNCTIONAL_TITLEIDS = {Constants.XENON_TITLE,
                                                Constants.XENON_TITLE2,
                                                Constants.XENON_PARTITIONED_TITLE,
                                                Constants.XENON_ROUND_ROBINED_TITLE};
            /*  //This never really worked...
            //prop all 360 titles
            foreach (uint titleid in XENON_FUNCTIONAL_TITLEIDS) {
            bool isPropped = LiveTitle.CheckIfTitleIsPropped(titleid);
            if (!isPropped) {
                    //Global.RO.Info("Titleid " + titleid.ToString("X") + " not found.  Attempting to prop...");
                    //LiveTitle.PropTitle(titleid, 0, AuthContext.ClientTypes.Xenon);
                    //LiveMatch.RunLiveMatchDefault(titleid);
                    Global.RO.Info("Titleid " + titleid.ToString("X") + 
                                   " not found.  Please prop, as some or  all tests may not work without this title!");
                }
            }

            //prop the known xbox1 title.
            uint xboxTitleid = Constants.TITLE_ID;
            bool xboxTitleIsPropped = LiveTitle.CheckIfTitleIsPropped(xboxTitleid);
            if (!xboxTitleIsPropped) {
                Global.RO.Info("Titleid " + xboxTitleid.ToString("X") + " not found.  Attempting to prop...");
                LiveTitle.PropTitle(xboxTitleid, 0, AuthContext.ClientTypes.Xbox);
                LiveMatch.RunLiveMatchDefault(xboxTitleid);
            }
            */
        }
    }

    public abstract class MatchTestBase : TestBase
    {
        public enum Verify
        {
            Inclusive,
            Exclusive
        }

        public bool DeleteSession(uint titleID, byte[] sessionID)
        {
            XRL2DeleteSession delReq = new XRL2DeleteSession(sessionID, titleID);
            if (delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
            {
                return true;
            }
            else
            {
                Global.RO.Warn("MatchTestBase::DeleteSession: Failed to delete session ID {0}", 
                    Constants.sessionIDConvert(sessionID));
                return false;
            }
        }

        public bool DeleteSessions(uint titleID, XRLSessionInfo[] sessions)
        {
            if (sessions == null)
            {
                Global.RO.Warn("MatchTestBase::DeleteSessions: sessions == null");
            }
            bool success = true;
            foreach (XRLSessionInfo session in sessions)
            {
                success = success && DeleteSession(titleID, session.SessionID);
            }
            return success;
        }

        public XRL2SingleSearchResult FindSession(XRLSessionInfo target,
            XRL2SearchResults searchResults)
        {
            XRL2SingleSearchResult result = null;
            for (int i = 0; i < searchResults.resultsLen; i++)
            {
                if (ArrayEx.Compare(searchResults.results[i].SessionID, target.SessionID))
                {
                    result = searchResults.results[i];
                    break;
                }
            }
            return result;
        }

        public bool VerifySessions(XRLSessionInfo[] sessions, XRL2SearchResults searchResults, Verify verify)
        {
            if (sessions == null)
            {
                Global.RO.Error("MatchTestBase::VerifySessions: sessions == null");
                return false;
            }
            if (searchResults == null)
            {
                Global.RO.Error("MatchTestBase::VerifySessions: searchResults == null");
                return false;
            }
            if (verify == Verify.Exclusive)
            {
                if (sessions.Length != searchResults.resultsLen)
                {
                    Global.RO.Error("MatchTestBase::VerifySessions: expected.Length ({0}) != actual.resultsLen {1}",
                        sessions.Length, searchResults.resultsLen);
                    return false;
                }
            }
            foreach (XRLSessionInfo session in sessions)
            {
                if (FindSession(session, searchResults) == null)
                {
                    Global.RO.Error("MatchTestBase::VerifySessions: Session ID 0x{0} not found in results",
                        Constants.sessionIDConvert(session.SessionID).ToString("X8"));
                    return false;
                }
            }
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\xmgmt\List.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;

namespace XmgmtServerTest
{
    [TestGroup]
    public class List
    {
        //verifies that there are no duplicate lines
        public void VerifyNoDuplicates(string []lines)
        {
            for (int i=0; i<lines.Length; ++i)
            {
                for (int k=0; k<lines.Length; ++k)
                {
                    if (k!=i)
                    {
                        if (lines[k]==lines[i])
                        {
                            throw new UnexpectedTestResultException("Line "+i+" is the same as line "+k+": "+lines[i]);
                        }
                    }
                }
            }
        }

        [TestCase, Description("Does a 'list' command with no parameters and checks for several things that should be there.")]
        public void NoParams()
        {
            string ret=Util.RunCommandVerbose("kdcsvc", "l");
            ret=ret.Replace("\r", "");
            string []lines=ret.Split(new char[]{'\n'}, System.StringSplitOptions.RemoveEmptyEntries);
            VerifyNoDuplicates(lines);

            //should be 1 entry for xmgmtsrv, and at least 4 for kdcsvc
            int xmgmtsrvCount=0;
            int kdcsvcCount=0;

            foreach (string line in lines)
            {
                if (line.StartsWith("xmgmtsrv"))
                {
                    ++xmgmtsrvCount;
                }

                if (line.StartsWith("kdcsvc"))
                {
                    ++kdcsvcCount;
                }
            }

            if (xmgmtsrvCount!=1)
            {
                throw new UnexpectedTestResultException("Expect exactly 1 xmgmtsrv line but found "+xmgmtsrvCount);
            }

            if (kdcsvcCount<4)
            {
                throw new UnexpectedTestResultException("Expected at least 4 kdcsvc lines but found "+kdcsvcCount);
            }
        }

        [TestCase, Description("Does a 'list interface' command and verifies that only that component comes back.")]
        public void InterfaceFilter()
        {
            string ret=Util.RunCommandVerbose("kdcsvc", "list kdcsvc");
            ret=ret.Replace("\r", "");
            string []lines=ret.Split(new char[]{'\n'}, System.StringSplitOptions.RemoveEmptyEntries);
            VerifyNoDuplicates(lines);

            //should be at least 4 for kdcsvc
            int kdcsvcCount=0;

            foreach (string line in lines)
            {
                if (line.StartsWith("kdcsvc"))
                {
                    ++kdcsvcCount;
                }
                else if (line.Length>0)
                {
                    throw new UnexpectedTestResultException("Got a non-kdcsvc line back: "+line);
                }
            }

            if (kdcsvcCount<4)
            {
                throw new UnexpectedTestResultException("Expected at least 4 kdcsvc lines but found "+kdcsvcCount);
            }
        }

        [TestCase, Description("Does a 'list component' command and verifies that only that component comes back.")]
        public void ComponentFilter()
        {
            string ret=Util.RunCommandVerbose("kdcsvc", "list XMACS");
            ret=ret.Replace("\r", "");
            string []lines=ret.Split(new char[]{'\n'}, System.StringSplitOptions.RemoveEmptyEntries);
            VerifyNoDuplicates(lines);

            //should be at least 4 for kdcsvc
            int kdcsvcXmacsCount=0;

            foreach (string line in lines)
            {
                if (line.StartsWith("kdcsvc") && line.EndsWith("XMACS"))
                {
                    ++kdcsvcXmacsCount;
                }
                else
                {
                    throw new UnexpectedTestResultException("Got a non-kdcsvc-XMACS line back: "+line);
                }
            }

            if (kdcsvcXmacsCount!=1)
            {
                throw new UnexpectedTestResultException("Expected 1 kdcsvc XMACS line but found "+kdcsvcXmacsCount);
            }
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\xmgmt\Common.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;

namespace XmgmtServerTest
{
    public class Util
    {
        public static string RunCommandVerbose(string innterface, string command)
        {
            System.Net.IPEndPoint []ep=ManagementListener.GetXmgmtEndPoints(innterface);
            if (ep.Length==0)
            {
                throw new System.Exception("There are no xmgmt endpoints for "+innterface);
            }

            Global.RO.Debug("Sending to "+innterface+"("+ep[0]+"): "+command);
            string ret;
            ManagementConsole.Execute(ep[0], command, out ret);
            Global.RO.Debug("Response:\n"+ret);
            return ret;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XRLScan\XrlScanTestSuite\Suite.cs ===
using ServerTestFramework;

[assembly: RootNode(typeof(XrlScanTestSuite.XrlScanTestSuite))]

namespace XrlScanTestSuite
{
    [TestGroup, Owner("craigick"), TestFrequency("Daily"), TestCasePriority(1)]
    public class XrlScanTestSuite: TestNode
    {
    };
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XRLScan\XrlScanTestSuite\MiscTest.cs ===
using System;
using ServerTestFramework;
using System.Net;
using System.IO;
using ServerTestFramework.LiveService;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.common.protocol;

namespace XrlScanTestSuite.Functional
{
    [TestGroup, Owner("craigick"), TestCasePriority(1)]
    public class MiscTest : TestNode
    {
        [TestCase, Description("Validate host header is updated if the high octet is zero.  Regression test for PS:174395")]
        [CompoundCase("standard path", @"/testfd/Reflect/XrlScanDefault.ashx", "0.1.2.0", 200), TestCasePriority(2)]
        class VerifyHostHeader : TestNode
        {
            public override void Run()
            {
                string verifiedUrl = (string)MyValues[0];
                string requestHost = (string)MyValues[1];
                int expectedHttpStatusCode = (int)MyValues[2];

                CustomTransaction xns = new CustomTransaction();
                xns.endPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.testfd);
                xns.ServiceURL = @"/testfd/Reflect/XrlScanDefault.ashx";
                xns.hostName = requestHost;

                if (!XrlScanTestBase.Exec(xns, (HttpStatusCode)expectedHttpStatusCode))
                {
                    throw new UnexpectedTestResultException(String.Format("Failure on url [{0}] Actual [{1}] Expected [{2}].", verifiedUrl, (int)xns.httpStatus, expectedHttpStatusCode));
                }

                MemoryStream responseBuffer = new MemoryStream(xns.ResponseContents);
                BinaryReader binaryReader = new BinaryReader(responseBuffer);
                TestFdReflectorResponse reflectorResponse = new TestFdReflectorResponse();
                reflectorResponse.ReadStream(binaryReader);

                string responseHost = reflectorResponse.HttpRequest.Headers.Dict["Host"];
                Global.RO.Debug("ResponseHost: " + responseHost);
                Global.RO.Debug("RequestHost: " + requestHost);
                if (responseHost == requestHost)
                {
                    throw new UnexpectedTestResultException(String.Format("Hosts are not expected to match: Actual [{0}] Expected [{1}].", responseHost, requestHost));
                }
            }
        }

        [TestCase, Description("Verify functionality of added ServerPort Header."), TestCasePriority(2)]
        [CompoundCase("ServerPort passed in", @"/testfd/Reflect/XrlScanDefault.ashx", "ServerPort", "foo")] // XrlScan should override this with the actual server port
        [CompoundCase("ServerPort is added", @"/testfd/Reflect/XrlScanDefault.ashx", "ServerPort", "")] // in this case ensure the server port header is added
        class VerifyServerPortHeader : TestNode
        {
            public override void Run()
            {
                string verifiedUrl = (string)MyValues[0];
                string verifiedHeader = (string)MyValues[1];
                string verifiedHeaderValue = (string)MyValues[2];

                CustomTransaction xns = new CustomTransaction();
                xns.endPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.testfd);
                xns.ServiceURL = verifiedUrl;
                if (verifiedHeaderValue.Length > 0)
                    xns.CustomHeaderField = String.Format("{0}: {1}", verifiedHeader, verifiedHeaderValue);

                if (!XrlScanTestBase.Exec(xns, HttpStatusCode.OK))
                {
                    throw new UnexpectedTestResultException(String.Format("Failure on url [{0}] Actual [{1}] Expected [{2}].", verifiedUrl, (int)xns.httpStatus, HttpStatusCode.OK));
                }

                MemoryStream responseBuffer = new MemoryStream(xns.ResponseContents);
                BinaryReader binaryReader = new BinaryReader(responseBuffer);
                TestFdReflectorResponse reflectorResponse = new TestFdReflectorResponse();
                reflectorResponse.ReadStream(binaryReader);

                if (!reflectorResponse.HttpRequest.Headers.Dict.ContainsKey(verifiedHeader))
                {
                    foreach (System.Collections.Generic.KeyValuePair<string, string> kvp in reflectorResponse.HttpRequest.Headers.Dict)
                    {
                        Global.RO.Error("{0}: {1}", kvp.Key, kvp.Value);
                    }
                    throw new UnexpectedTestResultException(String.Format("The response did not conain the expected header [{0}].", verifiedHeader));
                }

                string port = xns.endPoint.Port.ToString();
                if (reflectorResponse.HttpRequest.Headers.Dict[verifiedHeader] != port)
                {
                    throw new UnexpectedTestResultException(String.Format("The expected header [{0}] does not match port [{1}].", verifiedHeader, port));
                }
            }
        }

        [TestCase, Description("Verify functionality of added SGIPPort Header."), TestCasePriority(2)]
        [CompoundCase("SGIPPort passed in", @"/testfd/Reflect/XrlScanDefault.ashx", "SGIPPort", "foo")] // XrlScan should override this with the actual server port
        [CompoundCase("SGIPPort is added", @"/testfd/Reflect/XrlScanDefault.ashx", "SGIPPort", "")] // in this case ensure the server port header is added
        class VerifySGIPPortHeader : TestNode
        {
            public override void Run()
            {
                string verifiedUrl = (string)MyValues[0];
                string verifiedHeader = (string)MyValues[1];
                string verifiedHeaderValue = (string)MyValues[2];

                CustomTransaction xns = new CustomTransaction();
                xns.endPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.testfd);
                xns.ServiceURL = verifiedUrl;
                if (verifiedHeaderValue != String.Empty)
                    xns.CustomHeaderField = String.Format("{0}: {1}", verifiedHeader, verifiedHeaderValue);

                if (!XrlScanTestBase.Exec(xns, HttpStatusCode.OK))
                {
                    throw new UnexpectedTestResultException(String.Format("Failure on url [{0}] Actual [{1}] Expected [{2}].", verifiedUrl, (int)xns.httpStatus, HttpStatusCode.OK));
                }

                MemoryStream responseBuffer = new MemoryStream(xns.ResponseContents);
                BinaryReader binaryReader = new BinaryReader(responseBuffer);
                TestFdReflectorResponse reflectorResponse = new TestFdReflectorResponse();
                reflectorResponse.ReadStream(binaryReader);

                if (!reflectorResponse.HttpRequest.Headers.Dict.ContainsKey(verifiedHeader))
                {
                    foreach (System.Collections.Generic.KeyValuePair<string, string> kvp in reflectorResponse.HttpRequest.Headers.Dict)
                    {
                        Global.RO.Error("{0}: {1}", kvp.Key, kvp.Value);
                    }
                    throw new UnexpectedTestResultException(String.Format("The response did not conain the expected header [{0}].", verifiedHeader));
                }

                // in the case where the header is not sent in the existence check above is good enough
                if (verifiedHeaderValue != String.Empty)
                {
                    // The passed in value will not be overridden
                    if (reflectorResponse.HttpRequest.Headers.Dict[verifiedHeader] != verifiedHeaderValue)
                    {
                        foreach (System.Collections.Generic.KeyValuePair<string, string> kvp in reflectorResponse.HttpRequest.Headers.Dict)
                        {
                            Global.RO.Error("{0}: {1}", kvp.Key, kvp.Value);
                        }
                        throw new UnexpectedTestResultException(String.Format("The header [{0}] was not the expected value: [{1}].", verifiedHeader, verifiedHeaderValue));
                    }
                }
            }
        }
    }; //class MiscTest
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XRLScan\XrlScanTestSuite\SettingsTest.cs ===
using System;
using ServerTestFramework;
using System.Net;
using ServerTestFramework.LiveService;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;

namespace XrlScanTestSuite.Functional
{
    [TestGroup]
    public class SettingsTest : TestNode
    {
        [TestGroup, Description("Validate valid urls which pass through XrlScan."), TestCasePriority(1)]
        public class SettingsVerification : TestNode
        {            
            [TestCase, Description("Validate max url length setting.")]
            // The max url length is 100.
            [CompoundCase("above maximum",  @"/testfd/Reflect/XrlScanDefault.ashx" + // 36 chars 
                                            @"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx", 404)]  // 100 x's
            [CompoundCase("equals maximum", @"/testfd/Reflect/XrlScanDefault.ashx" + // 36 chars
                                            @"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx", 404)]  // 64 x's
            [CompoundCase("under maximum",  @"/testfd/Reflect/XrlScanDefault.ashx" + // 36 chars
                                            @"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx", 200)]  // 63 x's
            class VerifyMaxUrlLength : TestNode
            {
                public override void Run()
                {
                    string verifiedUrl = (string)MyValues[0];
                    int expectedHttpStatusCode = (int)MyValues[1];

                    CustomTransaction xns = new CustomTransaction();
                    xns.endPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.testfd);
                    xns.ServiceURL = verifiedUrl;

                    if (!XrlScanTestBase.Exec(xns, (HttpStatusCode)expectedHttpStatusCode))
                    {
                        throw new UnexpectedTestResultException(String.Format("Failure on url [{0}] Actual [{1}] Expected [{2}].", verifiedUrl, (int) xns.httpStatus, expectedHttpStatusCode));
                    }
                }
            }

            [TestCase, Description("Validate max url content length setting."), TestCasePriority(1)]
            [CompoundCase("standard path max", @"/testfd/Reflect/XrlScanDefault.ashx", 1024, 200)] // allows length 1024
            [CompoundCase("standard path max plus one", @"/testfd/Reflect/XrlScanDefault.ashx", 1025, 404)]
            class VerifyMaxContentLength : TestNode
            {
                public override void Run()
                {
                    string verifiedUrl = (string)MyValues[0];
                    int contentLength = (int)MyValues[1];
                    int expectedHttpStatusCode = (int)MyValues[2];

                    CustomTransaction xns = new CustomTransaction();
                    xns.endPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.testfd);
                    xns.ServiceURL = verifiedUrl;

                    if (!XrlScanTestBase.Exec(xns, (HttpStatusCode)expectedHttpStatusCode, contentLength))
                    {
                        throw new UnexpectedTestResultException(String.Format("Failure on url [{0}] Actual [{1}] Expected [{2}].", verifiedUrl, (int)xns.httpStatus, expectedHttpStatusCode));
                    }
                }
            }

            [TestCase, Description("Validate max query string length setting."), TestCasePriority(1)]
            [CompoundCase("standard path valid", @"/testfd/Reflect/XrlScanDefault.ashx?1234567890123456", 200)] // allows length 16
            [CompoundCase("standard path max plus 1", @"/testfd/Reflect/XrlScanDefault.ashx?12345678901234567", 404)] // allows length 16
            [CompoundCase("standard path max plus 1 with zero setting", @"/testfd/ReflectNoAuthSg.ashx?1", 404)] // this has a setting for query string length of 0
            class VerifyMaxQueryStringLength : TestNode
            {
                public override void Run()
                {
                    string verifiedUrl = (string)MyValues[0];
                    int expectedHttpStatusCode = (int)MyValues[1];

                    CustomTransaction xns = new CustomTransaction();
                    xns.endPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.testfd);
                    xns.ServiceURL = verifiedUrl;

                    if (!XrlScanTestBase.Exec(xns, (HttpStatusCode)expectedHttpStatusCode))
                    {
                        throw new UnexpectedTestResultException(String.Format("Failure on url [{0}] Actual [{1}] Expected [{2}].", verifiedUrl, (int)xns.httpStatus, expectedHttpStatusCode));
                    }
                }
            }

            [TestCase, Description("Validate allow text xml setting."), TestCasePriority(1)]
            [CompoundCase("allow setting",    @"/testfd/ReflectNoAuthSg.ashx", 200)] // does allow
            [CompoundCase("disallow setting", @"/testfd/Reflect/XrlScanDefault.ashx", 404)] // does not allow
            class VerifyAllowTextXml : TestNode
            {
                public override void Run()
                {
                    string verifiedUrl = (string)MyValues[0];
                    int expectedHttpStatusCode = (int)MyValues[1];

                    CustomTransaction xns = new CustomTransaction();
                    xns.endPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.testfd);
                    xns.ContentType = "Content-Type: text/xml";
                    xns.ServiceURL = verifiedUrl;

                    if (!XrlScanTestBase.Exec(xns, (HttpStatusCode)expectedHttpStatusCode))
                    {
                        throw new UnexpectedTestResultException(String.Format("Failure on url [{0}] Actual [{1}] Expected [{2}].", verifiedUrl, (int)xns.httpStatus, expectedHttpStatusCode));
                    }
                }
            }

            [TestCase, Description("Validate allow partial match setting."), TestCasePriority(1)]
            [CompoundCase("allow setting",    @"/testfd/Reflect/XrlScanDefault.ashxxx", 200)] // does allow
            [CompoundCase("disallow setting", @"/testfd/ReflectNoAuthSg.ashxxx", 404)] // does not allow
            class VerifyPartialMatch : TestNode
            {
                public override void Run()
                {
                    string verifiedUrl = (string)MyValues[0];
                    int expectedHttpStatusCode = (int)MyValues[1];

                    CustomTransaction xns = new CustomTransaction();
                    xns.endPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.testfd);
                    xns.ServiceURL = verifiedUrl;

                    if (!XrlScanTestBase.Exec(xns, (HttpStatusCode)expectedHttpStatusCode))
                    {
                        throw new UnexpectedTestResultException(String.Format("Failure on url [{0}] Actual [{1}] Expected [{2}].", verifiedUrl, (int)xns.httpStatus, expectedHttpStatusCode));
                    }
                }
            }

            [TestCase, Description("Validate verb list setting."), TestCasePriority(1)]
            [CompoundCase("method GET allowed",     @"/testfd/ReflectNoAuthSg.ashx", "GET", 200)] // is allowed on this xrl
            [CompoundCase("method POST allowed",    @"/testfd/ReflectNoAuthSg.ashx", "POST", 200)] // is allowed on this xrl
            [CompoundCase("method POSTER allowed",  @"/testfd/ReflectNoAuthSg.ashx", "POSTER", 404)] // negative case not allowed
            [CompoundCase("method PUT allowed",     @"/testfd/ReflectNoAuthSg.ashx", "PUT", 404)] // is not allowed on this xrl
            [CompoundCase("method DELETE allowed",  @"/testfd/ReflectNoAuthSg.ashx", "DELETE", 404)] // not is allowed on this xrl
            [CompoundCase("method HEAD allowed",    @"/testfd/ReflectNoAuthSg.ashx", "HEAD", 404)] // is not allowed on this xrl
            [CompoundCase("method2 GET allowed",    @"/testfd/Reflect/XrlScanDefault.ashx", "GET", 200)] // is allowed on this xrl
            [CompoundCase("method2 POST allowed",   @"/testfd/Reflect/XrlScanDefault.ashx", "POST", 200)] // is allowed on this xrl
            [CompoundCase("method2 PUT allowed",    @"/testfd/Reflect/XrlScanDefault.ashx", "PUT", 200)] // is allowed on this xrl
            [CompoundCase("method2 PUTTER allowed", @"/testfd/Reflect/XrlScanDefault.ashx", "PUTTER", 404)] // negative case not allowed
            [CompoundCase("method2 DELETE allowed", @"/testfd/Reflect/XrlScanDefault.ashx", "DELETE", 200)] // is allowed on this xrl
            [CompoundCase("method2 HEAD allowed",   @"/testfd/Reflect/XrlScanDefault.ashx", "HEAD", 404)] // is allowed on this xrl but is only settable via t_settings_override and will be blocked
            class VerifyHTTPVerbs : TestNode
            {
                public override void Run()
                {
                    string verifiedUrl = (string)MyValues[0];
                    string httpVerb = (string)MyValues[1];
                    int expectedHttpStatusCode = (int)MyValues[2];

                    CustomTransaction xns = new CustomTransaction();
                    xns.endPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.testfd);
                    xns.Method = httpVerb;
                    xns.ServiceURL = verifiedUrl;

                    if (!XrlScanTestBase.Exec(xns, (HttpStatusCode)expectedHttpStatusCode))
                    {
                        throw new UnexpectedTestResultException(String.Format("Failure on url [{0}] Actual [{1}] Expected [{2}].", verifiedUrl, (int)xns.httpStatus, expectedHttpStatusCode));
                    }
                }
            }

            [TestCase, Description("Validate HEAD setting which is only allowed via t_settings_override.  NOTE: this will only pass if the below title is propped"), TestCasePriority(1)]
            [CompoundCase("method HEAD allowed", @"/content/584107d8/29a47ca681738bdde9e24cfaa94fd1c0bf2a3eab.xcp", "HEAD", 200)] // Joust
            class VerifyHEADSetting : TestNode
            {
                public override void Run()
                {
                    string verifiedUrl = (string)MyValues[0];
                    string httpVerb = (string)MyValues[1];
                    int expectedHttpStatusCode = (int)MyValues[2];

                    CustomTransaction xns = new CustomTransaction();
                    xns.endPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.download);
                    xns.Method = httpVerb;
                    xns.ServiceURL = verifiedUrl;

                    if (!XrlScanTestBase.Exec(xns, (HttpStatusCode)expectedHttpStatusCode))
                    {
                        throw new UnexpectedTestResultException(String.Format("Failure on url [{0}] Actual [{1}] Expected [{2}].", verifiedUrl, (int)xns.httpStatus, expectedHttpStatusCode));
                    }
                }
            }
        }
    }; //class SettingsTest
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XRLScan\XrlScanTestSuite\UrlTest.cs ===
using System;
using ServerTestFramework;
using System.Net;
using System.IO;
using ServerTestFramework.LiveService;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;

namespace XrlScanTestSuite.Functional
{
    [TestGroup]
    public class UrlTest : TestNode
    {
        [TestGroup, Description("Validate valid urls which pass through XrlScan."), TestCasePriority(1)]
        public class UrlVerification : TestNode
        {
            [TestCase, Description("Positive url validation."), TestCasePriority(1)]
            [CompoundCase("standard url no querystring", @"/testfd/ReflectNoAuthSg.ashx",     200)]
            [CompoundCase("includes empty querystring",  @"/testfd/ReflectNoAuthSg.ashx?",    200)]
            [CompoundCase("includes simple querystring", @"/testfd/Reflect/XrlScanDefault.ashx?a=b", 200)]
            class VerifyValidUrls : TestNode
            {
                public override void Run()
                {
                    string verifiedUrl = (string)MyValues[0];
                    int expectedHttpStatusCode = (int)MyValues[1];

                    CustomTransaction xns = new CustomTransaction();
                    xns.endPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.testfd);
                    xns.ServiceURL = verifiedUrl;

                    if (!XrlScanTestBase.Exec(xns, (HttpStatusCode)expectedHttpStatusCode))
                    {
                        throw new UnexpectedTestResultException(String.Format("Failure on url [{0}] Actual [{1}] Expected [{2}].", verifiedUrl, (int) xns.httpStatus, expectedHttpStatusCode));
                    }
                }
            }

            [TestCase, Description("Invalid character in url (encoded and standard)."), TestCasePriority(1)]
            // Note that 404's are caught by XrlScan and 400's are caught by IIS
            [CompoundCase("invalid char questionmark encoded", @"/testfd/Reflect/%3FXrlScanDefault.ashx", 400)]
            [CompoundCase("invalid char quote",                @"/testfd/Reflect/""XrlScanDefault.ashx",  400)] // does not make it to XrlScan and is blocked by IIS
            [CompoundCase("invalid char quote encoded",        @"/testfd/Reflect/%22XrlScanDefault.ashx", 404)]
            [CompoundCase("invalid char lessthan",             @"/testfd/Reflect/<XrlScanDefault.ashx",   400)] // does not make it to XrlScan and is blocked by IIS
            [CompoundCase("invalid char lessthan encoded",     @"/testfd/Reflect/%3CXrlScanDefault.ashx", 400)]
            [CompoundCase("invalid char greaterthan",          @"/testfd/Reflect/>XrlScanDefault.ashx",   400)] // does not make it to XrlScan and is blocked by IIS
            [CompoundCase("invalid char greaterthan encoded",  @"/testfd/Reflect/%3EXrlScanDefault.ashx", 400)]
            [CompoundCase("invalid char pipe",                 @"/testfd/Reflect/|XrlScanDefault.ashx",   404)]
            [CompoundCase("invalid char pipe encoded",         @"/testfd/Reflect/%7CXrlScanDefault.ashx", 404)]
            [CompoundCase("invalid char star",                 @"/testfd/Reflect/*XrlScanDefault.ashx",   400)]
            [CompoundCase("invalid char star encoded",         @"/testfd/Reflect/%2AXrlScanDefault.ashx", 400)]
            [CompoundCase("invalid char double dot",           @"/testfd/Reflect/..XrlScanDefault.ashx", 400)]
            [CompoundCase("invalid char double dot encoded",   @"/testfd/Reflect/%2E%2EXrlScanDefault.ashx", 400)]
            class VerifyInvalidUrlCharacters : TestNode
            {
                public override void Run()
                {
                    string verifiedUrl = (string)MyValues[0];
                    int expectedHttpStatusCode = (int)MyValues[1];

                    CustomTransaction xns = new CustomTransaction();
                    xns.endPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.testfd);
                    xns.ServiceURL = verifiedUrl;

                    if (!XrlScanTestBase.Exec(xns, (HttpStatusCode)expectedHttpStatusCode))
                    {
                        throw new UnexpectedTestResultException(String.Format("Failure on url [{0}] Actual [{1}] Expected [{2}].", verifiedUrl, (int)xns.httpStatus, expectedHttpStatusCode));
                    }
                }
            }

            [TestCase, Description("Valid character in query string (encoded and standard)."), TestCasePriority(1)]
            // this tests uses 'Reflect/XrlScanDefault.ashx' because it is set to allow query strings of length 16 
            [CompoundCase(@"valid char questionmark",         @"/testfd/Reflect/XrlScanDefault.ashx?a?b",   200)]
            [CompoundCase(@"valid char questionmark encoded", @"/testfd/Reflect/XrlScanDefault.ashx?a%3Fb", 200)]
            [CompoundCase(@"valid char equals",               @"/testfd/Reflect/XrlScanDefault.ashx?a=b",   200)]
            [CompoundCase(@"valid char equals encoded",       @"/testfd/Reflect/XrlScanDefault.ashx?a%3Db", 200)]
            [CompoundCase(@"valid char ampersand",            @"/testfd/Reflect/XrlScanDefault.ashx?a&b",   200)]
            [CompoundCase(@"valid char ampersand encoded",    @"/testfd/Reflect/XrlScanDefault.ashx?a%26b", 200)]
            [CompoundCase(@"valid char percent",              @"/testfd/Reflect/XrlScanDefault.ashx?a%b",   200)]
            [CompoundCase(@"valid char percent encoded",      @"/testfd/Reflect/XrlScanDefault.ashx?a%25b", 200)]
            [CompoundCase(@"valid char plus",                 @"/testfd/Reflect/XrlScanDefault.ashx?a+b",   200)]
            [CompoundCase(@"valid char plus encoded",         @"/testfd/Reflect/XrlScanDefault.ashx?a%2Bb", 200)]
            [CompoundCase(@"valid char underscore",           @"/testfd/Reflect/XrlScanDefault.ashx?a_b",   200)]
            [CompoundCase(@"valid char underscore encoded",   @"/testfd/Reflect/XrlScanDefault.ashx?a%5Fb", 200)]
            [CompoundCase(@"valid char hyphen",               @"/testfd/Reflect/XrlScanDefault.ashx?a-b",   200)]
            [CompoundCase(@"valid char hyphen encoded",       @"/testfd/Reflect/XrlScanDefault.ashx?a%2Db", 200)]
            [CompoundCase(@"valid char dot",                  @"/testfd/Reflect/XrlScanDefault.ashx?a.b",   200)]
            [CompoundCase(@"valid char dot encoded",          @"/testfd/Reflect/XrlScanDefault.ashx?a%2Eb", 200)]
            [CompoundCase(@"valid char comma",                @"/testfd/Reflect/XrlScanDefault.ashx?a,b",   200)]
            [CompoundCase(@"valid char comma encoded",        @"/testfd/Reflect/XrlScanDefault.ashx?a%2Cb", 200)]
            [CompoundCase(@"valid char singlequote",          @"/testfd/Reflect/XrlScanDefault.ashx?a'b",   200)]
            [CompoundCase(@"valid char singlequote encoded",  @"/testfd/Reflect/XrlScanDefault.ashx?a%27b", 200)]
            [CompoundCase(@"valid char openparen",            @"/testfd/Reflect/XrlScanDefault.ashx?a(b",   200)]
            [CompoundCase(@"valid char openparen encoded",    @"/testfd/Reflect/XrlScanDefault.ashx?a%28b", 200)]
            [CompoundCase(@"valid char closeparen",           @"/testfd/Reflect/XrlScanDefault.ashx?a)b",   200)]
            [CompoundCase(@"valid char closeparen encoded",   @"/testfd/Reflect/XrlScanDefault.ashx?a%29b", 200)]
            [CompoundCase(@"valid char star",                 @"/testfd/Reflect/XrlScanDefault.ashx?a*b",   200)]
            [CompoundCase(@"valid char star encoded",         @"/testfd/Reflect/XrlScanDefault.ashx?a%2Ab", 200)]
            [CompoundCase(@"valid char exclamation",          @"/testfd/Reflect/XrlScanDefault.ashx?a!b",   200)]
            [CompoundCase(@"valid char exclamation encoded",  @"/testfd/Reflect/XrlScanDefault.ashx?a%21b", 200)]
            [CompoundCase(@"valid char tilda",                @"/testfd/Reflect/XrlScanDefault.ashx?a~b",   200)]
            [CompoundCase(@"valid char tilda encoded",        @"/testfd/Reflect/XrlScanDefault.ashx?a%7Eb", 200)]
            class VerifyValidQueryStringCharacters : TestNode
            {
                public override void Run()
                {
                    string verifiedUrl = (string)MyValues[0];
                    int expectedHttpStatusCode = (int)MyValues[1];

                    CustomTransaction xns = new CustomTransaction();
                    xns.endPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.testfd);
                    xns.ServiceURL = verifiedUrl;

                    if (!XrlScanTestBase.Exec(xns, (HttpStatusCode)expectedHttpStatusCode))
                    {
                        throw new UnexpectedTestResultException(String.Format("Failure on url [{0}] Actual [{1}] Expected [{2}].", verifiedUrl, (int)xns.httpStatus, expectedHttpStatusCode));
                    }
                }
            }

            [TestCase, Description("Invalid character in query string (also validate encoding causes the character to pass."), TestCasePriority(1)]
            // this tests uses 'Reflect/XrlScanDefault.ashx' because it is set to allow query strings of length 16 
            [CompoundCase(@"invalid char carrot",            @"/testfd/Reflect/XrlScanDefault.ashx?a^b",   404)]
            [CompoundCase(@"invalid char carrot encoded",    @"/testfd/Reflect/XrlScanDefault.ashx?a%5Eb", 200)]
            [CompoundCase(@"invalid char pound",             @"/testfd/Reflect/XrlScanDefault.ashx?a#b",   404)]
            [CompoundCase(@"invalid char pound encoded",     @"/testfd/Reflect/XrlScanDefault.ashx?a%23b", 200)]
            [CompoundCase(@"invalid char bracket",           @"/testfd/Reflect/XrlScanDefault.ashx?a[b",   404)]
            [CompoundCase(@"invalid char bracket encoded",   @"/testfd/Reflect/XrlScanDefault.ashx?a%5Bb", 200)]
            [CompoundCase(@"invalid char semicolon",         @"/testfd/Reflect/XrlScanDefault.ashx?a;b",   404)]
            [CompoundCase(@"invalid char semicolon encoded", @"/testfd/Reflect/XrlScanDefault.ashx?a%3Bb", 200)]
            class VerifyInvalidQueryStringCharacters : TestNode
            {
                public override void Run()
                {
                    string verifiedUrl = (string)MyValues[0];
                    int expectedHttpStatusCode = (int)MyValues[1];

                    CustomTransaction xns = new CustomTransaction();
                    xns.endPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.testfd);
                    xns.ServiceURL = verifiedUrl;

                    if (!XrlScanTestBase.Exec(xns, (HttpStatusCode)expectedHttpStatusCode))
                    {
                        throw new UnexpectedTestResultException(String.Format("Failure on url [{0}] Actual [{1}] Expected [{2}].", verifiedUrl, (int)xns.httpStatus, expectedHttpStatusCode));
                    }
                }
            }

            [TestCase, Description("Verify disallowed url characters are still enforced if query string is specified."), TestCasePriority(1)]
            [CompoundCase(@"invalid char star",      @"/testfd/*/ReflectNoAuthSg.ashx?", 400)]
            [CompoundCase(@"invalid char star pipe", @"/testfd/|ReflectNoAuthSg.ashx?",  404)]
            class VerifyInvalidUrlCharacterWithQueryString : TestNode
            {
                public override void Run()
                {
                    string verifiedUrl = (string)MyValues[0];
                    int expectedHttpStatusCode = (int)MyValues[1];

                    CustomTransaction xns = new CustomTransaction();
                    xns.endPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.testfd);
                    xns.ServiceURL = verifiedUrl;

                    if (!XrlScanTestBase.Exec(xns, (HttpStatusCode)expectedHttpStatusCode))
                    {
                        throw new UnexpectedTestResultException(String.Format("Failure on url [{0}] Actual [{1}] Expected [{2}].", verifiedUrl, (int)xns.httpStatus, expectedHttpStatusCode));
                    }
                }
            }

            [TestCase, Description("Verify disallowed url characters are allowed in the query string."), TestCasePriority(1)]
            // this tests uses 'Reflect/XrlScanDefault.ashx' because it is set to allow query strings of length 16 
            [CompoundCase(@"invalid char question mark", @"/testfd/Reflect/XrlScanDefault.ashx?a?b", 200)]
            [CompoundCase(@"invalid char star",          @"/testfd/Reflect/XrlScanDefault.ashx?a*b", 200)]
            [CompoundCase(@"invalid char double dot",    @"/testfd/Reflect/XrlScanDefault.ashx?a..b", 200)]
            class VerifyInvalidUrlCharacterIsValidWithQueryString : TestNode
            {
                public override void Run()
                {
                    string verifiedUrl = (string)MyValues[0];
                    int expectedHttpStatusCode = (int)MyValues[1];

                    CustomTransaction xns = new CustomTransaction();
                    xns.endPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.testfd);
                    xns.ServiceURL = verifiedUrl;

                    if (!XrlScanTestBase.Exec(xns, (HttpStatusCode)expectedHttpStatusCode))
                    {
                        throw new UnexpectedTestResultException(String.Format("Failure on url [{0}] Actual [{1}] Expected [{2}].", verifiedUrl, (int)xns.httpStatus, expectedHttpStatusCode));
                    }
                }
            }            
            
            [TestCase, Description("Verify various invalid urls"), TestCasePriority(2)]
            // Note that 404's are caught by XrlScan and 400's are caught by IIS
            [CompoundCase("invalid url querychar",      @"?", 400)]
            [CompoundCase("invalid url querychar1",     @"??", 400)]
            [CompoundCase("invalid url querychar2",     @"..?()", 400)]
            [CompoundCase("invalid url querychar3",     @"?/testfd/Reflect.ashxxx", 400)]
            [CompoundCase("invalid url extension",      @"/testfd/Reflect.ashxxx", 404)]
            [CompoundCase("invalid url extension1",     @"/testfd/Reflect.3ashxxx", 404)]
            [CompoundCase("invalid url folder",         @"/testfd1/Reflect.ashx", 404)]
            [CompoundCase("invalid url file not exist", @"/help.gif", 404)]
            [CompoundCase("invalid url above max 1024", @"/testfd/Reflect/XrlScanDefault.ashx" + // 36 chars 
                                                         @"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" + // 100 x's
                                                         @"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" + // 100 x's
                                                         @"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" + // 100 x's
                                                         @"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" + // 100 x's
                                                         @"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" + // 100 x's
                                                         @"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" + // 100 x's
                                                         @"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" + // 100 x's
                                                         @"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" + // 100 x's
                                                         @"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" + // 100 x's
                                                         @"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" + // 100 x's
                                                         @"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx", 400)]  // 100 x's
            class VerifyInvalidUrls : TestNode
            {
                public override void Run()
                {
                    string verifiedUrl = (string)MyValues[0];
                    int expectedHttpStatusCode = (int)MyValues[1];

                    CustomTransaction xns = new CustomTransaction();
                    xns.endPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.testfd);
                    xns.ServiceURL = verifiedUrl;

                    if (!XrlScanTestBase.Exec(xns, (HttpStatusCode) expectedHttpStatusCode))
                    {
                        throw new UnexpectedTestResultException(String.Format("Failure on url [{0}] Actual [{1}] Expected [{2}].", verifiedUrl, (int)xns.httpStatus, expectedHttpStatusCode));
                    }
                }
            }

            [TestCase, Description("Normalization validation."), TestCasePriority(1)]
            [CompoundCase("relative path", @"/testfd/../testfd/ReflectNoAuthSg.ashx", 200)]
            [CompoundCase("relative path url escaped dots", @"/testfd/%2e%2e/testfd/ReflectNoAuthSg.ashx?", 200)]
            [CompoundCase("url escaping", @"/%74es%74fd/ReflectNoAuthSg.ashx", 200)]
            [CompoundCase("special treatment of backslash", @"/testfd/\ReflectNoAuthSg.ashx", 200)]     // During normalization the backslash is removed
            [CompoundCase("special treatment of extra slashes", @"/testfd//ReflectNoAuthSg.ashx", 200)] // During normalization the extra slash is removed
            class VerifyNormalizedUrls : TestNode
            {
                public override void Run()
                {
                    string verifiedUrl = (string)MyValues[0];
                    int expectedHttpStatusCode = (int)MyValues[1];

                    CustomTransaction xns = new CustomTransaction();
                    xns.endPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.testfd);
                    xns.ServiceURL = verifiedUrl;

                    if (!XrlScanTestBase.Exec(xns, (HttpStatusCode)expectedHttpStatusCode))
                    {
                        throw new UnexpectedTestResultException(String.Format("Failure on url [{0}] Actual [{1}] Expected [{2}].", verifiedUrl, (int)xns.httpStatus, expectedHttpStatusCode));
                    }
                }
            }
        }
    }; //class UrlTest
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XRLScan\XrlScanTestSuite\stress.cs ===
using System;
using ServerTestFramework;
using XrlScanTestSuite.Functional;
using System.Net;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;

using xonline.common.config;

namespace XrlScanTestSuite.Stress
{
    [StressTest]
    [StressInstantiate]
    public class GetSprov : TestBase
    {
        override protected void Execute()
        {
            string url=@"/xsuppapi/cxsuppapi.asmx?sprov";

            CustomTransaction xns=new CustomTransaction();
            xns.endPoint=Global.XEnv.GetInterface(Interface.xsuppapi)[0];
            xns.ServiceURL=url;
            xns.Slot.machinePuid=2556731038455101;
            xns.Slot.userPuid0=2596271570897747;
            xns.Execute();
            if (xns.httpStatus==HttpStatusCode.OK)
                ResultCode=TEST_RESULTS.PASSED;
            else
                Global.RO.Error("Got back unexpected http response: "+xns.httpStatus);
        }
    }

    [StressTest]
    [StressInstantiate]
    public class GoodUrl : TestBase
    {
        override protected void Execute()
        { 
            string url=@"/xsuppapi/cxsuppapi.asmx?asdhasdhyuasidyasd99";

            CustomTransaction xns=new CustomTransaction();
            xns.endPoint=Global.XEnv.GetInterface(Interface.xsuppapi)[0];
            xns.ServiceURL=url;
            xns.Slot.machinePuid=2556731038455101;
            xns.Slot.userPuid0=2596271570897747;
            xns.Execute();
            if (xns.httpStatus==HttpStatusCode.NotFound)
                ResultCode=TEST_RESULTS.PASSED;
            else
                Global.RO.Error("Got back unexpected http response: "+xns.httpStatus);
        }
    }

    [StressTest]
    [StressInstantiate]
    public class BadRequest : TestBase
    {
        override protected void Execute()
        {
            string url=@"/xsuppapi/cxsuppapi.asmx?"+RandomEx.GlobalRandGen.GenerateTotallyRandomString(64);

            CustomTransaction xns=new CustomTransaction();
            xns.endPoint=Global.XEnv.GetInterface(Interface.xsuppapi)[0];
            xns.ServiceURL=url;
            xns.Slot.machinePuid=2556731038455101;
            xns.Slot.userPuid0=2596271570897747;
            xns.Execute();
            if (xns.httpStatus==HttpStatusCode.NotFound)
                ResultCode=TEST_RESULTS.PASSED;
            else
                Global.RO.Error("Got back unexpected http response: "+xns.httpStatus);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XRLScan\XrlScanTestSuite\WhiteListTest.cs ===
using System;
using ServerTestFramework;
using System.Net;
using ServerTestFramework.LiveService;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;

namespace XrlScanTestSuite.Functional
{
    [TestGroup, Owner("craigick"), TestCasePriority(1)]
    public class WhiteListTest : TestNode
    {
        [TestCase, Description("Verify all current whitelist headers succeed"), TestCasePriority(2)]
        [CompoundCase("xon normal format with number", "xon/1", 200)]
        [CompoundCase("xon normal format with character", "xon/A", 200)]
        [CompoundCase("xon normal format nothing", "xon/", 200)]
        [CompoundCase("xon invalid format pound", "xon/#", 404)]
        class VerifyXonContentType : TestNode
        {
            public override void Run()
            {
                string verifiedContentType = (string)MyValues[0];
                int expectedHttpStatusCode = (int)MyValues[1];

                CustomTransaction xns = new CustomTransaction();
                xns.endPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.testfd);
                xns.Method = "POST";
                xns.ServiceURL = "/testfd/Reflect/XrlScanDefault.ashx";

                xns.ContentType = String.Format("Content-Type: {0}", verifiedContentType);

                if (!XrlScanTestBase.Exec(xns, (HttpStatusCode)expectedHttpStatusCode))
                {
                    throw new UnexpectedTestResultException(String.Format("Unexpected HTTP status result: Actual [{0}] Expected [{1}].", (int)xns.httpStatus, (int)expectedHttpStatusCode));
                }
            }
        }

        [TestCase, Description("Verify all current whitelist headers succeed"), TestCasePriority(1)]
        class VerifyExistingWhiteList : TestNode
        {
            public override void Run()
            {
                string currentHeaders = Global.XEnv.GetSetting("xrlscan_whitelistcontenttypes");
                CustomTransaction xns = new CustomTransaction();
                xns.endPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.testfd);
                xns.Method = "POST";
                xns.ServiceURL = "/testfd/ReflectNoAuthSg.ashx";

                foreach (string header in currentHeaders.Split(','))
                {
                    xns.ContentType = "Content-Type: " + header;
                    if (!XrlScanTestBase.Exec(xns, (HttpStatusCode)HttpStatusCode.OK))
                    {
                        throw new UnexpectedTestResultException(String.Format("Unexpected HTTP status result: Actual [{0}] Expected [{1}].", (int)xns.httpStatus, (int)HttpStatusCode.OK));
                    }
                }
            }
        }

        [TestCase, Description("Tests for the new content type while list feature."), TestCasePriority(1)]
        public class ContentTypeWhiteList : TestNode
        {
            //The values here are based on XrlScan.cpp; if this constant changes this should be updated: static const DWORD SETTING_MAX_LENGTH = 256;  Note also that CSmallStr has a limit of 250.
            [TestCase, Description("Verification that XrlScan handles too-large content type headers without crashing.  The content type should always be rejected with 404 since it's not in the valid list.")]
            [CompoundCase("CSmallStr-1", 249)]
            [CompoundCase("CSmallStr+0", 250)]
            [CompoundCase("CSmallStr+1", 251)]
            [CompoundCase("HeaderSetting-4", 252)]
            [CompoundCase("HeaderSetting-3", 253)]
            [CompoundCase("HeaderSetting-2", 254)]
            [CompoundCase("HeaderSetting-1", 255)]
            [CompoundCase("HeaderSetting+0", 256)]
            [CompoundCase("HeaderSetting+1", 257)]
            [CompoundCase("HeaderSetting+2", 258)]
            class ContentTypeLength : TestNode
            {
                public override void Run()
                {
                    int contentTypeLength = (int)MyValues[0];
                    string contentType = "Content-Type: ";
                    for (int i = 0; i < contentTypeLength; ++i)
                    {
                        contentType += "x";
                    }

                    CustomTransaction xns = new CustomTransaction();
                    xns.endPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.testfd);
                    xns.Method = "POST";
                    xns.ServiceURL = "/testfd/Reflect.ashx";
                    xns.ContentType = contentType;
                    if (!XrlScanTestBase.Exec(xns, HttpStatusCode.NotFound))
                    {
                        throw new UnexpectedTestResultException("Got unexpected HTTP status result back.");
                    }
                }
            }
        } //class ContentTypeWhiteList

        [TestCase, Description("Verifies that an empty whitelist allows nothing through."), TestCasePriority(2)]
        class EmptyWhiteList : WhiteListTestBase
        {
            public EmptyWhiteList()
            {
                WhiteList = "";
            }

            public override void Run()
            {
                CustomTransaction xns = new CustomTransaction();
                xns.endPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.testfd);
                xns.Method = "POST";
                xns.ServiceURL = "/testfd/Reflect/XrlScanDefault.ashx";
                xns.ContentType = "Content-Type: text/xml";
                if (!XrlScanTestBase.Exec(xns, HttpStatusCode.NotFound))
                {
                    throw new UnexpectedTestResultException(String.Format("Unexpected HTTP status result: Actual [{1}] Expected [{2}].", (int)xns.httpStatus, (int)HttpStatusCode.NotFound));
                }
            }
        };

        [TestCase, Description("Verify specific whitelist with various combinations of values."), TestCasePriority(2)]
        class SpecificWhiteList : WhiteListTestBase
        {
            public SpecificWhiteList()
            {
                WhiteList = "test/a,test/b, test/c ,, test/d, ,test/e, ";
            }

            public override void Run()
            {
                CustomTransaction xns = new CustomTransaction();
                xns.endPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.testfd);
                xns.Method = "POST";
                xns.ServiceURL = "/testfd/ReflectNoAuthSg.ashx";

                //allowed NOTE that test/apple is allowed due to the resolution of TFS 222420
                string[] allowedTests = new string[] { "test/a", "TEST/A", "test/b", "test/c", "test/d", "test/e", "xon/9", "test/a; test/e", "test/apple", };
                foreach (string ct in allowedTests)
                {
                    xns.ContentType = "Content-Type: " + ct;
                    if (!XrlScanTestBase.Exec(xns, HttpStatusCode.OK))
                    {
                        throw new UnexpectedTestResultException(String.Format("Whitelist value [{0}] did not match as expected", ct));
                    }
                }

                //not allowed
                string[] notAllowedTests = new string[] { " ", "text/xml", ",", "/", "testing/a" };
                foreach (string ct in notAllowedTests)
                {
                    xns.ContentType = "Content-Type: " + ct;
                    if (!XrlScanTestBase.Exec(xns, HttpStatusCode.NotFound))
                    {
                        throw new UnexpectedTestResultException(String.Format("Whitelist value [{0}] matched and was expected to fail", ct));
                    }
                }
            }
        };

        [TestCase, Description("Verifies that an loading a large whitelist works correctly."), TestCasePriority(2)]
        class LongWhiteList : WhiteListTestBase
        {
            public LongWhiteList()
            {
                string contentTypes = "test/a";
                for (int i = 0; i < 600; ++i)
                    contentTypes += ",t/" + i;
                contentTypes += ",test/b";

                WhiteList = contentTypes;
            }

            public override void Run()
            {
                CustomTransaction xns = new CustomTransaction();
                xns.endPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.testfd);
                xns.Method = "POST";
                xns.ServiceURL = "/testfd/ReflectNoAuthSg.ashx";

                //allowed
                string[] allowedTests = new string[] { "test/a", "t/275" };
                foreach (string ct in allowedTests)
                {
                    xns.ContentType = "Content-Type: " + ct;
                    if (!XrlScanTestBase.Exec(xns, HttpStatusCode.OK))
                    {
                        throw new UnexpectedTestResultException(String.Format("Whitelist value [{0}] did not match as expected", ct));
                    }
                }

                //not allowed
                string[] notAllowedTests = new string[] { "text/zzz", "test/b" };
                foreach (string ct in notAllowedTests)
                {
                    xns.ContentType = "Content-Type: " + ct;
                    if (!XrlScanTestBase.Exec(xns, HttpStatusCode.NotFound))
                    {
                        throw new UnexpectedTestResultException(String.Format("Whitelist value [{0}] matched and was expected to fail", ct));
                    }
                }
            }
        };

        [TestCase, Description("Verifies that an loading a content-type string into a whitelist works correctly.  NOTE: XrlScan uses CSmallStr which limits content-types being sent in to 250 characters."), TestCasePriority(2)]
        class LargeEntryInWhiteList : WhiteListTestBase
        {
            string largeContentType;

            public LargeEntryInWhiteList()
            {
                largeContentType = "big/";
                for (int i = 0; i < 3000; ++i)
                    largeContentType += (i % 10).ToString();

                WhiteList = "test/a, " + largeContentType + ", test/b";
            }

            public override void Run()
            {
                CustomTransaction xns = new CustomTransaction();
                xns.endPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.testfd);
                xns.Method = "POST";
                xns.ServiceURL = "/testfd/ReflectNoAuthSg.ashx";

                //allowed
                string[] allowedTests = new string[] { "test/a", "test/b" };
                foreach (string ct in allowedTests)
                {
                    xns.ContentType = "Content-Type: " + ct;
                    if (!XrlScanTestBase.Exec(xns, HttpStatusCode.OK))
                    {
                        throw new UnexpectedTestResultException("Got unexpected HTTP status result back.");
                    }
                }

                //not allowed
                string trunctaedContentType0 = largeContentType.Substring(0, 249);
                string trunctaedContentType1 = largeContentType.Substring(0, 250);

                string[] notAllowedTests = new string[] { "text/xmk", largeContentType, trunctaedContentType0, trunctaedContentType1 };
                foreach (string ct in notAllowedTests)
                {
                    xns.ContentType = "Content-Type: " + ct;
                    if (!XrlScanTestBase.Exec(xns, HttpStatusCode.NotFound))
                    {
                        throw new UnexpectedTestResultException("Got unexpected HTTP status result back.");
                    }
                }
            }
        };
    
    }; //class WhiteListTest
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XRLScan\XrlScanTestSuite\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XRLScan\XrlScanTestSuite\CustomTransaction.cs ===
using System;
using System.IO;
using System.Text;
using System.Net;
using ServerTestFramework.LiveService.FakeSG;

namespace ServerTestFramework.LiveService
{
    /// <summary>
    /// Summary description for CustomTransaction.
    /// </summary>
    public class CustomTransaction : FDTransaction
    {
        public CSGInfo        Slot;
        public string        ServiceURL="";
        public string        ContentType=String.Empty;
        public XOService     XOServiceID = XOService.Feedback;
        public string        Method="POST";
        public string        CustomHeaderField = null;
        public string        hostName = null;

        public CustomTransaction()
        {
            if (GlobalFakeSG.FakeSG != null)
                Slot=GlobalFakeSG.FakeSG.GetSlot();
            Slot.userPuid0=15;
        }

        public byte[]    GenerateHttpHeader(XOService XOServiceID, MemoryStream reqStream)
        {
            if (hostName == null)
                hostName = this.endPoint.ToString();

            StringBuilder sbURL;
            sbURL = new StringBuilder();
            sbURL.Append( Method+" " );
            sbURL.Append( ServiceURL );
            sbURL.Append( " HTTP/1.1\r\n" );
            //            sbURL.Append( "Expect: 100-continue\r\n");
            if (CustomHeaderField != null)
                sbURL.Append(CustomHeaderField + "\r\n");
            sbURL.Append("Connection: Keep-Alive\r\n");
            sbURL.Append( "Host: " + hostName + "\r\n");
            if (ContentType.Length == 0)
                sbURL.Append( "Content-Type: xon/" + ((int)XOServiceID).ToString("x")+"\r\n");
            else
                sbURL.Append(ContentType+"\r\n");
            sbURL.Append( "User-Agent: "+((int)XOServiceID).ToString("x")+"/0.10.4715\r\n");
            sbURL.Append( "Content-Length: " +  reqStream.Length+"\r\n\r\n");

            System.Text.ASCIIEncoding    AE=new System.Text.ASCIIEncoding();

            return AE.GetBytes(sbURL.ToString());
        }

        /// <summary>
        /// Sends a request with garbage data
        /// </summary>
        /// <returns></returns>
        public bool Execute()
        {
            MemoryStream ms = new MemoryStream(400);
            ms.SetLength(400);
            return Execute(ms);
        }
        
        /// <summary>
        /// Sends a request with garbage data of specified length
        /// </summary>
        /// <returns></returns>
        public bool Execute(int contentLenth)
        {
            MemoryStream ms = new MemoryStream(contentLenth);
            ms.SetLength(contentLenth);
            return Execute(ms);
        }
        
        /// <summary>
        /// Sends a request
        /// </summary>
        /// <param name="reqStream">Data to be sent to the server (HTTP header will be generated automatically)</param>
        /// <returns></returns>
        public bool Execute(MemoryStream reqStream)
        {
            // We can potentially add header caching here. We'll do that later
            byte[]    httpHeader=GenerateHttpHeader(XOServiceID,reqStream);
            bool bRet = false;
            
            try
            {
                bRet=this.Execute(httpHeader, reqStream, ref Slot);
            }
            catch (System.IO.IOException)
            {
            }
            catch (System.Net.Sockets.SocketException)
            {        
            }
            finally
            {
            }

            return bRet;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XRLScan\XrlScanTestSuite\TestBase.cs ===
using System;
using ServerTestFramework;
using System.Net;
using ServerTestFramework.LiveService;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;

namespace XrlScanTestSuite.Functional
{
    public abstract class XrlScanTestBase : TestNode
    {
        public static ulong validUserPuid = 0;
        public static ulong ValidUserPuid
        {
            get
            {
                if (validUserPuid == 0)
                {
                    validUserPuid = ServerTestFramework.Database.UserEditor.CreateNew().Puid;
                }

                return validUserPuid;
            }
        }

        public static ulong validMachinePuid = 0;
        public static ulong ValidMachinePuid
        {
            get
            {
                if (validMachinePuid == 0)
                {
                    validMachinePuid = ServerTestFramework.Database.MachineEditor.CreateNew().Id;
                }

                return validMachinePuid;
            }
        }

        public static string Truncate(string s, int count)
        {
            return s.Substring(0, Math.Min(count, s.Length));
        }

        public static string GetXTouUNCPath(string server)
        {
            //first try what is normal for real environments
            string path = "\\\\" + server + "\\d$\\webroot\\xtou\\";
            if (System.IO.Directory.Exists(path))
            {
                return path;
            }

            //try what is normal for xblobs
            string xblobPath = "\\\\" + server + "\\c$\\esp\\webroot\\xtou\\";
            if (System.IO.Directory.Exists(xblobPath))
            {
                return xblobPath;
            }

            //should never get here.. fall back to the normal environment path
            Global.RO.Warn("Unable to determine the path of xtou.  Assuming a normal expanded test environment.");
            return path;
        }

        public static bool Exec(CustomTransaction xns)
        {
            return Exec(xns, HttpStatusCode.NotFound);
        }

        public static bool Exec(CustomTransaction xns, HttpStatusCode expected)
        {
            return Exec(xns, expected, 400);
        }

        public static bool Exec(CustomTransaction xns, HttpStatusCode expected, int contentLength)
        {
            Global.RO.Info("Executing: " + Truncate(xns.ServiceURL, 50));
            xns.Execute(contentLength);
            if (xns.httpStatus != expected)
            {
                Global.RO.Warn(new String('-', 50));
                Global.RO.Warn("     URL: [" + Truncate(xns.ServiceURL, 70) + "]");
                Global.RO.Warn("  Method: [" + Truncate(xns.Method, 70) + "]");
                Global.RO.Warn(" Content: [" + Truncate(xns.ContentType, 70) + "]");
                Global.RO.Warn("Returned: " + xns.httpStatus + " (" + (int)xns.httpStatus + ")");
                Global.RO.Warn("Expected: " + expected + " (" + (int)expected + ")");
                return false;
            }
            else
            {
                Global.RO.Debug(new String('-', 50));
                Global.RO.Debug("     URL: [" + Truncate(xns.ServiceURL, 70) + "]");
                Global.RO.Debug("  Method: [" + Truncate(xns.Method, 70) + "]");
                Global.RO.Debug(" Content: [" + Truncate(xns.ContentType, 70) + "]");
                Global.RO.Debug("Returned: " + xns.httpStatus + " (" + (int)xns.httpStatus + ")");
                Global.RO.Debug("Expected: " + expected + " (" + (int)expected + ")");
                return true;
            }
        }

        public static void ReloadMappings(string interfaceToReload)
        {
            IPEndPoint[] eps = Global.XEnv.GetInterface(interfaceToReload);
            foreach (IPEndPoint ep in eps)
            {
                int[] pids = ServerTestFramework.LiveService.ManagementConsole.GetIISProcessIDs(ep, "xrlscan");

                foreach (int pid in pids)
                {
                    string output;
                    string command = "e " + pid + ":xrlscan reload_mappings";
                    Global.RO.Debug("Executing xmgmt command on " + ep + ": " + command);
                    if (!ServerTestFramework.LiveService.ManagementConsole.Execute(ep, command, out output))
                    {
                        Global.RO.Warn(command + " returned failed on " + ep.Address + ": " + output);
                    }
                }

                if (pids.Length == 0)
                {
                    Global.RO.Debug("No PIDs for xrlscan found on " + ep);
                }
            }

            if (eps.Length == 0)
            {
                throw new UnexpectedTestResultException("No servers found for interface " + interfaceToReload);
            }

            System.Threading.Thread.Sleep(1000); //account for possible delay in picking up the change
        }

        public static void ReloadConfig(string interfaceToReload)
        {
            IPEndPoint[] eps = Global.XEnv.GetInterface(interfaceToReload);
            foreach (IPEndPoint ep in eps)
            {
                string output;
                string command = "e :" + interfaceToReload + " configcacherefresh";
                Global.RO.Debug("Executing xmgmt command on " + ep + ": " + command);
                if (!ServerTestFramework.LiveService.ManagementConsole.Execute(ep, command, out output))
                {
                    Global.RO.Warn(command + " returned failed on " + ep.Address + ": " + output);
                }
            }

            if (eps.Length == 0)
            {
                throw new UnexpectedTestResultException("No servers found for interface " + interfaceToReload);
            }
        }
    }

    public abstract class WhiteListTestBase : TestNode
    {
        protected string WhiteList;
        private SettingState prevSetting = null;

        public override void PreRun()
        {
            Global.RO.Debug("Setting whitelist to: " + WhiteList);
            prevSetting = Global.XEnv.OverrideSetting("testfd", "ALL", "xrlscan_whitelistcontenttypes", WhiteList);
            XrlScanTestBase.ReloadConfig("testfd");
            XrlScanTestBase.ReloadMappings("testfd");
        }

        public override void PostRun()
        {
            if (prevSetting != null)
            {
                Global.XEnv.RestoreOverrideSettingState(prevSetting);
                prevSetting = null;
                XrlScanTestBase.ReloadConfig("testfd");
                XrlScanTestBase.ReloadMappings("testfd");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XRLScan\XrlScanTestSuite\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XRLScan\XrlScanTestSuite\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xrlscantestsuite_none_12.4.56.0_none_57652a509451808e
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xrlscantestsuite_no-public-key_12.4.56.0_x-ww_18f7937a
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xrlscantestsuite
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xrlscantestsuite_no-public-key_12.4.56.0_x-ww_18f7937a
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xrlscantestsuite_no-public-key_12.4.56.0_x-ww_18f7937a.manifest
XP_MANIFEST_PATH=manifests\msil_xrlscantestsuite_no-public-key_12.4.56.0_x-ww_18f7937a.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xrlscantestsuite_no-public-key_12.4.56.0_x-ww_18f7937a.cat
XP_CATALOG_PATH=manifests\msil_xrlscantestsuite_no-public-key_12.4.56.0_x-ww_18f7937a.cat
XP_PAYLOAD_PATH=msil_xrlscantestsuite_no-public-key_12.4.56.0_x-ww_18f7937a
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xrlscantestsuite,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XRLScan\XrlScanTestSuite\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xrlscantestsuite_none_12.4.56.0_none_57652a509451808e
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xrlscantestsuite_no-public-key_12.4.56.0_x-ww_18f7937a
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xrlscantestsuite
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xrlscantestsuite_no-public-key_12.4.56.0_x-ww_18f7937a
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xrlscantestsuite_no-public-key_12.4.56.0_x-ww_18f7937a.manifest
XP_MANIFEST_PATH=manifests\msil_xrlscantestsuite_no-public-key_12.4.56.0_x-ww_18f7937a.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xrlscantestsuite_no-public-key_12.4.56.0_x-ww_18f7937a.cat
XP_CATALOG_PATH=manifests\msil_xrlscantestsuite_no-public-key_12.4.56.0_x-ww_18f7937a.cat
XP_PAYLOAD_PATH=msil_xrlscantestsuite_no-public-key_12.4.56.0_x-ww_18f7937a
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xrlscantestsuite,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\ConfigDBTest.cs ===
using System;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using xonline.common.config;

namespace XStoreTest
{
	/// <summary>
	/// Summary description for ConfigDBTest.
	/// </summary>
    [TestGroup, Owner("jkonkle"), TestFrequency("Regression"), TestCasePriority(3)]
	public class ConfigDBTest :TestNode
	{
		public ConfigDBTest()
		{
			ConfigTestBase.component= Component.stfd;
			ConfigTestBase.Interface= Interface.stfd_storage;
			Add(new ConfigTestBase(Setting.sginfo_verifyAuth,"false"));	//default is yes
			Add(new ConfigTestBase(Setting.storageFD_writeFileSqlTimeout,"30"));//default is 30
			Add(new ConfigTestBase(Setting.storageFD_removeFileSqlTimeout,"30"));//default is 30
			Add(new ConfigTestBase(Setting.storageFD_verifyAccessTokens,"false"));//default is true
			Add(new ConfigTestBase(Setting.storageFD_allowZeroUserPuidsFromInternet,"true"));//default is false
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\FuncCrossTitleDF.cs ===
using System;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Storage;
using ServerTestFramework.LiveService.Signature;
using xonline.common.config;

namespace XStoreTest
{
	internal abstract class CrossTitleDFTestBase : TestBase
	{
		protected bool RemoveFileSendAndVerify(XRLRemoveFile removeReq)
		{
			uint    titleID = removeReq.uiTitleId;
			string    pathName = removeReq.accessToken.baseAT.pathName;
            Global.RO.Info("PathName: {0}", pathName);
			XRLWriteFile    WriteReq = new XRLWriteFile("ServiceAddr", pathName);
			if(WriteReq.Execute())
			{
                Global.RO.Info("Wrote...");
				if(removeReq.Execute())
				{
                    Global.RO.Info("Deleted.");
					XRLReadFile        readReq = new XRLReadFile(pathName);
					readReq.Slot.titleId = readReq.uiTitleId = titleID;
					if(!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)) &&
						(readReq.XErr == HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
						return true;
					else
					{
						Global.RO.Warn("File was not removed: {0}", readReq.XErr);
						return false;
					}
				}
				Global.RO.Warn("RemoveFile request failed with "+Global.XErrToString(removeReq.XErr));
				return false;
			}
			return false;
		}
	}
	internal abstract class NegCrossTitleDFTestBase : TestBase
	{
		protected bool RemoveFileTestNegative(XRLRemoveFile    removeReq, uint XErr)
		{
			if (removeReq.Execute())
			{
				Global.RO.Warn("Negative RemoveFile request succeed unexpectedly");
				return false;
			}
			if(removeReq.XErr != XErr)
			{
				Global.RO.Warn("Wrong error code " + Global.XErrToString(removeReq.XErr) +" returned");
				return false;
			}
			return true;
		}
	}
    [TestGroup, Owner("JKonkle"), TestFrequency("Regression"), TestCasePriority(1)]
	public class FuncCrossTitleDF : TestNode
	{
		/**********************************************************************************
		 * Positive Wire Protocol Testing
		 *********************************************************************************/
		[TestCase, Description("check X-Delay in the http response header")]
		class PThrottling : CrossTitleDFTestBase
		{
			override protected void Execute()
			{
				uint    randomIndex = (uint)new Random().Next();
				string	pathName= "//global/t:fffe0000/tile/1/" + randomIndex.ToString("x");

				XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,(uint)new Random().Next(),"ServiceAddr");

				int Xdelay= 3000;
				Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage,"exec :stfd SetXDelay "+ removeReq.uiTitleId.ToString("X")+" removefile "+Xdelay);

				if(RemoveFileSendAndVerify(removeReq)&& (removeReq.XDelay == Xdelay))
					ResultCode=TEST_RESULTS.PASSED;

				Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage,"exec :stfd ReloadThrottleConfig");
			}
		}
		[TestCase, Description("Write a file first then call removeFile")]
		class PNormalCase : CrossTitleDFTestBase
		{
			override protected void Execute()
			{
				uint    randomIndex = (uint)new Random().Next();
				string	pathName= "//global/t:fffe0000/tile/1/" + randomIndex.ToString("x");

                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,(uint)new Random().Next(),"ServiceAddr");
				if(RemoveFileSendAndVerify(removeReq))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		// according to PM/Dev: you can only remove File from the title (i.e. dash) 
		// that you upload the file from, period!
	//	[TestCase, Description("20086:create a file with a pathname and one title ID, call RemoveFile with the same pathname but different title ID")]
		class PRemoveFromOtherTitle : TestBase
		{
			override protected void Execute()
			{
				uint    randomIndex = (uint)new Random().Next();
				string	pathName= "//global/t:fffe0000/tile/"+new Random().Next().ToString("x")+"/" + randomIndex.ToString("x");

				XRLWriteFile    WriteReq = new XRLWriteFile("ServiceAddr",pathName);
				ulong    requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
				uint	ip = 0;
				byte [] addr = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int).Address.GetAddressBytes();
				for(int i = 0; i < addr.Length; i++)
					ip = (ip << 8) + addr[i];
				HTTPAuthData authData = new HTTPAuthData((ushort) Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int).Port,
					ip,requestId,0,0x1235,(uint)XOService.Storage,0);
				authData.dwTitleVersion = WriteReq.uiTitleVersion;
				WriteReq.CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" +
					authData.GetBase64EncodedString() + "\r\n";
				WriteReq.uiTitleId = 0x1235;
				if(WriteReq.Execute())
				{
					//since pathName has t:, the removeReq will have 0xfffe0000 as sending titleID,
					// the new Random one will be ignored.
					XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,(uint)new Random().Next(),"ServiceAddr");
					if(removeReq.Execute())
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
        /*
		[TestCase, Description("remove only one ref for a file with multiple references")]
		class PRemoveFileWithMultiRef : TestBase
		{
			override protected void Execute()
			{
				uint    randomIndex = (uint)new Random().Next();
				string	pathName= "//global/t:fffe0000/tile/1/" + randomIndex.ToString("x");

				// write a blob with 4 references
				uint        title = (uint)new Random().Next();
				uint        FileWithMultiRefLen = 10240;
				byte[]        FileData = new byte[FileWithMultiRefLen];
				new Random().NextBytes(FileData);
				byte[]        FileWithMultiRefHash = new byte[Constants.sizeHash];
				new Random().NextBytes(FileWithMultiRefHash);
				int            keyValue = (int)(new Random().Next());
				string        MultiRefPath1 = "", RemovedRefPath = "";
				XRLWriteFile    wReq1 = new XRLWriteFile("ServiceAddr",pathName), wReq2 = new XRLWriteFile("ServiceAddr",pathName);
				for(int i = 0; i < 4; i++)
				{
					pathName= "//global/t:fffe0000/tile/1/" + new Random().Next().ToString("x");
					XRLWriteFile    writeReq = new XRLWriteFile("ServiceAddr",pathName);
					writeReq.blobDataLen = FileWithMultiRefLen;
					writeReq.uiBlobSizeCompressed = FileWithMultiRefLen;
					writeReq.blobData = new byte[FileWithMultiRefLen];
					FileData.CopyTo(writeReq.blobData,0);
					FileWithMultiRefHash.CopyTo(writeReq.blobHash,0);

					if(!writeReq.Execute())
					{
						Global.RO.Warn("Write File(" + i + ")failed: " + writeReq.XErr.ToString("X"));
						return;
					}
					if(i == 0)
					{
						wReq1 = writeReq;
						MultiRefPath1 = writeReq.accessToken.baseAT.pathName;
					}
					else if (i == 1)
						wReq2 = writeReq;
					// the removed Ref path will be i = 3
					RemovedRefPath = writeReq.accessToken.baseAT.pathName;
				}

				// only remove one reference to the file; the file still in the db and
				// check the i_ref_count=3
				XRLRemoveFile    removeReq = new XRLRemoveFile(RemovedRefPath,title,"ServiceAddr");
				if(removeReq.Execute())
				{
					XRLReadFile        readReq = new XRLReadFile(MultiRefPath1);
					readReq.Slot.titleId = readReq.uiTitleId = title;
					XRLReadFileResponse    resp;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out resp))
						// check ref count
						if(wReq1.CheckRefCount(wReq2,3,false))
							ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
         */
		[TestCase, Description("remove all refs for a file with multiple references")]
			class PRemoveFileWithMultiRef2 : TestBase
		{
			override protected void Execute()
			{
				string	pathName;

				// write a blob with 2 references
				uint        title = (uint)new Random().Next();
				uint        FileWithMultiRefLen = 10240;
				byte[]        FileData = new byte[FileWithMultiRefLen];
				new Random().NextBytes(FileData);
				byte[]        FileWithMultiRefHash = new byte[Constants.sizeHash];
				new Random().NextBytes(FileWithMultiRefHash);
				string        []refPath = new string[2]{"",""};
				XRLWriteFile    [] writeReq = new XRLWriteFile[2]{null, null};
				for(int i = 0; i < 2; i++)
				{
					pathName= "//global/t:fffe0000/tile/1/" + new Random().Next().ToString("x");
					writeReq[i] = new XRLWriteFile("ServiceAddr",pathName);
					writeReq[i].blobDataLen = FileWithMultiRefLen;
					writeReq[i].uiBlobSizeCompressed = FileWithMultiRefLen;
					writeReq[i].blobData = new byte[FileWithMultiRefLen];
					FileData.CopyTo(writeReq[i].blobData,0);
					FileWithMultiRefHash.CopyTo(writeReq[i].blobHash,0);
					if(!writeReq[i].Execute())
					{
						Global.RO.Warn("Write File failed:"+i);
						return;
					}
					refPath[i]=pathName;
				}

				// remove all references to the file; the file will be deleted
				XRLRemoveFile    removeReq1 = new XRLRemoveFile(refPath[0],title,"ServiceAddr");
				XRLRemoveFile    removeReq2 = new XRLRemoveFile(refPath[1],title,"ServiceAddr");
				if(removeReq1.Execute() && (removeReq2.Execute()))
				{
					XRLReadFile        readReq = new XRLReadFile(refPath[0]);
					readReq.Slot.titleId = readReq.uiTitleId = title;
					if(!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage))&&
						(readReq.XErr==HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("Call RemoveFile with invalid pathName"), TestCasePriority(2)]
		class NFileNotFound : NegCrossTitleDFTestBase
		{
			override protected void Execute()
			{
				string 	pathName= "//global/t:fffe0000/tile/1/" + new Random().Next().ToString("x");

				uint    titleID = 0x1234;
				XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
				if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass non-removeFile operation"), TestCasePriority(2)]
			class NInvalidOperation : NegCrossTitleDFTestBase
		{
			override protected void Execute()
			{
				string 	pathName= "//global/t:fffe0000/tile/1/" + new Random().Next().ToString("x");
				uint    titleID = 0x1234;
				XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
				removeReq.accessToken.baseAT.operation = (ushort)Constants.Operation.FileEnumerate;
				if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass NULL for pathName"), TestCasePriority(2)]
		class NNullPathname : NegCrossTitleDFTestBase
		{
			override protected void Execute()
			{
				uint    titleID = 0x1234;
				XRLRemoveFile    removeReq = new XRLRemoveFile(null,titleID,"ServiceAddr");

				if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\FuncCrossTitleEnumFiles.cs ===
using System;
using System.Net;
using System.Text;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Storage;
using ServerTestFramework.Utilities;
using xonline.common.config;

namespace XStoreTest
{
	internal abstract class CrossTitleEnumFilesTestBase : TestBase
	{
		//	send WriteFile requests first; then send readfile;verifies the response
		protected bool EnumFilesSendAndVerify(XRLEnumFiles enumReq, XRLWriteFile[] writeReqs, uint expectedFilesTotal, uint expectedFilesReturn, bool checkEachFile)
		{
			// write files for this title
			uint	numFiles = (uint)writeReqs.Length;
			for(int i = 0; i < numFiles; i++)
			{
				if(i % 2 ==0)
				{
					writeReqs[i].attributes = new byte[50];
					new Random().NextBytes(writeReqs[i].attributes);
					writeReqs[i].attributesLen = 50;
				}
				if(!writeReqs[i].Execute())
				{
					Global.RO.Warn("WriteFile request failed:"+ Global.XErrToString(writeReqs[i].XErr));
					return false;
				}
			}

			XRLEnumFilesResponse		enumResp;
			if(enumReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int),out enumResp))
			{
				if(enumResp.numFilesTotal != expectedFilesTotal)
				{
					Global.RO.Warn("numFilesTotal is not correct");
					return false;
				}
				if(enumResp.resultsLen != expectedFilesReturn)
				{
					Global.RO.Warn("numFiles returned is not correct");
					return false;
				}
				// check each returned file
				if(checkEachFile)
				{
					for (int i = 0; i < expectedFilesReturn; i++)
					{
						if(!enumResp.results[i].Compare(writeReqs[i]))
						{
							Global.RO.Warn("The returned file is not correct");
							return false;
						}
					}
				}
				return true;
			}
			else
			{
				Global.RO.Warn("Failed send EnumFiles request");
				return false;
			}
		}
	}

    [TestGroup, Owner("JKonkle"), TestFrequency("Regression"), TestCasePriority(1)]
	public class FuncCrossTitleEnumFiles : TestNode
	{
		[TestCase, Description("Write 10 files for a given title, pass an lmodified that 1 out of 5 matching ones will be returned")]
		class PEnumPartFiles : TestBase
		{
            private RandomEx RandGen = new RandomEx();

			override protected void Execute()
			{
                long modifiedSince = 0;
                uint TitleID = (uint)RandGen.Next();
                uint version = (uint)RandGen.Next();
                string enumXrl = "//global/t:fffe0000/ach/" + version.ToString("x") + "/*", xrl = "";
                string expectedPathName = "";
				XRLWriteFile[]	writeReqs = new XRLWriteFile[10];
				for(int i = 0; i < 10; i++)
				{
					if(i < 5)
					{
                        xrl = "//global/t:fffe0000/ach/" + version.ToString("x") + "/" + RandGen.Next().ToString("x");
						if(i == 4)
						{
							expectedPathName = xrl;
							Thread.Sleep(2000);
						}
					}
					else
                        xrl = "//global/t:fffe0000/ach/2/" + RandGen.Next().ToString("x");
					writeReqs[i] = new XRLWriteFile("ServiceAddr",xrl);
					// make sure the 10 files has 10 different blobs
					writeReqs[i].blobData[0] = (byte)i;
					if(i % 2 ==0)
					{
						writeReqs[i].attributes = new byte[50];
						new Random().NextBytes(writeReqs[i].attributes);
						writeReqs[i].attributesLen = 50;
					}
                    Global.RO.Debug("pathName == {0}", writeReqs[i].accessToken.baseAT.pathName);
					if(!writeReqs[i].Execute())
					{
                        Global.RO.Error("WriteFile request failed" + Global.XErrToString(writeReqs[i].XErr));
                        Global.RO.Error("pathName == {0}", writeReqs[i].accessToken.baseAT.pathName);
						return;
					}
					else if (i == 4)	// get the modified Time by reading the 4th file
					{
						XRLReadFile		readReq = new XRLReadFile(xrl);
						XRLReadFileResponse	readResp;
						if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
							modifiedSince = readResp.lCreationDate;
						else
						{
							Global.RO.Warn("ReadFile request failed"+ Global.XErrToString(readReq.XErr));
							return;
						}
					}
				}

				XRLEnumFilesResponse		enumResp;
				XRLEnumFiles	enumReq = new XRLEnumFiles(enumXrl,0xfffe0000,0,9,modifiedSince);
				if(enumReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int),out enumResp))
				{	// check returned results
					if(enumResp.numFilesTotal == 1 && (enumResp.resultsLen == 1))
					{
						if(String.Compare(enumResp.results[0].pathName,expectedPathName) == 0)
							ResultCode=TEST_RESULTS.PASSED;
						else
							Global.RO.Warn("Returned file is not correct;expected is "+expectedPathName+"actual returned is "+enumResp.results[0].pathName);
					}
					else
						Global.RO.Warn("numFilesTotal"+enumResp.numFilesTotal+" or numFilesResponse "+enumResp.resultsLen+" is not correct");
				}
			}
		}
		[TestCase, Description("enumerate one file and check the file's content")]
			class PEnumOneFile : CrossTitleEnumFilesTestBase
		{
			override protected void Execute()
			{
				long	modifiedSince = (long)System.DateTime.UtcNow.AddHours(-1).ToFileTimeUtc();
				uint	TitleID = 0xfffe0000;
				uint	version = (uint)new Random().Next();
				string	enumXrl = "//global/t:fffe0000/ach/"+version.ToString("x") +"/*", url = "//global/t:fffe0000/ach/"+version.ToString("x") +"/0";
				XRLWriteFile	[]writeReqs = new XRLWriteFile[1]{new XRLWriteFile("ServiceAddr",url)};
				XRLEnumFiles	enumReq = new XRLEnumFiles(enumXrl,TitleID,0,1,modifiedSince);

				if(EnumFilesSendAndVerify(enumReq,writeReqs,1,1,true))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write 10 files for a given title, enumerate all files")]
			class PEnumAllFiles : CrossTitleEnumFilesTestBase
		{
			override protected void Execute()
			{
				long	modifiedSince = (long)System.DateTime.UtcNow.AddHours(-1).ToFileTimeUtc();
				uint	TitleID = 0xfffe0000;
				uint	version = (uint)new Random().Next();
				string	enumXrl = "//global/t:fffe0000/ach/"+version.ToString("x") +"/*", url="";
				XRLWriteFile[]	writeReqs = new XRLWriteFile[10];
				for(int i = 0; i < 10; i++)
				{
					url = "//global/t:fffe0000/ach/"+version.ToString("x") +"/"+i;
					writeReqs[i] = new XRLWriteFile("ServiceAddr",url);
				}
				XRLEnumFiles	enumReq = new XRLEnumFiles(enumXrl,TitleID,0,9,modifiedSince);

				if(EnumFilesSendAndVerify(enumReq,writeReqs,10,10,false))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass rangeStart=0,rangeEnd=5")]
			class PEnumFirstFiles : CrossTitleEnumFilesTestBase
		{
			override protected void Execute()
			{
				long	modifiedSince = (long)System.DateTime.UtcNow.AddHours(-1).ToFileTimeUtc();
				uint	TitleID = 0xfffe0000;
				uint	version = (uint)new Random().Next();
				string	enumXrl = "//global/t:fffe0000/ach/"+version.ToString("x") +"/*", url ="";
				XRLWriteFile[]	writeReqs = new XRLWriteFile[10];
				for(int i = 0; i < 10; i++)
				{
					url = "//global/t:fffe0000/ach/"+version.ToString("x") +"/"+i;
					writeReqs[i] = new XRLWriteFile("ServiceAddr",url);
				}
				XRLEnumFiles	enumReq = new XRLEnumFiles(enumXrl,TitleID,0,5,modifiedSince);

				if(EnumFilesSendAndVerify(enumReq,writeReqs,10,6,false))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass rangeStart=4,rangeEnd=8")]
			class PEnumMiddleFiles : CrossTitleEnumFilesTestBase
		{
			override protected void Execute()
			{
				long	modifiedSince = (long)System.DateTime.UtcNow.AddHours(-1).ToFileTimeUtc();
				uint	TitleID = 0xfffe0000;
				uint	version = (uint)new Random().Next();
				string	enumXrl = "//global/t:fffe0000/ach/"+version.ToString("x") +"/*", url = "";
				XRLWriteFile[]	writeReqs = new XRLWriteFile[10];
				for(int i = 0; i < 10; i++)
				{
					url = "//global/t:fffe0000/ach/"+version.ToString("x") +"/"+i;
					writeReqs[i] = new XRLWriteFile("ServiceAddr",url);
				}
				XRLEnumFiles	enumReq = new XRLEnumFiles(enumXrl,TitleID,4,8,modifiedSince);

				if(EnumFilesSendAndVerify(enumReq,writeReqs,10,5,false))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass rangeStart=5,rangeEnd=9")]
			class PEnumLastFiles : CrossTitleEnumFilesTestBase
		{
			override protected void Execute()
			{
				long	modifiedSince = (long)System.DateTime.UtcNow.AddHours(-1).ToFileTimeUtc();
				uint	TitleID = 0xfffe0000;
				uint	version = (uint)new Random().Next();
				string	enumXrl = "//global/t:fffe0000/ach/"+version.ToString("x") +"/*", url="";
				XRLWriteFile[]	writeReqs = new XRLWriteFile[10];
				for(int i = 0; i < 10; i++)
				{
					url = "//global/t:fffe0000/ach/"+version.ToString("x") +"/"+i;
					writeReqs[i] = new XRLWriteFile("ServiceAddr",url);
				}
				XRLEnumFiles	enumReq = new XRLEnumFiles(enumXrl,TitleID,5,9,modifiedSince);

				if(EnumFilesSendAndVerify(enumReq,writeReqs,10,5,false))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write 10 files for a given title, pass a lModifiedSince so none is is returned")]
			class PEnumNoFiles : CrossTitleEnumFilesTestBase
		{
			override protected void Execute()
			{
				long	modifiedSince = (long)System.DateTime.UtcNow.AddDays(1).ToFileTimeUtc();
				uint	TitleID = 0xfffe0000;
				uint	version = (uint)new Random().Next();
				string	enumXrl = "//global/t:fffe0000/ach/"+version.ToString("x") +"/*", url = "";
				XRLWriteFile[]	writeReqs = new XRLWriteFile[10];
				for(int i = 0; i < 10; i++)
				{
					url = "//global/t:fffe0000/ach/"+version.ToString("x") +"/"+i;
					writeReqs[i] = new XRLWriteFile("ServiceAddr",url);
				}
				XRLEnumFiles	enumReq = new XRLEnumFiles(enumXrl,TitleID,0,5,modifiedSince);

				if(EnumFilesSendAndVerify(enumReq,writeReqs,0,0,false))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("write 5 files for a given title, pass 5 as rangeStart")]
			class PInvalidrangEnd: CrossTitleEnumFilesTestBase
		{
			override protected void Execute()
			{
				// check there should be no results returned
				long	modifiedSince = (long)System.DateTime.UtcNow.AddHours(-1).ToFileTimeUtc();
				uint	TitleID = 0xfffe0000;
				uint	version = (uint)new Random().Next();
				string	enumXrl = "//global/t:fffe0000/ach/"+version.ToString("x") +"/*", url="";
				XRLWriteFile[]	writeReqs = new XRLWriteFile[5];
				for(int i = 0; i < 5; i++)
				{
					url = "//global/t:fffe0000/ach/"+version.ToString("x") +"/"+i;
					writeReqs[i] = new XRLWriteFile("ServiceAddr",url);
				}
				XRLEnumFiles	enumReq = new XRLEnumFiles(enumXrl,TitleID,5,9,modifiedSince);

				if(EnumFilesSendAndVerify(enumReq,writeReqs,5,0,false))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("write 5 files for a given title, pass rangeStart=0,end=5")]
			class PRequestMoreFiles: CrossTitleEnumFilesTestBase
		{
			override protected void Execute()
			{
				// check there should be 5 results returned
				long	modifiedSince = (long)System.DateTime.UtcNow.AddHours(-1).ToFileTimeUtc();
				uint	TitleID = 0xfffe0000;
				uint	version = (uint)new Random().Next();
				string	enumXrl = "//global/t:fffe0000/ach/"+version.ToString("x") +"/*", url="";
				XRLWriteFile[]	writeReqs = new XRLWriteFile[5];
				for(int i = 0; i < 5; i++)
				{
					url = "//global/t:fffe0000/ach/"+version.ToString("x") +"/"+i;
					writeReqs[i] = new XRLWriteFile("ServiceAddr",url);
				}
				XRLEnumFiles	enumReq = new XRLEnumFiles(enumXrl,TitleID,0,5,modifiedSince);

				if(EnumFilesSendAndVerify(enumReq,writeReqs,5,5,false))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\AccessToken.cs ===
using System;

namespace XStoreTest
{
	/// <summary>
	/// Summary description for AccessToken.
	/// </summary>
	public class AccessToken
	{
		public AccessToken()
		{
			//
			// TODO: Add constructor logic here
			//
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\FuncAchievementsRF.cs ===
using System;
using System.Text;
using System.IO;
using System.Net;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Storage;
using xonline.common.config;
using System.Collections.Generic;
using System.Diagnostics;
using FuzzEngine;

namespace XStoreTest
{
    /// <summary>
    /// Summary description for FuncGlobalTitleRF.
    /// </summary>
    [TestGroup]
    public class FuncAchievementsRF : TestNode
    {
        private static Random random;
        public static Random Random 
        {
            get
            {
                if (random == null)
                    random = new Random((int)DateTime.Now.Ticks);
                return random;
            }

        }

        private static bool isDataInitialized = false;
        public const uint uiTitleId = 0xBAADBAAD;
        public const uint uiInitialTileId = 0x0;
        public static void InsertDummyData(uint tileId)
        {

            string url = "//global/t:" + uiTitleId.ToString("x") + "/ach/1/" + tileId.ToString("x");

			XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
			req.attributes = new byte[100];
			new Random().NextBytes(req.attributes);
			req.attributesLen = (ushort)req.attributes.Length;

            //call starts here
            bool fPassed = req.Execute();
            if (!fPassed)
            {
                Global.RO.Warn("Failed to send WriteFile request ");                
            }
        }
        public static void InitializeData()
        {
            if (!isDataInitialized)
            {
                for (uint i = uiInitialTileId; i < uiInitialTileId + 200; i++)
                {
                    InsertDummyData(i);
                }
                isDataInitialized = true;
            }
        }

        public enum ValidationType { None, Full};
        /// <summary>
        /// Calls the ReadAchievements Method and validates its results according to the specified validation type.
        /// </summary>
        /// <param name="uiTitleId">The Title Id for the achievement tiles</param>
        /// <param name="readResp">The response that the call will return (out parameter)</param>
        /// <param name="pathName">Explicit declaration of the path to call, it set to string.empty then it will be automatically generated</param>
        /// <param name="tiles">An array of Tile Ids</param>
        /// <param name="validate">The type of validation to make</param>
        /// <param name="invalidIds">If some Ids are invalid they should be specified here</param>
        /// <returns>True if the call succeeds, false if it doesn't</returns>
        public static bool CallReadAchievements(uint uiTitleId, out XRLReadAchievementsResponse readResp, string pathName, uint[] tiles, ValidationType validate, List<uint> invalidIds)
        {            
            if (pathName == string.Empty)
                pathName = String.Format("//global/t:{0}/ach/1/{1}", uiTitleId.ToString("x"), ArrayToCSV(tiles, "x"));
            readResp = new XRLReadAchievementsResponse();
            XRLReadAchievements readAchievements = new XRLReadAchievements(pathName);

            readAchievements.Slot.titleId = uiTitleId;
            readAchievements.Slot.titleVersion = 1;
            Global.RO.Info("Calling ReadTitleFiles with path " + pathName);
            bool isSuccess = readAchievements.Execute(out readResp);
            Global.RO.Info("ReadAchievements.Execute returned " + isSuccess.ToString());
            if (isSuccess && (validate != ValidationType.None))
            {
                Global.RO.Info("Validating");
                if (tiles.Length > 0)
                {
                    Global.RO.Info("More than 0 tiles to validate.");
                    if ((invalidIds == null) && (readResp.numItems != ((ushort)tiles.Length)))
                    {
                        Global.RO.Warn("Number of returned items was incorrect. Expected: " + tiles.Length.ToString() + ", Actual: " + readResp.numItems.ToString());
                        return false;
                    }
                    else
                    {
                        //Validate same Ids
                        List<uint> validateIds = new List<uint>();
                        validateIds.AddRange(tiles);
                        List<uint> Tiles = new List<uint>(tiles);
                        foreach (AchievementInfo achievement in readResp.resultItems)
                        {
                            Global.RO.Info("Validating achievement " + achievement.id.ToString("x"));
                            if (!Tiles.Contains(achievement.id) && ((invalidIds == null) || (invalidIds.Count == 0)))
                            {
                                Global.RO.Warn("Requested achievement was not found on the list of results returned. Achievement Id: " + achievement.id.ToString("x"));
                                return false;
                            }
                            else
                            {
                                if ((invalidIds != null) && invalidIds.Contains(achievement.id))
                                {
                                    Global.RO.Warn("Invalid Achievement ID appears to be returned on results. Invalid Id: " + achievement.id);
                                    return false;
                                }
                                else
                                {
                                    if (validateIds.Contains(achievement.id))
                                    {
                                        //Call ReadFile and validate the blob data
                                        XRLReadFileResponse readFileResp;
                                        if (!ReadFile(uiTitleId, achievement.id, out readFileResp))
                                        {
                                            Global.RO.Warn("Read File could not read achievement tile id: " + achievement.id + ", data was not verified.");
                                        }
                                        else
                                        {
                                            if (readFileResp.blobData.Length != achievement.blob.Length)
                                            {
                                                Global.RO.Warn("Blob data length was incorrect for achievement id: " + achievement.id);
                                                return false;
                                            }
                                            else
                                            {

                                                for (int i = 0; i < readFileResp.blobData.Length; i++)
                                                {
                                                    if (readFileResp.blobData[i] != achievement.blob[i])
                                                    {
                                                        Global.RO.Warn("Blob data length was incorrect for achievement id: " + achievement.id);
                                                        Global.RO.Warn("Byte index: " + i.ToString() + ", Byte Received: " + achievement.blob[i] + ", Byte Expected: " + readFileResp.blobData[i]);
                                                        return false;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                if (readResp == null)
                {
                    Global.RO.Info("Response was null");
                    Global.RO.Info(readAchievements.ErrorStatusMessage);
                }
                else
                {
                    Global.RO.Info(readResp.ErrorStatusMessage);
                }
            }
            return isSuccess;
        }
        /// <summary>
        /// Reads a file/tile from the server
        /// </summary>
        /// <param name="uiTitleId">Title Id of the Tile</param>
        /// <param name="tileId">Tile Id</param>
        /// <param name="readResp">The Response of the server</param>
        /// <returns>An XRLReadFileResponse object with the response of the server</returns>
        public static bool ReadFile(uint uiTitleId, uint tileId, out XRLReadFileResponse readResp)
        {
            string pathName = String.Format("//global/t:{0}/ach/1/{1}", uiTitleId.ToString("x"), tileId.ToString("x"));
            XRLReadFile readReq = new XRLReadFile(pathName);
            readReq.Slot.titleId = readReq.uiTitleId = uiTitleId; ;
            readReq.Slot.titleVersion = 1;
            readReq.uiTitleVersion = 1;
            return readReq.Execute(out readResp);
        }
        /// <summary>
        /// Converts an array of ints to a comma delimited string
        /// </summary>
        /// <param name="values">Array of Int32</param>
        /// <param name="format">The output format of the comma delimited values (use "x" for Hex)</param>
        /// <returns>A string of the values separated by commas</returns>
        public static string ArrayToCSV(uint[] values, string format)
        {
            StringBuilder str = new StringBuilder();
            foreach (int value in values)
            {
                str.Append(value.ToString(format));
                str.Append(",");
            }
            if (values.Length > 0)
                str.Remove(str.Length - 1, 1);
            return str.ToString();
        }
        /// <summary>
        /// Converts an array of ints to a comma delimited string
        /// </summary>
        /// <param name="values">Array of Int32</param>
        /// <returns>A string of the values separated by commas</returns>
        public static string ArrayToCSV(uint[] values)
        {
            StringBuilder str = new StringBuilder();
            foreach (uint value in values)
            {
                str.Append(value.ToString());
                str.Append(",");
            }
            if (values.Length > 0)
                str.Remove(str.Length - 1, 1);
            return str.ToString();
        }

        [TestCase, Owner("isaiasfs"), Description("Test to compare single file performance vs multiple file performance")]
        [Ignore]
        class PerfDownloadTilesCompare : TestBase
        {
            override protected void Execute()
            {
                InitializeData();
                const int nTiles = 25; 
                long readFileMs = 0;
                long readAchievementsMs = 0;
                int cycles = 100; 
                uint[] ids = new uint[nTiles];
                XRLReadAchievementsResponse dummyResponse;
                XRLReadFileResponse dummyResponse2;
                for (int i = 0; i < ids.Length; i++)
                {
                    ids[i] = (uint)(uiInitialTileId+i);
                }




                for (int i = 0; i < nTiles; i++)
                {
                    ReadFile(uiTitleId, ids[i], out dummyResponse2);
                }

                if (!CallReadAchievements(uiTitleId, out dummyResponse, string.Empty, ids, ValidationType.None, null))
                    Global.RO.Warn("Warmup failed for ReadAchievements");

                DateTime startReadFile;
                DateTime startReadAchievements;
                ResultCode = TEST_RESULTS.PASSED;
                for (int i = 0; i < cycles; i++)
                {
                    startReadFile = DateTime.Now;
                    for (int j = 0; j < nTiles; j++)
                    {
                        if (!ReadFile(uiTitleId, ids[j], out dummyResponse2))
                        {
                            Global.RO.Error("Call Read File failed on the " + i.ToString() + " cycle.");
                            ResultCode = TEST_RESULTS.FAILED;
                        }
                    }
                    readFileMs += DateTime.Now.Subtract(startReadFile).Ticks;
                    startReadAchievements = DateTime.Now;
                    if (!CallReadAchievements(uiTitleId, out dummyResponse, string.Empty, ids, ValidationType.None, null))
                    {
                        Global.RO.Error("Call Read Achievements failed on the " + i.ToString() + " cycle.");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                    readAchievementsMs += DateTime.Now.Subtract(startReadAchievements).Ticks;
                }
                Global.RO.Info(String.Format("Ticks on Read File: " + readFileMs.ToString()));
                Global.RO.Info(String.Format("Ticks on Read Achievements: " + readAchievementsMs.ToString()));
                if (readFileMs < readAchievementsMs)
                {
                    Global.RO.Error(String.Format("Performance on ReadTitleFiles has gone down to worse than ReadFile"));
                    ResultCode = TEST_RESULTS.FAILED;
                }

            }
        }
        [TestCase, Owner("isaiasfs"), Description("Test to meassure new performance with 100 Titles")]
        [Ignore]
        class PerfHundredTitles : TestBase
        {
            override protected void Execute()
            {
                InitializeData();
                const int nTiles = 25; 
                int cycles = 100; 
                uint[] ids = new uint[nTiles];
                XRLReadAchievementsResponse dummyResponse;
                for (int i = 0; i < ids.Length; i++)
                {
                    ids[i] = (uint)(uiInitialTileId+i);
                }

                CallReadAchievements(uiTitleId, out dummyResponse, string.Empty, ids, ValidationType.None, null);
                
                DateTime startReadAchievements;
                ResultCode = TEST_RESULTS.PASSED;
                long readAchievementsMs = 0;
                for (int i = 0; i < cycles; i++)
                {
                    startReadAchievements = DateTime.Now;
                    if (!CallReadAchievements(uiTitleId, out dummyResponse, string.Empty, ids, ValidationType.None, null))
                    {
                        Global.RO.Error("Call Read Achievements failed on the " + i.ToString() + " cycle.");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                    readAchievementsMs += DateTime.Now.Subtract(startReadAchievements).Ticks;
                }
                Global.RO.Info(String.Format("Ticks on Read Achievements: " + readAchievementsMs.ToString()));

            }
        }
        [TestCase, Owner("isaiasfs"), Description("Test to meassure old performance with 100 Titles")]
        [Ignore]
        class PerfHundredTitlesOld : TestBase
        {
            override protected void Execute()
            {
                InitializeData();
                const int nTiles = 25;
                int cycles = 100;
                uint[] ids = new uint[nTiles];
                XRLReadFileResponse dummyResponse;
                for (int i = 0; i < ids.Length; i++)
                {
                    ids[i] = (uint)(uiInitialTileId+i);
                    ReadFile(uiTitleId, ids[i], out dummyResponse);
                }

                DateTime startReadAchievements;
                ResultCode = TEST_RESULTS.PASSED;
                long readAchievementsMs = 0; 
                for (int i = 0; i < cycles; i++)
                {
                    startReadAchievements = DateTime.Now;
                    for (int j = 0; j < nTiles; j++)
                    {
                        if (!ReadFile(uiTitleId, ids[j], out dummyResponse))
                        {
                            Global.RO.Error("Failed to get Tile Id: " + ids[j]);
                            ResultCode = TEST_RESULTS.FAILED;
                            return;
                        }
                    }
                    readAchievementsMs += DateTime.Now.Subtract(startReadAchievements).Ticks;
                }
                Global.RO.Info(String.Format("Ticks on Read Achievements: " + readAchievementsMs.ToString()));
            }
        }
        [TestCase, Owner("isaiasfs"), Description("Tests with 50 Achievement Tiles")]
        class ValidTitleId50Achievements : TestBase
        {
            override protected void Execute()
            {
                InitializeData();
                const int nTiles = 50;
                uint[] ids = new uint[nTiles];
                for (int i = 0; i < ids.Length; i++)
                {
                    ids[i] = (uint)(uiInitialTileId+i);
                }
                XRLReadAchievementsResponse dummyResponse;
                string desc = "TitleId: " + uiTitleId + ", Achievement Count: " + nTiles.ToString() + ", Tiles: " + ArrayToCSV(ids);

                ResultCode = TEST_RESULTS.PASSED;
                if (!CallReadAchievements(uiTitleId, out dummyResponse, string.Empty, ids, ValidationType.Full, null))
                {
                    Global.RO.Error("Failed to get the valid tiles.");
                    ResultCode = TEST_RESULTS.FAILED;
                }
                
            }
        }
        [TestCase, Owner("isaiasfs"), Description("Tests with 51 Achievement Tiles")]
        class ValidTitleId51Achievements : TestBase
        {
            override protected void Execute()
            {
                InitializeData();
                const int nTiles = 51; 
                uint[] ids = new uint[nTiles];
                XRLReadAchievementsResponse dummyResponse;
                for (int i = 0; i < ids.Length; i++)
                {
                    ids[i] = (uint)(uiInitialTileId+i);
                }
                string desc = "TitleId: " + uiTitleId + ", Achievement Count: " + nTiles.ToString() + ", Tiles: " + ArrayToCSV(ids);

                ResultCode = TEST_RESULTS.PASSED;
                if (CallReadAchievements(uiTitleId, out dummyResponse, string.Empty, ids, ValidationType.Full, null))
                {
                    Global.RO.Error("Call should failed because it went over the tile request limit (51).");
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }
        [TestCase, Owner("isaiasfs"), Description("Tests with 0 Achivement Tiles")]
        class ValidTitleId0Achievements : TestBase
        {
            override protected void Execute()
            {
                InitializeData();
                const int nTiles = 0; 
                uint[] ids = new uint[nTiles];
                XRLReadAchievementsResponse dummyResponse;
                string desc = "TitleId: " + uiTitleId + ", Achievement Count: " + nTiles.ToString() + ", Tiles: " + ArrayToCSV(ids);
                if (CallReadAchievements(uiTitleId, out dummyResponse, string.Empty, ids, ValidationType.None, null))
                {
                    Global.RO.Error("Got a response when requested zero tiles.");
                    ResultCode = TEST_RESULTS.FAILED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.PASSED;                
                }

            }
        }
        [TestCase, Owner("isaiasfs"), Description("Tests with 0 Achivement Tiles")]
        class ValidTitleId1Achievement : TestBase
        {
            override protected void Execute()
            {
                InitializeData();
                const int nTiles = 1;
                uint[] ids = new uint[nTiles];
                for (int i = 0; i < ids.Length; i++)
                {
                    ids[i] = (uint)(uiInitialTileId+i);
                }
                
                XRLReadAchievementsResponse dummyResponse;
                Global.RO.Info("TitleId: " + uiTitleId + ", Achievement Count: " + nTiles.ToString() + ", Tiles: " + ArrayToCSV(ids));
                if (CallReadAchievements(uiTitleId, out dummyResponse, string.Empty, ids, ValidationType.Full, null))
                {                    
                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    Global.RO.Error("Calling 1 achievement failed.");
                    ResultCode = TEST_RESULTS.FAILED;
                }

            }
        }
        [TestCase, Owner("isaiasfs"), Description("Tests with 25 Achievement Tiles")]
        class ValidTitleId25Achievements : TestBase
        {
            override protected void Execute()
            {
                InitializeData();
                const int nTiles = 25; 
                uint[] ids = new uint[nTiles];
                for (int i = 0; i < ids.Length; i++)
                {
                    ids[i] = (uint)(uiInitialTileId+i);
                }
                XRLReadAchievementsResponse dummyResponse;
                string desc = "TitleId: " + uiTitleId + ", Achievement Count: " + nTiles.ToString() + ", Tiles: " + ArrayToCSV(ids);

                ResultCode = TEST_RESULTS.PASSED;
                if (!CallReadAchievements(uiTitleId, out dummyResponse, string.Empty, ids, ValidationType.Full, null))
                {
                    Global.RO.Error("Failed to get the valid tiles.");
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }
        [TestCase, Owner("isaiasfs"), Description("Tests with negative Tile Id in hex")]
        class ValidTitleIdNegativeAchievementId : TestBase
        {
            override protected void Execute()
            {
                InitializeData();
                const int nTiles = 25; 
                uint[] ids = new uint[nTiles];
                for (int i = 0; i < ids.Length; i++)
                {
                    ids[i] = (uint)(uiInitialTileId+i);
                }
                unchecked
                {
                    ids[4] = (uint)-5;
                }
                List<uint> invalidIds = new List<uint>();
                invalidIds.Add(ids[4]);
                XRLReadAchievementsResponse dummyResponse;
                string desc = "TitleId: " + uiTitleId + ", Achievement Count: " + nTiles.ToString() + ", Tiles: " + ArrayToCSV(ids);

                ResultCode = TEST_RESULTS.PASSED;
                if (!CallReadAchievements(uiTitleId, out dummyResponse, string.Empty, ids, ValidationType.Full, invalidIds))
                {
                    Global.RO.Info(desc);
                    Global.RO.Error("Failed to get the valid tiles.");                    
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }
        [TestCase, Owner("isaiasfs"), Description("Tests with negative Tile Id in dec")]
        class ValidTitleIdNegativeAchievementId2 : TestBase
        {
            override protected void Execute()
            {
                InitializeData();
                const int nTiles = 25; 
                uint[] ids = new uint[nTiles];
                for (int i = 0; i < ids.Length; i++)
                {
                    ids[i] = (uint)(uiInitialTileId+i);
                }
                unchecked
                {
                    ids[4] = (uint)-1;
                }
                List<uint> invalidIds = new List<uint>();
                invalidIds.Add(ids[4]);
                XRLReadAchievementsResponse dummyResponse;
                string pathName = String.Format("//global/t:{0}/ach/0/{2}", uiTitleId.ToString("x"), ids.Length.ToString(), ArrayToCSV(ids, "x"));
                pathName = pathName.Replace("ffffffff", "-1");
                string desc = "TitleId: " + uiTitleId + ", Achievement Count: " + nTiles.ToString() + ", Tiles: " + ArrayToCSV(ids).Replace("ffffffff", "-1");

                ResultCode = TEST_RESULTS.PASSED;
                if (!CallReadAchievements(uiTitleId, out dummyResponse, pathName, ids, ValidationType.Full, invalidIds))
                {
                    Global.RO.Info(desc);                    
                    Global.RO.Error("Failed to get the valid tiles.");
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }
        [TestCase, Owner("isaiasfs"), Description("Tests with 51 Achievement Tiles and F Achievement ID")]
        class ValidTitleId51AchievementsAchievementF : TestBase
        {
            override protected void Execute()
            {
                InitializeData();
                const int nTiles = 51;
                uint[] ids = new uint[nTiles];
                XRLReadAchievementsResponse dummyResponse;
                for (int i = 0; i < ids.Length; i++)
                {
                    ids[i] = (uint)(uiInitialTileId+i);
                }
                string desc = "TitleId: " + uiTitleId + ", Achievement Count: " + nTiles.ToString() + ", Tiles: " + ArrayToCSV(ids);

                ResultCode = TEST_RESULTS.PASSED;
                if (CallReadAchievements(uiTitleId, out dummyResponse, string.Empty, ids, ValidationType.Full, null))
                {
                    Global.RO.Error("Call should failed because it went over the tile request limit (51).");
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }
        [TestCase, Owner("isaiasfs"), Description("Tests with 51 Achievement Tiles and 0 Achievement ID")]
        class ValidTitleId51AchievementsAchievement0 : TestBase
        {
            override protected void Execute()
            {
                InitializeData();
                const int nTiles = 51;
                uint[] ids = new uint[nTiles];
                XRLReadAchievementsResponse dummyResponse;
                for (int i = 0; i < ids.Length; i++)
                {
                    ids[i] = (uint)(uiInitialTileId+i);
                }
                string desc = "TitleId: " + uiTitleId + ", Achievement Count: " + nTiles.ToString() + ", Tiles: " + ArrayToCSV(ids);

                ResultCode = TEST_RESULTS.PASSED;
                if (CallReadAchievements(uiTitleId, out dummyResponse, string.Empty, ids, ValidationType.Full, null))
                {
                    Global.RO.Error("Call should failed because it went over the tile request limit (51).");
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }
        [TestCase, Owner("isaiasfs"), Description("Tests with 25 Achievement Tiles, Invalid Title ID")]
        class InvalidTitleId25AchievementsAchievement : TestBase
        {
            override protected void Execute()
            {
                const int nTiles = 25;
                uint uiTitleId = 0xBBBBBBBB;
                uint[] ids = new uint[nTiles];
                XRLReadAchievementsResponse dummyResponse;
                for (int i = 0; i < ids.Length; i++)
                {
                    ids[i] = (uint)(uiInitialTileId+i);
                }
                string desc = "TitleId: " + uiTitleId + ", Achievement Count: " + nTiles.ToString() + ", Tiles: " + ArrayToCSV(ids);

                ResultCode = TEST_RESULTS.PASSED;
                if (!CallReadAchievements(uiTitleId, out dummyResponse, string.Empty, ids, ValidationType.None, null))
                {
                    Global.RO.Error("Call failed when calling for an invalid TitleID");
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }
        [TestCase, Owner("isaiasfs"), Description("Tests with 50 Achievement Tiles, Invalid Title ID and -1")]
        class InvalidTitleId50AchievementsNegativeAchievement : TestBase
        {
            override protected void Execute()
            {
                const int nTiles = 50;
                uint uiTitleId = 0xBBBBBBBB;
                uint[] ids = new uint[nTiles];
                XRLReadAchievementsResponse dummyResponse;
                for (int i = 0; i < ids.Length; i++)
                {
                    ids[i] = (uint)(uiInitialTileId+i);
                }
                unchecked
                {
                    ids[4] = (uint)-1;
                }
                List<uint> invalidIds = new List<uint>();
                invalidIds.Add(ids[4]);                
                string pathName = String.Format("//global/t:{0}/ach/0/{2}", uiTitleId.ToString("x"), ids.Length.ToString(), ArrayToCSV(ids, "x"));
                pathName = pathName.Replace("ffffffff", "-1");
                string desc = "TitleId: " + uiTitleId + ", Achievement Count: " + nTiles.ToString() + ", Tiles: " + ArrayToCSV(ids).Replace("ffffffff", "-1");

                ResultCode = TEST_RESULTS.PASSED;
                if (!CallReadAchievements(uiTitleId, out dummyResponse, pathName, ids, ValidationType.None, invalidIds))
                {
                    Global.RO.Info(desc);
                    Global.RO.Error("Failed to get the valid tiles.");
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }
        [TestCase, Owner("isaiasfs"), Description("Tests with 1 Achievement Tiles, Invalid Title ID and F")]
        class InvalidTitleId1AchievementsFAchievement : TestBase
        {
            override protected void Execute()
            {
                const int nTiles = 1;
                uint uiTitleId = 0xBBBBBBBB;
                uint[] ids = new uint[nTiles];
                XRLReadAchievementsResponse dummyResponse;
                for (int i = 0; i < ids.Length; i++)
                {
                    ids[i] = (uint)(uiInitialTileId+i);
                }
                ids[0] = 0xf; 
                string desc = "TitleId: " + uiTitleId + ", Achievement Count: " + nTiles.ToString() + ", Tiles: " + ArrayToCSV(ids);

                ResultCode = TEST_RESULTS.PASSED;
                if (!CallReadAchievements(uiTitleId, out dummyResponse, string.Empty, ids, ValidationType.None, null))
                {
                    Global.RO.Error("Call failed when calling for an invalid TitleID");
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }
        [TestCase, Owner("isaiasfs"), Description("Tests with 25 Achievement Tiles, Invalid Title ID and g")]
        class InvalidTitleId25AchievementsGAchievement : TestBase
        {
            override protected void Execute()
            {
                uint uiTitleId = 0xBBBBBBBB;
                XRLReadAchievementsResponse dummyResponse;
                string pathName = "//global/t:0xFFFE07D1/ach/0/1,2,3,4,5,6,7,8,9,a,b,c,d,e,f,g,11,12,13,14,15,16";
                string desc = pathName;

                ResultCode = TEST_RESULTS.PASSED;
                if (CallReadAchievements(uiTitleId, out dummyResponse, pathName, null, ValidationType.None, null))
                {
                    Global.RO.Info(desc);
                    Global.RO.Error("Failed to get the valid tiles.");
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }
        [TestCase, Owner("isaiasfs"), Description("Tests with 50 Achievement Tiles, Invalid Title ID")]
        class InvalidTitleId50AchievementsAchievement : TestBase
        {
            override protected void Execute()
            {
                const int nTiles = 50;
                uint uiTitleId = 0xBBBBBBBB;
                uint[] ids = new uint[nTiles];
                XRLReadAchievementsResponse dummyResponse;
                for (int i = 0; i < ids.Length; i++)
                {
                    ids[i] = (uint)(uiInitialTileId+i);
                }
                string desc = "TitleId: " + uiTitleId + ", Achievement Count: " + nTiles.ToString() + ", Tiles: " + ArrayToCSV(ids);

                ResultCode = TEST_RESULTS.PASSED;
                if (!CallReadAchievements(uiTitleId, out dummyResponse, string.Empty, ids, ValidationType.None, null))
                {
                    Global.RO.Error("Call failed when calling for an invalid TitleID");
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }
        [TestCase, Owner("isaiasfs"), Description("Tests with invalid scope")]
        class InvalidScope1 : TestBase
        {
            override protected void Execute()
            {
                const int nTiles = 25;
                uint[] ids = new uint[nTiles];
                for (int i = 0; i < ids.Length; i++)
                {
                    ids[i] = (uint)(uiInitialTileId+i);
                }
                unchecked
                {
                    ids[4] = (uint)-1;
                }
                List<uint> invalidIds = new List<uint>();
                invalidIds.Add(ids[4]);
                XRLReadAchievementsResponse dummyResponse;
                string pathName = String.Format("//invalid/t:{0}/ach/0/{2}", uiTitleId.ToString("x"), ids.Length.ToString(), ArrayToCSV(ids, "x"));
                pathName = pathName.Replace("ffffffff", "-1");
                string desc = "TitleId: " + uiTitleId + ", Achievement Count: " + nTiles.ToString() + ", Tiles: " + ArrayToCSV(ids).Replace("ffffffff", "-1");

                ResultCode = TEST_RESULTS.PASSED;
                if (CallReadAchievements(uiTitleId, out dummyResponse, pathName, ids, ValidationType.Full, invalidIds))
                {
                    Global.RO.Info(desc);
                    Global.RO.Error("Succeded with an invalid titleId.");
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }
        [TestCase, Owner("isaiasfs"), Description("Tests with 50 Achievement Tiles")]
        class InvalidTitleId50Achievements : TestBase
        {
            override protected void Execute()
            {
                const int nTiles = 50;
                uint uiTitleId = 0xBBBBBBBB;
                uint[] ids = new uint[nTiles];
                for (int i = 0; i < ids.Length; i++)
                {
                    ids[i] = (uint)(uiInitialTileId+i);
                }
                XRLReadAchievementsResponse dummyResponse;
                string desc = "TitleId: " + uiTitleId + ", Achievement Count: " + nTiles.ToString() + ", Tiles: " + ArrayToCSV(ids).Replace("ffffffff", "-1");

                ResultCode = TEST_RESULTS.PASSED;
                if (!CallReadAchievements(uiTitleId, out dummyResponse, string.Empty, ids, ValidationType.None, null))
                {
                    Global.RO.Info(desc);
                    Global.RO.Error("Failed with an invalid titleId.");
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }
        [TestCase, Owner("isaiasfs"), Description("Tests with negative Tile Id in dec")]
        class InvalidTitleIdAchievementIdG : TestBase
        {
            override protected void Execute()
            {
                const int nTiles = 25;
                uint uiTitleId = 0xBBBBBBBB;
                uint[] ids = new uint[nTiles];
                for (int i = 0; i < ids.Length; i++)
                {
                    ids[i] = (uint)(uiInitialTileId+i);
                }
                unchecked
                {
                    ids[4] = (uint)-1;
                }
                List<uint> invalidIds = new List<uint>();
                invalidIds.Add(ids[4]);
                XRLReadAchievementsResponse dummyResponse;
                string pathName = String.Format("//global/t:{0}/ach/0/{2}", uiTitleId.ToString("x"), ids.Length.ToString(), ArrayToCSV(ids, "x"));
                pathName = pathName.Replace("ffffffff", "g");
                string desc = "TitleId: " + uiTitleId + ", Achievement Count: " + nTiles.ToString() + ", Tiles: " + ArrayToCSV(ids).Replace("ffffffff", "-1");

                ResultCode = TEST_RESULTS.PASSED;
                if (!CallReadAchievements(uiTitleId, out dummyResponse, pathName, ids, ValidationType.None, invalidIds))
                {
                    Global.RO.Info(desc);
                    Global.RO.Error("Failed to get the valid tiles.");
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }
        [TestCase, Owner("isaiasfs"), Description("Tests with invalid scope 2")]
        class InvalidScope2 : TestBase
        {
            override protected void Execute()
            {
                const int nTiles = 25;
                uint[] ids = new uint[nTiles];
                for (int i = 0; i < ids.Length; i++)
                {
                    ids[i] = (uint)(uiInitialTileId+i);
                }
                unchecked
                {
                    ids[4] = (uint)-1;
                }
                List<uint> invalidIds = new List<uint>();
                invalidIds.Add(ids[4]);
                XRLReadAchievementsResponse dummyResponse;
                string pathName = String.Format("///t:{0}/ach/0/{2}", uiTitleId.ToString("x"), ids.Length.ToString(), ArrayToCSV(ids, "x"));
                pathName = pathName.Replace("ffffffff", "-1");
                string desc = "TitleId: " + uiTitleId + ", Achievement Count: " + nTiles.ToString() + ", Tiles: " + ArrayToCSV(ids).Replace("ffffffff", "-1");

                ResultCode = TEST_RESULTS.PASSED;
                if (CallReadAchievements(uiTitleId, out dummyResponse, pathName, ids, ValidationType.Full, invalidIds))
                {
                    Global.RO.Info(desc);
                    Global.RO.Error("Succeded with emtpy scope.");
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        [TestCase, Owner("isaiasfs"), Description("Fuzz test with 300,000 itetarions (MS Standard)")]
        [Ignore]
        class FuzzPathTest : TestBase 
        {
            override protected void Execute()
            {
                const int iterations = 300000;
                XRLReadAchievementsResponse dummyResponse;
                CharacterBag cbItem = new CharacterBag("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz01234567890+-&; <>/\\,.");
                for (int i=0; i < iterations; i++)
                {
                    string[] values = new string[4];
                    values[0] = StringFuzzer.Generate((uint)Random.Next(1000), cbItem);
                    values[1] = StringFuzzer.Generate((uint)Random.Next(1000), cbItem);
                    values[2] = StringFuzzer.Generate((uint)Random.Next(1000), cbItem);
                    values[3] = StringFuzzer.Generate((uint)Random.Next(1000), cbItem);
                    string pathName = String.Format("///t:{0}/{1}/{2}/{3}", values[0], values[1], values[2], values[3]);
                    ResultCode = TEST_RESULTS.PASSED;
                    if (CallReadAchievements(0, out dummyResponse, pathName, null, ValidationType.None, null))
                    {
                        Global.RO.Error("Succeded with fuzzfile: " + pathName);
                    }
                }
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\FuncCrossTitleRF.cs ===
using System;
using System.Text;
using System.IO;
using System.Net;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Storage;
using xonline.common.config;

namespace XStoreTest
{
	internal abstract class NegCrossTitleRFTestBase : TestBase
	{
		//	send readFile requests, then check the error code
		protected bool ReadFileTestNegative(XRLReadFile ReadFileReq, uint XErr)
		{
			XRLReadFileResponse	ReadFileResp;
			if (ReadFileReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out ReadFileResp))
			{
				Global.RO.Warn("Negative ReadFile request succeed unexpectedly");
				return false;
			}
			if((ReadFileReq.XErr != XErr) || (ReadFileResp != null))
			{
				Global.RO.Warn("Wrong error code " + Global.XErrToString(ReadFileReq.XErr) +" returned or ReadFileResp is not null");
				return false;
			}
			return true;
		}
	}
	/// <summary>
	/// Summary description for FuncCrossTitleRF.
	/// </summary>
    [TestGroup, Owner("JKonkle"), TestFrequency("Regression"), TestCasePriority(1)]
	public class FuncCrossTitleRF : TestNode
	{
		[TestCase, Description("read a file from cache")]
		class PReadFromCache : TestBase
		{
			override protected void Execute()
			{
				uint    randomIndex = (uint)new Random().Next();
				string	pathName= "//global/t:fffe0000/icon/1/" + randomIndex.ToString("x");

				XRLWriteFile	writeReq = new XRLWriteFile("ServiceAddr",pathName);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp, readResp2;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId+1;;
					if(readReq.Execute(Global.XEnv.GetInterface(Interface.stfd_storage)[0],out readResp))
					{
						// the file now is in the cache; remove it 
						XRLRemoveFile	removeReq = new XRLRemoveFile(pathName, 0x1234,"ServiceAddr");
						if(removeReq.Execute())
						{
							XRLReadFile		readReq2 = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
							readReq2.Slot.titleId = readReq2.uiTitleId = 0x123;
							readReq2.Slot.titleVersion = readReq2.uiTitleVersion;
							if(readReq2.Execute(Global.XEnv.GetInterface(Interface.stfd_storage)[0], out readResp2))
								ResultCode=TEST_RESULTS.PASSED;
						}
					}
				}
			}
		}
		[TestCase, Description("read a file from different title")]
		class PReadFromOtherTitle : TestBase
		{
			override protected void Execute()
			{
				uint    randomIndex = (uint)new Random().Next();
				string	pathName= "//global/t:fffe0000/icon/1/" + randomIndex.ToString("x");

				XRLWriteFile	writeReq = new XRLWriteFile("ServiceAddr",pathName);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId + 1;;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
					{
						ResultCode=TEST_RESULTS.PASSED;
					}
				}
			}
		}
		[TestCase, Description("Write a file first; then read the file with ifModifiedSince>actualModifiedTime")]
			class PModifiedSince : TestBase
		{
			override protected void Execute()
			{
				uint    randomIndex = (uint)new Random().Next();
				string	pathName= "//global/t:fffe0000/icon/1/" + randomIndex.ToString("x");

				XRLWriteFile	writeReq = new XRLWriteFile("ServiceAddr",pathName);

				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.lIfModifiedSinceDate = (long)System.DateTime.UtcNow.AddHours(2).ToFileTimeUtc();
					if(!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp)&&
						(readReq.XErr == HResult.XONLINE_S_STORAGE_FILE_NOT_MODIFIED) && (readResp == null))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("pass null for AccessToken"), TestCasePriority(2)]
			class NAccessTokenNullAT : NegCrossTitleRFTestBase
		{
			override protected void Execute()
			{
				uint    randomIndex = (uint)new Random().Next();
				string	pathName= "//global/t:fffe0000/icon/1/" + randomIndex.ToString("x");
				XRLReadFile		readReq = new XRLReadFile(pathName);
				readReq.accessToken = null;

				if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode = TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass non-readfile operation in the AT"), TestCasePriority(2)]
			class NAccessTokenMismatchedOp : NegCrossTitleRFTestBase
		{
			override protected void Execute()
			{
				uint    randomIndex = (uint)new Random().Next();
				string	pathName= "//global/t:fffe0000/icon/1/" + randomIndex.ToString("x");
				XRLReadFile		readReq = new XRLReadFile(pathName);
				readReq.accessToken.baseAT.operation = (ushort)Constants.Operation.FileWrite;

				if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode = TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("write file first, then request it with non-zero flags"), TestCasePriority(2)]
		class NAccessTokenWrongFlags : NegCrossTitleRFTestBase
		{
			override protected void Execute()
			{
				uint    randomIndex = (uint)new Random().Next();
				string	pathName= "//global/t:fffe0000/icon/1/" + randomIndex.ToString("x");

				XRLWriteFile	writeReq = new XRLWriteFile("ServiceAddr",pathName);
				if(writeReq.Execute())
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.accessToken.baseAT.flags = 1;
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
		/**********************************************************************
		 * Other ReadFile Testing Cases
		 **********************************************************************/
		[TestCase, Description("Multiple threads read same file simultaneously")]
			class PMultiThreadsReadFile : TestBase
		{
			override protected void Execute()
			{
				uint    randomIndex = (uint)new Random().Next();
				string	xrl= "//global/t:fffe0000/icon/1/" + randomIndex.ToString("x");

				XRLWriteFile	writeReq = new XRLWriteFile("ServiceAddr",xrl);
				pathName = writeReq.accessToken.baseAT.pathName;
				uiTitleId = writeReq.uiTitleId;
				uiTitleVersion = writeReq.uiTitleVersion;

				if(writeReq.Execute())
				{
					Thread [] threadArray = new Thread[10];
					for(int i = 0; i < 10; i++)
					{
                        threadArray[i] = ThreadMaker.CreateThread(readFileTS);
						threadArray[i].Start();
					}
					// the main thread is waiting for all threads to exit or timeout
					foreach (Thread t in threadArray)
						t.Join(1000);
					if(FailedReqs == 0)
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
			private void readFileTS()
			{
				XRLReadFileResponse	readResp;
				XRLReadFile		readReq = new XRLReadFile(pathName);

				if(!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out readResp))
				{
					Global.RO.Warn("readFileTS: read file request failed");
					Interlocked.Increment(ref FailedReqs);
				}
			}
			private string	pathName;
			private uint	uiTitleId, uiTitleVersion;
			private int		FailedReqs;
		}
		[TestCase, Description("read file 100 times and check bi_read_count in t_files")]
		class PReadFileMultiTimes : TestBase
		{
			override protected void Execute()
			{
				uint    randomIndex = (uint)new Random().Next();
				string	pathName= "//global/t:fffe0000/icon/1/" + randomIndex.ToString("x");

				XRLWriteFile	writeReq = new XRLWriteFile("ServiceAddr",pathName);
				if(writeReq.Execute())
				{
					uint				uiFailedReq = 0;
					for(int i = 0; i < 100; i++)
					{
						XRLReadFileResponse	readResp;
						XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
						if(!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
							uiFailedReq++;
					}
					if(uiFailedReq == 0)
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\FuncGlobalTitleDF.cs ===
using System;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Storage;
using ServerTestFramework.LiveService.Signature;
using xonline.common.config;

namespace XStoreTest
{
    internal abstract class GlobalTitleDFTestBase : TestBase
    {
        protected bool RemoveFileSendAndVerify(XRLRemoveFile removeReq)
        {
            uint    titleID = removeReq.uiTitleId;
            string    pathName = removeReq.accessToken.baseAT.pathName;
            XRLWriteFile    WriteReq = new XRLWriteFile("ServiceAddr", pathName);
            if(WriteReq.Execute())
            {
                if(removeReq.Execute())
                {
                    XRLReadFile        readReq = new XRLReadFile(pathName);
                    readReq.Slot.titleId = readReq.uiTitleId = titleID;
                    if(!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)) &&
                        (readReq.XErr == HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
                        return true;
                    else
                    {
                        Global.RO.Warn("File was not removed");
                        return false;
                    }
                }
                Global.RO.Warn("RemoveFile request failed with "+Global.XErrToString(removeReq.XErr));
                return false;
            }
            return false;
        }
    }
    internal abstract class NegGlobalTitleDFTestBase : TestBase
    {
        protected bool RemoveFileTestNegative(XRLRemoveFile    removeReq, uint XErr)
        {
            if (removeReq.Execute())
            {
                Global.RO.Warn("Negative RemoveFile request succeed unexpectedly");
                return false;
            }
            if(removeReq.XErr != XErr)
            {
                Global.RO.Warn("Wrong error code " + Global.XErrToString(removeReq.XErr) +" returned");
                return false;
            }
            return true;
        }
    }
    [TestGroup, Owner("JKonkle"), TestFrequency("Regression"), TestCasePriority(1)]
    public class FuncGlobalTitleDF : TestNode
    {
        /**********************************************************************************
         * Positive Wire Protocol Testing

		     *********************************************************************************/
		//bug 38096
        [TestCase, Description("check X-Delay in the http response header")]
			class PThrottling : GlobalTitleDFTestBase
        {
            override protected void Execute()
            {
                uint    randomTitleID = (uint)new Random().Next();
                string    sTitleID = randomTitleID.ToString("x");
                string pathName = "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,randomTitleID,"ServiceAddr");

				int Xdelay= 3000;
				Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage,"exec :stfd SetXDelay "+removeReq.uiTitleId.ToString("X")+" removefile "+Xdelay);

                if(RemoveFileSendAndVerify(removeReq)&& (removeReq.XDelay == Xdelay))
                    ResultCode=TEST_RESULTS.PASSED;

				Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage,"exec :stfd ReloadThrottleConfig");
            }
        }
        [TestCase, Description("Write a file first then call removeFile with the same pathname but different userPUID")]
			class PNormalCase : GlobalTitleDFTestBase
        {
            override protected void Execute()
            {
                uint    randomTitleID = (uint)new Random().Next();
                string    sTitleID = randomTitleID.ToString("x");
                string pathName = "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,randomTitleID,"ServiceAddr");
                if(RemoveFileSendAndVerify(removeReq))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("call removeFile with maximum titleID")]
			class PMaxTitleID : GlobalTitleDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//title.ffffffff/t:ffffffff/" + Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,0xffffffff,"ServiceAddr");
                if(RemoveFileSendAndVerify(removeReq))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("call removeFile with minimum titleID")]
			class PMinTitleID : GlobalTitleDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//title.1/t:1/" + Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,1,"ServiceAddr");
                if(RemoveFileSendAndVerify(removeReq))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("call removeFile with maximum titleVersion")]
			class PMaxTitleVersion : GlobalTitleDFTestBase
        {
            override protected void Execute()
            {
                uint    randomTitleID = (uint)new Random().Next();
                string    sTitleID = randomTitleID.ToString("x");
                string pathName = "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,randomTitleID,"ServiceAddr");
                ulong    requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
                uint    ip = 0;
                byte [] addr = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).Address.GetAddressBytes();
                for(int i = 0; i < addr.Length; i++)
                    ip = (ip << 8) + addr[i];
                HTTPAuthData authData = new HTTPAuthData((ushort) Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int).Port,
                    ip,requestId,0,randomTitleID,(uint)XOService.Storage,0);
                authData.dwTitleVersion = removeReq.uiTitleVersion = 0xffffffff;
                removeReq.CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" +
                    authData.GetBase64EncodedString() + "\r\n";

                if(RemoveFileSendAndVerify(removeReq))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("call removeFile with minimum titleVersion")]
			class PMinTitleVersion : GlobalTitleDFTestBase
        {
            override protected void Execute()
            {
                uint    randomTitleID = (uint)new Random().Next();
                string    sTitleID = randomTitleID.ToString("x");
                string pathName = "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,randomTitleID,"ServiceAddr");
                ulong    requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
                uint    ip = 0;
                byte [] addr = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).Address.GetAddressBytes();
                for(int i = 0; i < addr.Length; i++)
                    ip = (ip << 8) + addr[i];
                HTTPAuthData authData = new HTTPAuthData((ushort) Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int).Port,
                    ip,requestId,0,randomTitleID,(uint)XOService.Storage,0);
                authData.dwTitleVersion = removeReq.uiTitleVersion = 1;
                removeReq.CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" +
                    authData.GetBase64EncodedString() + "\r\n";

                if(RemoveFileSendAndVerify(removeReq))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("call removeFile with 255 unicode chars")]
			class PMaxPathNameSize : GlobalTitleDFTestBase
        {
            override protected void Execute()
            {
                uint    randomTitleID = (uint)new Random().Next();
                string    sTitleID = randomTitleID.ToString("x");
                string pathName = "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

                StringBuilder    pathBuilder = new StringBuilder(pathName);
                if(pathName.Length < 255)
                    pathBuilder.Append('z',255-pathName.Length);

                XRLRemoveFile    removeReq = new XRLRemoveFile(pathBuilder.ToString(),randomTitleID,"ServiceAddr");
                if(RemoveFileSendAndVerify(removeReq))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        /**********************************************************************************
         * Positive Other Testing
         *********************************************************************************/
        [TestCase, Description("34925:create a file with a pathname and one title ID, call RemoveFile with the same pathname but different title ID"), TestCasePriority(2)]
			class NRemoveFromOtherTitle : NegGlobalTitleDFTestBase
		{
			override protected void Execute()
			{
				uint    randomTitleID = (uint)new Random().Next();
				string    sTitleID = randomTitleID.ToString("x");
				string pathName = "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,randomTitleID,"ServiceAddr");
				XRLWriteFile    WriteReq = new XRLWriteFile("ServiceAddr",pathName);
				ulong    requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
				uint    ip = 0;
				byte [] addr = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).Address.GetAddressBytes();
				for(int i = 0; i < addr.Length; i++)
					ip = (ip << 8) + addr[i];
				HTTPAuthData authData = new HTTPAuthData((ushort) Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int).Port,
					ip,requestId,0,0x1235,(uint)XOService.Storage,0);
				authData.dwTitleVersion = WriteReq.uiTitleVersion;
				WriteReq.CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" +
					authData.GetBase64EncodedString() + "\r\n";
				WriteReq.uiTitleId = 0x1235;
				if(WriteReq.Execute())
				{
					if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("call RemoveFile with the same pathname and titleID as writeFile but different title Version")]
			class PRemoveFromOtherTitleVersion : TestBase
        {
            override protected void Execute()
            {
                uint    randomTitleID = (uint)new Random().Next();
                string    sTitleID = randomTitleID.ToString("x");
                string pathName = "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,randomTitleID,"ServiceAddr");
                XRLWriteFile    WriteReq = new XRLWriteFile("ServiceAddr",pathName);
                ulong    requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
                uint    ip = 0;
                byte [] addr = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).Address.GetAddressBytes();
                for(int i = 0; i < addr.Length; i++)
                    ip = (ip << 8) + addr[i];
                HTTPAuthData authData = new HTTPAuthData((ushort) Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int).Port,
                    ip,requestId,0,randomTitleID,(uint)XOService.Storage,0);
                authData.dwTitleVersion = WriteReq.uiTitleVersion = removeReq.uiTitleVersion + 1;
                WriteReq.CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" +
                    authData.GetBase64EncodedString() + "\r\n";

                if(WriteReq.Execute())
                {
                    if(removeReq.Execute())
                    {
                        XRLReadFile        readReq = new XRLReadFile(pathName);
                        if(!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)) &&
                            (readReq.XErr == HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
                            ResultCode=TEST_RESULTS.PASSED;
                    }
                }
            }
        }
        [TestCase, Description("remove only one ref for a file with multiple references")]
			class PRemoveFileWithMultiRef : TestBase
        {
            override protected void Execute()
            {
                uint    randomTitleID = (uint)new Random().Next();
                string    sTitleID = randomTitleID.ToString("x");
                string pathName = "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

                // write a blob with 4 references
                uint        title = randomTitleID;
                uint        FileWithMultiRefLen = 10240;
                byte[]        FileData = new byte[FileWithMultiRefLen];
                new Random().NextBytes(FileData);
                byte[]        FileWithMultiRefHash = new byte[Constants.sizeHash];
                new Random().NextBytes(FileWithMultiRefHash);
                int            keyValue = (int)(new Random().Next());
                string        MultiRefPath1 = "", RemovedRefPath = "";
                XRLWriteFile    wReq1 = new XRLWriteFile("ServiceAddr",pathName), wReq2 = new XRLWriteFile("ServiceAddr",pathName);
                for(int i = 0; i < 4; i++)
                {
                    pathName = "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();
                    XRLWriteFile    writeReq = new XRLWriteFile("ServiceAddr",pathName);
                    writeReq.blobDataLen = FileWithMultiRefLen;
                    writeReq.uiBlobSizeCompressed = FileWithMultiRefLen;
                    writeReq.blobData = new byte[FileWithMultiRefLen];
                    FileData.CopyTo(writeReq.blobData,0);
                    FileWithMultiRefHash.CopyTo(writeReq.blobHash,0);

                    if(!writeReq.Execute())
                    {
                        Global.RO.Warn("Write File failed:"+i);
                        return;
                    }
                    if(i == 0)
                    {
                        wReq1 = writeReq;
                        MultiRefPath1 = writeReq.accessToken.baseAT.pathName;
                    }
                    else if (i == 1)
                        wReq2 = writeReq;
                    // the removed Ref path will be i = 3
                    RemovedRefPath = writeReq.accessToken.baseAT.pathName;
                }

                // only remove one reference to the file; the file still in the db and
                // check the i_ref_count=3
                XRLRemoveFile    removeReq = new XRLRemoveFile(RemovedRefPath,title,"ServiceAddr");
                if(removeReq.Execute())
                {
                    XRLReadFile        readReq = new XRLReadFile(MultiRefPath1);
                    readReq.Slot.titleId = readReq.uiTitleId = title;
                    XRLReadFileResponse    resp;
                    if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out resp))
                        // check ref count
                        if(wReq1.CheckRefCount(wReq2,3,false))
                            ResultCode=TEST_RESULTS.PASSED;
                }
            }
        }
        [TestCase, Description("remove all refs for a file with multiple references")]
			class PRemoveFileWithMultiRef2 : TestBase
        {
            override protected void Execute()
            {
                uint    randomTitleID = (uint)new Random().Next();
                string    sTitleID = randomTitleID.ToString("x");
                string pathName= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();
                // write a blob with 2 references
                uint        title = randomTitleID;
                uint        FileWithMultiRefLen = 10240;
                byte[]        FileData = new byte[FileWithMultiRefLen];
                new Random().NextBytes(FileData);
                byte[]        FileWithMultiRefHash = new byte[Constants.sizeHash];
                new Random().NextBytes(FileWithMultiRefHash);
                string        []refPath = new string[2]{"",""};
                XRLWriteFile    [] writeReq = new XRLWriteFile[2]{null, null};
                for(int i = 0; i < 2; i++)
                {
                    pathName = "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();
                    writeReq[i] = new XRLWriteFile("ServiceAddr",pathName);
                    writeReq[i].blobDataLen = FileWithMultiRefLen;
                    writeReq[i].uiBlobSizeCompressed = FileWithMultiRefLen;
                    writeReq[i].blobData = new byte[FileWithMultiRefLen];
                    FileData.CopyTo(writeReq[i].blobData,0);
                    FileWithMultiRefHash.CopyTo(writeReq[i].blobHash,0);
                    if(!writeReq[i].Execute())
                    {
                        Global.RO.Warn("Write File failed:"+i);
                        return;
                    }
                    refPath[i]=pathName;
                }

                // remove all references to the file; the file will be deleted
                XRLRemoveFile    removeReq1 = new XRLRemoveFile(refPath[0],title,"ServiceAddr");
                XRLRemoveFile    removeReq2 = new XRLRemoveFile(refPath[1],title,"ServiceAddr");
                if(removeReq1.Execute() && (removeReq2.Execute()))
                {
                    XRLReadFile        readReq = new XRLReadFile(refPath[0]);
                    readReq.Slot.titleId = readReq.uiTitleId = title;
                    if(!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage))&&
                        (readReq.XErr==HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
                        ResultCode=TEST_RESULTS.PASSED;
                }
            }
        }
        /**********************************************************************************
         * Negative Wire Protocol Testing
         *********************************************************************************/
        // since GlobalTitleDF is a dataCenter request, we need to test HTTPAuthData header
        // instead of SGAuth
        // [TestCase, Description("Bug33875:the userPUID in HTTPAuthData is different than the one in removeFile request"), TestCasePriority(2)]
			class NSGAuthInvalidUserPUID : NegGlobalTitleDFTestBase
        {
            override protected void Execute()
            {
                uint    randomTitleID = (uint)new Random().Next();
                string    sTitleID = randomTitleID.ToString("x");
                string pathName = "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,randomTitleID,"ServiceAddr");
                ulong    userPUID = removeReq.accessToken.baseAT.userPuid + 1;
                ulong    requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
                uint    ip = 0;
                byte [] addr = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).Address.GetAddressBytes();
                for(int i = 0; i < addr.Length; i++)
                    ip = (ip << 8) + addr[i];
                HTTPAuthData authData = new HTTPAuthData((ushort) Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int).Port,
                    ip,requestId,userPUID,randomTitleID,(uint)XOService.Storage,0);
                authData.dwTitleVersion = removeReq.uiTitleVersion;
                removeReq.CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" +
                    authData.GetBase64EncodedString() + "\r\n";
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("31658:the titleID in SGAuth response is not the one in the removeFile request"), TestCasePriority(2)]
			class NSGAuthInvalidTitleID : NegGlobalTitleDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//title.1234/t:1234/" + Guid.NewGuid().ToString();
                uint    titleID = 0x1234;
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                ulong    requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
                uint    ip = 0;
                byte [] addr = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).Address.GetAddressBytes();
                for(int i = 0; i < addr.Length; i++)
                    ip = (ip << 8) + addr[i];
                HTTPAuthData authData = new HTTPAuthData((ushort) Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int).Port,
                    ip,requestId,0,0x1235,(uint)XOService.Storage,0);
                authData.dwTitleVersion = removeReq.uiTitleVersion;
                removeReq.CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" +
                    authData.GetBase64EncodedString() + "\r\n";

                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_INVALID_TITLE_ID))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("31659:the titleVersion in SGAuth response is not the one in the removeFile request"), TestCasePriority(2)]
			class NSGAuthInvalidTitleVersion : NegGlobalTitleDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//title.1234/t:1234/" + Guid.NewGuid().ToString();
                uint    titleID = 0x1234;
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                ulong    requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
                uint    ip = 0;
                byte [] addr = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).Address.GetAddressBytes();
                for(int i = 0; i < addr.Length; i++)
                    ip = (ip << 8) + addr[i];
                HTTPAuthData authData = new HTTPAuthData((ushort) Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int).Port,
                    ip,requestId,0,titleID,(uint)XOService.Storage,0);
                authData.dwTitleVersion = removeReq.uiTitleVersion + 1;
                removeReq.CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" +
                    authData.GetBase64EncodedString() + "\r\n";

                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("the serviceID in SGAuth response is not Storage"), TestCasePriority(2)]
			class NSGAuthInvalidServiceID : NegGlobalTitleDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//title.1234/t:1234/" + Guid.NewGuid().ToString();
                uint    titleID = 0x1234;
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                ulong    requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
                uint    ip = 0;
                byte [] addr = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).Address.GetAddressBytes();
                for(int i = 0; i < addr.Length; i++)
                    ip = (ip << 8) + addr[i];
                HTTPAuthData authData = new HTTPAuthData((ushort) Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int).Port,
                    ip,requestId,0,0x1235,(uint)XOService.Stats,0);
                authData.dwTitleVersion = removeReq.uiTitleVersion;
                removeReq.CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" +
                    authData.GetBase64EncodedString() + "\r\n";

                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_SERVER_ERROR))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("31660:Call RemoveFile with invalid pathName"), TestCasePriority(2)]
			class NFileNotFound : NegGlobalTitleDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//title.1234/t:1234/" + Guid.NewGuid().ToString();
                uint    titleID = 0x1234;
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass non-removeFile operation"), TestCasePriority(2)]
			class NInvalidOperation : NegGlobalTitleDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//title.1234/t:1234/" + Guid.NewGuid().ToString();
                uint    titleID = 0x1234;
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                removeReq.accessToken.baseAT.operation = (ushort)Constants.Operation.FileEnumerate;
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        // [TestCase, Description("pass invalid serviceID(not 0)for Global Title Storage"), TestCasePriority(2)]
			class NInvalidServiceID : NegGlobalTitleDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//title.1234/t:1234/" + Guid.NewGuid().ToString();
                uint    titleID = 0x1234;
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                removeReq.accessToken.baseAT.serviceId = 1;
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        // bug 33914
        [TestCase, Description("pass non-zero as userPUID for GlobalTitleStorage"), TestCasePriority(2)]
			class NNonZeroUserPUID : NegGlobalTitleDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//title.1234/t:1234/" + Guid.NewGuid().ToString();
                uint    titleID = 0x1234;
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                removeReq.accessToken.baseAT.userPuid = 1;
                ulong    requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
                uint    ip = 0;
                byte [] addr = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).Address.GetAddressBytes();
                for(int i = 0; i < addr.Length; i++)
                    ip = (ip << 8) + addr[i];
                HTTPAuthData authData = new HTTPAuthData((ushort) Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int).Port,
                    ip,requestId,1,0x1234,(uint)XOService.Stats,0);
                authData.dwTitleVersion = removeReq.uiTitleVersion;
                removeReq.CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" +
                    authData.GetBase64EncodedString() + "\r\n";
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_SERVER_ERROR))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        // bug 33914
        [TestCase, Description("pass non-0 as xboxPUID"), TestCasePriority(2)]
			class NNonZeroXBoxPUID : NegGlobalTitleDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//title.1234/t:1234/" + Guid.NewGuid().ToString();
                uint    titleID = 0x1234;
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");

                ulong    requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
                uint    ip = 0;
                byte [] addr = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).Address.GetAddressBytes();
                for(int i = 0; i < addr.Length; i++)
                    ip = (ip << 8) + addr[i];
                HTTPAuthData authData = new HTTPAuthData((ushort) Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int).Port,
                    ip,requestId,0,0x1234,(uint)XOService.Stats,0);
                authData.dwTitleVersion = removeReq.uiTitleVersion;
                authData.qwXboxID = removeReq.accessToken.baseAT.xboxPuid = 1;
                removeReq.CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" +
                    authData.GetBase64EncodedString() + "\r\n";
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_SERVER_ERROR))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pathNameLen is greater than the actual pathname"), TestCasePriority(2)]
			class NTruncatePathname : NegGlobalTitleDFTestBase
        {
            public NTruncatePathname()
            {
                Name = "NTruncatePathname";
                Desc = "";
            }
            override protected void Execute()
            {
                string    pathName = "//title.1234/t:1234/" + Guid.NewGuid().ToString();
                uint    titleID = 0x1234;
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                removeReq.accessToken.baseAT.ManualArraySize = true;
                removeReq.accessToken.baseAT.pathNameLen +=1;
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pathNameLen is shorter than the actual pathname"), TestCasePriority(2)]
			class NOverflowPathname : NegGlobalTitleDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//title.1234/t:1234/" + Guid.NewGuid().ToString();
                uint    titleID = 0x1234;
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                removeReq.accessToken.baseAT.ManualArraySize = true;
                removeReq.accessToken.baseAT.pathNameLen -=1;
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass NULL for pathName"), TestCasePriority(2)]
			class NNullPathname : NegGlobalTitleDFTestBase
        {
            override protected void Execute()
            {
                uint    titleID = 0x1234;
                XRLRemoveFile    removeReq = new XRLRemoveFile(null,titleID,"ServiceAddr");

                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("token expiration time is before current time"), TestCasePriority(2)]
			class NInvalidTokenExpTime : NegGlobalTitleDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//title.1234/t:1234/" + Guid.NewGuid().ToString();
                uint    titleID = 0x1234;
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                removeReq.accessToken.removeAT.tokenExpirationDate = (long)System.DateTime.UtcNow.AddHours(-1).ToFileTimeUtc();
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        //   [TestCase, Description("pass removeFile request to stfd port 10140 other than 11140"), TestCasePriority(2)]
			class NNonDCReq : NegGlobalTitleDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//title.1234/t:1234/" + Guid.NewGuid().ToString();
                uint    titleID = 0x1234;
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                removeReq.Server.Port = 10140;

                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }


		[TestCase, Description("titleID in the pathName is not the sameas the one in the protocol"), TestCasePriority(2)]
			class NPathnameInvalidTitleID : NegGlobalTitleDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//title.1234/t:1234/" + Guid.NewGuid().ToString();
                uint    titleID = 0x1234;
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                removeReq.uiTitleId = 0x1235;
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_INVALID_TITLE_ID))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\FuncGameClipsWF.cs ===
using System;
using System.Globalization;
using System.Text;
using System.Net;
using System.IO;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Storage;
using ServerTestFramework.LiveService.Signature;
using xonline.common.config;
using xonline.common.protocol;
using System.Security.Cryptography;
namespace XStoreTest
{
	internal abstract class WriteFileTestBase : TestBase
	{
		//	send WriteFile request first; then send readfile;verifies the response
		protected bool WriteFileSendAndVerify(XRLWriteFile WriteFileReq, bool signAgain)
		{
			// when calling XRLWriteFile() the AccessToken is signed, but at this point some data
			// being signed might have been modified, so we need to sign again
			if(signAgain)
			{
				byte[] signDataWithExtra = (byte[])WriteFileReq.accessToken;
				int sizeDataToSign = WriteFileReq.accessToken.baseAT.Size() + 20;//20 is fileExp/tokenExp/maxFilesize
				byte[] signData = new byte[sizeDataToSign];
				Array.Copy(signDataWithExtra, 0, signData, 0, sizeDataToSign);
				XSigSignature signature = new XSigSignature();
				signature.Initialize();
				signature._serviceId = (uint)XOService.Stats;

                SHA1 sha1 = new SHA1CryptoServiceProvider();
                signature.ComputeSignature(sha1.ComputeHash(signData));
				WriteFileReq.accessToken.writeAT.signature = (byte [])signature;
			}

			bool fPassed=WriteFileReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage));
			if (!fPassed)
			{
				Global.RO.Warn("Failed to send WriteFile request ");
				return false;
			}

			XRLReadFileResponse	ReadFileResp;
			XRLReadFile			ReadFileReq = new XRLReadFile(WriteFileReq.accessToken.baseAT.pathName);
			ReadFileReq.Slot.titleId = ReadFileReq.uiTitleId = WriteFileReq.uiTitleId;
			ReadFileReq.Slot.titleVersion = ReadFileReq.uiTitleVersion = WriteFileReq.uiTitleVersion;
			if (ReadFileReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out ReadFileResp))
			{
				if ((!ReadFileResp.Compare(WriteFileReq)) || (!WriteFileReq.Verify()))
				{
					Global.RO.Warn("WriteFile request is not set correctly in the db");
					return false;
				}
			}
			else
			{
				Global.RO.Warn("Failed to send ReadFile request");
				return false;
			}
			return true;
		}
	}
	internal abstract class NegativeWFTestBase : TestBase
	{
		//	send WriteFile request first; then send readfile;verifies the response
		protected bool WriteFileTestNegative(XRLWriteFile WriteFileReq, bool signAgain, uint XErr)
		{
			if(signAgain)
			{
				byte[] signDataWithExtra = (byte[])WriteFileReq.accessToken;
				int sizeDataToSign = WriteFileReq.accessToken.baseAT.Size() + 20;//20 is fileExp/tokenExp/maxFilesize
				byte[] signData = new byte[sizeDataToSign];
				Array.Copy(signDataWithExtra, 0, signData, 0, sizeDataToSign);
				XSigSignature signature = new XSigSignature();
				signature.Initialize();
				signature._serviceId = (uint)XOService.Stats;

                SHA1 sha1 = new SHA1CryptoServiceProvider();
                signature.ComputeSignature(sha1.ComputeHash(signData));
				WriteFileReq.accessToken.writeAT.signature = (byte [])signature;
			}

			if (WriteFileReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
			{
				Global.RO.Warn("Negative WriteFile request succeed unexpectedly");
				return false;
			}
			if(WriteFileReq.XErr != XErr)
			{
				Global.RO.Warn("Wrong error code returned " + Global.XErrToString(WriteFileReq.XErr));
				return false;
			}
			// now we need to check the file is not written to the DB
			XRLReadFileResponse	ReadFileResp;
			XRLReadFile			ReadFileReq = new XRLReadFile(WriteFileReq.accessToken.baseAT.pathName);
			ReadFileReq.Slot.titleId = ReadFileReq.uiTitleId = WriteFileReq.uiTitleId;
			ReadFileReq.Slot.titleVersion = ReadFileReq.uiTitleVersion = WriteFileReq.uiTitleVersion;
			if (!ReadFileReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out ReadFileResp))
			{
/*				if((ReadFileReq.XErr != HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND)
					||(ReadFileResp != null))
				{
					Global.RO.Warn("file_not_found error is not returned OR File is being written to DB unexpectedly");
					return false;
				}
				*/
				if(ReadFileResp != null)
				{
					Global.RO.Warn("File is being written to DB unexpectedly");
					return false;
				}
			}
			else
			{
				Global.RO.Warn("ReadFile request succeed with S_OK unexpectedly");
				return false;
			}
			return true;
		}
		protected bool	MyOwnExecute(MemoryStream reqStream, uint XErr)
		{
			StringBuilder sbURL = new StringBuilder();
			sbURL.Append("http://");
			sbURL.Append(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage));
			sbURL.Append("/stfd/writefile.ashx");

			HttpWebRequest	httpReq;
			HttpWebResponse	httpResp = null;
			HttpStatusCode	statusCode;
			Stream			httpStream;
			httpReq = (HttpWebRequest)WebRequest.Create(sbURL.ToString());
			httpReq.ProtocolVersion = HttpVersion.Version11;
			httpReq.Method = "POST";
			httpReq.UserAgent = ((int)XOService.Storage).ToString("x") + "/1.0";
			httpReq.ContentType = "xon/" + ((int)XOService.Storage).ToString("x");
			httpReq.ContentLength = reqStream.Length;
			try
			{
				httpStream = httpReq.GetRequestStream();
				reqStream.WriteTo(httpStream);
				httpStream.Close();
				httpResp = (HttpWebResponse)httpReq.GetResponse();
			}
			catch (WebException e)
			{
				httpResp = (HttpWebResponse)e.Response;
				if(httpResp != null)
				{
					statusCode = httpResp.StatusCode;
					if(statusCode == HttpStatusCode.InternalServerError)
					{	// check XErr
						string strErr = httpResp.GetResponseHeader("X-Err");
						if (strErr.StartsWith("0x") || strErr.StartsWith("0X")) strErr = strErr.Substring(2);

						if (Convert.ToUInt32(strErr, 16) == XErr)
							return true;
						else
						{
							Global.RO.Warn("Wrong error code " + strErr +" returned");
							return false;
						}
					}
				}
				return true;
			}
			Global.RO.Warn("Negative WriteFile request succeed unexpectedly");
			return false;
		}
	}
	[TestGroup, Owner("JKonkle"), TestFrequency("Regression"), TestCasePriority(1)]
	public class FuncGameClipsWF : TestNode
	{
		[TestCase, Description("")]
		class PThrottling : TestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.attributes = new byte[100];
				for(int i = 0; i < 100; i++)
					req.attributes[i] = 1;
				req.attributesLen = (ushort)req.attributes.Length;

				int Xdelay= 3000;
				Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage,"exec :stfd SetXDelay "+req.uiTitleId.ToString("X")+" writefile "+Xdelay);

				if(req.Execute())
					if(req.XDelay == Xdelay)
						ResultCode=TEST_RESULTS.PASSED;

				Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage, "exec :stfd ReloadThrottleConfig");
			}
		}
		//	[TestCase, Description("Write a file with all valid parameters including valid signature/Access Token")]
		[TestCase, Description("Write a file with all valid parameters and some attributes")]
		class PNormalCase : WriteFileTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.attributes = new byte[100];
				for(int i = 0; i < 100; i++)
					req.attributes[i] = 1;
				req.attributesLen = (ushort)req.attributes.Length;

				if(WriteFileSendAndVerify(req,false))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write a 1k file")]
			class PSmallFileSize : WriteFileTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.blobData = new byte[1024];
				for(int i = 0; i < req.blobData.Length; i++)
					req.blobData[i] = (byte)(i%256);
				req.blobDataLen = req.uiBlobSizeCompressed = (uint)req.blobData.Length;

				if(WriteFileSendAndVerify(req,false))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write a 100k file")]
			class PMediumFileSize : WriteFileTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.blobData = new byte[1024*100];
				for(int i = 0; i < req.blobData.Length; i++)
					req.blobData[i] = (byte)(i%256);
				req.blobDataLen = req.uiBlobSizeCompressed = (uint)req.blobData.Length;

				if(WriteFileSendAndVerify(req,false))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write a 1MB file")]
			class PLargeFileSize : WriteFileTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.blobData = new byte[1024*1024];
				for(int i = 0; i < req.blobData.Length; i++)
					req.blobData[i] = (byte)(i%256);
				req.blobDataLen = req.uiBlobSizeCompressed = (uint)req.blobData.Length;

				if(WriteFileSendAndVerify(req,false))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write a file with title ID set to max value")]
			class PMaxTitleID : WriteFileTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				uint			titleID = req.uiTitleId = 0xffffffff;
				req.accessToken.baseAT.pathName = "//stats/u:" + req.accessToken.baseAT.userPuid.ToString("x")
					+ "/" + titleID.ToString("x") + "/"
					+ Guid.NewGuid().ToString();
				req.Slot.titleId = titleID;

				if(WriteFileSendAndVerify(req,true))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write a file with title ID set to min value")]
			class PMinTitleID : WriteFileTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				uint			titleID = req.uiTitleId = 0;
				req.accessToken.baseAT.pathName = "//stats/u:" + req.accessToken.baseAT.userPuid.ToString("x")
					+ "/" + titleID.ToString("x") + "/"
					+ Guid.NewGuid().ToString();
				req.Slot.titleId = titleID;

				if(WriteFileSendAndVerify(req,true))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write a file with titleVersion set to max value")]
			class PMaxTitleVersion : WriteFileTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.uiTitleVersion = 0xffffffff;
				req.Slot.titleVersion = 0xffffffff;

				if(WriteFileSendAndVerify(req,false))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write a file with titleVersion set to min value")]
			class PMinTitleVersion : WriteFileTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.uiTitleVersion = 0;
				req.Slot.titleVersion = 0;

				if(WriteFileSendAndVerify(req,false))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write a file with countryID set to max value")]
			class PMaxUserCountryID : WriteFileTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.bUserCountryId = 0xff;
				req.Slot.userFlag0 = (uint)0xff<<8;

				if(WriteFileSendAndVerify(req,false))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write a file with countryID set to min value")]
			class PMinUserCountryID : WriteFileTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.bUserCountryId = 0;
				req.Slot.userFlag0 = 0;

				if(WriteFileSendAndVerify(req,false))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write a max size file")]
			class PBlobDataMaxSize : WriteFileTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.blobData = new byte[Constants.maxFileSize];
				for(int i = 0; i < req.blobData.Length; i++)
					req.blobData[i] = (byte)(i%256);
				req.blobDataLen = req.uiBlobSizeCompressed = (uint)req.blobData.Length;

				if(WriteFileSendAndVerify(req,false))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass attributes with 256 byte")]
			class PMaxAttributeSize : WriteFileTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				uint	attSize = Constants.maxSizeAttributes;
				req.attributes = new byte[attSize];
				for(int i = 0; i < req.attributes.Length; i++)
					req.attributes[i] = 1;
				req.attributesLen = (ushort)req.attributes.Length;

				if(WriteFileSendAndVerify(req,false))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass 0 attributesLen")]
			class PMinAttributeSize : WriteFileTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.attributes = null;
				req.attributesLen = 0;

				if(WriteFileSendAndVerify(req,false))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass max value for UserPUID in the accessToken")]
			class PAccessTokenMaxUserPUID : WriteFileTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.accessToken.baseAT.userPuid = 0xffffffffffffffff;
				req.Slot.userPuid0 = 	req.accessToken.baseAT.userPuid;

				if(WriteFileSendAndVerify(req,true))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass min value for UserPUID in the accessToken")]
			class PAccessTokenMinUserPUID : WriteFileTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.accessToken.baseAT.userPuid = 1;
				req.Slot.userPuid0 = 1;

				if(WriteFileSendAndVerify(req,true))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass max value for xboxPUID in the accessToken")]
			class PAccessTokenMaxXBoxPUID : WriteFileTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.accessToken.baseAT.xboxPuid = 0xffffffffffffffff;
				req.Slot.machinePuid = 0xffffffffffffffff;

				if(WriteFileSendAndVerify(req,true))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass min value for xboxPUID in the accessToken")]
			class PAccessTokenMinXBoxPUID : WriteFileTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.accessToken.baseAT.xboxPuid = 1;
				req.Slot.machinePuid = 1;

				if(WriteFileSendAndVerify(req,true))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass 0 fileExpirationTime in the accessToken")]
			class PAccessTokenZeroFileExpTime : WriteFileTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.accessToken.writeAT.fileExpirationDate = 0;
				req.accessToken.writeAT.tokenExpirationDate = System.DateTime.UtcNow.AddHours(1).ToFileTimeUtc();

				if(WriteFileSendAndVerify(req,true))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass 0 AccessTokenExpirationTime in the accessToken")]
			class PAccessTokenZeroATExpTime : WriteFileTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.accessToken.writeAT.tokenExpirationDate = 0;

				if(WriteFileSendAndVerify(req,true))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
//		[TestCase, Description("")] class PAccessTokenMaxPathnameSize : WriteFileTestBase
//		{
//			public PAccessTokenMaxPathnameSize()
//			{
//				Name = "PAccessTokenMaxPathnameSize";
//				Desc = "35319:pass 255 unicode chars pathNameLen in the accessToken";
//			}
//			override protected void Execute()
//			{
//				XRLWriteFile	req = new XRLWriteFile();
//				req.accessToken.baseAT.pathNameLen = 255;
//				string path = "//stats/u:" + req.accessToken.baseAT.userPuid.ToString("x")
//					+ "/" + req.uiTitleId.ToString("x")+"/"
//					+ Guid.NewGuid().ToString();
//				StringBuilder	pathBuilder = new StringBuilder(path);
//				if(path.Length < 255)
//					pathBuilder.Append('z',255-path.Length);
//
//				req.accessToken.baseAT.pathName = pathBuilder.ToString();
//
//				if(WriteFileSendAndVerify(req,true))
//					ResultCode=TEST_RESULTS.PASSED;
//			}
//		}
		[TestCase, Description("pass non-existent compression type"), TestCasePriority(2)]
			class NInvalidCompressionType : NegativeWFTestBase //TODO:???
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.bCompressionType = (byte)Constants.CompressionType.Invalid;
				if(WriteFileTestNegative(req,false,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass non-existent content type"), TestCasePriority(2)]
			class NInvalidContentType : NegativeWFTestBase //TODO:???
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.uiContentType = (uint)Constants.ContentType.Invalid;
				if(WriteFileTestNegative(req,false,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass NULL for blob hash"), TestCasePriority(2)]
			class NNullBlobHash : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.ManualArraySize = true;
				req.blobHash = null;
				if(WriteFileTestNegative(req,false,HResult.XONLINE_E_STORAGE_FILE_IS_TOO_BIG))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass <20 byte for blob hash"), TestCasePriority(2)]
			class NInvalidBlobHash1 : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.ManualArraySize = true;
				req.blobHash = new byte[Constants.sizeHash - 1];
				if(WriteFileTestNegative(req,false,HResult.XONLINE_E_STORAGE_FILE_IS_TOO_BIG))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass >20 byte for blob hash"), TestCasePriority(2)]
			class NInvalidBlobHash2 : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.ManualArraySize = true;
				req.blobHash = new byte[Constants.sizeHash + 1];
				if(WriteFileTestNegative(req,false,HResult.XONLINE_E_STORAGE_FILE_IS_TOO_BIG))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass <100 byte for blob signature"), TestCasePriority(2)]
			class NInvalidSignatureLen1 : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.ManualArraySize = true;
				req.blobSignature = new byte[Constants.sizeSignature -1];
				if(WriteFileTestNegative(req,false,HResult.XONLINE_E_STORAGE_FILE_IS_TOO_BIG))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass >100 byte for blob signature"), TestCasePriority(2)]
			class NInvalidSignatureLen2 : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.ManualArraySize = true;
				req.blobSignature = new byte[Constants.sizeSignature + 1];
				if(WriteFileTestNegative(req,false,HResult.XONLINE_E_STORAGE_FILE_IS_TOO_BIG))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass null for blob signature"), TestCasePriority(2)]
			class NNullSignature : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.ManualArraySize = true;
				req.blobSignature = null;
				if(WriteFileTestNegative(req,false,HResult.XONLINE_E_STORAGE_FILE_IS_TOO_BIG))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("uncompressed size is smaller than compressed size"), TestCasePriority(2)]
			class NWrongCompressedSize : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.uiBlobSizeCompressed = req.blobDataLen + 1;

				if(WriteFileTestNegative(req,false,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass non-null for Attributes, but AttribLen is zero"), TestCasePriority(2)]
			class NMismatchedAttributes : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.ManualArraySize = true;
				req.attributesLen = 0;
				req.attributes = new byte[16];
				for(int i = 0; i < 16; i++)
					req.attributes[i] = (byte)i;
				if(WriteFileTestNegative(req,false,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Attributes size is greater than the actual size"), TestCasePriority(2)]
			class NTruncateAttributes : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.ManualArraySize = true;
				req.attributesLen +=1;
				if(WriteFileTestNegative(req,false,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Attributes size is smaller than the actual size"), TestCasePriority(2)]
			class NOverflowAttributes1 : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.ManualArraySize = true;
				req.attributes = new Byte[16];
				req.attributesLen = 15;
				if(WriteFileTestNegative(req,false,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Attributes is null but attribLen is nonzero"), TestCasePriority(2)]
			class NOverflowAttributes2 : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.ManualArraySize = true;
				req.attributes = null;
				req.attributesLen = 16;
				if(WriteFileTestNegative(req,false,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Attributes is null but attribLen is greater than maxallowed(256)"), TestCasePriority(2)]
			class NOverflowAttributes3 : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.ManualArraySize = true;
				req.attributes = null;
				req.attributesLen = Constants.maxSizeAttributes + 1;
				if(WriteFileTestNegative(req,false,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Attributes is larger than max allowed256bytes"), TestCasePriority(2)]
			class NOverflowAttributes4 : NegativeWFTestBase
		{
			override protected void Execute()
			{
				ushort	attriSize = Constants.maxSizeAttributes + 1;
				XRLWriteFile	req = new XRLWriteFile();
				req.attributes = new Byte[attriSize];
				req.attributesLen = attriSize;
				if(WriteFileTestNegative(req,false,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass special attributeLen = 0xffff"), TestCasePriority(2)]
			class NOverflowAttributes5 : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.attributes = new Byte[0xffff];
				req.attributesLen = 0xffff;
				if(WriteFileTestNegative(req,false,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass null for AccessToken"), TestCasePriority(2)]
			class NNullAccessToken : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	WriteFileReq = new XRLWriteFile();
				WriteFileReq.ManualArraySize = true;
				WriteFileReq.accessToken = null;
				if (!WriteFileReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
				{
					if(WriteFileReq.XErr != HResult.XONLINE_E_STORAGE_INVALID_REQUEST)
						Global.RO.Warn("Wrong error code returned " + Global.XErrToString(WriteFileReq.XErr));
					else
						ResultCode=TEST_RESULTS.PASSED;
				}
				else
					Global.RO.Warn("Negative WriteFile request succeed unexpectedly");
			}
		}
		[TestCase, Description("pass null for Blob data, but blobLen is non-zero"), TestCasePriority(2)]
			class NNullBlobData : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.ManualArraySize = true;
				req.blobData = null;
				if(WriteFileTestNegative(req,false,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass 0 for uncompressed blob size and null blobdata")]
			class PEmptyFile : WriteFileTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.blobDataLen = req.uiBlobSizeCompressed = 0;
				req.blobData = null;

				if(WriteFileSendAndVerify(req,false))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass 0 for compressed blob size, but non-null blobdata"), TestCasePriority(2)]
			class NEmptyCompressedFile : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.uiBlobSizeCompressed = 0;

				if(WriteFileTestNegative(req,false,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("uncompressed blob size is greater than the actual file size"), TestCasePriority(2)]
			class NTruncateFile : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.ManualArraySize = true;
				req.blobDataLen += 1;
				req.uiBlobSizeCompressed +=1;
				if(WriteFileTestNegative(req,false,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("uncompressed blob size is smaller than the actual file size"), TestCasePriority(2)]
			class NOverflowFile : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.ManualArraySize = true;
				req.blobDataLen -= 1;
				req.uiBlobSizeCompressed -=1;
				if(WriteFileTestNegative(req,false,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		//[TestCase, Description("Write a file with invalid signature"), TestCasePriority(2)]
			class NInvalidSignature : NegativeWFTestBase // TODO: need to use XSIG
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();

				if(WriteFileTestNegative(req,false,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
			[TestCase, Description("Expiration date is before the current time"), TestCasePriority(2)]
			class NAccessTokenInvalidExpTime1 : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.accessToken.writeAT.fileExpirationDate = System.DateTime.UtcNow.AddDays(-1).ToFileTimeUtc();

				if(WriteFileTestNegative(req,true,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		//bug 33817
            [TestCase, Description("pass 0 for userPUID in access Token"), TestCasePriority(2)]
			class NAccessTokenZeroUserPUID : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.accessToken.baseAT.userPuid = 0;
				req.Slot.userPuid0 = 0;

				if(WriteFileTestNegative(req,true,HResult.XONLINE_E_SERVER_ERROR))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
            [TestCase, Description("pass an access Token that is greater than 255+baseAT"), TestCasePriority(2)]
			class NAccessTokenOverflowAT : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				StringBuilder	pathName = new StringBuilder(req.accessToken.baseAT.pathName);
				int		i = 0, numCharToAdd = 256 - req.accessToken.baseAT.pathNameLen;
				while(i < numCharToAdd)
				{
					pathName.Append('a');
					i++;
				}
				req.accessToken.baseAT.pathNameLen = 256;
				req.accessToken.baseAT.pathName = pathName.ToString();

				if(WriteFileTestNegative(req,true,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
            [TestCase, Description("Access Token signature is NULL but sigLen is still 100"), TestCasePriority(2)]
			class NAccessTokenNullSig : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.accessToken.writeAT.ManualArraySize = true;
				req.accessToken.writeAT.signature = null;
				req.accessToken.writeAT.signatureLen = Constants.sizeSignature;
				if(WriteFileTestNegative(req,false,HResult.XONLINE_E_SIGNATURE_VER_UNKNOWN_SIGNATURE_VER))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
            [TestCase, Description("Access Token signature is invalid"), TestCasePriority(2)]
			class NAccessTokenInvalidSig : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				for(int i = 0; i < Constants.sizeSignature; i++)
				req.accessToken.writeAT.signature[i] = 0;

				if(WriteFileTestNegative(req,false,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
            [TestCase, Description("Access Token signatureLen is 0, but with valid signature"), TestCasePriority(2)]
			class NAccessTokenZeroSigSize : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.accessToken.writeAT.ManualArraySize = true;
				req.accessToken.writeAT.signatureLen = 0;
				if(WriteFileTestNegative(req,true,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
            [TestCase, Description("Access Token signatureLen is <100 but with valid Sig"), TestCasePriority(2)]
			class NAccessTokenWrongSigSize1 : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.accessToken.writeAT.ManualArraySize = true;
				req.accessToken.writeAT.signatureLen = Constants.sizeSignature - 1;
				if(WriteFileTestNegative(req,true,HResult.XONLINE_E_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
            [TestCase, Description("Access Token signatureLen is >100 but with valid Sig"), TestCasePriority(2)]
			class NAccessTokenWrongSigSize2 : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.accessToken.writeAT.ManualArraySize = true;
				req.accessToken.writeAT.signatureLen = Constants.sizeSignature + 1;

				if(WriteFileTestNegative(req,true,HResult.XONLINE_E_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
            [TestCase, Description("Access Token version is invalid"), TestCasePriority(2)]
			class NAccessTokenInvalidTokenVersion : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.accessToken.baseAT.version = Constants.accessTokenVersion + 1;

				if(WriteFileTestNegative(req,true,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
            [TestCase, Description("Operation in AT is non-write"), TestCasePriority(2)]
			class NAccessTokenMismatchedOperation : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.accessToken.baseAT.operation = (ushort)Constants.Operation.FileRead;

				if(WriteFileTestNegative(req,true,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		//33874:By design
		[TestCase, Description("ServiceID in AT is not stats")]
			class PAccessTokenInvalidServiceID : WriteFileTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.accessToken.baseAT.serviceId = (uint)XOService.Storage;

				if(this.WriteFileSendAndVerify(req,true))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}

		// bug 29366
		// STFD: sometimes stfd won't return error when there is garbage data appended
		// at the end of writeFile requests
		// XRLScan: S_False returned
//		[TestCase, Description("")] class NGarbageData : NegativeWFTestBase
//		{
//			public NGarbageData()
//			{
//				Name = "NGarbageData";
//				Desc = "attach garge data at the end of requests";
//			}
//			override protected void Execute()
//			{
//				XRLWriteFile	req = new XRLWriteFile();
//				req.ManualArraySize = true;
//				int			maxFileSize = (int)req.accessToken.writeAT.maxFileSize;
//				req.blobDataLen = req.uiBlobSizeCompressed = (uint)maxFileSize;
//				req.blobData = new byte[maxFileSize + 77381];
//				for (int i = maxFileSize; i < maxFileSize + 77381; i++)
//					req.blobData[i] = 0;
//
//				if(WriteFileTestNegative(req,false,HResult.XONLINE_E_SERVER_ERROR))
//					ResultCode=TEST_RESULTS.PASSED;
//			}
//		}

		// This will be caught by xrlscan.ini
        [TestCase, Description("the actual file size is greater than the dwMaxFileSize in AT"), TestCasePriority(2)]
			class NAccessTokenOverflowFileData1 : TestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				uint			maxFileSize = req.accessToken.writeAT.maxFileSize;
				req.blobData = new byte[maxFileSize + 1];
				for (int i = 0; i < maxFileSize + 1; i++)
					req.blobData[i] = (byte)i;
				req.blobDataLen = maxFileSize + 1;
				req.uiBlobSizeCompressed = maxFileSize + 1;

				// 404 returned back to client
				if(!req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		// This will be caught by xrlscan.ini
        [TestCase, Description("actual file size bigger than maxFileSize, but compressedSizeLen is smaller"), TestCasePriority(2)]
			class NAccessTokenOverflowFileData2 : TestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				uint			maxFileSize = req.accessToken.writeAT.maxFileSize;
				req.blobData = new byte[maxFileSize + 1];
				for (int i = 0; i < maxFileSize + 1; i++)
					req.blobData[i] = (byte)i;
				req.blobDataLen = maxFileSize + 1;
			//	req.uiBlobSizeCompressed = maxFileSize + 1;

				// 404 returned back to client
				if(!req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("ticket expiration time is greater than file expiration time"), TestCasePriority(2)]
			class NAccessTokenInvalidExpTime2 : WriteFileTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.accessToken.writeAT.fileExpirationDate = req.accessToken.writeAT.tokenExpirationDate - 100000;

				if(WriteFileSendAndVerify(req,true))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the pathnameLen is greater than the actual size"), TestCasePriority(2)]
			class NAccessTokenTruncatePathname : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.accessToken.baseAT.ManualArraySize = true;
				req.accessToken.baseAT.pathNameLen += 1;
				if( WriteFileTestNegative(req,true,HResult.XONLINE_E_INVALID_REQUEST)||
					WriteFileTestNegative(req,true,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the pathnameLen is less than the actual size"), TestCasePriority(2)]
			class NAccessTokenOverflowPathname : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.accessToken.baseAT.ManualArraySize = true;
				req.accessToken.baseAT.pathNameLen -= 1;
				if( WriteFileTestNegative(req,true,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the flags in AT is non-zero"), TestCasePriority(2)]
			class NAccessTokenInvalidFlags : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.accessToken.baseAT.flags = 1;

				if(WriteFileTestNegative(req,true,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		/***********************************************************************
		* Pathname Testing
		* *********************************************************************/
		[TestCase, Description("<Domain-part> is 63 unicode chars")]
			class PPathnameMaxDomainPart : WriteFileTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				string path = "//stats.111111111111111111111111111111111111111111111111111111111/u:"
					+ req.accessToken.baseAT.userPuid.ToString("x")
					+ "/" + req.uiTitleId.ToString("x") + "/"
					+ Guid.NewGuid().ToString();
				req.accessToken.baseAT.pathName = path;
				req.accessToken.baseAT.pathNameLen = (ushort)path.Length;

				if(WriteFileSendAndVerify(req,true))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass no IP part for the pathname")]
			class PPathnameNoIPPart : WriteFileTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				string path = "//stats/u:"
					+ req.accessToken.baseAT.userPuid.ToString("x")
					+ "/" + req.uiTitleId.ToString("x")+"/"
					+ Guid.NewGuid().ToString();
				req.accessToken.baseAT.pathName = path;
				req.accessToken.baseAT.pathNameLen = (ushort)path.Length;

				if(WriteFileSendAndVerify(req,true))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
//		[TestCase, Description("")] class PPathnameHasIPPart : WriteFileTestBase
//		{
//			public PPathnameHasIPPart()
//			{
//				Name = "PPathnameHasIPPart";
//				Desc = "pass IP part for the pathname";
//			}
//			override protected void Execute()
//			{
//				XRLWriteFile	req = new XRLWriteFile();
//				string path = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).TextDefault	//TODO: NEED TO CHECK
//					+ "//stats/u:"
//					+ req.accessToken.baseAT.userPuid.ToString("x")
//					+ "/"
//					+ Guid.NewGuid().ToString();
//				req.accessToken.baseAT.pathName = path;
//				req.accessToken.baseAT.pathNameLen = (ushort)path.Length;
//
//				if(WriteFileSendAndVerify(req,true))
//					ResultCode=TEST_RESULTS.PASSED;
//			}
//		}
		[TestCase, Description("pass u for the <ID-Namespace> in <Unique-ID-part>")]
			class PPathnameUserNameSpace : WriteFileTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				string path = "//stats/u:"
					+ req.accessToken.baseAT.userPuid.ToString("x")
					+ "/" + req.uiTitleId.ToString("x") + "/"
					+ Guid.NewGuid().ToString();
				req.accessToken.baseAT.pathName = path;
				req.accessToken.baseAT.pathNameLen = (ushort)path.Length;

				if(WriteFileSendAndVerify(req,true))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass max value for userPUID in <Unique-ID-part>")]
			class PPathnameMaxUserPUID : WriteFileTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				string path = "//stats/u:ffffffffffffffff"
					+ "/" + req.uiTitleId.ToString("x") + "/"
					+ Guid.NewGuid().ToString();
				req.accessToken.baseAT.pathName = path;
				req.accessToken.baseAT.pathNameLen = (ushort)path.Length;

				if(WriteFileSendAndVerify(req,true))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass min value for userPUID in <Unique-ID-part>")]
			class PPathnameMinUserPUID : WriteFileTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				string path = "//stats/u:1"
					+ "/" + req.uiTitleId.ToString("x") + "/"
					+ Guid.NewGuid().ToString();
				req.accessToken.baseAT.pathName = path;
				req.accessToken.baseAT.pathNameLen = (ushort)path.Length;

				if(WriteFileSendAndVerify(req,true))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("only specify domain in <Domain-part> (stats), no optional information")]
			class PPathnameNoOptionalDomainSpecifier : WriteFileTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				string path = "//stats/u:"
					+ req.accessToken.baseAT.userPuid.ToString("x")
					+ "/" + req.uiTitleId.ToString("x") + "/"
					+ Guid.NewGuid().ToString();
				req.accessToken.baseAT.pathName = path;
				req.accessToken.baseAT.pathNameLen = (ushort)path.Length;

				if(WriteFileSendAndVerify(req,true))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass a pathname that one null char in the middle of <Domain-part>"), TestCasePriority(2)]
			class NPathnameBadString1 : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	writeReq = new XRLWriteFile();
				string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
				newPath = pathName.Insert(6,'\0'.ToString());
				writeReq.accessToken.baseAT.pathName = newPath;
				writeReq.accessToken.baseAT.pathNameLen = (ushort)newPath.Length;

				//TODO: need to return xonline_e_storage_domain_not_supported
				if(WriteFileTestNegative(writeReq,true,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass a pathname that two null char in the middle of <Domain-part>"), TestCasePriority(2)]
			class NPathnameBadString2 : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	writeReq = new XRLWriteFile();
				string	pathName = writeReq.accessToken.baseAT.pathName, newPath, temp;
				temp = '\0'.ToString() + '\0'.ToString();
				newPath = pathName.Insert(6,temp);	// //stat..s/u:....
				writeReq.accessToken.baseAT.pathName = newPath;
				writeReq.accessToken.baseAT.pathNameLen = (ushort)newPath.Length;

				//TODO: need to return xonline_e_storage_domain_not_supported
				if(WriteFileTestNegative(writeReq,true,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass one nullchar in the middle of <userPUID>"), TestCasePriority(2)]
			class NPathnameBadString3 : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	writeReq = new XRLWriteFile();
				string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
				// //stats/u:123.456/xxxxx
				newPath = pathName.Insert(12,'\0'.ToString());
				writeReq.accessToken.baseAT.pathName = newPath;
				writeReq.accessToken.baseAT.pathNameLen = (ushort)newPath.Length;

				if(WriteFileTestNegative(writeReq,true,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass one nullchar in the middle of <pathpart>"), TestCasePriority(2)]
			class NPathnameBadString4 : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	writeReq = new XRLWriteFile();
				string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
				// //stats/u:123456/<pathpart>
				newPath = pathName.Insert(30,'\0'.ToString());
				writeReq.accessToken.baseAT.pathName = newPath;
				writeReq.accessToken.baseAT.pathNameLen = (ushort)newPath.Length;

				if(WriteFileTestNegative(writeReq,true,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass one nullchar at the end of <pathpart>"), TestCasePriority(2)]
			class NPathnameBadString5 : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	writeReq = new XRLWriteFile();
				string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
				// //stats/u:123456/<pathpart>
				newPath = pathName + '\0'.ToString();
				writeReq.accessToken.baseAT.pathName = newPath;
				writeReq.accessToken.baseAT.pathNameLen = (ushort)newPath.Length;

				if(WriteFileTestNegative(writeReq,true,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("<Domain-part> is greater than max allowed (63 unicode chars)"), TestCasePriority(2)]
			class NPathnameOverflowDomainLen : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				string path = "//stats.1111111111111111111111111111111111111111111111111111111111/u:"
					+ req.accessToken.baseAT.userPuid.ToString("x")
					+ "/" + req.uiTitleId.ToString("x") + "/"
					+ Guid.NewGuid().ToString();
				req.accessToken.baseAT.pathName = path;
				req.accessToken.baseAT.pathNameLen = (ushort)path.Length;

				if(WriteFileTestNegative(req,true,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("<Domain-part> is missing in pathname"), TestCasePriority(2)]
			class NPathnameNoDomainPart : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				string path = "/u:" + req.accessToken.baseAT.userPuid.ToString("x")
					+ "/" + Guid.NewGuid().ToString();
				req.accessToken.baseAT.pathName = path;
				req.accessToken.baseAT.pathNameLen = (ushort)path.Length;

				if(WriteFileTestNegative(req,true,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass a pathname that has no ID namespace (u)"), TestCasePriority(2)]
			class NPathnameNoIDNameSpace : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				string path = "//stats/:" + req.accessToken.baseAT.userPuid.ToString("x")
					+ "/" + req.uiTitleId.ToString("x") + "/"+ Guid.NewGuid().ToString();
				req.accessToken.baseAT.pathName = path;
				req.accessToken.baseAT.pathNameLen = (ushort)path.Length;

				if(WriteFileTestNegative(req,true,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass a pathname that has no userPUID following u"), TestCasePriority(2)]
			class NPathnameNoUserPUID : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				string path = "//stats/u:/" + req.uiTitleId.ToString("x") + "/"+Guid.NewGuid().ToString();
				req.accessToken.baseAT.pathName = path;
				req.accessToken.baseAT.pathNameLen = (ushort)path.Length;

				if(WriteFileTestNegative(req,true,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass a pathname that userPUID is invalid (greater than ulonglong)"), TestCasePriority(2)]
			class NPathnameOverflowUserPUID : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				string path = "//stats/u:" + "ffffffffffffffff1" + "/" + req.uiTitleId.ToString("x") + "/"+ Guid.NewGuid().ToString();
				req.accessToken.baseAT.pathName = path;
				req.accessToken.baseAT.pathNameLen = (ushort)path.Length;

				if(WriteFileTestNegative(req,true,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass 0 as userPUID in <Domain-part>"), TestCasePriority(2)]
			class NPathnameInvalidUserPUID : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				string path = "//stats/u:0" + "/"+ req.uiTitleId.ToString("x") + "/" + Guid.NewGuid().ToString();
				req.accessToken.baseAT.userPuid = 0;
				req.accessToken.baseAT.pathName = path;
				req.accessToken.baseAT.pathNameLen = (ushort)path.Length;

				if(WriteFileTestNegative(req,true,HResult.XONLINE_E_SERVER_ERROR))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass non stats for domain"), TestCasePriority(2)]
			class NPathnameNonExistDomain : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				string path = "//voice/u:8989/" + Guid.NewGuid().ToString();
				req.accessToken.baseAT.pathName = path;
				req.accessToken.baseAT.pathNameLen = (ushort)path.Length;

				if(WriteFileTestNegative(req,true,HResult.XONLINE_E_STORAGE_INVALID_PATH))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass invalid ID-Namespace"), TestCasePriority(2)]
			class NPathnameNonExistIDNameSpace : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				string path = "//stats/x:897789/" + req.uiTitleId.ToString("x") + "/"+ Guid.NewGuid().ToString();
				req.accessToken.baseAT.pathName = path;
				req.accessToken.baseAT.pathNameLen = (ushort)path.Length;

				if(WriteFileTestNegative(req,true,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass a pathname that is greater than 255"), TestCasePriority(2)]
			class NPathnameOverflowPathname : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				StringBuilder	pathName = new StringBuilder(req.accessToken.baseAT.pathName);
				int		i = 0, numCharToAdd = 256 - req.accessToken.baseAT.pathNameLen;
				while(i < numCharToAdd)
					pathName.Append(i++);
				req.accessToken.baseAT.pathNameLen = 256;
				req.accessToken.baseAT.pathName = pathName.ToString();

				if(WriteFileTestNegative(req,true,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass a pathname that has special chars"), TestCasePriority(2)]
			class NPathnameWrongCharSet : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				StringBuilder	pathName = new StringBuilder(req.accessToken.baseAT.pathName);
				//Bug 27831: domain and optional domain specified: A-Za-z0-9_
				// pathname allows anything except control chars('\0\, control characters, etc)
				char i = '\0';
				pathName.Append(i);
				req.accessToken.baseAT.pathNameLen++;
				req.accessToken.baseAT.pathName = pathName.ToString();

				if(WriteFileTestNegative(req,true,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		/*****************************************************************
		 *  Other stats w/attachments Testing
		 *****************************************************************/
        [TestCase, Description("try to update an existing file"), TestCasePriority(2)]
			class NUpdateExistingFile : WriteFileTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req1 = new XRLWriteFile(), req2 = new XRLWriteFile();

				req2.uiTitleId = req1.uiTitleId;
				req2.bUserCountryId = req1.bUserCountryId;
				req2.uiTitleVersion = req1.uiTitleVersion;
				ulong userPUID = req2.accessToken.baseAT.userPuid = req1.accessToken.baseAT.userPuid;

				req1.accessToken.baseAT.pathName = "//stats/u:" + userPUID.ToString("x")
					+ "/"+ req1.uiTitleId.ToString("x") + "/"
					+ Guid.NewGuid().ToString();
				req2.accessToken.baseAT.pathName = req1.accessToken.baseAT.pathName;

				// make sure the two blobs are different
				req2.blobHash[1] = (byte)(req1.blobHash[1]+1);

				req2.Slot.titleId = req2.uiTitleId;
				req2.Slot.titleVersion = req2.uiTitleVersion;
				req2.Slot.userPuid0 = userPUID;
				req2.Slot.userFlag0 = (uint)req2.bUserCountryId <<8;

				if(WriteFileSendAndVerify(req1,true))
				{
					// resign writeFile request2
					{
						byte[] signDataWithExtra = (byte[])req2.accessToken;
						int sizeDataToSign = req2.accessToken.baseAT.Size() + 20;						byte[] signData = new byte[sizeDataToSign];
						Array.Copy(signDataWithExtra, 0, signData, 0, sizeDataToSign);
						XSigSignature signature = new XSigSignature();
						signature.Initialize();
						signature._serviceId = (uint)XOService.Stats;

                        SHA1 sha1 = new SHA1CryptoServiceProvider();
                        signature.ComputeSignature(sha1.ComputeHash(signData));
						req2.accessToken.writeAT.signature = (byte [])signature;
					}

					if(!req2.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage))&&
						(req2.XErr == HResult.XONLINE_E_STORAGE_FILE_ALREADY_EXISTS))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		// TODO: this is only for stats w/attachment, which the userPUID in writeFile request is the same as
		// the one in the pathName; for other features, this test case don't have to use the same userPUID in the
		// writeFile requests but have to use the same userPUID in the pathName
		[TestCase, Description("userPUID and data blob are identical, but different <path-part> for two writeFile requests")]
			class PSameFileUploadTwiceBySameUser : WriteFileTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req1 = new XRLWriteFile(), req2 = new XRLWriteFile();

				req2.uiTitleId = req1.uiTitleId;
				req2.bUserCountryId = req1.bUserCountryId;
				req2.uiTitleVersion = req1.uiTitleVersion;
				ulong userPUID = req2.accessToken.baseAT.userPuid = req1.accessToken.baseAT.userPuid;

				req1.accessToken.baseAT.pathName = "//stats/u:" + userPUID.ToString("x")
					+ "/"+ req1.uiTitleId.ToString("x") + "/"
					+ Guid.NewGuid().ToString();
				req2.accessToken.baseAT.pathName = "//stats/u:" + userPUID.ToString("x")
					+ "/"+ req2.uiTitleId.ToString("x") + "/"
					+ Guid.NewGuid().ToString();

				req2.blobDataLen = req1.blobDataLen;
				req2.uiBlobSizeCompressed = req1.uiBlobSizeCompressed;
				for(int i = 0; i < req1.blobDataLen; i++)
					req2.blobData[i] = req1.blobData[i];

				for(int i = 0; i < Constants.sizeHash; i++)
					req2.blobHash[i] = req1.blobHash[i];

				req2.Slot.titleId = req2.uiTitleId;
				req2.Slot.titleVersion = req2.uiTitleVersion;
				req2.Slot.userPuid0 = userPUID;
				req2.Slot.userFlag0 = (uint)req2.bUserCountryId <<8;

				if((WriteFileSendAndVerify(req1,true)) && (WriteFileSendAndVerify(req2,true)))
				{
					// do other  additional check
					if(req1.CheckRefCount(req2,2, true))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		// bug27040:compute hash used to ref count blobs on server
		// need to use sameuserPUID so that they mapped to same logical partition
		[TestCase, Description("same fileSize and hash, but blob are different")]
			class PSameHashDiffrentFileContent : WriteFileTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req1 = new XRLWriteFile(), req2 = new XRLWriteFile();

				req2.uiTitleId = req1.uiTitleId;
				req2.bUserCountryId = req1.bUserCountryId;
				req2.uiTitleVersion = req1.uiTitleVersion;
				ulong userPUID = req2.accessToken.baseAT.userPuid = req1.accessToken.baseAT.userPuid;

				req1.accessToken.baseAT.pathName = "//stats/u:" + userPUID.ToString("x") + "/"
					+ req1.uiTitleId.ToString("x") + "/"+ Guid.NewGuid().ToString();
				req2.accessToken.baseAT.pathName = "//stats/u:" + userPUID.ToString("x") + "/"
					+ req2.uiTitleId.ToString("x") + "/"+ Guid.NewGuid().ToString();

				req2.blobDataLen = req1.blobDataLen;
				req2.uiBlobSizeCompressed = req1.uiBlobSizeCompressed;

				// reenforce the two files to have different contents
				req2.blobData[9] = (byte)((int)req1.blobData[9]+ 1);

				for(int i = 0; i < Constants.sizeHash; i++)
					req2.blobHash[i] = req1.blobHash[i];

				req2.Slot.titleId = req2.uiTitleId;
				req2.Slot.titleVersion = req2.uiTitleVersion;
				req2.Slot.userPuid0 = userPUID;
				req2.Slot.userFlag0 = (uint)req2.bUserCountryId <<8;

				if((WriteFileSendAndVerify(req1,true)) && (WriteFileSendAndVerify(req2,true)))
				{
					// do other additional check
					if(req1.CheckRefCount(req2,1,false))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		// This is how webstore repartition works; there will be two rows
		// added in both t_files and t_blobs
		[TestCase, Description("data blob are identical, but different userID and <path-part> for two writeFile requests")]
			class PSameFileUploadTwiceByDifferentUser : WriteFileTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req1 = new XRLWriteFile(), req2 = new XRLWriteFile();

				req2.uiTitleId = req1.uiTitleId;
				req2.uiTitleVersion = req1.uiTitleVersion;
				req2.Slot.titleId = req2.uiTitleId;
				req2.Slot.titleVersion = req2.uiTitleVersion;

				req2.blobDataLen = req1.blobDataLen;
				req2.uiBlobSizeCompressed = req1.uiBlobSizeCompressed;
				for(int i = 0; i < req1.blobDataLen; i++)
					req2.blobData[i] = req1.blobData[i];
				for(int i = 0; i < Constants.sizeHash; i++)
					req2.blobHash[i] = req1.blobHash[i];

				if((WriteFileSendAndVerify(req1,false)) && (WriteFileSendAndVerify(req2,false)))
						ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Multiple threads write a file simultaneously")]
			class PMultiThreadsWriteFile : WriteFileTestBase
		{
			override protected void Execute()
			{
				Thread [] threadArray = new Thread[10];
				for(int i = 0; i < 10; i++)
				{
					threadArray[i] = ThreadMaker.CreateThread(writeFileTS);
					threadArray[i].Name = i.ToString();
					threadArray[i].Start();
				}
				// the main thread is waiting for all threads to exit or timeout
				foreach (Thread t in threadArray)
					t.Join(10000);
				if(FailedReqs == 0)
					ResultCode=TEST_RESULTS.PASSED;
			}
			private void writeFileTS()
			{
				XRLWriteFile	writeReq = new XRLWriteFile();
				if(!WriteFileSendAndVerify(writeReq,false))
				{
					Global.RO.Warn(Thread.CurrentThread.Name+"writeFileTS: write file request/verify failed");
					Interlocked.Increment(ref FailedReqs);
				}
			}
			private	int FailedReqs = 0;
		}
		[TestCase, Description("write file 50 times")]
			class PWriteFileMultiTimes : WriteFileTestBase
		{
			override protected void Execute()
			{
				uint			uiFailedReq = 0;
				for(int i = 0; i < 50; i++)
				{
					XRLWriteFile	writeReq = new XRLWriteFile();
					if(!WriteFileSendAndVerify(writeReq,false))
						uiFailedReq++;
				}
				if(uiFailedReq == 0)
					ResultCode=TEST_RESULTS.PASSED;
				else
					Global.RO.Warn("It failed " + uiFailedReq.ToString() + " times");
			}
		}
		[TestCase, Description("the titleID in the request is not the acutal logged on title")]
			class PFamilyTitleID : WriteFileTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.Slot.titleId = req.uiTitleId + 1;
				req.Slot.altTitleId1 = req.uiTitleId;

				if(WriteFileSendAndVerify(req,false))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		/***********************************************************************
		* SG Auth Data Testing
		* *********************************************************************/
        [TestCase, Description("the userPUID in SGAuth response is not_found user"), TestCasePriority(2)]
			class NSGAuthNotFoundUser : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.Slot.UserExists = 0;

				if(WriteFileTestNegative(req,false,HResult.XONLINE_E_SERVER_ERROR))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the userPUID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidUser : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.Slot.userPuid0++;

				if(WriteFileTestNegative(req,false,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the TitleID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidTitleID : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.Slot.titleId++;

				if(WriteFileTestNegative(req,false,HResult.XONLINE_E_INVALID_TITLE_ID))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the XBoxPUID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidXBoxPUID : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.Slot.machinePuid++;

				if(WriteFileTestNegative(req,false,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the TitleVersion in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidTitleVersion : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.Slot.titleVersion++;

				if(WriteFileTestNegative(req,false,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the CountryID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidCountryID : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
				req.Slot.userFlag0 = (uint)((req.bUserCountryId+1)<<8);

				if(WriteFileTestNegative(req,false,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the Service ID in SGInfo is not set to storage"), TestCasePriority(2)]
			class nSGAuthInvalidServiceID : NegativeWFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	req = new XRLWriteFile();
                req.Slot.ClearServices();
				req.Slot.AddService(XOService.Stats);

				if(WriteFileTestNegative(req,false,HResult.XONLINE_E_SERVER_ERROR))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}

		/*****************************************************************
		 *  Hacked WriteFile request testing
		 *****************************************************************/
        [TestCase, Description("send garbage data, followed by valid requests"), TestCasePriority(2)]
			class NHackedRequest1 : NegativeWFTestBase
		{
			override protected void Execute()
			{
				MemoryStream	reqStream = new MemoryStream();
				BinaryWriter	bw = new BinaryWriter(reqStream);
				string			garbage = "fjiadpofjdipfjaipfiejfi0p9jafja;dfadfpaeifj;daj";
				bw.Write(garbage);
				bw.Write((ushort)Constants.Operation.FileWrite);
				bw.Write(Constants.accessTokenVersion);
				bw.Write((uint)XOService.Storage);
				bw.Write((uint)0);
				bw.Write((ulong)999);
				bw.Write((ulong)999);
				string pathName = "//stats/u:999/" + "999/"+ Guid.NewGuid().ToString();
				bw.Write((ushort)pathName.Length);
				byte [] path = new UTF8Encoding().GetBytes(pathName);
				bw.Write(path);
				bw.Write((long)789789078);
				bw.Write((long)789789000);
				bw.Write(Constants.maxFileSize);
				bw.Write(Constants.sizeSignature);
				byte [] accessTokenSig = new Byte[100];	//TODO: need to be signed by XSig
				bw.Write(accessTokenSig);
				bw.Write((uint)999);
				bw.Write((uint)999);
				bw.Write((byte)11);
				bw.Write((byte)0);
				bw.Write((uint)0);
				byte [] blobHash = new Byte[20];
				bw.Write(blobHash);
				byte [] blobSig = new Byte[100];
				bw.Write(blobSig);
				bw.Write((uint)100);	//100 byte blob data
				bw.Write((ushort)0);
				bw.Write((uint)100);
	//			bw.Write(attrib);
				byte [] blobData = new Byte[100];
				bw.Write(blobData);

				if(MyOwnExecute(reqStream,HResult.XONLINE_E_STORAGE_INVALID_REQUEST) ||
					MyOwnExecute(reqStream,HResult.XONLINE_E_STORAGE_ERROR))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("send valid requests followed by garbage data"), TestCasePriority(2)]
			class NHackedRequest2 : NegativeWFTestBase
		{
			override protected void Execute()
			{
				MemoryStream	reqStream = new MemoryStream();
				BinaryWriter	bw = new BinaryWriter(reqStream);
				bw.Write((ushort)Constants.Operation.FileWrite);
				bw.Write(Constants.accessTokenVersion);
				bw.Write((uint)XOService.Storage);
				bw.Write((uint)0);
				bw.Write((ulong)999);
				bw.Write((ulong)999);
				string pathName = "//stats/u:999/999/" + Guid.NewGuid().ToString();
				bw.Write((ushort)pathName.Length);
				byte [] path = new UTF8Encoding().GetBytes(pathName);
				bw.Write(path);
				bw.Write((long)789789078);
				bw.Write((long)789789000);
				bw.Write(Constants.maxFileSize);
				bw.Write(Constants.sizeSignature);
				byte [] accessTokenSig = new Byte[100];	//TODO: need to be signed by XSig
				bw.Write(accessTokenSig);
				bw.Write((uint)999);
				bw.Write((uint)999);
				bw.Write((byte)11);
				bw.Write((byte)0);
				bw.Write((uint)0);
				byte [] blobHash = new Byte[20];
				bw.Write(blobHash);
				byte [] blobSig = new Byte[100];
				bw.Write(blobSig);
				bw.Write((uint)100);	//100 byte blob data
				bw.Write((ushort)0);
				bw.Write((uint)100);
				byte [] blobData = new Byte[100];
				bw.Write(blobData);
				string			garbage = "afdfdfdfdffjiadpofjdipfjaipfiejfi0p9jafja;dfadfpaeifj;daj";
				bw.Write(garbage);

				if(MyOwnExecute(reqStream,HResult.XONLINE_E_STORAGE_ACCESS_DENIED)||
					MyOwnExecute(reqStream,HResult.XONLINE_E_STORAGE_ERROR))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\FuncGlobalTitleEnumFiles.cs ===
using System;
using System.Net;
using System.Text;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Storage;
using ServerTestFramework.Utilities;
using xonline.common.config;

namespace XStoreTest
{
	internal abstract class GlobalTitleEnumFilesTestBase : TestBase
	{
		//	send WriteFile requests first; then send readfile;verifies the response
		protected bool EnumFilesSendAndVerify(uint titleID, XRLEnumFiles enumReq, XRLWriteFile[] writeReqs, uint expectedFilesTotal, uint expectedFilesReturn, bool checkEachFile)
		{
			string	hexTitleID = titleID.ToString("x");
			string	xrl = "";
			// write files for this title
			uint	numFiles = (uint)writeReqs.Length;
			for(int i = 0; i < numFiles; i++)
			{
				xrl = "//title."+hexTitleID+"/t:"+hexTitleID+"/"+Guid.NewGuid().ToString();
				writeReqs[i] = new XRLWriteFile("ServiceAddr",xrl);
				if(i % 2 ==0)
				{
					writeReqs[i].attributes = new byte[50];
					new Random().NextBytes(writeReqs[i].attributes);
					writeReqs[i].attributesLen = 50;
				}
				if(!writeReqs[i].Execute())
				{
					Global.RO.Warn("WriteFile request failed"+ writeReqs[i].XErr.ToString());
					return false;
				}
			}

			XRLEnumFilesResponse		enumResp;
			if(enumReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out enumResp))
			{
				if(enumResp.numFilesTotal != expectedFilesTotal)
				{
                    Global.RO.Warn("numFilesTotal(" + enumResp.numFilesTotal + ") is not correct; expected " + expectedFilesTotal);
					return false;
				}
				if(enumResp.resultsLen != expectedFilesReturn)
				{
					Global.RO.Warn("numFiles returned is not correct");
					return false;
				}
				// check each returned file
				if(checkEachFile)
				{
					for (int i = 0; i < expectedFilesReturn; i++)
					{
						if(!enumResp.results[i].Compare(writeReqs[i]))
						{
							Global.RO.Warn("The returned file is not correct");
							return false;
						}
					}
				}
				return true;
			}
			else
			{
				Global.RO.Warn("Failed send EnumFiles request");
				return false;
			}
		}
	}
	internal abstract class GlobalTitleNegEnumFilesTestBase : TestBase
	{
		//	send readFile requests, then check the error code
		protected bool EnumFilesTestNegative(XRLEnumFiles Req, uint XErr)
		{
			XRLEnumFilesResponse		resp;
			if (Req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out resp))
			{
				Global.RO.Warn("Negative EnumFiles request succeed unexpectedly");
				return false;
			}
			if((Req.XErr != XErr) || (resp != null))
			{
				Global.RO.Warn("Wrong error code " + Global.XErrToString(Req.XErr) +" returned or Resp is not null");
				return false;
			}
			return true;
		}
	}
    [TestGroup, Owner("JKonkle"), TestFrequency("Regression"), TestCasePriority(1)]
	public class FuncGlobalTitleEnumFiles : TestNode
	{
		[TestCase, Description("Write 10 files for a given title, pass an lmodified that 1 out of 5 matching ones will be returned")]
			class PEnumPartFiles3 : TestBase
		{
			override protected void Execute()
			{
				long	modifiedSince = 0;
				uint	TitleID = (uint)new Random().Next();
				string	hexTitleID = TitleID.ToString("x");
				string	enumXrl = "//title."+hexTitleID+"/t:"+hexTitleID+"/roster*", xrl="";
				string	expectedPathName = "";
				XRLWriteFile[]	writeReqs = new XRLWriteFile[10];
				for(int i = 0; i < 10; i++)
				{
					if(i < 5)
					{
						xrl = "//title."+hexTitleID+"/t:"+hexTitleID+"/roster"+Guid.NewGuid().ToString();
						if(i == 4)
						{
					//		modifiedSince = (long)System.DateTime.UtcNow.ToFileTimeUtc();
							expectedPathName = xrl;
							Thread.Sleep(2000);
						}
					}
					else
						xrl = "//title."+hexTitleID+"/t:"+hexTitleID+"/emem"+Guid.NewGuid().ToString();
					writeReqs[i] = new XRLWriteFile("ServiceAddr",xrl);
					// make sure the 10 files has 10 different blobs
					writeReqs[i].blobData[0] = (byte)i;
					if(i % 2 ==0)
					{
						writeReqs[i].attributes = new byte[50];
						new Random().NextBytes(writeReqs[i].attributes);
						writeReqs[i].attributesLen = 50;
					}
					if(!writeReqs[i].Execute())
					{
						Global.RO.Warn("WriteFile request failed"+ writeReqs[i].XErr.ToString());
						return;
					}
					else if (i == 4)	// get the modified Time by reading the 4th file
					{
						XRLReadFile		readReq = new XRLReadFile(xrl);
						readReq.Slot.titleId = readReq.uiTitleId = writeReqs[i].uiTitleId;
						readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReqs[i].uiTitleVersion;
						XRLReadFileResponse	readResp;
						if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
							modifiedSince = readResp.lCreationDate;
						else
						{
							Global.RO.Warn("ReadFile request failed"+ readReq.XErr.ToString());
							return;
						}
					}
				}

				XRLEnumFilesResponse		enumResp;
				XRLEnumFiles	enumReq = new XRLEnumFiles(enumXrl,TitleID,0,9,modifiedSince);
				if(enumReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out enumResp))
				{	// check returned results
					if(enumResp.numFilesTotal == 1 && (enumResp.resultsLen == 1))
					{
						if(String.Compare(enumResp.results[0].pathName,expectedPathName) == 0)
							ResultCode=TEST_RESULTS.PASSED;
						else
							Global.RO.Warn("Returned file is not correct;expected is "+expectedPathName+"actual returned is "+enumResp.results[0].pathName);
					}
					else
						Global.RO.Warn("numFilesTotal"+enumResp.numFilesTotal+" or numFilesResponse "+enumResp.resultsLen+" is not correct");
				}
			}
		}
		[TestCase, Description("Check X-Delay header in the http response")]
		class PThrottling : GlobalTitleEnumFilesTestBase
		{
			override protected void Execute()
			{
				long	modifiedSince = (long)System.DateTime.UtcNow.AddHours(-1).ToFileTimeUtc();
				uint	TitleID = (uint)new Random().Next();
				string	hexTitleID = TitleID.ToString("x");
				string	enumXrl = "//title."+hexTitleID+"/t:"+hexTitleID+"/*";
				XRLWriteFile[]	writeReqs = new XRLWriteFile[1];
				XRLEnumFiles	enumReq = new XRLEnumFiles(enumXrl,TitleID,0,9,modifiedSince);

				int Xdelay= 3000;
				Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage,"exec :stfd SetXDelay "+enumReq.uiTitleId.ToString("X")+" enumerateFiles "+Xdelay);

				if(EnumFilesSendAndVerify(TitleID,enumReq,writeReqs,1,1,false)&& (enumReq.XDelay == Xdelay))
					ResultCode=TEST_RESULTS.PASSED;

				Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage,"exec :stfd ReloadThrottleConfig");

			}
		}
		[TestCase, Description("titleID in the request is not the one the user is logged on")]
			class PFamilyTitleID : GlobalTitleEnumFilesTestBase
		{
			override protected void Execute()
			{
				long	modifiedSince = (long)System.DateTime.UtcNow.AddHours(-1).ToFileTimeUtc();
				uint	TitleID = (uint)new Random().Next();
				string	hexTitleID = TitleID.ToString("x");
				string	enumXrl = "//title."+hexTitleID+"/t:"+hexTitleID+"/*";
				XRLWriteFile[]	writeReqs = new XRLWriteFile[1];
				XRLEnumFiles	enumReq = new XRLEnumFiles(enumXrl,TitleID,0,9,modifiedSince);
				enumReq.Slot.titleId = enumReq.uiTitleId + 1;
				enumReq.Slot.altTitleId1 = enumReq.uiTitleId;

				if(EnumFilesSendAndVerify(TitleID,enumReq,writeReqs,1,1,false))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("enumerate one file and check the file's content")]
		class PEnumOneFile : GlobalTitleEnumFilesTestBase
		{
			override protected void Execute()
			{
				long	modifiedSince = (long)System.DateTime.UtcNow.AddHours(-1).ToFileTimeUtc();
				uint	TitleID = (uint)new Random().Next();
				string	hexTitleID = TitleID.ToString("x");
				string	enumXrl = "//title."+hexTitleID+"/t:"+hexTitleID+"/*";
				XRLWriteFile[]	writeReqs = new XRLWriteFile[1];
				XRLEnumFiles	enumReq = new XRLEnumFiles(enumXrl,TitleID,0,1,modifiedSince);

				if(EnumFilesSendAndVerify(TitleID,enumReq,writeReqs,1,1,true))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write 10 files for a given title, enumerate all files")]
		class PEnumAllFiles : GlobalTitleEnumFilesTestBase
		{
			override protected void Execute()
			{
				long	modifiedSince = (long)System.DateTime.UtcNow.AddHours(-1).ToFileTimeUtc();
				uint	TitleID = (uint)new Random().Next();
				string	hexTitleID = TitleID.ToString("x");
				string	enumXrl = "//title."+hexTitleID+"/t:"+hexTitleID+"/*";
				XRLWriteFile[]	writeReqs = new XRLWriteFile[10];
				XRLEnumFiles	enumReq = new XRLEnumFiles(enumXrl,TitleID,0,9,modifiedSince);

				if(EnumFilesSendAndVerify(TitleID,enumReq,writeReqs,10,10,false))
						ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass rangeStart=0,rangeEnd=5")]
		class PEnumFirstFiles : GlobalTitleEnumFilesTestBase
		{
			override protected void Execute()
			{
				long	modifiedSince = (long)System.DateTime.UtcNow.AddHours(-1).ToFileTimeUtc();
				uint	TitleID = (uint)new Random().Next();
				string	hexTitleID = TitleID.ToString("x");
				string	enumXrl = "//title."+hexTitleID+"/t:"+hexTitleID+"/*";
				XRLWriteFile[]	writeReqs = new XRLWriteFile[10];
				XRLEnumFiles	enumReq = new XRLEnumFiles(enumXrl,TitleID,0,5,modifiedSince);

				if(EnumFilesSendAndVerify(TitleID,enumReq,writeReqs,10,6,false))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass rangeStart=4,rangeEnd=8")]
		class PEnumMiddleFiles : GlobalTitleEnumFilesTestBase
		{
			override protected void Execute()
			{
				long	modifiedSince = (long)System.DateTime.UtcNow.AddHours(-1).ToFileTimeUtc();
				uint	TitleID = (uint)new Random().Next();
				string	hexTitleID = TitleID.ToString("x");
				string	enumXrl = "//title."+hexTitleID+"/t:"+hexTitleID+"/*";
				XRLWriteFile[]	writeReqs = new XRLWriteFile[10];
				XRLEnumFiles	enumReq = new XRLEnumFiles(enumXrl,TitleID,4,8,modifiedSince);

				if(EnumFilesSendAndVerify(TitleID,enumReq,writeReqs,10,5,false))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass rangeStart=5,rangeEnd=9")]
		class PEnumLastFiles : GlobalTitleEnumFilesTestBase
		{
			override protected void Execute()
			{
				long	modifiedSince = (long)System.DateTime.UtcNow.AddHours(-1).ToFileTimeUtc();
				uint	TitleID = (uint)new Random().Next();
				string	hexTitleID = TitleID.ToString("x");
				string	enumXrl = "//title."+hexTitleID+"/t:"+hexTitleID+"/*";
				XRLWriteFile[]	writeReqs = new XRLWriteFile[10];
				XRLEnumFiles	enumReq = new XRLEnumFiles(enumXrl,TitleID,5,9,modifiedSince);

				if(EnumFilesSendAndVerify(TitleID,enumReq,writeReqs,10,5,false))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write 10 files for a given title, pass a lModifiedSince so none is is returned")]
		class PEnumNoFiles : GlobalTitleEnumFilesTestBase
		{
			override protected void Execute()
			{
				long	modifiedSince = (long)System.DateTime.UtcNow.AddDays(1).ToFileTimeUtc();
				uint	TitleID = (uint)new Random().Next();
				string	hexTitleID = TitleID.ToString("x");
				string	enumXrl = "//title."+hexTitleID+"/t:"+hexTitleID+"/*";
				XRLWriteFile[]	writeReqs = new XRLWriteFile[10];
				XRLEnumFiles	enumReq = new XRLEnumFiles(enumXrl,TitleID,0,5,modifiedSince);

				if(EnumFilesSendAndVerify(TitleID,enumReq,writeReqs,0,0,false))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("write 5 files for a given title, pass 5 as rangeStart")]
		class PInvalidrangEnd: GlobalTitleEnumFilesTestBase
		{
			override protected void Execute()
			{
				// check there should be no results returned
				long	modifiedSince = (long)System.DateTime.UtcNow.AddHours(-1).ToFileTimeUtc();
				uint	TitleID = (uint)new Random().Next();
				string	hexTitleID = TitleID.ToString("x");
				string	enumXrl = "//title."+hexTitleID+"/t:"+hexTitleID+"/*";
				XRLWriteFile[]	writeReqs = new XRLWriteFile[5];
				XRLEnumFiles	enumReq = new XRLEnumFiles(enumXrl,TitleID,5,9,modifiedSince);

				if(EnumFilesSendAndVerify(TitleID,enumReq,writeReqs,5,0,false))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("write 5 files for a given title, pass rangeStart=0,end=5")]
		class PRequestMoreFiles: GlobalTitleEnumFilesTestBase
		{
			override protected void Execute()
			{
				// check there should be 5 results returned
				long	modifiedSince = (long)System.DateTime.UtcNow.AddHours(-1).ToFileTimeUtc();
				uint	TitleID = (uint)new Random().Next();
				string	hexTitleID = TitleID.ToString("x");
				string	enumXrl = "//title."+hexTitleID+"/t:"+hexTitleID+"/*";
				XRLWriteFile[]	writeReqs = new XRLWriteFile[5];
				XRLEnumFiles	enumReq = new XRLEnumFiles(enumXrl,TitleID,0,5,modifiedSince);

				if(EnumFilesSendAndVerify(TitleID,enumReq,writeReqs,5,5,false))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write 10 files for two titles, pass an xrl that enum files for one title")]
		class PEnumOneTitleOnly : TestBase
		{
			override protected void Execute()
			{
				long	modifiedSince = (long)System.DateTime.UtcNow.AddHours(-1).ToFileTimeUtc();
				uint	TitleID1 = (uint)new Random().Next(),TitleID2 = TitleID1 + 10;
				string	hexTitleID1 = TitleID1.ToString("x"),hexTitleID2 = TitleID2.ToString("x");
				string	enumXrl = "//title."+hexTitleID2+"/t:"+hexTitleID2+"/*", xrl="";
				XRLWriteFile[]	writeReqs = new XRLWriteFile[10];
				for(int i = 0; i < 10; i++)
				{
					if(i < 5)
						xrl = "//title."+hexTitleID1+"/t:"+hexTitleID1+"/"+Guid.NewGuid().ToString();
					else
						xrl = "//title."+hexTitleID2+"/t:"+hexTitleID2+"/"+Guid.NewGuid().ToString();
					writeReqs[i] = new XRLWriteFile("ServiceAddr",xrl);
					if(i % 2 ==0)
					{
						writeReqs[i].attributes = new byte[50];
						new Random().NextBytes(writeReqs[i].attributes);
						writeReqs[i].attributesLen = 50;
					}
					if(!writeReqs[i].Execute())
					{
						Global.RO.Warn("WriteFile request failed"+ writeReqs[i].XErr.ToString());
						return;
					}
				}

				XRLEnumFilesResponse		enumResp;
				XRLEnumFiles	enumReq = new XRLEnumFiles(enumXrl,TitleID2,0,9,modifiedSince);
				if(enumReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out enumResp))
				{	// check returned results
					if(enumResp.numFilesTotal == 5 && (enumResp.resultsLen == 5))
					{
						bool ret = true;
						for(int i = 0; i < 5; i++)
						{
							if(enumResp.results[i].uiTitleId != TitleID2)
							{
								Global.RO.Warn("Returned file is not for the right title");
								ret = false;
								break;
							}
						}
						if(ret)
							ResultCode=TEST_RESULTS.PASSED;
					}
				}
			}
		}
		[TestCase, Description("Write 10 files for a given title, pass an xrl(roster*) that 5 will be returned")]
		class PEnumPartFiles1 : TestBase
		{
			override protected void Execute()
			{
				// create 5 files with ..../roster*, another 5 with .../emem*;pass xrl that /roster*
				long	modifiedSince = (long)System.DateTime.UtcNow.AddHours(-1).ToFileTimeUtc();
				uint	TitleID = (uint)new Random().Next();
				string	hexTitleID = TitleID.ToString("x");
				string	enumXrl = "//title."+hexTitleID+"/t:"+hexTitleID+"/roster*", xrl="";
				XRLWriteFile[]	writeReqs = new XRLWriteFile[10];
				for(int i = 0; i < 10; i++)
				{
					if(i < 5)
						xrl = "//title."+hexTitleID+"/t:"+hexTitleID+"/roster"+Guid.NewGuid().ToString();
					else
						xrl = "//title."+hexTitleID+"/t:"+hexTitleID+"/emem"+Guid.NewGuid().ToString();
					writeReqs[i] = new XRLWriteFile("ServiceAddr",xrl);
					if(i % 2 ==0)
					{
						writeReqs[i].attributes = new byte[50];
						new Random().NextBytes(writeReqs[i].attributes);
						writeReqs[i].attributesLen = 50;
					}
					if(!writeReqs[i].Execute())
					{
						Global.RO.Warn("WriteFile request failed"+ writeReqs[i].XErr.ToString());
						return;
					}
				}

				XRLEnumFilesResponse		enumResp;
				XRLEnumFiles	enumReq = new XRLEnumFiles(enumXrl,TitleID,0,9,modifiedSince);
				if(enumReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out enumResp))
				{	// check returned results
					if(enumResp.numFilesTotal == 5 && (enumResp.resultsLen == 5))
					{
						bool ret = true;
						for(int i = 0; i < 5; i++)
						{
							if(enumResp.results[i].pathName.IndexOf("roster")==-1)
							{
								Global.RO.Warn("Returned file is not roster*");
								ret = false;
								break;
							}
						}
						if(ret)
							ResultCode=TEST_RESULTS.PASSED;
					}
				}
			}
		}
		[TestCase, Description("Write 10 files for a given title, pass an xrl(*.txt) that 5 will be returned")]
		class PEnumPartFiles2 : TestBase
		{
			override protected void Execute()
			{
				// create 5 files with ..../*.txt, another 5 with .../*.doc;pass xrl that /*.txt
				long	modifiedSince = (long)System.DateTime.UtcNow.AddHours(-1).ToFileTimeUtc();
				uint	TitleID = (uint)new Random().Next();
				string	hexTitleID = TitleID.ToString("x");
				string	enumXrl = "//title."+hexTitleID+"/t:"+hexTitleID+"/*.txt", xrl="";
				XRLWriteFile[]	writeReqs = new XRLWriteFile[10];
				for(int i = 0; i < 10; i++)
				{
					if(i < 5)
						xrl = "//title."+hexTitleID+"/t:"+hexTitleID+"/"+Guid.NewGuid().ToString()+".txt";
					else
						xrl = "//title."+hexTitleID+"/t:"+hexTitleID+"/"+Guid.NewGuid().ToString()+".doc";
					writeReqs[i] = new XRLWriteFile("ServiceAddr",xrl);
					if(i % 2 ==0)
					{
						writeReqs[i].attributes = new byte[50];
						new Random().NextBytes(writeReqs[i].attributes);
						writeReqs[i].attributesLen = 50;
					}
					if(!writeReqs[i].Execute())
					{
						Global.RO.Warn("WriteFile request failed"+ writeReqs[i].XErr.ToString());
						return;
					}
				}

				XRLEnumFilesResponse		enumResp;
				XRLEnumFiles	enumReq = new XRLEnumFiles(enumXrl,TitleID,0,9,modifiedSince);
				if(enumReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out enumResp))
				{	// check returned results
					if(enumResp.numFilesTotal == 5 && (enumResp.resultsLen == 5))
					{
						bool ret = true;
						for(int i = 0; i < 5; i++)
						{
							if(enumResp.results[i].pathName.EndsWith(".txt") == false)
							{
								Global.RO.Warn("Returned file is not ending with .txt");
								ret = false;
								break;
							}
						}
						if(ret)
							ResultCode=TEST_RESULTS.PASSED;
					}
				}
			}
		}

		/**************************************************************************************
		 * negtative Cases
		 **************************************************************************************/
        [TestCase, Description("Tries to enum for all titles"), TestCasePriority(2)]
		class NEnumAllTitles : GlobalTitleNegEnumFilesTestBase
		{
			override protected void Execute()
			{
				long	modifiedSince = (long)System.DateTime.UtcNow.AddHours(-1).ToFileTimeUtc();
                uint titleId = (uint)RandomEx.GlobalRandGen.Next();
                string enumXrl = string.Format("//title.{0:X8}/*", titleId);

                XRLEnumFiles enumReq = new XRLEnumFiles(enumXrl, titleId, 0, 10, modifiedSince);
				if(EnumFilesTestNegative(enumReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("tries to enum files from a different title"), TestCasePriority(2)]
		class NEnumFromDifferentTitle : TestBase
		{
			override protected void Execute()
			{
				// create a file for title 0x1234
				string xrl = "//title.1234/u:8989/1234/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("ServiceAddr",xrl);

				long	modifiedSince = (long)System.DateTime.UtcNow.AddHours(-1).ToFileTimeUtc();
				string	enumXrl = "//title.1234/u:8989/1234/*";
				XRLEnumFiles	enumReq = new XRLEnumFiles(enumXrl,0x1245,0,10,modifiedSince);
				XRLEnumFilesResponse		enumResp;
				if(enumReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out enumResp)&& (enumResp.resultsLen==0))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("tries to enumerateFiles for perTitlePerUser"), TestCasePriority(2)]
			class NEnumPerTitlePerUser : GlobalTitleNegEnumFilesTestBase
		{
			override protected void Execute()
			{
				long	modifiedSince = (long)System.DateTime.UtcNow.ToFileTimeUtc();
                uint titleId = (uint)RandomEx.GlobalRandGen.Next();                
                ulong ownerPUID = (RandomEx.GlobalRandGen.NextUlong() & ServerTestFramework.LiveService.Auth.SgClient.k_CounterPuidMask) | ServerTestFramework.LiveService.Auth.SgClient.k_UserPuidMask;
                
                string enumXrl = string.Format("//tuser.{0:X8}/u:{1:X8}/{0:X8}/*", titleId, ownerPUID);
                XRLEnumFiles enumReq = new XRLEnumFiles(enumXrl, titleId, 0, 9, modifiedSince);

				if(EnumFilesTestNegative(enumReq,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("34939/35333:tries to enumerateFiles for perTitleperTeam"), TestCasePriority(2)]
			class NEnumPerTitlePerTeam : GlobalTitleNegEnumFilesTestBase
		{
			override protected void Execute()
			{
				long	modifiedSince = (long)System.DateTime.UtcNow.ToFileTimeUtc();
				uint	TitleID = (uint)new Random().Next();
				ulong	teamPUID = (ulong)(new Random().NextDouble()*0xffffffffffffffff);
				string	hexTitleID = TitleID.ToString("x");
				string	enumXrl = "//tteam."+hexTitleID+"/u:"+teamPUID.ToString("x")+"/"+hexTitleID+"/*";
				XRLEnumFiles	enumReq = new XRLEnumFiles(enumXrl,TitleID,0,9,modifiedSince);

				if(EnumFilesTestNegative(enumReq,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("tries to enumerateFiles for Msg storage"), TestCasePriority(2)]
			class NEnumMsg : GlobalTitleNegEnumFilesTestBase
		{
			override protected void Execute()
			{
				long	modifiedSince = (long)System.DateTime.UtcNow.ToFileTimeUtc();
				ulong	userPUID = (ulong)(new Random().NextDouble()*0xffffffffffffffff);
				string	enumXrl = "//msg.ab"+"/u:"+userPUID.ToString("x")+"/*";
				XRLEnumFiles	enumReq = new XRLEnumFiles(enumXrl,0x89898,0,9,modifiedSince);

				if(EnumFilesTestNegative(enumReq,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		/***********************************************************************
		* SG Auth Data Testing
		* *********************************************************************/
        [TestCase, Description("the userPUID in SGAuth response is not_found user"), TestCasePriority(2)]
			class NSGAuthNotFoundUser : GlobalTitleNegEnumFilesTestBase
		{
			override protected void Execute()
			{
				long	modifiedSince = (long)System.DateTime.UtcNow.AddHours(-1).ToFileTimeUtc();
				string	enumXrl = "//title.1234/t:1234/*";
				XRLEnumFiles	req = new XRLEnumFiles(enumXrl,0x1234,0,10,modifiedSince);
				req.Slot.UserExists = 0;

				if(EnumFilesTestNegative(req,HResult.XONLINE_E_SERVER_ERROR))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the userPUID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidUser : GlobalTitleNegEnumFilesTestBase
		{
			override protected void Execute()
			{
				long	modifiedSince = (long)System.DateTime.UtcNow.AddHours(-1).ToFileTimeUtc();
				string	enumXrl = "//title.1234/t:1234/*";
				XRLEnumFiles	req = new XRLEnumFiles(enumXrl,0x1234,0,10,modifiedSince);
				req.Slot.userPuid0++;

				if(EnumFilesTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the TitleID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidTitleID : GlobalTitleNegEnumFilesTestBase
		{
			override protected void Execute()
			{
				long	modifiedSince = (long)System.DateTime.UtcNow.AddHours(-1).ToFileTimeUtc();
				string	enumXrl = "//title.1234/t:1234/*";
				XRLEnumFiles	req = new XRLEnumFiles(enumXrl,0x1234,0,10,modifiedSince);
				req.Slot.titleId++;

				if(EnumFilesTestNegative(req,HResult.XONLINE_E_INVALID_TITLE_ID))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the XBoxPUID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidXBoxPUID : GlobalTitleNegEnumFilesTestBase
		{
			override protected void Execute()
			{
				long	modifiedSince = (long)System.DateTime.UtcNow.AddHours(-1).ToFileTimeUtc();
				string	enumXrl = "//title.1234/t:1234/*";
				XRLEnumFiles	req = new XRLEnumFiles(enumXrl,0x1234,0,10,modifiedSince);
				req.Slot.machinePuid++;

				if(EnumFilesTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the TitleVersion in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidTitleVersion : GlobalTitleNegEnumFilesTestBase
		{
			override protected void Execute()
			{
				long	modifiedSince = (long)System.DateTime.UtcNow.AddHours(-1).ToFileTimeUtc();
				string	enumXrl = "//title.1234/t:1234/*";
				XRLEnumFiles	req = new XRLEnumFiles(enumXrl,0x1234,0,10,modifiedSince);
				req.Slot.titleVersion++;

				if(EnumFilesTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the CountryID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidCountryID : GlobalTitleNegEnumFilesTestBase
		{
			override protected void Execute()
			{
				long	modifiedSince = (long)System.DateTime.UtcNow.AddHours(-1).ToFileTimeUtc();
				string	enumXrl = "//title.1234/t:1234/*";
				XRLEnumFiles	req = new XRLEnumFiles(enumXrl,0x1234,0,10,modifiedSince);
				req.Slot.userFlag0 = (uint)((req.bUserCountryId+1)<<8);

				if(EnumFilesTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}

        abstract class PEnumCacheBasicTestBase : TestBase
        {
            private static ServerTestFramework.Utilities.RandomEx RandGen =
                new ServerTestFramework.Utilities.RandomEx();

            protected const uint DashTitleID = XOn.XENON_DASH_TITLE_ID;
            protected const uint NonDashTitleID = XOn.XENON_DASH_TITLE_ID + 1;

            protected enum Domain
            {
                title,
                global
            }

            [Flags]
            protected enum EnumWith : int
            {
                Default = 0,
                Wildcard = 1,
                ModifiedSince = 2
            }

            private bool IsFlagSet(EnumWith enumWith, EnumWith test)
            {
                return (enumWith & test) == test;
            }

            protected string GenerateTitleFilePath(uint titleID)
            {
                return "//title." + titleID.ToString("x") + "/t:" + titleID.ToString("x") + "/" + Guid.NewGuid().ToString();
            }

            protected string GenerateGlobalFilePath(uint titleID)
            {
                // format:          //global/t:titleId/ach/version/filename
                // ex. path name:   //global/t:fffe0000/ach/7f65b06d/0
                return "//global/t:" + titleID.ToString("x") + "/ach/" + RandGen.Next().ToString("x") + "/0";
            }

            protected string GetWriteFilePath(uint titleID, Domain domain)
            {
                switch (domain)
                {
                    case Domain.title: return GenerateTitleFilePath(titleID);
                    case Domain.global: return GenerateGlobalFilePath(titleID);
                    default: throw new UnexpectedTestResultException("Unknown domain " + domain);
                }
            }

            protected string GetEnumFilePath(string writeFilePath, EnumWith enumWith)
            {
                string enumFilePath = writeFilePath;
                if (IsFlagSet(enumWith, EnumWith.Wildcard))
                {
                    enumFilePath = enumFilePath.Substring(0, enumFilePath.Length - 5) + "*";
                    //enumFilePath = enumFilePath.Substring(0, writeFilePath.LastIndexOf('/') + 1) + "*";
                }
                Global.RO.Info("GetEnumFilePath(" + writeFilePath + ") returning " + enumFilePath);
                return enumFilePath;
            }

            protected XRLEnumFilesResponse FindFileInCache(uint titleID, Domain domain, EnumWith enumWith, bool expectToFindFiles)
            {
                // Write File
                string writeFilePath = GetWriteFilePath(titleID, domain);
                XRLWriteFile writeReq = new XRLWriteFile("ServiceAddr", writeFilePath);
                if (!writeReq.Execute())
                {
                    throw new UnexpectedTestResultException("WriteFile failed: " + writeReq.XErr);
                }

                //long modifiedSince = (long)System.DateTime.UtcNow.AddHours(-1).ToFileTimeUtc();
                //uint TitleID = (uint)new Random().Next();
                //string hexTitleID = TitleID.ToString("x");
                //string enumXrl = "//title." + hexTitleID + "/t:" + hexTitleID + "/*";
                //XRLWriteFile[] writeReqs = new XRLWriteFile[10];
                //XRLEnumFiles enumReq = new XRLEnumFiles(enumXrl, TitleID, 0, 9, modifiedSince);

                long modifiedSince = 0;
                if (IsFlagSet(enumWith, EnumWith.ModifiedSince))
                {
                    modifiedSince = (long)System.DateTime.UtcNow.AddHours(-1).ToFileTimeUtc();
                }

                // Enum File (from DB)
                string enumFilePath = GetEnumFilePath(writeReq.accessToken.baseAT.pathName, enumWith);

                try
                {
                    XRLEnumFiles enumReq = new XRLEnumFiles(enumFilePath, titleID, 0, 99, modifiedSince);
                    XRLEnumFilesResponse enumResp;
                    if (!enumReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out enumResp))
                    {
                        throw new UnexpectedTestResultException("EnumFile(1) failed: " + enumReq.XErr);
                    }
                    if (enumResp.resultsLen == 0)
                    {
                        throw new UnexpectedTestResultException("EnumFile(1) failed: enumResp.resultsLen == 0");
                    }
                }
                finally
                {
                    // Remove File
                    // the file now is in the cache;
                    // remove the actual file, then read the file again
                    XRLRemoveFile removeReq = new XRLRemoveFile(writeReq.accessToken.baseAT.pathName, titleID, "ServiceAddr");
                    if (!removeReq.Execute())
                    {
                        throw new UnexpectedTestResultException("RemoveFile failed: " + removeReq.XErr);
                    }
                }

                // Enum File (from cache)
                XRLEnumFiles enumReq2 = new XRLEnumFiles(enumFilePath, titleID, 0, 99, modifiedSince);
                XRLEnumFilesResponse enumResp2;
                if (!enumReq2.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out enumResp2))
                {
                    throw new UnexpectedTestResultException("EnumFile(2) failed: " + enumReq2.XErr);
                }
                Global.RO.Info("EnumFile(2) got back " + enumResp2.resultsLen + " results");
                if (enumResp2.resultsLen == 0 && expectToFindFiles)
                {
                    throw new UnexpectedTestResultException("EnumFile(2) didn't find expected file(s); count = " + enumResp2.resultsLen);
                }
                if (enumResp2.resultsLen > 0 && !expectToFindFiles)
                {
                    throw new UnexpectedTestResultException("EnumFile(2) found unexpected file(s); count = " + enumResp2.resultsLen +
                        "; first filepath = " + enumResp2.results[0].pathName);
                }
                if (enumResp2.resultsLen != 0)
                {
                    Global.RO.Info("writeReq.accessToken.baseAT.pathName.ToLower() == " + writeReq.accessToken.baseAT.pathName.ToLower());
                    bool found = false;
                    foreach (XRLSingleEnumFileResult result in enumResp2.results)
                    {
                        Global.RO.Info("result.pathName.ToLower() == " + result.pathName.ToLower());
                        if (result.pathName.ToLower() == writeReq.accessToken.baseAT.pathName.ToLower())
                        {
                            found = true;
                        }
                    }
                    if (found == false)
                    {
                        throw new UnexpectedTestResultException("EnumFile(2) expected but did not find file " + 
                            writeReq.accessToken.baseAT.pathName);
                    }
                }

                base.ResultCode = TEST_RESULTS.PASSED;
                return enumResp2;
            }
        }

        [TestCase, Description("verify that enumerating a file path without wildcard and not using if-modified-since param a second time returns the results from the cache")]
        class PEnumCache_DashTitle_TitleDomain_NoWild_NoMod : PEnumCacheBasicTestBase
        {
            protected override void Execute()
            {
                FindFileInCache(DashTitleID, Domain.title, EnumWith.Default, true);
            }
        }

        [TestCase, Description("verify PEnumCache_DashTitle_TitleDomain_NoWild_NoMod can fail too")]
        class PEnumCache_DashTitle_NoWild_NoMod_InvTest : PEnumCacheBasicTestBase
        {
            protected override void Execute()
            {
                base.ResultCode = TEST_RESULTS.FAILED;
                try
                {
                    // Expected to fail!
                    FindFileInCache(DashTitleID, Domain.title, EnumWith.Default, false);
                }
                catch
                {
                    base.ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase(BugID=19093), Description("verify that enumerating a file path with wildcard and not using if-modified-since param a second time returns the results from the cache")]
        class PEnumCache_DashTitle_TitleDomain_Wild_NoMod : PEnumCacheBasicTestBase
        {
            protected override void Execute()
            {
                FindFileInCache(DashTitleID, Domain.title, EnumWith.Wildcard, false);
            }
        }

        [TestCase, Description("verify that enumerating a file path without wildcard and using if-modified-since param a second time returns the results from the cache")]
        class PEnumCache_DashTitle_TitleDomain_NoWild_Mod : PEnumCacheBasicTestBase
        {
            protected override void Execute()
            {
                FindFileInCache(DashTitleID, Domain.title, EnumWith.ModifiedSince, true);
            }
        }

        [TestCase, Description("verify that enumerating a file path with wildcard and using if-modified-since param a second time returns the results from the DB")]
        class PEnumCache_DashTitle_TitleDomain_Wild_Mod : PEnumCacheBasicTestBase
        {
            protected override void Execute()
            {
                FindFileInCache(DashTitleID, Domain.title, EnumWith.Wildcard | EnumWith.ModifiedSince, false);
            }
        }

        [TestCase, Description("verify that enumerating a file path from a non-dash title ID in the title domain does cache")]
        class PEnumCache_NonDashTitle_TitleDomain : PEnumCacheBasicTestBase
        {
            protected override void Execute()
            {
                FindFileInCache(NonDashTitleID, Domain.title, EnumWith.Default, true);
            }
        }

        [TestCase, Description("verify that enumerating a file path with the dash title ID from a domain other than title does cache")]
        class PEnumCache_DashTitle_GlobalDomain : PEnumCacheBasicTestBase
        {
            protected override void Execute()
            {
                FindFileInCache(DashTitleID, Domain.global, EnumWith.Default, true);
            }
        }

        [TestCase, Description("verify that enumerating a file path from a domain other than title does cache")]
        class PEnumCache_NonDashTitle_GlobalDomain : PEnumCacheBasicTestBase
        {
            protected override void Execute()
            {
                FindFileInCache(NonDashTitleID, Domain.global, EnumWith.Default, true);
            }
        }

        [TestCase, Description("enumerate one file test - Caching Test")]
        class PEnumFileCachingTest : GlobalTitleEnumFilesTestBase
        {
            override protected void Execute()
            {

                //uint TitleID = (uint)new Random().Next();
                //uint TitleID = (uint)Convert.ToUInt32("0xfffe07d1", 16);              
                //long modifiedSince = (long)System.DateTime.UtcNow.AddHours(-1).ToFileTimeUtc();
                //string enumXrl = "//title." + hexTitleID + "/t:" + hexTitleID + "/*";

                uint TitleID = 0xfffe07d1; //4294838225
                string hexTitleID = TitleID.ToString("x");

                long modifiedSince = 0;
                string fileName = "/mediasite.xzp";
                string writeXrl = "//title." + hexTitleID + "/t:" + hexTitleID + fileName;
                string enumXrl = "//title." + hexTitleID + "/t:" + hexTitleID + fileName;

                if (EnumFilesSendAndVerify2(TitleID, writeXrl, enumXrl, 1, 1, true, modifiedSince))
                    ResultCode = TEST_RESULTS.PASSED;
            }


            //	send WriteFile requests first; then send readfile;verifies the response
            protected bool EnumFilesSendAndVerify2(uint titleID, string writeXrl, string enumXrl, uint expectedFilesTotal, uint expectedFilesReturn, bool checkEachFile, long modifiedSince)
            {
                string hexTitleID = titleID.ToString("x");

                XRLWriteFile[] writeReqs = new XRLWriteFile[1];
                XRLEnumFiles enumReq = new XRLEnumFiles(enumXrl, titleID, 0, 1, modifiedSince);


                Global.RO.Info("WriteFiles: XRL= " + writeXrl);
                if (!WriteFilesSend(writeReqs, hexTitleID, writeXrl))
                    return false;

                TimeSpan callDuration;
                Global.RO.Info("EnumFiles: XRL= " + enumXrl);
                
                if (!EnumFilesSendAndMeasureTime(enumReq, writeReqs, expectedFilesTotal, expectedFilesReturn, checkEachFile, out callDuration))
                    return false;

                if (!EnumFilesSendAndMeasureTime(enumReq, writeReqs, expectedFilesTotal, expectedFilesReturn, checkEachFile, out callDuration))
                    return false;

                if (!EnumFilesSendAndMeasureTime(enumReq, writeReqs, expectedFilesTotal, expectedFilesReturn, checkEachFile, out callDuration))
                    return false;

                if (!EnumFilesSendAndMeasureTime(enumReq, writeReqs, expectedFilesTotal, expectedFilesReturn, checkEachFile, out callDuration))
                    return false;

                if (!EnumFilesSendAndMeasureTime(enumReq, writeReqs, expectedFilesTotal, expectedFilesReturn, checkEachFile, out callDuration))
                    return false;

                if (!EnumFilesSendAndMeasureTime(enumReq, writeReqs, expectedFilesTotal, expectedFilesReturn, checkEachFile, out callDuration))
                    return false;

                return true;

            }

            private static bool EnumFilesSendAndMeasureTime(XRLEnumFiles enumReq, XRLWriteFile[] writeReqs, uint expectedFilesTotal, uint expectedFilesReturn, bool checkEachFile, out TimeSpan firstCallDuration)
            {

                DateTime beforeFirstCall, afterFirstCall;
                firstCallDuration = new TimeSpan(0);


                beforeFirstCall = DateTime.Now;
                if (!EnumFilesSend(enumReq, writeReqs, expectedFilesTotal, expectedFilesReturn, checkEachFile))
                    return false;
                afterFirstCall = DateTime.Now;
                firstCallDuration = afterFirstCall - beforeFirstCall;

                Global.RO.Info("EnumFiles: Time taken for API calls = " + firstCallDuration);

                return true;

            }

            private static bool EnumFilesSend(XRLEnumFiles enumReq, XRLWriteFile[] writeReqs, uint expectedFilesTotal, uint expectedFilesReturn, bool checkEachFile)
            {
                XRLEnumFilesResponse enumResp;
                bool callResult = enumReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out enumResp);

                if (callResult)
                {
                    
                    //Log results:
                    XRLSingleEnumFileResult result;
                    //Global.RO.Info("EnumFile response: NumofFiles = " + enumResp.numFilesTotal.ToString());
                    for (int i = 0; i < enumResp.results.Length; i++)
                    {
                        result = enumResp.results[i];
                        //Global.RO.Info(String.Format("EnumFile response: File[{1}]: CreationDate={2}", DateTime.Now.ToString(), i, result.lCreationDate));
                        //Global.RO.Info(String.Format("EnumFile response: File[{1}]: ModificationDate={2}", DateTime.Now.ToString(), i, result.lModifiedDate));

                    }

                    uint respNumFilesTotal = enumResp.numFilesTotal;
                    uint respResultsLen = enumResp.resultsLen;

                    if (enumResp.numFilesTotal != expectedFilesTotal)
                    {
                        Global.RO.Warn(String.Format("numFilesTotal is not correct Expected={0} , Actual={1}", expectedFilesTotal, enumResp.numFilesTotal));
                        return false;
                    }
                    if (enumResp.resultsLen != expectedFilesReturn)
                    {
                        Global.RO.Warn(String.Format("numFiles returned is not correct - Expected={0} , Actual={1}", expectedFilesReturn, enumResp.resultsLen));
                        return false;
                    }
                    // check each returned file
                    if (checkEachFile)
                    {
                        for (int i = 0; i < expectedFilesReturn; i++)
                        {
                            if (!enumResp.results[i].Compare(writeReqs[i]))
                            {
                                Global.RO.Warn("The returned file is not correct");
                                return false;
                            }
                        }
                    }
                    return true;
                }
                else
                {
                    Global.RO.Warn("Failed send EnumFiles request");
                    return false;
                }
            }

            private static bool WriteFilesSend(XRLWriteFile[] writeReqs, string hexTitleID, string xrl)
            {

                // write files for this title
                uint numFiles = (uint)writeReqs.Length;
                for (int i = 0; i < numFiles; i++)
                {
                    writeReqs[i] = new XRLWriteFile("ServiceAddr", xrl);
                    if (i % 2 == 0)
                    {
                        writeReqs[i].attributes = new byte[50];
                        new Random().NextBytes(writeReqs[i].attributes);
                        writeReqs[i].attributesLen = 50;
                    }
                    if (!writeReqs[i].Execute())
                    {
                        Global.RO.Warn("WriteFile request failed" + writeReqs[i].XErr.ToString());
                        return false;
                    }
                }
                return true;
            }
        }


	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\FuncGameClipsDF.cs ===
using System;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Storage;
using ServerTestFramework.LiveService.Signature;
using xonline.common.config;

namespace XStoreTest
{
    internal abstract class RemoveFileTestBase : TestBase
    {
        protected bool RemoveFileSendAndVerify(XRLRemoveFile removeReq)
        {
            // WriteReq and removeReq has the same pathName, but
            // 1.the userPUID that write the file is not the userPUID that remove the file
            // 2.the userPUID in pathName is not the above
            uint    titleID = removeReq.uiTitleId;
            string    pathName = removeReq.accessToken.baseAT.pathName;
            // the one write the file is not the one that remove it
            ulong    userPUID = (ulong)((new Random().NextDouble()) * 0xffffffffffffffff);
            XRLWriteFile    WriteReq = new XRLWriteFile(titleID,1000,pathName,userPUID);
            if(WriteReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
            {
                if(removeReq.Execute())
                {
                    XRLReadFile        readReq = new XRLReadFile(pathName);
                    readReq.Slot.titleId = readReq.uiTitleId = titleID;
                    if(!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)) &&
                        (readReq.XErr == HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
                        return true;
                    else
                    {
                        Global.RO.Warn("File was not removed");
                        return false;
                    }
                }
                Global.RO.Warn("RemoveFile request failed with "+Global.XErrToString(removeReq.XErr));
                return false;
            }
            return false;
        }
    }
    internal abstract class NegativeRemoveTestBase : TestBase
    {
        protected bool RemoveFileTestNegative(XRLRemoveFile    removeReq, uint XErr)
        {
            if (removeReq.Execute())
            {
                Global.RO.Warn("Negative RemoveFile request succeed unexpectedly");
                return false;
            }
            if(removeReq.XErr != XErr)
            {
                Global.RO.Warn("Wrong error code " + Global.XErrToString(removeReq.XErr) +" returned");
                return false;
            }
            return true;
        }
    }
    [TestGroup, Owner("JKonkle"), TestFrequency("Regression"), TestCasePriority(1)]
    public class FuncGameClipsDF : TestNode
    {
        /**********************************************************************************
         * Positive Wire Protocol Testing
         *********************************************************************************/
		// Bug 38096
		[TestCase(38096), Description("")]
			class PThrottling : RemoveFileTestBase
        {
            override protected void Execute()
            {
                ulong    ownerPUID = (ulong)((new Random().NextDouble()) * 0xffffffffffffffff);
                uint    titleID = (uint) new Random().Next();
                string    pathName = "//stats/u:" + ownerPUID.ToString("x")+ "/"+titleID.ToString("x")+"/"
                    + Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");

				int Xdelay= 3000;
				Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage,"exec :stfd SetXDelay "+removeReq.uiTitleId.ToString("X")+" removefile "+Xdelay);

                if(RemoveFileSendAndVerify(removeReq) && (removeReq.XDelay == Xdelay))
                    ResultCode=TEST_RESULTS.PASSED;

				Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage,"exec :stfd ReloadThrottleConfig");
			}
        }
		[TestCase, Description("Write a file first then call removeFile with the same pathname but different userPUID")]
			class PNormalCase : RemoveFileTestBase
        {
            override protected void Execute()
            {
                ulong    ownerPUID = (ulong)((new Random().NextDouble()) * 0xffffffffffffffff);
                uint    titleID = (uint) new Random().Next();
                string    pathName = "//stats/u:" + ownerPUID.ToString("x")+ "/"+titleID.ToString("x")+"/"
                    + Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                if(RemoveFileSendAndVerify(removeReq))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
		[TestCase, Description("call removeFile with maximum titleID")]
			class PMaxTitleID : RemoveFileTestBase
        {
            override protected void Execute()
            {
                ulong    ownerPUID = (ulong)((new Random().NextDouble()) * 0xffffffffffffffff);
                string    pathName = "//stats/u:" + ownerPUID.ToString("x")+ "/ffffffff/" + Guid.NewGuid().ToString();
                uint    titleID = 0xffffffff;
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                if(RemoveFileSendAndVerify(removeReq))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
		[TestCase, Description("call removeFile with minimum titleID")]
			class PMinTitleID : RemoveFileTestBase
        {
            override protected void Execute()
            {
                ulong    ownerPUID = (ulong)((new Random().NextDouble()) * 0xffffffffffffffff);
                string    pathName = "//stats/u:" + ownerPUID.ToString("x")+ "/1/" + Guid.NewGuid().ToString();
                uint    titleID = 1;
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                if(RemoveFileSendAndVerify(removeReq))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
		[TestCase, Description("call removeFile with maximum titleVersion")]
			class PMaxTitleVersion : RemoveFileTestBase
        {
            override protected void Execute()
            {
                ulong    ownerPUID = (ulong)((new Random().NextDouble()) * 0xffffffffffffffff);
                uint    titleID = (uint) new Random().Next();
                string    pathName = "//stats/u:" + ownerPUID.ToString("x")+ "/"+titleID.ToString("x")+"/"
                    + Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                removeReq.uiTitleVersion = 0xffffffff;
                // need to set the titleVersion in hte HTTPAuthdata
                ulong    requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
                uint    ip = 0;
                byte [] addr = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).Address.GetAddressBytes();
                for(int i = 0; i < addr.Length; i++)
                    ip = (ip << 8) + addr[i];
                HTTPAuthData authData = new HTTPAuthData((ushort) Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int).Port,
                    ip,requestId,0,titleID,(uint)XOService.Storage,0);
                authData.dwTitleVersion = removeReq.uiTitleVersion;
                removeReq.CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" +
                    authData.GetBase64EncodedString() + "\r\n";
                if(RemoveFileSendAndVerify(removeReq))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
		[TestCase, Description("call removeFile with minimum titleVersion")]
			class PMinTitleVersion : RemoveFileTestBase
        {
            override protected void Execute()
            {
                ulong    ownerPUID = (ulong)((new Random().NextDouble()) * 0xffffffffffffffff);
                uint    titleID = (uint) new Random().Next();
                string    pathName = "//stats/u:" + ownerPUID.ToString("x")+ "/"+titleID.ToString("x")+"/"
                    + Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                removeReq.uiTitleVersion = 1;
                ulong    requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
                uint    ip = 0;
                byte [] addr = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).Address.GetAddressBytes();
                for(int i = 0; i < addr.Length; i++)
                    ip = (ip << 8) + addr[i];
                HTTPAuthData authData = new HTTPAuthData((ushort) Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int).Port,
                    ip,requestId,0,titleID,(uint)XOService.Storage,0);
                authData.dwTitleVersion = removeReq.uiTitleVersion;
                removeReq.CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" +
                    authData.GetBase64EncodedString() + "\r\n";
                if(RemoveFileSendAndVerify(removeReq))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
//        class PMaxPathNameSize : RemoveFileTestBase
//        {
//            public PMaxPathNameSize()
//            {
//                Name = "PMaxPathNameSize";
//                Desc = "call removeFile with 255 unicode chars";
//            }
//            override protected void Execute()
//            {
//                ulong    ownerPUID = (ulong)((new Random().NextDouble()) * 0xffffffffffffffff);
//                uint    titleID = (uint) new Random().Next();
//                string    pathName = "//stats/u:" + ownerPUID.ToString("x")+ "/"+titleID.ToString("x")+"/"
//                    + Guid.NewGuid().ToString();
//                StringBuilder    pathBuilder = new StringBuilder(pathName);
//                if(pathName.Length < 255)
//                    pathBuilder.Append('z',255-pathName.Length);
//
//                XRLRemoveFile    removeReq = new XRLRemoveFile(pathBuilder.ToString(),titleID,"ServiceAddr");
//                if(RemoveFileSendAndVerify(removeReq))
//                    ResultCode=TEST_RESULTS.PASSED;
//            }
//        }
        /**********************************************************************************
         * Positive Other Testing
         *********************************************************************************/
        [TestCase, Description("create a file with a pathname and one title ID, call RemoveFile with the same pathname but different title ID"), TestCasePriority(2)]
			class NRemoveFromOtherTitle : NegativeRemoveTestBase
        {
            override protected void Execute()
            {
                ulong    ownerPUID = (ulong)((new Random().NextDouble()) * 0xffffffffffffffff);
                uint    titleID = (uint) new Random().Next();
                string    pathName = "//stats/u:" + ownerPUID.ToString("x")+ "/"+titleID.ToString("x")+"/"
                    + Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                XRLWriteFile    WriteReq = new XRLWriteFile(titleID+1,1000,pathName,ownerPUID);
                if(WriteReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
                {
                    if(!removeReq.Execute()&& (removeReq.XErr == HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
                        ResultCode=TEST_RESULTS.PASSED;
                }
            }
        }
		[TestCase, Description("call RemoveFile with the same pathname and titleID as writeFile but different title Version")]
			class PRemoveFromOtherTitleVersion : TestBase
        {
            override protected void Execute()
            {
                ulong    ownerPUID = (ulong)((new Random().NextDouble()) * 0xffffffffffffffff);
                uint    titleID = (uint) new Random().Next();
                string    pathName = "//stats/u:" + ownerPUID.ToString("x")+ "/"+titleID.ToString("x")+"/"
                    + Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                XRLWriteFile    WriteReq = new XRLWriteFile(titleID,1000,pathName,ownerPUID);
                if(WriteReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
                {
                    if(removeReq.Execute())
                    {
                        XRLReadFile        readReq = new XRLReadFile(pathName);
                        if(!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)) &&
                            (readReq.XErr == HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
                            ResultCode=TEST_RESULTS.PASSED;
                    }
                }
            }
        }
        /*
		[TestCase, Description("remove only one ref for a file with multiple references")]
			class PRemoveFileWithMultiRef : TestBase
        {
            override protected void Execute()
            {
                // write a blob with 4 references
                uint        title = (uint)new Random(unchecked((int)System.DateTime.Now.Ticks)).Next();
                uint        FileWithMultiRefLen = 10240;
                byte[]        FileData = new byte[FileWithMultiRefLen];
                new Random().NextBytes(FileData);
                byte[]        FileWithMultiRefHash = new byte[Constants.sizeHash];
                new Random().NextBytes(FileWithMultiRefHash);
                int            keyValue = (int)(new Random().Next());
                string        MultiRefPath1 = "", RemovedRefPath = "";
                XRLWriteFile    wReq1 = new XRLWriteFile(), wReq2 = new XRLWriteFile();
                for(int i = 0; i < 4; i++)
                {
                    XRLWriteFile    writeReq = new XRLWriteFile();
                    writeReq.uiTitleId = title;
                    writeReq.Slot.titleId = title;
                    writeReq.accessToken.baseAT.pathName = "//stats/u:" + keyValue.ToString("x")+"/"
                        + title.ToString("x")+"/"+Guid.NewGuid().ToString();
                    writeReq.accessToken.baseAT.pathNameLen = (ushort)writeReq.accessToken.baseAT.pathName.Length;
                    writeReq.blobDataLen = FileWithMultiRefLen;
                    writeReq.uiBlobSizeCompressed = FileWithMultiRefLen;
                    writeReq.blobData = new byte[FileWithMultiRefLen];
                    FileData.CopyTo(writeReq.blobData,0);
                    FileWithMultiRefHash.CopyTo(writeReq.blobHash,0);
                    // need to sign the token again
                    byte[] signDataWithExtra = (byte[])writeReq.accessToken;
                    int sizeDataToSign = writeReq.accessToken.baseAT.Size() + 20;//20 is fileExp/tokenExp/maxFilesize
                    byte[] signData = new byte[sizeDataToSign];
                    Array.Copy(signDataWithExtra, 0, signData, 0, sizeDataToSign);
                    XSignature signature = new XSignature();
                    signature.serviceID = (uint)XOService.Stats;
                    signature.SignData(signData);
                    writeReq.accessToken.writeAT.signature = (byte [])signature;
                    if(!writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
                    {
                        Global.RO.Warn("Write File failed:"+i);
                        return;
                    }
                    if(i == 0)
                    {
                        wReq1 = writeReq;
                        MultiRefPath1 = writeReq.accessToken.baseAT.pathName;
                    }
                    else if (i == 1)
                        wReq2 = writeReq;
                    // the removed Ref path will be i = 3
                    RemovedRefPath = writeReq.accessToken.baseAT.pathName;
                }

                // only remove one reference to the file; the file still in the db and
                // check the i_ref_count=3
                XRLRemoveFile    removeReq = new XRLRemoveFile(RemovedRefPath,title,"ServiceAddr");
                if(removeReq.Execute())
                {
                    XRLReadFile        readReq = new XRLReadFile(MultiRefPath1);
                    readReq.Slot.titleId = readReq.uiTitleId = title;
                    XRLReadFileResponse    resp;
                    if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out resp))
                        // check ref count
                        if(wReq1.CheckRefCount(wReq2,3,false))
                            ResultCode=TEST_RESULTS.PASSED;
                }
            }
        }
		[TestCase, Description("remove all refs for a file with multiple references")]
		class PRemoveFileWithMultiRef2 : TestBase
        {
            override protected void Execute()
            {
                // write a blob with 2 references
                uint        title = (uint)new Random(unchecked((int)System.DateTime.Now.Ticks)).Next();
                uint        FileWithMultiRefLen = 10240;
                byte[]        FileData = new byte[FileWithMultiRefLen];
                new Random().NextBytes(FileData);
                byte[]        FileWithMultiRefHash = new byte[Constants.sizeHash];
                new Random().NextBytes(FileWithMultiRefHash);
                int            keyValue = (int)(new Random().Next());
                string        []refPath = new string[2]{"",""};
                XRLWriteFile    [] writeReq = new XRLWriteFile[2]{null, null};
                for(int i = 0; i < 2; i++)
                {
                    writeReq[i] = new XRLWriteFile();
                    writeReq[i].uiTitleId = title;
                    writeReq[i].Slot.titleId = title;
                    refPath[i] = writeReq[i].accessToken.baseAT.pathName = "//stats/u:" + keyValue.ToString("x")+"/"
                        + title.ToString("x")+"/"+Guid.NewGuid().ToString();
                    writeReq[i].accessToken.baseAT.pathNameLen = (ushort)writeReq[i].accessToken.baseAT.pathName.Length;
                    writeReq[i].blobDataLen = FileWithMultiRefLen;
                    writeReq[i].uiBlobSizeCompressed = FileWithMultiRefLen;
                    writeReq[i].blobData = new byte[FileWithMultiRefLen];
                    FileData.CopyTo(writeReq[i].blobData,0);
                    FileWithMultiRefHash.CopyTo(writeReq[i].blobHash,0);
                    // need to sign the token again
                    byte[] signDataWithExtra = (byte[])writeReq[i].accessToken;
                    int sizeDataToSign = writeReq[i].accessToken.baseAT.Size() + 20;//20 is fileExp/tokenExp/maxFilesize
                    byte[] signData = new byte[sizeDataToSign];
                    Array.Copy(signDataWithExtra, 0, signData, 0, sizeDataToSign);
                    XSignature signature = new XSignature();
                    signature.serviceID = (uint)XOService.Stats;
                    signature.SignData(signData);
                    writeReq[i].accessToken.writeAT.signature = (byte [])signature;
                    if(!writeReq[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
                    {
                        Global.RO.Warn("Write File failed:"+i);
                        return;
                    }
                }

                // remove all references to the file; the file will be deleted
                XRLRemoveFile    removeReq1 = new XRLRemoveFile(refPath[0],title,"ServiceAddr");
                XRLRemoveFile    removeReq2 = new XRLRemoveFile(refPath[1],title,"ServiceAddr");
                if(removeReq1.Execute() && (removeReq2.Execute()))
                {
                    XRLReadFile        readReq = new XRLReadFile(refPath[0]);
                    readReq.Slot.titleId = readReq.uiTitleId = title;
                    if(!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage))&&
                        (readReq.XErr==HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
                            ResultCode=TEST_RESULTS.PASSED;
                }
            }
        }*/
        /**********************************************************************************
         * Negative Wire Protocol Testing
         *********************************************************************************/
	// 33875 won't fix
	//[TestCase, Description("the userPUID in HTTPAuthData is different than the one in removeFile request"), TestCasePriority(2)]
		/*	class NSGAuthInvalidUserPUID : NegativeRemoveTestBase
        {
            override protected void Execute()
            {
                uint    titleID = (uint) new Random().Next();
                string    pathName = "//stats/u:12345/"+titleID.ToString("x")+"/" + Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                ulong    userPUID = removeReq.accessToken.baseAT.userPuid + 1;
                ulong    requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
                uint    ip = 0;
                byte [] addr = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).Address.GetAddressBytes();
                for(int i = 0; i < addr.Length; i++)
                    ip = (ip << 8) + addr[i];
                HTTPAuthData authData = new HTTPAuthData((ushort) Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int).Port,
                    ip,requestId,userPUID,titleID,(uint)XOService.Storage,0);
                authData.dwTitleVersion = removeReq.uiTitleVersion;
                removeReq.CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" +
                    authData.GetBase64EncodedString() + "\r\n";

                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }*/
		[TestCase, Description("the titleID in HTTPAuthData is not the one in the removeFile request"), TestCasePriority(2)]
			class NSGAuthInvalidTitleID : NegativeRemoveTestBase
        {
            override protected void Execute()
            {
                uint    titleID = (uint) new Random().Next();
                string    pathName = "//stats/u:12345/"+titleID.ToString("x")+"/" + Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                ulong    requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
                uint    ip = 0;
                byte [] addr = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).Address.GetAddressBytes();
                for(int i = 0; i < addr.Length; i++)
                    ip = (ip << 8) + addr[i];
                HTTPAuthData authData = new HTTPAuthData((ushort) Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int).Port,
                    ip,requestId,0,0x1235,(uint)XOService.Storage,0);
                authData.dwTitleVersion = removeReq.uiTitleVersion;
                removeReq.CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" +
                    authData.GetBase64EncodedString() + "\r\n";
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_INVALID_TITLE_ID))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("the titleVersion in HTTPAUthData is not the one in the removeFile request"), TestCasePriority(2)]
			class NSGAuthInvalidTitleVersion : NegativeRemoveTestBase
        {
            override protected void Execute()
            {
                uint    titleID = (uint) new Random().Next();
                string    pathName = "//stats/u:12345/"+titleID.ToString("x")+"/" + Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                ulong    requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
                uint    ip = 0;
                byte [] addr = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).Address.GetAddressBytes();
                for(int i = 0; i < addr.Length; i++)
                    ip = (ip << 8) + addr[i];
                HTTPAuthData authData = new HTTPAuthData((ushort) Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int).Port,
                    ip,requestId,0,titleID,(uint)XOService.Storage,0);
                authData.dwTitleVersion = removeReq.uiTitleVersion + 1;
                removeReq.CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" +
                    authData.GetBase64EncodedString() + "\r\n";
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("the serviceID in HTTPAuthData is not storage"), TestCasePriority(2)]
			class NSGAuthInvalidServiceID : NegativeRemoveTestBase
        {
            override protected void Execute()
            {
                uint    titleID = (uint) new Random().Next();
                string    pathName = "//stats/u:12345/"+titleID.ToString("x")+"/" + Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                ulong    requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
                uint    ip = 0;
                byte [] addr = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).Address.GetAddressBytes();
                for(int i = 0; i < addr.Length; i++)
                    ip = (ip << 8) + addr[i];
                HTTPAuthData authData = new HTTPAuthData((ushort) Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int).Port,
                    ip,requestId,0,0x1235,(uint)XOService.Stats,0);
                authData.dwTitleVersion = removeReq.uiTitleVersion;
                removeReq.CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" +
                    authData.GetBase64EncodedString() + "\r\n";

                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_SERVER_ERROR))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Call RemoveFile with invalid pathName"), TestCasePriority(2)]
			class NFileNotFound : NegativeRemoveTestBase
        {
            override protected void Execute()
            {
                uint    titleID = (uint) new Random().Next();
                string    pathName = "//stats/u:12345/"+titleID.ToString("x")+"/" + Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass non-removeFile operation"), TestCasePriority(2)]
			class NInvalidOperation : NegativeRemoveTestBase
        {
            override protected void Execute()
            {
                uint    titleID = (uint) new Random().Next();
                string    pathName = "//stats/u:12345/"+titleID.ToString("x")+"/" + Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                removeReq.accessToken.baseAT.operation = (ushort)Constants.Operation.FileEnumerate;
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        //	[TestCase, Description("pass invalid serviceID(not stats)"), TestCasePriority(2)]
			class NInvalidServiceID : NegativeRemoveTestBase
        {
            override protected void Execute()
            {
                uint    titleID = (uint) new Random().Next();
                string    pathName = "//stats/u:12345/"+titleID.ToString("x")+"/" + Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                removeReq.accessToken.baseAT.serviceId = (uint)XOService.Matchmaking;
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
            [TestCase, Description("pathNameLen is greater than the actual pathname"), TestCasePriority(2)]
		class NTruncatePathname : NegativeRemoveTestBase
        {
            override protected void Execute()
            {
                uint    titleID = (uint) new Random().Next();
                string    pathName = "//stats/u:12345/"+titleID.ToString("x")+"/" + Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                removeReq.accessToken.baseAT.ManualArraySize = true;
                removeReq.accessToken.baseAT.pathNameLen +=1;
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
            [TestCase, Description("pathNameLen is shorter than the actual pathname"), TestCasePriority(2)]
		class NOverflowPathname : NegativeRemoveTestBase
        {
            override protected void Execute()
            {
                uint    titleID = (uint) new Random().Next();
                string    pathName = "//stats/u:12345/"+titleID.ToString("x")+"/" + Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                removeReq.accessToken.baseAT.ManualArraySize = true;
                removeReq.accessToken.baseAT.pathNameLen -=1;    //??????what's the right error code?
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
            [TestCase, Description("pass NULL for pathName"), TestCasePriority(2)]
		class NNullPathname : NegativeRemoveTestBase
        {
            override protected void Execute()
            {
                uint    titleID = (uint) new Random().Next();
                XRLRemoveFile    removeReq = new XRLRemoveFile("abcd",titleID,"ServiceAddr");
                removeReq.accessToken.baseAT.pathName = null;
                removeReq.accessToken.baseAT.pathNameLen = 0;

                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
            [TestCase, Description("token expiration time is before current time"), TestCasePriority(2)]
		class NInvalidTokenExpTime : NegativeRemoveTestBase
        {
            override protected void Execute()
            {
                uint    titleID = (uint) new Random().Next();
                string    pathName = "//stats/u:12345/"+titleID.ToString("x")+"/" + Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                //??????what's the right error code
                removeReq.accessToken.removeAT.tokenExpirationDate = (long)System.DateTime.UtcNow.AddHours(-1).ToFileTimeUtc();
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
            //[TestCase, Description("pass removeFile request to stfd port 10140 other than 11140"), TestCasePriority(2)]
		class NNonDCReq : NegativeRemoveTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//stats/u:12345/" + Guid.NewGuid().ToString();
                uint    titleID = (uint) new Random().Next();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                removeReq.Server.Port = 10140;

                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\FuncGameClipsRF.cs ===
using System;
using System.Text;
using System.IO;
using System.Net;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Storage;
using xonline.common.config;

namespace XStoreTest
{
	internal abstract class NegativeRFTestBase : TestBase
	{
		//	send readFile requests, then check the error code
		protected bool ReadFileTestNegative(XRLReadFile ReadFileReq, uint XErr)
		{
			XRLReadFileResponse	ReadFileResp;
			if (ReadFileReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out ReadFileResp))
			{
				Global.RO.Warn("Negative ReadFile request succeed unexpectedly");
				return false;
			}
			if((ReadFileReq.XErr != XErr) || (ReadFileResp != null))
			{
				Global.RO.Warn("Wrong error code " + Global.XErrToString(ReadFileReq.XErr) +" returned or ReadFileResp is not null");
				return false;
			}
			return true;
		}
	}
	/// <summary>
	/// Summary description for FuncGameClipsRF.
	/// </summary>
    [TestGroup, Owner("JKonkle"), TestFrequency("Regression"), TestCasePriority(1)]
	public class FuncGameClipsRF : TestNode
	{
		/**********************************************************************
		 * Wire Protocol Testing Cases
		 **********************************************************************/
		[TestCase, Description("Check X-Delay header in the http response")]
			class PThrottling : TestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	writeReq = new XRLWriteFile();

				if(writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;

					int Xdelay= 3000;
					Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage,"exec :stfd SetXDelay "+readReq.uiTitleId.ToString("X")+" readfile "+Xdelay);

					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp) && (readReq.XDelay == Xdelay))
						ResultCode=TEST_RESULTS.PASSED;

					Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage, "exec :stfd ReloadThrottleConfig");
				}
			}
		}
		[TestCase, Description("the titleID in the request is not the acutal logged on title")]
			class PFamilyTitleID : TestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	writeReq = new XRLWriteFile();
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.altTitleId1 = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleId = readReq.uiTitleId + 1;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("read a file for TitleA to the cache; try to read the file from a different title")]
		class PReadCacheFromDiffTitle : TestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	writeReq = new XRLWriteFile();
				if(writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
				{
					XRLReadFileResponse	readResp, readResp2;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;
                    if (readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out readResp))
                    {
                        // the file now is in the cache; try to read the file from titleB
                        XRLReadFile readReq2 = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
                        readReq2.Slot.titleId = readReq2.uiTitleId = writeReq.uiTitleId + 1;
                        readReq2.Slot.titleVersion = readReq2.uiTitleVersion;
                        if ((!readReq2.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out readResp2)))
                            //&& (readReq2.XErr == HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
                        {
                            ResultCode = TEST_RESULTS.PASSED;
                        }
                        else
                        {
                            Global.RO.Error("Was able to read.  Result code: {0}", readReq2.XErr);
                        }
                    }
                    else
                    {
                        Global.RO.Error("Failed to read back file by same titleID.");
                    }
				}
			}
		}
		[TestCase, Description("read file from cache for the same title")]
			class PReadCacheFromSameTitle : TestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	writeReq = new XRLWriteFile();
				if(writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
				{
					XRLReadFileResponse	readResp, readResp2;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;
					if(readReq.Execute(Global.XEnv.GetInterface(Interface.stfd_storage)[0],out readResp))
					{
						// the file now is in the cache;
						// remove the actual file, then read it from the cache
						XRLRemoveFile	removeReq = new XRLRemoveFile(writeReq.accessToken.baseAT.pathName,writeReq.uiTitleId,"ServiceAddr");
						if(removeReq.Execute())
						{
							XRLReadFile		readReq2 = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
							readReq2.Slot.titleId = readReq2.uiTitleId = writeReq.uiTitleId;
							readReq2.Slot.titleVersion = readReq2.uiTitleVersion;
							if(readReq2.Execute(Global.XEnv.GetInterface(Interface.stfd_storage)[0], out readResp2))
								ResultCode=TEST_RESULTS.PASSED;
						}
					}
				}
			}
		}
		[TestCase, Description("33960:Write a file first; then read the file with ifModifiedSince>actualModifiedTime")]
			class PModifiedSince : TestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	writeReq = new XRLWriteFile();
				if(writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;
					readReq.lIfModifiedSinceDate = (long)System.DateTime.UtcNow.AddHours(2).ToFileTimeUtc();
					if(!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp)&&
						(readReq.XErr == HResult.XONLINE_S_STORAGE_FILE_NOT_MODIFIED) && (readResp == null))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("Write a file first; the request this file with userCountryID set to max")]
			class PMaxUserCountryID : TestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	writeReq = new XRLWriteFile();
				if(writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.bUserCountryId = 0xff;
					readReq.Slot.userFlag0 = 0xff<<8;
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("Write a file first; the request this file with userCountryID set to min")]
			class PMinUserCountryID : TestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	writeReq = new XRLWriteFile();
				if(writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.bUserCountryId = 0;
					readReq.Slot.userFlag0 = 0<<8;
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("Write a file first; the request this file with userPUID set to max")]
			class PMaxUserPUID : TestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	writeReq = new XRLWriteFile();
				if(writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;
					readReq.Slot.userPuid0 = readReq.accessToken.baseAT.userPuid = 0xffffffffffffffff;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("Write a file first; the request this file with userPUID set to min")]
			class PMinUserPUID : TestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	writeReq = new XRLWriteFile();
				if(writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;
					readReq.Slot.userPuid0 = readReq.accessToken.baseAT.userPuid = 1;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("Write a file first; the request this file with machine PUID set to max")]
			class PMaxXBoxPUID : TestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	writeReq = new XRLWriteFile();
				if(writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;
					readReq.Slot.machinePuid = readReq.accessToken.baseAT.xboxPuid = 0xffffffffffffffff;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("Write a file first; the request this file with machine PUID set to min")]
			class PMinXBoxPUID : TestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	writeReq = new XRLWriteFile();
				if(writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;
					readReq.Slot.machinePuid =  readReq.accessToken.baseAT.xboxPuid = 1;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("write a valid file first, then request with mismatched TitleID"), TestCasePriority(2)]
			class NMismatchedTitleID : NegativeRFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	writeReq = new XRLWriteFile();
				if(writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId + 1;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_ERROR))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("write a valid file first, then request with mismatched TitleVersion")]
			class PMismatchedTitleVersion : TestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	writeReq = new XRLWriteFile();
				if(writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion= writeReq.uiTitleVersion + 1;
					XRLReadFileResponse		Response;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out Response))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("pass null for AccessToken"), TestCasePriority(2)]
			class NAccessTokenNullAT : NegativeRFTestBase
		{
			override protected void Execute()
			{
				XRLReadFile		readReq = new XRLReadFile();
				readReq.accessToken = null;

				if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode = TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass 0 for userPUID for AccessToken"), TestCasePriority(2)]
			class NAccessTokenZeroUserPUID : NegativeRFTestBase
		{
			override protected void Execute()
			{
				XRLReadFile		readReq = new XRLReadFile();
				readReq.Slot.userPuid0 = readReq.accessToken.baseAT.userPuid = 0;

				if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode = TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass non-readfile operation in the AT"), TestCasePriority(2)]
			class NAccessTokenMismatchedOp : NegativeRFTestBase
		{
			override protected void Execute()
			{
				XRLReadFile		readReq = new XRLReadFile();
				readReq.accessToken.baseAT.operation = (ushort)Constants.Operation.FileWrite;

				if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode = TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("write a file first, then request it with pathnameLen is greater than the actual pathname"), TestCasePriority(2)]
			class NAccessTokenTruncatePathname : NegativeRFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	writeReq = new XRLWriteFile();
				if(writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;
					readReq.accessToken.baseAT.ManualArraySize = true;
					readReq.accessToken.baseAT.pathNameLen += 1;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a file first, then request it with pathnameLen is less than the actual pathname"), TestCasePriority(2)]
			class NAccessTokenOverflowPathname : NegativeRFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	writeReq = new XRLWriteFile();
				if(writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;
					readReq.accessToken.baseAT.ManualArraySize = true;
					readReq.accessToken.baseAT.pathNameLen -= 1;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("pass null for pathname and pathnameLen is 0"), TestCasePriority(2)]
			class NAccessTokenNullPathname : NegativeRFTestBase
		{
			override protected void Execute()
			{
				XRLReadFile		readReq = new XRLReadFile();
				readReq.accessToken.baseAT.pathName = null;
				readReq.accessToken.baseAT.pathNameLen = 0;

				if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode = TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("AccessToken size is greater than 255+baseAT"), TestCasePriority(2)]
			class NAccessTokenOverflowAT : NegativeRFTestBase
		{
			override protected void Execute()
			{
				XRLReadFile		req = new XRLReadFile();
				StringBuilder	pathName = new StringBuilder(req.accessToken.baseAT.pathName);
				int		numUniCharToAdd = 256 - req.accessToken.baseAT.pathNameLen;
				string			temp = new string('a',numUniCharToAdd);
				pathName.Append(temp);
				req.accessToken.baseAT.pathNameLen = 256;//actual pathName length is 256
				req.accessToken.baseAT.pathName = pathName.ToString();

				if(ReadFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode = TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("write file first, then request it with wrong service ID instead of storage")]
			class PAccessTokenWrongServiceID : NegativeRFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	writeReq = new XRLWriteFile();
				if(writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.accessToken.baseAT.serviceId = (uint)XOService.Storage;
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;
					XRLReadFileResponse		resp;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out resp))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write file first, then request it with non-zero signature size"), TestCasePriority(2)]
			class NAccessTokenNonZeroSigSize : NegativeRFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	writeReq = new XRLWriteFile();
				if(writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.accessToken.readAT.signatureLen = Constants.sizeSignature;
					readReq.accessToken.readAT.signature = new byte[Constants.sizeSignature];
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write file first, then request it with non-null signature but sigSize is zero"), TestCasePriority(2)]
			class NAccessTokenNonNullSignature : NegativeRFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	writeReq = new XRLWriteFile();
				if(writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.accessToken.readAT.ManualArraySize = true;
					readReq.accessToken.readAT.signatureLen = 0;
					readReq.accessToken.readAT.signature = new byte[Constants.sizeSignature];
					for(int i = 0; i < Constants.sizeSignature; i++)
						readReq.accessToken.readAT.signature[i] = 0;
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write file first, then request it with token exp is before current time"), TestCasePriority(2)]
			class NAccessTokenWrongATExpTime : NegativeRFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	writeReq = new XRLWriteFile();
				if(writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.accessToken.readAT.tokenExpirationDate = System.DateTime.UtcNow.AddDays(-1).ToFileTimeUtc();
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write file first, then request it with non-zero flags"), TestCasePriority(2)]
			class NAccessTokenWrongFlags : NegativeRFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	writeReq = new XRLWriteFile();
				if(writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.accessToken.baseAT.flags = 1;
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
		/**********************************************************************
		 * Pathname Testing Cases
		 **********************************************************************/
        [TestCase, Description("write a valid file first, then request it with one null char in the middle of <Domain-part>"), TestCasePriority(2)]
			class NPathnameBadString1 : NegativeRFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	writeReq = new XRLWriteFile();
				if(writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					// //stat.s/u:....
					newPath = pathName.Insert(6,'\0'.ToString());

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;

					//TODO: need to return xonline_e_storage_domain_not_supported
					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it with two null char in the middle of <domain-part>"), TestCasePriority(2)]
			class NPathnameBadString2 : NegativeRFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	writeReq = new XRLWriteFile();
				if(writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath, temp;
					temp = '\0'.ToString() + '\0'.ToString();
					newPath = pathName.Insert(6,temp);	// //stat..s/u:....

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;

					//TODO: need to return xonline_e_storage_domain_not_supported
					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it with one nullchar in the middle of <userPUID>"), TestCasePriority(2)]
			class NPathnameBadString3 : NegativeRFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	writeReq = new XRLWriteFile();
				if(writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					// //stats/u:123.456/xxxxx
					newPath = pathName.Insert(12,'\0'.ToString());

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it with one nullchar in the middle of <pathpart>"), TestCasePriority(2)]
			class NPathnameBadString4 : NegativeRFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	writeReq = new XRLWriteFile();
				if(writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					// //stats/u:123456/<pathpart>
					newPath = pathName.Insert(30,'\0'.ToString());

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it with one nullchar at the end of <pathpart>"), TestCasePriority(2)]
			class NPathnameBadString5 : NegativeRFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	writeReq = new XRLWriteFile();
				if(writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					// //stats/u:123456/<pathpart>
					newPath = pathName + '\0'.ToString();

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it by passing a nonexisitent <path-part>(vc_name)"), TestCasePriority(2)]
			class NPathnameNonExistFile1 : NegativeRFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	writeReq = new XRLWriteFile();
				if(writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
				{
					// "//stats/u:<ulonglong>/<guid>"
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					int		guidStartPos = pathName.LastIndexOf('/');
					newPath = pathName.Substring(0,guidStartPos)+ "/" + Guid.NewGuid().ToString();

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it by passing wrong owner PUID"), TestCasePriority(2)]
			class NPathnameNonExistFile2 : NegativeRFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	writeReq = new XRLWriteFile();
				if(writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
				{
					// "//stats/u:<ulonglong>/titleid/<guid>"
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					int		pos = pathName.IndexOf("u:"), guidStart = pathName.LastIndexOf('/');
					newPath = pathName.Substring(0,pos)+ "u:393939/" + writeReq.uiTitleId.ToString("x")+ pathName.Substring(guidStart);

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it by passing wrong IDNameSpace"), TestCasePriority(2)]
			class NPathnameNonExistFile3 : NegativeRFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	writeReq = new XRLWriteFile();
				if(writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
				{
					// "//stats/u:<ulonglong>/<guid>"
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					newPath = pathName.Replace("u:","x:");

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it by passing wrong Domain"), TestCasePriority(2)]
			class NPathnameNonExistFile4 : NegativeRFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	writeReq = new XRLWriteFile();
				if(writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
				{
					// "//stats/u:<ulonglong>/<guid>"
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					newPath = pathName.Replace("stats","voice");

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;

					//TODO: proper error code needed
					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_PATH))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("<Domain-part> is greater than max allowed(63 unicode chars)"), TestCasePriority(2)]
			class NPathnameOverflowDomainLen : NegativeRFTestBase
		{
			override protected void Execute()
			{
				string path = "//stats.1111111111111111111111111111111111111111111111111111111111/u:"
					+ "123123/" + Guid.NewGuid().ToString();

				XRLReadFile		readReq = new XRLReadFile(path);
				if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode = TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("Write file first, then request it by passing a pathname that has no domain part"), TestCasePriority(2)]
			class NPathnameNoDomainPart : NegativeRFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	writeReq = new XRLWriteFile();
				if(writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
				{
					string path = writeReq.accessToken.baseAT.pathName, newPath, temp;
					temp = path.Substring(path.IndexOf("u:"));
					newPath = "///" + temp;

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;

					//TODO: need new error code
					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("Write file first, then request it by passing noID namespace"), TestCasePriority(2)]
			class NPathnameNoIDNameSpace : NegativeRFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	writeReq = new XRLWriteFile();
				if(writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
				{
					string path = writeReq.accessToken.baseAT.pathName, newPath;
					newPath = path.Remove(path.IndexOf("u:"),1);

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("Write file first, then request it by passing no userPUID"), TestCasePriority(2)]
			class NPathnameNoUserPUID : NegativeRFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	writeReq = new XRLWriteFile();
				if(writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
				{
					string pathName = writeReq.accessToken.baseAT.pathName, newPath;
					int		pos = pathName.IndexOf("u:"), guidStart = pathName.LastIndexOf('/');
					newPath = pathName.Substring(0,pos)+ "u:" + pathName.Substring(guidStart);

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("Write file first, then request it by passing overflow PUID"), TestCasePriority(2)]
			class NPathnameOverflowUserPUID : NegativeRFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	writeReq = new XRLWriteFile();
				if(writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
				{
					string pathName = writeReq.accessToken.baseAT.pathName, newPath;
					int		pos = pathName.IndexOf("u:"), guidStart = pathName.LastIndexOf('/');
					newPath = pathName.Substring(0,pos)+ "u:" + "ffffffffffffffff1" + pathName.Substring(guidStart);

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("Write file first, then request it by passing 0 PUID"), TestCasePriority(2)]
			class NPathnameZeroUserPUID : NegativeRFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	writeReq = new XRLWriteFile();
				if(writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
				{
					string pathName = writeReq.accessToken.baseAT.pathName, newPath;
					int		pos = pathName.IndexOf("u:"), guidStart = pathName.LastIndexOf('/');
					newPath = pathName.Substring(0,pos)+ "u:0" + pathName.Substring(guidStart);

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;
					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("Write file first, then request it by pass wrong charset"), TestCasePriority(2)]
			class NPathnameWrongCharSet : NegativeRFTestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	writeReq = new XRLWriteFile();
				if(writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
				{
					string path = writeReq.accessToken.baseAT.pathName;
					StringBuilder	pathName = new StringBuilder(path);
					//Bug 27831: domain and optional domain specified: A-Za-z0-9_
					// pathname allows anything except control chars('\0\, control characters, etc)
					char i = '\0';
					pathName.Append(i);

					XRLReadFile		readReq = new XRLReadFile(pathName.ToString());
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;
					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("Read file from a different titleVersion other than creator's")]
			class PFromDifferentTitleVersion : TestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	writeReq = new XRLWriteFile();
				if(writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion + 1;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		/***********************************************************************
		* SG Auth Data Testing
		* *********************************************************************/
        [TestCase, Description("the userPUID in SGAuth response is not_found user"), TestCasePriority(2)]
			class NSGAuthNotFoundUser : NegativeRFTestBase
		{
			override protected void Execute()
			{
				string url = "//stats.1234/u:9090/1234/"+Guid.NewGuid().ToString();
				XRLReadFile	req = new XRLReadFile(url);
				req.Slot.UserExists = 0;

				if(ReadFileTestNegative(req,HResult.XONLINE_E_SERVER_ERROR))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the userPUID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidUser : NegativeRFTestBase
		{
			override protected void Execute()
			{
				string url = "//stats.1234/u:9090/1234/"+Guid.NewGuid().ToString();
				XRLReadFile	req = new XRLReadFile(url);
				req.Slot.userPuid0++;

				if(ReadFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the TitleID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidTitleID : NegativeRFTestBase
		{
			override protected void Execute()
			{
				string url = "//stats.1234/u:9090/1234/"+Guid.NewGuid().ToString();
				XRLReadFile	req = new XRLReadFile(url);
				req.Slot.titleId++;

				if(ReadFileTestNegative(req,HResult.XONLINE_E_INVALID_TITLE_ID))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the XBoxPUID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidXBoxPUID : NegativeRFTestBase
		{
			override protected void Execute()
			{
				string url = "//stats.1234/u:9090/1234/"+Guid.NewGuid().ToString();
				XRLReadFile	req = new XRLReadFile(url);
				req.Slot.machinePuid++;

				if(ReadFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the TitleVersion in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidTitleVersion : NegativeRFTestBase
		{
			override protected void Execute()
			{
				string url = "//stats.1234/u:9090/1234/"+Guid.NewGuid().ToString();
				XRLReadFile	req = new XRLReadFile(url);
				req.Slot.titleVersion++;

				if(ReadFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the CountryID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidCountryID : NegativeRFTestBase
		{
			override protected void Execute()
			{
				string url = "//stats.1234/u:9090/1234/"+Guid.NewGuid().ToString();
				XRLReadFile	req = new XRLReadFile(url);
				req.Slot.userFlag0 = (uint)((req.bUserCountryId+1)<<8);

				if(ReadFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		/**********************************************************************
		 * Other ReadFile Testing Cases
		 **********************************************************************/
		[TestCase, Description("Multiple threads read same file simultaneously")]
			class PMultiThreadsReadFile : TestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	writeReq = new XRLWriteFile();
				pathName = writeReq.accessToken.baseAT.pathName;
				uiTitleId = writeReq.uiTitleId;
				uiTitleVersion = writeReq.uiTitleVersion;

				if(writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
				{
					Thread [] threadArray = new Thread[10];
					for(int i = 0; i < 10; i++)
					{
						threadArray[i] = ThreadMaker.CreateThread(readFileTS);
						threadArray[i].Start();
					}
					// the main thread is waiting for all threads to exit or timeout
					foreach (Thread t in threadArray)
						t.Join(1000);
					if(FailedReqs == 0)
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
			private void readFileTS()
			{
				XRLReadFileResponse	readResp;
				XRLReadFile		readReq = new XRLReadFile(pathName);
				readReq.Slot.titleId = readReq.uiTitleId = uiTitleId;
				readReq.Slot.titleVersion = readReq.uiTitleVersion = uiTitleVersion;

				if(!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out readResp))
				{
					Global.RO.Warn("readFileTS: read file request failed");
					Interlocked.Increment(ref FailedReqs);
				}
			}
			private string	pathName;
			private uint	uiTitleId, uiTitleVersion;
			private int		FailedReqs;
		}
		[TestCase, Description("read file 100 times and check bi_read_count in t_files")]
			// bi_read_count in t_files: number of times the file has been read
			class PReadFileMultiTimes : TestBase
		{
			override protected void Execute()
			{
				XRLWriteFile	writeReq = new XRLWriteFile();
				if(writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
				{
					uint				uiFailedReq = 0;
					for(int i = 0; i < 100; i++)
					{
						XRLReadFileResponse	readResp;
						XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
						readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
						readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;
						if(!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
							uiFailedReq++;
					}
					if(uiFailedReq == 0)
						ResultCode=TEST_RESULTS.PASSED;
					// check bi_read_count in t_files
					// Bug26804:since we cache file in the front door, it will be 1 instead of 100
					//					long expectedCount = 1;
					//					XRLWriteFile	dumbReq = new XRLWriteFile();
					//					if(writeReq.CheckReadCount(dumbReq,expectedCount))
					//						if(uiFailedReq == 0)
					//							ResultCode=TEST_RESULTS.PASSED;
					//						else
					//							Global.RO.Warn("bi_read_count is set right, but not all 100 read requests succeeded");
				}
			}
		}
		/**********************************************************************
		 * Hacked ReadFile Testing Cases
		 **********************************************************************/
        [TestCase, Description("send garbage data, followed by valid requests"), TestCasePriority(2)]
			class NHackedRequest1 : NegativeRFTestBase
		{
			override protected void Execute()
			{
				MemoryStream	reqStream = new MemoryStream();
				BinaryWriter	bw = new BinaryWriter(reqStream);
				string			garbage = "fjiadpofjdipfjaipfiejfi0p9jafja;dfadfpaeifj;daj";
				bw.Write(garbage);
				bw.Write((ushort)Constants.Operation.FileRead);
				bw.Write(Constants.accessTokenVersion);
				bw.Write((uint)XOService.Storage);
				bw.Write((uint)0);
				bw.Write((ulong)999);
				bw.Write((ulong)999);
				string pathName = "//stats/u:999/999/" + Guid.NewGuid().ToString();
				bw.Write(pathName.Length);
				bw.Write(pathName);
				bw.Write((long)789789000);
				bw.Write((ushort)0);
				//			byte [] accessTokenSig = null;
				//			bw.Write(accessTokenSig);
				bw.Write((uint)999);
				bw.Write((uint)999);
				bw.Write((byte)11);
				bw.Write((uint)0);
				bw.Write((uint)0);
				bw.Write((ulong)0);

				StringBuilder sbURL = new StringBuilder();
				sbURL.Append("http://");
				sbURL.Append(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage));
				sbURL.Append("/stfd/readfile.ashx");

				HttpWebRequest	httpReq;
				HttpWebResponse	httpResp = null;
				Stream			httpStream;
				httpReq = (HttpWebRequest)WebRequest.Create(sbURL.ToString());
				httpReq.ProtocolVersion = HttpVersion.Version11;
				httpReq.Method = "POST";
				httpReq.UserAgent = ((int)XOService.Storage).ToString("x") + "/1.0";
				httpReq.ContentType = "xon/" + ((int)XOService.Storage).ToString("x");
				httpReq.ContentLength = reqStream.Length;
				try
				{
					httpStream = httpReq.GetRequestStream();
					reqStream.WriteTo(httpStream);
					httpStream.Close();
					httpResp = (HttpWebResponse)httpReq.GetResponse();
				}
				catch (WebException e)
				{
					httpResp = (HttpWebResponse)e.Response;
					if(httpResp != null)
					{
						if(httpResp.StatusCode == HttpStatusCode.InternalServerError)
						{	// check XErr
							string	strErr = httpResp.GetResponseHeader("X-Err");
                            if (strErr.StartsWith("0x") || strErr.StartsWith("0X")) strErr = strErr.Substring(2);

                            if (Convert.ToUInt32(strErr, 16) == HResult.XONLINE_E_STORAGE_INVALID_REQUEST)
								ResultCode=TEST_RESULTS.PASSED;
							else
							{
								Global.RO.Warn("Wrong error code " + strErr +" returned");
							}
						}
					}
				}
			}
		}
        [TestCase, Description("send valid request followed by garbage data"), TestCasePriority(2)]
			class NHackedRequest2 : NegativeRFTestBase
		{
			override protected void Execute()
			{
				MemoryStream	reqStream = new MemoryStream();
				BinaryWriter	bw = new BinaryWriter(reqStream);
				string			garbage = "fjiadpofjdipfjaipfiejfi0p9jafja;dfadfpaeifj;daj";
				bw.Write((ushort)Constants.Operation.FileRead);
				bw.Write(Constants.accessTokenVersion);
				bw.Write((uint)XOService.Storage);
				bw.Write((uint)0);
				bw.Write((ulong)999);
				bw.Write((ulong)999);
				string pathName = "//stats/u:999/999/" + Guid.NewGuid().ToString();
				bw.Write(pathName.Length);
				bw.Write(pathName);
				bw.Write((long)789789000);
				bw.Write((ushort)0);
				bw.Write((uint)999);
				bw.Write((uint)999);
				bw.Write((byte)11);
				bw.Write((uint)0);
				bw.Write((uint)0);
				bw.Write((ulong)0);
				bw.Write(garbage);

				StringBuilder sbURL = new StringBuilder();
				sbURL.Append("http://");
				sbURL.Append(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage));
				sbURL.Append("/stfd/readfile.ashx");

				HttpWebRequest	httpReq;
				HttpWebResponse	httpResp = null;
				Stream			httpStream;
				httpReq = (HttpWebRequest)WebRequest.Create(sbURL.ToString());
				httpReq.ProtocolVersion = HttpVersion.Version11;
				httpReq.Method = "POST";
				httpReq.UserAgent = ((int)XOService.Storage).ToString("x") + "/1.0";
				httpReq.ContentType = "xon/" + ((int)XOService.Storage).ToString("x");
				httpReq.ContentLength = reqStream.Length;
				try
				{
					httpStream = httpReq.GetRequestStream();
					reqStream.WriteTo(httpStream);
					httpStream.Close();
					httpResp = (HttpWebResponse)httpReq.GetResponse();
				}
				catch (WebException e)
				{
					httpResp = (HttpWebResponse)e.Response;
					if(httpResp != null)
					{
						if(httpResp.StatusCode == HttpStatusCode.InternalServerError)
						{	// check XErr
                            string strErr = httpResp.GetResponseHeader("X-Err");
                            if (strErr.StartsWith("0x") || strErr.StartsWith("0X")) strErr = strErr.Substring(2);

                            if (Convert.ToUInt32(strErr, 16) == HResult.XONLINE_E_STORAGE_INVALID_REQUEST)
                                ResultCode = TEST_RESULTS.PASSED;
							else
							{
								Global.RO.Warn("Wrong error code " + strErr +" returned");
							}
						}
					}
				}
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\FuncGlobalTitleRF.cs ===
using System;
using System.Text;
using System.IO;
using System.Net;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Storage;
using xonline.common.config;

namespace XStoreTest
{
	internal abstract class NegGlobalTitleRFTestBase : TestBase
	{
		//	send readFile requests, then check the error code
		protected bool ReadFileTestNegative(XRLReadFile ReadFileReq, uint XErr)
		{
			XRLReadFileResponse	ReadFileResp;
			if (ReadFileReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out ReadFileResp))
			{
				Global.RO.Warn("Negative ReadFile request succeed unexpectedly");
				return false;
			}
			if((ReadFileReq.XErr != XErr) || (ReadFileResp != null))
			{
				Global.RO.Warn("Wrong error code " + Global.XErrToString(ReadFileReq.XErr) +" returned or ReadFileResp is not null");
				return false;
			}
			return true;
		}
	}
	/// <summary>
	/// Summary description for FuncGlobalTitleRF.
	/// </summary>
    [TestGroup, Owner("JKonkle"), TestFrequency("Regression"), TestCasePriority(1)]
	public class FuncGlobalTitleRF : TestNode
	{
		/**********************************************************************
		 * Wire Protocol Testing Cases
		 **********************************************************************/
		[TestCase, Description("check X-Delay in the http response header")]
		class PThrottling : TestBase
		{
			override protected void Execute()
			{
				string pathName = "//title.ffffffff/t:ffffffff/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("ServiceAddr",pathName);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					int Xdelay= 3000;
					Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage,"exec :stfd SetXDelay "+readReq.uiTitleId.ToString("X")+" readfile "+Xdelay);

					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp)&&
						(readReq.XDelay == Xdelay))
						ResultCode=TEST_RESULTS.PASSED;

					Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage,"exec :stfd ReloadThrottleConfig");

				}
			}
		}
		[TestCase, Description("read a file for TitleA to the cache; try to read the file from a different title")]
			class PReadCacheFromDiffTitle : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string pathName= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("ServiceAddr",pathName);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp, readResp2;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
					{
						// the file now is in the cache; try to read the file from titleB
						XRLReadFile		readReq2 = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
						readReq2.Slot.titleId = readReq2.uiTitleId = writeReq.uiTitleId + 1;
						readReq2.Slot.titleVersion = readReq2.uiTitleVersion;
						if(!readReq2.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out readResp2))
                        {
                            if (readReq2.XErr == HResult.XONLINE_E_STORAGE_ERROR)
                            {
                                ResultCode = TEST_RESULTS.PASSED;
                            }
                            else
                            {
                                Global.RO.Warn("Wrong error code " + Global.XErrToString(readReq2.XErr) + " returned");
                            }
                        }
                        else
                        {
                            Global.RO.Warn("Read succeeded when it should've failed.");
                        }
					}
				}
			}
		}

        [TestCase, Description("read a file from cache for the same title")]
        class PReadCacheFromSameTitle : TestBase
        {
            override protected void Execute()
            {
                uint randomTitleID = (uint)new Random().Next();
                string sTitleID = randomTitleID.ToString("x");
                string pathName = "//title." + sTitleID + "/t:" + sTitleID + "/" + Guid.NewGuid().ToString();

                XRLWriteFile writeReq = new XRLWriteFile("ServiceAddr", pathName);
                if (!writeReq.Execute())
                {
                    throw new UnexpectedTestResultException("WriteFile failed: " + writeReq.XErr);
                }
                XRLReadFileResponse readResp, readResp2;
                XRLReadFile readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
                readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
                readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
                if (!readReq.Execute(Global.XEnv.GetInterface(Interface.stfd_storage)[0], out readResp))
                {
                    throw new UnexpectedTestResultException("ReadFile(1) failed: " + readReq.XErr);
                }
                // the file now is in the cache;
                // remove the actual file, then read the file again
                XRLRemoveFile removeReq = new XRLRemoveFile(pathName, randomTitleID, "ServiceAddr");
                if (!removeReq.Execute())
                {
                    throw new UnexpectedTestResultException("RemoveFile failed: " + removeReq.XErr);
                }
                XRLReadFile readReq2 = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
                readReq2.Slot.titleId = readReq2.uiTitleId = writeReq.uiTitleId;
                readReq2.Slot.titleVersion = readReq2.uiTitleVersion;
                if (!readReq2.Execute(Global.XEnv.GetInterface(Interface.stfd_storage)[0], out readResp2))
                {
                    throw new UnexpectedTestResultException("ReadFile(2) failed: " + readReq2.XErr);
                }
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("33960:Write a file first; then read the file with ifModifiedSince>actualModifiedTime")]
			class PModifiedSince : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string pathName= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("ServiceAddr",pathName);

				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;
					readReq.lIfModifiedSinceDate = (long)System.DateTime.UtcNow.AddHours(2).ToFileTimeUtc();
					if(!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp)&&
						(readReq.XErr == HResult.XONLINE_S_STORAGE_FILE_NOT_MODIFIED) && (readResp == null))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("Write a file first; the request this file with titleID set to max")]
			class PMaxTitlePUID : TestBase
		{
			override protected void Execute()
			{
				string pathName = "//title.ffffffff/t:ffffffff/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("ServiceAddr",pathName);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("Write a file first; the request this file with titleID set to min")]
			class PMinTitlePUID : TestBase
		{
			override protected void Execute()
			{
				string pathName = "//title.1/t:1/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("ServiceAddr",pathName);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("Write a file first; the request this file with machine PUID set to max")]
			class PMaxXBoxPUID : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string pathName= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("ServiceAddr",pathName);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					readReq.Slot.machinePuid = readReq.accessToken.baseAT.xboxPuid = 0xffffffffffffffff;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("Write a file first; the request this file with machine PUID set to min")]
			class PMinXBoxPUID : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string pathName= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("ServiceAddr",pathName);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					readReq.Slot.machinePuid = readReq.accessToken.baseAT.xboxPuid = 1;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request with mismatched TitleID"), TestCasePriority(2)]
			class NMismatchedTitleID : NegGlobalTitleRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string pathName= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("ServiceAddr",pathName);
				if(writeReq.Execute())
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId + 1;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_ERROR))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("write a valid file first, then request with mismatched TitleVersion")]
			class PMismatchedTitleVersion : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string pathName= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("ServiceAddr",pathName);
				if(writeReq.Execute())
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion= writeReq.uiTitleVersion + 1;
					XRLReadFileResponse		Response;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out Response))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("pass null for AccessToken"), TestCasePriority(2)]
		class NAccessTokenNullAT : NegGlobalTitleRFTestBase
		{
			override protected void Execute()
			{
				string pathName = "//title.1234/t:1234/" + Guid.NewGuid().ToString();
				XRLReadFile		readReq = new XRLReadFile(pathName);
				readReq.accessToken = null;

				if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode = TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass non-readfile operation in the AT"), TestCasePriority(2)]
			class NAccessTokenMismatchedOp : NegGlobalTitleRFTestBase
		{
			override protected void Execute()
			{
				string pathName = "//title.1234/t:1234/" + Guid.NewGuid().ToString();
				XRLReadFile		readReq = new XRLReadFile(pathName);
				readReq.accessToken.baseAT.operation = (ushort)Constants.Operation.FileWrite;

				if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode = TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("write a file first, then request it with pathnameLen is greater than the actual pathname"), TestCasePriority(2)]
			class NAccessTokenTruncatePathname : NegGlobalTitleRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string pathName= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("ServiceAddr",pathName);
				if(writeReq.Execute())
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					readReq.accessToken.baseAT.ManualArraySize = true;
					readReq.accessToken.baseAT.pathNameLen += 1;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a file first, then request it with pathnameLen is less than the actual pathname"), TestCasePriority(2)]
			class NAccessTokenOverflowPathname : NegGlobalTitleRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string pathName= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("ServiceAddr",pathName);
				if(writeReq.Execute())
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					readReq.accessToken.baseAT.ManualArraySize = true;
					readReq.accessToken.baseAT.pathNameLen -= 1;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("pass null for pathname and pathnameLen is 0"), TestCasePriority(2)]
			class NAccessTokenNullPathname : NegGlobalTitleRFTestBase
		{
			override protected void Execute()
			{
				string pathName = "//title.1234/t:1234/" + Guid.NewGuid().ToString();
				XRLReadFile		readReq = new XRLReadFile(pathName);
				readReq.accessToken.baseAT.pathName = null;
				readReq.accessToken.baseAT.pathNameLen = 0;

				if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode = TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("AccessToken size is greater than 255+baseAT"), TestCasePriority(2)]
			class NAccessTokenOverflowAT : NegGlobalTitleRFTestBase
		{
			override protected void Execute()
			{
				string url = "//title.1234/t:1234/" + Guid.NewGuid().ToString();
				XRLReadFile		readReq = new XRLReadFile(url);
				StringBuilder	pathName = new StringBuilder(readReq.accessToken.baseAT.pathName);
				int		numUniCharToAdd = 256 - readReq.accessToken.baseAT.pathNameLen;
				string			temp = new string('a',numUniCharToAdd);
				pathName.Append(temp);
				readReq.accessToken.baseAT.pathNameLen = 256;//actual pathName length is 256
				readReq.accessToken.baseAT.pathName = pathName.ToString();

				if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode = TEST_RESULTS.PASSED;
			}
		}

        [TestCase, Description("write file first, then request it with non-null signature but sigSize is zero"), TestCasePriority(2)]
			class NAccessTokenNonNullSignature : NegGlobalTitleRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string pathName= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("ServiceAddr",pathName);
				if(writeReq.Execute())
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.accessToken.readAT.ManualArraySize = true;
					readReq.accessToken.readAT.signatureLen = 0;
					readReq.accessToken.readAT.signature = new byte[Constants.sizeSignature];
					for(int i = 0; i < Constants.sizeSignature; i++)
						readReq.accessToken.readAT.signature[i] = 0;
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write file first, then request it with token exp is before current time"), TestCasePriority(2)]
			class NAccessTokenWrongATExpTime : NegGlobalTitleRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string pathName= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("ServiceAddr",pathName);
				if(writeReq.Execute())
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.accessToken.readAT.tokenExpirationDate = System.DateTime.UtcNow.AddDays(-1).ToFileTimeUtc();
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write file first, then request it with non-zero flags"), TestCasePriority(2)]
			class NAccessTokenWrongFlags : NegGlobalTitleRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string pathName= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("ServiceAddr",pathName);
				if(writeReq.Execute())
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.accessToken.baseAT.flags = 1;
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
		/**********************************************************************
		 * Pathname Testing Cases
		 **********************************************************************/
        [TestCase, Description("write a valid file first, then request it with one null char in the middle of <Domain-part>"), TestCasePriority(2)]
		class NPathnameBadString1 : NegGlobalTitleRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("ServiceAddr",url);
				if(writeReq.Execute())
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					newPath = pathName.Insert(6,'\0'.ToString());

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					//TODO: need to return xonline_e_storage_domain_not_supported
					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it with two null char in the middle of <domain-part>"), TestCasePriority(2)]
			class NPathnameBadString2 : NegGlobalTitleRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("ServiceAddr",url);
				if(writeReq.Execute())
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath, temp;
					temp = '\0'.ToString() + '\0'.ToString();
					newPath = pathName.Insert(6,temp);	// //stat..s/u:....

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it with one nullchar in the middle of <title>"), TestCasePriority(2)]
			class NPathnameBadString3 : NegGlobalTitleRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("ServiceAddr",url);
				if(writeReq.Execute())
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					newPath = pathName.Insert(17,'\0'.ToString());

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it with one nullchar in the middle of <pathpart>"), TestCasePriority(2)]
			class NPathnameBadString4 : NegGlobalTitleRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("ServiceAddr",url);
				if(writeReq.Execute())
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					newPath = pathName.Insert(30,'\0'.ToString());

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it with one nullchar at the end of <pathpart>"), TestCasePriority(2)]
			class NPathnameBadString5 : NegGlobalTitleRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("ServiceAddr",url);
				if(writeReq.Execute())
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					newPath = pathName + '\0'.ToString();

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it by passing a nonexisitent <path-part>(vc_name)"), TestCasePriority(2)]
			class NPathnameNonExistFile1 : NegGlobalTitleRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("ServiceAddr",url);
				if(writeReq.Execute())
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					int		guidStartPos = pathName.LastIndexOf('/');
					newPath = pathName.Substring(0,guidStartPos)+ "/" + Guid.NewGuid().ToString();

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it by passing wrong titleID"), TestCasePriority(2)]
			class NPathnameNonExistFile2 : NegGlobalTitleRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("ServiceAddr",url);
				if(writeReq.Execute())
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					int		pos = pathName.IndexOf("t:"), guidStart = pathName.LastIndexOf('/');
					newPath = pathName.Substring(0,pos)+ "t:789789" + pathName.Substring(guidStart);

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it by passing wrong IDNameSpace"), TestCasePriority(2)]
			class NPathnameNonExistFile3 : NegGlobalTitleRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("ServiceAddr",url);
				if(writeReq.Execute())
				{
					// "//stats/u:<ulonglong>/<guid>"
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					newPath = pathName.Replace("t:","x:");

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it by passing wrong Domain"), TestCasePriority(2)]
			class NPathnameNonExistFile4 : NegGlobalTitleRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("ServiceAddr",url);
				if(writeReq.Execute())
				{
					// "//stats/u:<ulonglong>/<guid>"
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					newPath = pathName.Replace("title","voice");

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_PATH))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("Write file first, then request it by passing a pathname that has no domain part"), TestCasePriority(2)]
			class NPathnameNoDomainPart : NegGlobalTitleRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("ServiceAddr",url);
				if(writeReq.Execute())
				{
					string path = writeReq.accessToken.baseAT.pathName, newPath, temp;
					temp = path.Substring(path.IndexOf("t:"));
					newPath = "///" + temp;

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("Write file first, then request it by passing no t:"), TestCasePriority(2)]
			class NPathnameNoIDNameSpace : NegGlobalTitleRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("ServiceAddr",url);
				if(writeReq.Execute())
				{
					string path = writeReq.accessToken.baseAT.pathName, newPath;
					newPath = path.Remove(path.IndexOf("t:"),1);

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("Write file first, then request it by passing no titleID"), TestCasePriority(2)]
			class NPathnameNoUserPUID : NegGlobalTitleRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("ServiceAddr",url);
				if(writeReq.Execute())
				{
					string pathName = writeReq.accessToken.baseAT.pathName, newPath;
					int		pos = pathName.IndexOf("t:"), guidStart = pathName.LastIndexOf('/');
					newPath = pathName.Substring(0,pos)+ "t:" + pathName.Substring(guidStart);

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}

        [TestCase, Description("Write file first, then request it by pass wrong charset"), TestCasePriority(2)]
			class NPathnameWrongCharSet : NegGlobalTitleRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("ServiceAddr",url);
				if(writeReq.Execute())
				{
					string path = writeReq.accessToken.baseAT.pathName;
					StringBuilder	pathName = new StringBuilder(path);
					//Bug 27831: domain and optional domain specified: A-Za-z0-9_
					// pathname allows anything except control chars('\0\, control characters, etc)
					char i = '\0';
					pathName.Append(i);

					XRLReadFile		readReq = new XRLReadFile(pathName.ToString());
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
		/***********************************************************************
		* SG Auth Data Testing
		* *********************************************************************/
        [TestCase, Description("the userPUID in SGAuth response is not_found user"), TestCasePriority(2)]
			class NSGAuthNotFoundUser : NegGlobalTitleRFTestBase
		{
			override protected void Execute()
			{
				string url = "//title.1234/t:1234/" + Guid.NewGuid().ToString();
				XRLReadFile	req = new XRLReadFile(url);
				req.Slot.UserExists = 0;

				if(ReadFileTestNegative(req,HResult.XONLINE_E_SERVER_ERROR))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the userPUID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidUser : NegGlobalTitleRFTestBase
		{
			override protected void Execute()
			{
				string url = "//title.1234/t:1234/" + Guid.NewGuid().ToString();
				XRLReadFile	req = new XRLReadFile(url);
				req.Slot.userPuid0++;

				if(ReadFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the TitleID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidTitleID : NegGlobalTitleRFTestBase
		{
			override protected void Execute()
			{
				string url = "//title.1234/t:1234/" + Guid.NewGuid().ToString();
				XRLReadFile	req = new XRLReadFile(url);
				req.Slot.titleId++;

				if(ReadFileTestNegative(req,HResult.XONLINE_E_INVALID_TITLE_ID))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the XBoxPUID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidXBoxPUID : NegGlobalTitleRFTestBase
		{
			override protected void Execute()
			{
				string url = "//title.1234/t:1234/" + Guid.NewGuid().ToString();
				XRLReadFile	req = new XRLReadFile(url);
				req.Slot.machinePuid++;

				if(ReadFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the TitleVersion in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidTitleVersion : NegGlobalTitleRFTestBase
		{
			override protected void Execute()
			{
				string url = "//title.1234/t:1234/" + Guid.NewGuid().ToString();
				XRLReadFile	req = new XRLReadFile(url);
				req.Slot.titleVersion++;

				if(ReadFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the CountryID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidCountryID : NegGlobalTitleRFTestBase
		{
			override protected void Execute()
			{
				string url = "//title.1234/t:1234/" + Guid.NewGuid().ToString();
				XRLReadFile	req = new XRLReadFile(url);
				req.Slot.userFlag0 = (uint)((req.bUserCountryId+1)<<8);

				if(ReadFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}

		/**********************************************************************
		 * Other ReadFile Testing Cases
		 **********************************************************************/
		[TestCase, Description("Multiple threads read same file simultaneously")]
			class PMultiThreadsReadFile : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string xrl= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("ServiceAddr",xrl);
				pathName = writeReq.accessToken.baseAT.pathName;
				uiTitleId = writeReq.uiTitleId;
				uiTitleVersion = writeReq.uiTitleVersion;

				if(writeReq.Execute())
				{
					Thread [] threadArray = new Thread[10];
					for(int i = 0; i < 10; i++)
					{
						threadArray[i] = ThreadMaker.CreateThread(readFileTS);
						threadArray[i].Start();
					}
					// the main thread is waiting for all threads to exit or timeout
					foreach (Thread t in threadArray)
						t.Join(1000);
					if(FailedReqs == 0)
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
			private void readFileTS()
			{
				XRLReadFileResponse	readResp;
				XRLReadFile		readReq = new XRLReadFile(pathName);
				readReq.Slot.titleId = readReq.uiTitleId = uiTitleId;
				readReq.Slot.titleVersion = readReq.uiTitleVersion = uiTitleVersion;

				if(!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out readResp))
				{
					Global.RO.Warn("readFileTS: read file request failed");
					Interlocked.Increment(ref FailedReqs);
				}
			}
			private string	pathName;
			private uint	uiTitleId, uiTitleVersion;
			private int		FailedReqs;
		}
		[TestCase, Description("read file 100 times and check bi_read_count in t_files")]
			// bi_read_count in t_files: number of times the file has been read
		class PReadFileMultiTimes : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string pathName= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("ServiceAddr",pathName);
				if(writeReq.Execute())
				{
					uint				uiFailedReq = 0;
					for(int i = 0; i < 100; i++)
					{
						XRLReadFileResponse	readResp;
						XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
						readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
						readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
						if(!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
							uiFailedReq++;
					}
					if(uiFailedReq == 0)
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		[TestCase, Description("the titleID in the request is not the acutal logged on title")]
			class PFamilyTitleID : TestBase
		{
			override protected void Execute()
			{
				string pathName = "//title.5566/t:5566/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("ServiceAddr",pathName);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.altTitleId1 = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleId = readReq.uiTitleId + 1;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("Read file from a different title other than creator's"), TestCasePriority(2)]
			class NFromDifferentTitle : NegativeRFTestBase
		{
			override protected void Execute()
			{
				string pathName = "//title.5566/t:5566/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("ServiceAddr",pathName);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId + 1;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion + 1;
                    if (!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out readResp))
                    {
                        if (readReq.XErr == HResult.XONLINE_E_STORAGE_ERROR)
                        {
                            ResultCode = TEST_RESULTS.PASSED;
                        }
                        else
                        {
                            Global.RO.Warn("Wrong error code " + Global.XErrToString(readReq.XErr) + " returned");
                        }
                    }
                    else
                    {
                        Global.RO.Warn("Read succeeded when it should've failed.");
                    }
                }
			}
		}
		[TestCase, Description("Read file from a different titleVersion other than creator's")]
			class PFromDifferentTitleVersion : TestBase
		{
			override protected void Execute()
			{
				string pathName = "//title.5566/t:5566/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("ServiceAddr",pathName);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion + 1;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\FuncCrossTitleWF.cs ===
using System;
using System.Globalization;
using System.Text;
using System.Net;
using System.IO;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Storage;
using ServerTestFramework.LiveService.Signature;
using ServerTestFramework.Utilities;
using xonline.common.config;

namespace XStoreTest
{
	internal abstract class CrossTitleWFTestBase : TestBase
	{
		//    send WriteFile request first; then readfile from different title;verifies the response
		protected bool WriteFileSendAndVerify(XRLWriteFile WriteFileReq)
		{
			bool fPassed=WriteFileReq.Execute();
			if (!fPassed)
			{
				Global.RO.Warn("Failed to send WriteFile request ");
				return false;
			}

			XRLReadFileResponse    ReadFileResp;
			XRLReadFile            ReadFileReq = new XRLReadFile(WriteFileReq.accessToken.baseAT.pathName);
			ReadFileReq.Slot.titleId = ReadFileReq.uiTitleId = WriteFileReq.uiTitleId+1;
			ReadFileReq.Slot.titleVersion = ReadFileReq.uiTitleVersion = WriteFileReq.uiTitleVersion+1;
			if (ReadFileReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out ReadFileResp))
			{
				if ((!ReadFileResp.Compare(WriteFileReq)) || (!WriteFileReq.Verify()))
				{
					Global.RO.Warn("WriteFile request is not set correctly in the db");
					return false;
				}
			}
			else
			{
				Global.RO.Warn("Failed to send ReadFile request");
				return false;
			}
			return true;
		}
	}
	internal abstract class CrossTitleWFNegTestBase : TestBase
	{
		// send WriteFile request first; then send readfile;verifies the response
		protected bool WriteFileTestNegative(XRLWriteFile WriteFileReq,uint XErr)
		{
			if (WriteFileReq.Execute())
			{
				Global.RO.Warn("Negative WriteFile request succeed unexpectedly");
				return false;
			}
			if(WriteFileReq.XErr != XErr)
			{
				Global.RO.Warn("Wrong error code returned " + Global.XErrToString(WriteFileReq.XErr));
				return false;
			}
			// now we need to check the file is not written to the DB
			XRLReadFileResponse    ReadFileResp;
			XRLReadFile            ReadFileReq = new XRLReadFile(WriteFileReq.accessToken.baseAT.pathName);
			if (!ReadFileReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out ReadFileResp))
			{
				if(ReadFileResp != null)
				{
					Global.RO.Warn("File is being written to DB unexpectedly");
					return false;
				}
			}
			else
			{
				Global.RO.Warn("ReadFile request succeed with S_OK unexpectedly");
				return false;
			}
			return true;
		}
	}
    [TestGroup, Owner("JKonkle"), TestFrequency("Regression"), TestCasePriority(1)]
	public class FuncCrossTitleWF : TestNode
	{
		/***********************************************************************
		 * Wire Protocol Testing
		 * *********************************************************************/
		[TestCase, Description("Write a file with all valid parameters including attributes")]
			class PNormalCase : CrossTitleWFTestBase
		{
			override protected void Execute()
			{
				uint    randomIndex = (uint)new Random().Next();
				string url= "//global/t:FFFE07D1/ach/1/" + randomIndex.ToString("x");

				XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
				req.attributes = new byte[100];
				new Random().NextBytes(req.attributes);
				req.attributesLen = (ushort)req.attributes.Length;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		// npdb: t_storage_domain: 11mb
		[TestCase, Description("Write a max size file")]
			class PBlobDataMaxSize : CrossTitleWFTestBase
		{
			override protected void Execute()
			{
				uint    randomIndex = (uint)new Random().Next();
				string url= "//global/t:FFFE07D1/ach/1/" + randomIndex.ToString("x");

				XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
				req.blobData = new byte[11*1024*1024];
				new Random().NextBytes(req.blobData);
				req.blobDataLen = req.uiBlobSizeCompressed = (uint)req.blobData.Length;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass attributes with 256 byte")]
			class PMaxAttributeSize : CrossTitleWFTestBase
		{
			override protected void Execute()
			{
				uint    randomIndex = (uint)new Random().Next();
				string url= "//global/t:FFFE07D1/ach/1/" + randomIndex.ToString("x");

				XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
				uint attLen = Constants.maxSizeAttributes;
				req.attributes = new byte[attLen];
				new Random().NextBytes(req.attributes);
				req.attributesLen = (ushort)req.attributes.Length;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass 0 attributeslen")]
			class PMinAttributeSize : CrossTitleWFTestBase
		{
			override protected void Execute()
			{
				uint    randomIndex = (uint)new Random().Next();
				string url= "//global/t:FFFE07D1/ach/1/" + randomIndex.ToString("x");

				XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
				req.attributes = null;
				req.attributesLen = 0;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		
		[TestCase, Description("pass 0 for uncompressed blob size and null blobdata")]
			class PEmptyFile : CrossTitleWFTestBase
		{
			override protected void Execute()
			{
				uint    randomIndex = (uint)new Random().Next();
				string url= "//global/t:FFFE07D1/ach/1/" + randomIndex.ToString("x");

				XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
				req.blobDataLen = req.uiBlobSizeCompressed = 0;
				req.blobData = null;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("try to write a file that is bigger than max allowed"), TestCasePriority(2)]
			class NBiggerThanMaxFile : CrossTitleWFNegTestBase
		{
			override protected void Execute()
			{
				uint    randomIndex = (uint)new Random().Next();
				string url= "//global/t:FFFE07D1/ach/1/" + randomIndex.ToString("x");

				XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
				req.blobData = new byte[11*1024*1024+1];
				new Random().NextBytes(req.blobData);
				req.blobDataLen = req.uiBlobSizeCompressed = (uint)req.blobData.Length;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_FILE_IS_TOO_BIG))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("Attributes size is smaller than the actual size"), TestCasePriority(2)]
		class NWrongAttribSize : CrossTitleWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//global/t:FFFE07D1/ach/8989/" + new Random().Next();
				XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
				req.ManualArraySize = true;
				req.attributes = new Byte[16];
				req.attributesLen = 15;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass null for AccessToken"), TestCasePriority(2)]
			class NNullAccessToken : CrossTitleWFNegTestBase
		{
			override protected void Execute()
			{
				uint	randomIndex = (uint)new Random().Next();
				string url= "//global/t:FFFE07D1/ach/8989/" + randomIndex.ToString("x");
				XRLWriteFile    WriteFileReq = new XRLWriteFile("ServiceAddr",url);
				WriteFileReq.ManualArraySize = true;
				WriteFileReq.accessToken = null;
				if (!WriteFileReq.Execute())
				{
					if((WriteFileReq.XErr != HResult.XONLINE_E_STORAGE_INVALID_REQUEST)&&
						(WriteFileReq.XErr != HResult.XONLINE_E_SERVER_ERROR))
						Global.RO.Warn("Wrong error code returned " + Global.XErrToString(WriteFileReq.XErr));
					else
						ResultCode=TEST_RESULTS.PASSED;
				}
				else
					Global.RO.Warn("Negative WriteFile request succeed unexpectedly");
			}
		}
        [TestCase, Description("Access Token version is invalid"), TestCasePriority(2)]
			class NAccessTokenInvalidTokenVersion : CrossTitleWFNegTestBase
		{
			override protected void Execute()
			{
				uint	randomIndex = (uint)new Random().Next();
				string url= "//global/t:FFFE07D1/ach/8989/" + randomIndex.ToString("x");
				XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
				req.accessToken.baseAT.version = Constants.accessTokenVersion + 1;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the flags in AT is non-zero"), TestCasePriority(2)]
			class NAccessTokenInvalidFlags : CrossTitleWFNegTestBase
		{
			override protected void Execute()
			{
				uint	randomIndex = (uint)new Random().Next();
				string url= "//global/t:FFFE07D1/ach/8989/" + randomIndex.ToString("x");
				XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
				req.accessToken.baseAT.flags = 1;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		/***********************************************************************
		* Pathname Testing
		* *********************************************************************/
        [TestCase, Description("pass an invalid feature in the pathname"), TestCasePriority(2)]
			class NPathnameInvalidFeature : CrossTitleWFNegTestBase
		{
			override protected void Execute()
			{
				uint	randomIndex = (uint)new Random().Next();
				string url= "//global/t:FFFE07D1/achv/8989/" + randomIndex.ToString("x");
				XRLWriteFile    writeReq = new XRLWriteFile("ServiceAddr",url);

				if(WriteFileTestNegative(writeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass non hexdecimal in the index"), TestCasePriority(2)]
		class NPathnameNonHexIndex : CrossTitleWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//global/t:FFFE07D1/ach/8989/g12";
				XRLWriteFile    writeReq = new XRLWriteFile("ServiceAddr",url);

				if(WriteFileTestNegative(writeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass non hexdecimal in the version"), TestCasePriority(2)]
			class NPathnameNonHexVersion : CrossTitleWFNegTestBase
		{
			override protected void Execute()
			{
				uint	randomIndex = (uint)new Random().Next();
				string url= "//global/t:FFFE07D1/ach/8989g/" + randomIndex.ToString("x");
				XRLWriteFile    writeReq = new XRLWriteFile("ServiceAddr",url);

				if(WriteFileTestNegative(writeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass a pathname that one null char in the middle of <Domain-part>"), TestCasePriority(2)]
		class NPathnameBadString1 : CrossTitleWFNegTestBase
		{
			override protected void Execute()
			{
				uint	randomIndex = (uint)new Random().Next();
				string url= "//global/t:FFFE07D1/ach/8989/" + randomIndex.ToString("x");
				string newurl = url.Insert(4,'\0'.ToString());
				XRLWriteFile    writeReq = new XRLWriteFile("ServiceAddr",newurl);

				//TODO: need to return xonline_e_storage_domain_not_supported
				if(WriteFileTestNegative(writeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass a pathname that two null char in the middle of <Domain-part>"), TestCasePriority(2)]
		class NPathnameBadString2 : CrossTitleWFNegTestBase
		{
			override protected void Execute()
			{
				uint	randomIndex = (uint)new Random().Next();
				string url= "//global/t:FFFE07D1/ach/8989/" + randomIndex.ToString("x"), temp, newurl;
				temp = '\0'.ToString() + '\0'.ToString();
				newurl = url.Insert(4,'\0'.ToString());
				XRLWriteFile    writeReq = new XRLWriteFile("ServiceAddr",newurl);

				//TODO: need to return xonline_e_storage_domain_not_supported
				if(WriteFileTestNegative(writeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass float number in the index"), TestCasePriority(2)]
			class NPathnameBadString5 : CrossTitleWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//global/t:FFFE07D1/ach/8989/1.2";
				XRLWriteFile    writeReq = new XRLWriteFile("ServiceAddr",url);

				if(WriteFileTestNegative(writeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("<Domain-part> is missing in pathname"), TestCasePriority(2)]
			class NPathnameNoDomainPart : CrossTitleWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//t:FFFE07D1/ach/8989/12";
				XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass a pathname that has special chars"), TestCasePriority(2)]
			class NPathnameWrongCharSet : CrossTitleWFNegTestBase
		{
			override protected void Execute()
			{
				uint	randomIndex = (uint)new Random().Next();
				string url= "//global/t:FFFE07D1/ach/89a89/" + randomIndex.ToString("x")+'\0';

				XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
				
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		/*****************************************************************
		 *  Other Testing
		 *****************************************************************/
		// bug 38096
		[TestCase, Description("Check X-Delay in the http response")]
		class PThrottling : CrossTitleWFTestBase
		{
			override protected void Execute()
			{
				uint	randomIndex = (uint)new Random().Next();
				string url= "//global/t:FFFE07D1/ach/8989/" + randomIndex.ToString("x");
				XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);

				int Xdelay= 3000;
				Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage,"exec :stfd SetXDelay "+ req.uiTitleId.ToString("X")+" writefile "+Xdelay);

				if(WriteFileSendAndVerify(req) && (req.XDelay == Xdelay))
					ResultCode=TEST_RESULTS.PASSED;

				Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage,"exec :stfd ReloadThrottleConfig");

			}
		}
        [TestCase, Description("try to update an existing file"), TestCasePriority(2)]
        class NUpdateExistingFile : TestBase
        {
            private RandomEx RandGen = new RandomEx();

            override protected void Execute()
            {
                uint randomIndex = (uint)RandGen.Next();
                string url = "//global/t:FFFE07D1/ach/234/" + randomIndex.ToString("x");

                XRLWriteFile req1 = new XRLWriteFile("ServiceAddr", url);
                if (!req1.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int)))
                {
                    throw new UnexpectedTestResultException("First WriteFile failed: " +
                        Global.XErrToString(req1.XErr));
                }

                XRLWriteFile req2 = new XRLWriteFile("ServiceAddr", url);
                req2.Slot.titleId = req2.uiTitleId = req1.uiTitleId;
                req2.Slot.titleVersion = req2.uiTitleVersion = req1.uiTitleVersion;
                req2.bUserCountryId = req1.bUserCountryId;
                req2.Slot.userPuid0 = req1.Slot.userPuid0;
                req2.accessToken.baseAT.userPuid = req1.accessToken.baseAT.userPuid;
                req2.Slot.userFlag0 = (uint)req1.bUserCountryId << 8;
                req2.CustomHeader = req1.CustomHeader;
                // make sure the two blobs are different
                req2.blobHash[1] = (byte)(req1.blobHash[1] + 1);
                if (!req2.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int)) &&
                    (req2.XErr == HResult.XONLINE_E_STORAGE_FILE_ALREADY_EXISTS))
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    throw new UnexpectedTestResultException("Second WriteFile failed: " + 
                        Global.XErrToString(req2.XErr));
                }
            }
        }
		
		[TestCase, Description("write file 50 times")]
			class PWriteFileMultiTimes : CrossTitleWFTestBase
		{
			override protected void Execute()
			{
				uint            uiFailedReq = 0;
				for(int i = 0; i < 50; i++)
				{
					uint    randomIndex = (uint)new Random().Next();
					string url= "//global/t:FFFE07D1/ach/1/" + randomIndex.ToString("x");

					XRLWriteFile    writeReq = new XRLWriteFile("ServiceAddr",url);
					if(!WriteFileSendAndVerify(writeReq))
						uiFailedReq++;
				}
				if(uiFailedReq == 0)
					ResultCode=TEST_RESULTS.PASSED;
				else
					Global.RO.Warn("It failed " + uiFailedReq.ToString() + " times");
			}
		}
		
		/***********************************************************************
		* HTTPAuth Data header testing
		***********************************************************************/
		// bug 33194
        [TestCase, Description("the TitleID in HTTPAuthData header is different than the one in the WriteFile request"), TestCasePriority(2)]
		class NHTTPAuthInvalidTitleID : CrossTitleWFNegTestBase
		{
			override protected void Execute()
			{
				uint    randomIndex = (uint)new Random().Next();
				string url= "//global/t:FFFE07D1/ach/1/" + randomIndex.ToString("x");
				XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
				uint            titleID = req.uiTitleId + 1;
				ulong    requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
				uint    ip = 0;
				byte [] addr = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).Address.GetAddressBytes();
				for(int i = 0; i < addr.Length; i++)
					ip = (ip << 8) + addr[i];
				HTTPAuthData authData = new HTTPAuthData((ushort) Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int).Port,
					ip,requestId,0,titleID,(uint)XOService.Storage,0);
				authData.dwTitleVersion = req.uiTitleVersion;
				req.CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" +
					authData.GetBase64EncodedString() + "\r\n";

				if(WriteFileTestNegative(req,HResult.XONLINE_E_INVALID_TITLE_ID))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the TitleVersion in HTTPAuthData is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NHTTPAuthInvalidTitleVersion : CrossTitleWFNegTestBase
		{
			override protected void Execute()
			{
				uint    randomIndex = (uint)new Random().Next();
				string url= "//global/t:FFFE07D1/ach/1/" + randomIndex.ToString("x");
				XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
				ulong    requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
				uint    ip = 0;
				byte [] addr = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).Address.GetAddressBytes();
				for(int i = 0; i < addr.Length; i++)
					ip = (ip << 8) + addr[i];
				HTTPAuthData authData = new HTTPAuthData((ushort) Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int).Port,
					ip,requestId,0,0xFFFE07D1,(uint)XOService.Storage,0);
				authData.dwTitleVersion = req.uiTitleVersion + 1;
				req.CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" +
					authData.GetBase64EncodedString() + "\r\n";

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the Service ID in HTTPAuthData is different than the one in WriteFile request"), TestCasePriority(2)]
		class NHTTPAuthInvalidServiceID : CrossTitleWFNegTestBase
		{
			override protected void Execute()
			{
				uint    randomIndex = (uint)new Random().Next();
				string url= "//global/t:FFFE07D1/ach/1/" + randomIndex.ToString("x");
				XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
				ulong    requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
				uint    ip = 0;
				byte [] addr = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).Address.GetAddressBytes();
				for(int i = 0; i < addr.Length; i++)
					ip = (ip << 8) + addr[i];
				HTTPAuthData authData = new HTTPAuthData((ushort) Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int).Port,
					ip,requestId,0,0xfffe07d1,(uint)XOService.Arbitration,0);
				authData.dwTitleVersion = req.uiTitleVersion + 1;
				req.CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" +
					authData.GetBase64EncodedString() + "\r\n";

				if(WriteFileTestNegative(req,HResult.XONLINE_E_SERVER_ERROR))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\FuncMsgDF.cs ===
using System;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Storage;
using ServerTestFramework.LiveService.Signature;
using xonline.common.config;

namespace XStoreTest
{
    internal abstract class MsgDFTestBase : TestBase
    {
        protected bool RemoveFileSendAndVerify(XRLRemoveFile removeReq)
        {
            string    pathName = removeReq.accessToken.baseAT.pathName;
            XRLWriteFile    WriteReq = new XRLWriteFile("All", pathName);
            WriteReq.Slot.titleId = WriteReq.uiTitleId = removeReq.uiTitleId;
            if(WriteReq.Execute())
            {
                if(removeReq.Execute())
                {
                    XRLReadFile        readReq = new XRLReadFile(pathName);
                    readReq.Slot.titleId = readReq.uiTitleId = WriteReq.uiTitleId;
                    if(!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)) &&
                        (readReq.XErr == HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
                        return true;
                    else
                    {
                        Global.RO.Warn("File was not removed");
                        return false;
                    }
                }
                Global.RO.Warn("RemoveFile request failed with "+Global.XErrToString(removeReq.XErr));
                return false;
            }
            return false;
        }
    }
    internal abstract class NegMsgDFTestBase : TestBase
    {
        protected bool RemoveFileTestNegative(XRLRemoveFile    removeReq, uint XErr)
        {
            if (removeReq.Execute())
            {
                Global.RO.Warn("Negative RemoveFile request succeed unexpectedly");
                return false;
            }
            if(removeReq.XErr != XErr)
            {
                Global.RO.Warn("Wrong error code " + Global.XErrToString(removeReq.XErr) +" returned");
                return false;
            }
            return true;
        }
    }
    [TestGroup, Owner("JKonkle"), TestFrequency("Regression"), TestCasePriority(1)]
    public class FuncMsgDF : TestNode
    {
        /**********************************************************************************
         * Positive Wire Protocol Testing
         *********************************************************************************/
		// bug 38096
        [TestCase(38096), Description("check X-Delay in the http response header")]
			class PThrottling : MsgDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//msg.3/u:89899/" + Guid.NewGuid().ToString();
                uint    titleID = (uint) new Random().Next();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");

				int Xdelay= 3000;
				Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage,"exec :stfd SetXDelay "+removeReq.uiTitleId.ToString("X")+" removefile "+Xdelay);

                if(RemoveFileSendAndVerify(removeReq) && (removeReq.XDelay == Xdelay))
                    ResultCode=TEST_RESULTS.PASSED;

				Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage,"exec :stfd ReloadThrottleConfig");

            }
        }
        [TestCase, Description("Write a file first then call removeFile by the different user")]
			class PNormalCase : MsgDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//msg.3/u:89899/" + Guid.NewGuid().ToString();
                uint    titleID = (uint) new Random().Next();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                if(RemoveFileSendAndVerify(removeReq))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("call removeFile with maximum titleID")]
			class PMaxTitleID : MsgDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//msg.3/u:89899/" + Guid.NewGuid().ToString();
                uint    titleID = 0xffffffff;
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                if(RemoveFileSendAndVerify(removeReq))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("call removeFile with minimum titleID")]
			class PMinTitleID : MsgDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//msg.3/u:89899/" + Guid.NewGuid().ToString();
                uint    titleID = 1;
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                if(RemoveFileSendAndVerify(removeReq))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("call removeFile with maximum titleVersion")]
			class PMaxTitleVersion : MsgDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//msg.3/u:89899/" + Guid.NewGuid().ToString();
                uint    ip = 0;
                uint    titleID = (uint) new Random().Next();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                ulong    requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
                byte [] addr = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).Address.GetAddressBytes();
                for(int i = 0; i < addr.Length; i++)
                    ip = (ip << 8) + addr[i];
                HTTPAuthData authData = new HTTPAuthData((ushort) Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int).Port,
                    ip,requestId,0,titleID,(uint)XOService.Storage,0);
                authData.dwTitleVersion = removeReq.uiTitleVersion = 0xffffffff;
                removeReq.CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" +
                    authData.GetBase64EncodedString() + "\r\n";

                if(RemoveFileSendAndVerify(removeReq))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("call removeFile with minimum titleVersion")]
			class PMinTitleVersion : MsgDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//msg.3/u:89899/" + Guid.NewGuid().ToString();
                uint    titleID = (uint) new Random().Next();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                removeReq.uiTitleVersion = 1;
                uint    ip = 0;
                ulong requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
                byte [] addr = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).Address.GetAddressBytes();
                for(int i = 0; i < addr.Length; i++)
                    ip = (ip << 8) + addr[i];
                HTTPAuthData authData = new HTTPAuthData((ushort) Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int).Port,
                    ip,requestId,0,titleID,(uint)XOService.Storage,0);
                authData.dwTitleVersion = 1;
                removeReq.CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" +
                    authData.GetBase64EncodedString() + "\r\n";
                if(RemoveFileSendAndVerify(removeReq))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("call removeFile with 255 unicode chars")]
			class PMaxPathNameSize : MsgDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//msg.3/u:89899/" + Guid.NewGuid().ToString();
                uint    titleID = (uint) new Random().Next();
                StringBuilder    pathBuilder = new StringBuilder(pathName);
                if(pathName.Length < 255)
                    pathBuilder.Append('z',255-pathName.Length);

                XRLRemoveFile    removeReq = new XRLRemoveFile(pathBuilder.ToString(),titleID,"ServiceAddr");
                if(RemoveFileSendAndVerify(removeReq))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        /**********************************************************************************
         * Positive Other Testing
         *********************************************************************************/
        [TestCase, Description("create a file with a pathname and one title ID, call RemoveFile with the same pathname but different title ID"), TestCasePriority(2)]
			class NRemoveFromOtherTitle : TestBase
        {
            override protected void Execute()
            {
                string    pathName = "//msg.3/u:89899/" + Guid.NewGuid().ToString();
                uint    titleID = (uint) new Random().Next();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                XRLWriteFile    WriteReq = new XRLWriteFile("All",pathName);
                WriteReq.Slot.titleId = WriteReq.uiTitleId = titleID + 1;
                if(WriteReq.Execute())
                {
                    if(!removeReq.Execute()&& (removeReq.XErr == HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
                            ResultCode=TEST_RESULTS.PASSED;
                }
            }
        }
        [TestCase, Description("call RemoveFile with the same pathname and titleID as writeFile but different title Version")]
			class PRemoveFromOtherTitleVersion : TestBase
        {
            override protected void Execute()
            {
                string    pathName = "//msg.3/u:89899/" + Guid.NewGuid().ToString();
                uint    titleID = (uint) new Random().Next();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                XRLWriteFile    WriteReq = new XRLWriteFile("All",pathName);
				WriteReq.Slot.titleId = WriteReq.uiTitleId = titleID;
                WriteReq.Slot.titleVersion = WriteReq.uiTitleVersion = removeReq.uiTitleVersion + 1;
                if(WriteReq.Execute())
                {
                    if(removeReq.Execute())
                    {
                        XRLReadFile        readReq = new XRLReadFile(pathName);
                        if(!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)) &&
                            (readReq.XErr == HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
                            ResultCode=TEST_RESULTS.PASSED;
                    }
                }
            }
        }
        [TestCase, Description("remove only one ref for a file with multiple references")]
			class PRemoveFileWithMultiRef : TestBase
        {
            override protected void Execute()
            {
                string    pathName = "//msg.3/u:89899/" + Guid.NewGuid().ToString();
                uint    title = (uint) new Random().Next();
                // write a blob with 4 references
                uint        FileWithMultiRefLen = 10240;
                byte[]        FileData = new byte[FileWithMultiRefLen];
                new Random().NextBytes(FileData);
                byte[]        FileWithMultiRefHash = new byte[Constants.sizeHash];
                new Random().NextBytes(FileWithMultiRefHash);
                string        MultiRefPath1 = "", RemovedRefPath = "";
                XRLWriteFile    wReq1 = new XRLWriteFile("All",pathName), wReq2 = new XRLWriteFile("All",pathName);
                for(int i = 0; i < 4; i++)
                {
                    pathName = "//msg.3/u:89899/" + Guid.NewGuid().ToString();
                    XRLWriteFile    writeReq = new XRLWriteFile("All",pathName);
                    writeReq.uiTitleId = title;
                    writeReq.Slot.titleId = title;
                    writeReq.blobDataLen = FileWithMultiRefLen;
                    writeReq.uiBlobSizeCompressed = FileWithMultiRefLen;
                    writeReq.blobData = new byte[FileWithMultiRefLen];
                    FileData.CopyTo(writeReq.blobData,0);
                    FileWithMultiRefHash.CopyTo(writeReq.blobHash,0);

                    if(!writeReq.Execute())
                    {
                        Global.RO.Warn("Write File failed:"+i);
                        return;
                    }
                    if(i == 0)
                    {
                        wReq1 = writeReq;
                        MultiRefPath1 = writeReq.accessToken.baseAT.pathName;
                    }
                    else if (i == 1)
                        wReq2 = writeReq;
                    // the removed Ref path will be i = 3
                    RemovedRefPath = writeReq.accessToken.baseAT.pathName;
                }

                // only remove one reference to the file; the file still in the db and
                // check the i_ref_count=3
                XRLRemoveFile    removeReq = new XRLRemoveFile(RemovedRefPath,title,"ServiceAddr");
                if(removeReq.Execute())
                {
                    XRLReadFile        readReq = new XRLReadFile(MultiRefPath1);
                    readReq.Slot.titleId = readReq.uiTitleId = title;
                    XRLReadFileResponse    resp;
                    if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out resp))
                        // check ref count
                        if(wReq1.CheckRefCount(wReq2,3,false))
                            ResultCode=TEST_RESULTS.PASSED;
                }
            }
        }
        [TestCase, Description("remove all refs for a file with multiple references")]
			class PRemoveFileWithMultiRef2 : TestBase
        {
            override protected void Execute()
            {
                string    pathName = "//msg.3/u:89899/" + Guid.NewGuid().ToString();
                uint    title = (uint) new Random().Next();
                // write a blob with 2 references
                uint        FileWithMultiRefLen = 10240;
                byte[]        FileData = new byte[FileWithMultiRefLen];
                new Random().NextBytes(FileData);
                byte[]        FileWithMultiRefHash = new byte[Constants.sizeHash];
                new Random().NextBytes(FileWithMultiRefHash);
                string        []refPath = new string[2]{"",""};
                XRLWriteFile    [] writeReq = new XRLWriteFile[2]{null, null};
                for(int i = 0; i < 2; i++)
                {
                    refPath[i] = pathName = "//msg.3/u:89899/" + Guid.NewGuid().ToString();
                    writeReq[i] = new XRLWriteFile("All",pathName);
                    writeReq[i].uiTitleId = title;
                    writeReq[i].Slot.titleId = title;
                    writeReq[i].blobDataLen = FileWithMultiRefLen;
                    writeReq[i].uiBlobSizeCompressed = FileWithMultiRefLen;
                    writeReq[i].blobData = new byte[FileWithMultiRefLen];
                    FileData.CopyTo(writeReq[i].blobData,0);
                    FileWithMultiRefHash.CopyTo(writeReq[i].blobHash,0);
                    if(!writeReq[i].Execute())
                    {
                        Global.RO.Warn("Write File failed:"+i);
                        return;
                    }
                }

                // remove all references to the file; the file will be deleted
                XRLRemoveFile    removeReq1 = new XRLRemoveFile(refPath[0],title,"ServiceAddr");
                XRLRemoveFile    removeReq2 = new XRLRemoveFile(refPath[1],title,"ServiceAddr");
                if(removeReq1.Execute() && (removeReq2.Execute()))
                {
                    XRLReadFile        readReq = new XRLReadFile(refPath[0]);
                    readReq.Slot.titleId = readReq.uiTitleId = title;
                    if(!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage))&&
                        (readReq.XErr==HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
                        ResultCode=TEST_RESULTS.PASSED;
                }
            }
        }
        /**********************************************************************************
         * Negative Wire Protocol Testing
         *********************************************************************************/
        [TestCase, Description("31658:the titleID in HTTPAuthData is not the one in the removeFile request"), TestCasePriority(2)]
			class NSGAuthInvalidTitleID : NegMsgDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//msg.3/u:89899/" + Guid.NewGuid().ToString();
                uint    titleID = (uint) new Random().Next();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                uint ip = 0;
                ulong    requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
                byte[]    addr = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).Address.GetAddressBytes();
                for(int i = 0; i < addr.Length; i++)
                    ip = (ip << 8) + addr[i];
                HTTPAuthData authData = new HTTPAuthData((ushort) Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int).Port,
                    ip,requestId,0,(titleID+1),(uint)XOService.Storage,0);
                authData.dwTitleVersion = removeReq.uiTitleVersion;
                removeReq.CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" +
                    authData.GetBase64EncodedString() + "\r\n";
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_INVALID_TITLE_ID))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("31659:the titleVersion in HTTPAuthData is not the one in the removeFile request"), TestCasePriority(2)]
			class NSGAuthInvalidTitleVersion : NegMsgDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//msg.3/u:89899/" + Guid.NewGuid().ToString();
                uint    titleID = (uint) new Random().Next();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                uint ip = 0;
                ulong    requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
                byte[]    addr = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).Address.GetAddressBytes();
                for(int i = 0; i < addr.Length; i++)
                    ip = (ip << 8) + addr[i];
                HTTPAuthData authData = new HTTPAuthData((ushort) Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int).Port,
                    ip,requestId,0,titleID,(uint)XOService.Storage,0);
                authData.dwTitleVersion = removeReq.uiTitleVersion+1;
                removeReq.CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" +
                    authData.GetBase64EncodedString() + "\r\n";
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("the serviceID in HTTPAuthData header is not the one in the removeFile request"), TestCasePriority(2)]
			class NSGAuthInvalidServiceID : NegMsgDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//msg.3/u:89899/" + Guid.NewGuid().ToString();
                uint    titleID = (uint) new Random().Next();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                uint ip = 0;
                ulong    requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
                byte[]    addr = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).Address.GetAddressBytes();
                for(int i = 0; i < addr.Length; i++)
                    ip = (ip << 8) + addr[i];
                HTTPAuthData authData = new HTTPAuthData((ushort) Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int).Port,
                    ip,requestId,0,titleID,(uint)XOService.Stats,0);
                authData.dwTitleVersion = removeReq.uiTitleVersion;
                removeReq.CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" +
                    authData.GetBase64EncodedString() + "\r\n";

                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_SERVER_ERROR))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("31660:Call RemoveFile with invalid pathName"), TestCasePriority(2)]
			class NFileNotFound : NegMsgDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//msg.3/u:89899/" + Guid.NewGuid().ToString();
                uint    titleID = (uint) new Random().Next();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass non-removeFile operation"), TestCasePriority(2)]
			class NInvalidOperation : NegMsgDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//msg.3/u:89899/" + Guid.NewGuid().ToString();
                uint    titleID = (uint) new Random().Next();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                removeReq.accessToken.baseAT.operation = (ushort)Constants.Operation.FileEnumerate;
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pathNameLen is greater than the actual pathname"), TestCasePriority(2)]
			class NTruncatePathname : NegMsgDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//msg.3/u:89899/" + Guid.NewGuid().ToString();
                uint    titleID = (uint) new Random().Next();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                removeReq.accessToken.baseAT.ManualArraySize = true;
                removeReq.accessToken.baseAT.pathNameLen +=1;
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pathNameLen is shorter than the actual pathname"), TestCasePriority(2)]
			class NOverflowPathname : NegMsgDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//msg.3/u:89899/" + Guid.NewGuid().ToString();
                uint    titleID = (uint) new Random().Next();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                removeReq.accessToken.baseAT.ManualArraySize = true;
                removeReq.accessToken.baseAT.pathNameLen -=1;
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass NULL for pathName"), TestCasePriority(2)]
			class NNullPathname : NegMsgDFTestBase
        {
            override protected void Execute()
            {
                uint    titleID = (uint) new Random().Next();
                XRLRemoveFile    removeReq = new XRLRemoveFile(null,titleID,"ServiceAddr");
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("token expiration time is before current time"), TestCasePriority(2)]
			class NInvalidTokenExpTime : NegMsgDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//msg.3/u:89899/" + Guid.NewGuid().ToString();
                uint    titleID = (uint) new Random().Next();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                removeReq.accessToken.removeAT.tokenExpirationDate = (long)System.DateTime.UtcNow.AddHours(-1).ToFileTimeUtc();
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }

        // [TestCase, Description("pass removeFile request to stfd port 10140 other than 11140"), TestCasePriority(2)]
			class NDCReq : NegMsgDFTestBase
        {
            public NDCReq()
            {
                Name = "NDCReq";
                Desc = "";
            }
            override protected void Execute()
            {
                string    pathName = "//msg.3/u:89899/" + Guid.NewGuid().ToString();
                uint    titleID = (uint) new Random().Next();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
                removeReq.Server.Port = 10140;

                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\FuncMsgWF.cs ===
using System;
using System.Globalization;
using System.Text;
using System.Net;
using System.IO;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Storage;
using ServerTestFramework.LiveService.Signature;
using xonline.common.config;

namespace XStoreTest
{
	internal abstract class MsgWFTestBase : TestBase
	{
		//	send WriteFile request first; then send readfile;verifies the response
		protected bool WriteFileSendAndVerify(XRLWriteFile WriteFileReq)
		{
			bool fPassed=WriteFileReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage));
			if (!fPassed)
			{
				Global.RO.Warn("Failed to send WriteFile request ");
				return false;
			}

			XRLReadFileResponse	ReadFileResp;
			XRLReadFile			ReadFileReq = new XRLReadFile(WriteFileReq.accessToken.baseAT.pathName);
			ReadFileReq.Slot.titleId = ReadFileReq.uiTitleId = WriteFileReq.uiTitleId;
			ReadFileReq.Slot.titleVersion = ReadFileReq.uiTitleVersion = WriteFileReq.uiTitleVersion;
			if (ReadFileReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out ReadFileResp))
			{
				//?????? need to rewrite according to the new schema
				if ((!ReadFileResp.Compare(WriteFileReq)) || (!WriteFileReq.Verify()))
				{
					Global.RO.Warn("WriteFile request is not set correctly in the db");
					return false;
				}
			}
			else
			{
				Global.RO.Warn("Failed to send ReadFile request");
				return false;
			}
			return true;
		}
	}
	internal abstract class MsgWFNegTestBase : TestBase
	{
		//	send WriteFile request first; then send readfile;verifies the response
		protected bool WriteFileTestNegative(XRLWriteFile WriteFileReq, uint XErr)
		{
			if (WriteFileReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
			{
				Global.RO.Warn("Negative WriteFile request succeed unexpectedly");
				return false;
			}
			if(WriteFileReq.XErr != XErr)
			{
				Global.RO.Warn("Wrong error code returned " + Global.XErrToString(WriteFileReq.XErr));
				return false;
			}
			// now we need to check the file is not written to the DB
			XRLReadFileResponse	ReadFileResp;
			XRLReadFile			ReadFileReq = new XRLReadFile(WriteFileReq.accessToken.baseAT.pathName);
			ReadFileReq.Slot.titleId = ReadFileReq.uiTitleId = WriteFileReq.uiTitleId;
			ReadFileReq.Slot.titleVersion = ReadFileReq.uiTitleVersion = WriteFileReq.uiTitleVersion;
			if (!ReadFileReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out ReadFileResp))
			{
				/*				if((ReadFileReq.XErr != HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND)
									||(ReadFileResp != null))
								{
									Global.RO.Warn("file_not_found error is not returned OR File is being written to DB unexpectedly");
									return false;
								}
								*/
				if(ReadFileResp != null)
				{
					Global.RO.Warn("File is being written to DB unexpectedly");
					return false;
				}
			}
			else
			{
				Global.RO.Warn("ReadFile request succeed with S_OK unexpectedly");
				return false;
			}
			return true;
		}
	}
    [TestGroup, Owner("JKonkle"), TestFrequency("Regression"), TestCasePriority(1)]
	public class FuncMsgWF : TestNode
	{
		/***********************************************************************
		 * Wire Protocol Testing
		 * *********************************************************************/
		[TestCase, Description("check x-delay in the http response")]
		class PThrottling : MsgWFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.attributes = new byte[100];
				new Random().NextBytes(req.attributes);
				req.attributesLen = (ushort)req.attributes.Length;

				int Xdelay= 3000;
				Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage,"exec :stfd SetXDelay "+req.uiTitleId.ToString("X")+" writefile "+Xdelay);

				if(WriteFileSendAndVerify(req) &&
					(req.XDelay == Xdelay))
					ResultCode=TEST_RESULTS.PASSED;

				Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage,"exec :stfd ReloadThrottleConfig");
			}
		}
		[TestCase, Description("the titleID in the request is not the acutal logged on title")]
			class PFamilyTitleID : MsgWFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.Slot.titleId = req.uiTitleId+1;
				req.Slot.altTitleId1 = req.uiTitleId;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write a file with all valid parameters including attributes")]
			class PNormalCase : MsgWFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.attributes = new byte[100];
				new Random().NextBytes(req.attributes);
				req.attributesLen = (ushort)req.attributes.Length;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write a 1k file")]
			class PSmallFileSize : MsgWFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.blobData = new byte[1024];
				new Random().NextBytes(req.blobData);
				req.blobDataLen = req.uiBlobSizeCompressed = (uint)req.blobData.Length;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write a 32k file")]
			class PMediumFileSize : MsgWFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.blobData = new byte[1024*32];
				new Random().NextBytes(req.blobData);
				req.blobDataLen = req.uiBlobSizeCompressed = (uint)req.blobData.Length;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write a 63KB file")]
			class PLargeFileSize : MsgWFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.blobData = new byte[63*1024];
				new Random().NextBytes(req.blobData);
				req.blobDataLen = req.uiBlobSizeCompressed = (uint)req.blobData.Length;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write a file with title ID set to max value")]
			class PMaxTitleID : MsgWFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.uiTitleId = req.Slot.titleId = 0xffffffff;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write a file with title ID set to min value")]
			class PMinTitleID : MsgWFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.uiTitleId = req.Slot.titleId = 1;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write a file with titleVersion set to max value")]
			class PMaxTitleVersion : MsgWFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.uiTitleVersion = 0xffffffff;
				req.Slot.titleVersion = 0xffffffff;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write a file with titleVersion set to min value")]
			class PMinTitleVersion : MsgWFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.uiTitleVersion = 0;
				req.Slot.titleVersion = 0;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write a file with countryID set to max value")]
			class PMaxUserCountryID : MsgWFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ff/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.bUserCountryId = 0xff;
				req.Slot.userFlag0 = (uint)0xff<<8;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write a file with countryID set to min value")]
			class PMinUserCountryID : MsgWFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ff/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.bUserCountryId = 0;
				req.Slot.userFlag0 = 0;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write a max size file")]
			class PBlobDataMaxSize : MsgWFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ff/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.blobData = new byte[64*1024];
				for(int i = 0; i < req.blobData.Length; i++)
					req.blobData[i] = (byte)(i%256);
				req.blobDataLen = req.uiBlobSizeCompressed = (uint)req.blobData.Length;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass attributes with 256 byte")]
			class PMaxAttributeSize : MsgWFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ff/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				uint			attribLen = Constants.maxSizeAttributes;
				req.attributes = new byte[attribLen];
				for(int i = 0; i < req.attributes.Length; i++)
					req.attributes[i] = 1;
				req.attributesLen = (ushort)req.attributes.Length;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass 0 attributeslen")]
			class PMinAttributeSize : MsgWFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ff/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.attributes = null;
				req.attributesLen = 0;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass max value for UserPUID in the accessToken")]
			class PAccessTokenMaxUserPUID : MsgWFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ff/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.accessToken.baseAT.userPuid = 0xffffffffffffffff;
				req.Slot.userPuid0 = 	req.accessToken.baseAT.userPuid;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass min value for UserPUID in the accessToken")]
			class PAccessTokenMinUserPUID : MsgWFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.accessToken.baseAT.userPuid = 1;
				req.Slot.userPuid0 = 1;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass max value for xboxPUID in the accessToken")]
			class PAccessTokenMaxXBoxPUID : MsgWFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.accessToken.baseAT.xboxPuid = 0xffffffffffffffff;
				req.Slot.machinePuid = 0xffffffffffffffff;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass min value for xboxPUID in the accessToken")]
			class PAccessTokenMinXBoxPUID : MsgWFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.accessToken.baseAT.xboxPuid = 1;
				req.Slot.machinePuid = 1;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass 0 fileExpirationTime in the accessToken")]
			class PAccessTokenZeroFileExpTime : MsgWFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.accessToken.writeAT.fileExpirationDate = 0;
				req.accessToken.writeAT.tokenExpirationDate = System.DateTime.UtcNow.AddHours(1).ToFileTimeUtc();

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass 0 AccessTokenExpirationTime in the accessToken")]
			class PAccessTokenZeroATExpTime : MsgWFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.accessToken.writeAT.tokenExpirationDate = 0;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass 255 unicode chars pathNameLen in the accessToken")]
			class PAccessTokenMaxPathnameSize : MsgWFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				StringBuilder	pathBuilder = new StringBuilder(url);
				if(url.Length < 255)
					pathBuilder.Append('z',255-url.Length);
				XRLWriteFile	req = new XRLWriteFile("All",pathBuilder.ToString());

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass non-existent compression type"), TestCasePriority(2)]
		class NInvalidCompressionType : MsgWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.bCompressionType = (byte)Constants.CompressionType.Invalid;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass non-existent content type"), TestCasePriority(2)]
			class NInvalidContentType : MsgWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.uiContentType = (uint)Constants.ContentType.Invalid;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass NULL for blob hash"), TestCasePriority(2)]
			class NNullBlobHash : MsgWFNegTestBase
		{
			public NNullBlobHash()
			{
				Name = "NNullBlobHash";
				Desc = "pass NULL for blob hash";
			}
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.ManualArraySize = true;
				req.blobHash = null;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_FILE_IS_TOO_BIG))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass <20 byte for blob hash"), TestCasePriority(2)]
			class NInvalidBlobHash1 : MsgWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.ManualArraySize = true;
				req.blobHash = new byte[Constants.sizeHash - 1];
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_FILE_IS_TOO_BIG))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        //		[TestCase, Description("34897:pass >20 byte for blob hash"), TestCasePriority(2)]
//			class NInvalidBlobHash2 : MsgWFNegTestBase
//		{
//			public NInvalidBlobHash2()
//			{
//				Name = "NInvalidBlobHash2";
//				Desc = "pass >20 byte for blob hash";
//			}
//			override protected void Execute()
//			{
//				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
//				XRLWriteFile	req = new XRLWriteFile("All",url);
//				req.ManualArraySize = true;
//				req.blobHash = new byte[Constants.sizeHash + 1];
//				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
//					ResultCode=TEST_RESULTS.PASSED;
//			}
//		}
        [TestCase, Description("uncompressed size is smaller than compressed size"), TestCasePriority(2)]
			class NWrongCompressedSize : MsgWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.uiBlobSizeCompressed = req.blobDataLen + 1;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass non-null for Attributes, but AttribLen is zero"), TestCasePriority(2)]
			class NMismatchedAttributes : MsgWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.ManualArraySize = true;
				req.attributesLen = 0;
				req.attributes = new byte[16];
				for(int i = 0; i < 16; i++)
					req.attributes[i] = (byte)i;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("Attributes size is greater than the actual size"), TestCasePriority(2)]
			class NTruncateAttributes : MsgWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.ManualArraySize = true;
				req.attributesLen +=1;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("Attributes size is smaller than the actual size"), TestCasePriority(2)]
			class NOverflowAttributes1 : MsgWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.ManualArraySize = true;
				req.attributes = new Byte[16];
				req.attributesLen = 15;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("Attributes is null but attribLen is nonzero"), TestCasePriority(2)]
			class NOverflowAttributes2 : MsgWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.ManualArraySize = true;
				req.attributes = null;
				req.attributesLen = 16;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("Attributes is null but attribLen is greater than maxallowed(256)"), TestCasePriority(2)]
			class NOverflowAttributes3 : MsgWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.ManualArraySize = true;
				req.attributes = null;
				req.attributesLen = 257;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("Attributes is larger than max allowed256bytes"), TestCasePriority(2)]
			class NOverflowAttributes4 : MsgWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				ushort			attribLen = Constants.maxSizeAttributes + 1;
				req.attributes = new Byte[attribLen];
				req.attributesLen = attribLen;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass special attributeLen = 0xffff"), TestCasePriority(2)]
			class NOverflowAttributes5 : MsgWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.attributes = new Byte[0xffff];
				req.attributesLen = 0xffff;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass null for AccessToken"), TestCasePriority(2)]
			class NNullAccessToken : MsgWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	WriteFileReq = new XRLWriteFile("All",url);
				WriteFileReq.ManualArraySize = true;
				WriteFileReq.accessToken = null;
				if (!WriteFileReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
				{
					if((WriteFileReq.XErr != HResult.XONLINE_E_STORAGE_INVALID_REQUEST)&&
						(WriteFileReq.XErr != HResult.XONLINE_E_SERVER_ERROR))
						Global.RO.Warn("Wrong error code returned " + Global.XErrToString(WriteFileReq.XErr));
					else
						ResultCode=TEST_RESULTS.PASSED;
				}
				else
					Global.RO.Warn("Negative WriteFile request succeed unexpectedly");
			}
		}
        [TestCase, Description("pass null for Blob data, but blobLen is non-zero"), TestCasePriority(2)]
			class NNullBlobData : MsgWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.ManualArraySize = true;
				req.blobData = null;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass 0 for uncompressed blob size and null blobdata")]
			class PEmptyFile : MsgWFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.blobDataLen = req.uiBlobSizeCompressed = 0;
				req.blobData = null;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("try to write a file that is bigger than max allowed"), TestCasePriority(2)]
			class NBiggerThanMaxFile : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.blobData = new byte[65536+1];
				new Random().NextBytes(req.blobData);
				req.blobDataLen = req.uiBlobSizeCompressed = (uint)req.blobData.Length;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_FILE_IS_TOO_BIG))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass 0 for compressed blob size, but non-null blobdata"), TestCasePriority(2)]
			class NEmptyCompressedFile : MsgWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.uiBlobSizeCompressed = 0;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("uncompressed blob size is greater than the actual file size"), TestCasePriority(2)]
			class NTruncateFile : MsgWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.ManualArraySize = true;
				req.blobDataLen += 1;
				req.uiBlobSizeCompressed +=1;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("uncompressed blob size is smaller than the actual file size"), TestCasePriority(2)]
			class NOverflowFile : MsgWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.ManualArraySize = true;
				req.blobDataLen -= 1;
				req.uiBlobSizeCompressed -=1;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("Expiration date is before the current time"), TestCasePriority(2)]
			class NAccessTokenInvalidExpTime1 : MsgWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.accessToken.writeAT.fileExpirationDate = System.DateTime.UtcNow.AddDays(-1).ToFileTimeUtc();

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("33962:pass 0 for userPUID in access Token"), TestCasePriority(2)]
			class NAccessTokenZeroUserPUID : MsgWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.accessToken.baseAT.userPuid = 0;
				req.Slot.userPuid0 = 0;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_SERVER_ERROR))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass an access Token that is greater than 255+baseAT"), TestCasePriority(2)]
			class NAccessTokenOverflowAT : MsgWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				StringBuilder	pathName = new StringBuilder(url);
				int		i = 0, numCharToAdd = 256 - url.Length;
				while(i < numCharToAdd)
				{
					pathName.Append('a');
					i++;
				}
				XRLWriteFile	req = new XRLWriteFile("All",pathName.ToString());

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		// This should be a positive case because storage shouldn't check signature for msg storage
		// but since 33961 is fixed, this is a neg
        [TestCase, Description("Access Token signature is invalid"), TestCasePriority(2)]
			class NAccessTokenInvalidSig : TestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.accessToken.writeAT.ManualArraySize = true;
				req.accessToken.writeAT.signature = new byte[Constants.sizeSignature];
				req.accessToken.writeAT.signatureLen = (ushort)Constants.sizeSignature;
				new Random().NextBytes(req.accessToken.writeAT.signature);
				if(!req.Execute() && (req.XErr == HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("Access Token version is invalid"), TestCasePriority(2)]
			class NAccessTokenInvalidTokenVersion : MsgWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.accessToken.baseAT.version = Constants.accessTokenVersion + 1;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("Operation in AT is non-write"), TestCasePriority(2)]
			class NAccessTokenMismatchedOperation : MsgWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.accessToken.baseAT.operation = (ushort)Constants.Operation.FileRead;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}

		// bug 29366
		// STFD: sometimes stfd won't return error when there is garbage data appended
		// at the end of writeFile requests
		// XRLScan: S_False returned
		//		class NGarbageData : MsgWFNegTestBase
		//		{
		//			public NGarbageData()
		//			{
		//				Name = "NGarbageData";
		//				Desc = "attach garge data at the end of requests";
		//			}
		//			override protected void Execute()
		//			{
		//				XRLWriteFile	req = new XRLWriteFile("All",url);
		//				req.ManualArraySize = true;
		//				int			maxFileSize = (int)req.accessToken.writeAT.maxFileSize;
		//				req.blobDataLen = req.uiBlobSizeCompressed = (uint)maxFileSize;
		//				req.blobData = new byte[maxFileSize + 77381];
		//				for (int i = maxFileSize; i < maxFileSize + 77381; i++)
		//					req.blobData[i] = 0;
		//
		//				if(WriteFileTestNegative(req,HResult.XONLINE_E_SERVER_ERROR))
		//					ResultCode=TEST_RESULTS.PASSED;
		//			}
		//		}

		// This will be caught by xrlscan.ini
        [TestCase, Description("the actual file size is greater than the dwMaxFileSize in AT"), TestCasePriority(2)]
			class NAccessTokenOverflowFileData1 : TestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				uint			maxFileSize = req.accessToken.writeAT.maxFileSize;
				req.blobData = new byte[maxFileSize + 1];
				for (int i = 0; i < maxFileSize + 1; i++)
					req.blobData[i] = (byte)i;
				req.blobDataLen = maxFileSize + 1;
				req.uiBlobSizeCompressed = maxFileSize + 1;

				// 404 returned back to client
				if(!req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("ticket expiration time is greater than file expiration time"), TestCasePriority(2)]
			class NAccessTokenInvalidExpTime2 : MsgWFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.accessToken.writeAT.fileExpirationDate = req.accessToken.writeAT.tokenExpirationDate - 100000;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the pathnameLen is greater than the actual size"), TestCasePriority(2)]
			class NAccessTokenTruncatePathname : MsgWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.accessToken.baseAT.ManualArraySize = true;
				req.accessToken.baseAT.pathNameLen += 1;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the pathnameLen is less than the actual size"), TestCasePriority(2)]
			class NAccessTokenOverflowPathname : MsgWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.accessToken.baseAT.ManualArraySize = true;
				req.accessToken.baseAT.pathNameLen -= 1;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST)||
					WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the flags in AT is non-zero"), TestCasePriority(2)]
			class NAccessTokenInvalidFlags : MsgWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.accessToken.baseAT.flags = 1;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		/***********************************************************************
		* Pathname Testing
		* *********************************************************************/
		[TestCase, Description("pass max value for userPUID in <Unique-ID-part>")]
			class PPathnameMaxUserPUID : MsgWFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:ffffffffffffffff/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass min value for userPUID in <Unique-ID-part>")]
			class PPathnameMinUserPUID : MsgWFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:1/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass a pathname that one null char in the middle of <Domain-part>"), TestCasePriority(2)]
			class NPathnameBadString1 : MsgWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				string	pathName = url, newPath;
				newPath = pathName.Insert(3,'\0'.ToString());
				XRLWriteFile	writeReq = new XRLWriteFile("All",newPath);

				//TODO: need to return xonline_e_storage_domain_not_supported
				if(WriteFileTestNegative(writeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass a pathname that two null char in the middle of <Domain-part>"), TestCasePriority(2)]
			class NPathnameBadString2 : MsgWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				string	pathName = url, newPath, temp;
				temp = '\0'.ToString() + '\0'.ToString();
				newPath = pathName.Insert(3,temp);

				XRLWriteFile	writeReq = new XRLWriteFile("All",newPath);

				//TODO: need to return xonline_e_storage_domain_not_supported
				if(WriteFileTestNegative(writeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass one nullchar in the middle of <userPUID>"), TestCasePriority(2)]
			class NPathnameBadString3 : MsgWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				string	pathName = url, newPath;
				newPath = pathName.Insert(11,'\0'.ToString());
				XRLWriteFile	writeReq = new XRLWriteFile("All",newPath);

				if(WriteFileTestNegative(writeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass one nullchar in the middle of <pathpart>"), TestCasePriority(2)]
			class NPathnameBadString4 : MsgWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				string	pathName = url, newPath;
				newPath = pathName.Insert(15,'\0'.ToString());
				XRLWriteFile	writeReq = new XRLWriteFile("All",newPath);

				if(WriteFileTestNegative(writeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass one nullchar at the end of <pathpart>"), TestCasePriority(2)]
			class NPathnameBadString5 : MsgWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString()+'\0';
				XRLWriteFile	writeReq = new XRLWriteFile("All",url);

				if(WriteFileTestNegative(writeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}

        [TestCase, Description("<Domain-part> is missing in pathname"), TestCasePriority(2)]
		class NPathnameNoDomainPart : MsgWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass a pathname that has no ID namespace (u)"), TestCasePriority(2)]
			class NPathnameNoIDNameSpace : MsgWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass a pathname that has no userPUID following u"), TestCasePriority(2)]
			class NPathnameNoUserPUID : MsgWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass a pathname that userPUID is invalid (greater than ulonglong)"), TestCasePriority(2)]
			class NPathnameOverflowUserPUID : MsgWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:ffffffffffffffff1/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass 0 as userPUID in <Domain-part>")]
			class PPathnameInvalidUserPUID : MsgWFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:0/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass invalid ID-Namespace"), TestCasePriority(2)]
			class NPathnameNonExistIDNameSpace : MsgWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/x:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass a pathname that is greater than 255"), TestCasePriority(2)]
			class NPathnameOverflowPathname : MsgWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				StringBuilder	pathName = new StringBuilder(url);
				int		i = 0, numCharToAdd = 256 - url.Length;
				while(i < numCharToAdd)
					pathName.Append(i++);
				XRLWriteFile	req = new XRLWriteFile("All",pathName.ToString());

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass a pathname that has special chars"), TestCasePriority(2)]
			class NPathnameWrongCharSet : MsgWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				StringBuilder	pathName = new StringBuilder(url);
				//Bug 27831: domain and optional domain specified: A-Za-z0-9_
				// pathname allows anything except control chars('\0\, control characters, etc)
				char i = '\0';
				pathName.Append(i);
				XRLWriteFile	req = new XRLWriteFile("All",pathName.ToString());

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		/*****************************************************************
		 *  Other stats w/attachments Testing
		 *****************************************************************/
        [TestCase, Description("try to update an existing file"), TestCasePriority(2)]
		class NUpdateExistingFile : TestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req1 = new XRLWriteFile("All",url), req2 = new XRLWriteFile("All",url);

				req2.uiTitleId = req1.uiTitleId;
				req2.bUserCountryId = req1.bUserCountryId;
				req2.uiTitleVersion = req1.uiTitleVersion;
				ulong userPUID = req2.accessToken.baseAT.userPuid = req1.accessToken.baseAT.userPuid;

				// make sure the two blobs are different
				req2.blobHash[1] = (byte)(req1.blobHash[1]+1);

				req2.Slot.titleId = req2.uiTitleId;
				req2.Slot.titleVersion = req2.uiTitleVersion;
				req2.Slot.userPuid0 = userPUID;
				req2.Slot.userFlag0 = (uint)req2.bUserCountryId <<8;

				if(req1.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
				{
					if(!req2.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage))&&
						(req2.XErr == HResult.XONLINE_E_STORAGE_FILE_ALREADY_EXISTS))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("data blob are identical,userPUID are the same so mapped to same webstore partition")]
			class PSameFileUploadTwice : MsgWFTestBase
		{
			override protected void Execute()
			{
				string url1= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				string url2= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req1 = new XRLWriteFile("All",url1), req2 = new XRLWriteFile("All",url2);

				req2.blobDataLen = req1.blobDataLen;
				req2.uiBlobSizeCompressed = req1.uiBlobSizeCompressed;
				for(int i = 0; i < req1.blobDataLen; i++)
					req2.blobData[i] = req1.blobData[i];

				for(int i = 0; i < Constants.sizeHash; i++)
					req2.blobHash[i] = req1.blobHash[i];

				if((WriteFileSendAndVerify(req1)) && (WriteFileSendAndVerify(req2)))
				{
					// do other  additional check
					if(req1.CheckRefCount(req2,2, true))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("same fileSize and hash, but blob are different")]
			class PSameHashDiffrentFileContent : MsgWFTestBase
		{
			override protected void Execute()
			{
				string url1= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				string url2= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req1 = new XRLWriteFile("All",url1), req2 = new XRLWriteFile("All",url2);

				req2.blobDataLen = req1.blobDataLen;
				req2.uiBlobSizeCompressed = req1.uiBlobSizeCompressed;

				// reenforce the two files to have different contents
				req2.blobData[9] = (byte)((int)req1.blobData[9]+ 1);

				for(int i = 0; i < Constants.sizeHash; i++)
					req2.blobHash[i] = req1.blobHash[i];

				if((WriteFileSendAndVerify(req1)) && (WriteFileSendAndVerify(req2)))
				{
					// do other additional check
					if(req1.CheckRefCount(req2,1,false))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		// This is how webstore repartition works; there will be two rows
		// added in both t_files and t_blobs
		[TestCase, Description("data blob are identical, but different userPUID and xrl for two writeFile requests")]
			class PSameFileUploadTwiceByDifferentUser : MsgWFTestBase
		{
			override protected void Execute()
			{
				string url1= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				string url2= "//msg.ab/u:89899/" + Guid.NewGuid().ToString();
				XRLWriteFile	req1 = new XRLWriteFile("All",url1), req2 = new XRLWriteFile("All",url2);

				req2.blobDataLen = req1.blobDataLen;
				req2.uiBlobSizeCompressed = req1.uiBlobSizeCompressed;
				for(int i = 0; i < req1.blobDataLen; i++)
					req2.blobData[i] = req1.blobData[i];
				for(int i = 0; i < Constants.sizeHash; i++)
					req2.blobHash[i] = req1.blobHash[i];

				if((WriteFileSendAndVerify(req1)) && (WriteFileSendAndVerify(req2)))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Multiple threads write a file simultaneously")]
			class PMultiThreadsWriteFile : MsgWFTestBase
		{
			override protected void Execute()
			{
				Thread [] threadArray = new Thread[10];
				for(int i = 0; i < 10; i++)
				{
					threadArray[i] = ThreadMaker.CreateThread(writeFileTS);
					threadArray[i].Name = i.ToString();
					threadArray[i].Start();
				}
				// the main thread is waiting for all threads to exit or timeout
				foreach (Thread t in threadArray)
					t.Join(10000);
				if(FailedReqs == 0)
					ResultCode=TEST_RESULTS.PASSED;
			}
			private void writeFileTS()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("All",url);
				if(!WriteFileSendAndVerify(writeReq))
				{
					Global.RO.Warn(Thread.CurrentThread.Name+"writeFileTS: write file request/verify failed");
					Interlocked.Increment(ref FailedReqs);
				}
			}
			private	int FailedReqs = 0;
		}
		[TestCase, Description("write file 50 times")]
			class PWriteFileMultiTimes : MsgWFTestBase
		{
			override protected void Execute()
			{
				uint			uiFailedReq = 0;
				for(int i = 0; i < 50; i++)
				{
					string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
					XRLWriteFile	writeReq = new XRLWriteFile("All",url);
					if(!WriteFileSendAndVerify(writeReq))
						uiFailedReq++;
				}
				if(uiFailedReq == 0)
					ResultCode=TEST_RESULTS.PASSED;
				else
					Global.RO.Warn("It failed " + uiFailedReq.ToString() + " times");
			}
		}

		/***********************************************************************
		* SG Auth Data Testing
		* *********************************************************************/
        [TestCase, Description("the userPUID in SGAuth response is not_found user"), TestCasePriority(2)]
			class NSGAuthNotFoundUser : MsgWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.Slot.UserExists = 0;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_SERVER_ERROR))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the userPUID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidUser : MsgWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.Slot.userPuid0++;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the TitleID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidTitleID : MsgWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.Slot.titleId++;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_INVALID_TITLE_ID))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the XBoxPUID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidXBoxPUID : MsgWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.Slot.machinePuid++;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the TitleVersion in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidTitleVersion : MsgWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.Slot.titleVersion++;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the CountryID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidCountryID : MsgWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("All",url);
				req.Slot.userFlag0 = (uint)((req.Slot.userFlag0>>8+1)<<8);

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\FuncMsgRF.cs ===
using System;
using System.Text;
using System.IO;
using System.Net;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Storage;
using xonline.common.config;

namespace XStoreTest
{
	internal abstract class NegMsgRFTestBase : TestBase
	{
		//	send readFile requests, then check the error code
		protected bool ReadFileTestNegative(XRLReadFile ReadFileReq, uint XErr)
		{
			XRLReadFileResponse	ReadFileResp;
			if (ReadFileReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out ReadFileResp))
			{
				Global.RO.Warn("Negative ReadFile request succeed unexpectedly");
				return false;
			}
			if((ReadFileReq.XErr != XErr) || (ReadFileResp != null))
			{
				Global.RO.Warn("Wrong error code " + Global.XErrToString(ReadFileReq.XErr) +" returned or ReadFileResp is not null");
				return false;
			}
			return true;
		}
	}
	/// <summary>
	/// Summary description for FuncMsgRF.
	/// </summary>
    [TestGroup, Owner("JKonkle"), TestFrequency("Regression"), TestCasePriority(1)]
	public class FuncMsgRF : TestNode
	{
		/**********************************************************************
		 * Wire Protocol Testing Cases
		 **********************************************************************/
		[TestCase, Description("Check X-Delay in the http response")]
			class PThrottling : TestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("All",url);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					int Xdelay= 3000;
					Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage,"exec :stfd SetXDelay "+readReq.uiTitleId.ToString("X")+" readfile "+Xdelay);

					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp)&&
						(readReq.XDelay == Xdelay))
						ResultCode=TEST_RESULTS.PASSED;

					Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage,"exec :stfd ReloadThrottleConfig");

				}
			}
		}
		[TestCase, Description("the titleID in the request is not the acutal logged on title")]
			class PFamilyTitleID : TestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("All",url);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.altTitleId1 = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleId = readReq.uiTitleId + 1;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("no readFile cache for message storage")]
			class PNoReadCache : TestBase
		{
			override protected void Execute()
			{
				string pathName= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("All",pathName);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp, readResp2;
					XRLReadFile		readReq = new XRLReadFile(pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
					{
						// the file now is in the cache;
						// remove the actual file, then read the file again
						XRLRemoveFile	removeReq = new XRLRemoveFile(pathName,writeReq.uiTitleId,"ServiceAddr");
						if(removeReq.Execute())
						{
							XRLReadFile		readReq2 = new XRLReadFile(pathName);
							readReq2.Slot.titleId = readReq2.uiTitleId = writeReq.uiTitleId;
							readReq2.Slot.titleVersion = readReq2.uiTitleVersion;
							if(!readReq2.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out readResp2) &&
								(readReq2.XErr == HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
								ResultCode=TEST_RESULTS.PASSED;
						}
					}
				}
			}
		}
		[TestCase, Description("33960:Write a file first; then read the file with ifModifiedSince>actualModifiedTime")]
			class PModifiedSince : TestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("All",url);

				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;
					readReq.lIfModifiedSinceDate = (long)System.DateTime.UtcNow.AddHours(2).ToFileTimeUtc();
					if(!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp)&&
						(readReq.XErr == HResult.XONLINE_S_STORAGE_FILE_NOT_MODIFIED) && (readResp == null))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("34231:Read message from a different title other than creator's")]
		class PFromDifferentTitle : TestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("All",url);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId + 1;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion + 1;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("Read file from a different titleVersion other than creator's")]
			class PFromDifferentTitleVersion : TestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("All",url);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion + 1;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("Write a file first; the request this file with userCountryID set to max")]
			class PMaxUserCountryID : TestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("All",url);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.bUserCountryId = 0xff;
					readReq.Slot.userFlag0 = 0xff<<8;
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("Write a file first; the request this file with userCountryID set to min")]
			class PMinUserCountryID : TestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("All",url);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.userFlag0 = readReq.bUserCountryId = 0;
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("Write a file first; the request this file with userPUID set to max")]
			class PMaxUserPUID : TestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("All",url);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					readReq.Slot.userPuid0 = readReq.accessToken.baseAT.userPuid = 0xffffffffffffffff;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("Write a file first; the request this file with userPUID set to min")]
			class PMinUserPUID : TestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("All",url);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					readReq.Slot.userPuid0 = readReq.accessToken.baseAT.userPuid = 1;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("Write a file first; the request this file with machine PUID set to max")]
			class PMaxXBoxPUID : TestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("All",url);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					readReq.Slot.machinePuid = readReq.accessToken.baseAT.xboxPuid = 0xffffffffffffffff;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("Write a file first; the request this file with machine PUID set to min")]
			class PMinXBoxPUID : TestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("All",url);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					readReq.Slot.machinePuid = readReq.accessToken.baseAT.xboxPuid = 1;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("write a valid file first, then request with mismatched TitleID")]
			class PMismatchedTitleID : TestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("All",url);
				if(writeReq.Execute())
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId + 1;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					XRLReadFileResponse		Response;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out Response))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("write a valid file first, then request with mismatched TitleVersion")]
			class PMismatchedTitleVersion : TestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("All",url);
				if(writeReq.Execute())
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion= writeReq.uiTitleVersion + 1;
					XRLReadFileResponse		Response;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out Response))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("pass null for AccessToken"), TestCasePriority(2)]
			class NAccessTokenNullAT : NegMsgRFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLReadFile		readReq = new XRLReadFile(url);
				readReq.accessToken = null;

				if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode = TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass 0 for userPUID for AccessToken"), TestCasePriority(2)]
			class NAccessTokenZeroUserPUID : NegMsgRFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLReadFile		readReq = new XRLReadFile(url);
				readReq.Slot.userPuid0 = readReq.accessToken.baseAT.userPuid = 0;

				if(ReadFileTestNegative(readReq,HResult.XONLINE_E_SERVER_ERROR))
					ResultCode = TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass non-readfile operation in the AT"), TestCasePriority(2)]
			class NAccessTokenMismatchedOp : NegMsgRFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLReadFile		readReq = new XRLReadFile(url);
				readReq.accessToken.baseAT.operation = (ushort)Constants.Operation.FileWrite;

				if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode = TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("write a file first, then request it with pathnameLen is greater than the actual pathname"), TestCasePriority(2)]
			class NAccessTokenTruncatePathname : NegMsgRFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("All",url);
				if(writeReq.Execute())
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					readReq.accessToken.baseAT.ManualArraySize = true;
					readReq.accessToken.baseAT.pathNameLen += 1;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a file first, then request it with pathnameLen is less than the actual pathname"), TestCasePriority(2)]
			class NAccessTokenOverflowPathname : NegMsgRFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("All",url);
				if(writeReq.Execute())
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					readReq.accessToken.baseAT.ManualArraySize = true;
					readReq.accessToken.baseAT.pathNameLen -= 1;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("pass null for pathname and pathnameLen is 0"), TestCasePriority(2)]
			class NAccessTokenNullPathname : NegMsgRFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLReadFile		readReq = new XRLReadFile(url);
				readReq.accessToken.baseAT.pathName = null;
				readReq.accessToken.baseAT.pathNameLen = 0;

				if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode = TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("AccessToken size is greater than 255+baseAT"), TestCasePriority(2)]
			class NAccessTokenOverflowAT : NegMsgRFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLReadFile		req = new XRLReadFile(url);
				StringBuilder	pathName = new StringBuilder(req.accessToken.baseAT.pathName);
				int		numUniCharToAdd = 256 - req.accessToken.baseAT.pathNameLen;
				string			temp = new string('a',numUniCharToAdd);
				pathName.Append(temp);
				req.accessToken.baseAT.pathNameLen = 256;//actual pathName length is 256
				req.accessToken.baseAT.pathName = pathName.ToString();

				if(ReadFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode = TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("write file first, then request it with non-null signature but sigSize is zero"), TestCasePriority(2)]
			class NAccessTokenNonNullSignature : NegMsgRFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("All",url);
				if(writeReq.Execute())
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.accessToken.readAT.ManualArraySize = true;
					readReq.accessToken.readAT.signatureLen = 0;
					readReq.accessToken.readAT.signature = new byte[Constants.sizeSignature];
					for(int i = 0; i < Constants.sizeSignature; i++)
						readReq.accessToken.readAT.signature[i] = 0;
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write file first, then request it with token exp is before current time"), TestCasePriority(2)]
			class NAccessTokenWrongATExpTime : NegMsgRFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("All",url);
				if(writeReq.Execute())
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.accessToken.readAT.tokenExpirationDate = System.DateTime.UtcNow.AddDays(-1).ToFileTimeUtc();
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write file first, then request it with non-zero flags"), TestCasePriority(2)]
			class NAccessTokenWrongFlags : NegMsgRFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("All",url);
				if(writeReq.Execute())
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.accessToken.baseAT.flags = 1;
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
		/**********************************************************************
		 * Pathname Testing Cases
		 **********************************************************************/
        [TestCase, Description("write a valid file first, then request it with one null char in the middle of <Domain-part>"), TestCasePriority(2)]
			class NPathnameBadString1 : NegMsgRFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("All",url);
				if(writeReq.Execute())
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					// //stat.s/u:....
					newPath = pathName.Insert(4,'\0'.ToString());

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it with two null char in the middle of <domain-part>"), TestCasePriority(2)]
			class NPathnameBadString2 : NegMsgRFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("All",url);
				if(writeReq.Execute())
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath, temp;
					temp = '\0'.ToString() + '\0'.ToString();
					newPath = pathName.Insert(4,temp);	// //stat..s/u:....

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it with one nullchar in the middle of <userPUID>"), TestCasePriority(2)]
			class NPathnameBadString3 : NegMsgRFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("All",url);
				if(writeReq.Execute())
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					newPath = pathName.Insert(14,'\0'.ToString());

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it with one nullchar in the middle of <pathpart>"), TestCasePriority(2)]
			class NPathnameBadString4 : NegMsgRFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("All",url);
				if(writeReq.Execute())
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					newPath = pathName.Insert(26,'\0'.ToString());

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it with one nullchar at the end of <pathpart>"), TestCasePriority(2)]
			class NPathnameBadString5 : NegMsgRFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("All",url);
				if(writeReq.Execute())
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					newPath = pathName + '\0'.ToString();

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it by passing a nonexisitent <path-part>(vc_name)"), TestCasePriority(2)]
			class NPathnameNonExistFile1 : NegMsgRFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("All",url);
				if(writeReq.Execute())
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					int		guidStartPos = pathName.LastIndexOf('/');
					newPath = pathName.Substring(0,guidStartPos)+ "/" + Guid.NewGuid().ToString();

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it by passing wrong owner PUID"), TestCasePriority(2)]
			class NPathnameNonExistFile2 : NegMsgRFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("All",url);
				if(writeReq.Execute())
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					int		pos = pathName.IndexOf("u:"), guidStart = pathName.LastIndexOf('/');
					newPath = pathName.Substring(0,pos)+ "u:393939" + pathName.Substring(guidStart);

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it by passing wrong IDNameSpace"), TestCasePriority(2)]
		class NPathnameNonExistFile3 : NegMsgRFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("All",url);
				if(writeReq.Execute())
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					newPath = pathName.Replace("u:","x:");

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it by passing wrong Domain"), TestCasePriority(2)]
			class NPathnameNonExistFile4 : NegMsgRFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("All",url);
				if(writeReq.Execute())
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					newPath = pathName.Replace("msg","voice");

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					//TODO: proper error code needed
					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_PATH))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("Write file first, then request it by passing a pathname that has no domain part"), TestCasePriority(2)]
			class NPathnameNoDomainPart : NegMsgRFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("All",url);
				if(writeReq.Execute())
				{
					string path = writeReq.accessToken.baseAT.pathName, newPath, temp;
					temp = path.Substring(path.IndexOf("u:"));
					newPath = "///" + temp;

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					//TODO: need new error code
					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("Write file first, then request it by passing noID namespace"), TestCasePriority(2)]
			class NPathnameNoIDNameSpace : NegMsgRFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("All",url);
				if(writeReq.Execute())
				{
					string path = writeReq.accessToken.baseAT.pathName, newPath;
					newPath = path.Remove(path.IndexOf("u:"),1);

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("Write file first, then request it by passing no userPUID"), TestCasePriority(2)]
			class NPathnameNoUserPUID : NegMsgRFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("All",url);
				if(writeReq.Execute())
				{
					string pathName = writeReq.accessToken.baseAT.pathName, newPath;
					int		pos = pathName.IndexOf("u:"), guidStart = pathName.LastIndexOf('/');
					newPath = pathName.Substring(0,pos)+ "u:" + pathName.Substring(guidStart);

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("Write file first, then request it by passing overflow PUID"), TestCasePriority(2)]
			class NPathnameOverflowUserPUID : NegMsgRFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("All",url);
				if(writeReq.Execute())
				{
					string pathName = writeReq.accessToken.baseAT.pathName, newPath;
					int		pos = pathName.IndexOf("u:"), guidStart = pathName.LastIndexOf('/');
					newPath = pathName.Substring(0,pos)+ "u:" + "ffffffffffffffff1" + pathName.Substring(guidStart);

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        //	[TestCase, Description("Write file first, then request it by passing 0 PUID"), TestCasePriority(2)]
			class NPathnameZeroUserPUID : NegMsgRFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("All",url);
				if(writeReq.Execute())
				{
					string pathName = writeReq.accessToken.baseAT.pathName, newPath;
					int		pos = pathName.IndexOf("u:"), guidStart = pathName.LastIndexOf('/');
					newPath = pathName.Substring(0,pos)+ "u:0" + pathName.Substring(guidStart);

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
            [TestCase, Description("Write file first, then request it by pass wrong charset"), TestCasePriority(2)]
			class NPathnameWrongCharSet : NegMsgRFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("All",url);
				if(writeReq.Execute())
				{
					string path = writeReq.accessToken.baseAT.pathName;
					StringBuilder	pathName = new StringBuilder(path);
					//Bug 27831: domain and optional domain specified: A-Za-z0-9_
					// pathname allows anything except control chars('\0\, control characters, etc)
					char i = '\0';
					pathName.Append(i);

					XRLReadFile		readReq = new XRLReadFile(pathName.ToString());
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
		/***********************************************************************
		* SG Auth Data Testing
		* *********************************************************************/
            [TestCase, Description("the userPUID in SGAuth response is not_found user"), TestCasePriority(2)]
			class NSGAuthNotFoundUser : NegMsgRFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLReadFile	req = new XRLReadFile(url);
				req.Slot.UserExists = 0;

				if(ReadFileTestNegative(req,HResult.XONLINE_E_SERVER_ERROR))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
            [TestCase, Description("the userPUID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidUser : NegMsgRFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLReadFile	req = new XRLReadFile(url);
				req.Slot.userPuid0++;

				if(ReadFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
            [TestCase, Description("the TitleID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidTitleID : NegMsgRFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLReadFile	req = new XRLReadFile(url);
				req.Slot.titleId++;

				if(ReadFileTestNegative(req,HResult.XONLINE_E_INVALID_TITLE_ID))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
            [TestCase, Description("the XBoxPUID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidXBoxPUID : NegMsgRFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLReadFile	req = new XRLReadFile(url);
				req.Slot.machinePuid++;

				if(ReadFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
            [TestCase, Description("the TitleVersion in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidTitleVersion : NegMsgRFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLReadFile	req = new XRLReadFile(url);
				req.Slot.titleVersion++;

				if(ReadFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
            [TestCase, Description("the CountryID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidCountryID : NegMsgRFTestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLReadFile	req = new XRLReadFile(url);
				req.Slot.userFlag0 = (uint)((req.bUserCountryId+1)<<8);

				if(ReadFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}

		/**********************************************************************
		 * Other ReadFile Testing Cases
		 **********************************************************************/
		[TestCase, Description("Multiple threads read same file simultaneously")]
			class PMultiThreadsReadFile : TestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("All",url);
				pathName = writeReq.accessToken.baseAT.pathName;
				uiTitleId = writeReq.uiTitleId;
				uiTitleVersion = writeReq.uiTitleVersion;

				if(writeReq.Execute())
				{
					Thread [] threadArray = new Thread[10];
					for(int i = 0; i < 10; i++)
					{
						threadArray[i] = ThreadMaker.CreateThread(readFileTS);
						threadArray[i].Start();
					}
					// the main thread is waiting for all threads to exit or timeout
					foreach (Thread t in threadArray)
						t.Join(1000);
					if(FailedReqs == 0)
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
			private void readFileTS()
			{
				XRLReadFileResponse	readResp;
				XRLReadFile		readReq = new XRLReadFile(pathName);
				readReq.Slot.titleId = readReq.uiTitleId = uiTitleId;
				readReq.Slot.titleVersion = readReq.uiTitleVersion = uiTitleVersion;

				if(!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out readResp))
				{
					Global.RO.Warn("readFileTS: read file request failed");
					Interlocked.Increment(ref FailedReqs);
				}
			}
			private string	pathName;
			private uint	uiTitleId, uiTitleVersion;
			private int		FailedReqs;
		}
		[TestCase, Description("read file 100 times and check bi_read_count in t_files")]
			// bi_read_count in t_files: number of times the file has been read
			class PReadFileMultiTimes : TestBase
		{
			override protected void Execute()
			{
				string url= "//msg.ab/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("All",url);
				if(writeReq.Execute())
				{
					uint				uiFailedReq = 0;
					for(int i = 0; i < 100; i++)
					{
						XRLReadFileResponse	readResp;
						XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
						readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
						readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
						if(!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
							uiFailedReq++;
					}
					if(uiFailedReq == 0)
						ResultCode=TEST_RESULTS.PASSED;
					// check bi_read_count in t_files
					// Bug26804:since we cache file in the front door, it will be 1 instead of 100
					//					long expectedCount = 1;
					//					XRLWriteFile	dumbReq = new XRLWriteFile();
					//					if(writeReq.CheckReadCount(dumbReq,expectedCount))
					//						if(uiFailedReq == 0)
					//							ResultCode=TEST_RESULTS.PASSED;
					//						else
					//							Global.RO.Warn("bi_read_count is set right, but not all 100 read requests succeeded");
				}
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\FuncReadFileHash.cs ===
using System;
using System.Net;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Storage;
using ServerTestFramework.LiveService.Signature;
using xonline.common.config;
using xonline.common.protocol;

namespace XStoreTest
{
	internal abstract class ReadHashTestBase : TestBase
	{
		//	send WriteFile request first; then send readfile;verifies the response
		protected bool ReadHashAndVerify(bool signAgain,XRLWriteFile WriteFileReq)
		{
			byte []				clientHash = new byte[Constants.sizeHash];
			Array.Copy(WriteFileReq.blobHash,clientHash,Constants.sizeHash);

			if(signAgain)
			{
				byte[] signDataWithExtra = (byte[])WriteFileReq.accessToken;
				int sizeDataToSign = WriteFileReq.accessToken.baseAT.Size() + 20;//20 is fileExp/tokenExp/maxFilesize
				byte[] signData = new byte[sizeDataToSign];
				Array.Copy(signDataWithExtra, 0, signData, 0, sizeDataToSign);
				XSigSignature signature = new XSigSignature();
				signature.Initialize();
				signature._serviceId = (uint)XOService.Stats;
				signature.ComputeSignature(signData);
				WriteFileReq.accessToken.writeAT.signature = (byte [])signature;
			}

			if(WriteFileReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
			{
				XRLReadFileHash				readHashReq = new XRLReadFileHash();
				XRLReadFileHashResponse		resp;
				readHashReq.pathName = WriteFileReq.accessToken.baseAT.pathName;
				readHashReq.pathNameLen = (ushort)readHashReq.pathName.Length;
				if(readHashReq.Execute(readHashReq.Server, out resp))
				{
					// check the returned hash
					if(resp != null)
					{
						for(int i = 0; i < Constants.sizeHash; i++)
							if(clientHash[i] != resp.clientHash[i])
							{
								Global.RO.Warn("clientHash in the reponse is wrong");
								return false;
							}
						return true;
					}
					else
					{
						Global.RO.Warn("ReadFileHash response is null");
						return false;
					}
				}
				else
				{
					Global.RO.Warn("readFileHash Request failed");
					return false;
				}
			}
			else
			{
				Global.RO.Warn("WriteFile Request failed");
				return false;
			}
		}
	}
	internal abstract class NegativeReadHashTestBase : TestBase
	{
		//	send readFileHash requests, then check the error code
		protected bool ReadHashTestNegative(XRLReadFileHash readHashReq, uint XErr)
		{
			XRLReadFileHashResponse	Resp;
			if (readHashReq.Execute(readHashReq.Server,out Resp))
			{
				Global.RO.Warn("Negative readFileHash request succeed unexpectedly");
				return false;
			}
			if((readHashReq.XErr != XErr) || (Resp != null))
			{
				Global.RO.Warn("Wrong error code " + Global.XErrToString(readHashReq.XErr) +" returned or ReadFileHashResp is not null");
				return false;
			}
			return true;
		}
	}
    [TestGroup, Owner("JKonkle"), TestFrequency("Regression"), TestCasePriority(1)]
	public class FuncReadFileHash : TestNode
	{
		[TestCase, Description("send a request with a valid GlobalTitle pathName")]
			class PNormalCase : ReadHashTestBase
		{
			override protected void Execute()
			{
				uint    randomTitleID = (uint)new Random().Next();
				string    sTitleID = randomTitleID.ToString("x");
				string url= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile		writeReq = new XRLWriteFile("ServiceAddr",url);
				if(ReadHashAndVerify(false, writeReq))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("send a request with a valid PerTitlePerUser pathName")]
			class PNormalCase2 : ReadHashTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.attributes = new byte[100];
				new Random().NextBytes(req.attributes);
				req.attributesLen = (ushort)req.attributes.Length;

				if(ReadHashAndVerify(false, req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		/********************************************************************************
		 * The following are negative test cases
		 * ******************************************************************************/
//		[TestCase, Description(""), TestCasePriority(2)] class NNonDatacenterCall : TestBase
//		{
//			public NNonDatacenterCall()
//			{
//				Name = "NNonDatacenterCall";
//				Desc = "27837:send a request to stfd internet port other than dataCenter port";
//			}
//			override protected void Execute()
//			{
//				XRLWriteFile	WriteFileReq = new XRLWriteFile();
//				if(WriteFileReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
//				{
//					XRLReadFileHash				readHashReq = new XRLReadFileHash();
//					XRLReadFileHashResponse		resp;
//					readHashReq.pathName = WriteFileReq.accessToken.baseAT.pathName;
//					readHashReq.pathNameLen = (ushort)readHashReq.pathName.Length;
//					readHashReq.Server = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage);
//					if(!readHashReq.Execute(readHashReq.Server, out resp))
//					{
//						if(resp != null)
//							Global.RO.Warn("The readHashResponse is not null");
//						else
//						{
//							if(readHashReq.XErr != HResult.XONLINE_E_SERVER_ERROR)
//								Global.RO.Warn("Wrong error code " + Global.XErrToString(readHashReq.XErr));
//							else
//								ResultCode=TEST_RESULTS.PASSED;
//						}
//					}
//					else
//						Global.RO.Warn("negative readFileHash Request succeed unexpectedly");
//				}
//				else
//					Global.RO.Warn("WriteFile Request failed");
//			}
//		}
        [TestCase, Description("27838send a request with nonexistent pathname"), TestCasePriority(2)]
			class NPathNotFound : NegativeReadHashTestBase
		{
			override protected void Execute()
			{
				uint    randomTitleID = (uint)new Random().Next();
				string    sTitleID = randomTitleID.ToString("x");
				string url= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLReadFileHash		req = new XRLReadFileHash();
				req.pathName = url;
				req.pathNameLen = (ushort)req.pathName.Length;
				if(ReadHashTestNegative(req,HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("27839:send a request with null pathname, but pathNamelen set to non-zero"), TestCasePriority(2)]
			class NNullPathname : NegativeReadHashTestBase
		{
			override protected void Execute()
			{
				XRLReadFileHash		req = new XRLReadFileHash();
				req.ManualArraySize = true;
				req.pathName = null;
				req.pathNameLen = 12;
				if(ReadHashTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\FuncTeamDF.cs ===
using System;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Storage;
using ServerTestFramework.LiveService.Signature;
using ServerTestFramework.LiveService.Presence;
using xonline.common.config;

namespace XStoreTest
{
    internal abstract class TeamDFTestBase : TestBase
    {
        protected bool RemoveFileSendAndVerify(XRLRemoveFile removeReq)
        {
            // WriteReq and removeReq has the same pathName, but
            // 1.the userPUID that write the file is not the userPUID that remove the file
            // 2.the userPUID in pathName is not the above
            uint    titleID = removeReq.uiTitleId;
            string    pathName = removeReq.accessToken.baseAT.pathName;
            // the one write the file is not the one that remove it
            ulong    userPUID = (ulong)((new Random().NextDouble()) * 0xffffffffffffffff);
            XRLWriteFile    WriteReq = new XRLWriteFile("Team", pathName);
            // create a new teamTicket since the one created in above has different userPUID
            ulong    []teamPUIDList = new ulong[1];
            teamPUIDList[0] = WriteReq.tickets.list.tickets[0].teamIDs[0];//teamPUID unchanged
            byte []key    = new byte[16];
            new Random().NextBytes(key);
            WriteReq.Slot.userPuid0 = WriteReq.accessToken.baseAT.userPuid = userPUID;
            WriteReq.tickets.list.tickets[0].Populate(userPUID,teamPUIDList,key);
            WriteReq.Slot.SetKey(key);

            if(WriteReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
            {
                if(removeReq.Execute())
                {
                    XRLReadFile        readReq = new XRLReadFile(pathName);
                    readReq.Slot.titleId = readReq.uiTitleId = titleID;
                    if(!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)) &&
                        (readReq.XErr == HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
                        return true;
                    else
                    {
                        Global.RO.Warn("File was not removed");
                        return false;
                    }
                }
                Global.RO.Warn("RemoveFile request failed with "+Global.XErrToString(removeReq.XErr));
                return false;
            }
            return false;
        }
    }
    internal abstract class NegTeamDFTestBase : TestBase
    {
        protected bool RemoveFileTestNegative(XRLRemoveFile    removeReq, uint XErr)
        {
            if (removeReq.Execute())
            {
                Global.RO.Warn("Negative RemoveFile request succeed unexpectedly");
                return false;
            }
            if(removeReq.XErr != XErr)
            {
                Global.RO.Warn("Wrong error code " + Global.XErrToString(removeReq.XErr) +" returned");
                return false;
            }
            return true;
        }
    }
    [TestGroup, Owner("JKonkle"), TestFrequency("Regression"), TestCasePriority(1)]
	public class FuncTeamDF : TestNode
    {
        /**********************************************************************************
         * Positive Wire Protocol Testing
         *********************************************************************************/
        [TestCase, Description("check x-delay in the http response")]
        class PThrottling : TeamDFTestBase
        {
            override protected void Execute()
            {
                ulong    userPUID = (ulong) (new Random().NextDouble() * 0xffffffffffffffff);
                ulong    teamPUID = (ulong)(new Random().NextDouble() * 0xffffffffffffffff);
                uint    titleID = (uint) new Random().Next();
                string pathName = "//tteam."+titleID.ToString("x")+"/u:"+teamPUID.ToString("x")
                    + "/" + titleID.ToString("x")+"/"+userPUID.ToString("x")+"/"+Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Team");

				int Xdelay= 3000;
				Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage,"exec :stfd SetXDelay "+removeReq.uiTitleId.ToString("X")+" removefile "+Xdelay);

                if(RemoveFileSendAndVerify(removeReq)&&
                    (removeReq.XDelay == Xdelay))
                    ResultCode=TEST_RESULTS.PASSED;

				Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage,"exec :stfd ReloadThrottleConfig");
            }
        }
        [TestCase, Description("Write a file first then call removeFile with the same pathname but different userPUID")]
			class PNormalCase : TeamDFTestBase
        {
            override protected void Execute()
            {
                ulong    userPUID = (ulong) (new Random().NextDouble() * 0xffffffffffffffff);
                ulong    teamPUID = (ulong)(new Random().NextDouble() * 0xffffffffffffffff);
                uint    titleID = (uint) new Random().Next();
                string pathName = "//tteam."+titleID.ToString("x")+"/u:"+teamPUID.ToString("x")
                    + "/" + titleID.ToString("x")+"/"+userPUID.ToString("x")+"/"+Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Team");
                if(RemoveFileSendAndVerify(removeReq))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("call removeFile with maximum titleID")]
			class PMaxTitleID : TeamDFTestBase
        {
            override protected void Execute()
            {
                uint    titleID = 0xffffffff;
                ulong    userPUID = (ulong) (new Random().NextDouble() * 0xffffffffffffffff);
                ulong    teamPUID = (ulong)(new Random().NextDouble() * 0xffffffffffffffff);
                string pathName = "//tteam."+titleID.ToString("x")+"/u:"+teamPUID.ToString("x")
                    + "/" + titleID.ToString("x")+"/"+userPUID.ToString("x")+"/"+Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Team");
                if(RemoveFileSendAndVerify(removeReq))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("call removeFile with minimum titleID")]
			class PMinTitleID : TeamDFTestBase
        {
            override protected void Execute()
            {
                ulong    userPUID = (ulong) (new Random().NextDouble() * 0xffffffffffffffff);
                ulong    teamPUID = (ulong)(new Random().NextDouble() * 0xffffffffffffffff);
                uint    titleID = 1;
                string pathName = "//tteam."+titleID.ToString("x")+"/u:"+teamPUID.ToString("x")
                    + "/" + titleID.ToString("x")+"/"+userPUID.ToString("x")+"/"+Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Team");
                if(RemoveFileSendAndVerify(removeReq))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("call removeFile with maximum titleVersion")]
			class PMaxTitleVersion : TeamDFTestBase
        {
            override protected void Execute()
            {
                ulong    userPUID = (ulong) (new Random().NextDouble() * 0xffffffffffffffff);
                ulong    teamPUID = (ulong)(new Random().NextDouble() * 0xffffffffffffffff);
                uint    titleID = (uint) new Random().Next();
                string pathName = "//tteam."+titleID.ToString("x")+"/u:"+teamPUID.ToString("x")
                    + "/" + titleID.ToString("x")+"/"+userPUID.ToString("x")+"/"+Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Team");
                removeReq.uiTitleVersion = 0xffffffff;
                removeReq.Slot.titleVersion = 0xffffffff;
                if(RemoveFileSendAndVerify(removeReq))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("call removeFile with minimum titleVersion")]
			class PMinTitleVersion : TeamDFTestBase
        {
            override protected void Execute()
            {
                ulong    userPUID = (ulong) (new Random().NextDouble() * 0xffffffffffffffff);
                ulong    teamPUID = (ulong)(new Random().NextDouble() * 0xffffffffffffffff);
                uint    titleID = (uint) new Random().Next();
                string pathName = "//tteam."+titleID.ToString("x")+"/u:"+teamPUID.ToString("x")
                    + "/" + titleID.ToString("x")+"/"+userPUID.ToString("x")+"/"+Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Team");
                removeReq.uiTitleVersion = 1;
                removeReq.Slot.titleVersion = 1;
                if(RemoveFileSendAndVerify(removeReq))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("call removeFile with max XBoxID")]
			class PMaxBoxID : TeamDFTestBase
        {
            override protected void Execute()
            {
                ulong    userPUID = (ulong) (new Random().NextDouble() * 0xffffffffffffffff);
                ulong    teamPUID = (ulong)(new Random().NextDouble() * 0xffffffffffffffff);
                uint    titleID = (uint) new Random().Next();
                string pathName = "//tteam."+titleID.ToString("x")+"/u:"+teamPUID.ToString("x")
                    + "/" + titleID.ToString("x")+"/"+userPUID.ToString("x")+"/"+Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Team");
                removeReq.accessToken.baseAT.xboxPuid = 0xffffffffffffffff;
                removeReq.Slot.machinePuid = 0xffffffffffffffff;
                if(RemoveFileSendAndVerify(removeReq))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("call removeFile with min XBoxID")]
			class PMinBoxID : TeamDFTestBase
        {
            override protected void Execute()
            {
                ulong    userPUID = (ulong) (new Random().NextDouble() * 0xffffffffffffffff);
                ulong    teamPUID = (ulong)(new Random().NextDouble() * 0xffffffffffffffff);
                uint    titleID = (uint) new Random().Next();
                string pathName = "//tteam."+titleID.ToString("x")+"/u:"+teamPUID.ToString("x")
                    + "/" + titleID.ToString("x")+"/"+userPUID.ToString("x")+"/"+Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Team");
                removeReq.accessToken.baseAT.xboxPuid = 1;
                removeReq.Slot.machinePuid = 1;
                if(RemoveFileSendAndVerify(removeReq))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("call removeFile with 255 unicode chars")]
			class PMaxPathNameSize : TeamDFTestBase
        {
            override protected void Execute()
            {
                ulong    userPUID = (ulong) (new Random().NextDouble() * 0xffffffffffffffff);
                ulong    teamPUID = (ulong)(new Random().NextDouble() * 0xffffffffffffffff);
                uint    titleID = (uint) new Random().Next();
                string pathName = "//tteam."+titleID.ToString("x")+"/u:"+teamPUID.ToString("x")
                    + "/" + titleID.ToString("x")+"/"+userPUID.ToString("x")+"/"+Guid.NewGuid().ToString();
                StringBuilder    pathBuilder = new StringBuilder(pathName);
                if(pathName.Length < 255)
                    pathBuilder.Append('z',255-pathName.Length);

                XRLRemoveFile    removeReq = new XRLRemoveFile(pathBuilder.ToString(),titleID,"Team");
                if(RemoveFileSendAndVerify(removeReq))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        /**********************************************************************************
         * Positive Other Testing
         *********************************************************************************/
        [TestCase, Description("create a file with a pathname and one title ID, call RemoveFile with the same pathname but different title ID"), TestCasePriority(2)]
			class NRemoveFromOtherTitle : TestBase
        {
            override protected void Execute()
            {
                ulong    userPUID = (ulong) (new Random().NextDouble() * 0xffffffffffffffff);
                ulong    teamPUID = (ulong)(new Random().NextDouble() * 0xffffffffffffffff);
                uint    titleID = (uint) new Random().Next();
                string pathName = "//tteam."+titleID.ToString("x")+"/u:"+teamPUID.ToString("x")
                    + "/" + titleID.ToString("x")+"/"+userPUID.ToString("x")+"/"+Guid.NewGuid().ToString();

                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Team");
                XRLWriteFile    WriteReq = new XRLWriteFile("Team",pathName);
                WriteReq.Slot.titleId = WriteReq.uiTitleId = titleID + 1;

                if(WriteReq.Execute())
                {
                    if(!removeReq.Execute()&& (removeReq.XErr == HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
                            ResultCode=TEST_RESULTS.PASSED;
                }
            }
        }
        [TestCase, Description("call RemoveFile with the same pathname and titleID as writeFile but different title Version")]
			class PRemoveFromOtherTitleVersion : TestBase
        {
            override protected void Execute()
            {
                ulong    userPUID = (ulong) (new Random().NextDouble() * 0xffffffffffffffff);
                ulong    teamPUID = (ulong)(new Random().NextDouble() * 0xffffffffffffffff);
                uint    titleID = (uint) new Random().Next();
                string pathName = "//tteam."+titleID.ToString("x")+"/u:"+teamPUID.ToString("x")
                    + "/" + titleID.ToString("x")+"/"+userPUID.ToString("x")+"/"+Guid.NewGuid().ToString();

                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Team");
                XRLWriteFile    WriteReq = new XRLWriteFile("Team",pathName);
                WriteReq.Slot.titleVersion = WriteReq.uiTitleVersion = removeReq.uiTitleVersion + 1;
                if(WriteReq.Execute())
                {
                    if(removeReq.Execute())
                    {
                        XRLReadFile        readReq = new XRLReadFile(pathName);
                        if(!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)) &&
                            (readReq.XErr == HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
                            ResultCode=TEST_RESULTS.PASSED;
                    }
                }
            }
        }
        [TestCase, Description("create a file with one userPUID;call RemoveFile with the same pathName but different userPUID")]
			class PRemoveByAnotherUser : TestBase
        {
            override protected void Execute()
            {
                ulong    userPUID = (ulong) (new Random().NextDouble() * 0xffffffffffffffff);
                ulong    teamPUID = (ulong)(new Random().NextDouble() * 0xffffffffffffffff);
                uint    titleID = (uint) new Random().Next();
                string pathName = "//tteam."+titleID.ToString("x")+"/u:"+teamPUID.ToString("x")
                    + "/" + titleID.ToString("x")+"/"+userPUID.ToString("x")+"/"+Guid.NewGuid().ToString();

                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Team");
                XRLWriteFile    WriteReq = new XRLWriteFile("Team",pathName);
                WriteReq.Slot.userPuid0=WriteReq.accessToken.baseAT.userPuid = removeReq.accessToken.baseAT.userPuid+1;
                // need to create a new team tickets since userPUID has changed.
                ulong    []teamPUIDList = new ulong[1];
                teamPUIDList[0] = teamPUID;
                byte []key    = new byte[16];
                new Random().NextBytes(key);
                WriteReq.tickets.list.tickets[0].Populate(WriteReq.Slot.userPuid0,teamPUIDList,key);
                WriteReq.Slot.SetKey(key);

                if(WriteReq.Execute())
                {
                    if(removeReq.Execute())
                    {
                        XRLReadFile        readReq = new XRLReadFile(pathName);
                        if(!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)) &&
                            (readReq.XErr == HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
                            ResultCode=TEST_RESULTS.PASSED;
                    }
                }
            }
        }
        [TestCase, Description("remove only one ref for a file with multiple references")]
			class PRemoveFileWithMultiRef : TestBase
        {
            override protected void Execute()
            {
                ulong    userPUID = (ulong) (new Random().NextDouble() * 0xffffffffffffffff);
                ulong    teamPUID = (ulong)(new Random().NextDouble() * 0xffffffffffffffff);
                uint    title = (uint) new Random().Next();
                string pathName = "//tteam."+title.ToString("x")+"/u:"+teamPUID.ToString("x")
                    + "/" + title.ToString("x")+"/"+userPUID.ToString("x")+"/"+Guid.NewGuid().ToString();
                // write a blob with 4 references

                uint        FileWithMultiRefLen = 10240;
                byte[]        FileData = new byte[FileWithMultiRefLen];
                new Random().NextBytes(FileData);
                byte[]        FileWithMultiRefHash = new byte[Constants.sizeHash];
                new Random().NextBytes(FileWithMultiRefHash);
                string        MultiRefPath1 = "", RemovedRefPath = "";
                XRLWriteFile    wReq1 = new XRLWriteFile("Team",pathName), wReq2 = new XRLWriteFile("Team",pathName);
                for(int i = 0; i < 4; i++)
                {
                    pathName = "//tteam."+title.ToString("x")+"/u:"+teamPUID.ToString("x")
                        + "/" + title.ToString("x")+"/"+userPUID.ToString("x")+"/"+Guid.NewGuid().ToString();
                    XRLWriteFile    writeReq = new XRLWriteFile("Team",pathName);
                    writeReq.blobDataLen = FileWithMultiRefLen;
                    writeReq.uiBlobSizeCompressed = FileWithMultiRefLen;
                    writeReq.blobData = new byte[FileWithMultiRefLen];
                    FileData.CopyTo(writeReq.blobData,0);
                    FileWithMultiRefHash.CopyTo(writeReq.blobHash,0);
                    if(!writeReq.Execute())
                    {
                        Global.RO.Warn("Write File failed:"+i);
                        return;
                    }
                    if(i == 0)
                    {
                        wReq1 = writeReq;
                        MultiRefPath1 = writeReq.accessToken.baseAT.pathName;
                    }
                    else if (i == 1)
                        wReq2 = writeReq;
                    // the removed Ref path will be i = 3
                    RemovedRefPath = writeReq.accessToken.baseAT.pathName;
                }

                // only remove one reference to the file; the file still in the db and
                // check the i_ref_count=3
                XRLRemoveFile    removeReq = new XRLRemoveFile(RemovedRefPath,title,"Team");
                if(removeReq.Execute())
                {
                    XRLReadFile        readReq = new XRLReadFile(MultiRefPath1);
                    readReq.Slot.titleId = readReq.uiTitleId = title;
                    XRLReadFileResponse    resp;
                    if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out resp))
                        // check ref count
                        if(wReq1.CheckRefCount(wReq2,3,false))
                            ResultCode=TEST_RESULTS.PASSED;
                }
            }
        }
        [TestCase, Description("remove all refs for a file with multiple references")]
			class PRemoveFileWithMultiRef2 : TestBase
        {
            override protected void Execute()
            {
                ulong    userPUID = (ulong) (new Random().NextDouble() * 0xffffffffffffffff);
                ulong    teamPUID = (ulong)(new Random().NextDouble() * 0xffffffffffffffff);
                uint    title = (uint) new Random().Next();
                string pathName = "//tteam."+title.ToString("x")+"/u:"+teamPUID.ToString("x")
                    + "/" + title.ToString("x")+"/"+userPUID.ToString("x")+"/"+Guid.NewGuid().ToString();
                // write a blob with 2 references
                uint        FileWithMultiRefLen = 10240;
                byte[]        FileData = new byte[FileWithMultiRefLen];
                new Random().NextBytes(FileData);
                byte[]        FileWithMultiRefHash = new byte[Constants.sizeHash];
                new Random().NextBytes(FileWithMultiRefHash);
                string        []refPath = new string[2]{"",""};
                XRLWriteFile    [] writeReq = new XRLWriteFile[2]{null, null};
                for(int i = 0; i < 2; i++)
                {
                    refPath[i] = pathName = "//tteam."+title.ToString("x")+"/u:"+teamPUID.ToString("x")
                        + "/" + title.ToString("x")+"/"+userPUID.ToString("x")+"/"+Guid.NewGuid().ToString();
                    writeReq[i] = new XRLWriteFile("Team",pathName);
                    writeReq[i].blobDataLen = FileWithMultiRefLen;
                    writeReq[i].uiBlobSizeCompressed = FileWithMultiRefLen;
                    writeReq[i].blobData = new byte[FileWithMultiRefLen];
                    FileData.CopyTo(writeReq[i].blobData,0);
                    FileWithMultiRefHash.CopyTo(writeReq[i].blobHash,0);

                    if(!writeReq[i].Execute())
                    {
                        Global.RO.Warn("Write File failed:"+i);
                        return;
                    }
                }

                // remove all references to the file; the file will be deleted
                XRLRemoveFile    removeReq1 = new XRLRemoveFile(refPath[0],title,"Team");
                XRLRemoveFile    removeReq2 = new XRLRemoveFile(refPath[1],title,"Team");
                if(removeReq1.Execute() && (removeReq2.Execute()))
                {
                    XRLReadFile        readReq = new XRLReadFile(refPath[0]);
                    readReq.Slot.titleId = readReq.uiTitleId = title;
                    if(!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage))&&
                        (readReq.XErr==HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
                        ResultCode=TEST_RESULTS.PASSED;
                }
            }
        }
        /**********************************************************************************
         * Negative Wire Protocol Testing
         *********************************************************************************/
        [TestCase, Description("31658:the userPUID in SGAuth response is different than the one in removeFile request"), TestCasePriority(2)]
			class NSGAuthInvalidUserPUID : NegTeamDFTestBase
        {
            override protected void Execute()
            {
                ulong    userPUID = (ulong) (new Random().NextDouble() * 0xffffffffffffffff);
                ulong    teamPUID = (ulong)(new Random().NextDouble() * 0xffffffffffffffff);
                uint    titleID = (uint) new Random().Next();
                string pathName = "//tteam."+titleID.ToString("x")+"/u:"+teamPUID.ToString("x")
                    + "/" + titleID.ToString("x")+"/"+userPUID.ToString("x")+"/"+Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Team");
                removeReq.Slot.userPuid0++;
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("the userPUID in SGAuth response is not_found user"), TestCasePriority(2)]
			class NSGAuthNotFoundUser : NegTeamDFTestBase
        {
            override protected void Execute()
            {
                ulong    userPUID = (ulong) (new Random().NextDouble() * 0xffffffffffffffff);
                ulong    teamPUID = (ulong)(new Random().NextDouble() * 0xffffffffffffffff);
                uint    titleID = (uint) new Random().Next();
                string pathName = "//tteam."+titleID.ToString("x")+"/u:"+teamPUID.ToString("x")
                    + "/" + titleID.ToString("x")+"/"+userPUID.ToString("x")+"/"+Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Team");
                removeReq.Slot.UserExists = 0;
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_SERVER_ERROR))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("31658:the machineID in SGAuth response is not the one in the removeFile request"), TestCasePriority(2)]
			class NSGAuthInvalidXBoxID : NegTeamDFTestBase
        {
            override protected void Execute()
            {
                ulong    userPUID = (ulong) (new Random().NextDouble() * 0xffffffffffffffff);
                ulong    teamPUID = (ulong)(new Random().NextDouble() * 0xffffffffffffffff);
                uint    titleID = (uint) new Random().Next();
                string pathName = "//tteam."+titleID.ToString("x")+"/u:"+teamPUID.ToString("x")
                    + "/" + titleID.ToString("x")+"/"+userPUID.ToString("x")+"/"+Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Team");
                removeReq.Slot.machinePuid++;
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("31658:the titleID in SGAuth response is not the one in the removeFile request"), TestCasePriority(2)]
			class NSGAuthInvalidTitleID : NegTeamDFTestBase
        {
            override protected void Execute()
            {
                ulong    userPUID = (ulong) (new Random().NextDouble() * 0xffffffffffffffff);
                ulong    teamPUID = (ulong)(new Random().NextDouble() * 0xffffffffffffffff);
                uint    titleID = (uint) new Random().Next();
                string pathName = "//tteam."+titleID.ToString("x")+"/u:"+teamPUID.ToString("x")
                    + "/" + titleID.ToString("x")+"/"+userPUID.ToString("x")+"/"+Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Team");
                removeReq.Slot.titleId++;
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_INVALID_TITLE_ID))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("31659:the titleVersion in SGAuth response is not the one in the removeFile request"), TestCasePriority(2)]
			class NSGAuthInvalidTitleVersion : NegTeamDFTestBase
        {
            override protected void Execute()
            {
                ulong    userPUID = (ulong) (new Random().NextDouble() * 0xffffffffffffffff);
                ulong    teamPUID = (ulong)(new Random().NextDouble() * 0xffffffffffffffff);
                uint    titleID = (uint) new Random().Next();
                string pathName = "//tteam."+titleID.ToString("x")+"/u:"+teamPUID.ToString("x")
                    + "/" + titleID.ToString("x")+"/"+userPUID.ToString("x")+"/"+Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Team");
                removeReq.Slot.titleVersion++;
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("the serviceID in SGAuth response is not the one in the removeFile req"), TestCasePriority(2)]
			class NSGAuthInvalidServiceID : NegTeamDFTestBase
        {
            override protected void Execute()
            {
                ulong    userPUID = (ulong) (new Random().NextDouble() * 0xffffffffffffffff);
                ulong    teamPUID = (ulong)(new Random().NextDouble() * 0xffffffffffffffff);
                uint    titleID = (uint) new Random().Next();
                string pathName = "//tteam."+titleID.ToString("x")+"/u:"+teamPUID.ToString("x")
                    + "/" + titleID.ToString("x")+"/"+userPUID.ToString("x")+"/"+Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Team");
                removeReq.Slot.ClearServices();
                removeReq.Slot.AddService(removeReq.ServiceId + 1);
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_SERVER_ERROR))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("31660:Call RemoveFile with invalid pathName"), TestCasePriority(2)]
			class NFileNotFound : NegTeamDFTestBase
        {
            override protected void Execute()
            {
                ulong    userPUID = (ulong) (new Random().NextDouble() * 0xffffffffffffffff);
                ulong    teamPUID = (ulong)(new Random().NextDouble() * 0xffffffffffffffff);
                uint    titleID = (uint) new Random().Next();
                string pathName = "//tteam."+titleID.ToString("x")+"/u:"+teamPUID.ToString("x")
                    + "/" + titleID.ToString("x")+"/"+userPUID.ToString("x")+"/"+Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Team");
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass non-removeFile operation"), TestCasePriority(2)]
			class NInvalidOperation : NegTeamDFTestBase
        {
            override protected void Execute()
            {
                ulong    userPUID = (ulong) (new Random().NextDouble() * 0xffffffffffffffff);
                ulong    teamPUID = (ulong)(new Random().NextDouble() * 0xffffffffffffffff);
                uint    titleID= (uint) new Random().Next();
                string pathName = "//tteam."+titleID.ToString("x")+"/u:"+teamPUID.ToString("x")
                    + "/" + titleID.ToString("x")+"/"+userPUID.ToString("x")+"/"+Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Team");
                removeReq.accessToken.baseAT.operation = (ushort)Constants.Operation.FileEnumerate;
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass 0 as userPUID"), TestCasePriority(2)]
			class NZeroUserPUID : NegTeamDFTestBase
        {
            override protected void Execute()
            {
                ulong    userPUID = 0;
                ulong    teamPUID = 0;
                uint    titleID = (uint) new Random().Next();
                string pathName = "//tteam."+titleID.ToString("x")+"/u:"+teamPUID.ToString("x")
                    + "/" + titleID.ToString("x")+"/"+userPUID.ToString("x")+"/"+Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Team");
                removeReq.accessToken.baseAT.userPuid = 0;
                removeReq.Slot.userPuid0 = 0;
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_SERVER_ERROR))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass 0 as xboxPUID"), TestCasePriority(2)]
			class NZeroXBoxPUID : NegTeamDFTestBase
        {
            override protected void Execute()
            {
                ulong    userPUID = (ulong) (new Random().NextDouble() * 0xffffffffffffffff);
                ulong    teamPUID = (ulong)(new Random().NextDouble() * 0xffffffffffffffff);
                uint    titleID = (uint) new Random().Next();
                string pathName = "//tteam."+titleID.ToString("x")+"/u:"+teamPUID.ToString("x")
                    + "/" + titleID.ToString("x")+"/"+userPUID.ToString("x")+"/"+Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Team");
                removeReq.accessToken.baseAT.xboxPuid = 0;
                removeReq.Slot.machinePuid = 0;
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pathNameLen is greater than the actual pathname"), TestCasePriority(2)]
			class NTruncatePathname : NegTeamDFTestBase
        {
            override protected void Execute()
            {
                ulong    userPUID = (ulong) (new Random().NextDouble() * 0xffffffffffffffff);
                ulong    teamPUID = (ulong)(new Random().NextDouble() * 0xffffffffffffffff);
                uint    title = (uint) new Random().Next();
                string pathName = "//tteam."+title.ToString("x")+"/u:"+teamPUID.ToString("x")
                    + "/" + title.ToString("x")+"/"+userPUID.ToString("x")+"/"+Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,title,"Team");
                removeReq.accessToken.baseAT.ManualArraySize = true;
                removeReq.accessToken.baseAT.pathNameLen +=1;    //??????what's the right error code?
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pathNameLen is shorter than the actual pathname"), TestCasePriority(2)]
			class NOverflowPathname : NegTeamDFTestBase
        {
            override protected void Execute()
            {
                ulong    userPUID = (ulong) (new Random().NextDouble() * 0xffffffffffffffff);
                ulong    teamPUID = (ulong)(new Random().NextDouble() * 0xffffffffffffffff);
                uint    title = (uint) new Random().Next();
                string pathName = "//tteam."+title.ToString("x")+"/u:"+teamPUID.ToString("x")
                    + "/" + title.ToString("x")+"/"+userPUID.ToString("x")+"/"+Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,title,"Team");
                removeReq.accessToken.baseAT.ManualArraySize = true;
                removeReq.accessToken.baseAT.pathNameLen -=1;    //??????what's the right error code?
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass NULL for pathName"), TestCasePriority(2)]
			class NNullPathname : NegTeamDFTestBase
        {
            override protected void Execute()
            {
                uint    titleID = (uint) new Random().Next();
                XRLRemoveFile    removeReq = new XRLRemoveFile(null,titleID,"Team");
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("token expiration time is before current time"), TestCasePriority(2)]
			class NInvalidTokenExpTime : NegTeamDFTestBase
        {
            override protected void Execute()
            {
                ulong    userPUID = (ulong) (new Random().NextDouble() * 0xffffffffffffffff);
                ulong    teamPUID = (ulong)(new Random().NextDouble() * 0xffffffffffffffff);
                uint    titleID = (uint) new Random().Next();
                string pathName = "//tteam."+titleID.ToString("x")+"/u:"+teamPUID.ToString("x")
                    + "/" + titleID.ToString("x")+"/"+userPUID.ToString("x")+"/"+Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Team");
                removeReq.accessToken.removeAT.tokenExpirationDate = (long)System.DateTime.UtcNow.AddHours(-1).ToFileTimeUtc();
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        //  [TestCase, Description("pass removeFile request to stfd port 11140 other than 80"), TestCasePriority(2)]
			class NDCReq : NegTeamDFTestBase
        {
            override protected void Execute()
            {
                ulong    userPUID = (ulong) (new Random().NextDouble() * 0xffffffffffffffff);
                ulong    teamPUID = (ulong)(new Random().NextDouble() * 0xffffffffffffffff);
                uint    titleID = (uint) new Random().Next();
                string pathName = "//tteam."+titleID.ToString("x")+"/u:"+teamPUID.ToString("x")
                    + "/" + titleID.ToString("x")+"/"+userPUID.ToString("x")+"/"+Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Team");
                removeReq.Server.Port = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int).Port;

                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
            [TestCase, Description("no team tickets at the end of removeFile request"), TestCasePriority(2)]
			class NoTeamTickets : NegTeamDFTestBase
        {
            override protected void Execute()
            {
                ulong    userPUID = (ulong) (new Random().NextDouble() * 0xffffffffffffffff);
                ulong    teamPUID = (ulong)(new Random().NextDouble() * 0xffffffffffffffff);
                uint    title = (uint) new Random().Next();
                string pathName = "//tteam."+title.ToString("x")+"/u:"+teamPUID.ToString("x")
                    + "/" + title.ToString("x")+"/"+userPUID.ToString("x")+"/"+Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,title,"Team");
                removeReq.accessToken.baseAT.flags = 0;
                removeReq.tickets = null;
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
            [TestCase, Description("The teamTicket is not for the requesting user"), TestCasePriority(2)]
			class NInvalidTeamTickets : NegTeamDFTestBase
        {
            override protected void Execute()
            {
                ulong    userPUID = (ulong) (new Random().NextDouble() * 0xffffffffffffffff);
                ulong    teamPUID = (ulong)(new Random().NextDouble() * 0xffffffffffffffff);
                uint    title = (uint) new Random().Next();
                string pathName = "//tteam."+title.ToString("x")+"/u:"+teamPUID.ToString("x")
                    + "/" + title.ToString("x")+"/"+userPUID.ToString("x")+"/"+Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,title,"Team");
        //        removeReq.tickets.list.tickets[0].userID = removeReq.accessToken.baseAT.userPuid+1;
                // append team tickets at the end of request
                ulong    []teamPUIDList = new ulong[1];
                teamPUIDList[0] = teamPUID;
                uint    numUsers = 1;
                byte []key    = new byte[16];
                new Random().NextBytes(key);
                removeReq.tickets = new TeamTickets();
                removeReq.tickets.list.tickets = new TeamTicket[numUsers];
                removeReq.tickets.list.tickets[0] = new TeamTicket();
                removeReq.Slot.userPuid0 = removeReq.accessToken.baseAT.userPuid = userPUID;
                removeReq.tickets.list.tickets[0].Populate(userPUID+1,teamPUIDList,key);
                removeReq.Slot.SetKey(key);

                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
            [TestCase, Description("the signing key in SGAuth response is different than the one used to create the signature in the team ticket"), TestCasePriority(2)]
			class NSGAuthInvalidKey : NegTeamDFTestBase
        {
            override protected void Execute()
            {
                ulong    userPUID = (ulong) (new Random().NextDouble() * 0xffffffffffffffff);
                ulong    teamPUID = (ulong)(new Random().NextDouble() * 0xffffffffffffffff);
                uint    title = (uint) new Random().Next();
                string pathName = "//tteam."+title.ToString("x")+"/u:"+teamPUID.ToString("x")
                    + "/" + title.ToString("x")+"/"+userPUID.ToString("x")+"/"+Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,title,"Team");
                byte [] key = new byte[16];
                new Random().NextBytes(key);
                key[8]--;
                key[0]++;
                removeReq.Slot.SetKey(key);
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\FuncGlobalTitleWF.cs ===
using System;
using System.Globalization;
using System.Text;
using System.Net;
using System.IO;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Storage;
using ServerTestFramework.LiveService.Signature;
using xonline.common.config;

namespace XStoreTest
{
    internal abstract class GlobalTitleWFTestBase : TestBase
    {
        //    send WriteFile request first; then send readfile;verifies the response
        protected bool WriteFileSendAndVerify(XRLWriteFile WriteFileReq)
        {
            bool fPassed=WriteFileReq.Execute();
            if (!fPassed)
            {
                Global.RO.Warn("Failed to send WriteFile request ");
                return false;
            }

            XRLReadFileResponse    ReadFileResp;
            XRLReadFile            ReadFileReq = new XRLReadFile(WriteFileReq.accessToken.baseAT.pathName);
            ReadFileReq.Slot.titleId = ReadFileReq.uiTitleId = WriteFileReq.uiTitleId;
            ReadFileReq.Slot.titleVersion = ReadFileReq.uiTitleVersion = WriteFileReq.uiTitleVersion;
            if (ReadFileReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out ReadFileResp))
            {
                if (!ReadFileResp.Compare(WriteFileReq))
                {
                    Global.RO.Warn("ReadFileResp.Compare failed.  WriteFile request is not set correctly in the db");
                    return false;
                }
                else if (!WriteFileReq.Verify())
                {
                    Global.RO.Warn("WriteFileReq.Verify failed.  WriteFile request is not set correctly in the db");
                    return false;
                }
            }
            else
            {
                Global.RO.Warn("Failed to send ReadFile request");
                return false;
            }
            return true;
        }
    }
    internal abstract class GlobalTitleWFNegTestBase : TestBase
    {
        //    send WriteFile request first; then send readfile;verifies the response
        protected bool WriteFileTestNegative(XRLWriteFile WriteFileReq,uint XErr)
        {
            if (WriteFileReq.Execute())
            {
                Global.RO.Warn("Negative WriteFile request succeed unexpectedly");
                return false;
            }
            if(WriteFileReq.XErr != XErr)
            {
                Global.RO.Warn("Wrong error code returned " + Global.XErrToString(WriteFileReq.XErr));
                return false;
            }
            // now we need to check the file is not written to the DB
            XRLReadFileResponse    ReadFileResp;
            XRLReadFile            ReadFileReq = new XRLReadFile(WriteFileReq.accessToken.baseAT.pathName);
            ReadFileReq.Slot.titleId = ReadFileReq.uiTitleId = WriteFileReq.uiTitleId;
            ReadFileReq.Slot.titleVersion = ReadFileReq.uiTitleVersion = WriteFileReq.uiTitleVersion;
            if (!ReadFileReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out ReadFileResp))
            {
                /*                if((ReadFileReq.XErr != HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND)
                                    ||(ReadFileResp != null))
                                {
                                    Global.RO.Warn("file_not_found error is not returned OR File is being written to DB unexpectedly");
                                    return false;
                                }
                                */
                if(ReadFileResp != null)
                {
                    Global.RO.Warn("File is being written to DB unexpectedly");
                    return false;
                }
            }
            else
            {
                Global.RO.Warn("ReadFile request succeed with S_OK unexpectedly");
                return false;
            }
            return true;
        }
    }
    [TestGroup, Owner("JKonkle"), TestFrequency("Regression"), TestCasePriority(1)]
    public class FuncGlobalTitleWF : TestNode
    {
        /***********************************************************************
         * Wire Protocol Testing
         * *********************************************************************/
		[TestCase, Description("Write a file with all valid parameters including attributes")]
            class PNormalCase : GlobalTitleWFTestBase
        {
            override protected void Execute()
            {
                uint    randomTitleID = (uint)RandomEx.GlobalRandGen.Next();
                string    sTitleID = randomTitleID.ToString("x");
                string url= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                req.attributes = new byte[100];
                new Random().NextBytes(req.attributes);
                req.attributesLen = (ushort)req.attributes.Length;

                if(WriteFileSendAndVerify(req))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Write a 1k file")]
            class PSmallFileSize : GlobalTitleWFTestBase
        {
            override protected void Execute()
            {
                uint    randomTitleID = (uint)RandomEx.GlobalRandGen.Next();
                string    sTitleID = randomTitleID.ToString("x");
                string url= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();
                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                req.blobData = new byte[1024];
                new Random().NextBytes(req.blobData);
                req.blobDataLen = req.uiBlobSizeCompressed = (uint)req.blobData.Length;

                if(WriteFileSendAndVerify(req))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Write a 100k file")]
            class PMediumFileSize : GlobalTitleWFTestBase
        {
            override protected void Execute()
            {
                uint    randomTitleID = (uint)RandomEx.GlobalRandGen.Next();
                string    sTitleID = randomTitleID.ToString("x");
                string url= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                req.blobData = new byte[1024*100];
                new Random().NextBytes(req.blobData);
                req.blobDataLen = req.uiBlobSizeCompressed = (uint)req.blobData.Length;

                if(WriteFileSendAndVerify(req))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Write a 1MB file")]
            class PLargeFileSize : GlobalTitleWFTestBase
        {
            override protected void Execute()
            {
                uint    randomTitleID = (uint)RandomEx.GlobalRandGen.Next();
                string    sTitleID = randomTitleID.ToString("x");
                string url= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                req.blobData = new byte[1024*1024];
                new Random().NextBytes(req.blobData);
                req.blobDataLen = req.uiBlobSizeCompressed = (uint)req.blobData.Length;

                if(WriteFileSendAndVerify(req))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Write a file with title ID set to max value")]
            class PMaxTitleID : GlobalTitleWFTestBase
        {
            override protected void Execute()
            {
                string url= "//title.ffffffff/t:ffffffff/" + Guid.NewGuid().ToString();
                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);

                if(WriteFileSendAndVerify(req))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Write a file with title ID set to min value")]
            class PMinTitleID : GlobalTitleWFTestBase
        {
            override protected void Execute()
            {
                string url= "//title.1/t:1/" + Guid.NewGuid().ToString();
                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);

                if(WriteFileSendAndVerify(req))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Write a file with titleVersion set to max value")]
            class PMaxTitleVersion : GlobalTitleWFTestBase
        {
            override protected void Execute()
            {
                uint    randomTitleID = (uint)RandomEx.GlobalRandGen.Next();
                string    sTitleID = randomTitleID.ToString("x");
                string url= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                ulong    requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
                uint    ip = 0;
                byte [] addr = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).Address.GetAddressBytes();
                for(int i = 0; i < addr.Length; i++)
                    ip = (ip << 8) + addr[i];
                HTTPAuthData authData = new HTTPAuthData((ushort) Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int).Port,
                    ip,requestId,0,randomTitleID,(uint)XOService.Storage,0);
                authData.dwTitleVersion = req.uiTitleVersion = 0xffffffff;
                req.CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" +
                    authData.GetBase64EncodedString() + "\r\n";

                if(WriteFileSendAndVerify(req))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Write a file with titleVersion set to min value")]
            class PMinTitleVersion : GlobalTitleWFTestBase
        {
            override protected void Execute()
            {
                uint    randomTitleID = (uint)RandomEx.GlobalRandGen.Next();
                string    sTitleID = randomTitleID.ToString("x");
                string url= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                ulong    requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
                uint    ip = 0;
                byte [] addr = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).Address.GetAddressBytes();
                for(int i = 0; i < addr.Length; i++)
                    ip = (ip << 8) + addr[i];
                HTTPAuthData authData = new HTTPAuthData((ushort) Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int).Port,
                    ip,requestId,0,randomTitleID,(uint)XOService.Storage,0);
                authData.dwTitleVersion = req.uiTitleVersion = 0;
                req.CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" +
                    authData.GetBase64EncodedString() + "\r\n";

                if(WriteFileSendAndVerify(req))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        // npdb: t_storage_domain: 5mb
        [TestCase, Description("Write a max size file")]
            class PBlobDataMaxSize : GlobalTitleWFTestBase
        {
            override protected void Execute()
            {
                uint    randomTitleID = (uint)RandomEx.GlobalRandGen.Next();
                string    sTitleID = randomTitleID.ToString("x");
                string url= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                req.blobData = new byte[5*1024*1024];
                new Random().NextBytes(req.blobData);
                req.blobDataLen = req.uiBlobSizeCompressed = (uint)req.blobData.Length;

                if(WriteFileSendAndVerify(req))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass attributes with 256 byte")]
            class PMaxAttributeSize : GlobalTitleWFTestBase
        {
            override protected void Execute()
            {
                uint    randomTitleID = (uint)RandomEx.GlobalRandGen.Next();
                string    sTitleID = randomTitleID.ToString("x");
                string url= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                uint attLen = Constants.maxSizeAttributes;
                req.attributes = new byte[attLen];
                new Random().NextBytes(req.attributes);
                req.attributesLen = (ushort)req.attributes.Length;

                if(WriteFileSendAndVerify(req))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass 0 attributeslen")]
            class PMinAttributeSize : GlobalTitleWFTestBase
        {
            override protected void Execute()
            {
                uint    randomTitleID = (uint)RandomEx.GlobalRandGen.Next();
                string    sTitleID = randomTitleID.ToString("x");
                string url= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                req.attributes = null;
                req.attributesLen = 0;

                if(WriteFileSendAndVerify(req))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass 0 fileExpirationTime in the accessToken")]
            class PAccessTokenZeroFileExpTime : GlobalTitleWFTestBase
        {
            override protected void Execute()
            {
                uint    randomTitleID = (uint)RandomEx.GlobalRandGen.Next();
                string    sTitleID = randomTitleID.ToString("x");
                string url= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                req.accessToken.writeAT.fileExpirationDate = 0;
                req.accessToken.writeAT.tokenExpirationDate = System.DateTime.UtcNow.AddHours(1).ToFileTimeUtc();

                if(WriteFileSendAndVerify(req))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass 0 AccessTokenExpirationTime in the accessToken")]
            class PAccessTokenZeroATExpTime : GlobalTitleWFTestBase
        {
            override protected void Execute()
            {
                uint    randomTitleID = (uint)RandomEx.GlobalRandGen.Next();
                string    sTitleID = randomTitleID.ToString("x");
                string url= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                req.accessToken.writeAT.tokenExpirationDate = 0;

                if(WriteFileSendAndVerify(req))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass 255 unicode chars pathNameLen in the accessToken")]
            class PAccessTokenMaxPathnameSize : GlobalTitleWFTestBase
        {
            override protected void Execute()
            {
                uint    randomTitleID = (uint)RandomEx.GlobalRandGen.Next();
                string    sTitleID = randomTitleID.ToString("x");
                string url= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

                StringBuilder    pathBuilder = new StringBuilder(url);
                if(url.Length < 255)
                    pathBuilder.Append('z',255-url.Length);
                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",pathBuilder.ToString());

                if(WriteFileSendAndVerify(req))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass 0 for uncompressed blob size and null blobdata")]
            class PEmptyFile : GlobalTitleWFTestBase
        {
            override protected void Execute()
            {
                uint    randomTitleID = (uint)RandomEx.GlobalRandGen.Next();
                string    sTitleID = randomTitleID.ToString("x");
                string url= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                req.blobDataLen = req.uiBlobSizeCompressed = 0;
                req.blobData = null;

                if(WriteFileSendAndVerify(req))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("try to write a file that is bigger than max allowed"), TestCasePriority(2)]
            class NBiggerThanMaxFile : GlobalTitleWFNegTestBase
        {
            override protected void Execute()
            {
                uint    randomTitleID = (uint)RandomEx.GlobalRandGen.Next();
                string    sTitleID = randomTitleID.ToString("x");
                string url= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                req.blobData = new byte[5*1024*1024+1];
                new Random().NextBytes(req.blobData);
                req.blobDataLen = req.uiBlobSizeCompressed = (uint)req.blobData.Length;

                if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_FILE_IS_TOO_BIG))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass non-existent compression type"), TestCasePriority(2)]
            class NInvalidCompressionType : GlobalTitleWFNegTestBase
        {
            override protected void Execute()
            {
                uint    randomTitleID = (uint)RandomEx.GlobalRandGen.Next();
                string    sTitleID = randomTitleID.ToString("x");
                string url= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                req.bCompressionType = (byte)Constants.CompressionType.Invalid;
                if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass non-existent content type"), TestCasePriority(2)]
            class NInvalidContentType : GlobalTitleWFNegTestBase
        {
            override protected void Execute()
            {
                uint    randomTitleID = (uint)RandomEx.GlobalRandGen.Next();
                string    sTitleID = randomTitleID.ToString("x");
                string url= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                req.uiContentType = (uint)Constants.ContentType.Invalid;
                if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass NULL for blob hash"), TestCasePriority(2)]
            class NNullBlobHash : GlobalTitleWFNegTestBase
        {
            override protected void Execute()
            {
                uint    randomTitleID = (uint)RandomEx.GlobalRandGen.Next();
                string    sTitleID = randomTitleID.ToString("x");
                string url= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                req.ManualArraySize = true;
                req.blobHash = null;
                if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_FILE_IS_TOO_BIG))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass <20 byte for blob hash"), TestCasePriority(2)]
            class NInvalidBlobHash1 : GlobalTitleWFNegTestBase
        {
            override protected void Execute()
            {
                uint    randomTitleID = (uint)RandomEx.GlobalRandGen.Next();
                string    sTitleID = randomTitleID.ToString("x");
                string url= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                req.ManualArraySize = true;
                req.blobHash = new byte[Constants.sizeHash - 1];
                if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_FILE_IS_TOO_BIG))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass >20 byte for blob hash"), TestCasePriority(2)]
            class NInvalidBlobHash2 : GlobalTitleWFNegTestBase
        {
            override protected void Execute()
            {
                string url = string.Format("//title.{0}/t:{0}/{1}", ((uint)RandomEx.GlobalRandGen.Next()).ToString("X"), Guid.NewGuid().ToString());
                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                req.ManualArraySize = true;
                req.blobHash = new byte[Constants.sizeHash + 1];
                if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("uncompressed size is smaller than compressed size"), TestCasePriority(2)]
            class NWrongCompressedSize : GlobalTitleWFNegTestBase
        {
            override protected void Execute()
            {
                string url = string.Format("//title.{0}/t:{0}/{1}", ((uint)RandomEx.GlobalRandGen.Next()).ToString("X").Length, Guid.NewGuid().ToString());
                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                req.uiBlobSizeCompressed = req.blobDataLen + 1;

                if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass non-null for Attributes, but AttribLen is zero"), TestCasePriority(2)]
            class NMismatchedAttributes : GlobalTitleWFNegTestBase
        {
            override protected void Execute()
            {
                string url = string.Format("//title.{0}/t:{0}/{1}", ((uint)RandomEx.GlobalRandGen.Next()).ToString("X"), Guid.NewGuid().ToString());
                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                req.ManualArraySize = true;
                req.attributesLen = 0;
                req.attributes = new byte[16];
                for(int i = 0; i < 16; i++)
                    req.attributes[i] = (byte)i;
                if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Attributes size is greater than the actual size"), TestCasePriority(2)]
            class NTruncateAttributes : GlobalTitleWFNegTestBase
        {
            override protected void Execute()
            {
                string url = string.Format("//title.{0}/t:{0}/{1}", ((uint)RandomEx.GlobalRandGen.Next()).ToString("X"), Guid.NewGuid().ToString());
                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                req.ManualArraySize = true;
                req.attributesLen +=1;
                if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Attributes size is smaller than the actual size"), TestCasePriority(2)]
            class NOverflowAttributes1 : GlobalTitleWFNegTestBase
        {
            override protected void Execute()
            {
                string url = string.Format("//title.{0}/t:{0}/{1}", ((uint)RandomEx.GlobalRandGen.Next()).ToString("X"), Guid.NewGuid().ToString());
                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                req.ManualArraySize = true;
                req.attributes = new Byte[16];
                req.attributesLen = 15;
                if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Attributes is null but attribLen is nonzero"), TestCasePriority(2)]
            class NOverflowAttributes2 : GlobalTitleWFNegTestBase
        {
            override protected void Execute()
            {
                string url = string.Format("//title.{0}/t:{0}/{1}", ((uint)RandomEx.GlobalRandGen.Next()).ToString("X"), Guid.NewGuid().ToString());
                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                req.ManualArraySize = true;
                req.attributes = null;
                req.attributesLen = 16;
                if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Attributes is null but attribLen is greater than maxallowed(256)"), TestCasePriority(2)]
            class NOverflowAttributes3 : GlobalTitleWFNegTestBase
        {
            override protected void Execute()
            {
                string url = string.Format("//title.{0}/t:{0}/{1}", ((uint)RandomEx.GlobalRandGen.Next()).ToString("X"), Guid.NewGuid().ToString());
                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                req.ManualArraySize = true;
                req.attributes = null;
                req.attributesLen = 257;
                if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Attributes is larger than max allowed256bytes"), TestCasePriority(2)]
            class NOverflowAttributes4 : GlobalTitleWFNegTestBase
        {
            override protected void Execute()
            {
                string url = string.Format("//title.{0}/t:{0}/{1}", ((uint)RandomEx.GlobalRandGen.Next()).ToString("X"), Guid.NewGuid().ToString());
                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                ushort            attribLen = Constants.maxSizeAttributes + 1;
                req.attributes = new Byte[attribLen];
                req.attributesLen = attribLen;
                if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass special attributeLen = 0xffff"), TestCasePriority(2)]
            class NOverflowAttributes5 : GlobalTitleWFNegTestBase
        {
            override protected void Execute()
            {
                string url = string.Format("//title.{0}/t:{0}/{1}", ((uint)RandomEx.GlobalRandGen.Next()).ToString("X"), Guid.NewGuid().ToString());
                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                req.attributes = new Byte[0xffff];
                req.attributesLen = 0xffff;
                if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass null for AccessToken"), TestCasePriority(2)]
            class NNullAccessToken : GlobalTitleWFNegTestBase
        {
            override protected void Execute()
            {
                string url = string.Format("//title.{0}/t:{0}/{1}", ((uint)RandomEx.GlobalRandGen.Next()).ToString("X"), Guid.NewGuid().ToString());
                XRLWriteFile    WriteFileReq = new XRLWriteFile("ServiceAddr",url);
                WriteFileReq.ManualArraySize = true;
                WriteFileReq.accessToken = null;
                if (!WriteFileReq.Execute())
                {
                    if((WriteFileReq.XErr != HResult.XONLINE_E_STORAGE_INVALID_REQUEST)&&
                        (WriteFileReq.XErr != HResult.XONLINE_E_SERVER_ERROR))
                        Global.RO.Warn("Wrong error code returned " + Global.XErrToString(WriteFileReq.XErr));
                    else
                        ResultCode=TEST_RESULTS.PASSED;
                }
                else
                    Global.RO.Warn("Negative WriteFile request succeed unexpectedly");
            }
        }
        [TestCase, Description("pass null for Blob data, but blobLen is non-zero"), TestCasePriority(2)]
            class NNullBlobData : GlobalTitleWFNegTestBase
        {
            override protected void Execute()
            {
                string url = string.Format("//title.{0}/t:{0}/{1}", ((uint)RandomEx.GlobalRandGen.Next()).ToString("X"), Guid.NewGuid().ToString());
                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                req.ManualArraySize = true;
                req.blobData = null;
                if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass 0 for compressed blob size, but non-null blobdata"), TestCasePriority(2)]
            class NEmptyCompressedFile : GlobalTitleWFNegTestBase
        {
            override protected void Execute()
            {
                string url = string.Format("//title.{0}/t:{0}/{1}", ((uint)RandomEx.GlobalRandGen.Next()).ToString("X"), Guid.NewGuid().ToString());
                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                req.uiBlobSizeCompressed = 0;

                if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("uncompressed blob size is greater than the actual file size"), TestCasePriority(2)]
            class NTruncateFile : GlobalTitleWFNegTestBase
        {
            override protected void Execute()
            {
                string url = string.Format("//title.{0}/t:{0}/{1}", ((uint)RandomEx.GlobalRandGen.Next()).ToString("X"), Guid.NewGuid().ToString());
                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                req.ManualArraySize = true;
                req.blobDataLen += 1;
                req.uiBlobSizeCompressed +=1;
                if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("uncompressed blob size is smaller than the actual file size"), TestCasePriority(2)]
            class NOverflowFile : GlobalTitleWFNegTestBase
        {
            override protected void Execute()
            {
                string url = string.Format("//title.{0}/t:{0}/{1}", ((uint)RandomEx.GlobalRandGen.Next()).ToString("X"), Guid.NewGuid().ToString());
                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                req.ManualArraySize = true;
                req.blobDataLen -= 1;
                req.uiBlobSizeCompressed -=1;
                if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Expiration date is before the current time"), TestCasePriority(2)]
            class NAccessTokenInvalidExpTime1 : GlobalTitleWFNegTestBase
        {
            override protected void Execute()
            {
                string url = string.Format("//title.{0}/t:{0}/{1}", ((uint)RandomEx.GlobalRandGen.Next()).ToString("X"), Guid.NewGuid().ToString());
                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                req.accessToken.writeAT.fileExpirationDate = System.DateTime.UtcNow.AddDays(-1).ToFileTimeUtc();

                if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass an access Token that is greater than 255+baseAT"), TestCasePriority(2)]
            class NAccessTokenOverflowAT : GlobalTitleWFNegTestBase
        {
            override protected void Execute()
            {
                string url = string.Format("//title.{0}/t:{0}/{1}", ((uint)RandomEx.GlobalRandGen.Next()).ToString("X"), Guid.NewGuid().ToString());
                StringBuilder    pathName = new StringBuilder(url);
                int        i = 0, numCharToAdd = 256 - url.Length;
                while(i < numCharToAdd)
                {
                    pathName.Append('a');
                    i++;
                }
                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",pathName.ToString());

                if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Access Token version is invalid"), TestCasePriority(2)]
            class NAccessTokenInvalidTokenVersion : GlobalTitleWFNegTestBase
        {
            override protected void Execute()
            {
                string url = string.Format("//title.{0}/t:{0}/{1}", ((uint)RandomEx.GlobalRandGen.Next()).ToString("X"), Guid.NewGuid().ToString());
                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                req.accessToken.baseAT.version = Constants.accessTokenVersion + 1;

                if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Operation in AT is non-write"), TestCasePriority(2)]
            class NAccessTokenMismatchedOperation : GlobalTitleWFNegTestBase
        {
            override protected void Execute()
            {                
                string url = string.Format("//title.{0}/t:{0}/{1}", ((uint)RandomEx.GlobalRandGen.Next()).ToString("X"), Guid.NewGuid().ToString());
                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                req.accessToken.baseAT.operation = (ushort)Constants.Operation.FileRead;

                if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        //bug 33842
        [TestCase, Description("ServiceID in AT is not zero for GlobalTitleStorage")]
            class PAccessTokenNonZeroServiceID : GlobalTitleWFTestBase
        {
            override protected void Execute()
            {
                string url = string.Format("//title.{0}/t:{0}/{1}", ((uint)RandomEx.GlobalRandGen.Next()).ToString("X"), Guid.NewGuid().ToString());
                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                req.accessToken.baseAT.serviceId = (uint)XOService.Storage;

                if(this.WriteFileSendAndVerify(req))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        // This will be caught by xrlscan.ini
        [TestCase, Description("the actual file size is greater than the dwMaxFileSize in AT"), TestCasePriority(2)]
            class NAccessTokenOverflowFileData1 : TestBase
        {
            override protected void Execute()
            {
                string url = string.Format("//title.{0}/t:{0}/{1}", ((uint)RandomEx.GlobalRandGen.Next()).ToString("X"), Guid.NewGuid().ToString());
                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                uint            maxFileSize = req.accessToken.writeAT.maxFileSize;
                req.blobData = new byte[maxFileSize + 1];
                for (int i = 0; i < maxFileSize + 1; i++)
                    req.blobData[i] = (byte)i;
                req.blobDataLen = maxFileSize + 1;
                req.uiBlobSizeCompressed = maxFileSize + 1;

                // 404 returned back to client
                if(!req.Execute())
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        // This will be caught by xrlscan.ini
        [TestCase, Description("actual file size bigger than maxFileSize, but compressedSizeLen is smaller"), TestCasePriority(2)]
            class NAccessTokenOverflowFileData2 : TestBase
        {
            override protected void Execute()
            {
                string url = string.Format("//title.{0}/t:{0}/{1}", ((uint)RandomEx.GlobalRandGen.Next()).ToString("X"), Guid.NewGuid().ToString());
                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                uint            maxFileSize = req.accessToken.writeAT.maxFileSize;
                req.blobData = new byte[maxFileSize + 1];
                for (int i = 0; i < maxFileSize + 1; i++)
                    req.blobData[i] = (byte)i;
                req.blobDataLen = maxFileSize + 1;
                //    req.uiBlobSizeCompressed = maxFileSize + 1;

                // 404 returned back to client
                if(!req.Execute())
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("ticket expiration time is greater than file expiration time"), TestCasePriority(2)]
            class NAccessTokenInvalidExpTime2 : GlobalTitleWFTestBase
        {
            override protected void Execute()
            {
                string url = string.Format("//title.{0}/t:{0}/{1}", ((uint)RandomEx.GlobalRandGen.Next()).ToString("X"), Guid.NewGuid().ToString());
                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                req.accessToken.writeAT.fileExpirationDate = req.accessToken.writeAT.tokenExpirationDate - 100000;

                if(WriteFileSendAndVerify(req))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("the pathnameLen is greater than the actual size"), TestCasePriority(2)]
            class NAccessTokenTruncatePathname : GlobalTitleWFNegTestBase
        {
            override protected void Execute()
            {
                string url = string.Format("//title.{0}/t:{0}/{1}", ((uint)RandomEx.GlobalRandGen.Next()).ToString("X"), Guid.NewGuid().ToString());
                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                req.accessToken.baseAT.ManualArraySize = true;
                req.accessToken.baseAT.pathNameLen += 1;
                if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED) ||
                    WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("the flags in AT is non-zero"), TestCasePriority(2)]
            class NAccessTokenInvalidFlags : GlobalTitleWFNegTestBase
        {
            override protected void Execute()
            {
                string url = string.Format("//title.{0}/t:{0}/{1}", ((uint)RandomEx.GlobalRandGen.Next()).ToString("X"), Guid.NewGuid().ToString());
                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                req.accessToken.baseAT.flags = 1;

                if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        // bug 33842
        [TestCase, Description("pass non-zero userPUID for GlobalTitleStorage")]
            class PAccessTokenNonZeroUserPUID : GlobalTitleWFTestBase
        {
            override protected void Execute()
            {
                string url = string.Format("//title.{0}/t:{0}/{1}", ((uint)RandomEx.GlobalRandGen.Next()).ToString("X"), Guid.NewGuid().ToString());
                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);

                ulong    requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
                uint    ip = 0;
                byte [] addr = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).Address.GetAddressBytes();
                for(int i = 0; i < addr.Length; i++)
                    ip = (ip << 8) + addr[i];
                ulong    userPUID = req.accessToken.baseAT.userPuid = 0xff;
                HTTPAuthData authData = new HTTPAuthData((ushort) Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int).Port,
                    ip,requestId,userPUID,0x125626,(uint)XOService.Storage,0);
                authData.dwTitleVersion = req.uiTitleVersion;
                req.CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" +
                    authData.GetBase64EncodedString() + "\r\n";

                if(this.WriteFileSendAndVerify(req))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        // bug 33842
        [TestCase, Description("pass non-zero xboxPUID for GlobalTitleStorage")]
            class PAccessTokenNonZeroXBoxPUID : GlobalTitleWFTestBase
        {
            override protected void Execute()
            {
                string url = string.Format("//title.{0}/t:{0}/{1}", ((uint)RandomEx.GlobalRandGen.Next()).ToString("X"), Guid.NewGuid().ToString());
                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);

                ulong    requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
                uint    ip = 0;
                byte [] addr = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).Address.GetAddressBytes();
                for(int i = 0; i < addr.Length; i++)
                    ip = (ip << 8) + addr[i];
                HTTPAuthData authData = new HTTPAuthData((ushort) Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int).Port,
                    ip,requestId,0,0x125626,(uint)XOService.Storage,0);
                authData.dwTitleVersion = req.uiTitleVersion;
                authData.qwXboxID = req.accessToken.baseAT.xboxPuid = 0xff;
                req.CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" +
                    authData.GetBase64EncodedString() + "\r\n";

                if(WriteFileSendAndVerify(req))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        /***********************************************************************
        * Pathname Testing
        * *********************************************************************/
        [TestCase, Description("pass no IP part for the pathname")]
            class PPathnameNoIPPart : GlobalTitleWFTestBase
        {
            override protected void Execute()
            {
                string url = string.Format("//title.{0}/t:{0}/{1}", ((uint)RandomEx.GlobalRandGen.Next()).ToString("X"), Guid.NewGuid().ToString());
                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);

                if(WriteFileSendAndVerify(req))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("only specify domain in <Domain-part> (title),no optional information")]
            class PPathnameNoOptionalDomainSpecifier : GlobalTitleWFTestBase
        {
            override protected void Execute()
            {
                string url = string.Format("//title.{0}/t:{0}/{1}", ((uint)RandomEx.GlobalRandGen.Next()).ToString("X"), Guid.NewGuid().ToString());
                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);

                if(WriteFileSendAndVerify(req))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass a pathname that one null char in the middle of <Domain-part>"), TestCasePriority(2)]
            class NPathnameBadString1 : GlobalTitleWFNegTestBase
        {
            override protected void Execute()
            {
                string url= string.Format("//title.{0}/t:{0}/{1}", ((uint)RandomEx.GlobalRandGen.Next()).ToString("X"), Guid.NewGuid().ToString()),newurl;
                newurl = url.Insert(8,'\0'.ToString());
                XRLWriteFile    writeReq = new XRLWriteFile("ServiceAddr",newurl);

                //TODO: need to return xonline_e_storage_domain_not_supported
                if(WriteFileTestNegative(writeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass a pathname that two null char in the middle of <Domain-part>"), TestCasePriority(2)]
            class NPathnameBadString2 : GlobalTitleWFNegTestBase
        {
            override protected void Execute()
            {
                string url= string.Format("//title.{0}/t:{0}/{1}", ((uint)RandomEx.GlobalRandGen.Next()).ToString("X"), Guid.NewGuid().ToString()),newurl,temp;
                temp = '\0'.ToString() + '\0'.ToString();
                newurl = url.Insert(8,'\0'.ToString());
                XRLWriteFile    writeReq = new XRLWriteFile("ServiceAddr",newurl);

                //TODO: need to return xonline_e_storage_domain_not_supported
                if(WriteFileTestNegative(writeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass one nullchar in the middle of <titleID>"), TestCasePriority(2)]
            class NPathnameBadString3 : GlobalTitleWFNegTestBase
        {
            private RandomEx RandGen = new RandomEx();

            override protected void Execute()
            {
                string url= string.Format("//title.{0}/t:{0}/{1}", ((uint)RandomEx.GlobalRandGen.Next()).ToString("X"), Guid.NewGuid().ToString()),newurl;
                newurl = url.Insert(18,'\0'.ToString());
                XRLWriteFile writeReq = new XRLWriteFile("ServiceAddr", newurl, 1024, false, (uint)RandGen.Next(), 125626);

                if(WriteFileTestNegative(writeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass one nullchar in the middle of <pathpart>"), TestCasePriority(2)]
            class NPathnameBadString4 : GlobalTitleWFNegTestBase
        {
            override protected void Execute()
            {
                string url= string.Format("//title.{0}/t:{0}/{1}", ((uint)RandomEx.GlobalRandGen.Next()).ToString("X"), Guid.NewGuid().ToString()),newurl;
                int insertPos = url.Length - 2;
                newurl = url.Insert(insertPos, '\0'.ToString());
                XRLWriteFile    writeReq = new XRLWriteFile("ServiceAddr",newurl);

                if(WriteFileTestNegative(writeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass one nullchar at the end of <pathpart>"), TestCasePriority(2)]
            class NPathnameBadString5 : GlobalTitleWFNegTestBase
        {
            override protected void Execute()
            {
                string url= string.Format("//title.{0}/t:{0}/{1}", ((uint)RandomEx.GlobalRandGen.Next()).ToString("X"), Guid.NewGuid().ToString()),newurl;
                newurl = url + '\0'.ToString();
                XRLWriteFile    writeReq = new XRLWriteFile("ServiceAddr",newurl);

                if(WriteFileTestNegative(writeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("<Domain-part> is missing in pathname"), TestCasePriority(2)]
            class NPathnameNoDomainPart : GlobalTitleWFNegTestBase
        {
            override protected void Execute()
            {
                string url = string.Format("/t:{0}/{1}", ((uint)RandomEx.GlobalRandGen.Next()).ToString("X"), Guid.NewGuid().ToString());
                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);

                if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass a pathname that has no ID namespace (t)"), TestCasePriority(2)]
            class NPathnameNoIDNameSpace : GlobalTitleWFNegTestBase
        {
            override protected void Execute()
            {
                string url = string.Format("//title.{0}/{1}", ((uint)RandomEx.GlobalRandGen.Next()).ToString("X"), "/" + Guid.NewGuid().ToString());
                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);

                if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass a pathname that is greater than 255"), TestCasePriority(2)]
            class NPathnameOverflowPathname : GlobalTitleWFNegTestBase
        {
            override protected void Execute()
            {
                string url= string.Format("//title.{0}/t:{0}/{1}", ((uint)RandomEx.GlobalRandGen.Next()).ToString("X"), Guid.NewGuid().ToString());
                StringBuilder    pathName = new StringBuilder(url);
                int        i = 0, numCharToAdd = 256 - url.Length;
                while(i < numCharToAdd)
                    pathName.Append(i++);

                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",pathName.ToString());

                if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass a pathname that has special chars"), TestCasePriority(2)]
            class NPathnameWrongCharSet : GlobalTitleWFNegTestBase
        {
            override protected void Execute()
            {
                string url= string.Format("//title.{0}/t:{0}/{1}{2}", ((uint)RandomEx.GlobalRandGen.Next()).ToString("X"), Guid.NewGuid().ToString(),'\0');

                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                //Bug 27831: domain and optional domain specified: A-Za-z0-9_
                // pathname allows anything except control chars('\0\, control characters, etc)

                if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        //        [TestCase, Description("35328:invalid XRL format--won't fix"), TestCasePriority(2)]
//            class NPathnameInvalidPart : GlobalTitleWFNegTestBase
//        {
//            override protected void Execute()
//            {
//                string url= "//title.125626/u:125626/" + Guid.NewGuid().ToString();
//
//                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
//
//                if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
//                    ResultCode=TEST_RESULTS.PASSED;
//            }
//        }
        /*****************************************************************
         *  Other Testing
         *****************************************************************/
		// bug 38096
        [TestCase, Description("Check X-Delay in the http response")]
            class PThrottling : GlobalTitleWFTestBase
        {
            override protected void Execute()
            {
                string url= string.Format("//title.{0}/t:{0}/{1}", ((uint)RandomEx.GlobalRandGen.Next()).ToString("X"), Guid.NewGuid().ToString());
                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);

				int Xdelay= 3000;
				Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage,"exec :stfd SetXDelay "+req.uiTitleId.ToString("X")+" writefile "+Xdelay);

                if(WriteFileSendAndVerify(req) && (req.XDelay == Xdelay))
                    ResultCode=TEST_RESULTS.PASSED;

				Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage,"exec :stfd ReloadThrottleConfig");

            }
        }
        [TestCase, Description("the titleID in the request is not the acutal logged on title")]
            class PFamilyTitleID : GlobalTitleWFTestBase
        {
            override protected void Execute()
            {

                uint titleId = (uint)RandomEx.GlobalRandGen.Next();
                string url = string.Format("//title.{0}/t:{0}/{1}", titleId.ToString("X"), Guid.NewGuid().ToString());
                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                req.Slot.titleId = 0x89898;
                req.Slot.altTitleId1 = 0x1234;

                if(WriteFileSendAndVerify(req))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }

        // Xenon bug #48202 - "storage: overwriting a 0 byte file increments TotalFilesUsed"
        [TestCase, Description("update an existing 0 length file; verify TotalFilesUsed counter is not incremented")]
        class PUpdateExistingZeroLenFile : TestBase
        {
            private RandomEx RandGen = new RandomEx();

            private void GetQuota(uint domainId, uint titleID, out ulong bytesUsed, out uint filesUsed)
            {
                XRLGetQuota getQuotaReq = new XRLGetQuota(domainId, titleID, (uint)Constants.IdType.TitleId, titleID);
                XRLGetQuotaResponse	getQuotaResp;
                if (!getQuotaReq.Execute(out getQuotaResp))
                {
                    throw new Exception("getQuotaReq.Execute failed");
                }
                bytesUsed = getQuotaResp.totalBytesUsed;
                filesUsed = getQuotaResp.totalFilesUsed;
            }

            private void VerifyQuota(uint domainId, uint titleID, ulong expectedBytesUsed, uint expectedFilesUsed)
            {
                // Verify the TotalFilesUsed counter was incremented
                ulong actualBytesUsed;
                uint actualFilesUsed;
                GetQuota(domainId, titleID, out actualBytesUsed, out actualFilesUsed);
                if (actualBytesUsed != expectedBytesUsed)
                {
                    throw new Exception("actualBytesUsed != expectedBytesUsed");
                }
                if (actualFilesUsed != expectedFilesUsed)
                {
                    throw new Exception("actualFilesUsed != expectedFilesUsed");
                }
            }

            private XRLReadFileResponse WriteFileSafe(XRLWriteFile WriteFileReq, string url, uint titleID)
            {
                if(!WriteFileReq.Execute())
                {
                    throw new Exception("WriteFileReq.Execute failed: " + WriteFileReq.xAct.XErr);
                }

                // Read the file to verify successful WriteFile request
                XRLReadFile ReadFileReq = new XRLReadFile(url);
                ReadFileReq.Slot.titleId = ReadFileReq.uiTitleId = titleID;
                ReadFileReq.Slot.titleVersion = ReadFileReq.uiTitleVersion = WriteFileReq.uiTitleVersion;
                XRLReadFileResponse ReadFileResp;
                if (!ReadFileReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out ReadFileResp))
                {
                    throw new Exception("ReadFileReq.Execute failed");
                }
                if (!ReadFileResp.Compare(WriteFileReq))
                {
                    throw new Exception("ReadFileResp.Compare failed");
                }
                if (!WriteFileReq.Verify())
                {
                    throw new Exception("WriteFileReq.Verify failed");
                }
                return(ReadFileResp);
            }

            override protected void Execute()
            {
                uint randomTitleID = (uint)RandGen.Next();
                string sTitleID = randomTitleID.ToString("x");
                string url = "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

                // Get the relevant counters before any files are added
                ulong originalBytesUsed;
                uint originalFilesUsed;
                GetQuota((uint)Constants.StorageDomain.Title, randomTitleID, out originalBytesUsed, out originalFilesUsed);

                // Zero length data blob for the first request
                XRLWriteFile WriteFileReq1 = new XRLWriteFile("ServiceAddr", url, 0, false);
                XRLReadFileResponse ReadFileResp1 = WriteFileSafe(WriteFileReq1, url, randomTitleID);
                if (ReadFileResp1.blobData.Length != 0)
                {
                    throw new Exception("ReadFileResp1.blobData.Length != 0");
                }
                // Verify the TotalFilesUsed counter was incremented
                VerifyQuota((uint)Constants.StorageDomain.Title, randomTitleID, 
                            originalBytesUsed, originalFilesUsed + 1);

                // Update the same file, this time with a non-zero length data blob
                XRLWriteFile WriteFileReq2 = new XRLWriteFile("ServiceAddr", url, 1024, false, WriteFileReq1.uiTitleVersion);
                if(!WriteFileReq2.Execute())
                {
                    throw new Exception("WriteFileReq2.Execute failed: " + WriteFileReq2.xAct.XErr);
                }

                // Verify the TotalFilesUsed counter was not incremented
                VerifyQuota((uint)Constants.StorageDomain.Title, randomTitleID, 
                            originalBytesUsed + WriteFileReq2.uiBlobSizeCompressed, originalFilesUsed + 1);
                ResultCode=TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("update an existing file;old blob will be deleted")]
            class PUpdateExistingFile1 : TestBase
        {
            override protected void Execute()
            {
                uint    randomTitleID = (uint)RandomEx.GlobalRandGen.Next();
                string    sTitleID = randomTitleID.ToString("x");
                string url= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

                XRLWriteFile    req1 = new XRLWriteFile("ServiceAddr",url), req2 = new XRLWriteFile("ServiceAddr",url);

                // make sure the two blobs are different
                req2.blobHash[1] = (byte)(req1.blobHash[1]+1);

                if(req1.Execute())
                {    // update the same file
                    if(req2.Execute())
                    {
                        // read the file
                        XRLReadFileResponse    ReadFileResp;
                        XRLReadFile            ReadFileReq = new XRLReadFile(url);
                        ReadFileReq.Slot.titleId = ReadFileReq.uiTitleId = randomTitleID;
                        ReadFileReq.Slot.titleVersion = ReadFileReq.uiTitleVersion = req2.uiTitleVersion;
                        if (ReadFileReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out ReadFileResp))
                        {
                            if ((ReadFileResp.Compare(req2)) || (req2.Verify()))
                                ResultCode=TEST_RESULTS.PASSED;
                        }
                    }
                }
            }
        }

        [TestCase, Description("update an existing file;old blob still exisits(have reference)")]
            class PUpdateExistingFile2 : TestBase
        {
            override protected void Execute()
            {
                uint    randomTitleID = (uint)RandomEx.GlobalRandGen.Next();
                string    sTitleID = randomTitleID.ToString("x");
                string url1= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();
                string url2= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

                XRLWriteFile    req1 = new XRLWriteFile("ServiceAddr",url1), req2 = new XRLWriteFile("ServiceAddr",url2);

                // make sure the two blob are identical; so we will have two referencs for the same blob
                req2.blobDataLen = req1.blobDataLen;
                req2.uiBlobSizeCompressed = req1.uiBlobSizeCompressed;
                for(int i = 0; i < req1.blobDataLen; i++)
                    req2.blobData[i] = req1.blobData[i];
                for(int i = 0; i < Constants.sizeHash; i++)
                    req2.blobHash[i] = req1.blobHash[i];

                if(req1.Execute() && req2.Execute())
                {
                    // use one of the url to update the blob
                    XRLWriteFile    updateReq = new XRLWriteFile("ServiceAddr",url1);
                    // make sure the two blobs are different
                    updateReq.blobHash[1] = (byte)(req1.blobHash[1]+1);

                    if(updateReq.Execute())
                    {    // the old blob's i_ref_count will be decremented; blob still exists
                        // a new blob will be created with i_ref_count is 1
                        // read the old blob with url2
                        XRLReadFileResponse        ReadOldBlobResp, ReadNewBlobResp;
                        XRLReadFile            ReadOldBlobReq = new XRLReadFile(url2),ReadNewBlobReq=new XRLReadFile(url1);
                        ReadOldBlobReq.Slot.titleId = ReadOldBlobReq.uiTitleId = randomTitleID;
                        ReadOldBlobReq.Slot.titleVersion = ReadOldBlobReq.uiTitleVersion = req2.uiTitleVersion;
                        if (ReadOldBlobReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out ReadOldBlobResp))
                        {
                            if ((ReadOldBlobResp.Compare(req2)) || (req2.Verify()))
                            {
                                // old blob still exist; check the new blob
                                ReadNewBlobReq.Slot.titleId = ReadNewBlobReq.uiTitleId = randomTitleID;
                                ReadNewBlobReq.Slot.titleVersion = ReadNewBlobReq.uiTitleVersion = updateReq.uiTitleVersion;
                                if(ReadNewBlobReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out ReadNewBlobResp))
                                    ResultCode=TEST_RESULTS.PASSED;
                            }
                        }
                    }
                }
            }
        }

        [TestCase, Description("data blob are identical,titleID are the same so mapped to same webstore partition")]
            class PSameFileUploadTwice : GlobalTitleWFTestBase
        {
            override protected void Execute()
            {
                uint    randomTitleID = (uint)RandomEx.GlobalRandGen.Next();
                string    sTitleID = randomTitleID.ToString("x");
                string url1= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();
                string url2= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();
                XRLWriteFile    req1 = new XRLWriteFile("ServiceAddr",url1), req2 = new XRLWriteFile("ServiceAddr",url2);

                req2.blobDataLen = req1.blobDataLen;
                req2.uiBlobSizeCompressed = req1.uiBlobSizeCompressed;
                for(int i = 0; i < req1.blobDataLen; i++)
                    req2.blobData[i] = req1.blobData[i];

                for(int i = 0; i < Constants.sizeHash; i++)
                    req2.blobHash[i] = req1.blobHash[i];

                if((WriteFileSendAndVerify(req1)) && (WriteFileSendAndVerify(req2)))
                {
                    // do other  additional check
                    if(req1.CheckRefCount(req2,2, true))
                        ResultCode=TEST_RESULTS.PASSED;
                }
            }
        }
        // need to use titleID so that they mapped to same logical partition
        [TestCase, Description("same fileSize and hash, but blob are different")]
            class PSameHashDiffrentFileContent : GlobalTitleWFTestBase
        {
            override protected void Execute()
            {
                uint    randomTitleID = (uint)RandomEx.GlobalRandGen.Next();
                string    sTitleID = randomTitleID.ToString("x");
                string url1= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();
                string url2= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();
                XRLWriteFile    req1 = new XRLWriteFile("ServiceAddr",url1), req2 = new XRLWriteFile("ServiceAddr",url2);

                req2.blobDataLen = req1.blobDataLen;
                req2.uiBlobSizeCompressed = req1.uiBlobSizeCompressed;

                // reenforce the two files to have different contents
                req2.blobData[9] = (byte)((int)req1.blobData[9]+ 1);

                for(int i = 0; i < Constants.sizeHash; i++)
                    req2.blobHash[i] = req1.blobHash[i];

                if((WriteFileSendAndVerify(req1)) && (WriteFileSendAndVerify(req2)))
                {
                    // do other additional check
                    if(req1.CheckRefCount(req2,1,false))
                        ResultCode=TEST_RESULTS.PASSED;
                }
            }
        }
        // This is how webstore repartition works; there will be two rows
        // added in both t_files and t_blobs
        [TestCase, Description("data blob are identical, but different titleID and xrl for two writeFile requests")]
            class PSameFileUploadTwiceByDifferentUser : GlobalTitleWFTestBase
        {
            override protected void Execute()
            {
                uint    randomTitleID = (uint)RandomEx.GlobalRandGen.Next();
                string    sTitleID = randomTitleID.ToString("x");
                string url1= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();
                string url2= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();
                XRLWriteFile    req1 = new XRLWriteFile("ServiceAddr",url1), req2 = new XRLWriteFile("ServiceAddr",url2);

                req2.blobDataLen = req1.blobDataLen;
                req2.uiBlobSizeCompressed = req1.uiBlobSizeCompressed;
                for(int i = 0; i < req1.blobDataLen; i++)
                    req2.blobData[i] = req1.blobData[i];
                for(int i = 0; i < Constants.sizeHash; i++)
                    req2.blobHash[i] = req1.blobHash[i];

                if((WriteFileSendAndVerify(req1)) && (WriteFileSendAndVerify(req2)))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Multiple threads write a file simultaneously")]
            class PMultiThreadsWriteFile : GlobalTitleWFTestBase
        {
            override protected void Execute()
            {
                Thread [] threadArray = new Thread[10];
                for(int i = 0; i < 10; i++)
                {
                    threadArray[i] = ThreadMaker.CreateThread(writeFileTS);
                    threadArray[i].Name = i.ToString();
                    threadArray[i].Start();
                }
                // the main thread is waiting for all threads to exit or timeout
                foreach (Thread t in threadArray)
                    t.Join(10000);
                if(FailedReqs == 0)
                    ResultCode=TEST_RESULTS.PASSED;
            }
            private void writeFileTS()
            {
                uint    randomTitleID = (uint)RandomEx.GlobalRandGen.Next();
                string    sTitleID = randomTitleID.ToString("x");
                string url= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

                XRLWriteFile    writeReq = new XRLWriteFile("ServiceAddr",url);
                if(!WriteFileSendAndVerify(writeReq))
                {
                    Global.RO.Warn(Thread.CurrentThread.Name+"writeFileTS: write file request/verify failed");
                    Interlocked.Increment(ref FailedReqs);
                }
            }
            private    int FailedReqs = 0;
        }
        [TestCase, Description("write file 50 times")]
            class PWriteFileMultiTimes : GlobalTitleWFTestBase
        {
            override protected void Execute()
            {
                uint            uiFailedReq = 0;
                for(int i = 0; i < 50; i++)
                {
                    uint    randomTitleID = (uint)RandomEx.GlobalRandGen.Next();
                    string    sTitleID = randomTitleID.ToString("x");
                    string url= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();

                    XRLWriteFile    writeReq = new XRLWriteFile("ServiceAddr",url);
                    if(!WriteFileSendAndVerify(writeReq))
                        uiFailedReq++;
                }
                if(uiFailedReq == 0)
                    ResultCode=TEST_RESULTS.PASSED;
                else
                    Global.RO.Warn("It failed " + uiFailedReq.ToString() + " times");
            }
        }

        /* Can't write this to the dash title anymore...
        /// <summary>
        /// Writes 5000 200K files to completely max the Xenon dash title ID storage space quotas
        /// </summary>
        [TestCase, Description("xenon bug37083:increase quota for web title id")]
        class PMaxBanners : GlobalTitleWFTestBase
        {
            private RandomEx RandGen = new RandomEx();

            private void WriteBanner(ref object state)
            {
                // Use Xenon dash title ID, not web title-ID or a random title ID
                string url = "//title.fffe07d1/t:fffe07d1/" + Guid.NewGuid().ToString();

                XRLWriteFile writeReq = new XRLWriteFile("ServiceAddr", url);
                writeReq.blobData = new byte[200 * 1024];
                RandGen.NextBytes(writeReq.blobData);
                writeReq.blobDataLen = writeReq.uiBlobSizeCompressed = (uint)writeReq.blobData.Length;

                if (!writeReq.Execute())
                {
                    throw new UnexpectedTestResultException("WriteFile request failed: " +
                        Global.XErrToString(writeReq.XErr));
                }
            }

            override protected void Execute()
            {
                SimpleJobMgr jobMgr = new SimpleJobMgr();
                uint uiFailedReq = 0;
                for (int i = 0; i < 5000; i++)
                {
                    jobMgr.AddJob(WriteBanner, null);
                }
                jobMgr.StartJobs(15);
                while (!jobMgr.Empty())
                {
                    SimpleJobMgr.Job job = jobMgr.GetCompletedJob();
                    if (job.Exception != null)
                    {
                        Global.RO.Error(job.Exception.Message);
                        uiFailedReq++;
                    }
                }
                if (uiFailedReq == 0)
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    Global.RO.Warn("WriteFile request failed " + uiFailedReq.ToString() + " times");
                }
            }
        }
        */

        //        [TestCase, Description("send GlobalTitleStorage request to port 80 other than 11140"), TestCasePriority(2)]
        //        class NNonDCRequest : TestBase
        //        {
        //            override protected void Execute()
        //            {
        //                string url= "//title.125626/u:125626/" + Guid.NewGuid().ToString();
        //                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
        //                req.Server.EPDefault.Port = 80;
        //
        //                if(    !req.Execute() &&
        //                    (req.XErr == HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
        //                    ResultCode=TEST_RESULTS.PASSED;
        //            }
        //        }
        /***********************************************************************
        * Tsunami: HTTPAuth Data header testing
        ***********************************************************************/
        // bug 33194
        [TestCase, Description("the TitleID in HTTPAuthData header is different than the one in the WriteFile request"), TestCasePriority(2)]
            class NSGAuthInvalidTitleID : GlobalTitleWFNegTestBase
        {
            override protected void Execute()
            {
                string url= string.Format("//title.{0}/t:{0}/", ((uint)RandomEx.GlobalRandGen.Next()).ToString("X")) + Guid.NewGuid().ToString();
                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                uint            titleID = req.uiTitleId + 1;
                ulong    requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
                uint    ip = 0;
                byte [] addr = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).Address.GetAddressBytes();
                for(int i = 0; i < addr.Length; i++)
                    ip = (ip << 8) + addr[i];
                HTTPAuthData authData = new HTTPAuthData((ushort) Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int).Port,
                    ip,requestId,0,titleID,(uint)XOService.Storage,0);
                authData.dwTitleVersion = req.uiTitleVersion;
                req.CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" +
                    authData.GetBase64EncodedString() + "\r\n";

                if(WriteFileTestNegative(req,HResult.XONLINE_E_INVALID_TITLE_ID))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("the TitleVersion in HTTPAuthData is different than the one in the WriteFile request"), TestCasePriority(2)]
            class NSGAuthInvalidTitleVersion : GlobalTitleWFNegTestBase
        {
            override protected void Execute()
            {
                string url= string.Format("//title.{0}/t:{0}/", ((uint)RandomEx.GlobalRandGen.Next()).ToString("X")) + Guid.NewGuid().ToString();
                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                ulong    requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
                uint    ip = 0;
                byte [] addr = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).Address.GetAddressBytes();
                for(int i = 0; i < addr.Length; i++)
                    ip = (ip << 8) + addr[i];
                HTTPAuthData authData = new HTTPAuthData((ushort) Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int).Port,
                    ip,requestId,0,0x125626,(uint)XOService.Storage,0);
                authData.dwTitleVersion = req.uiTitleVersion + 1;
                req.CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" +
                    authData.GetBase64EncodedString() + "\r\n";

                //if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
                if (WriteFileTestNegative(req, HResult.XONLINE_E_INVALID_TITLE_ID))                
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("the Service ID in HTTPAuthData is different than the one in WriteFile request"), TestCasePriority(2)]
            class nSGAuthInvalidServiceID : GlobalTitleWFNegTestBase
        {
            override protected void Execute()
            {
                string url= string.Format("//title.{0}/t:{0}/", ((uint)RandomEx.GlobalRandGen.Next()).ToString("X")) + Guid.NewGuid().ToString();
                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                ulong    requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
                uint    ip = 0;
                byte [] addr = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).Address.GetAddressBytes();
                for(int i = 0; i < addr.Length; i++)
                    ip = (ip << 8) + addr[i];
                HTTPAuthData authData = new HTTPAuthData((ushort) Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int).Port,
                    ip,requestId,0,0x125626,(uint)XOService.Arbitration,0);
                authData.dwTitleVersion = req.uiTitleVersion + 1;
                req.CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" +
                    authData.GetBase64EncodedString() + "\r\n";

                if(WriteFileTestNegative(req,HResult.XONLINE_E_SERVER_ERROR))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        /***********************************************************************
        * Tsunami: Quota testing
        ***********************************************************************/
        [TestCase, Description("34942:create max allowed # of files;remove some files; check quota being updated")]
            class PQuotaMaxFiles : TestBase
        {
            override protected void Execute()
            {
                uint    randomTitleID = (uint)RandomEx.GlobalRandGen.Next();
                string    sTitleID = randomTitleID.ToString("x");
                string [] removedUrls = new string[5];
                uint    [] removedFileSize = new uint[5];

                // create a file for this title first to fill out the t_quotas table
                string url= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();
                removedUrls[0] = url;
                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                req.attributes = new byte[100];
                new Random().NextBytes(req.attributes);
                req.attributesLen = (ushort)req.attributes.Length;
                if(req.Execute())
                    removedFileSize[0] = req.blobDataLen;

                XRLGetQuota        getQuotaReq = new XRLGetQuota(1,randomTitleID,(uint)Constants.IdType.TitleId ,randomTitleID);
                XRLGetQuotaResponse    getQuotaResp;
                ulong            maxFileSize=0;
                ulong            totalBytesMax=0;
                uint            totalFilesMax=0;
                ulong            start_BytesUsed=0, actualBytesUsed=0, removedBytes = 0;
                uint            start_FilesUsed=0, removedFiles = 0;
                if(getQuotaReq.Execute(out getQuotaResp))
                {
                    maxFileSize = getQuotaResp.maxFileSize;
                    totalBytesMax = getQuotaResp.totalBytesMax;
                    totalFilesMax = getQuotaResp.totalFilesMax;
                    start_BytesUsed = getQuotaResp.totalBytesUsed;
                    start_FilesUsed = getQuotaResp.totalFilesUsed;
                }
                else
                {
                    Global.RO.Warn("GetQuota request1 failed");
                    return;
                }
                uint failed = 0;
                for(int i = 1; i <= (totalFilesMax-start_FilesUsed); i++)
                {
                    url= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();
                    req = new XRLWriteFile("ServiceAddr",url);
                    req.attributes = new byte[100];
                    new Random().NextBytes(req.attributes);
                    req.attributesLen = (ushort)req.attributes.Length;
                    if(!req.Execute())
                    {
                        failed++;
                        return;
                    }
                    actualBytesUsed += req.blobDataLen;
                    if(i < 5)
                    {
                        removedUrls[i] = url;
                        removedFileSize[i] = req.blobDataLen;
                    }
                }
                if(failed == 0) // max # of files created for this title
                {    // check quota again
                    XRLGetQuota        gQReq = new XRLGetQuota(1,randomTitleID,(uint)Constants.IdType.TitleId ,randomTitleID);
                    XRLGetQuotaResponse    gQResp;
                    if(gQReq.Execute(out gQResp))
                    {
                        if((gQResp.totalFilesUsed == gQResp.totalFilesMax) &&
                            (gQResp.totalBytesUsed == (start_BytesUsed+actualBytesUsed)))
                        {// remove some files then check quota again
                            for(int i = 0; i < 5; i++)
                            {
                                XRLRemoveFile    removeReq = new XRLRemoveFile(removedUrls[i],randomTitleID,"ServiceAddr");
                                if(removeReq.Execute())
                                {
                                    removedFiles++;
                                    removedBytes += removedFileSize[i];
                                }
                            }
                            // check quota again
                            XRLGetQuota        gQReq2 = new XRLGetQuota(1,randomTitleID,(uint)Constants.IdType.TitleId ,randomTitleID);
                            XRLGetQuotaResponse    gQResp2;
                            if(gQReq2.Execute(out gQResp2))
                            {
                                if(gQResp2.totalFilesUsed == (gQResp2.totalFilesMax-removedFiles)&&
                                    (gQResp2.totalBytesUsed == (start_BytesUsed+actualBytesUsed-removedBytes)))
                                    ResultCode=TEST_RESULTS.PASSED;
                            }
                        }
                    }
                }
            }
        }
        [TestCase, Description("34977:create a file with multi ref, check quota; remove one ref check quota again")]
            class PQuotaFilesWithMultiRef : TestBase
        {
            override protected void Execute()
            {
                uint    randomTitleID = (uint)RandomEx.GlobalRandGen.Next();
                string    sTitleID = randomTitleID.ToString("x");

                ulong            maxFileSize=0;
                ulong            totalBytesMax=0;
                uint            totalFilesMax=0;
                ulong            start_BytesUsed=0;
                uint            start_FilesUsed=0;
                // create a file for this title first to fill out the t_quotas table
                string url= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();
                XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                if(req.Execute())
                {
                    XRLGetQuota        getQuotaReq = new XRLGetQuota(1,randomTitleID,(uint)Constants.IdType.TitleId ,randomTitleID);
                    XRLGetQuotaResponse    getQuotaResp;
                    if(getQuotaReq.Execute(out getQuotaResp))
                    {
                        maxFileSize = getQuotaResp.maxFileSize;
                        totalBytesMax = getQuotaResp.totalBytesMax;
                        totalFilesMax = getQuotaResp.totalFilesMax;
                        start_BytesUsed = getQuotaResp.totalBytesUsed;
                        start_FilesUsed = getQuotaResp.totalFilesUsed;
                    }
                    else
                    {
                        Global.RO.Warn("GetQuota request1 failed");
                        return;
                    }
                }
                else
                    return;
                // create a blob with two references
                string url1= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();
                string url2= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();
                XRLWriteFile    req1 = new XRLWriteFile("ServiceAddr",url1), req2 = new XRLWriteFile("ServiceAddr",url2);

                req2.blobDataLen = req1.blobDataLen;
                req2.uiBlobSizeCompressed = req1.uiBlobSizeCompressed;
                for(int i = 0; i < req1.blobDataLen; i++)
                    req2.blobData[i] = req1.blobData[i];
                for(int i = 0; i < Constants.sizeHash; i++)
                    req2.blobHash[i] = req1.blobHash[i];

                if(req1.Execute() && req2.Execute())
                {
                    XRLGetQuota        gQReq = new XRLGetQuota(1,randomTitleID,(uint)Constants.IdType.TitleId ,randomTitleID);
                    XRLGetQuotaResponse    gQResp;
                    if(gQReq.Execute(out gQResp))
                    {
                        if((gQResp.totalFilesUsed == (start_FilesUsed+2)) &&
                            (gQResp.totalBytesUsed == (start_BytesUsed+req1.blobDataLen+req2.blobDataLen)))
                        {// remove one ref then check quota again
                            XRLRemoveFile    removeReq = new XRLRemoveFile(url1,randomTitleID,"ServiceAddr");
                            if(removeReq.Execute())
                            {        // check quota again
                                XRLGetQuota        gQReq2 = new XRLGetQuota(1,randomTitleID,(uint)Constants.IdType.TitleId ,randomTitleID);
                                XRLGetQuotaResponse    gQResp2;
                                if(gQReq2.Execute(out gQResp2))
                                {    // totalBytesUsed and fileUsed should be changed.
                                    if(gQResp2.totalFilesUsed == (start_FilesUsed+1)&&
                                        (gQResp2.totalBytesUsed == (start_BytesUsed+req2.blobDataLen)))
                                        ResultCode=TEST_RESULTS.PASSED;
                                }
                            }
                        }
                    }
                }
            }
        }
        [TestCase, Description("create >max # allowed files, but byteUsed still within limit "), TestCasePriority(2)]
            class NQuotaOverflowTotalFiles : GlobalTitleWFNegTestBase
        {
            override protected void Execute()
            {
                // This test assume no files/bytes exist for this title
                uint    randomTitleID = (uint)RandomEx.GlobalRandGen.Next();
                string    sTitleID = randomTitleID.ToString("x");
                ulong    actualBytesUsed = 0;
                uint    totalFilesMax = 50;
                ulong    totalBytesMax = 5*1024*1024;//GlobalTitle

                uint failed = 0;
                for(int i = 0; i < totalFilesMax; i++)
                {
                    string url= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();
                    XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                    if(!req.Execute())
                    {
                        failed++;
                        return;
                    }
                    actualBytesUsed += req.blobDataLen;
                }
                if(failed == 0) // max # of files created for this title
                {    // create another file
                    string url= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();
                    XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                    ulong    totalActualBytes = actualBytesUsed+req.blobDataLen;
                    if(totalActualBytes<=totalBytesMax)
                        if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_QUOTA_EXCEEDED))
                            ResultCode=TEST_RESULTS.PASSED;
                        else
                            Global.RO.Warn("Total number of files used is over limit");
                }
            }
        }
        [TestCase, Description("create >max allowed bytes, but # of filesUsed still within limit "), TestCasePriority(2)]
            class NQuotaOverflowTotalBytes : GlobalTitleWFNegTestBase
        {
            override protected void Execute()
            {
                // This test assume no files/bytes exist for this title
                uint    randomTitleID = (uint)RandomEx.GlobalRandGen.Next();
                string    sTitleID = randomTitleID.ToString("x");
                ulong    actualBytesUsed = 0;

                // for GlobalTitle: bytesMax is 5MB, maxFiles is 50, maxSize = 5MB
                // so create 5 files each one is 1MB, then create aother one with 1 byte, which should fail
                uint failed = 0;
                for(int i = 0; i < 5; i++)
                {
                    string url= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();
                    XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                    req.blobDataLen = req.uiBlobSizeCompressed = 1024*1024;
                    req.blobData = new byte[1024*1024];
                    new Random().NextBytes(req.blobData);
                    if(!req.Execute())
                    {
                        failed++;
                        return;
                    }
                    actualBytesUsed += req.blobDataLen;
                }
                if(failed == 0) // maxBytes created for the title
                {    // create another file
                    string url= "//title."+sTitleID+"/t:"+sTitleID+"/" + Guid.NewGuid().ToString();
                    XRLWriteFile    req = new XRLWriteFile("ServiceAddr",url);
                    req.blobDataLen = req.uiBlobSizeCompressed = 1;
                    req.blobData = new byte[1];
                    new Random().NextBytes(req.blobData);

                    if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_QUOTA_EXCEEDED))
                        ResultCode=TEST_RESULTS.PASSED;
                    else
                        Global.RO.Warn("Total bytes used is over limit");
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\FuncReportBrokenLink.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Storage;
using xonline.common.config;

namespace XStoreTest
{
	/// <summary>
	/// Summary description for FuncReportBrokenLink.
	/// </summary>
    [TestGroup, Owner("JKonkle"), TestFrequency("Regression"), TestCasePriority(1)]
	public class FuncReportBrokenLink : TestNode
	{
		[TestCase, Description("call reportBrokenLink and check if there is event being logged at stfd")]
			class PNormalCase : TestBase
		{
			override protected void Execute()
			{
				XRLReportBrokenLink		req = new XRLReportBrokenLink("stats");
				if(req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\FuncNameResolver.cs ===
using System;
using System.Net;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Storage;
using xonline.common.config;

namespace XStoreTest
{
    internal abstract class NameResolverTestBase : TestBase
    {
        public IPEndPoint GetSGVirtualInterface()
        {
            return Global.XEnv.GetVirtualInterface(VirtualInterface.sgsvc); // , 5);
        }

        //	send WriteFile request first; then send readfile;verifies the response
        protected bool NameResolverSendAndVerify(XRLNameResolver req, string ExpectedRule,IPEndPoint ExpectedPrim, int RuleExpiration)
        {
            XRLNameResolverResponse resp;
            if (req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_name_resolution), out resp))
            {
                IPAddress actualPrimIP, alternateIP;
                actualPrimIP = new IPAddress(resp.uiPrimaryIP);
                alternateIP = new IPAddress(resp.uiAlternateIP);

                // check primary IP/port: primary IP will be got from NPDB, but port is hardcoded as 15
                if (!actualPrimIP.Equals(ExpectedPrim.Address) || (resp.usPrimaryPort != (ushort)XOService.Storage))
                {
                    Global.RO.Warn("The returned PrimaryIP/port " + actualPrimIP.ToString() + "/" + resp.usPrimaryPort + " is wrong" +
                                    " Expected IP/port " + ExpectedPrim.ToString());
                    return false;
                }

                // Xenon: the alternative SG IP address and port will be 0
                if (!alternateIP.Equals(new IPAddress(0)) || resp.usAlternatePort != 0)
                {
                    Global.RO.Warn("The returned AlternateIP/port " + alternateIP.ToString() + "/" + resp.usAlternatePort + " should be 0");
                    return false;
                }

                // stfd.ini: RuleExpirationHours=3
                // time difference is 100 second is tolerable
                if ((resp.lExpiration - System.DateTime.UtcNow.AddHours(RuleExpiration).ToFileTimeUtc()) / 10000000 > 100)
                {
                    Global.RO.Warn("The returned ruleExpiration " + resp.lExpiration.ToString() + " is wrong");
                    return false;
                }
                // check rule
                string ActualRule = new ASCIIEncoding().GetString(resp.Rule);
                if (ExpectedRule.Equals(ActualRule))
                    return true;
                else
                {
                    Global.RO.Warn("The rule " + ActualRule + " returned is wrong");
                    return false;
                }
            }
            else
            {
                Global.RO.Warn("Failed send NameResolver request");
                return false;
            }
        }
    }

    internal abstract class NegativeNRTestBase : TestBase
    {
        //	send readFile requests, then check the error code
        protected bool NRTestNegative(XRLNameResolver Req, uint XErr)
        {
            XRLNameResolverResponse resp;
            if (Req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out resp))
            {
                Global.RO.Warn("Negative NameResolver request succeed unexpectedly");
                return false;
            }
            if ((Req.XErr != XErr) || (resp != null))
            {
                Global.RO.Warn("Wrong error code " + Global.XErrToString(Req.XErr) + " returned or Resp is not null");
                return false;
            }
            return true;
        }
    }

    [TestGroup, Owner("trevorm"), TestFrequency("Regression"), TestCasePriority(1)]
    public class FuncNameResolver : TestBaseGroup
    {
        [TestCase, Description("")]
        class PThrottling : NameResolverTestBase
        {
            //This test doesn't make any sense since it is not title id specific
            override protected void Execute()
            {
                IPEndPoint ExpectedPrimIP = GetSGVirtualInterface();
                string pathName = "stats";
                XRLNameResolver req = new XRLNameResolver(pathName);

                int Xdelay = 3000;
                Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage, "exec :stfd SetXDelay 0 resolvename " + Xdelay);

                if (NameResolverSendAndVerify(req, "stats", ExpectedPrimIP, 3) &&
                    (req.XDelay == Xdelay))
                    ResultCode = TEST_RESULTS.PASSED;

                Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage, "exec :stfd ReloadThrottleConfig");
            }
        }

        [TestCase, Description("pass stats/title/tuser/tteam/msg for domain part")]
        class PNormalCase : NameResolverTestBase
        {
            override protected void Execute()
            {
                IPEndPoint ExpectedPrimIP = GetSGVirtualInterface();
                XRLNameResolver req1 = new XRLNameResolver("stats");
                XRLNameResolver req2 = new XRLNameResolver("title");
                XRLNameResolver req3 = new XRLNameResolver("tuser");
                XRLNameResolver req4 = new XRLNameResolver("tteam");
                XRLNameResolver req5 = new XRLNameResolver("msg");

                if (NameResolverSendAndVerify(req1, "stats", ExpectedPrimIP, 3) &&
                    NameResolverSendAndVerify(req2, "title", ExpectedPrimIP, 3) &&
                    NameResolverSendAndVerify(req3, "tuser", ExpectedPrimIP, 3) &&
                    NameResolverSendAndVerify(req4, "tteam", ExpectedPrimIP, 3) &&
                    NameResolverSendAndVerify(req5, "msg", ExpectedPrimIP, 3))
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase, Description("pass max length for the domain part (63 unicode chars)")]
        class PMaxLength : NameResolverTestBase
        {
            override protected void Execute()
            {
                string pathName1 = "stats.111111111111111111111111111111111111111111111111111111111";
                string pathName2 = "title.111111111111111111111111111111111111111111111111111111111";
                string pathName3 = "tuser.111111111111111111111111111111111111111111111111111111111";
                string pathName4 = "tteam.111111111111111111111111111111111111111111111111111111111";
                string pathName5 = "msg.11111111111111111111111111111111111111111111111111111111111";
                IPEndPoint ExpectedPrimIP = GetSGVirtualInterface();
                XRLNameResolver req1 = new XRLNameResolver(pathName1);
                XRLNameResolver req2 = new XRLNameResolver(pathName2);
                XRLNameResolver req3 = new XRLNameResolver(pathName3);
                XRLNameResolver req4 = new XRLNameResolver(pathName4);
                XRLNameResolver req5 = new XRLNameResolver(pathName5);
                if (NameResolverSendAndVerify(req1, "stats", ExpectedPrimIP, 3) &&
                    NameResolverSendAndVerify(req2, "title", ExpectedPrimIP, 3) &&
                    NameResolverSendAndVerify(req3, "tuser", ExpectedPrimIP, 3) &&
                    NameResolverSendAndVerify(req4, "tteam", ExpectedPrimIP, 3) &&
                    NameResolverSendAndVerify(req5, "msg", ExpectedPrimIP, 3))
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase, Description("28102:testing rules to NPDB (stats.1.2.3, stats.1.2, stats.1, stats), pass stats.1.2.3")]
        class PRules1 : NameResolverTestBase
        {
            override protected void Execute()
            {	// TODO: need to insert rules to NPDB and then change the IPs/Ports
                // need to use configDB calls to add rules to npdb
                string pathName1 = "stats.1.2.3", pathName2 = "title.1.2.3", pathName3 = "tuser.1.2.3", pathName4 = "tteam.1.2.3", pathName5 = "msg.1.2.3";
                IPEndPoint ExpectedPrimIP = new IPEndPoint(IPAddress.Parse("1.2.3.4"), 1111);
                XRLNameResolver req1 = new XRLNameResolver(pathName1);
                XRLNameResolver req2 = new XRLNameResolver(pathName2);
                XRLNameResolver req3 = new XRLNameResolver(pathName3);
                XRLNameResolver req4 = new XRLNameResolver(pathName4);
                XRLNameResolver req5 = new XRLNameResolver(pathName5);
                if (NameResolverSendAndVerify(req1, "stats.1.2.3", ExpectedPrimIP, 3) &&
                    NameResolverSendAndVerify(req2, "title.1.2.3", ExpectedPrimIP, 3) &&
                    NameResolverSendAndVerify(req3, "tuser.1.2.3", ExpectedPrimIP, 3) &&
                    NameResolverSendAndVerify(req4, "tteam.1.2.3", ExpectedPrimIP, 3) &&
                    NameResolverSendAndVerify(req5, "msg.1.2.3", ExpectedPrimIP, 3))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("28102:testing rules to NPDB (stats.1.2.3, stats.1.2, stats.1, stats), pass stats.1.2.4")]
        class PRules2 : NameResolverTestBase
        {
            override protected void Execute()
            {	//TODO: need to insert rules to NPDB and then change the IPs/Ports
                // need to use configDB calls to add rules to npdb
                string pathName1 = "stats.1.2.4", pathName2 = "title.1.2.4", pathName3 = "tuser.1.2.4", pathName4 = "tteam.1.2.4", pathName5 = "msg.1.2.4";
                IPEndPoint ExpectedPrimIP = new IPEndPoint(IPAddress.Parse("2.3.4.5"), 1112);
                XRLNameResolver req1 = new XRLNameResolver(pathName1);
                XRLNameResolver req2 = new XRLNameResolver(pathName2);
                XRLNameResolver req3 = new XRLNameResolver(pathName3);
                XRLNameResolver req4 = new XRLNameResolver(pathName4);
                XRLNameResolver req5 = new XRLNameResolver(pathName5);
                if (NameResolverSendAndVerify(req1, "stats.1.2", ExpectedPrimIP, 3) &&
                    NameResolverSendAndVerify(req2, "title.1.2", ExpectedPrimIP, 3) &&
                    NameResolverSendAndVerify(req3, "tuser.1.2", ExpectedPrimIP, 3) &&
                    NameResolverSendAndVerify(req4, "tteam.1.2", ExpectedPrimIP, 3) &&
                    NameResolverSendAndVerify(req5, "msg.1.2", ExpectedPrimIP, 3))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("testing rules to NPDB (stats.1.2.3, stats.1.2, stats.1, stats), pass stats.1.4")]
        class PRules3 : NameResolverTestBase
        {
            override protected void Execute()
            {	//TODO: need to insert rules to NPDB and then change the IPs/Ports
                // need to use configDB calls to add rules to npdb
                string pathName1 = "stats.1.4", pathName2 = "title.1.4", pathName3 = "tuser.1.4", pathName4 = "tteam.1.4", pathName5 = "msg.1.4";
                IPEndPoint ExpectedPrimIP = new IPEndPoint(IPAddress.Parse("3.4.5.6"), 6666);
                XRLNameResolver req1 = new XRLNameResolver(pathName1);
                XRLNameResolver req2 = new XRLNameResolver(pathName2);
                XRLNameResolver req3 = new XRLNameResolver(pathName3);
                XRLNameResolver req4 = new XRLNameResolver(pathName4);
                XRLNameResolver req5 = new XRLNameResolver(pathName5);
                if (NameResolverSendAndVerify(req1, "stats.1", ExpectedPrimIP, 3) &&
                    NameResolverSendAndVerify(req2, "title.1", ExpectedPrimIP, 3) &&
                    NameResolverSendAndVerify(req3, "tuser.1", ExpectedPrimIP, 3) &&
                    NameResolverSendAndVerify(req4, "tteam.1", ExpectedPrimIP, 3) &&
                    NameResolverSendAndVerify(req5, "msg.1", ExpectedPrimIP, 3))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("testing rules to NPDB (stats.1.2.3, stats.1.2, stats.1, stats), pass stats.4.1.2")]
        class PRules4 : NameResolverTestBase
        {
            override protected void Execute()
            {	//TODO: need to insert rules to NPDB and then change the IPs/Ports
                string pathName1 = "stats.4.1.2", pathName2 = "title.4.1.2", pathName3 = "tuser.4.1.2", pathName4 = "tteam.4.1.2", pathName5 = "msg.4.1.2";
                IPEndPoint ExpectedPrimIP = GetSGVirtualInterface();
                XRLNameResolver req1 = new XRLNameResolver(pathName1);
                XRLNameResolver req2 = new XRLNameResolver(pathName2);
                XRLNameResolver req3 = new XRLNameResolver(pathName3);
                XRLNameResolver req4 = new XRLNameResolver(pathName4);
                XRLNameResolver req5 = new XRLNameResolver(pathName5);
                if (NameResolverSendAndVerify(req1, "stats", ExpectedPrimIP, 3) &&
                    NameResolverSendAndVerify(req2, "title", ExpectedPrimIP, 3) &&
                    NameResolverSendAndVerify(req3, "tuser", ExpectedPrimIP, 3) &&
                    NameResolverSendAndVerify(req4, "tteam", ExpectedPrimIP, 3) &&
                    NameResolverSendAndVerify(req5, "msg", ExpectedPrimIP, 3))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        //	[TestCase, Description("Manual Test: comment out global RuleExpiration; set one for stats.999")]
        class PRuleExpiration : NameResolverTestBase
        {
            override protected void Execute()
            {	//TODO: need to insert rules to NPDB and then change the IPs/Ports
                string pathName = "stats.999";
                IPEndPoint ExpectedPrimIP = GetSGVirtualInterface();
                XRLNameResolver req = new XRLNameResolver(pathName);
                if (NameResolverSendAndVerify(req, "stats", ExpectedPrimIP, 1))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("pass unsupported domain  for the domain part"), TestCasePriority(2)]
        class NInvalidDomain : NegativeNRTestBase
        {
            override protected void Execute()
            {
                string pathName = "voice";
                XRLNameResolver req = new XRLNameResolver(pathName);
                if (NRTestNegative(req, HResult.XONLINE_E_STORAGE_UNKNOWN_DOMAIN))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("28076:pass an invalidService ID in sg-site2-primaryInfo"), TestCasePriority(2)]
        class NInvalidServiceID : NegativeNRTestBase
        {
            override protected void Execute()
            {
                string pathName = "stats";
                XRLNameResolver req = new XRLNameResolver(pathName);
                req.Slot.ClearServices();
                req.Slot.AddService(XOService.Name_Resolution + 1);
                if (NRTestNegative(req, HResult.XONLINE_E_SERVER_ERROR))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        // bug 38105
        [TestCase, Description("pass a domainpart that is 64 unicode long"), TestCasePriority(2)]
        class NOverflowDomainPart : NegativeNRTestBase
        {
            override protected void Execute()
            {
                string pathName = "stats.1111111111111111111111111111111111111111111111111111111111";
                XRLNameResolver req = new XRLNameResolver(pathName);
                if (NRTestNegative(req, HResult.XONLINE_E_INVALID_REQUEST))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        //  27222 27840 postponed
        //	[TestCase, Description("cbDomainLength is longer than the actual domain part"), TestCasePriority(2)]
        class NMismatchedLength1 : NegativeNRTestBase
        {
            override protected void Execute()
            {
                string pathName = "stats";
                XRLNameResolver req = new XRLNameResolver(pathName);
                req.ManualArraySize = true;
                req.DomainLen = (ushort)(req.Domain.Length + 1);
                // TODO: proper error code needed
                if (NRTestNegative(req, HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("cbDomainLength is shorter than the actual domain part"), TestCasePriority(2)]
        class NMismatchedLength2 : NegativeNRTestBase
        {
            override protected void Execute()
            {
                string pathName = "stats";
                XRLNameResolver req = new XRLNameResolver(pathName);
                req.ManualArraySize = true;
                req.DomainLen = (ushort)(req.Domain.Length - 1);
                // the "stats" will be truncated to "stat"
                if (NRTestNegative(req, HResult.XONLINE_E_STORAGE_UNKNOWN_DOMAIN))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        // won't fix
        //	[TestCase, Description("31954:sending nameResolver request to storage front door port 80 other than 94"), TestCasePriority(2)]
        class NWrongServerPort : TestBase
        {
            override protected void Execute()
            {
                string pathName = "stats";
                XRLNameResolver Req = new XRLNameResolver(pathName);
                XRLNameResolverResponse resp;
                if (Req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out resp))
                {
                    Global.RO.Warn("Negative NameResolver request succeed unexpectedly");
                    return;
                }
                if ((Req.XErr != HResult.XONLINE_E_SERVER_ERROR) || (resp != null))
                {
                    Global.RO.Warn("Wrong error code " + Global.XErrToString(Req.XErr) + " returned or Resp is not null");
                    return;
                }
                ResultCode = TEST_RESULTS.PASSED;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\FuncTeamRF.cs ===
using System;
using System.Text;
using System.IO;
using System.Net;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Storage;
using xonline.common.config;

namespace XStoreTest
{
	internal abstract class NegTeamRFTestBase : TestBase
	{
		//	send readFile requests, then check the error code
		protected bool ReadFileTestNegative(XRLReadFile ReadFileReq, uint XErr)
		{
			XRLReadFileResponse	ReadFileResp;
			if (ReadFileReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out ReadFileResp))
			{
				Global.RO.Warn("Negative ReadFile request succeed unexpectedly");
				return false;
			}
			if((ReadFileReq.XErr != XErr) || (ReadFileResp != null))
			{
				Global.RO.Warn("Wrong error code " + Global.XErrToString(ReadFileReq.XErr) +" returned or ReadFileResp is not null");
				return false;
			}
			return true;
		}
	}
	/// <summary>
	/// Summary description for FuncTeamRF.
	/// </summary>
    [TestGroup, Owner("JKonkle"), TestFrequency("Regression"), TestCasePriority(1)]
	public class FuncTeamRF : TestNode
	{
		/**********************************************************************
		 * Wire Protocol Testing Cases
		 **********************************************************************/
		[TestCase, Description("Check X-Delay in the http response")]
		class PThrottling : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string	sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abc/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("Team",url);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					int Xdelay= 3000;
					Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage,"exec :stfd SetXDelay "+readReq.uiTitleId.ToString("X")+" readfile "+Xdelay);

					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp)&&
						(readReq.XDelay == Xdelay))
						ResultCode=TEST_RESULTS.PASSED;

					Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage,"exec :stfd ReloadThrottleConfig");

				}
			}
		}
		[TestCase, Description("the titleID in the request is not the acutal logged on title")]
			class PFamilyTitleID : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string	sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abc/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("Team",url);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.altTitleId1 = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleId = readReq.uiTitleId + 1;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("34869: no team tickets appeneded at the end of readFile request")]
			class PNoTeamTicket : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abcd/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("Team",url);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.accessToken.baseAT.flags = 0;
					readReq.tickets = null;
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("read a file for TitleA to the cache; try to read the file from a different title")]
			class PReadCacheFromDiffTitle : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abcd/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("Team",url);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp, readResp2;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
					{
						// the file now is in the cache; try to read the file from titleB
						XRLReadFile		readReq2 = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
						readReq2.Slot.titleId = readReq2.uiTitleId = writeReq.uiTitleId + 1;
						readReq2.Slot.titleVersion = readReq2.uiTitleVersion;
						if(!readReq2.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out readResp2))
                        {
							if(readReq2.XErr == HResult.XONLINE_E_STORAGE_ERROR)
                            {
                                ResultCode = TEST_RESULTS.PASSED;
                            }
                            else
                            {
                                Global.RO.Warn("Wrong error code " + Global.XErrToString(readReq2.XErr) + " returned");
                            }
                        }
                        else
                        {
                            Global.RO.Warn("Read succeeded when it should've failed.");
                        }
                    }
				}
			}
		}
		[TestCase, Description("no readFile cache for Team storage")]
			class PNoReadCache : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string pathName= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abcd/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("Team",pathName);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp, readResp2;
					XRLReadFile		readReq = new XRLReadFile(pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
					{
						// the file now is in the cache;
						// remove the actual file, then read the file again
						XRLRemoveFile	removeReq = new XRLRemoveFile(pathName,writeReq.uiTitleId,"Team");
						if(removeReq.Execute())
						{
							XRLReadFile		readReq2 = new XRLReadFile(pathName);
							readReq2.Slot.titleId = readReq2.uiTitleId = writeReq.uiTitleId;
							readReq2.Slot.titleVersion = readReq2.uiTitleVersion;
							if(!readReq2.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out readResp2) &&
								(readReq2.XErr == HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
								ResultCode=TEST_RESULTS.PASSED;
						}
					}
				}
			}
		}
		[TestCase, Description("33960:Write a file first; then read the file with ifModifiedSince>actualModifiedTime")]
			class PModifiedSince : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abcd/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("Team",url);

				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;
					readReq.lIfModifiedSinceDate = (long)System.DateTime.UtcNow.AddHours(2).ToFileTimeUtc();
					if(!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp)&&
						(readReq.XErr == HResult.XONLINE_S_STORAGE_FILE_NOT_MODIFIED) && (readResp == null))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("Write a file first; the request this file with userCountryID set to max")]
		class PMaxUserCountryID : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abcd/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("Team",url);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.bUserCountryId = 0xff;
					readReq.Slot.userFlag0 = 0xff<<8;
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("Write a file first; the request this file with userCountryID set to min")]
			class PMinUserCountryID : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abcd/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("Team",url);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.bUserCountryId = 0;
					readReq.Slot.userFlag0 = 0;
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("Write a file first; the request this file with userPUID set to max")]
			class PMaxUserPUID : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abcd/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("Team",url);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.tickets = null;
					readReq.accessToken.baseAT.flags = 0;
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					readReq.Slot.userPuid0 = readReq.accessToken.baseAT.userPuid = 0xffffffffffffffff;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("Write a file first; the request this file with userPUID set to min")]
			class PMinUserPUID : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abcd/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("Team",url);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.tickets = null;
					readReq.accessToken.baseAT.flags = 0;
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					readReq.Slot.userPuid0 = readReq.accessToken.baseAT.userPuid = 1;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("Write a file first; the request this file with machine PUID set to max")]
			class PMaxXBoxPUID : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abcd/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("Team",url);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					readReq.Slot.machinePuid = readReq.accessToken.baseAT.xboxPuid = 0xffffffffffffffff;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("Write a file first; the request this file with machine PUID set to min")]
			class PMinXBoxPUID : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abcd/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("Team",url);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					readReq.Slot.machinePuid = readReq.accessToken.baseAT.xboxPuid = 1;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request with mismatched TitleID"), TestCasePriority(2)]
			class NMismatchedTitleID : NegTeamRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abcd/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("Team",url);
				if(writeReq.Execute())
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId + 1;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_ERROR))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("write a valid file first, then request with mismatched TitleVersion")]
			class PMismatchedTitleVersion : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abcd/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("Team",url);
				if(writeReq.Execute())
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion= writeReq.uiTitleVersion + 1;
					XRLReadFileResponse		Response;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out Response))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("pass null for AccessToken"), TestCasePriority(2)]
			class NAccessTokenNullAT : NegTeamRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abcd/" + Guid.NewGuid().ToString();

				XRLReadFile		readReq = new XRLReadFile(url);
				readReq.accessToken = null;

				if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode = TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass 0 for userPUID for AccessToken"), TestCasePriority(2)]
			class NAccessTokenZeroUserPUID : NegTeamRFTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLReadFile		readReq = new XRLReadFile(url);
				readReq.Slot.userPuid0 = readReq.accessToken.baseAT.userPuid = 0;

				if(ReadFileTestNegative(readReq,HResult.XONLINE_E_SERVER_ERROR))
					ResultCode = TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass non-readfile operation in the AT"), TestCasePriority(2)]
			class NAccessTokenMismatchedOp : NegTeamRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abcd/" + Guid.NewGuid().ToString();

				XRLReadFile		readReq = new XRLReadFile(url);
				readReq.accessToken.baseAT.operation = (ushort)Constants.Operation.FileWrite;

				if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode = TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("write a file first, then request it with pathnameLen is greater than the actual pathname"), TestCasePriority(2)]
			class NAccessTokenTruncatePathname : NegTeamRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abcd/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("Team",url);
				if(writeReq.Execute())
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					readReq.accessToken.baseAT.ManualArraySize = true;
					readReq.accessToken.baseAT.pathNameLen += 1;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a file first, then request it with pathnameLen is less than the actual pathname"), TestCasePriority(2)]
			class NAccessTokenOverflowPathname : NegTeamRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abcd/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("Team",url);
				if(writeReq.Execute())
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					readReq.accessToken.baseAT.ManualArraySize = true;
					readReq.accessToken.baseAT.pathNameLen -= 1;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("pass null for pathname and pathnameLen is 0"), TestCasePriority(2)]
			class NAccessTokenNullPathname : NegTeamRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abcd/" + Guid.NewGuid().ToString();

				XRLReadFile		readReq = new XRLReadFile(url);
				readReq.accessToken.baseAT.pathName = null;
				readReq.accessToken.baseAT.pathNameLen = 0;

				if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode = TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("AccessToken size is greater than 255+baseAT"), TestCasePriority(2)]
			class NAccessTokenOverflowAT : NegTeamRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abcd/" + Guid.NewGuid().ToString();

				XRLReadFile		req = new XRLReadFile(url);
				StringBuilder	pathName = new StringBuilder(req.accessToken.baseAT.pathName);
				int		numUniCharToAdd = 256 - req.accessToken.baseAT.pathNameLen;
				string			temp = new string('a',numUniCharToAdd);
				pathName.Append(temp);
				req.accessToken.baseAT.pathNameLen = 256;//actual pathName length is 256
				req.accessToken.baseAT.pathName = pathName.ToString();

				if(ReadFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode = TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("write file first, then request it with non-null signature but sigSize is zero"), TestCasePriority(2)]
			class NAccessTokenNonNullSignature : NegTeamRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abcd/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("Team",url);
				if(writeReq.Execute())
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.accessToken.readAT.ManualArraySize = true;
					readReq.accessToken.readAT.signatureLen = 0;
					readReq.accessToken.readAT.signature = new byte[Constants.sizeSignature];
					for(int i = 0; i < Constants.sizeSignature; i++)
						readReq.accessToken.readAT.signature[i] = 0;
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write file first, then request it with token exp is before current time"), TestCasePriority(2)]
			class NAccessTokenWrongATExpTime : NegTeamRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abcd/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("Team",url);
				if(writeReq.Execute())
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.accessToken.readAT.tokenExpirationDate = System.DateTime.UtcNow.AddDays(-1).ToFileTimeUtc();
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write file first, then request it with non-zero/1 flags"), TestCasePriority(2)]
			class NAccessTokenWrongFlags : NegTeamRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abcd/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("Team",url);
				if(writeReq.Execute())
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.accessToken.baseAT.flags = 2;
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
		/**********************************************************************
		 * Pathname Testing Cases
		 **********************************************************************/
        [TestCase, Description("write a valid file first, then request it with one null char in the middle of <Domain-part>"), TestCasePriority(2)]
			class NPathnameBadString1 : NegTeamRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abcd/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("Team",url);
				if(writeReq.Execute())
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					newPath = pathName.Insert(6,'\0'.ToString());

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					//TODO: need to return xonline_e_storage_domain_not_supported
					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it with two null char in the middle of <domain-part>"), TestCasePriority(2)]
			class NPathnameBadString2 : NegTeamRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abcd/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("Team",url);
				if(writeReq.Execute())
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath, temp;
					temp = '\0'.ToString() + '\0'.ToString();
					newPath = pathName.Insert(6,temp);

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it with one nullchar in the middle of <userPUID>"), TestCasePriority(2)]
			class NPathnameBadString3 : NegTeamRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abcd/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("Team",url);
				if(writeReq.Execute())
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					newPath = pathName.Insert(12,'\0'.ToString());

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it with one nullchar in the middle of <pathpart>"), TestCasePriority(2)]
			class NPathnameBadString4 : NegTeamRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abcd/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("Team",url);
				if(writeReq.Execute())
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					newPath = pathName.Insert(49,'\0'.ToString());

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it with one nullchar at the end of <pathpart>"), TestCasePriority(2)]
			class NPathnameBadString5 : NegTeamRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abcd/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("Team",url);
				if(writeReq.Execute())
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					newPath = pathName + '\0'.ToString();

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it by passing a nonexisitent <path-part>(vc_name)"), TestCasePriority(2)]
			class NPathnameNonExistFile1 : NegTeamRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abcd/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("Team",url);
				if(writeReq.Execute())
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					int		guidStartPos = pathName.LastIndexOf('/');
					newPath = pathName.Substring(0,guidStartPos)+ "/" + Guid.NewGuid().ToString();

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it by passing wrong owner PUID"), TestCasePriority(2)]
			class NPathnameNonExistFile2 : NegTeamRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abcd/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("Team",url);
				if(writeReq.Execute())
				{
					// "//stats/u:<ulonglong>/<guid>"
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					int		pos = pathName.IndexOf("u:"), guidStart = pathName.LastIndexOf('/');
					newPath = pathName.Substring(0,pos)+ "u:393939/1234/aaaabbbbccccdddd" + pathName.Substring(guidStart);

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it by passing wrong IDNameSpace"), TestCasePriority(2)]
			class NPathnameNonExistFile3 : NegTeamRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abcd/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("Team",url);
				if(writeReq.Execute())
				{
					// "//stats/u:<ulonglong>/<guid>"
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					newPath = pathName.Replace("u:","x:");

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it by passing wrong Domain"), TestCasePriority(2)]
			class NPathnameNonExistFile4 : NegTeamRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abcd/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("Team",url);
				if(writeReq.Execute())
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					newPath = pathName.Replace("tteam","voice");

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					//TODO: proper error code needed
					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_PATH))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("Write file first, then request it by passing a pathname that has no domain part"), TestCasePriority(2)]
			class NPathnameNoDomainPart : NegTeamRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abcd/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("Team",url);
				if(writeReq.Execute())
				{
					string path = writeReq.accessToken.baseAT.pathName, newPath, temp;
					temp = path.Substring(path.IndexOf("u:"));
					newPath = "///" + temp;

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("Write file first, then request it by passing noID namespace"), TestCasePriority(2)]
			class NPathnameNoIDNameSpace : NegTeamRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abcd/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("Team",url);
				if(writeReq.Execute())
				{
					string path = writeReq.accessToken.baseAT.pathName, newPath;
					newPath = path.Remove(path.IndexOf("u:"),1);

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        //		[TestCase, Description("Write file first, then request it by passing 0 PUID"), TestCasePriority(2)]
			class NPathnameZeroUserPUID : NegTeamRFTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("Team",url);
				if(writeReq.Execute())
				{
					string pathName = writeReq.accessToken.baseAT.pathName, newPath;
					int		pos = pathName.IndexOf("u:"), guidStart = pathName.LastIndexOf('/');
					newPath = pathName.Substring(0,pos)+ "u:0/1234/aaaabbbbccccdddd" + pathName.Substring(guidStart);

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
            [TestCase, Description("Write file first, then request it by pass wrong charset"), TestCasePriority(2)]
			class NPathnameWrongCharSet : NegTeamRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abcd/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("Team",url);
				if(writeReq.Execute())
				{
					string path = writeReq.accessToken.baseAT.pathName;
					StringBuilder	pathName = new StringBuilder(path);
					//Bug 27831: domain and optional domain specified: A-Za-z0-9_
					// pathname allows anything except control chars('\0\, control characters, etc)
					char i = '\0';
					pathName.Append(i);

					XRLReadFile		readReq = new XRLReadFile(pathName.ToString());
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
            [TestCase, Description("Write file first, then request it by passing wrong titleID"), TestCasePriority(2)]
			class NPathnameWrongTitleID : NegTeamRFTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("Team",url);
				if(writeReq.Execute())
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					int		guidStart = pathName.LastIndexOf('/');
					newPath = "//tteam.89898/u:8989/89898/aaaabbbbccccdddd/" + pathName.Substring(guidStart);

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
		/***********************************************************************
		* SG Auth Data Testing
		* *********************************************************************/
            [TestCase, Description("the userPUID in SGAuth response is not_found user"), TestCasePriority(2)]
			class NSGAuthNotFoundUser : NegTeamRFTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLReadFile		req = new XRLReadFile(url);
				req.Slot.UserExists = 0;

				if(ReadFileTestNegative(req,HResult.XONLINE_E_SERVER_ERROR))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
            [TestCase, Description("the userPUID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidUser : NegTeamRFTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLReadFile		req = new XRLReadFile(url);
				req.Slot.userPuid0++;

				if(ReadFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
            [TestCase, Description("the TitleID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidTitleID : NegTeamRFTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLReadFile		req = new XRLReadFile(url);
				req.Slot.titleId++;

				if(ReadFileTestNegative(req,HResult.XONLINE_E_INVALID_TITLE_ID))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
            [TestCase, Description("the XBoxPUID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidXBoxPUID : NegTeamRFTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLReadFile		req = new XRLReadFile(url);
				req.Slot.machinePuid++;

				if(ReadFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
            [TestCase, Description("the TitleVersion in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidTitleVersion : NegTeamRFTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLReadFile		req = new XRLReadFile(url);
				req.Slot.titleVersion++;

				if(ReadFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
            [TestCase, Description("the CountryID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidCountryID : NegTeamRFTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLReadFile		req = new XRLReadFile(url);
				req.Slot.userFlag0 = (uint)((req.bUserCountryId+1)<<8);

				if(ReadFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		/**********************************************************************
		 * Other ReadFile Testing Cases
		 **********************************************************************/
		[TestCase, Description("Multiple threads read same file simultaneously")]
			class PMultiThreadsReadFile : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abcd/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("Team",url);
				pathName = writeReq.accessToken.baseAT.pathName;
				uiTitleId = writeReq.uiTitleId;
				uiTitleVersion = writeReq.uiTitleVersion;

				if(writeReq.Execute())
				{
					Thread [] threadArray = new Thread[10];
					for(int i = 0; i < 10; i++)
					{
						threadArray[i] = ThreadMaker.CreateThread(readFileTS);
						threadArray[i].Start();
					}
					// the main thread is waiting for all threads to exit or timeout
					foreach (Thread t in threadArray)
						t.Join(1000);
					if(FailedReqs == 0)
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
			private void readFileTS()
			{
				XRLReadFileResponse	readResp;
				XRLReadFile		readReq = new XRLReadFile(pathName);
				readReq.Slot.titleId = readReq.uiTitleId = uiTitleId;
				readReq.Slot.titleVersion = readReq.uiTitleVersion = uiTitleVersion;

				if(!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out readResp))
				{
					Global.RO.Warn("readFileTS: read file request failed");
					Interlocked.Increment(ref FailedReqs);
				}
			}
			private string	pathName;
			private uint	uiTitleId, uiTitleVersion;
			private int		FailedReqs;
		}
		[TestCase, Description("read file 100 times and check bi_read_count in t_files")]
			// bi_read_count in t_files: number of times the file has been read
			class PReadFileMultiTimes : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abcd/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("Team",url);
				if(writeReq.Execute())
				{
					uint				uiFailedReq = 0;
					for(int i = 0; i < 100; i++)
					{
						XRLReadFileResponse	readResp;
						XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
						readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
						readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
						if(!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
							uiFailedReq++;
					}
					if(uiFailedReq == 0)
						ResultCode=TEST_RESULTS.PASSED;
					// check bi_read_count in t_files
					// Bug26804:since we cache file in the front door, it will be 1 instead of 100
					//					long expectedCount = 1;
					//					XRLWriteFile	dumbReq = new XRLWriteFile();
					//					if(writeReq.CheckReadCount(dumbReq,expectedCount))
					//						if(uiFailedReq == 0)
					//							ResultCode=TEST_RESULTS.PASSED;
					//						else
					//							Global.RO.Warn("bi_read_count is set right, but not all 100 read requests succeeded");
				}
			}
		}
        [TestCase, Description("Read file from a different title other than creator's"), TestCasePriority(2)]
			class NFromDifferentTitle : NegativeRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abcd/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("Team",url);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId + 1;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion + 1;
					if(!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
                    {
						if(readReq.XErr == HResult.XONLINE_E_STORAGE_ERROR)
                        {
                            ResultCode = TEST_RESULTS.PASSED;
                        }
                        else
                        {
                            Global.RO.Warn("Wrong error code " + Global.XErrToString(readReq.XErr) + " returned");
                        }
                    }
                    else
                    {
                        Global.RO.Warn("Read succeeded when it should've failed.");
                    }
                }
			}
		}
		[TestCase, Description("Read file from a different titleVersion other than creator's")]
			class PFromDifferentTitleVersion : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abcd/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("Team",url);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion + 1;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\FuncTeamWF.cs ===
using System;
using System.Globalization;
using System.Text;
using System.Net;
using System.IO;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Storage;
using ServerTestFramework.LiveService.Signature;
using ServerTestFramework.LiveService.Presence;
using xonline.common.config;

namespace XStoreTest
{
	internal abstract class TeamWFTestBase : TestBase
	{
		//	send WriteFile request first; then send readfile;verifies the response
		protected bool WriteFileSendAndVerify(XRLWriteFile WriteFileReq)
		{
			bool fPassed=WriteFileReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage));
			if (!fPassed)
			{
				Global.RO.Warn("Failed to send WriteFile request ");
				return false;
			}

			XRLReadFileResponse	ReadFileResp;
			XRLReadFile			ReadFileReq = new XRLReadFile(WriteFileReq.accessToken.baseAT.pathName);
			ReadFileReq.Slot.titleId = ReadFileReq.uiTitleId = WriteFileReq.uiTitleId;
			ReadFileReq.Slot.titleVersion = ReadFileReq.uiTitleVersion = WriteFileReq.uiTitleVersion;
			if (ReadFileReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out ReadFileResp))
			{
				if ((!ReadFileResp.Compare(WriteFileReq)) || (!WriteFileReq.Verify()))
				{
					Global.RO.Warn("WriteFile request is not set correctly in the db");
					return false;
				}
			}
			else
			{
				Global.RO.Warn("Failed to send ReadFile request");
				return false;
			}
			return true;
		}
	}
	internal abstract class TeamWFNegTestBase : TestBase
	{
		//	send WriteFile request first; then send readfile;verifies the response
		protected bool WriteFileTestNegative(XRLWriteFile WriteFileReq, uint XErr)
		{
			if (WriteFileReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
			{
				Global.RO.Warn("Negative WriteFile request succeed unexpectedly");
				return false;
			}
			if(WriteFileReq.XErr != XErr)
			{
				Global.RO.Warn("Wrong error code returned " + Global.XErrToString(WriteFileReq.XErr));
				return false;
			}
			// now we need to check the file is not written to the DB
			XRLReadFileResponse	ReadFileResp;
			XRLReadFile			ReadFileReq = new XRLReadFile(WriteFileReq.accessToken.baseAT.pathName);
			ReadFileReq.Slot.titleId = ReadFileReq.uiTitleId = WriteFileReq.uiTitleId;
			ReadFileReq.Slot.titleVersion = ReadFileReq.uiTitleVersion = WriteFileReq.uiTitleVersion;
			if (!ReadFileReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out ReadFileResp))
			{
				/*				if((ReadFileReq.XErr != HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND)
									||(ReadFileResp != null))
								{
									Global.RO.Warn("file_not_found error is not returned OR File is being written to DB unexpectedly");
									return false;
								}
								*/
				if(ReadFileResp != null)
				{
					Global.RO.Warn("File is being written to DB unexpectedly");
					return false;
				}
			}
			else
			{
				Global.RO.Warn("ReadFile request succeed with S_OK unexpectedly");
				return false;
			}
			return true;
		}
	}
    [TestGroup, Owner("JKonkle"), TestFrequency("Regression"), TestCasePriority(1)]
	public class FuncTeamWF : TestNode
	{
		/***********************************************************************
			* Wire Protocol Testing
			* *********************************************************************/
		[TestCase, Description("Check X-Delay in the http response header")]
			class PThrottling : TeamWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abc/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.attributes = new byte[100];
				new Random().NextBytes(req.attributes);
				req.attributesLen = (ushort)req.attributes.Length;

				int Xdelay= 3000;
				Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage,"exec :stfd SetXDelay "+req.uiTitleId.ToString("X")+" writefile "+Xdelay);

				if(WriteFileSendAndVerify(req)&&
					(req.XDelay == Xdelay))
					ResultCode=TEST_RESULTS.PASSED;

				Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage,"exec :stfd ReloadThrottleConfig");

			}
		}
		[TestCase, Description("Write a file with all valid parameters including attributes")]
			class PNormalCase : TeamWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abc/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.attributes = new byte[100];
				new Random().NextBytes(req.attributes);
				req.attributesLen = (ushort)req.attributes.Length;

                if (WriteFileSendAndVerify(req))
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    Global.RO.Error(Global.XErrToString(req.XErr));
                }
			}
		}
		[TestCase, Description("Write a 1k file")]
			class PSmallFileSize : TeamWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abc/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.blobData = new byte[1024];
				new Random().NextBytes(req.blobData);
				req.blobDataLen = req.uiBlobSizeCompressed = (uint)req.blobData.Length;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("Write a file with title ID set to max value")]
			class PMaxTitleID : TeamWFTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.ffffffff/u:8989/ffffffff/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Team",url);

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write a file with title ID set to min value")]
			class PMinTitleID : TeamWFTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.0/u:8989/0/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Team",url);

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write a file with titleVersion set to max value")]
			class PMaxTitleVersion : TeamWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abc/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.uiTitleVersion = 0xffffffff;
				req.Slot.titleVersion = 0xffffffff;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write a file with titleVersion set to min value")]
			class PMinTitleVersion : TeamWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abc/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.uiTitleVersion = 0;
				req.Slot.titleVersion = 0;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write a file with countryID set to max value")]
			class PMaxUserCountryID : TeamWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abc/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.bUserCountryId = 0xff;
				req.Slot.userFlag0 = (uint)0xff<<8;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write a file with countryID set to min value")]
			class PMinUserCountryID : TeamWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abc/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.bUserCountryId = 0;
				req.Slot.userFlag0 = 0;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write a max size file")]
			class PBlobDataMaxSize : TeamWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abc/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.blobData = new byte[65536];
				for(int i = 0; i < req.blobData.Length; i++)
					req.blobData[i] = (byte)(i%256);
				req.blobDataLen = req.uiBlobSizeCompressed = (uint)req.blobData.Length;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass attributes with 256 byte")]
			class PMaxAttributeSize : TeamWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abc/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Team",url);
				uint			attribLen = Constants.maxSizeAttributes;
				req.attributes = new byte[attribLen];
				for(int i = 0; i < req.attributes.Length; i++)
					req.attributes[i] = 1;
				req.attributesLen = (ushort)req.attributes.Length;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass 0 attributeslen")]
			class PMinAttributeSize : TeamWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abc/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.attributes = null;
				req.attributesLen = 0;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass max value for UserPUID in the accessToken")]
			class PAccessTokenMaxUserPUID : TeamWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/ffffffffffffffff/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Team",url);

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass min value for UserPUID in the accessToken")]
			class PAccessTokenMinUserPUID : TeamWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/1/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Team",url);

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass max value for xboxPUID in the accessToken")]
			class PAccessTokenMaxXBoxPUID : TeamWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abc/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.accessToken.baseAT.xboxPuid = 0xffffffffffffffff;
				req.Slot.machinePuid = 0xffffffffffffffff;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass min value for xboxPUID in the accessToken")]
			class PAccessTokenMinXBoxPUID : TeamWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abc/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.accessToken.baseAT.xboxPuid = 1;
				req.Slot.machinePuid = 1;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass 0 fileExpirationTime in the accessToken")]
			class PAccessTokenZeroFileExpTime : TeamWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abc/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.accessToken.writeAT.fileExpirationDate = 0;
				req.accessToken.writeAT.tokenExpirationDate = System.DateTime.UtcNow.AddHours(1).ToFileTimeUtc();

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass 0 AccessTokenExpirationTime in the accessToken")]
			class PAccessTokenZeroATExpTime : TeamWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abc/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.accessToken.writeAT.tokenExpirationDate = 0;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass 255 unicode chars pathNameLen in the accessToken")]
			class PAccessTokenMaxPathnameSize : TeamWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abc/" + Guid.NewGuid().ToString();

				uint			maxPathLen = Constants.maxSizeName;
				StringBuilder	pathBuilder = new StringBuilder(url);
				if(url.Length < maxPathLen)
					pathBuilder.Append('z',(int)(maxPathLen-url.Length));
				XRLWriteFile	req = new XRLWriteFile("Team",pathBuilder.ToString());

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("try to write a file that is bigger than max allowed"), TestCasePriority(2)]
			class NBiggerThanMaxFile : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abc/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.blobData = new byte[65536+1];
				new Random().NextBytes(req.blobData);
				req.blobDataLen = req.uiBlobSizeCompressed = (uint)req.blobData.Length;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_FILE_IS_TOO_BIG))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass non-existent compression type"), TestCasePriority(2)]
			class NInvalidCompressionType : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abc/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.bCompressionType = (byte)Constants.CompressionType.Invalid;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass non-existent content type"), TestCasePriority(2)]
			class NInvalidContentType : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abc/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.uiContentType = (uint)Constants.ContentType.Invalid;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass NULL for blob hash"), TestCasePriority(2)]
			class NNullBlobHash : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abc/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.ManualArraySize = true;
				req.blobHash = null;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass <20 byte for blob hash"), TestCasePriority(2)]
			class NInvalidBlobHash1 : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abc/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.ManualArraySize = true;
				req.blobHash = new byte[Constants.sizeHash - 1];
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass >20 byte for blob hash"), TestCasePriority(2)]
			class NInvalidBlobHash2 : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.ManualArraySize = true;
				req.blobHash = new byte[Constants.sizeHash + 1];
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("uncompressed size is smaller than compressed size"), TestCasePriority(2)]
			class NWrongCompressedSize : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.uiBlobSizeCompressed = req.blobDataLen + 1;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass non-null for Attributes, but AttribLen is zero"), TestCasePriority(2)]
			class NMismatchedAttributes : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.ManualArraySize = true;
				req.attributesLen = 0;
				req.attributes = new byte[16];
				for(int i = 0; i < 16; i++)
					req.attributes[i] = (byte)i;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("Attributes size is greater than the actual size"), TestCasePriority(2)]
			class NTruncateAttributes : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.ManualArraySize = true;
				req.attributesLen +=1;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("Attributes size is smaller than the actual size"), TestCasePriority(2)]
			class NOverflowAttributes1 : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.ManualArraySize = true;
				req.attributes = new Byte[16];
				req.attributesLen = 15;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("Attributes is null but attribLen is nonzero"), TestCasePriority(2)]
			class NOverflowAttributes2 : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.ManualArraySize = true;
				req.attributes = null;
				req.attributesLen = 16;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("Attributes is null but attribLen is greater than maxallowed(256)"), TestCasePriority(2)]
			class NOverflowAttributes3 : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.ManualArraySize = true;
				req.attributes = null;
				req.attributesLen = 257;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("Attributes is larger than max allowed256bytes"), TestCasePriority(2)]
			class NOverflowAttributes4 : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Team",url);
				ushort			attribLen = Constants.maxSizeAttributes + 1;
				req.attributes = new Byte[attribLen];
				req.attributesLen = attribLen;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass special attributeLen = 0xffff"), TestCasePriority(2)]
			class NOverflowAttributes5 : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.attributes = new Byte[0xffff];
				req.attributesLen = 0xffff;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass null for AccessToken"), TestCasePriority(2)]
			class NNullAccessToken : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	WriteFileReq = new XRLWriteFile("Team",url);
				WriteFileReq.ManualArraySize = true;
				WriteFileReq.accessToken = null;
				if (!WriteFileReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
				{
					if((WriteFileReq.XErr != HResult.XONLINE_E_STORAGE_INVALID_REQUEST)&&
						(WriteFileReq.XErr != HResult.XONLINE_E_SERVER_ERROR))
						Global.RO.Warn("Wrong error code returned " + Global.XErrToString(WriteFileReq.XErr));
					else
						ResultCode=TEST_RESULTS.PASSED;
				}
				else
					Global.RO.Warn("Negative WriteFile request succeed unexpectedly");
			}
		}
        [TestCase, Description("pass null for Blob data, but blobLen is non-zero"), TestCasePriority(2)]
			class NNullBlobData : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.ManualArraySize = true;
				req.blobData = null;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass 0 for uncompressed blob size and null blobdata")]
			class PEmptyFile : TeamWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abc/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.blobDataLen = req.uiBlobSizeCompressed = 0;
				req.blobData = null;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass 0 for compressed blob size, but non-null blobdata"), TestCasePriority(2)]
			class NEmptyCompressedFile : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.uiBlobSizeCompressed = 0;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("uncompressed blob size is greater than the actual file size"), TestCasePriority(2)]
			class NTruncateFile : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.ManualArraySize = true;
				req.blobDataLen += 1;
				req.uiBlobSizeCompressed +=1;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("uncompressed blob size is smaller than the actual file size"), TestCasePriority(2)]
			class NOverflowFile : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.ManualArraySize = true;
				req.blobDataLen -= 1;
				req.uiBlobSizeCompressed -=1;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("Expiration date is before the current time"), TestCasePriority(2)]
			class NAccessTokenInvalidExpTime1 : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.accessToken.writeAT.fileExpirationDate = System.DateTime.UtcNow.AddDays(-1).ToFileTimeUtc();

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("33962:pass 0 for userPUID in access Token"), TestCasePriority(2)]
			class NAccessTokenZeroUserPUID : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/0/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.accessToken.baseAT.userPuid = 0;
				req.Slot.userPuid0 = 0;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_SERVER_ERROR))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass an access Token that is greater than 255+baseAT"), TestCasePriority(2)]
			class NAccessTokenOverflowAT : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				StringBuilder	pathName = new StringBuilder(url);
				int		i = 0, numCharToAdd = 256 - url.Length;
				while(i < numCharToAdd)
				{
					pathName.Append('a');
					i++;
				}
				XRLWriteFile	req = new XRLWriteFile("Team",pathName.ToString());

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("Access Token signature is NULL but sigLen is still 100"), TestCasePriority(2)]
			class NAccessTokenNullSig : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.accessToken.writeAT.ManualArraySize = true;
				req.accessToken.writeAT.signature = null;
				req.accessToken.writeAT.signatureLen = Constants.sizeSignature;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("Access Token signature is not NULL"), TestCasePriority(2)]
			class NAccessTokenNonNullSig : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.accessToken.writeAT.ManualArraySize = true;
				byte [] sig = new byte[Constants.sizeSignature];
				new Random().NextBytes(sig);
				req.accessToken.writeAT.signature = sig;
				req.accessToken.writeAT.signatureLen = Constants.sizeSignature;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("Access Token version is invalid"), TestCasePriority(2)]
			class NAccessTokenInvalidTokenVersion : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.accessToken.baseAT.version = Constants.accessTokenVersion + 1;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("Operation in AT is non-write"), TestCasePriority(2)]
			class NAccessTokenMismatchedOperation : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.accessToken.baseAT.operation = (ushort)Constants.Operation.FileRead;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("ticket expiration time is greater than file expiration time"), TestCasePriority(2)]
			class NAccessTokenInvalidExpTime2 : TeamWFTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.accessToken.writeAT.fileExpirationDate = req.accessToken.writeAT.tokenExpirationDate - 100000;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the pathnameLen is greater than the actual size"), TestCasePriority(2)]
			class NAccessTokenTruncatePathname : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.accessToken.baseAT.ManualArraySize = true;
				req.accessToken.baseAT.pathNameLen += 1;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the pathnameLen is less than the actual size"), TestCasePriority(2)]
			class NAccessTokenOverflowPathname : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.accessToken.baseAT.ManualArraySize = true;
				req.accessToken.baseAT.pathNameLen -= 1;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("34215/35350:the flags in AT is non-zero and non1"), TestCasePriority(2)]
			class NAccessTokenInvalidFlags : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.accessToken.baseAT.flags = 2;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		/***********************************************************************
		* Pathname Testing
		* *********************************************************************/
		[TestCase, Description("pass max value for userPUID in <Unique-ID-part>")]
			class PPathnameMaxUserPUID : TeamWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/ffffffffffffffff/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Team",url);

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass min value for userPUID in <Unique-ID-part>")]
			class PPathnameMinUserPUID : TeamWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/1/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Team",url);

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("only specify domain in <Domain-part> (tteam), no optional information")]
			class PPathnameNoOptionalDomainSpecifier : TeamWFTestBase
		{
			override protected void Execute()
			{
				string url="//tteam/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Team",url);

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass a pathname that one null char in the middle of <Domain-part>"), TestCasePriority(2)]
			class NPathnameBadString1 : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				string newPath = url.Insert(6,'\0'.ToString());
				XRLWriteFile	writeReq = new XRLWriteFile("Team",newPath);

				//TODO: need to return xonline_e_storage_domain_not_supported
				if(WriteFileTestNegative(writeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass a pathname that two null char in the middle of <Domain-part>"), TestCasePriority(2)]
			class NPathnameBadString2 : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				string	pathName = url, newPath, temp;
				temp = '\0'.ToString() + '\0'.ToString();
				newPath = pathName.Insert(5,temp);
				XRLWriteFile	writeReq = new XRLWriteFile("Team",newPath);

				//TODO: need to return xonline_e_storage_domain_not_supported
				if(WriteFileTestNegative(writeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass one nullchar in the middle of <userPUID>"), TestCasePriority(2)]
			class NPathnameBadString3 : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				string	pathName = url, newPath;
				newPath = pathName.Insert(16,'\0'.ToString());

				XRLWriteFile	writeReq = new XRLWriteFile("Team",newPath);

				if(WriteFileTestNegative(writeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass one nullchar in the middle of <pathpart>"), TestCasePriority(2)]
			class NPathnameBadString4 : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				string	pathName = url, newPath;
				// //stats/u:123456/<pathpart>
				newPath = pathName.Insert(37,'\0'.ToString());
				XRLWriteFile	writeReq = new XRLWriteFile("Team",newPath);

				if(WriteFileTestNegative(writeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass one nullchar at the end of <pathpart>"), TestCasePriority(2)]
			class NPathnameBadString5 : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString()+'\0';
				XRLWriteFile	writeReq = new XRLWriteFile("Team",url);

				if(WriteFileTestNegative(writeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("<Domain-part> is missing in pathname"), TestCasePriority(2)]
			class NPathnameNoDomainPart : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Team",url);
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass a pathname that has no ID namespace (u)"), TestCasePriority(2)]
			class NPathnameNoIDNameSpace : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Team",url);

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass 0 as userPUID in <Domain-part>")]
			class PPathnameInvalidUserPUID : TeamWFTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:0/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Team",url);

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}

        [TestCase, Description("pass invalid ID-Namespace"), TestCasePriority(2)]
			class NPathnameNonExistIDNameSpace : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/x:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Team",url);

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass a pathname that is greater than 255"), TestCasePriority(2)]
			class NPathnameOverflowPathname : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				StringBuilder	pathName = new StringBuilder(url);
				int		i = 0, numCharToAdd = 256 - url.Length;
				while(i < numCharToAdd)
					pathName.Append(i++);
				XRLWriteFile	req = new XRLWriteFile("Team",pathName.ToString());

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass a pathname that has special chars"), TestCasePriority(2)]
			class NPathnameWrongCharSet : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				StringBuilder	pathName = new StringBuilder(url);
				//Bug 27831: domain and optional domain specified: A-Za-z0-9_
				// pathname allows anything except control chars('\0\, control characters, etc)
				char i = '\0';
				pathName.Append(i);

				XRLWriteFile	req = new XRLWriteFile("Team",pathName.ToString());

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		/*****************************************************************
			*  Other stats w/attachments Testing
			*****************************************************************/
		[TestCase, Description("update an existing file;old blob will be deleted")]
			class PUpdateExistingFile1 : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abc/" + Guid.NewGuid().ToString();

				XRLWriteFile	req1 = new XRLWriteFile("Team",url), req2 = new XRLWriteFile("Team",url);

				// make sure the two blobs are different
				req2.blobHash[1] = (byte)(req1.blobHash[1]+1);

				if(req1.Execute())
				{	// update the same file
					if(req2.Execute())
					{
						// read the file
						XRLReadFileResponse	ReadFileResp;
						XRLReadFile			ReadFileReq = new XRLReadFile(url);
						ReadFileReq.Slot.titleId = ReadFileReq.uiTitleId = randomTitleID;
						ReadFileReq.Slot.titleVersion = ReadFileReq.uiTitleVersion = req2.uiTitleVersion;
						if (ReadFileReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out ReadFileResp))
						{
							if ((ReadFileResp.Compare(req2)) || (req2.Verify()))
								ResultCode=TEST_RESULTS.PASSED;
						}
					}
				}
			}
		}
		[TestCase, Description("update an existing file;old blob still exisits(have reference)")]
			class PUpdateExistingFile2 : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url1= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abc/" + Guid.NewGuid().ToString();
				string url2= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abc/" + Guid.NewGuid().ToString();

				XRLWriteFile	req1 = new XRLWriteFile("Team",url1), req2 = new XRLWriteFile("Team",url2);

				// make sure the two blob are identical; so we will have two referencs for the same blob
				req2.blobDataLen = req1.blobDataLen;
				req2.uiBlobSizeCompressed = req1.uiBlobSizeCompressed;
				for(int i = 0; i < req1.blobDataLen; i++)
					req2.blobData[i] = req1.blobData[i];
				for(int i = 0; i < Constants.sizeHash; i++)
					req2.blobHash[i] = req1.blobHash[i];

				if(req1.Execute() && req2.Execute())
				{
					// use one of the url to update the blob
					XRLWriteFile	updateReq = new XRLWriteFile("Team",url1);
					// make sure the two blobs are different
					updateReq.blobHash[1] = (byte)(req1.blobHash[1]+1);

					if(updateReq.Execute())
					{	// the old blob's i_ref_count will be decremented; blob still exists
						// a new blob will be created with i_ref_count is 1
						// read the old blob with url2
						XRLReadFileResponse		ReadOldBlobResp, ReadNewBlobResp;
						XRLReadFile			ReadOldBlobReq = new XRLReadFile(url2),ReadNewBlobReq=new XRLReadFile(url1);
						ReadOldBlobReq.Slot.titleId = ReadOldBlobReq.uiTitleId = randomTitleID;
						ReadOldBlobReq.Slot.titleVersion = ReadOldBlobReq.uiTitleVersion = req2.uiTitleVersion;
						if (ReadOldBlobReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out ReadOldBlobResp))
						{
							if ((ReadOldBlobResp.Compare(req2)) || (req2.Verify()))
							{
								// old blob still exist; check the new blob
								ReadNewBlobReq.Slot.titleId = ReadNewBlobReq.uiTitleId = randomTitleID;
								ReadNewBlobReq.Slot.titleVersion = ReadNewBlobReq.uiTitleVersion = updateReq.uiTitleVersion;
								if(ReadNewBlobReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out ReadNewBlobResp))
									ResultCode=TEST_RESULTS.PASSED;
							}
						}
					}
				}
			}
		}
		[TestCase, Description("data blob are identical,teamPUID are the same so mapped to same webstore partition")]
			class PSameFileUploadTwice : GlobalTitleWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url1= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abc/" + Guid.NewGuid().ToString();
				string url2= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abc/" + Guid.NewGuid().ToString();

				XRLWriteFile	req1 = new XRLWriteFile("Team",url1), req2 = new XRLWriteFile("Team",url2);

				req2.blobDataLen = req1.blobDataLen;
				req2.uiBlobSizeCompressed = req1.uiBlobSizeCompressed;
				for(int i = 0; i < req1.blobDataLen; i++)
					req2.blobData[i] = req1.blobData[i];

				for(int i = 0; i < Constants.sizeHash; i++)
					req2.blobHash[i] = req1.blobHash[i];

				if((WriteFileSendAndVerify(req1)) && (WriteFileSendAndVerify(req2)))
				{
					// do other  additional check
					if(req1.CheckRefCount(req2,2, true))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("same fileSize and hash, but blob are different")]
			class PSameHashDiffrentFileContent : GlobalTitleWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url1= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abc/" + Guid.NewGuid().ToString();
				string url2= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abc/" + Guid.NewGuid().ToString();

				XRLWriteFile	req1 = new XRLWriteFile("Team",url1), req2 = new XRLWriteFile("Team",url2);

				req2.blobDataLen = req1.blobDataLen;
				req2.uiBlobSizeCompressed = req1.uiBlobSizeCompressed;

				// reenforce the two files to have different contents
				req2.blobData[9] = (byte)((int)req1.blobData[9]+ 1);

				for(int i = 0; i < Constants.sizeHash; i++)
					req2.blobHash[i] = req1.blobHash[i];

				if((WriteFileSendAndVerify(req1)) && (WriteFileSendAndVerify(req2)))
				{
					// do other additional check
					if(req1.CheckRefCount(req2,1,false))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		// This is how webstore repartition works; there will be two rows
		// added in both t_files and t_blobs
		[TestCase, Description("data blob are identical, but different teamPUID and xrl for two writeFile requests")]
			class PSameFileUploadTwiceByDifferentUser : GlobalTitleWFTestBase
		{
			override protected void Execute()
			{
				string url1="//tteam.1234/u:89899/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				string url2="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	req1 = new XRLWriteFile("Team",url1), req2 = new XRLWriteFile("Team",url2);

				req2.blobDataLen = req1.blobDataLen;
				req2.uiBlobSizeCompressed = req1.uiBlobSizeCompressed;
				for(int i = 0; i < req1.blobDataLen; i++)
					req2.blobData[i] = req1.blobData[i];
				for(int i = 0; i < Constants.sizeHash; i++)
					req2.blobHash[i] = req1.blobHash[i];

				if((WriteFileSendAndVerify(req1)) && (WriteFileSendAndVerify(req2)))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Multiple threads write a file simultaneously")]
			class PMultiThreadsWriteFile : TeamWFTestBase
		{
			override protected void Execute()
			{
				Thread [] threadArray = new Thread[10];
				for(int i = 0; i < 10; i++)
				{
					threadArray[i] = ThreadMaker.CreateThread(writeFileTS);
					threadArray[i].Name = i.ToString();
					threadArray[i].Start();
				}
				// the main thread is waiting for all threads to exit or timeout
				foreach (Thread t in threadArray)
					t.Join(10000);
				if(FailedReqs == 0)
					ResultCode=TEST_RESULTS.PASSED;
			}
			private void writeFileTS()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abc/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("Team",url);
				if(!WriteFileSendAndVerify(writeReq))
				{
					Global.RO.Warn(Thread.CurrentThread.Name+"writeFileTS: write file request/verify failed");
					Interlocked.Increment(ref FailedReqs);
				}
			}
			private	int FailedReqs = 0;
		}
		[TestCase, Description("write file 50 times")]
			class PWriteFileMultiTimes : TeamWFTestBase
		{
			override protected void Execute()
			{
				uint			uiFailedReq = 0;
				for(int i = 0; i < 50; i++)
				{
					uint	randomTitleID = (uint)new Random().Next();
					string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
					string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abc/" + Guid.NewGuid().ToString();
					XRLWriteFile	writeReq = new XRLWriteFile("Team",url);
					if(!WriteFileSendAndVerify(writeReq))
						uiFailedReq++;
				}
				if(uiFailedReq == 0)
					ResultCode=TEST_RESULTS.PASSED;
				else
					Global.RO.Warn("It failed " + uiFailedReq.ToString() + " times");
			}
		}

		/***********************************************************************
		* SG Auth Data Testing
		* *********************************************************************/
        [TestCase, Description("the userPUID in SGAuth response is not_found user"), TestCasePriority(2)]
			class NSGAuthNotFoundUser : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.Slot.UserExists = 0;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_SERVER_ERROR))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the userPUID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidUser : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.Slot.userPuid0++;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the TitleID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidTitleID : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.Slot.titleId++;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_INVALID_TITLE_ID))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the XBoxPUID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidXBoxPUID : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.Slot.machinePuid++;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the TitleVersion in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidTitleVersion : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.Slot.titleVersion++;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the CountryID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidCountryID : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.Slot.userFlag0 = (uint)((req.Slot.userFlag0>>8+1)<<8);

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the signing key in SGAuth response is different than the one used to create the signature in the team ticket"), TestCasePriority(2)]
		class NSGAuthInvalidKey : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Team",url);
				byte [] key = new byte[16];
				new Random().NextBytes(key);
				key[8]--;
				key[0]++;
				req.Slot.SetKey(key);

				if(WriteFileTestNegative(req,HResult.XONLINE_E_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the teamPUID in teamTickets is not the one in the url "), TestCasePriority(2)]
		class NTTInvalidTeamPUID : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Team",url);
				// append team tickets at the end of request
				ulong	[]teamPUIDList = new ulong[1];
				teamPUIDList[0] = 0x890899;
				uint	numUsers = 1;
				byte []key	= new byte[16];
				new Random().NextBytes(key);
				req.tickets = new TeamTickets();
				req.tickets.list.tickets = new TeamTicket[numUsers];
				req.tickets.list.tickets[0] = new TeamTicket();
				req.Slot.userPuid0 = req.accessToken.baseAT.userPuid = 0xaaaabbbbccccdddd;
				req.tickets.list.tickets[0].Populate(0xaaaabbbbccccdddd,teamPUIDList,key);
				req.Slot.SetKey(key);

				if(WriteFileTestNegative(req,HResult.XONLINE_E_TEAMS_NOT_A_MEMBER))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the user that requests the writeFile is not in the teamTickets"), TestCasePriority(2)]
		class NTTInvalidUserPUID1 : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Team",url);
			//	req.tickets.list.tickets[0].userID = req.accessToken.baseAT.userPuid+1;
				// append team tickets at the end of request
				ulong	[]teamPUIDList = new ulong[1];
				teamPUIDList[0] = 0x8989;
				uint	numUsers = 1;
				byte []key	= new byte[16];
				new Random().NextBytes(key);
				req.tickets = new TeamTickets();
				req.tickets.list.tickets = new TeamTicket[numUsers];
				req.tickets.list.tickets[0] = new TeamTicket();
				req.Slot.userPuid0 = req.accessToken.baseAT.userPuid = 0xaaaabbbbccccdddd;
				req.tickets.list.tickets[0].Populate(0xaaaabbbbccccdddd+1,teamPUIDList,key);
				req.Slot.SetKey(key);

				if(WriteFileTestNegative(req,HResult.XONLINE_E_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the user that requests the writeFile is not the one in the xrl"), TestCasePriority(2)]
		class NTTInvalidUserPUID2 : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.Slot.userPuid0 = req.accessToken.baseAT.userPuid = 0x1235;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("no teamTickets in the writeFile request"), TestCasePriority(2)]
		class NTTNoTeamTickets : TeamWFNegTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.accessToken.baseAT.flags = 0;
				req.tickets = null;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("34911:userID in the xrl is at the end of Teamtickets")]
		class PTTUserPUIDList : TeamWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string	sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abc/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Team",url);
				uint	numUsers = 4;	// max 4 logon users
				byte []key	= new byte[16];
				new Random().NextBytes(key);
				req.tickets = new TeamTickets();
				req.tickets.list.tickets = new TeamTicket[numUsers];
				for(int i = 0; i < numUsers; i++)
					req.tickets.list.tickets[i] = new TeamTicket();
				ulong	[]teamPUIDList = new ulong[TeamTicket.MAXIMUM_TEAMS_PER_TICKET];
				teamPUIDList[0] = 1+randomTitleID;
				for(uint i = 0; i < numUsers; i++)
				{
					if(i != 3)
					{
						ulong	userId = i+1;
						req.tickets.list.tickets[i].Populate(userId,teamPUIDList,key);
						if (i == 0)
							req.Slot.userPuid0 = userId;
						else if (i == 1)
							req.Slot.userPuid1 = userId;
						else if (i == 2)
							req.Slot.userPuid2 = userId;
					}
					else
					{
						req.tickets.list.tickets[3].Populate(0xabc,teamPUIDList,key);
						req.Slot.userPuid3 = 0xabc;
						req.Slot.userFlag3 = (uint)req.bUserCountryId <<8;
					}
				}
				req.Slot.SetKey(key);

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("teamPUID in the xrl is at the end of TeamPUIDList")]
			class PTTTeamPUIDList : TeamWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/abcd/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Team",url);
				uint	numUsers = 1;	// max 4 logon users
				byte []key	= new byte[16];
				new Random().NextBytes(key);
				req.tickets = new TeamTickets();
				req.tickets.list.tickets = new TeamTicket[numUsers];
				req.tickets.list.tickets[0] = new TeamTicket();
				ulong	[]teamPUIDList = new ulong[TeamTicket.MAXIMUM_TEAMS_PER_TICKET];
				teamPUIDList[TeamTicket.MAXIMUM_TEAMS_PER_TICKET-1] = 1+randomTitleID;
				req.tickets.list.tickets[0].Populate(0xabcd,teamPUIDList,key);
				req.Slot.SetKey(key);

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("the titleID in the request is not the acutal logged on title")]
			class PFamilyTitleID : TeamWFTestBase
		{
			override protected void Execute()
			{
				string url="//tteam.1234/u:8989/1234/aaaabbbbccccdddd/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.Slot.titleId = req.uiTitleId+1;
				req.Slot.altTitleId1 = req.uiTitleId;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		/***********************************************************************
		* Tsunami: Quota testing
		***********************************************************************/
		[TestCase, Description("34942:create max allowed # of files;remove some files; check quota being updated")]
			class PQuotaMaxFiles : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				string [] removedUrls = new string[5];
				uint	[] removedFileSize = new uint[5];

				// create a file for this title first to fill out the t_quotas table
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/566/" + Guid.NewGuid().ToString();
				removedUrls[0] = url;
				XRLWriteFile	req = new XRLWriteFile("Team",url);
				req.attributes = new byte[100];
				new Random().NextBytes(req.attributes);
				req.attributesLen = (ushort)req.attributes.Length;
				if(req.Execute())
					removedFileSize[0] = req.blobDataLen;

				XRLGetQuota		getQuotaReq = new XRLGetQuota(3,randomTitleID,(uint)Constants.IdType.UserId ,1+randomTitleID);
				XRLGetQuotaResponse	getQuotaResp;
				ulong			maxFileSize=0;
				ulong			totalBytesMax=0;
				uint			totalFilesMax=0;
				ulong			start_BytesUsed=0, actualBytesUsed=0, removedBytes = 0;
				uint			start_FilesUsed=0, removedFiles = 0;
				if(getQuotaReq.Execute(out getQuotaResp))
				{
					maxFileSize = getQuotaResp.maxFileSize;
					totalBytesMax = getQuotaResp.totalBytesMax;
					totalFilesMax = getQuotaResp.totalFilesMax;
					start_BytesUsed = getQuotaResp.totalBytesUsed;
					start_FilesUsed = getQuotaResp.totalFilesUsed;
				}
				else
				{
					Global.RO.Warn("GetQuota request1 failed");
					return;
				}
				uint failed = 0;
				for(int i = 1; i <= (totalFilesMax-start_FilesUsed); i++)
				{
					url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/566/" + Guid.NewGuid().ToString();
					req = new XRLWriteFile("Team",url);
					req.attributes = new byte[100];
					new Random().NextBytes(req.attributes);
					req.attributesLen = (ushort)req.attributes.Length;
					if(!req.Execute())
					{
						failed++;
						return;
					}
					actualBytesUsed += req.blobDataLen;
					if(i < 5)
					{
						removedUrls[i] = url;
						removedFileSize[i] = req.blobDataLen;
					}
				}
				if(failed == 0) // max # of files created for this title
				{	// check quota again
					XRLGetQuota		gQReq = new XRLGetQuota(3,randomTitleID,(uint)Constants.IdType.UserId ,1+randomTitleID);
					XRLGetQuotaResponse	gQResp;
					if(gQReq.Execute(out gQResp))
					{
						if((gQResp.totalFilesUsed == gQResp.totalFilesMax) &&
							(gQResp.totalBytesUsed == (start_BytesUsed+actualBytesUsed)))
						{// remove some files then check quota again
							for(int i = 0; i < 5; i++)
							{
								XRLRemoveFile	removeReq = new XRLRemoveFile(removedUrls[i],randomTitleID,"Team");
								if(removeReq.Execute())
								{
									removedFiles++;
									removedBytes += removedFileSize[i];
								}
							}
							// check quota again
							XRLGetQuota		gQReq2 = new XRLGetQuota(3,randomTitleID,(uint)Constants.IdType.UserId ,1+randomTitleID);
							XRLGetQuotaResponse	gQResp2;
							if(gQReq2.Execute(out gQResp2))
							{
								if(gQResp2.totalFilesUsed == (gQResp2.totalFilesMax-removedFiles)&&
									(gQResp2.totalBytesUsed == (start_BytesUsed+actualBytesUsed-removedBytes)))
									ResultCode=TEST_RESULTS.PASSED;
							}
						}
					}
				}
			}
		}
		[TestCase, Description("create a file with multi ref, check quota; remove one ref check quota again")]
			class PQuotaFilesWithMultiRef : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");

				ulong			maxFileSize=0;
				ulong			totalBytesMax=0;
				uint			totalFilesMax=0;
				ulong			start_BytesUsed=0;
				uint			start_FilesUsed=0;
				// create a file for this title first to fill out the t_quotas table
				string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/566/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Team",url);
				if(req.Execute())
				{
					XRLGetQuota		getQuotaReq = new XRLGetQuota(3,randomTitleID,(uint)Constants.IdType.UserId ,1+randomTitleID);
					XRLGetQuotaResponse	getQuotaResp;
					if(getQuotaReq.Execute(out getQuotaResp))
					{
						maxFileSize = getQuotaResp.maxFileSize;
						totalBytesMax = getQuotaResp.totalBytesMax;
						totalFilesMax = getQuotaResp.totalFilesMax;
						start_BytesUsed = getQuotaResp.totalBytesUsed;
						start_FilesUsed = getQuotaResp.totalFilesUsed;
					}
					else
					{
						Global.RO.Warn("GetQuota request1 failed");
						return;
					}
				}
				else
					return;
				// create a blob with two references
				string url1= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/566/" + Guid.NewGuid().ToString();
				string url2= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/566/" + Guid.NewGuid().ToString();
				XRLWriteFile	req1 = new XRLWriteFile("Team",url1), req2 = new XRLWriteFile("Team",url2);

				req2.blobDataLen = req1.blobDataLen;
				req2.uiBlobSizeCompressed = req1.uiBlobSizeCompressed;
				for(int i = 0; i < req1.blobDataLen; i++)
					req2.blobData[i] = req1.blobData[i];
				for(int i = 0; i < Constants.sizeHash; i++)
					req2.blobHash[i] = req1.blobHash[i];

				if(req1.Execute() && req2.Execute())
				{
					XRLGetQuota		gQReq = new XRLGetQuota(3,randomTitleID,(uint)Constants.IdType.UserId ,1+randomTitleID);
					XRLGetQuotaResponse	gQResp;
					if(gQReq.Execute(out gQResp))
					{
						if((gQResp.totalFilesUsed == (start_FilesUsed+2)) &&
							(gQResp.totalBytesUsed == (start_BytesUsed+req1.blobDataLen+req2.blobDataLen)))
						{// remove one ref then check quota again
							XRLRemoveFile	removeReq = new XRLRemoveFile(url1,randomTitleID,"Team");
							if(removeReq.Execute())
							{		// check quota again
								XRLGetQuota		gQReq2 = new XRLGetQuota(3,randomTitleID,(uint)Constants.IdType.UserId ,1+randomTitleID);
								XRLGetQuotaResponse	gQResp2;
								if(gQReq2.Execute(out gQResp2))
								{	// totalBytesUsed and fileUsed should be changed.
									if(gQResp2.totalFilesUsed == (start_FilesUsed+1)&&
										(gQResp2.totalBytesUsed == (start_BytesUsed+req2.blobDataLen)))
										ResultCode=TEST_RESULTS.PASSED;
								}
							}
						}
					}
				}
			}
		}
        [TestCase, Description("create >max # allowed files, but byteUsed still within limit "), TestCasePriority(2)]
			class NQuotaOverflowTotalFiles : GlobalTitleWFNegTestBase
		{
			override protected void Execute()
			{
				// This test assume no files/bytes exist for this title
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				ulong	actualBytesUsed = 0;
				uint	totalFilesMax = 101;
				ulong	totalBytesMax = 864*1024;

				uint failed = 0;
				for(int i = 0; i < totalFilesMax; i++)
				{
					string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/566/" + Guid.NewGuid().ToString();
					XRLWriteFile	req = new XRLWriteFile("Team",url);
					if(!req.Execute())
					{
						failed++;
						return;
					}
					actualBytesUsed += req.blobDataLen;
				}
				if(failed == 0) // max # of files created for this title
				{	// create another file
					string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/566/" + Guid.NewGuid().ToString();
					XRLWriteFile	req = new XRLWriteFile("Team",url);
					ulong	totalActualBytes = actualBytesUsed+req.blobDataLen;
					if(totalActualBytes<=totalBytesMax)
						if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_QUOTA_EXCEEDED))
							ResultCode=TEST_RESULTS.PASSED;
						else
							Global.RO.Warn("Total number of files used is over limit");
				}
			}
		}
        [TestCase, Description("create >max allowed bytes, but # of filesUsed still within limit "), TestCasePriority(2)]
			class NQuotaOverflowTotalBytes : GlobalTitleWFNegTestBase
		{
			override protected void Execute()
			{
				// This test assume no files/bytes exist for this title
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x"), sTeamPUID =(1+randomTitleID).ToString("x");
				ulong	actualBytesUsed = 0;

				// for PerTitlePerTeam: bytesMax is 864KB, maxFiles is 101, maxSize = 64KB
				// so create 24 files each one is 36KB, then create aother one with 1 byte, which should fail
				uint failed = 0;
				for(int i = 0; i < 24; i++)
				{
					string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/566/" + Guid.NewGuid().ToString();
					XRLWriteFile	req = new XRLWriteFile("Team",url);
					req.blobDataLen = req.uiBlobSizeCompressed = 36*1024;
					req.blobData = new byte[36*1024];
					new Random().NextBytes(req.blobData);
					if(!req.Execute())
					{
						failed++;
						return;
					}
					actualBytesUsed += req.blobDataLen;
				}
				if(failed == 0) // maxBytes created for the title
				{	// create another file
					string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/566/" + Guid.NewGuid().ToString();
					XRLWriteFile	req = new XRLWriteFile("Team",url);
					req.blobDataLen = req.uiBlobSizeCompressed = 1;
					req.blobData = new byte[1];
					new Random().NextBytes(req.blobData);

					if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_QUOTA_EXCEEDED))
						ResultCode=TEST_RESULTS.PASSED;
					else
						Global.RO.Warn("Total bytes used is over limit");
				}
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\FuncUserTitleDF.cs ===
using System;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Storage;
using ServerTestFramework.LiveService.Signature;
using ServerTestFramework.Utilities;
using xonline.common.config;

namespace XStoreTest
{
    internal abstract class UserTitleDFTestBase : TestBase
    {
        protected bool RemoveFileSendAndVerify(XRLRemoveFile removeReq)
        {
            string pathName = removeReq.accessToken.baseAT.pathName;
            XRLWriteFile WriteReq = new XRLWriteFile("Owner", pathName);
            WriteReq.uiTitleId = removeReq.uiTitleId;
            if (!WriteReq.Execute())
            {
                Global.RO.Error("Write req failed: " + WriteReq.XErr.ToString("X"));
                return false;
            }
            if (!removeReq.Execute())
            {
                Global.RO.Error("Remove req failed: " + removeReq.XErr.ToString("X"));
                return false;
            }
            XRLReadFile readReq = new XRLReadFile(pathName);
            readReq.Slot.titleId = readReq.uiTitleId = WriteReq.uiTitleId;
            if (!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)) &&
                (readReq.XErr == HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
            {
                return true;
            }
            else
            {
                Global.RO.Warn("File was not removed: " + readReq.XErr.ToString("X"));
                return false;
            }
        }
    }

    internal abstract class NegUserTitleDFTestBase : TestBase
    {
        protected bool RemoveFileTestNegative(XRLRemoveFile    removeReq, uint XErr)
        {
            if (removeReq.Execute())
            {
                Global.RO.Warn("Negative RemoveFile request succeed unexpectedly");
                return false;
            }
            if(removeReq.XErr != XErr)
            {
                Global.RO.Warn("Wrong error code " + Global.XErrToString(removeReq.XErr) +" returned");
                return false;
            }
            return true;
        }
    }
    [TestGroup, Owner("JKonkle"), TestFrequency("Regression"), TestCasePriority(1)]
	public class FuncUserTitleDF : TestNode
    {
        /**********************************************************************************
         * Positive Wire Protocol Testing
         *********************************************************************************/
        [TestCase, Description("Check X-Delay in the http response header")]
        class PThrottling : UserTitleDFTestBase
        {
            override protected void Execute()
            {
                uint    titleID = (uint)RandomEx.GlobalRandGen.Next();
                string    sTitleID = titleID.ToString("x");
                string pathName= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Owner");

				int Xdelay= 3000;
				Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage,"exec :stfd SetXDelay "+removeReq.uiTitleId.ToString("X")+" removefile "+Xdelay);

                if(RemoveFileSendAndVerify(removeReq) &&
                    (removeReq.XDelay == Xdelay))
                    ResultCode=TEST_RESULTS.PASSED;

				Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage,"exec :stfd ReloadThrottleConfig");

            }
        }
        [TestCase, Description("Write a file first then call removeFile")]
			class PNormalCase : UserTitleDFTestBase
        {
            override protected void Execute()
            {
                uint    titleID = (uint)RandomEx.GlobalRandGen.Next();
                string    sTitleID = titleID.ToString("x");
                string pathName= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
                Global.RO.Info(pathName);
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Owner");
                if(RemoveFileSendAndVerify(removeReq))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("call removeFile with maximum titleID")]
			class PMaxTitleID : UserTitleDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//tuser.ffffffff/u:7878/ffffffff/" + Guid.NewGuid().ToString();
                uint    titleID = 0xffffffff;
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Owner");
                if(RemoveFileSendAndVerify(removeReq))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("call removeFile with minimum titleID")]
			class PMinTitleID : UserTitleDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//tuser.1/u:7878/1/" + Guid.NewGuid().ToString();
                uint    titleID = 1;
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Owner");
                if(RemoveFileSendAndVerify(removeReq))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("call removeFile with maximum titleVersion")]
			class PMaxTitleVersion : UserTitleDFTestBase
        {
            override protected void Execute()
            {
                uint    titleID = (uint)RandomEx.GlobalRandGen.Next();
                string    sTitleID = titleID.ToString("x");
                string pathName= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Owner");
                removeReq.uiTitleVersion = 0xffffffff;
                removeReq.Slot.titleVersion = 0xffffffff;
                if(RemoveFileSendAndVerify(removeReq))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("call removeFile with minimum titleVersion")]
			class PMinTitleVersion : UserTitleDFTestBase
        {
            override protected void Execute()
            {
                uint    titleID = (uint)RandomEx.GlobalRandGen.Next();
                string    sTitleID = titleID.ToString("x");
                string pathName= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Owner");
                removeReq.uiTitleVersion = 1;
                removeReq.Slot.titleVersion = 1;
                if(RemoveFileSendAndVerify(removeReq))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("call removeFile with max userPUID")]
			class PMaxUserPUID : UserTitleDFTestBase
        {
            override protected void Execute()
            {
                uint    titleID = (uint)RandomEx.GlobalRandGen.Next();
                string    sTitleID = titleID.ToString("x");
                string pathName= "//tuser."+sTitleID+"/u:ffffffffffffffff/"+sTitleID+"/" + Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Owner");
                removeReq.accessToken.baseAT.userPuid = 0xffffffffffffffff;
                removeReq.Slot.userPuid0 = 0xffffffffffffffff;
                if(RemoveFileSendAndVerify(removeReq))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("call removeFile with min userPUID")]
			class PMinUserPUID : UserTitleDFTestBase
        {
            override protected void Execute()
            {
                uint    titleID = (uint)RandomEx.GlobalRandGen.Next();
                string    sTitleID = titleID.ToString("x");
                string pathName= "//tuser."+sTitleID+"/u:1/"+sTitleID+"/" + Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Owner");
                removeReq.accessToken.baseAT.userPuid = 1;
                removeReq.Slot.userPuid0 = 1;
                if(RemoveFileSendAndVerify(removeReq))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("call removeFile with max XBoxID")]
			class PMaxBoxID : UserTitleDFTestBase
        {
            override protected void Execute()
            {
                uint    titleID = (uint)RandomEx.GlobalRandGen.Next();
                string    sTitleID = titleID.ToString("x");
                string pathName= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Owner");
                removeReq.accessToken.baseAT.xboxPuid = 0xffffffffffffffff;
                removeReq.Slot.machinePuid = 0xffffffffffffffff;
                if(RemoveFileSendAndVerify(removeReq))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("call removeFile with min XBoxID")]
			class PMinBoxID : UserTitleDFTestBase
        {
            override protected void Execute()
            {
                uint    titleID = (uint)RandomEx.GlobalRandGen.Next();
                string    sTitleID = titleID.ToString("x");
                string pathName= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Owner");
                removeReq.accessToken.baseAT.xboxPuid = 1;
                removeReq.Slot.machinePuid = 1;
                if(RemoveFileSendAndVerify(removeReq))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("call removeFile with 255 unicode chars")]
			class PMaxPathNameSize : UserTitleDFTestBase
        {
            override protected void Execute()
            {
                uint    titleID = (uint)RandomEx.GlobalRandGen.Next();
                string    sTitleID = titleID.ToString("x");
                string pathName= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
                StringBuilder    pathBuilder = new StringBuilder(pathName);
                if(pathName.Length < 255)
                    pathBuilder.Append('z',255-pathName.Length);

                XRLRemoveFile    removeReq = new XRLRemoveFile(pathBuilder.ToString(),titleID,"Owner");
                if(RemoveFileSendAndVerify(removeReq))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        /**********************************************************************************
         * Positive Other Testing
         *********************************************************************************/
        [TestCase, Description("create a file with a pathname and one title ID, call RemoveFile with the same pathname but different title ID"), TestCasePriority(2)]
			class NRemoveFromOtherTitle : TestBase
        {
            override protected void Execute()
            {
                uint    titleID = (uint)RandomEx.GlobalRandGen.Next();
                string    sTitleID = titleID.ToString("x");
                string pathName= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Owner");
                XRLWriteFile    WriteReq = new XRLWriteFile("Owner",pathName);

                // make sure we get a new "unique" ID.
                uint titleIDNew = (uint)RandomEx.GlobalRandGen.Next();
                while (titleIDNew == titleID)
                {
                    titleIDNew = (uint)RandomEx.GlobalRandGen.Next();
                }
                WriteReq.Slot.titleId = WriteReq.uiTitleId = titleIDNew; // 0x1235;

                if(WriteReq.Execute())
                {
                    if(!removeReq.Execute()&&(removeReq.XErr == HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
                            ResultCode=TEST_RESULTS.PASSED;
                }
            }
        }
        [TestCase, Description("call RemoveFile with the same pathname and titleID as writeFile but different title Version")]
			class PRemoveFromOtherTitleVersion : TestBase
        {
            override protected void Execute()
            {
                uint    titleID = (uint)RandomEx.GlobalRandGen.Next();
                string    sTitleID = titleID.ToString("x");
                string pathName= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Owner");
                XRLWriteFile    WriteReq = new XRLWriteFile("Owner",pathName);
                WriteReq.Slot.titleVersion = WriteReq.uiTitleVersion = removeReq.uiTitleVersion + 1;
                if(WriteReq.Execute())
                {
                    if(removeReq.Execute())
                    {
                        XRLReadFile        readReq = new XRLReadFile(pathName);
                        if(!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)) &&
                            (readReq.XErr == HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
                            ResultCode=TEST_RESULTS.PASSED;
                    }
                }
            }
        }
        [TestCase, Description("remove only one ref for a file with multiple references")]
			class PRemoveFileWithMultiRef : TestBase
        {
            override protected void Execute()
            {
                // write a blob with 4 references
                ulong    userPUID = (ulong)(new Random().NextDouble()*0xffffffffffffffff);
                string    pathName = "//tuser.1234/u:"+userPUID.ToString("x")+"/1234/" + Guid.NewGuid().ToString();
                uint    titleID = 0x1234;
                uint        FileWithMultiRefLen = 1024;
                byte[]        FileData = new byte[FileWithMultiRefLen];
                new Random().NextBytes(FileData);
                byte[]        FileWithMultiRefHash = new byte[Constants.sizeHash];
                new Random().NextBytes(FileWithMultiRefHash);
                string        MultiRefPath1 = "", RemovedRefPath = "";
                XRLWriteFile    wReq1 = new XRLWriteFile("Owner",pathName), wReq2 = new XRLWriteFile("Owner",pathName);
                for(int i = 0; i < 4; i++)
                {
                    pathName = "//tuser.1234/u:"+userPUID.ToString("x")+"/1234/" + Guid.NewGuid().ToString();
                    XRLWriteFile    writeReq = new XRLWriteFile("Owner",pathName);
                    writeReq.blobDataLen = FileWithMultiRefLen;
                    writeReq.uiBlobSizeCompressed = FileWithMultiRefLen;
                    writeReq.blobData = new byte[FileWithMultiRefLen];
                    FileData.CopyTo(writeReq.blobData,0);
                    FileWithMultiRefHash.CopyTo(writeReq.blobHash,0);

                    if(!writeReq.Execute())
                    {
                        Global.RO.Warn("Write File failed:"+i);
                        return;
                    }
                    if(i == 0)
                    {
                        wReq1 = writeReq;
                        MultiRefPath1 = writeReq.accessToken.baseAT.pathName;
                    }
                    else if (i == 1)
                        wReq2 = writeReq;
                    // the removed Ref path will be i = 3
                    RemovedRefPath = writeReq.accessToken.baseAT.pathName;
                }

                // only remove one reference to the file; the file still in the db and
                // check the i_ref_count=3
                XRLRemoveFile    removeReq = new XRLRemoveFile(RemovedRefPath,titleID,"Owner");
                if(removeReq.Execute())
                {
                    XRLReadFile        readReq = new XRLReadFile(MultiRefPath1);
                    readReq.Slot.titleId = readReq.uiTitleId = titleID;
                    XRLReadFileResponse    resp;
                    if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out resp))
                        // check ref count
                        if(wReq1.CheckRefCount(wReq2,3,false))
                            ResultCode=TEST_RESULTS.PASSED;
                }
            }
        }
        [TestCase, Description("remove all refs for a file with multiple references")]
			class PRemoveFileWithMultiRef2 : TestBase
        {
            override protected void Execute()
            {
                ulong    userPUID = (ulong)(new Random().NextDouble()*0xffffffffffffffff);
                string    pathName = "//tuser.1234/u:"+userPUID.ToString("x")+"/1234/" + Guid.NewGuid().ToString();
                uint    titleID = 0x1234;
                // write a blob with 2 references
                uint        FileWithMultiRefLen = 1024;
                byte[]        FileData = new byte[FileWithMultiRefLen];
                new Random().NextBytes(FileData);
                byte[]        FileWithMultiRefHash = new byte[Constants.sizeHash];
                new Random().NextBytes(FileWithMultiRefHash);
                string        []refPath = new string[2]{"",""};
                XRLWriteFile    [] writeReq = new XRLWriteFile[2]{null, null};
                for(int i = 0; i < 2; i++)
                {
                    refPath[i] = pathName = "//tuser.1234/u:"+userPUID.ToString("x")+"/1234/" + Guid.NewGuid().ToString();
                    writeReq[i] = new XRLWriteFile("Owner",pathName);
                    writeReq[i].blobDataLen = FileWithMultiRefLen;
                    writeReq[i].uiBlobSizeCompressed = FileWithMultiRefLen;
                    writeReq[i].blobData = new byte[FileWithMultiRefLen];
                    FileData.CopyTo(writeReq[i].blobData,0);
                    FileWithMultiRefHash.CopyTo(writeReq[i].blobHash,0);

                    if(!writeReq[i].Execute())
                    {
                        Global.RO.Warn("Write File failed:"+i);
                        return;
                    }
                }

                // remove all references to the file; the file will be deleted
                XRLRemoveFile    removeReq1 = new XRLRemoveFile(refPath[0],titleID,"Owner");
                XRLRemoveFile    removeReq2 = new XRLRemoveFile(refPath[1],titleID,"Owner");
                if(removeReq1.Execute() && (removeReq2.Execute()))
                {
                    XRLReadFile        readReq = new XRLReadFile(refPath[0]);
                    readReq.Slot.titleId = readReq.uiTitleId = titleID;
                    if(!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage))&&
                        (readReq.XErr==HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
                        ResultCode=TEST_RESULTS.PASSED;
                }
            }
        }
        /**********************************************************************************
         * Negative Wire Protocol Testing
         *********************************************************************************/
        [TestCase, Description("33875:the userPUID in SGAuth response is different than the one in removeFile request"), TestCasePriority(2)]
			class NSGAuthInvalidUserPUID : NegUserTitleDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//tuser.1234/u:7878/1234/" + Guid.NewGuid().ToString();
                uint    titleID = 0x1234;
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Owner");
                removeReq.Slot.userPuid0++;
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("the userPUID in SGAuth response is not_found user"), TestCasePriority(2)]
			class NSGAuthNotFoundUser : NegUserTitleDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//tuser.1234/u:7878/1234/" + Guid.NewGuid().ToString();
                uint    titleID = 0x1234;
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Owner");
                removeReq.Slot.UserExists = 0;
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_SERVER_ERROR))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("31658:the machineID in SGAuth response is not the one in the removeFile request"), TestCasePriority(2)]
			class NSGAuthInvalidXBoxID : NegUserTitleDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//tuser.1234/u:7878/1234/" + Guid.NewGuid().ToString();
                uint    titleID = 0x1234;
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Owner");
                removeReq.Slot.machinePuid++;
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("31658:the titleID in SGAuth response is not the one in the removeFile request"), TestCasePriority(2)]
			class NSGAuthInvalidTitleID : NegUserTitleDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//tuser.1234/u:7878/1234/" + Guid.NewGuid().ToString();
                uint    titleID = 0x1234;
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Owner");
                removeReq.Slot.titleId++;
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_INVALID_TITLE_ID))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("31659:the titleVersion in SGAuth response is not the one in the removeFile request"), TestCasePriority(2)]
			class NSGAuthInvalidTitleVersion : NegUserTitleDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//tuser.1234/u:7878/1234/" + Guid.NewGuid().ToString();
                uint    titleID = 0x1234;
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Owner");
                removeReq.Slot.titleVersion++;
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("the serviceID in SGAuth response is not 0"), TestCasePriority(2)]
			class NSGAuthInvalidServiceID : NegUserTitleDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//tuser.1234/u:7878/1234/" + Guid.NewGuid().ToString();
                uint    titleID = 0x1234;
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Owner");
                removeReq.Slot.ClearServices();
                removeReq.Slot.AddService(XOService.Stats);
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_SERVER_ERROR))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("31660:Call RemoveFile with invalid pathName"), TestCasePriority(2)]
			class NFileNotFound : NegUserTitleDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//tuser.1234/u:7878/1234/" + Guid.NewGuid().ToString();
                uint    titleID = 0x1234;
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Owner");
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass non-removeFile operation"), TestCasePriority(2)]
			class NInvalidOperation : NegUserTitleDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//tuser.1234/u:7878/1234/" + Guid.NewGuid().ToString();
                uint    titleID = 0x1234;
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Owner");
                removeReq.accessToken.baseAT.operation = (ushort)Constants.Operation.FileEnumerate;
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
//        [TestCase, Description(""), TestCasePriority(2)] class NInvalidServiceID : NegUserTitleDFTestBase
//        {
//            public NInvalidServiceID()
//            {
//                Name = "NInvalidServiceID";
//                Desc = "pass invalid serviceID(not 0)";
//            }
//            override protected void Execute()
//            {
//                string    pathName = "//tuser.1234/u:7878/1234/" + Guid.NewGuid().ToString();
//                uint    titleID = 0x1234;
//                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Owner");
//                removeReq.accessToken.baseAT.serviceId = (uint)XOService.Matchmaking;
//                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
//                    ResultCode=TEST_RESULTS.PASSED;
//            }
//        }
        [TestCase, Description("pass 0 as userPUID"), TestCasePriority(2)]
			class NZeroUserPUID : NegUserTitleDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//tuser.1234/u:0/1234/" + Guid.NewGuid().ToString();
                uint    titleID = 0x1234;
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Owner");
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_SERVER_ERROR))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass 0 as xboxPUID"), TestCasePriority(2)]
			class NZeroXBoxPUID : NegUserTitleDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//tuser.1234/u:7878/1234/" + Guid.NewGuid().ToString();
                uint    titleID = 0x1234;
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Owner");
                removeReq.accessToken.baseAT.xboxPuid = 0;
                removeReq.Slot.machinePuid = 0;
                 
                // if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))                 
                // We either have to disable this test or check 'XONLINE_E_SERVER_ERROR' since the server 
                // actually returns 'XONLINE_E_SERVER_ERROR' complaining "Invalid platform type"
                if (RemoveFileTestNegative(removeReq, HResult.XONLINE_E_SERVER_ERROR))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pathNameLen is greater than the actual pathname"), TestCasePriority(2)]
			class NTruncatePathname : NegUserTitleDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//tuser.1234/u:7878/1234/" + Guid.NewGuid().ToString();
                uint    titleID = 0x1234;
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Owner");
                removeReq.accessToken.baseAT.ManualArraySize = true;
                removeReq.accessToken.baseAT.pathNameLen +=1;    //??????what's the right error code?
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pathNameLen is shorter than the actual pathname"), TestCasePriority(2)]
			class NOverflowPathname : NegUserTitleDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//tuser.1234/u:7878/1234/" + Guid.NewGuid().ToString();
                uint    titleID = 0x1234;
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Owner");
                removeReq.accessToken.baseAT.ManualArraySize = true;
                removeReq.accessToken.baseAT.pathNameLen -=1;    //??????what's the right error code?
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass NULL for pathName"), TestCasePriority(2)]
			class NNullPathname : NegUserTitleDFTestBase
        {
            override protected void Execute()
            {
                uint    titleID = 0x1234;
                XRLRemoveFile    removeReq = new XRLRemoveFile(null,titleID,"Owner");

                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("token expiration time is before current time"), TestCasePriority(2)]
			class NInvalidTokenExpTime : NegUserTitleDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//tuser.1234/u:7878/1234/" + Guid.NewGuid().ToString();
                uint    titleID = 0x1234;
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Owner");
                removeReq.accessToken.removeAT.tokenExpirationDate = (long)System.DateTime.UtcNow.AddHours(-1).ToFileTimeUtc();
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        //  [TestCase, Description("pass removeFile request to stfd port 11140 other than 80"), TestCasePriority(2)]
			class NDCReq : NegUserTitleDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//tuser.1234/u:7878/1234/" + Guid.NewGuid().ToString();
                uint    titleID = 0x1234;
                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Owner");
                removeReq.Server.Port = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int).Port;

                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("create a file with one userPUID;call RemoveFile with the same pathName but different userPUID"), TestCasePriority(2)]
			class NRemoveByAnotherUser : NegUserTitleDFTestBase
        {
            override protected void Execute()
            {
                string    pathName = "//tuser.1234/u:7878/1234/" + Guid.NewGuid().ToString();
                uint    titleID = 0x1234;

                XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"Owner");
                removeReq.accessToken.baseAT.userPuid = 0x78789;
                removeReq.Slot.userPuid0 = 0x78789;
                if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\FuncUserTitleRF.cs ===
using System;
using System.Text;
using System.IO;
using System.Net;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Storage;
using xonline.common.config;

namespace XStoreTest
{
	internal abstract class NegUserTitleRFTestBase : TestBase
	{
		//	send readFile requests, then check the error code
		protected bool ReadFileTestNegative(XRLReadFile ReadFileReq, uint XErr)
		{
			XRLReadFileResponse	ReadFileResp;
			if (ReadFileReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out ReadFileResp))
			{
				Global.RO.Warn("Negative ReadFile request succeed unexpectedly");
				return false;
			}
			if((ReadFileReq.XErr != XErr) || (ReadFileResp != null))
			{
				Global.RO.Warn("Wrong error code " + Global.XErrToString(ReadFileReq.XErr) +" returned or ReadFileResp is not null");
				return false;
			}
			return true;
		}
	}
	/// <summary>
	/// Summary description for FuncUserTitleRF.
	/// </summary>
    [TestGroup, Owner("JKonkle"), TestFrequency("Regression"), TestCasePriority(1)]
	public class FuncUserTitleRF : TestNode
	{
		/**********************************************************************
		 * Wire Protocol Testing Cases
		 **********************************************************************/
		[TestCase, Description("Check X-Delay in the http response header")]
			class PThrottling : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					int Xdelay= 3000;
					Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage,"exec :stfd SetXDelay "+readReq.uiTitleId.ToString("X")+" readfile "+Xdelay);

					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp) &&
						(readReq.XDelay == Xdelay))
						ResultCode=TEST_RESULTS.PASSED;

					Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage,"exec :stfd ReloadThrottleConfig");

				}
			}
		}
		[TestCase, Description("the titleID in the request is not the acutal logged on title")]
			class PFamilyTitleID : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.altTitleId1 = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleId = readReq.uiTitleId + 1;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("read a file for TitleA to the cache; try to read the file from a different title")]
			class PReadCacheFromDiffTitle : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp, readResp2;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
					{
						// the file now is in the cache; try to read the file from titleB
						XRLReadFile		readReq2 = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
						readReq2.Slot.titleId = readReq2.uiTitleId = writeReq.uiTitleId + 1;
						readReq2.Slot.titleVersion = readReq2.uiTitleVersion;
						if(!readReq2.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out readResp2))
                        {
							if(readReq2.XErr == HResult.XONLINE_E_STORAGE_ERROR)
                            {
                                ResultCode = TEST_RESULTS.PASSED;
                            }
                            else
                            {
                                Global.RO.Warn("Wrong error code " + Global.XErrToString(readReq2.XErr) + " returned");
                            }
                        }
                        else
                        {
                            Global.RO.Warn("Read succeeded when it should've failed.");
                        }
                    }
				}
			}
		}
		[TestCase, Description("no readFile cache for PerTitlePerUser storage")]
			class PNoReadCache : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string pathName= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("Owner",pathName);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp, readResp2;
					XRLReadFile		readReq = new XRLReadFile(pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
					{
						// the file now is in the cache;
						// remove the actual file, then read the file again
						XRLRemoveFile	removeReq = new XRLRemoveFile(pathName,writeReq.uiTitleId,"Owner");
						if(removeReq.Execute())
						{
							XRLReadFile		readReq2 = new XRLReadFile(pathName);
							readReq2.Slot.titleId = readReq2.uiTitleId = writeReq.uiTitleId;
							readReq2.Slot.titleVersion = readReq2.uiTitleVersion;
							if(!readReq2.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out readResp2) &&
								(readReq2.XErr == HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
								ResultCode=TEST_RESULTS.PASSED;
						}
					}
				}
			}
		}
	
		[TestCase, Description("33960:Write a file first; then read the file with ifModifiedSince>actualModifiedTime")]
			class PModifiedSince : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);

				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;
					readReq.lIfModifiedSinceDate = (long)System.DateTime.UtcNow.AddHours(2).ToFileTimeUtc();
					if(!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp)&&
						(readReq.XErr == HResult.XONLINE_S_STORAGE_FILE_NOT_MODIFIED) && (readResp == null))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("Write a file first; the request this file with userCountryID set to max")]
		class PMaxUserCountryID : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.bUserCountryId = 0xff;
					readReq.Slot.userFlag0 = 0xff<<8;
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("Write a file first; the request this file with userCountryID set to min")]
		class PMinUserCountryID : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.userFlag0 = readReq.bUserCountryId = 0;
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("Write a file first; the request this file with userPUID set to max")]
		class PMaxUserPUID : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					readReq.Slot.userPuid0 = readReq.accessToken.baseAT.userPuid = 0xffffffffffffffff;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("Write a file first; the request this file with userPUID set to min")]
		class PMinUserPUID : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					readReq.Slot.userPuid0 = readReq.accessToken.baseAT.userPuid = 1;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("Write a file first; the request this file with machine PUID set to max")]
		class PMaxXBoxPUID : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					readReq.Slot.machinePuid = readReq.accessToken.baseAT.xboxPuid = 0xffffffffffffffff;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("Write a file first; the request this file with machine PUID set to min")]
		class PMinXBoxPUID : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					readReq.Slot.machinePuid = readReq.accessToken.baseAT.xboxPuid = 1;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request with mismatched TitleID"), TestCasePriority(2)]
		class NMismatchedTitleID : NegUserTitleRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId + 1;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_ERROR))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("write a valid file first, then request with mismatched TitleVersion")]
		class PMismatchedTitleVersion : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion + 1;
					XRLReadFileResponse		Response;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out Response))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("pass null for AccessToken"), TestCasePriority(2)]
		class NAccessTokenNullAT : NegUserTitleRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLReadFile		readReq = new XRLReadFile(url);
				readReq.accessToken = null;

				if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode = TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass 0 for userPUID for AccessToken"), TestCasePriority(2)]
		class NAccessTokenZeroUserPUID : NegUserTitleRFTestBase
		{
			override protected void Execute()
			{
				string url= "//tuser.12345/u:8989/12345/" + Guid.NewGuid().ToString();
				XRLReadFile		readReq = new XRLReadFile(url);
				readReq.Slot.userPuid0 = readReq.accessToken.baseAT.userPuid = 0;

				if(ReadFileTestNegative(readReq,HResult.XONLINE_E_SERVER_ERROR))
					ResultCode = TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass non-readfile operation in the AT"), TestCasePriority(2)]
		class NAccessTokenMismatchedOp : NegUserTitleRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLReadFile		readReq = new XRLReadFile(url);
				readReq.accessToken.baseAT.operation = (ushort)Constants.Operation.FileWrite;

				if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode = TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("write a file first, then request it with pathnameLen is greater than the actual pathname"), TestCasePriority(2)]
		class NAccessTokenTruncatePathname : NegUserTitleRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					readReq.accessToken.baseAT.ManualArraySize = true;
					readReq.accessToken.baseAT.pathNameLen += 1;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a file first, then request it with pathnameLen is less than the actual pathname"), TestCasePriority(2)]
		class NAccessTokenOverflowPathname : NegUserTitleRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					readReq.accessToken.baseAT.ManualArraySize = true;
					readReq.accessToken.baseAT.pathNameLen -= 1;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("pass null for pathname and pathnameLen is 0"), TestCasePriority(2)]
		class NAccessTokenNullPathname : NegUserTitleRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLReadFile		readReq = new XRLReadFile(url);
				readReq.accessToken.baseAT.pathName = null;
				readReq.accessToken.baseAT.pathNameLen = 0;

				if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode = TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("AccessToken size is greater than 255+baseAT"), TestCasePriority(2)]
		class NAccessTokenOverflowAT : NegUserTitleRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLReadFile		req = new XRLReadFile(url);
				StringBuilder	pathName = new StringBuilder(req.accessToken.baseAT.pathName);
				int		numUniCharToAdd = 256 - req.accessToken.baseAT.pathNameLen;
				string			temp = new string('a',numUniCharToAdd);
				pathName.Append(temp);
				req.accessToken.baseAT.pathNameLen = 256;//actual pathName length is 256
				req.accessToken.baseAT.pathName = pathName.ToString();

				if(ReadFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode = TEST_RESULTS.PASSED;
			}
		}

        [TestCase, Description("write file first, then request it with non-null signature but sigSize is zero"), TestCasePriority(2)]
		class NAccessTokenNonNullSignature : NegUserTitleRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.accessToken.readAT.ManualArraySize = true;
					readReq.accessToken.readAT.signatureLen = 0;
					readReq.accessToken.readAT.signature = new byte[Constants.sizeSignature];
					for(int i = 0; i < Constants.sizeSignature; i++)
						readReq.accessToken.readAT.signature[i] = 0;
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write file first, then request it with token exp is before current time"), TestCasePriority(2)]
		class NAccessTokenWrongATExpTime : NegUserTitleRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.accessToken.readAT.tokenExpirationDate = System.DateTime.UtcNow.AddDays(-1).ToFileTimeUtc();
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write file first, then request it with non-zero flags"), TestCasePriority(2)]
		class NAccessTokenWrongFlags : NegUserTitleRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.accessToken.baseAT.flags = 1;
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
		/**********************************************************************
		 * Pathname Testing Cases
		 **********************************************************************/
        [TestCase, Description("write a valid file first, then request it with one null char in the middle of <Domain-part>"), TestCasePriority(2)]
		class NPathnameBadString1 : NegUserTitleRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					newPath = pathName.Insert(6,'\0'.ToString());

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					//TODO: need to return xonline_e_storage_domain_not_supported
					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it with two null char in the middle of <domain-part>"), TestCasePriority(2)]
		class NPathnameBadString2 : NegUserTitleRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath, temp;
					temp = '\0'.ToString() + '\0'.ToString();
					newPath = pathName.Insert(6,temp);	// //stat..s/u:....

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					//TODO: need to return xonline_e_storage_domain_not_supported
					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it with one nullchar in the middle of <userPUID>"), TestCasePriority(2)]
		class NPathnameBadString3 : NegUserTitleRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					newPath = pathName.Insert(17,'\0'.ToString());

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it with one nullchar in the middle of <pathpart>"), TestCasePriority(2)]
		class NPathnameBadString4 : NegUserTitleRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					newPath = pathName.Insert(38,'\0'.ToString());

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it with one nullchar at the end of <pathpart>"), TestCasePriority(2)]
		class NPathnameBadString5 : NegUserTitleRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					newPath = pathName + '\0'.ToString();

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it by passing a nonexisitent <path-part>(vc_name)"), TestCasePriority(2)]
		class NPathnameNonExistFile1 : NegUserTitleRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					int		guidStartPos = pathName.LastIndexOf('/');
					newPath = pathName.Substring(0,guidStartPos)+ "/" + Guid.NewGuid().ToString();

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it by passing wrong owner PUID"), TestCasePriority(2)]
		class NPathnameNonExistFile2 : NegUserTitleRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					int		pos = pathName.IndexOf("u:"), guidStart = pathName.LastIndexOf('/');
					newPath = pathName.Substring(0,pos)+ "u:393939/" + sTitleID+pathName.Substring(guidStart);

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it by passing wrong IDNameSpace"), TestCasePriority(2)]
		class NPathnameNonExistFile3 : NegUserTitleRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					newPath = pathName.Replace("u:","x:");

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it by passing wrong Domain"), TestCasePriority(2)]
		class NPathnameNonExistFile4 : NegUserTitleRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					newPath = pathName.Replace("tuser","voice");

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					//TODO: proper error code needed
					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_PATH))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("Write file first, then request it by passing a pathname that has no domain part"), TestCasePriority(2)]
		class NPathnameNoDomainPart : NegUserTitleRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					string path = writeReq.accessToken.baseAT.pathName, newPath, temp;
					temp = path.Substring(path.IndexOf("u:"));
					newPath = "///" + temp;

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					//TODO: need new error code
					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("Write file first, then request it by passing noID namespace"), TestCasePriority(2)]
		class NPathnameNoIDNameSpace : NegUserTitleRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					string path = writeReq.accessToken.baseAT.pathName, newPath;
					newPath = path.Remove(path.IndexOf("u:"),1);

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("Write file first, then request it by passing no userPUID"), TestCasePriority(2)]
		class NPathnameNoUserPUID : NegUserTitleRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					string pathName = writeReq.accessToken.baseAT.pathName, newPath;
					int		pos = pathName.IndexOf("u:"), guidStart = pathName.LastIndexOf('/');
					newPath = pathName.Substring(0,pos)+ "u:" + pathName.Substring(guidStart);

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("Write file first, then request it by passing overflow PUID"), TestCasePriority(2)]
		class NPathnameOverflowUserPUID : NegUserTitleRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					string pathName = writeReq.accessToken.baseAT.pathName, newPath;
					int		pos = pathName.IndexOf("u:"), guidStart = pathName.LastIndexOf('/');
					newPath = pathName.Substring(0,pos)+ "u:" + "ffffffffffffffff1" + pathName.Substring(guidStart);

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("Write file first, then request it by passing 0 PUID"), TestCasePriority(2)]
		class NPathnameZeroUserPUID : NegUserTitleRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					string pathName = writeReq.accessToken.baseAT.pathName, newPath;
					int		pos = pathName.IndexOf("u:"), guidStart = pathName.LastIndexOf('/');
					newPath = pathName.Substring(0,pos)+ "u:0" + pathName.Substring(guidStart);

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("Write file first, then request it by pass wrong charset"), TestCasePriority(2)]
		class NPathnameWrongCharSet : NegUserTitleRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					string path = writeReq.accessToken.baseAT.pathName;
					StringBuilder	pathName = new StringBuilder(path);
					//Bug 27831: domain and optional domain specified: A-Za-z0-9_
					// pathname allows anything except control chars('\0\, control characters, etc)
					char i = '\0';
					pathName.Append(i);

					XRLReadFile		readReq = new XRLReadFile(pathName.ToString());
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
		/***********************************************************************
		* SG Auth Data Testing
		* *********************************************************************/
        [TestCase, Description("the userPUID in SGAuth response is not_found user"), TestCasePriority(2)]
			class NSGAuthNotFoundUser : NegUserTitleRFTestBase
		{
			override protected void Execute()
			{
				string url= "//tuser.12345/u:8989/12345/" + Guid.NewGuid().ToString();
				XRLReadFile		req = new XRLReadFile(url);
				req.Slot.UserExists = 0;

				if(ReadFileTestNegative(req,HResult.XONLINE_E_SERVER_ERROR))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the userPUID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidUser : NegUserTitleRFTestBase
		{
			override protected void Execute()
			{
				string url= "//tuser.12345/u:8989/12345/" + Guid.NewGuid().ToString();
				XRLReadFile		req = new XRLReadFile(url);
				req.Slot.userPuid0++;

				if(ReadFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the TitleID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidTitleID : NegUserTitleRFTestBase
		{
			override protected void Execute()
			{
				string url= "//tuser.12345/u:8989/12345/" + Guid.NewGuid().ToString();
				XRLReadFile		req = new XRLReadFile(url);
				req.Slot.titleId++;

				if(ReadFileTestNegative(req,HResult.XONLINE_E_INVALID_TITLE_ID))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the XBoxPUID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidXBoxPUID : NegUserTitleRFTestBase
		{
			override protected void Execute()
			{
				string url= "//tuser.12345/u:8989/12345/" + Guid.NewGuid().ToString();
				XRLReadFile		req = new XRLReadFile(url);
				req.Slot.machinePuid++;

				if(ReadFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the TitleVersion in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidTitleVersion : NegUserTitleRFTestBase
		{
			override protected void Execute()
			{
				string url= "//tuser.12345/u:8989/12345/" + Guid.NewGuid().ToString();
				XRLReadFile		req = new XRLReadFile(url);
				req.Slot.titleVersion++;

				if(ReadFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the CountryID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidCountryID : NegUserTitleRFTestBase
		{
			override protected void Execute()
			{
				string url= "//tuser.12345/u:8989/12345/" + Guid.NewGuid().ToString();
				XRLReadFile		req = new XRLReadFile(url);
				req.Slot.userFlag0 = (uint)((req.bUserCountryId+1)<<8);

				if(ReadFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		/**********************************************************************
		 * Other ReadFile Testing Cases
		 **********************************************************************/
		[TestCase, Description("Multiple threads read same file simultaneously")]
		class PMultiThreadsReadFile : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				pathName = writeReq.accessToken.baseAT.pathName;
				uiTitleId = writeReq.uiTitleId;
				uiTitleVersion = writeReq.uiTitleVersion;

				if(writeReq.Execute())
				{
					Thread [] threadArray = new Thread[10];
					for(int i = 0; i < 10; i++)
					{
						threadArray[i] = ThreadMaker.CreateThread(readFileTS);
						threadArray[i].Start();
					}
					// the main thread is waiting for all threads to exit or timeout
					foreach (Thread t in threadArray)
						t.Join(1000);
					if(FailedReqs == 0)
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
			private void readFileTS()
			{
				XRLReadFileResponse	readResp;
				XRLReadFile		readReq = new XRLReadFile(pathName);
				readReq.Slot.titleId = readReq.uiTitleId = uiTitleId;
				readReq.Slot.titleVersion = readReq.uiTitleVersion = uiTitleVersion;

				if(!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out readResp))
				{
					Global.RO.Warn("readFileTS: read file request failed");
					Interlocked.Increment(ref FailedReqs);
				}
			}
			private string	pathName;
			private uint	uiTitleId, uiTitleVersion;
			private int		FailedReqs;
		}
		[TestCase, Description("read file 100 times and check bi_read_count in t_files")]
		// bi_read_count in t_files: number of times the file has been read
		class PReadFileMultiTimes : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					uint				uiFailedReq = 0;
					for(int i = 0; i < 100; i++)
					{
						XRLReadFileResponse	readResp;
						XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
						readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
						readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
						if(!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
							uiFailedReq++;
					}
					if(uiFailedReq == 0)
						ResultCode=TEST_RESULTS.PASSED;
					// check bi_read_count in t_files
					// Bug26804:since we cache file in the front door, it will be 1 instead of 100
					//					long expectedCount = 1;
					//					XRLWriteFile	dumbReq = new XRLWriteFile();
					//					if(writeReq.CheckReadCount(dumbReq,expectedCount))
					//						if(uiFailedReq == 0)
					//							ResultCode=TEST_RESULTS.PASSED;
					//						else
					//							Global.RO.Warn("bi_read_count is set right, but not all 100 read requests succeeded");
				}
			}
		}
        [TestCase, Description("Read file from a different title other than creator's"), TestCasePriority(2)]
			class NFromDifferentTitle : NegativeRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId + 1;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion + 1;
					if(!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
                    {
						if(readReq.XErr == HResult.XONLINE_E_STORAGE_ERROR)
                        {
                            ResultCode = TEST_RESULTS.PASSED;
                        }
                        else
                        {
                            Global.RO.Warn("Wrong error code " + Global.XErrToString(readReq.XErr) + " returned");
                        }
                    }
                    else
                    {
                        Global.RO.Warn("Read succeeded when it should've failed.");
                    }
                }
			}
		}
		[TestCase, Description("Read file from a different titleVersion other than creator's")]
			class PFromDifferentTitleVersion : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion + 1;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\FuncUserTitleWF.cs ===
using System;
using System.Globalization;
using System.Text;
using System.Net;
using System.IO;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Storage;
using ServerTestFramework.LiveService.Signature;
using xonline.common.config;

namespace XStoreTest
{
	internal abstract class UserTitleWFTestBase : TestBase
	{
		//	send WriteFile request first; then send readfile;verifies the response
		protected bool WriteFileSendAndVerify(XRLWriteFile WriteFileReq)
		{
			bool fPassed=WriteFileReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage));
			if (!fPassed)
			{
				Global.RO.Warn("Failed to send WriteFile request ");
				return false;
			}

			XRLReadFileResponse	ReadFileResp;
			XRLReadFile			ReadFileReq = new XRLReadFile(WriteFileReq.accessToken.baseAT.pathName);
			ReadFileReq.Slot.titleId = ReadFileReq.uiTitleId = WriteFileReq.uiTitleId;
			ReadFileReq.Slot.titleVersion = ReadFileReq.uiTitleVersion = WriteFileReq.uiTitleVersion;
			if (ReadFileReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out ReadFileResp))
			{
				//?????? need to rewrite according to the new schema
				if ((!ReadFileResp.Compare(WriteFileReq)) || (!WriteFileReq.Verify()))
				{
					Global.RO.Warn("WriteFile request is not set correctly in the db");
					return false;
				}
			}
			else
			{
				Global.RO.Warn("Failed to send ReadFile request");
				return false;
			}
			return true;
		}
	}
	internal abstract class UserTitleWFNegTestBase : TestBase
	{
		//	send WriteFile request first; then send readfile;verifies the response
		protected bool WriteFileTestNegative(XRLWriteFile WriteFileReq,uint XErr)
		{
			if (WriteFileReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
			{
				Global.RO.Warn("Negative WriteFile request succeed unexpectedly");
				return false;
			}
			if(WriteFileReq.XErr != XErr)
			{
				Global.RO.Warn("Wrong error code returned " + Global.XErrToString(WriteFileReq.XErr));
				return false;
			}
			// now we need to check the file is not written to the DB
			XRLReadFileResponse	ReadFileResp;
			XRLReadFile			ReadFileReq = new XRLReadFile(WriteFileReq.accessToken.baseAT.pathName);
			ReadFileReq.Slot.titleId = ReadFileReq.uiTitleId = WriteFileReq.uiTitleId;
			ReadFileReq.Slot.titleVersion = ReadFileReq.uiTitleVersion = WriteFileReq.uiTitleVersion;
			if (!ReadFileReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out ReadFileResp))
			{
				/*				if((ReadFileReq.XErr != HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND)
									||(ReadFileResp != null))
								{
									Global.RO.Warn("file_not_found error is not returned OR File is being written to DB unexpectedly");
									return false;
								}
								*/
				if(ReadFileResp != null)
				{
					Global.RO.Warn("File is being written to DB unexpectedly");
					return false;
				}
			}
			else
			{
				Global.RO.Warn("ReadFile request succeed with S_OK unexpectedly");
				return false;
			}
			return true;
		}
	}
    [TestGroup, Owner("JKonkle"), TestFrequency("Regression"), TestCasePriority(1)]
	public class FuncUserTitleWF : TestNode
	{
		/***********************************************************************
		 * Wire Protocol Testing
		 * *********************************************************************/
		[TestCase, Description("Check X-Delay in the http reaposne")]
		class PThrottling : UserTitleWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.attributes = new byte[100];
				new Random().NextBytes(req.attributes);
				req.attributesLen = (ushort)req.attributes.Length;

				int Xdelay= 3000;
				Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage,"exec :stfd SetXDelay "+req.uiTitleId.ToString("X")+" writefile "+Xdelay);

				if(WriteFileSendAndVerify(req)&& (req.XDelay == Xdelay))
					ResultCode=TEST_RESULTS.PASSED;

				Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage,"exec :stfd ReloadThrottleConfig");

			}
		}
		[TestCase, Description("Write a file with all valid parameters including attributes")]
		class PNormalCase : UserTitleWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.attributes = new byte[100];
				new Random().NextBytes(req.attributes);
				req.attributesLen = (ushort)req.attributes.Length;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write a 1k file")]
		class PSmallFileSize : UserTitleWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.blobData = new byte[1024];
				new Random().NextBytes(req.blobData);
				req.blobDataLen = req.uiBlobSizeCompressed = (uint)req.blobData.Length;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write a 4k file")]
		class PMediumFileSize : UserTitleWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.blobData = new byte[1024*4];
				new Random().NextBytes(req.blobData);
				req.blobDataLen = req.uiBlobSizeCompressed = (uint)req.blobData.Length;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write a slightly smaller than max allowed file")]
			class PLargeFileSize : UserTitleWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.blobData = new byte[80000];
				new Random().NextBytes(req.blobData);
				req.blobDataLen = req.uiBlobSizeCompressed = (uint)req.blobData.Length;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write a file with title ID set to max value")]
			class PMaxTitleID : UserTitleWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.uiTitleId = 0xffffffff;
				req.Slot.titleId = 0xffffffff;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write a file with title ID set to min value")]
			class PMinTitleID : UserTitleWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.uiTitleId = req.Slot.titleId = 0;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write a file with titleVersion set to max value")]
			class PMaxTitleVersion : UserTitleWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.uiTitleVersion = 0xffffffff;
				req.Slot.titleVersion = 0xffffffff;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write a file with titleVersion set to min value")]
			class PMinTitleVersion : UserTitleWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.uiTitleVersion = 0;
				req.Slot.titleVersion = 0;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write a file with countryID set to max value")]
			class PMaxUserCountryID : UserTitleWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.bUserCountryId = 0xff;
				req.Slot.userFlag0 = (uint)0xff<<8;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write a file with countryID set to min value")]
			class PMinUserCountryID : UserTitleWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.bUserCountryId = 0;
				req.Slot.userFlag0 = 0;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write a max size file")]
			class PBlobDataMaxSize : UserTitleWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.blobData = new byte[64*1024];
				for(int i = 0; i < req.blobData.Length; i++)
					req.blobData[i] = (byte)(i%256);
				req.blobDataLen = req.uiBlobSizeCompressed = (uint)req.blobData.Length;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass attributes with 256 byte")]
		class PMaxAttributeSize : UserTitleWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				uint			attribLen = Constants.maxSizeAttributes;
				req.attributes = new byte[attribLen];
				for(int i = 0; i < req.attributes.Length; i++)
					req.attributes[i] = 1;
				req.attributesLen = (ushort)req.attributes.Length;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass 0 attributeslen")]
			class PMinAttributeSize : UserTitleWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.attributes = null;
				req.attributesLen = 0;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass max value for UserPUID in the accessToken")]
			class PAccessTokenMaxUserPUID : UserTitleWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:ffffffffffffffff/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass min value for UserPUID in the accessToken")]
			class PAccessTokenMinUserPUID : UserTitleWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:1/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass max value for xboxPUID in the accessToken")]
			class PAccessTokenMaxXBoxPUID : UserTitleWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.accessToken.baseAT.xboxPuid = 0xffffffffffffffff;
				req.Slot.machinePuid = 0xffffffffffffffff;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass min value for xboxPUID in the accessToken")]
			class PAccessTokenMinXBoxPUID : UserTitleWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.accessToken.baseAT.xboxPuid = 1;
				req.Slot.machinePuid = 1;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass 0 fileExpirationTime in the accessToken")]
			class PAccessTokenZeroFileExpTime : UserTitleWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.accessToken.writeAT.fileExpirationDate = 0;
				req.accessToken.writeAT.tokenExpirationDate = System.DateTime.UtcNow.AddHours(1).ToFileTimeUtc();

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass 0 AccessTokenExpirationTime in the accessToken")]
			class PAccessTokenZeroATExpTime : UserTitleWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.accessToken.writeAT.tokenExpirationDate = 0;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass 255 unicode chars pathNameLen in the accessToken")]
			class PAccessTokenMaxPathnameSize : UserTitleWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				StringBuilder	pathBuilder = new StringBuilder(url);
				if(url.Length < 255)
					pathBuilder.Append('z',255-url.Length);
				XRLWriteFile	req = new XRLWriteFile("Owner",url);

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("try to write a file that is bigger than max allowed"), TestCasePriority(2)]
			class NBiggerThanMaxFile : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.blobData = new byte[65536+1];
				new Random().NextBytes(req.blobData);
				req.blobDataLen = req.uiBlobSizeCompressed = (uint)req.blobData.Length;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_FILE_IS_TOO_BIG))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass non-existent compression type"), TestCasePriority(2)]
			class NInvalidCompressionType : UserTitleWFNegTestBase //TODO:???
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.bCompressionType = 0xff;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass non-existent content type"), TestCasePriority(2)]
			class NInvalidContentType : UserTitleWFNegTestBase //TODO:???
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.uiContentType = 0xff;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass NULL for blob hash"), TestCasePriority(2)]
			class NNullBlobHash : UserTitleWFNegTestBase
		{
			public NNullBlobHash()
			{
				Name = "NNullBlobHash";
				Desc = "pass NULL for blob hash";
			}
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.ManualArraySize = true;
				req.blobHash = null;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_FILE_IS_TOO_BIG))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass <20 byte for blob hash"), TestCasePriority(2)]
			class NInvalidBlobHash1 : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.ManualArraySize = true;
				req.blobHash = new byte[Constants.sizeHash - 1];
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_FILE_IS_TOO_BIG))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        //		[TestCase, Description("34897:pass >20 byte for blob hash"), TestCasePriority(2)]
//			class NInvalidBlobHash2 : UserTitleWFNegTestBase
//		{
//			override protected void Execute()
//			{
//				uint	randomTitleID = (uint)new Random().Next();
//				string	sTitleID = randomTitleID.ToString("x");
//				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
//
//				XRLWriteFile	req = new XRLWriteFile("Owner",url);
//				req.ManualArraySize = true;
//				req.blobHash = new byte[Constants.sizeHash + 1];
//				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
//					ResultCode=TEST_RESULTS.PASSED;
//			}
//		}
        [TestCase, Description("uncompressed size is smaller than compressed size"), TestCasePriority(2)]
			class NWrongCompressedSize : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.uiBlobSizeCompressed = req.blobDataLen + 1;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass non-null for Attributes, but AttribLen is zero"), TestCasePriority(2)]
			class NMismatchedAttributes : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.ManualArraySize = true;
				req.attributesLen = 0;
				req.attributes = new byte[16];
				for(int i = 0; i < 16; i++)
					req.attributes[i] = (byte)i;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("Attributes size is greater than the actual size"), TestCasePriority(2)]
			class NTruncateAttributes : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.ManualArraySize = true;
				req.attributesLen +=1;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("Attributes size is smaller than the actual size"), TestCasePriority(2)]
			class NOverflowAttributes1 : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.ManualArraySize = true;
				req.attributes = new Byte[16];
				req.attributesLen = 15;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("Attributes is null but attribLen is nonzero"), TestCasePriority(2)]
			class NOverflowAttributes2 : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.ManualArraySize = true;
				req.attributes = null;
				req.attributesLen = 16;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("Attributes is null but attribLen is greater than maxallowed(256)"), TestCasePriority(2)]
			class NOverflowAttributes3 : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.ManualArraySize = true;
				req.attributes = null;
				req.attributesLen = 257;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("Attributes is larger than max allowed256bytes"), TestCasePriority(2)]
			class NOverflowAttributes4 : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				ushort			attribLen = Constants.maxSizeAttributes + 1;
				req.attributes = new Byte[attribLen];
				req.attributesLen = attribLen;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass special attributeLen = 0xffff"), TestCasePriority(2)]
			class NOverflowAttributes5 : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.attributes = new Byte[0xffff];
				req.attributesLen = 0xffff;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass null for AccessToken"), TestCasePriority(2)]
			class NNullAccessToken : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	WriteFileReq = new XRLWriteFile("Owner",url);
				WriteFileReq.ManualArraySize = true;
				WriteFileReq.accessToken = null;
				if (!WriteFileReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
				{
					if((WriteFileReq.XErr != HResult.XONLINE_E_STORAGE_INVALID_REQUEST)&&
						(WriteFileReq.XErr != HResult.XONLINE_E_SERVER_ERROR))
						Global.RO.Warn("Wrong error code returned " + Global.XErrToString(WriteFileReq.XErr));
					else
						ResultCode=TEST_RESULTS.PASSED;
				}
				else
					Global.RO.Warn("Negative WriteFile request succeed unexpectedly");
			}
		}
        [TestCase, Description("pass null for Blob data, but blobLen is non-zero"), TestCasePriority(2)]
			class NNullBlobData : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.ManualArraySize = true;
				req.blobData = null;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass 0 for uncompressed blob size and null blobdata")]
			class PEmptyFile : UserTitleWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.blobDataLen = req.uiBlobSizeCompressed = 0;
				req.blobData = null;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass 0 for compressed blob size, but non-null blobdata"), TestCasePriority(2)]
			class NEmptyCompressedFile : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.uiBlobSizeCompressed = 0;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("uncompressed blob size is greater than the actual file size"), TestCasePriority(2)]
			class NTruncateFile : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.ManualArraySize = true;
				req.blobDataLen += 1;
				req.uiBlobSizeCompressed +=1;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("uncompressed blob size is smaller than the actual file size"), TestCasePriority(2)]
			class NOverflowFile : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.ManualArraySize = true;
				req.blobDataLen -= 1;
				req.uiBlobSizeCompressed -=1;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("userPUID in the url is not the same as the one in the AT"), TestCasePriority(2)]
		class NNonOwerReq : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.accessToken.baseAT.userPuid = 898989;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("Expiration date is before the current time"), TestCasePriority(2)]
			class NAccessTokenInvalidExpTime1 : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.accessToken.writeAT.fileExpirationDate = System.DateTime.UtcNow.AddDays(-1).ToFileTimeUtc();

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass 0 for userPUID in access Token"), TestCasePriority(2)]
			class NAccessTokenZeroUserPUID : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.accessToken.baseAT.userPuid = 0;
				req.Slot.userPuid0 = 0;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_SERVER_ERROR))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass an access Token that is greater than 255+baseAT"), TestCasePriority(2)]
			class NAccessTokenOverflowAT : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				StringBuilder	pathName = new StringBuilder(req.accessToken.baseAT.pathName);
				int		i = 0, numCharToAdd = 256 - req.accessToken.baseAT.pathNameLen;
				while(i < numCharToAdd)
				{
					pathName.Append('a');
					i++;
				}
				req.accessToken.baseAT.pathNameLen = 256;
				req.accessToken.baseAT.pathName = pathName.ToString();

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("Access Token version is invalid"), TestCasePriority(2)]
			class NAccessTokenInvalidTokenVersion : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.accessToken.baseAT.version = Constants.accessTokenVersion + 1;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("Operation in AT is non-write"), TestCasePriority(2)]
			class NAccessTokenMismatchedOperation : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.accessToken.baseAT.operation = (ushort)Constants.Operation.FileRead;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        //		[TestCase, Description("ServiceID in AT is not zero"), TestCasePriority(2)]
//			class NAccessTokenInvalidServiceID : UserTitleWFNegTestBase
//		{
//			override protected void Execute()
//			{
//				string url= "//tuser.12345/u:8989/12345/" + Guid.NewGuid().ToString();
//				XRLWriteFile	req = new XRLWriteFile("Owner",url);
//				req.accessToken.baseAT.serviceId = (uint)XOService.Storage;
//
//				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
//					ResultCode=TEST_RESULTS.PASSED;
//			}
//		}

		// bug 29366
		// STFD: sometimes stfd won't return error when there is garbage data appended
		// at the end of writeFile requests
		// XRLScan: S_False returned
		//		class NGarbageData : UserTitleWFNegTestBase
		//		{
		//			public NGarbageData()
		//			{
		//				Name = "NGarbageData";
		//				Desc = "attach garge data at the end of requests";
		//			}
		//			override protected void Execute()
		//			{
		//				XRLWriteFile	req = new XRLWriteFile("Owner",url);
		//				req.ManualArraySize = true;
		//				int			maxFileSize = (int)req.accessToken.writeAT.maxFileSize;
		//				req.blobDataLen = req.uiBlobSizeCompressed = (uint)maxFileSize;
		//				req.blobData = new byte[maxFileSize + 77381];
		//				for (int i = maxFileSize; i < maxFileSize + 77381; i++)
		//					req.blobData[i] = 0;
		//
		//				if(WriteFileTestNegative(req,HResult.XONLINE_E_SERVER_ERROR))
		//					ResultCode=TEST_RESULTS.PASSED;
		//			}
		//		}

		// This will be caught by xrlscan.ini
        [TestCase, Description("the actual file size is greater than the dwMaxFileSize in AT"), TestCasePriority(2)]
			class NAccessTokenOverflowFileData1 : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				uint			maxFileSize = req.accessToken.writeAT.maxFileSize;
				req.blobData = new byte[maxFileSize + 1];
				for (int i = 0; i < maxFileSize + 1; i++)
					req.blobData[i] = (byte)i;
				req.blobDataLen = maxFileSize + 1;
				req.uiBlobSizeCompressed = maxFileSize + 1;

				// 404 returned back to client
				if(!req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		// This will be caught by xrlscan.ini
        [TestCase, Description("actual file size bigger than maxFileSize, but compressedSizeLen is smaller"), TestCasePriority(2)]
			class NAccessTokenOverflowFileData2 : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				uint			maxFileSize = req.accessToken.writeAT.maxFileSize;
				req.blobData = new byte[maxFileSize + 1];
				for (int i = 0; i < maxFileSize + 1; i++)
					req.blobData[i] = (byte)i;
				req.blobDataLen = maxFileSize + 1;
				//	req.uiBlobSizeCompressed = maxFileSize + 1;

				// 404 returned back to client
				if(!req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("ticket expiration time is greater than file expiration time"), TestCasePriority(2)]
			class NAccessTokenInvalidExpTime2 : UserTitleWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.accessToken.writeAT.fileExpirationDate = req.accessToken.writeAT.tokenExpirationDate - 100000;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the pathnameLen is greater than the actual size"), TestCasePriority(2)]
			class NAccessTokenTruncatePathname : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.accessToken.baseAT.ManualArraySize = true;
				req.accessToken.baseAT.pathNameLen += 1;
				if((WriteFileTestNegative(req,HResult.XONLINE_E_SERVER_ERROR))||
					(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST)))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the pathnameLen is less than the actual size"), TestCasePriority(2)]
			class NAccessTokenOverflowPathname : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.accessToken.baseAT.ManualArraySize = true;
				req.accessToken.baseAT.pathNameLen -= 1;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the flags in AT is non-zero"), TestCasePriority(2)]
			class NAccessTokenInvalidFlags : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.accessToken.baseAT.flags = 1;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		/***********************************************************************
		* Pathname Testing
		* *********************************************************************/
		//		class PPathnameHasIPPart : UserTitleWFTestBase
		//		{
		//			public PPathnameHasIPPart()
		//			{
		//				Name = "PPathnameHasIPPart";
		//				Desc = "pass IP part for the pathname";
		//			}
		//			override protected void Execute()
		//			{
		//				XRLWriteFile	req = new XRLWriteFile("Owner",url);
		//				string path = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).TextDefault	//TODO: NEED TO CHECK
		//					+ "//stats/u:"
		//					+ req.accessToken.baseAT.userPuid.ToString("x")
		//					+ "/t" + req.uiTitleId.ToString("x") + "/"
		//					+ Guid.NewGuid().ToString();
		//				req.accessToken.baseAT.pathName = path;
		//				req.accessToken.baseAT.pathNameLen = (ushort)path.Length;
		//
		//				if(WriteFileSendAndVerify(req))
		//					ResultCode=TEST_RESULTS.PASSED;
		//			}
		//		}
		[TestCase, Description("pass max value for userPUID in <Unique-ID-part>")]
			class PPathnameMaxUserPUID : UserTitleWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:ffffffffffffffff/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Owner",url);

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass min value for userPUID in <Unique-ID-part>")]
			class PPathnameMinUserPUID : UserTitleWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:1/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Owner",url);

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("only specify domain in <Domain-part> (tuser), no optional information")]
			class PPathnameNoOptionalDomainSpecifier : UserTitleWFTestBase
		{
			override protected void Execute()
			{
				string url= "//tuser/u:ffffffffffffffff/12345/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Owner",url);

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass a pathname that one null char in the middle of <Domain-part>"), TestCasePriority(2)]
			class NPathnameBadString1 : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//tuser.12345/u:8989/12345/" + Guid.NewGuid().ToString(),newPath;
				newPath = url.Insert(6,'\0'.ToString());
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",newPath);

				//TODO: need to return xonline_e_storage_domain_not_supported
				if(WriteFileTestNegative(writeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass a pathname that two null char in the middle of <Domain-part>"), TestCasePriority(2)]
			class NPathnameBadString2 : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//tuser.12345/u:8989/12345/" + Guid.NewGuid().ToString(),newPath;
				string temp;
				temp = '\0'.ToString() + '\0'.ToString();
				newPath = url.Insert(6,temp);
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",newPath);

				//TODO: need to return xonline_e_storage_domain_not_supported
				if(WriteFileTestNegative(writeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass one nullchar in the middle of <userPUID>"), TestCasePriority(2)]
			class NPathnameBadString3 : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//tuser.12345/u:8989/12345/" + Guid.NewGuid().ToString(),newPath;
				newPath = url.Insert(17,'\0'.ToString());
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",newPath);

				if(WriteFileTestNegative(writeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass one nullchar in the middle of <pathpart>"), TestCasePriority(2)]
			class NPathnameBadString4 : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//tuser.12345/u:8989/12345/" + Guid.NewGuid().ToString(),newPath;
				newPath = url.Insert(34,'\0'.ToString());
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",newPath);

				if(WriteFileTestNegative(writeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass one nullchar at the end of <pathpart>"), TestCasePriority(2)]
		class NPathnameBadString5 : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//tuser.12345/u:8989/12345/" + Guid.NewGuid().ToString(),newPath;
				newPath = url + '\0'.ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",newPath);

				if(WriteFileTestNegative(writeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("<Domain-part> is missing in pathname"), TestCasePriority(2)]
			class NPathnameNoDomainPart : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "/u:8989/12345/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Owner",url);

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass a pathname that has no ID namespace (u)"), TestCasePriority(2)]
			class NPathnameNoIDNameSpace : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//tuser.12345/:8989/12345/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Owner",url);

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass a pathname that has no userPUID following u"), TestCasePriority(2)]
			class NPathnameNoUserPUID : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//tuser.12345/u:/12345/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Owner",url);

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass 0 as userPUID in <Domain-part>"), TestCasePriority(2)]
			class NPathnameInvalidUserPUID : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//tuser.12345/u:0/12345/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Owner",url);

				if((WriteFileTestNegative(req,HResult.XONLINE_E_SERVER_ERROR))||
					WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}

        [TestCase, Description("pass invalid ID-Namespace"), TestCasePriority(2)]
			class NPathnameNonExistIDNameSpace : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//tuser.12345/x:8989/12345/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Owner",url);

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}

        [TestCase, Description("33946:no titleID in the url"), TestCasePriority(2)]
		class NPathnameNoTitleID : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//tuser.12345/u:8989/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Owner",url);

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}

        [TestCase, Description("33946:missing actual title ID"), TestCasePriority(2)]
			class NPathnameMissingTitleID : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//tuser.12345/u:8989//" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Owner",url);

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass a pathname that is greater than 255"), TestCasePriority(2)]
			class NPathnameOverflowPathname : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//tuser.12345/u:8989/12345/" + Guid.NewGuid().ToString();
				StringBuilder	pathName = new StringBuilder(url);
				int		i = 0, numCharToAdd = 256 - url.Length;
				while(i < numCharToAdd)
					pathName.Append(i++);
				XRLWriteFile	req = new XRLWriteFile("Owner",pathName.ToString());

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass a pathname that has special chars"), TestCasePriority(2)]
			class NPathnameWrongCharSet : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//tuser.12345/u:8989/12345/" + Guid.NewGuid().ToString()+'\0';
				XRLWriteFile	req = new XRLWriteFile("Owner",url);

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		/*****************************************************************
		 *  Other Testing
		 *****************************************************************/
		[TestCase, Description("update an existing file;old blob will be deleted")]
			class PUpdateExistingFile1 : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req1 = new XRLWriteFile("Owner",url), req2 = new XRLWriteFile("Owner",url);

				// make sure the two blobs are different
				req2.blobHash[1] = (byte)(req1.blobHash[1]+1);

				if(req1.Execute())
				{	// update the same file
					if(req2.Execute())
					{
						// read the file
						XRLReadFileResponse	ReadFileResp;
						XRLReadFile			ReadFileReq = new XRLReadFile(url);
						ReadFileReq.Slot.titleId = ReadFileReq.uiTitleId = randomTitleID;
						ReadFileReq.Slot.titleVersion = ReadFileReq.uiTitleVersion = req2.uiTitleVersion;
						if (ReadFileReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out ReadFileResp))
						{
							if ((ReadFileResp.Compare(req2)) || (req2.Verify()))
								ResultCode=TEST_RESULTS.PASSED;
						}
					}
				}
			}
		}
		[TestCase, Description("update an existing file;old blob still exisits(have reference)")]
			class PUpdateExistingFile2 : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url1= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				string url2= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();

				XRLWriteFile	req1 = new XRLWriteFile("Owner",url1), req2 = new XRLWriteFile("Owner",url2);

				// make sure the two blob are identical; so we will have two referencs for the same blob
				req2.blobDataLen = req1.blobDataLen;
				req2.uiBlobSizeCompressed = req1.uiBlobSizeCompressed;
				for(int i = 0; i < req1.blobDataLen; i++)
					req2.blobData[i] = req1.blobData[i];
				for(int i = 0; i < Constants.sizeHash; i++)
					req2.blobHash[i] = req1.blobHash[i];

				if(req1.Execute() && req2.Execute())
				{
					// use one of the url to update the blob
					XRLWriteFile	updateReq = new XRLWriteFile("Owner",url1);
					// make sure the two blobs are different
					updateReq.blobHash[1] = (byte)(req1.blobHash[1]+1);

					if(updateReq.Execute())
					{	// the old blob's i_ref_count will be decremented; blob still exists
						// a new blob will be created with i_ref_count is 1
						// read the old blob with url2
						XRLReadFileResponse		ReadOldBlobResp, ReadNewBlobResp;
						XRLReadFile			ReadOldBlobReq = new XRLReadFile(url2),ReadNewBlobReq=new XRLReadFile(url1);
						ReadOldBlobReq.Slot.titleId = ReadOldBlobReq.uiTitleId = randomTitleID;
						ReadOldBlobReq.Slot.titleVersion = ReadOldBlobReq.uiTitleVersion = req2.uiTitleVersion;
						if (ReadOldBlobReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out ReadOldBlobResp))
						{
							if ((ReadOldBlobResp.Compare(req2)) || (req2.Verify()))
							{
								// old blob still exist; check the new blob
								ReadNewBlobReq.Slot.titleId = ReadNewBlobReq.uiTitleId = randomTitleID;
								ReadNewBlobReq.Slot.titleVersion = ReadNewBlobReq.uiTitleVersion = updateReq.uiTitleVersion;
								if(ReadNewBlobReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out ReadNewBlobResp))
									ResultCode=TEST_RESULTS.PASSED;
							}
						}
					}
				}
			}
		}
		[TestCase, Description("data blob are identical,userPUID are the same so mapped to same webstore partition")]
			class PSameFileUploadTwice : GlobalTitleWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url1= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				string url2= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	req1 = new XRLWriteFile("Owner",url1), req2 = new XRLWriteFile("Owner",url2);

				req2.blobDataLen = req1.blobDataLen;
				req2.uiBlobSizeCompressed = req1.uiBlobSizeCompressed;
				for(int i = 0; i < req1.blobDataLen; i++)
					req2.blobData[i] = req1.blobData[i];

				for(int i = 0; i < Constants.sizeHash; i++)
					req2.blobHash[i] = req1.blobHash[i];

				if((WriteFileSendAndVerify(req1)) && (WriteFileSendAndVerify(req2)))
				{
					// do other  additional check
					if(req1.CheckRefCount(req2,2, true))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("same fileSize and hash, but blob are different")]
			class PSameHashDiffrentFileContent : GlobalTitleWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url1= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				string url2= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	req1 = new XRLWriteFile("Owner",url1), req2 = new XRLWriteFile("Owner",url2);

				req2.blobDataLen = req1.blobDataLen;
				req2.uiBlobSizeCompressed = req1.uiBlobSizeCompressed;

				// reenforce the two files to have different contents
				req2.blobData[9] = (byte)((int)req1.blobData[9]+ 1);

				for(int i = 0; i < Constants.sizeHash; i++)
					req2.blobHash[i] = req1.blobHash[i];

				if((WriteFileSendAndVerify(req1)) && (WriteFileSendAndVerify(req2)))
				{
					// do other additional check
					if(req1.CheckRefCount(req2,1,false))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		// This is how webstore repartition works; there will be two rows
		// added in both t_files and t_blobs
		[TestCase, Description("data blob are identical, but different userPUID and xrl for two writeFile requests")]
			class PSameFileUploadTwiceByDifferentUser : GlobalTitleWFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url1= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				string url2= "//tuser."+sTitleID+"/u:898999/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	req1 = new XRLWriteFile("Owner",url1), req2 = new XRLWriteFile("Owner",url2);

				req2.blobDataLen = req1.blobDataLen;
				req2.uiBlobSizeCompressed = req1.uiBlobSizeCompressed;
				for(int i = 0; i < req1.blobDataLen; i++)
					req2.blobData[i] = req1.blobData[i];
				for(int i = 0; i < Constants.sizeHash; i++)
					req2.blobHash[i] = req1.blobHash[i];

				if((WriteFileSendAndVerify(req1)) && (WriteFileSendAndVerify(req2)))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Multiple threads write a file simultaneously")]
			class PMultiThreadsWriteFile : UserTitleWFTestBase
		{
			override protected void Execute()
			{
                FailedReqs = 0; // variable wasn't being reset if the test was re-run
				Thread [] threadArray = new Thread[10];
				for(int i = 0; i < 10; i++)
				{
					threadArray[i] = ThreadMaker.CreateThread(writeFileTS);
					threadArray[i].Name = i.ToString();
					threadArray[i].Start();
				}
				// the main thread is waiting for all threads to exit or timeout
				foreach (Thread t in threadArray)
					t.Join(10000);
				if(FailedReqs == 0)
					ResultCode=TEST_RESULTS.PASSED;
			}
			private void writeFileTS()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(!WriteFileSendAndVerify(writeReq))
				{
					Global.RO.Warn(Thread.CurrentThread.Name+"writeFileTS: write file request/verify failed");
					Interlocked.Increment(ref FailedReqs);
				}
			}
			private	int FailedReqs = 0;
		}
		[TestCase, Description("write file 50 times")]
			class PWriteFileMultiTimes : UserTitleWFTestBase
		{
			override protected void Execute()
			{
				uint			uiFailedReq = 0;
				for(int i = 0; i < 50; i++)
				{
					uint	randomTitleID = (uint)new Random().Next();
					string	sTitleID = randomTitleID.ToString("x");
					string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
					XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
					if(!WriteFileSendAndVerify(writeReq))
						uiFailedReq++;
				}
				if(uiFailedReq == 0)
					ResultCode=TEST_RESULTS.PASSED;
				else
					Global.RO.Warn("It failed " + uiFailedReq.ToString() + " times");
			}
		}
		[TestCase, Description("the titleID in the request is not the acutal logged on title")]
			class PFamilyTitleID : UserTitleWFTestBase
		{
			override protected void Execute()
			{
				string url= "//tuser.12345/u:8989/12345/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.Slot.titleId = req.uiTitleId+1;
				req.Slot.altTitleId1 = req.uiTitleId;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		/***********************************************************************
		* SG Auth Data Testing
		* *********************************************************************/
        [TestCase, Description("the userPUID in SGAuth response is not_found user"), TestCasePriority(2)]
			class NSGAuthNotFoundUser : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//tuser.12345/u:8989/12345/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.Slot.UserExists = 0;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_SERVER_ERROR))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the userPUID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidUser : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//tuser.12345/u:8989/12345/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.Slot.userPuid0++;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the TitleID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidTitleID : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//tuser.12345/u:8989/12345/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.Slot.titleId++;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_INVALID_TITLE_ID))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the XBoxPUID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidXBoxPUID : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//tuser.12345/u:8989/12345/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.Slot.machinePuid++;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the TitleVersion in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidTitleVersion : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//tuser.12345/u:8989/12345/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.Slot.titleVersion++;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the CountryID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidCountryID : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//tuser.12345/u:8989/12345/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.Slot.userFlag0 = (uint)((req.Slot.userFlag0>>8+1)<<8);

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        //		[TestCase, Description("the Service ID in SGInfo is not zero for perUserperTitle Storage"), TestCasePriority(2)]
//		class nSGAuthInvalidServiceID : UserTitleWFNegTestBase
//		{
//			override protected void Execute()
//			{
//				string url= "//tuser.12345/u:8989/12345/" + Guid.NewGuid().ToString();
//				XRLWriteFile	req = new XRLWriteFile("Owner",url);
//				req.Slot.service0 = XOService.Stats;
//
//				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
//					ResultCode=TEST_RESULTS.PASSED;
//			}
//		}

		/***********************************************************************
		* Tsunami: Quota testing
		***********************************************************************/
		[TestCase, Description("34942:create max allowed # of files;remove some files; check quota being updated")]
			class PQuotaMaxFiles : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string [] removedUrls = new string[5];
				uint	[] removedFileSize = new uint[5];

				// create a file for this title first to fill out the t_quotas table
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				removedUrls[0] = url;
				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.attributes = new byte[100];
				new Random().NextBytes(req.attributes);
				req.attributesLen = (ushort)req.attributes.Length;
				if(req.Execute())
					removedFileSize[0] = req.blobDataLen;

				XRLGetQuota		getQuotaReq = new XRLGetQuota(2,randomTitleID,(uint)Constants.IdType.UserId,0x8989);
				XRLGetQuotaResponse	getQuotaResp;
				ulong			maxFileSize=0;
				ulong			totalBytesMax=0;
				uint			totalFilesMax=0;
				ulong			start_BytesUsed=0, actualBytesUsed=0, removedBytes = 0;
				uint			start_FilesUsed=0, removedFiles = 0;
				if(getQuotaReq.Execute(out getQuotaResp))
				{
					maxFileSize = getQuotaResp.maxFileSize;
					totalBytesMax = getQuotaResp.totalBytesMax;
					totalFilesMax = getQuotaResp.totalFilesMax;
					start_BytesUsed = getQuotaResp.totalBytesUsed;
					start_FilesUsed = getQuotaResp.totalFilesUsed;
				}
				else
				{
					Global.RO.Warn("GetQuota request1 failed");
					return;
				}
				uint failed = 0;
				for(int i = 1; i <= (totalFilesMax-start_FilesUsed); i++)
				{
					url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
					req = new XRLWriteFile("Owner",url);
					req.attributes = new byte[100];
					new Random().NextBytes(req.attributes);
					req.attributesLen = (ushort)req.attributes.Length;
					if(!req.Execute())
					{
						failed++;
						return;
					}
					actualBytesUsed += req.blobDataLen;
					if(i < 5)
					{
						removedUrls[i] = url;
						removedFileSize[i] = req.blobDataLen;
					}
				}
				if(failed == 0) // max # of files created for this title
				{	// check quota again
					XRLGetQuota		gQReq = new XRLGetQuota(2,randomTitleID,(uint)Constants.IdType.UserId ,0x8989);
					XRLGetQuotaResponse	gQResp;
					if(gQReq.Execute(out gQResp))
					{
						if((gQResp.totalFilesUsed == gQResp.totalFilesMax) &&
							(gQResp.totalBytesUsed == (start_BytesUsed+actualBytesUsed)))
						{// remove some files then check quota again
							for(int i = 0; i < 5; i++)
							{
								XRLRemoveFile	removeReq = new XRLRemoveFile(removedUrls[i],randomTitleID,"Owner");
								if(removeReq.Execute())
								{
									removedFiles++;
									removedBytes += removedFileSize[i];
								}
							}
							// check quota again
							XRLGetQuota		gQReq2 = new XRLGetQuota(2,randomTitleID,(uint)Constants.IdType.UserId ,0x8989);
							XRLGetQuotaResponse	gQResp2;
							if(gQReq2.Execute(out gQResp2))
							{
								if(gQResp2.totalFilesUsed == (gQResp2.totalFilesMax-removedFiles)&&
									(gQResp2.totalBytesUsed == (start_BytesUsed+actualBytesUsed-removedBytes)))
									ResultCode=TEST_RESULTS.PASSED;
							}
						}
					}
				}
			}
		}
		[TestCase, Description("create a file with multi ref, check quota; remove one ref check quota again")]
			class PQuotaFilesWithMultiRef : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");

				ulong			maxFileSize=0;
				ulong			totalBytesMax=0;
				uint			totalFilesMax=0;
				ulong			start_BytesUsed=0;
				uint			start_FilesUsed=0;
				// create a file for this title first to fill out the t_quotas table
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				if(req.Execute())
				{
					XRLGetQuota		getQuotaReq = new XRLGetQuota(2,randomTitleID,(uint)Constants.IdType.UserId ,0x8989);
					XRLGetQuotaResponse	getQuotaResp;
					if(getQuotaReq.Execute(out getQuotaResp))
					{
						maxFileSize = getQuotaResp.maxFileSize;
						totalBytesMax = getQuotaResp.totalBytesMax;
						totalFilesMax = getQuotaResp.totalFilesMax;
						start_BytesUsed = getQuotaResp.totalBytesUsed;
						start_FilesUsed = getQuotaResp.totalFilesUsed;
					}
					else
					{
						Global.RO.Warn("GetQuota request1 failed");
						return;
					}
				}
				else
					return;
				// create a blob with two references
				string url1= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				string url2= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	req1 = new XRLWriteFile("Owner",url1), req2 = new XRLWriteFile("Owner",url2);

				req2.blobDataLen = req1.blobDataLen;
				req2.uiBlobSizeCompressed = req1.uiBlobSizeCompressed;
				for(int i = 0; i < req1.blobDataLen; i++)
					req2.blobData[i] = req1.blobData[i];
				for(int i = 0; i < Constants.sizeHash; i++)
					req2.blobHash[i] = req1.blobHash[i];

				if(req1.Execute() && req2.Execute())
				{
					XRLGetQuota		gQReq = new XRLGetQuota(2,randomTitleID,(uint)Constants.IdType.UserId ,0x8989);
					XRLGetQuotaResponse	gQResp;
					if(gQReq.Execute(out gQResp))
					{
						if((gQResp.totalFilesUsed == (start_FilesUsed+2)) &&
							(gQResp.totalBytesUsed == (start_BytesUsed+req1.blobDataLen+req2.blobDataLen)))
						{// remove one ref then check quota again
							XRLRemoveFile	removeReq = new XRLRemoveFile(url1,randomTitleID,"Owner");
							if(removeReq.Execute())
							{		// check quota again
								XRLGetQuota		gQReq2 = new XRLGetQuota(2,randomTitleID,(uint)Constants.IdType.UserId ,0x8989);
								XRLGetQuotaResponse	gQResp2;
								if(gQReq2.Execute(out gQResp2))
								{	// totalBytesUsed and fileUsed should be changed.
									if(gQResp2.totalFilesUsed == (start_FilesUsed+1)&&
										(gQResp2.totalBytesUsed == (start_BytesUsed+req2.blobDataLen)))
										ResultCode=TEST_RESULTS.PASSED;
								}
							}
						}
					}
				}
			}
		}
        [TestCase, Description("create >max # allowed files, but byteUsed still within limit "), TestCasePriority(2)]
			class NQuotaOverflowTotalFiles : GlobalTitleWFNegTestBase
		{
			override protected void Execute()
			{
				// This test assume no files/bytes exist for this title
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				ulong	actualBytesUsed = 0;
				uint	totalFilesMax = 8;
				ulong	totalBytesMax = 64*1024;//PerUserPerTitle

				uint failed = 0;
				for(int i = 0; i < totalFilesMax; i++)
				{
					string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
					XRLWriteFile	req = new XRLWriteFile("Owner",url);
					if(!req.Execute())
					{
						failed++;
						return;
					}
					actualBytesUsed += req.blobDataLen;
				}
				if(failed == 0) // max # of files created for this title
				{	// create another file
					string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
					XRLWriteFile	req = new XRLWriteFile("Owner",url);
					ulong	totalActualBytes = actualBytesUsed+req.blobDataLen;
					if(totalActualBytes<=totalBytesMax)
						if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_QUOTA_EXCEEDED))
							ResultCode=TEST_RESULTS.PASSED;
						else
							Global.RO.Warn("Total number of files used is over limit");
				}
			}
		}
        [TestCase, Description("create >max allowed bytes, but # of filesUsed still within limit "), TestCasePriority(2)]
			class NQuotaOverflowTotalBytes : GlobalTitleWFNegTestBase
		{
			override protected void Execute()
			{
				// This test assume no files/bytes exist for this title
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				ulong	actualBytesUsed = 0;

				// for PerUserPerTitle: bytesMax is 64KB, maxFiles is 8, maxSize = 64KB
				// so create 4 files each one is 16KB, then create aother one with 1 byte, which should fail
				uint failed = 0;
				for(int i = 0; i < 4; i++)
				{
					string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
					XRLWriteFile	req = new XRLWriteFile("Owner",url);
					req.blobDataLen = req.uiBlobSizeCompressed = 16*1024;
					req.blobData = new byte[16*1024];
					new Random().NextBytes(req.blobData);
					if(!req.Execute())
					{
						failed++;
						return;
					}
					actualBytesUsed += req.blobDataLen;
				}
				if(failed == 0) // maxBytes created for the title
				{	// create another file
					string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
					XRLWriteFile	req = new XRLWriteFile("Owner",url);
					req.blobDataLen = req.uiBlobSizeCompressed = 1;
					req.blobData = new byte[1];
					new Random().NextBytes(req.blobData);

					if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_QUOTA_EXCEEDED))
						ResultCode=TEST_RESULTS.PASSED;
					else
						Global.RO.Warn("Total bytes used is over limit");
				}
			}
		}

		[TestCase, Description("goto quota and replace last file")]
			class PReplaceLastFileWhenQuotaReached : TestBase
		{
			override protected void Execute()
			{

				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");

				// create a file for this title first to fill out the t_quotas table
				string url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.attributes = new byte[100];
				new Random().NextBytes(req.attributes);
				req.attributesLen = (ushort)req.attributes.Length;

				// get the quota
				XRLGetQuota		getQuotaReq = new XRLGetQuota(2,randomTitleID,(uint)Constants.IdType.UserId,0x8989);
				XRLGetQuotaResponse	getQuotaResp;
				ulong			maxFileSize=0;
				ulong			totalBytesMax=0;
				uint			totalFilesMax=0;
				ulong			start_BytesUsed=0, actualBytesUsed=0;
				uint			start_FilesUsed=0;
				if(getQuotaReq.Execute(out getQuotaResp))
				{
					maxFileSize = getQuotaResp.maxFileSize;
					totalBytesMax = getQuotaResp.totalBytesMax;
					totalFilesMax = getQuotaResp.totalFilesMax;
					start_BytesUsed = getQuotaResp.totalBytesUsed;
					start_FilesUsed = getQuotaResp.totalFilesUsed;
				}
				else
				{
					Global.RO.Warn("GetQuota request1 failed");
					return;
				}

				//Fill the quota
				uint failed = 0;
				for(int i = 1; i <= (totalFilesMax-start_FilesUsed); i++)
				{
					url= "//tuser."+sTitleID+"/u:8989/"+sTitleID+"/" + Guid.NewGuid().ToString();
					req = new XRLWriteFile("Owner",url);
					req.attributes = new byte[100];
					new Random().NextBytes(req.attributes);
					req.attributesLen = (ushort)req.attributes.Length;
					if(!req.Execute())
					{
						failed++;
						return;
					}
					actualBytesUsed += req.blobDataLen;
				}

				//Update the last file again
				if (failed==0)
				{
					req.attributes = new byte[10]{1,2,3,4,5,6,7,8,9,0};
					req.attributesLen = 10;
					if(!req.Execute())
					{
						return;	// fail
					}
				}

				ResultCode=TEST_RESULTS.PASSED;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\FuncXeStatsDF.cs ===
using System;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Storage;
using ServerTestFramework.LiveService.Signature;
using ServerTestFramework.Utilities;
using xonline.common.config;

namespace XStoreTest
{
	internal abstract class XeStatsDFTestBase : TestBase
	{
		protected bool RemoveFileSendAndVerify(XRLRemoveFile removeReq)
		{
			uint    titleID = removeReq.uiTitleId;
			string    pathName = removeReq.accessToken.baseAT.pathName;
			XRLWriteFile    WriteReq = new XRLWriteFile("Owner", pathName);
			if(WriteReq.Execute())
			{
				if(removeReq.Execute())
				{
					XRLReadFile        readReq = new XRLReadFile(pathName);
					readReq.Slot.titleId = readReq.uiTitleId = titleID;
					if(!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)) &&
						(readReq.XErr == HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
						return true;
					else
					{
						Global.RO.Warn("File was not removed");
						return false;
					}
				}
				Global.RO.Warn("RemoveFile request failed with "+Global.XErrToString(removeReq.XErr));
				return false;
			}
			return false;
		}
	}
	internal abstract class NegXeStatsDFTestBase : TestBase
	{
		protected bool RemoveFileTestNegative(XRLRemoveFile    removeReq, uint XErr)
		{
			if (removeReq.Execute())
			{
				Global.RO.Warn("Negative RemoveFile request succeed unexpectedly");
				return false;
			}
			if(removeReq.XErr != XErr)
			{
				Global.RO.Warn("Wrong error code " + Global.XErrToString(removeReq.XErr) +" returned");
				return false;
			}
			return true;
		}
	}
    [TestGroup, Owner("JKonkle"), TestFrequency("Regression"), TestCasePriority(1)]
	public class FuncXeStatsDF : TestNode
	{
		/**********************************************************************************
		 * Positive Wire Protocol Testing

			 *********************************************************************************/
		//bug 38096
		[TestCase, Description("check X-Delay in the http response header")]
			class PThrottling : XeStatsDFTestBase
		{
			override protected void Execute()
			{
				uint    randomTitleID = (uint)new Random().Next();
				string    sTitleID = randomTitleID.ToString("x");
				string pathName = "//xestats."+sTitleID+"/u:abcdef/"+sTitleID+"/" + new Random().Next().ToString("x");;

				XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,randomTitleID,"ServiceAddr");

				int Xdelay= 3000;
				Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage,"exec :stfd SetXDelay "+removeReq.uiTitleId.ToString("X")+" removefile "+Xdelay);

				if(RemoveFileSendAndVerify(removeReq)&& (removeReq.XDelay == Xdelay))
					ResultCode=TEST_RESULTS.PASSED;

				Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage,"exec :stfd ReloadThrottleConfig");
			}
		}
		[TestCase, Description("Write a file first then call removeFile")]
			class PNormalCase : XeStatsDFTestBase
		{
			override protected void Execute()
			{
				uint    randomTitleID = (uint)new Random().Next();
				string    sTitleID = randomTitleID.ToString("x");
				string pathName = "//xestats."+sTitleID+"/u:abcdef/"+sTitleID+"/" + new Random().Next().ToString("x");;

				XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,randomTitleID,"ServiceAddr");
				if(RemoveFileSendAndVerify(removeReq))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("call removeFile with maximum titleID")]
			class PMaxTitleID : XeStatsDFTestBase
		{
			override protected void Execute()
			{
				string    pathName = "//xestats.ffffffff/u:dfd/ffffffff/" + new Random().Next().ToString("x");;
				XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,0xffffffff,"ServiceAddr");
				if(RemoveFileSendAndVerify(removeReq))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("call removeFile with minimum titleID")]
			class PMinTitleID : XeStatsDFTestBase
		{
			override protected void Execute()
			{
				string    pathName = "//xestats.1/u:dfd/1/" + new Random().Next().ToString("x");;
				XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,1,"ServiceAddr");
				if(RemoveFileSendAndVerify(removeReq))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("call removeFile with maximum titleVersion")]
			class PMaxTitleVersion : XeStatsDFTestBase
		{
			override protected void Execute()
			{
				uint    randomTitleID = (uint)new Random().Next();
				string    sTitleID = randomTitleID.ToString("x");
				string pathName = "//xestats."+sTitleID+"/u:abcdef/"+sTitleID+"/" + new Random().Next().ToString("x");;

				XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,randomTitleID,"ServiceAddr");
				ulong    requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
				uint    ip = 0;
				byte [] addr = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).Address.GetAddressBytes();
				for(int i = 0; i < addr.Length; i++)
					ip = (ip << 8) + addr[i];
				HTTPAuthData authData = new HTTPAuthData((ushort) Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int).Port,
					ip,requestId,0,randomTitleID,(uint)XOService.Storage,0);
				authData.dwTitleVersion = removeReq.uiTitleVersion = 0xffffffff;
				removeReq.CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" +
					authData.GetBase64EncodedString() + "\r\n";

				if(RemoveFileSendAndVerify(removeReq))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("call removeFile with minimum titleVersion")]
			class PMinTitleVersion : XeStatsDFTestBase
		{
			override protected void Execute()
			{
				uint    randomTitleID = (uint)new Random().Next();
				string    sTitleID = randomTitleID.ToString("x");
				string pathName = "//xestats."+sTitleID+"/u:abcdef/"+sTitleID+"/" + new Random().Next().ToString("x");;

				XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,randomTitleID,"ServiceAddr");
				ulong    requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
				uint    ip = 0;
				byte [] addr = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).Address.GetAddressBytes();
				for(int i = 0; i < addr.Length; i++)
					ip = (ip << 8) + addr[i];
				HTTPAuthData authData = new HTTPAuthData((ushort) Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int).Port,
					ip,requestId,0,randomTitleID,(uint)XOService.Storage,0);
				authData.dwTitleVersion = removeReq.uiTitleVersion = 1;
				removeReq.CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" +
					authData.GetBase64EncodedString() + "\r\n";

				if(RemoveFileSendAndVerify(removeReq))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		/********************************************************
		 * Positive Other Testing
		 *********************************************************************************/
		[TestCase, Description("call RemoveFile with the same pathname and titleID as writeFile but different title Version")]
			class PRemoveFromOtherTitleVersion : TestBase
		{
			override protected void Execute()
			{
				uint    randomTitleID = (uint)new Random().Next();
				string    sTitleID = randomTitleID.ToString("x");
				string pathName = "//xestats."+sTitleID+"/u:abcdef/"+sTitleID+"/" + new Random().Next().ToString("x");;

				XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,randomTitleID,"ServiceAddr");
				XRLWriteFile    WriteReq = new XRLWriteFile("Owner",pathName);
				removeReq.uiTitleVersion = WriteReq.uiTitleVersion+1;
				ulong    requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
				uint    ip = 0;
				byte [] addr = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).Address.GetAddressBytes();
				for(int i = 0; i < addr.Length; i++)
					ip = (ip << 8) + addr[i];
				HTTPAuthData authData = new HTTPAuthData((ushort) Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int).Port,
					ip,requestId,0xabcdef,randomTitleID,(uint)XOService.Storage,0);
				authData.dwTitleVersion = removeReq.uiTitleVersion;
				removeReq.CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" +
					authData.GetBase64EncodedString() + "\r\n";
				
				if(WriteReq.Execute())
				{
					if(removeReq.Execute())
					{
						XRLReadFile        readReq = new XRLReadFile(pathName);
						if(!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)) &&
							(readReq.XErr == HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
							ResultCode=TEST_RESULTS.PASSED;
					}
				}
			}
		}
		[TestCase, Description("remove only one ref for a file with multiple references")]
		class PRemoveFileWithMultiRef : TestBase
		{
			override protected void Execute()
			{
                uint randomTitleID = (uint)RandomEx.GlobalRandGen.Next();
                string pathName = string.Format("//xestats.{0:X8}/u:abcdef/{0:X8}/{1:X8}", randomTitleID, RandomEx.GlobalRandGen.Next());

				// write a blob with 4 references
				uint  title = randomTitleID;
				uint  FileWithMultiRefLen = 10240;
				byte[]        FileData = new byte[FileWithMultiRefLen];
				new Random().NextBytes(FileData);
				byte[]        FileWithMultiRefHash = new byte[Constants.sizeHash];
				new Random().NextBytes(FileWithMultiRefHash);
				string        MultiRefPath1 = "", RemovedRefPath = "";
				XRLWriteFile wReq1 = new XRLWriteFile("Owner",pathName);
                XRLWriteFile wReq2 = new XRLWriteFile("Owner", pathName);
				for(int i = 0; i < 4; i++)
				{
                    pathName = string.Format("//xestats.{0:X8}/u:abcdef/{0:X8}/{1:X}", randomTitleID, RandomEx.GlobalRandGen.Next());
					XRLWriteFile    writeReq = new XRLWriteFile("Owner",pathName);
					writeReq.blobDataLen = FileWithMultiRefLen;
					writeReq.uiBlobSizeCompressed = FileWithMultiRefLen;
					writeReq.blobData = new byte[FileWithMultiRefLen];
					FileData.CopyTo(writeReq.blobData,0);
					FileWithMultiRefHash.CopyTo(writeReq.blobHash,0);

					if(!writeReq.Execute())
					{
						Global.RO.Warn("Write File failed:"+i);
						return;
					}
					if(i == 0)
					{
						wReq1 = writeReq;
						MultiRefPath1 = writeReq.accessToken.baseAT.pathName;
					}
					else if (i == 1)
						wReq2 = writeReq;
					// the removed Ref path will be i = 3
					RemovedRefPath = writeReq.accessToken.baseAT.pathName;
				}

				// only remove one reference to the file; the file still in the db and
				// check the i_ref_count=3
				XRLRemoveFile    removeReq = new XRLRemoveFile(RemovedRefPath,title,"ServiceAddr");
				if(removeReq.Execute())
				{
					XRLReadFile        readReq = new XRLReadFile(MultiRefPath1);
					readReq.Slot.titleId = readReq.uiTitleId = title;
					XRLReadFileResponse    resp;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out resp))
						// check ref count
						if(wReq1.CheckRefCount(wReq2,3,false))
							ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("remove all refs for a file with multiple references")]
			class PRemoveFileWithMultiRef2 : TestBase
		{
			override protected void Execute()
			{
                uint randomTitleID = (uint)RandomEx.GlobalRandGen.Next();
                string pathName = string.Format("//xestats.{0:X8}/u:abcdef/{0:X8}/{1:X8}", randomTitleID, RandomEx.GlobalRandGen.Next());				
				// write a blob with 2 references
				uint        title = randomTitleID;
				uint        FileWithMultiRefLen = 10240;
				byte[]        FileData = new byte[FileWithMultiRefLen];
				new Random().NextBytes(FileData);
				byte[]        FileWithMultiRefHash = new byte[Constants.sizeHash];
				new Random().NextBytes(FileWithMultiRefHash);
				string        []refPath = new string[2]{"",""};
				XRLWriteFile    [] writeReq = new XRLWriteFile[2]{null, null};
				for(int i = 0; i < 2; i++)
				{
                    pathName = string.Format("//xestats.{0:X8}/u:abcdef/{0:X8}/{1:X}", randomTitleID, RandomEx.GlobalRandGen.Next());
					writeReq[i] = new XRLWriteFile("Owner",pathName);
					writeReq[i].blobDataLen = FileWithMultiRefLen;
					writeReq[i].uiBlobSizeCompressed = FileWithMultiRefLen;
					writeReq[i].blobData = new byte[FileWithMultiRefLen];
					FileData.CopyTo(writeReq[i].blobData,0);
					FileWithMultiRefHash.CopyTo(writeReq[i].blobHash,0);
					if(!writeReq[i].Execute())
					{
						Global.RO.Warn("Write File failed:"+i);
						return;
					}
					refPath[i]=pathName;
				}

				// remove all references to the file; the file will be deleted
				XRLRemoveFile    removeReq1 = new XRLRemoveFile(refPath[0],title,"ServiceAddr");
				XRLRemoveFile    removeReq2 = new XRLRemoveFile(refPath[1],title,"ServiceAddr");
				if(removeReq1.Execute() && (removeReq2.Execute()))
				{
					XRLReadFile        readReq = new XRLReadFile(refPath[0]);
					readReq.Slot.titleId = readReq.uiTitleId = title;
					if(!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage))&&
						(readReq.XErr==HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		/**********************************************************************************
		 * Negative Wire Protocol Testing
		 *********************************************************************************/
		// since XeStatsDF is a dataCenter request, we need to test HTTPAuthData header
		// instead of SGAuth
        // [TestCase, Description("Bug33875:the userPUID in HTTPAuthData is different than the one in removeFile request"), TestCasePriority(2)]
		class NSGAuthInvalidUserPUID : NegXeStatsDFTestBase
		{
			override protected void Execute()
			{
				uint    randomTitleID = (uint)new Random().Next();
				string    sTitleID = randomTitleID.ToString("x");
				string pathName = "//xestats."+sTitleID+"/u:abcdef/"+sTitleID+"/" + new Random().Next().ToString("x");;

				XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,randomTitleID,"ServiceAddr");
				ulong    userPUID = removeReq.accessToken.baseAT.userPuid + 1;
				ulong    requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
				uint    ip = 0;
				byte [] addr = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).Address.GetAddressBytes();
				for(int i = 0; i < addr.Length; i++)
					ip = (ip << 8) + addr[i];
				HTTPAuthData authData = new HTTPAuthData((ushort) Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int).Port,
					ip,requestId,userPUID,randomTitleID,(uint)XOService.Storage,0);
				authData.dwTitleVersion = removeReq.uiTitleVersion;
				removeReq.CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" +
					authData.GetBase64EncodedString() + "\r\n";
				if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("31658:the titleID in SGAuth response is not the one in the removeFile request"), TestCasePriority(2)]
			class NSGAuthInvalidTitleID : NegXeStatsDFTestBase
		{
			override protected void Execute()
			{
				string    pathName = "//xestats.1234/u:3949/1234/" + new Random().Next().ToString("x");;
				uint    titleID = 0x1234;
				XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
				ulong    requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
				uint    ip = 0;
				byte [] addr = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).Address.GetAddressBytes();
				for(int i = 0; i < addr.Length; i++)
					ip = (ip << 8) + addr[i];
				HTTPAuthData authData = new HTTPAuthData((ushort) Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int).Port,
					ip,requestId,0,0x1235,(uint)XOService.Storage,0);
				authData.dwTitleVersion = removeReq.uiTitleVersion;
				removeReq.CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" +
					authData.GetBase64EncodedString() + "\r\n";

				if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_INVALID_TITLE_ID))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("31659:the titleVersion in SGAuth response is not the one in the removeFile request"), TestCasePriority(2)]
			class NSGAuthInvalidTitleVersion : NegXeStatsDFTestBase
		{
			override protected void Execute()
			{
				string    pathName = "//xestats.1234/u:3949/1234/" + new Random().Next().ToString("x");;
				uint    titleID = 0x1234;
				XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
				ulong    requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
				uint    ip = 0;
				byte [] addr = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).Address.GetAddressBytes();
				for(int i = 0; i < addr.Length; i++)
					ip = (ip << 8) + addr[i];
				HTTPAuthData authData = new HTTPAuthData((ushort) Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int).Port,
					ip,requestId,0,titleID,(uint)XOService.Storage,0);
				authData.dwTitleVersion = removeReq.uiTitleVersion + 1;
				removeReq.CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" +
					authData.GetBase64EncodedString() + "\r\n";

				if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the serviceID in SGAuth response is not Storage"), TestCasePriority(2)]
			class NSGAuthInvalidServiceID : NegXeStatsDFTestBase
		{
			override protected void Execute()
			{
				string    pathName = "//xestats.1234/u:3949/1234/" + new Random().Next().ToString("x");;
				uint    titleID = 0x1234;
				XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
				ulong    requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
				uint    ip = 0;
				byte [] addr = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).Address.GetAddressBytes();
				for(int i = 0; i < addr.Length; i++)
					ip = (ip << 8) + addr[i];
				HTTPAuthData authData = new HTTPAuthData((ushort) Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int).Port,
					ip,requestId,0,0x1235,(uint)XOService.Stats,0);
				authData.dwTitleVersion = removeReq.uiTitleVersion;
				removeReq.CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" +
					authData.GetBase64EncodedString() + "\r\n";

				if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_SERVER_ERROR))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("31660:Call RemoveFile with invalid pathName"), TestCasePriority(2)]
			class NFileNotFound : NegXeStatsDFTestBase
		{
			override protected void Execute()
			{
				string    pathName = "//xestats.1234/u:3949/1234/" + new Random().Next().ToString("x");;
				uint    titleID = 0x1234;
				XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
				if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass non-removeFile operation"), TestCasePriority(2)]
			class NInvalidOperation : NegXeStatsDFTestBase
		{
			override protected void Execute()
			{
				string    pathName = "//xestats.1234/u:3949/1234/" + new Random().Next().ToString("x");;
				uint    titleID = 0x1234;
				XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
				removeReq.accessToken.baseAT.operation = (ushort)Constants.Operation.FileEnumerate;
				if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		
		// bug 33914
        [TestCase, Description("pass non-zero as userPUID"), TestCasePriority(2)]
			class NNonZeroUserPUID : NegXeStatsDFTestBase
		{
			override protected void Execute()
			{
				string    pathName = "//xestats.1234/u:3949/1234/" + new Random().Next().ToString("x");;
				uint    titleID = 0x1234;
				XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
				removeReq.accessToken.baseAT.userPuid = 1;
				ulong    requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
				uint    ip = 0;
				byte [] addr = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).Address.GetAddressBytes();
				for(int i = 0; i < addr.Length; i++)
					ip = (ip << 8) + addr[i];
				HTTPAuthData authData = new HTTPAuthData((ushort) Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int).Port,
					ip,requestId,1,0x1234,(uint)XOService.Stats,0);
				authData.dwTitleVersion = removeReq.uiTitleVersion;
				removeReq.CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" +
					authData.GetBase64EncodedString() + "\r\n";
				if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_SERVER_ERROR))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		// bug 33914
        [TestCase, Description("pass non-0 as xboxPUID"), TestCasePriority(2)]
			class NNonZeroXBoxPUID : NegXeStatsDFTestBase
		{
			override protected void Execute()
			{
				string    pathName = "//xestats.1234/u:3949/1234/" + new Random().Next().ToString("x");;
				uint    titleID = 0x1234;
				XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");

				ulong    requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
				uint    ip = 0;
				byte [] addr = Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).Address.GetAddressBytes();
				for(int i = 0; i < addr.Length; i++)
					ip = (ip << 8) + addr[i];
				HTTPAuthData authData = new HTTPAuthData((ushort) Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage_int).Port,
					ip,requestId,0,0x1234,(uint)XOService.Stats,0);
				authData.dwTitleVersion = removeReq.uiTitleVersion;
				authData.qwXboxID = removeReq.accessToken.baseAT.xboxPuid = 1;
				removeReq.CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" +
					authData.GetBase64EncodedString() + "\r\n";
				if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_SERVER_ERROR))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pathNameLen is greater than the actual pathname"), TestCasePriority(2)]
			class NTruncatePathname : NegXeStatsDFTestBase
		{
			public NTruncatePathname()
			{
				Name = "NTruncatePathname";
				Desc = "";
			}
			override protected void Execute()
			{
				string    pathName = "//xestats.1234/u:3949/1234/" + new Random().Next().ToString("x");;
				uint    titleID = 0x1234;
				XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
				removeReq.accessToken.baseAT.ManualArraySize = true;
				removeReq.accessToken.baseAT.pathNameLen +=1;
				if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pathNameLen is shorter than the actual pathname"), TestCasePriority(2)]
			class NOverflowPathname : NegXeStatsDFTestBase
		{
			override protected void Execute()
			{
				string    pathName = "//xestats.1234/u:3949/1234/" + new Random().Next().ToString("x");;
				uint    titleID = 0x1234;
				XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
				removeReq.accessToken.baseAT.ManualArraySize = true;
				removeReq.accessToken.baseAT.pathNameLen -=1;
				if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass NULL for pathName"), TestCasePriority(2)]
			class NNullPathname : NegXeStatsDFTestBase
		{
			override protected void Execute()
			{
				uint    titleID = 0x1234;
				XRLRemoveFile    removeReq = new XRLRemoveFile(null,titleID,"ServiceAddr");

				if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("token expiration time is before current time"), TestCasePriority(2)]
			class NInvalidTokenExpTime : NegXeStatsDFTestBase
		{
			override protected void Execute()
			{
				string    pathName = "//xestats.1234/u:3949/1234/" + new Random().Next().ToString("x");;
				uint    titleID = 0x1234;
				XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
				removeReq.accessToken.removeAT.tokenExpirationDate = (long)System.DateTime.UtcNow.AddHours(-1).ToFileTimeUtc();
				if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        //   [TestCase, Description("pass removeFile request to stfd port 10140 other than 11140"), TestCasePriority(2)]
		class NNonDCReq : NegXeStatsDFTestBase
		{
			override protected void Execute()
			{
				string    pathName = "//xestats.1234/u:3949/1234/" + new Random().Next().ToString("x");;
				uint    titleID = 0x1234;
				XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,titleID,"ServiceAddr");
				removeReq.Server.Port = 10140;

				if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}

        [TestCase, Description("34925:create a file with a pathname and one title ID, call RemoveFile with the same pathname but different title ID"), TestCasePriority(2)]
		class NRemoveFromOtherTitle : NegXeStatsDFTestBase
		{
			override protected void Execute()
			{
				uint    randomTitleID = (uint)new Random().Next();
				string    sTitleID = randomTitleID.ToString("x");
				string pathName = "//xestats."+sTitleID+"/u:abcdef/"+sTitleID+"/" + new Random().Next().ToString("x");;

				XRLRemoveFile    removeReq = new XRLRemoveFile(pathName,randomTitleID+1,"ServiceAddr");
				XRLWriteFile    WriteReq = new XRLWriteFile("Owner",pathName);
				if(WriteReq.Execute())
				{
					if(RemoveFileTestNegative(removeReq,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\FuncXeStatsRF.cs ===
using System;
using System.Text;
using System.IO;
using System.Net;
using System.Data.SqlClient;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Storage;
using xonline.common.config;

namespace XStoreTest
{
	internal abstract class NegXeStatsRFTestBase : TestBase
	{
		//	send readFile requests, then check the error code
		protected bool ReadFileTestNegative(XRLReadFile ReadFileReq, uint XErr)
		{
			XRLReadFileResponse	ReadFileResp;
			if (ReadFileReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out ReadFileResp))
			{
				Global.RO.Warn("Negative ReadFile request succeed unexpectedly");
				return false;
			}
			if((ReadFileReq.XErr != XErr) || (ReadFileResp != null))
			{
				Global.RO.Warn("Wrong error code " + Global.XErrToString(ReadFileReq.XErr) +" returned or ReadFileResp is not null");
				return false;
			}
			return true;
		}
	}
	/// <summary>
	/// Summary description for FuncGlobalTitleRF.
	/// </summary>
    [TestGroup, Owner("JKonkle"), TestFrequency("Regression"), TestCasePriority(1)]
	public class FuncXeStatsRF : TestNode
	{
		/**********************************************************************
		 * Wire Protocol Testing Cases
		 **********************************************************************/
		[TestCase, Description("check X-Delay in the http response header")]
			class PThrottling : TestBase
		{
			override protected void Execute()
			{
				string pathName = "//xestats/u:ffffffff/343/" + new Random().Next().ToString("x");;
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",pathName);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					int Xdelay= 3000;
					Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage,"exec :stfd SetXDelay "+readReq.uiTitleId.ToString("X")+" readfile "+Xdelay);

					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp)&&
						(readReq.XDelay == Xdelay))
						ResultCode=TEST_RESULTS.PASSED;

					Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage,"exec :stfd ReloadThrottleConfig");

				}
			}
		}
        [TestCase, Description("read a file for TitleA to the cache; try to read the file from a different title"), TestCasePriority(2)]
			class NReadCacheFromDiffTitle : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string pathName= "//xestats."+sTitleID+"/u:846/"+sTitleID+"/" + new Random().Next().ToString("x");;

				XRLWriteFile	writeReq = new XRLWriteFile("Owner",pathName);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp, readResp2;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
					{
						// the file now is in the cache; try to read the file from titleB
						XRLReadFile		readReq2 = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
						readReq2.Slot.titleId = readReq2.uiTitleId = writeReq.uiTitleId + 1;
						readReq2.Slot.titleVersion = readReq2.uiTitleVersion;
						if(!readReq2.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out readResp2))
                        {
							if(readReq2.XErr == HResult.XONLINE_E_STORAGE_ERROR)
                            {
                                ResultCode = TEST_RESULTS.PASSED;
                            }
                            else
                            {
                                Global.RO.Warn("Wrong error code " + Global.XErrToString(readReq2.XErr) + " returned");
                            }
                        }
                        else
                        {
                            Global.RO.Warn("Read succeeded when it should've failed.");
                        }
                    }
				}
			}
		}
		[TestCase, Description("read a file from cache for the same title")]
			class PReadCacheFromSameTitle : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string pathName= "//xestats."+sTitleID+"/u:846/"+sTitleID+"/" + new Random().Next().ToString("x");;

				XRLWriteFile	writeReq = new XRLWriteFile("Owner",pathName);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp, readResp2;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;
					if(readReq.Execute(Global.XEnv.GetInterface(Interface.stfd_storage)[0],out readResp))
					{
						// the file now is in the cache;
						// remove the actual file, then read the file again
						XRLRemoveFile	removeReq = new XRLRemoveFile(pathName,randomTitleID,"ServiceAddr");
						if(removeReq.Execute())
						{
							XRLReadFile		readReq2 = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
							readReq2.Slot.titleId = readReq2.uiTitleId = writeReq.uiTitleId;
							readReq2.Slot.titleVersion = readReq2.uiTitleVersion;
							if(readReq2.Execute(Global.XEnv.GetInterface(Interface.stfd_storage)[0], out readResp2))
								ResultCode=TEST_RESULTS.PASSED;
						}
					}
				}
			}
		}
        [TestCase, Description("33960:Write a file first; then read the file with ifModifiedSince>actualModifiedTime"), TestCasePriority(2)]
			class NModifiedSince : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string pathName= "//xestats."+sTitleID+"/u:846/"+sTitleID+"/" + new Random().Next().ToString("x");;

				XRLWriteFile	writeReq = new XRLWriteFile("Owner",pathName);

				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;;
					readReq.lIfModifiedSinceDate = (long)System.DateTime.UtcNow.AddHours(2).ToFileTimeUtc();
					if(!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp)&&
						(readReq.XErr == HResult.XONLINE_S_STORAGE_FILE_NOT_MODIFIED) && (readResp == null))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("Write a file first; the request this file with titleID set to max")]
			class PMaxTitlePUID : TestBase
		{
			override protected void Execute()
			{
				string pathName = "//xestats/u:3993/ffffffff/" + new Random().Next().ToString("x");;
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",pathName);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("Write a file first; the request this file with titleID set to min")]
			class PMinTitlePUID : TestBase
		{
			override protected void Execute()
			{
				string pathName = "//xestats.1/u:dfd1/1/" + new Random().Next().ToString("x");;
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",pathName);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("Write a file first; the request this file with machine PUID set to max")]
			class PMaxXBoxPUID : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string pathName= "//xestats."+sTitleID+"/u:846/"+sTitleID+"/" + new Random().Next().ToString("x");;

				XRLWriteFile	writeReq = new XRLWriteFile("Owner",pathName);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					readReq.Slot.machinePuid = readReq.accessToken.baseAT.xboxPuid = 0xffffffffffffffff;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("Write a file first; the request this file with machine PUID set to min")]
			class PMinXBoxPUID : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string pathName= "//xestats."+sTitleID+"/u:846/"+sTitleID+"/" + new Random().Next().ToString("x");;

				XRLWriteFile	writeReq = new XRLWriteFile("Owner",pathName);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					readReq.Slot.machinePuid = readReq.accessToken.baseAT.xboxPuid = 1;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request with mismatched TitleID"), TestCasePriority(2)]
			class NReadFromDifferentTitle : NegXeStatsRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string pathName= "//xestats."+sTitleID+"/u:846/"+sTitleID+"/" + new Random().Next().ToString("x");;

				XRLWriteFile	writeReq = new XRLWriteFile("Owner",pathName);
				if(writeReq.Execute())
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId + 1;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_ERROR))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("write a valid file first, then request with mismatched TitleVersion")]
			class PReadFromDifferentTitleVersion : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string pathName= "//xestats."+sTitleID+"/u:846/"+sTitleID+"/" + new Random().Next().ToString("x");;

				XRLWriteFile	writeReq = new XRLWriteFile("Owner",pathName);
				if(writeReq.Execute())
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion= writeReq.uiTitleVersion + 1;
					XRLReadFileResponse		Response;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out Response))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("pass null for AccessToken"), TestCasePriority(2)]
			class NAccessTokenNullAT : NegXeStatsRFTestBase
		{
			override protected void Execute()
			{
				string pathName = "//xestats.1234/u:abcd/1234/" + new Random().Next().ToString("x");;
				XRLReadFile		readReq = new XRLReadFile(pathName);
				readReq.accessToken = null;

				if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode = TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass non-readfile operation in the AT"), TestCasePriority(2)]
			class NAccessTokenMismatchedOp : NegXeStatsRFTestBase
		{
			override protected void Execute()
			{
				string pathName = "//xestats.1234/u:abcd/1234/" + new Random().Next().ToString("x");;
				XRLReadFile		readReq = new XRLReadFile(pathName);
				readReq.accessToken.baseAT.operation = (ushort)Constants.Operation.FileWrite;

				if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode = TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("write a file first, then request it with pathnameLen is greater than the actual pathname"), TestCasePriority(2)]
			class NAccessTokenTruncatePathname : NegXeStatsRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string pathName= "//xestats."+sTitleID+"/u:846/"+sTitleID+"/" + new Random().Next().ToString("x");;

				XRLWriteFile	writeReq = new XRLWriteFile("Owner",pathName);
				if(writeReq.Execute())
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					readReq.accessToken.baseAT.ManualArraySize = true;
					readReq.accessToken.baseAT.pathNameLen += 1;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a file first, then request it with pathnameLen is less than the actual pathname"), TestCasePriority(2)]
			class NAccessTokenOverflowPathname : NegXeStatsRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string pathName= "//xestats."+sTitleID+"/u:846/"+sTitleID+"/" + new Random().Next().ToString("x");;

				XRLWriteFile	writeReq = new XRLWriteFile("Owner",pathName);
				if(writeReq.Execute())
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					readReq.accessToken.baseAT.ManualArraySize = true;
					readReq.accessToken.baseAT.pathNameLen -= 1;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("pass null for pathname and pathnameLen is 0"), TestCasePriority(2)]
			class NAccessTokenNullPathname : NegXeStatsRFTestBase
		{
			override protected void Execute()
			{
				string pathName = "//xestats.1234/u:abcd/1234/" + new Random().Next().ToString("x");;
				XRLReadFile		readReq = new XRLReadFile(pathName);
				readReq.accessToken.baseAT.pathName = null;
				readReq.accessToken.baseAT.pathNameLen = 0;

				if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode = TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("AccessToken size is greater than 255+baseAT"), TestCasePriority(2)]
			class NAccessTokenOverflowAT : NegXeStatsRFTestBase
		{
			override protected void Execute()
			{
				string url = "//xestats.1234/u:abcd/1234/" + new Random().Next().ToString("x");;
				XRLReadFile		readReq = new XRLReadFile(url);
				StringBuilder	pathName = new StringBuilder(readReq.accessToken.baseAT.pathName);
				int		numUniCharToAdd = 256 - readReq.accessToken.baseAT.pathNameLen;
				string			temp = new string('a',numUniCharToAdd);
				pathName.Append(temp);
				readReq.accessToken.baseAT.pathNameLen = 256;//actual pathName length is 256
				readReq.accessToken.baseAT.pathName = pathName.ToString();

				if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode = TEST_RESULTS.PASSED;
			}
		}

        [TestCase, Description("write file first, then request it with non-null signature but sigSize is zero"), TestCasePriority(2)]
			class NAccessTokenNonNullSignature : NegXeStatsRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string pathName= "//xestats."+sTitleID+"/u:846/"+sTitleID+"/" + new Random().Next().ToString("x");;

				XRLWriteFile	writeReq = new XRLWriteFile("Owner",pathName);
				if(writeReq.Execute())
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.accessToken.readAT.ManualArraySize = true;
					readReq.accessToken.readAT.signatureLen = 0;
					readReq.accessToken.readAT.signature = new byte[Constants.sizeSignature];
					for(int i = 0; i < Constants.sizeSignature; i++)
						readReq.accessToken.readAT.signature[i] = 0;
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write file first, then request it with token exp is before current time"), TestCasePriority(2)]
			class NAccessTokenWrongATExpTime : NegXeStatsRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string pathName= "//xestats."+sTitleID+"/u:846/"+sTitleID+"/" + new Random().Next().ToString("x");;

				XRLWriteFile	writeReq = new XRLWriteFile("Owner",pathName);
				if(writeReq.Execute())
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.accessToken.readAT.tokenExpirationDate = System.DateTime.UtcNow.AddDays(-1).ToFileTimeUtc();
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write file first, then request it with non-zero flags"), TestCasePriority(2)]
			class NAccessTokenWrongFlags : NegXeStatsRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string pathName= "//xestats."+sTitleID+"/u:846/"+sTitleID+"/" + new Random().Next().ToString("x");;

				XRLWriteFile	writeReq = new XRLWriteFile("Owner",pathName);
				if(writeReq.Execute())
				{
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.accessToken.baseAT.flags = 1;
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
		/**********************************************************************
		 * Pathname Testing Cases
		 **********************************************************************/
        [TestCase, Description("write a valid file first, then request it with one null char in the middle of <Domain-part>"), TestCasePriority(2)]
			class NPathnameBadString1 : NegXeStatsRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//xestats."+sTitleID+"/u:846/"+sTitleID+"/" + new Random().Next().ToString("x");;

				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					newPath = pathName.Insert(6,'\0'.ToString());

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					//TODO: need to return xonline_e_storage_domain_not_supported
					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it with two null char in the middle of <domain-part>"), TestCasePriority(2)]
			class NPathnameBadString2 : NegXeStatsRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//xestats."+sTitleID+"/u:846/"+sTitleID+"/" + new Random().Next().ToString("x");;
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath, temp;
					temp = '\0'.ToString() + '\0'.ToString();
					newPath = pathName.Insert(6,temp);	// //stat..s/u:....

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it with one nullchar in the middle of <title>"), TestCasePriority(2)]
			class NPathnameBadString3 : NegXeStatsRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//xestats."+sTitleID+"/u:846/"+sTitleID+"/" + new Random().Next().ToString("x");;
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					newPath = pathName.Insert(17,'\0'.ToString());

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it with one nullchar in the middle of <pathpart>"), TestCasePriority(2)]
			class NPathnameBadString4 : NegXeStatsRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//xestats."+sTitleID+"/u:846/"+sTitleID+"/" + new Random().Next().ToString("x");;
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					newPath = pathName.Insert(30,'\0'.ToString());

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it with one nullchar at the end of <pathpart>"), TestCasePriority(2)]
			class NPathnameBadString5 : NegXeStatsRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//xestats."+sTitleID+"/u:846/"+sTitleID+"/" + new Random().Next().ToString("x");;
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					newPath = pathName + '\0'.ToString();

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it by passing a nonexisitent <path-part>(vc_name)"), TestCasePriority(2)]
			class NPathnameNonExistFile1 : NegXeStatsRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//xestats."+sTitleID+"/u:846/"+sTitleID+"/" + new Random().Next().ToString("x");;
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					int		guidStartPos = pathName.LastIndexOf('/');
					newPath = pathName.Substring(0,guidStartPos)+ "/" + new Random().Next().ToString("x");;

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}

        [TestCase, Description("write a valid file first, then request it by passing wrong IDNameSpace"), TestCasePriority(2)]
			class NPathnameWrongIDNameSpace : NegXeStatsRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//xestats."+sTitleID+"/u:846/"+sTitleID+"/" + new Random().Next().ToString("x");;
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					newPath = pathName.Replace("u:","x:");

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("write a valid file first, then request it by passing wrong Domain"), TestCasePriority(2)]
			class NPathnameWrongDomain : NegXeStatsRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//xestats."+sTitleID+"/u:846/"+sTitleID+"/" + new Random().Next().ToString("x");;
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					// "//stats/u:<ulonglong>/<guid>"
					string	pathName = writeReq.accessToken.baseAT.pathName, newPath;
					newPath = pathName.Replace("xestats","voice");

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_PATH))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("Write file first, then request it by passing a pathname that has no domain part"), TestCasePriority(2)]
			class NPathnameNoDomainPart : NegXeStatsRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//xestats."+sTitleID+"/u:846/"+sTitleID+"/" + new Random().Next().ToString("x");;
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					string path = writeReq.accessToken.baseAT.pathName, newPath, temp;
					temp = path.Substring(path.IndexOf("u:"));
					newPath = "///" + temp;

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("Write file first, then request it by passing no t:"), TestCasePriority(2)]
			class NPathnameNoIDNameSpace : NegXeStatsRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//xestats."+sTitleID+"/u:846/"+sTitleID+"/" + new Random().Next().ToString("x");;
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					string path = writeReq.accessToken.baseAT.pathName, newPath;
					newPath = path.Remove(path.IndexOf("u:"),1);

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
        [TestCase, Description("Write file first, then request it by passing no userPUID"), TestCasePriority(2)]
			class NPathnameNoUserPUID : NegXeStatsRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//xestats."+sTitleID+"/u:846/"+sTitleID+"/" + new Random().Next().ToString("x");;
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					string pathName = writeReq.accessToken.baseAT.pathName, newPath;
					int		pos = pathName.IndexOf("u:"), guidStart = pathName.LastIndexOf('/');
					newPath = pathName.Substring(0,pos)+ "u:" + pathName.Substring(guidStart);

					XRLReadFile		readReq = new XRLReadFile(newPath);
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}

        [TestCase, Description("Write file first, then request it by pass wrong charset"), TestCasePriority(2)]
			class NPathnameWrongCharSet : NegXeStatsRFTestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//xestats."+sTitleID+"/u:846/"+sTitleID+"/" + new Random().Next().ToString("x");;
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					string path = writeReq.accessToken.baseAT.pathName;
					StringBuilder	pathName = new StringBuilder(path);
					//Bug 27831: domain and optional domain specified: A-Za-z0-9_
					// pathname allows anything except control chars('\0\, control characters, etc)
					char i = '\0';
					pathName.Append(i);

					XRLReadFile		readReq = new XRLReadFile(pathName.ToString());
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					if(ReadFileTestNegative(readReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
		/***********************************************************************
		* SG Auth Data Testing
		* *********************************************************************/
        [TestCase, Description("the userPUID in SGAuth response is not_found user"), TestCasePriority(2)]
			class NSGAuthNotFoundUser : NegXeStatsRFTestBase
		{
			override protected void Execute()
			{
				string url = "//xestats.1234/u:abcd/1234/" + new Random().Next().ToString("x");;
				XRLReadFile	req = new XRLReadFile(url);
				req.Slot.UserExists = 0;

				if(ReadFileTestNegative(req,HResult.XONLINE_E_SERVER_ERROR))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the userPUID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidUser : NegXeStatsRFTestBase
		{
			override protected void Execute()
			{
				string url = "//xestats.1234/u:abcd/1234/" + new Random().Next().ToString("x");;
				XRLReadFile	req = new XRLReadFile(url);
				req.Slot.userPuid0++;

				if(ReadFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the TitleID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidTitleID : NegXeStatsRFTestBase
		{
			override protected void Execute()
			{
				string url = "//xestats.1234/u:abcd/1234/" + new Random().Next().ToString("x");;
				XRLReadFile	req = new XRLReadFile(url);
				req.Slot.titleId++;

				if(ReadFileTestNegative(req,HResult.XONLINE_E_INVALID_TITLE_ID))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the XBoxPUID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidXBoxPUID : NegXeStatsRFTestBase
		{
			override protected void Execute()
			{
				string url = "//xestats.1234/u:abcd/1234/" + new Random().Next().ToString("x");;
				XRLReadFile	req = new XRLReadFile(url);
				req.Slot.machinePuid++;

				if(ReadFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the TitleVersion in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidTitleVersion : NegXeStatsRFTestBase
		{
			override protected void Execute()
			{
				string url = "//xestats.1234/u:abcd/1234/" + new Random().Next().ToString("x");;
				XRLReadFile	req = new XRLReadFile(url);
				req.Slot.titleVersion++;

				if(ReadFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the CountryID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidCountryID : NegXeStatsRFTestBase
		{
			override protected void Execute()
			{
				string url = "//xestats.1234/u:abcd/1234/" + new Random().Next().ToString("x");;
				XRLReadFile	req = new XRLReadFile(url);
				req.Slot.userFlag0 = (uint)((req.bUserCountryId+1)<<8);

				if(ReadFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}

		/**********************************************************************
		 * Other ReadFile Testing Cases
		 **********************************************************************/
		[TestCase, Description("Multiple threads read same file simultaneously")]
			class PMultiThreadsReadFile : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string xrl= "//xestats."+sTitleID+"/u:846/"+sTitleID+"/" + new Random().Next().ToString("x");;

				XRLWriteFile	writeReq = new XRLWriteFile("Owner",xrl);
				pathName = writeReq.accessToken.baseAT.pathName;
				uiTitleId = writeReq.uiTitleId;
				uiTitleVersion = writeReq.uiTitleVersion;

				if(writeReq.Execute())
				{
					Thread [] threadArray = new Thread[10];
					for(int i = 0; i < 10; i++)
					{
						threadArray[i] = ThreadMaker.CreateThread(readFileTS);
						threadArray[i].Start();
					}
					// the main thread is waiting for all threads to exit or timeout
					foreach (Thread t in threadArray)
						t.Join(1000);
					if(FailedReqs == 0)
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
			private void readFileTS()
			{
				XRLReadFileResponse	readResp;
				XRLReadFile		readReq = new XRLReadFile(pathName);
				readReq.Slot.titleId = readReq.uiTitleId = uiTitleId;
				readReq.Slot.titleVersion = readReq.uiTitleVersion = uiTitleVersion;

				if(!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out readResp))
				{
					Global.RO.Warn("readFileTS: read file request failed");
					Interlocked.Increment(ref FailedReqs);
				}
			}
			private string	pathName;
			private uint	uiTitleId, uiTitleVersion;
			private int		FailedReqs;
		}
		[TestCase, Description("read file 100 times")]
			class PReadFileMultiTimes : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string pathName= "//xestats."+sTitleID+"/u:846/"+sTitleID+"/" + new Random().Next().ToString("x");;

				XRLWriteFile	writeReq = new XRLWriteFile("Owner",pathName);
				if(writeReq.Execute())
				{
					uint				uiFailedReq = 0;
					for(int i = 0; i < 100; i++)
					{
						XRLReadFileResponse	readResp;
						XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
						readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
						readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
						if(!readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
							uiFailedReq++;
					}
					if(uiFailedReq == 0)
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		[TestCase, Description("the titleID in the request is not the acutal logged on title")]
		class PFamilyTitleID : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string pathName= "//xestats."+sTitleID+"/u:846/"+sTitleID+"/" + new Random().Next().ToString("x");;				
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",pathName);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
					readReq.Slot.altTitleId1 = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleId = readReq.uiTitleId + 1;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("write a valid file first, the request it from non-owner")]
		class PReadFromNonOwner : TestBase
		{
			override protected void Execute()
			{
				uint	randomTitleID = (uint)new Random().Next();
				string	sTitleID = randomTitleID.ToString("x");
				string url= "//xestats."+sTitleID+"/u:846/"+sTitleID+"/" + new Random().Next().ToString("x");;
				XRLWriteFile	writeReq = new XRLWriteFile("Owner",url);
				if(writeReq.Execute())
				{
					XRLReadFileResponse	readResp;
					XRLReadFile		readReq = new XRLReadFile(url);
					readReq.accessToken.baseAT.userPuid = 0xabcde;
					readReq.Slot.userPuid0 = 0xabcde;
					readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId;
					readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;

					if(readReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage),out readResp))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("change default readCacheTime to 1 sec")]
		class PReadCacheTimeChange : TestBase
		{
			override protected void Execute()
			{
                string environment = Config.Environment;
                string myQuery = "select TOP 1 i_read_cache_seconds from t_storage_domains where vc_name='xestats' AND vc_environment ='" + environment + "'";
                Global.RO.Debug("Executing query against NPDB to get i_read_cache_seconds: " + myQuery);
                object originalReadCacheSetting = StaticNpdb.ExecuteScalar(myQuery);
                if (originalReadCacheSetting == null)
                {
                    environment = "ALL";
                    myQuery = "select TOP 1 i_read_cache_seconds from t_storage_domains where vc_name='xestats' AND vc_environment ='" + environment + "'";
                    Global.RO.Debug("Executing query against NPDB to get i_read_cache_seconds: " + myQuery);
                    originalReadCacheSetting = StaticNpdb.ExecuteScalar(myQuery);
                }
                Global.RO.Debug("Default i_read_cache_seconds: " + originalReadCacheSetting.ToString());

                try
                {
                    myQuery = "update t_storage_domains set i_read_cache_seconds=1 where vc_name='xestats' AND vc_environment = '" + environment + "'";
                    Global.RO.Debug("Executing query against NPDB to change i_read_cache_seconds: " + myQuery);

                    if (StaticNpdb.ExecuteNonQuery(myQuery) != 0)
                    {
                        Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage, "exec :stfd Reloadnpdb");
                        uint randomTitleID = (uint)new Random().Next();
                        string sTitleID = randomTitleID.ToString("x");
                        string pathName = "//xestats." + sTitleID + "/u:846/" + sTitleID + "/" + new Random().Next().ToString("x"); ;
                        XRLWriteFile writeReq = new XRLWriteFile("Owner", pathName);
                        if (writeReq.Execute())
                        {
                            XRLReadFileResponse readResp, readResp2;
                            XRLReadFile readReq = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
                            readReq.Slot.titleId = readReq.uiTitleId = writeReq.uiTitleId; ;
                            readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion; ;
                            if (readReq.Execute(Global.XEnv.GetInterface(Interface.stfd_storage)[0], out readResp))
                            {
                                // the file now is in the cache; wait until cache expire
                                Thread.Sleep(5000); // 1 second wasn't long enough.
                                // remove the actual file, then read the file again
                                XRLRemoveFile removeReq = new XRLRemoveFile(pathName, randomTitleID, "ServiceAddr");
                                if (removeReq.Execute())
                                {
                                    XRLReadFile readReq2 = new XRLReadFile(writeReq.accessToken.baseAT.pathName);
                                    readReq2.Slot.titleId = readReq2.uiTitleId = writeReq.uiTitleId;
                                    readReq2.Slot.titleVersion = readReq2.uiTitleVersion;
                                    if (!readReq2.Execute(Global.XEnv.GetInterface(Interface.stfd_storage)[0], out readResp2))
                                    {
                                        if (readReq2.XErr == HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND)
                                        {
                                            ResultCode = TEST_RESULTS.PASSED;
                                        }
                                        else
                                        {
                                            Global.RO.Warn("Wrong error code " + Global.XErrToString(readReq2.XErr) + " returned");
                                        }
                                    }
                                    else
                                    {
                                        Global.RO.Warn("Read succeeded when it should've failed.");
                                    }
                                }
                            }
                        }
                    }
                }
                finally
                {
                    // change the setting back in npdb:
                    if(originalReadCacheSetting != null)
                        myQuery = "update t_storage_domains set i_read_cache_seconds=" + originalReadCacheSetting.ToString() + " where vc_name='xestats' AND vc_environment = '" + environment + "'";
                    else
                        myQuery = "update t_storage_domains set i_read_cache_seconds=3600 where vc_name='xestats' AND vc_environment = '" + environment + "'";
                    Global.RO.Debug("Executing query against NPDB to restore i_read_cache_seconds: " + myQuery);
                    StaticNpdb.ExecuteNonQuery(myQuery);
                    Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage, "exec :stfd Reloadnpdb");
                }
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\StressCrossTitle.cs ===
using System;
using System.Threading;
using System.Collections;
using System.Globalization;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Storage;
using xonline.common.config;

namespace XStoreTest
{
    [StressInstantiate]
    public class StressGlobalWrite : TestBase
	{
		override protected void Execute()
		{
			bool fail = false;
            string writeUrl;
            // get file off of queue and write...
            if (XStoreTest.syncdCrossTitleFileQ.Count >= XStoreTest.MaxQueueLength)
            {
                try
                {
                    writeUrl = (string)XStoreTest.syncdCrossTitleFileQ.Dequeue();
                }
                catch (InvalidOperationException)
                {
                    // if we fail to read, generate a new one to play with
                    uint randomIndex = (uint)XStoreTest.randomInstance.Next();
                    writeUrl = "//global/t:FFFE07D1/ach/1/" + randomIndex.ToString("x");
                }
            }
            else
            {
                // if the queue is not full, generate a new one to play with
                uint randomIndex = (uint)XStoreTest.randomInstance.Next();
                writeUrl = "//global/t:FFFE07D1/ach/1/" + randomIndex.ToString("x");
            }
            
            // Clean up to be safe because global overwrite is off by default
            XRLRemoveFile removeReq = new XRLRemoveFile(writeUrl, 0xFFFE07D1, "ServiceAddr");
            removeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage));

            XRLWriteFile writeReq = new XRLWriteFile("ServiceAddr", writeUrl, XStoreTest.CrossTitleFile, true);
            writeReq.uiTitleId = writeReq.Slot.titleId = 0xFFFE07D1;
            byte[] rand = new byte[(XStoreTest.CrossTitleFile < 8) ? XStoreTest.CrossTitleFile : 8];
            XStoreTest.rng.GetBytes(rand);
            rand.CopyTo(writeReq.blobData, 0);
            if (writeReq.Execute())
            {
                // Put the file at the end of the queue.  Recycling is good. 
                if (XStoreTest.syncdCrossTitleFileQ.Count < XStoreTest.MaxQueueLength)
                {
                    XStoreTest.syncdCrossTitleFileQ.Enqueue(writeUrl);
                }
            }
            else
            {
                XStoreTest.Safetw.WriteLine(DateTime.Now.ToString() + ":WriteFile request failed:" + writeUrl + " - 0x" + writeReq.XErr.ToString("x"));
                fail = true;
            }

            if (!fail)
                ResultCode = TEST_RESULTS.PASSED;

		}
	}

    [StressInstantiate]
    public class StressGlobalRead : TestBase
    {
        override protected void Execute()
        {
            bool fail = false;
            string readUrl;
            // get file off of queue and read...
            try
            {
                readUrl = (string)XStoreTest.syncdCrossTitleFileQ.Dequeue();
            }
            catch  // if we fail to read, generate a new one to play with
            {
                uint randomIndex = (uint)XStoreTest.randomInstance.Next();
                readUrl = "//global/t:FFFE07D1/ach/1/" + randomIndex.ToString("x");

                XRLWriteFile writeReq = new XRLWriteFile("ServiceAddr", readUrl, XStoreTest.CrossTitleFile, true);
                writeReq.uiTitleId = writeReq.Slot.titleId = 0xFFFE07D1;
                byte[] rand = new byte[(XStoreTest.CrossTitleFile < 8) ? XStoreTest.CrossTitleFile : 8];
                XStoreTest.rng.GetBytes(rand);
                rand.CopyTo(writeReq.blobData, 0);
                writeReq.Execute();
            }

            XRLReadFileResponse readResp;
            XRLReadFile readReq = new XRLReadFile(readUrl);

            if (!readReq.Execute(true, Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out readResp))
            {
                XStoreTest.Safetw.WriteLine(DateTime.Now.ToString() + ":ReadFile request failed:" + readUrl + " - 0x" + readReq.XErr.ToString("x"));
                fail = true;
            }

            // Put the file at the end of the queue immediately.  Recycling is good. 
            if (XStoreTest.syncdCrossTitleFileQ.Count < XStoreTest.MaxQueueLength)
            {
                XStoreTest.syncdCrossTitleFileQ.Enqueue(readUrl);
            }

            if (!fail)
                ResultCode = TEST_RESULTS.PASSED;

        }
    }

    [StressInstantiate]
    public class StressGlobalEnum : TestBase
    {
        override protected void Execute()
        {
            bool fail = false;
            string enumUrl;
            // get file off of queue and read...
            try
            {
                enumUrl = (string)XStoreTest.syncdCrossTitleFileQ.Dequeue();
            }
            catch
            {
                // if we fail to read, generate a new one to play with
                uint randomIndex = (uint)XStoreTest.randomInstance.Next();
                enumUrl = "//global/t:FFFE07D1/ach/1/" + randomIndex.ToString("x");

                XRLWriteFile writeReq = new XRLWriteFile("ServiceAddr", enumUrl, XStoreTest.CrossTitleFile, true);
                writeReq.uiTitleId = writeReq.Slot.titleId = 0xFFFE07D1;
                byte[] rand = new byte[(XStoreTest.CrossTitleFile < 8) ? XStoreTest.CrossTitleFile : 8];
                XStoreTest.rng.GetBytes(rand);
                rand.CopyTo(writeReq.blobData, 0);
                writeReq.Execute();
            }

            long modifiedSince = (long)System.DateTime.UtcNow.AddDays(-1).ToFileTimeUtc();
            XRLEnumFiles enumReq = new XRLEnumFiles(enumUrl, 0xFFFE07D1, 0, 9, modifiedSince);
            XRLEnumFilesResponse enumResp;
            if (!enumReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out enumResp))
            {
                XStoreTest.Safetw.WriteLine(DateTime.Now.ToString() + ":EnumReq request failed:" + enumUrl + " - 0x" + enumReq.XErr.ToString("x"));
                fail = true;
            }

            // Put the file at the end of the queue immediately.  Recycling is good. 
            if (XStoreTest.syncdCrossTitleFileQ.Count < XStoreTest.MaxQueueLength)
            {
                XStoreTest.syncdCrossTitleFileQ.Enqueue(enumUrl);
            }

            if (!fail)
                ResultCode = TEST_RESULTS.PASSED;

        }
    }

    [StressInstantiate]
    public class StressGlobalRemove : TestBase
    {
        override protected void Execute()
        {
            bool fail = false;
            string removeUrl;
            // get file off of queue and read...
            try
            {
                removeUrl = (string)XStoreTest.syncdCrossTitleFileQ.Dequeue();
            }
            catch
            {
                // if we fail to read, generate a new one to play with
                uint randomIndex = (uint)XStoreTest.randomInstance.Next();
                removeUrl = "//global/t:FFFE07D1/ach/1/" + randomIndex.ToString("x");

                XRLWriteFile writeReq = new XRLWriteFile("ServiceAddr", removeUrl, XStoreTest.CrossTitleFile, true);
                writeReq.uiTitleId = writeReq.Slot.titleId = 0xFFFE07D1;
                byte[] rand = new byte[(XStoreTest.CrossTitleFile < 8) ? XStoreTest.CrossTitleFile : 8];
                XStoreTest.rng.GetBytes(rand);
                rand.CopyTo(writeReq.blobData, 0);
                writeReq.Execute();
            }

            XRLRemoveFile removeReq = new XRLRemoveFile(removeUrl, 0xFFFE07D1, "ServiceAddr");
            removeReq.Slot.titleId = removeReq.uiTitleId = 0xFFFE07D1;

            if (!removeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
            {
                XStoreTest.Safetw.WriteLine(DateTime.Now.ToString() + ":RemoveFile request failed:" + removeUrl + " - 0x" + removeReq.XErr.ToString("x"));
                fail = true;
            }

            if (!fail)
                ResultCode = TEST_RESULTS.PASSED;

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\StressGlobalTitle.cs ===
using System;
using System.Threading;
using System.Collections;
using System.Globalization;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Storage;
using xonline.common.config;

namespace XStoreTest
{
    // //title.fffe07d1/t:fffe07d1/livepackfall07.xex
    [StressInstantiate]
    public class StressGlobalTitleEnum : TestBase
    {
        override protected void Execute()
        {
            string url;
            uint TitleID = 0xFFFE07D1;
            long modifiedSince = 0;
            uint selection=0;

            selection = (uint)(DateTime.Now.Millisecond % 10);

            switch (selection)
            {
                case 0:
                    url = "//title.fffe07d1/t:fffe07d1/livepack*";
                    break;
                case 1:
                    url = "//title.fffe07d1/t:fffe07d1/parentalRatingsIcons/USK*";
                    break;
                case 2:
                    url = "//title.fffe07d1/t:fffe07d1/parentalRatingsIcons/PEGI*";
                    break;
                case 3:
                    url = "//title.fffe07d1/t:fffe07d1/parentalRatingsIcons/OFLC*";
                    break;
                case 4:
                    url = "//title.fffe07d1/t:fffe07d1/parentalRatingsIcons/KMRB*";
                    break;
                case 5:
                    url = "//title.fffe07d1/t:fffe07d1/parentalRatingsIcons/ESRB*";
                    break;
                case 6:
                    url = "//title.fffe07d1/t:fffe07d1/parentalRatingsIcons/CERO*";
                    break;
                default:
                    url = "//title.fffe07d1/t:fffe07d1/livepack*";
                    break;
            }

            XRLEnumFilesResponse enumResp;
            XRLEnumFiles enumReq = new XRLEnumFiles(url, TitleID, 0, 9, modifiedSince);
            if (enumReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out enumResp))
            {	// check returned results
                if (enumResp.numFilesTotal >0)
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                    Global.RO.Warn("numFilesTotal" + enumResp.numFilesTotal + " or numFilesResponse " + enumResp.resultsLen + " is not correct");
            }
        }
    }

    [StressInstantiate]
	public class StressTitleWrite : TestBase
	{
		override protected void Execute()
		{
			uint	titleID = 0;
			string	writeUrl;
            string  sTitleID;
			bool	fail = false;

            // get file off of queue and write...
            if (XStoreTest.syncdTitleFileQ.Count >= XStoreTest.MaxQueueLength)
            {
                try
                {
                    QueueUrlObject tempUrlObject = (QueueUrlObject)XStoreTest.syncdTitleFileQ.Dequeue();
                    writeUrl = tempUrlObject.Url;
                    titleID = tempUrlObject.TitleId;
                    sTitleID = titleID.ToString("x");
                }
                catch (InvalidOperationException)
                {
                    // if we fail to read, generate a new one to play with
                    titleID = (uint)(XStoreTest.randomInstance.Next(1, (int)XStoreTest.numOfTitles));
                    sTitleID = titleID.ToString("x");
                    writeUrl = "//title." + sTitleID + "/t:" + sTitleID + "/shuyinz";
                }
            }
            else
            {
                // if the queue is not full, generate a new one to play with
                titleID = (uint)(XStoreTest.randomInstance.Next(1, (int)XStoreTest.numOfTitles));
                sTitleID = titleID.ToString("x");
                writeUrl = "//title." + sTitleID + "/t:" + sTitleID + "/shuyinz";
            }

            XRLWriteFile writeReq = new XRLWriteFile("ServiceAddr", writeUrl, XStoreTest.TitleFile, true);
			byte [] rand = new byte[(XStoreTest.TitleFile<8)? XStoreTest.TitleFile : 8];
			XStoreTest.rng.GetBytes(rand);
			rand.CopyTo(writeReq.blobData,0);

            if (writeReq.Execute())
            {
                if (XStoreTest.syncdTitleFileQ.Count < XStoreTest.MaxQueueLength)
                {
                    XStoreTest.syncdTitleFileQ.Enqueue(new QueueUrlObject(titleID, writeUrl));
                }
            }
            else
            {
                XStoreTest.Safetw.WriteLine(DateTime.Now.ToString() + ":WriteFile request failed:" + writeReq.XErr.ToString("x"));
                fail = true;
            }
            
            if (!fail)
                ResultCode = TEST_RESULTS.PASSED;
        }
	}

    [StressInstantiate]
    public class StressTitleRead : TestBase
    {
        override protected void Execute()
        {
            uint titleID = 0;
            string readUrl;
            string sTitleID;
            bool fail = false;

            try
            {
                QueueUrlObject tempUrlObject = (QueueUrlObject)XStoreTest.syncdTitleFileQ.Dequeue();
                readUrl = tempUrlObject.Url;
                titleID = tempUrlObject.TitleId;
                sTitleID = titleID.ToString("x");
            }
            catch (InvalidOperationException)
            {
                // if we fail to read, generate a new one to play with
                titleID = (uint)(XStoreTest.randomInstance.Next(1, (int)XStoreTest.numOfTitles));
                sTitleID = titleID.ToString("x");
                readUrl = "//title." + sTitleID + "/t:" + sTitleID + "/shuyinz";

                XRLWriteFile writeReq = new XRLWriteFile("ServiceAddr", readUrl, XStoreTest.TitleFile, true);
                byte[] rand = new byte[(XStoreTest.TitleFile < 8) ? XStoreTest.TitleFile : 8];
                XStoreTest.rng.GetBytes(rand);
                rand.CopyTo(writeReq.blobData, 0);

                writeReq.Execute();
            }

            XRLReadFileResponse readResp;
            XRLReadFile readReq = new XRLReadFile(readUrl);
            // get titleID from readUrl

            readReq.Slot.titleId = readReq.uiTitleId = titleID;
            //	readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
            if (!readReq.Execute(true, Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out readResp))
            {
                XStoreTest.Safetw.WriteLine(DateTime.Now.ToString() + ":ReadFile request failed:" + readReq.XErr.ToString("x"));
                fail = true;
            }

            if (XStoreTest.syncdTitleFileQ.Count < XStoreTest.MaxQueueLength)
            {
                XStoreTest.syncdTitleFileQ.Enqueue(new QueueUrlObject(titleID, readUrl));
            }

            if (!fail)
                ResultCode = TEST_RESULTS.PASSED;
        }
    }

    [StressInstantiate]
    public class StressTitleEnum : TestBase
    {
        override protected void Execute()
        {
            uint titleID = 0;
            string enumUrl;
            string sTitleID;
            bool fail = false;
            long modifiedSince = 0;

            try
            {
                QueueUrlObject tempUrlObject = (QueueUrlObject)XStoreTest.syncdTitleFileQ.Dequeue();
                enumUrl = tempUrlObject.Url;
                titleID = tempUrlObject.TitleId;
                sTitleID = titleID.ToString("x");
            }
            catch (InvalidOperationException)
            {
                // if we fail to read, generate a new one to play with
                titleID = (uint)(XStoreTest.randomInstance.Next(1, (int)XStoreTest.numOfTitles));
                sTitleID = titleID.ToString("x");
                enumUrl = "//title." + sTitleID + "/t:" + sTitleID + "/shuyinz";

                XRLWriteFile writeReq = new XRLWriteFile("ServiceAddr", enumUrl, XStoreTest.TitleFile, true);
                byte[] rand = new byte[(XStoreTest.TitleFile < 8) ? XStoreTest.TitleFile : 8];
                XStoreTest.rng.GetBytes(rand);
                rand.CopyTo(writeReq.blobData, 0);

                writeReq.Execute();
            }

            string enumXRL = "//title." + sTitleID + "/t:" + sTitleID + "/*";
            modifiedSince = (long)System.DateTime.UtcNow.AddDays(-1).ToFileTimeUtc();
            XRLEnumFiles enumReq = new XRLEnumFiles(enumXRL, titleID, 0, 9, modifiedSince);
            XRLEnumFilesResponse enumResp;
            if (!enumReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out enumResp))
            {
                XStoreTest.Safetw.WriteLine(DateTime.Now.ToString() + ":EnumReq request failed:" + enumReq.XErr.ToString("x"));
                fail = true;
            }

            if (XStoreTest.syncdTitleFileQ.Count < XStoreTest.MaxQueueLength)
            {
                XStoreTest.syncdTitleFileQ.Enqueue(new QueueUrlObject(titleID, enumUrl));
            }

            if (!fail)
                ResultCode = TEST_RESULTS.PASSED;
        }
    }

    [StressInstantiate]
    public class StressTitleRemove : TestBase
    {
        override protected void Execute()
        {
            uint titleID = 0;
            string removeUrl;
            string sTitleID;
            bool fail = false;

            try
            {
                QueueUrlObject tempUrlObject = (QueueUrlObject)XStoreTest.syncdTitleFileQ.Dequeue();
                removeUrl = tempUrlObject.Url;
                titleID = tempUrlObject.TitleId;
                sTitleID = titleID.ToString("x");
            }
            catch (InvalidOperationException)
            {
                // if we fail to read, generate a new one to play with
                titleID = (uint)(XStoreTest.randomInstance.Next(1, (int)XStoreTest.numOfTitles));
                sTitleID = titleID.ToString("x");
                removeUrl = "//title." + sTitleID + "/t:" + sTitleID + "/shuyinz";

                XRLWriteFile writeReq = new XRLWriteFile("ServiceAddr", removeUrl, XStoreTest.TitleFile, true);
                byte[] rand = new byte[(XStoreTest.TitleFile < 8) ? XStoreTest.TitleFile : 8];
                XStoreTest.rng.GetBytes(rand);
                rand.CopyTo(writeReq.blobData, 0);

                writeReq.Execute();
            }

            XRLRemoveFile removeReq = new XRLRemoveFile(removeUrl, titleID, "ServiceAddr");
            if (!removeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
            {
                XStoreTest.Safetw.WriteLine(DateTime.Now.ToString() + ":RemoveFile request failed:" + removeReq.XErr.ToString("x"));
                fail = true;
            }

            if (!fail)
                ResultCode = TEST_RESULTS.PASSED;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\FuzzEngine.cs ===
using System;
using System.IO;
using System.Text;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Globalization;

namespace FuzzEngine
{
    public class CharacterBag
    {
        /// <summary>
        /// Used to list this character bag's surrogates:
        /// </summary>
        public CharacterBag Surrogate = null;

        /// <summary>
        /// CharacterBag contents
        /// </summary>
        private String m_strValue = null;
        public String Value
        {
            get { return m_strValue; }
            set { m_strValue = value; }
        }

        /// <summary>
        /// Right-To-Left reading indicator:
        /// </summary>
        public bool IsRightToLeft
        {
            get
            {
                return CultureInfo.TextInfo.IsRightToLeft;
            }
        }

        /// <summary>
        /// Culture Information - used to determine the properties of the language
        /// see: http://msdn2.microsoft.com/en-us/library/system.globalization.cultureinfo(VS.71).aspx
        /// </summary>
        private CultureInfo m_CultureInfo = null;
        public CultureInfo CultureInfo
        {
            get
            {
                if (m_CultureInfo == null)
                {
                    m_CultureInfo = new CultureInfo(CultureIdentifier);
                }

                return m_CultureInfo;
            }
        }

        /// <summary>
        /// Culture Identifier - used to determine the properties of the language
        /// see: http://msdn2.microsoft.com/en-us/library/system.globalization.cultureinfo(VS.71).aspx
        /// </summary>
        private int m_nCultureIdentifier = 0x007F;
        public int CultureIdentifier
        {
            get { return m_nCultureIdentifier; }
            set { m_nCultureIdentifier = value; }
        }

        /// <summary>
        /// Constructs a CharacterBag
        /// </summary>
        /// <param name="value">CharacterBag contents</param>
        public CharacterBag(
            string value)
        {
            Value = value;
        }

        /// <summary>
        /// Constructs an empty CharacterBag
        /// </summary>
        public CharacterBag()
        {
        }

        /// <summary>
        /// Removes characters from the CharacterBag
        /// </summary>
        /// <param name="strCharacters">characters to remove</param>
        public void Remove(
            char[] characters)
        {
            StringBuilder sbValue = new StringBuilder(Value);

            foreach (char cItem in characters)
            {
                String strTemp = cItem + "";

                sbValue.Replace(strTemp, "");
            }

            Value = sbValue.ToString();
        }

        /// <summary>
        /// Inserts characters into the CharacterBag
        /// </summary>
        /// <param name="Characters">characters to insert</param>
        public void Insert(
            char[] characters)
        {
            StringBuilder sbValue = new StringBuilder(Value);

            foreach (char cItem in characters)
            {
                sbValue.Append(cItem);
            }

            Value = sbValue.ToString();
        }

        // characters to be excluded from paths:
        public static char[] acPathExclude = { '"', '*', '/', ':', '<', '>', '?', '\\', '|' };

        public static string GenCharRange(int startIndex, int endIndex)
        {
            // include last character in set:
            endIndex++;

            // calculate the size of the set:
            int size = (endIndex - startIndex);

            StringBuilder sb = new StringBuilder(size);

            for (int nItem = startIndex; nItem < endIndex; nItem++)
            {
                sb.Append((char)nItem);
            }

            return sb.ToString();
        }

        public static string GenAlphaChars()
        {
            string strOutput = GenCharRange((int)'a', (int)'z');

            strOutput += GenCharRange((int)'A', (int)'Z');

            return strOutput;
        }

        public static string GenAsciiChars()
        {
            // add the chars from <space> to <del> (exclusive):
            string strOutput = GenCharRange(0x20, 0x7E);

            // add the remaining chars:
            strOutput += GenCharRange(0x80, 0xFF);

            return strOutput;
        }

        public static string GenUnicodeChars()
        {
            // add the first round of chars:
            string strOutput = GenCharRange(0x0100, 0xD7FF);

            // NOTE: skipping over the following:
            // - The high surrogate character set (0xD800 to 0xDBFF) 
            // - The low surrogate character set (0xDC00 to 0xDFFF) 
            // charactersfrom these sets must be in high/low pairs to be valid,
            // so a new form of random character picking needs to be employed to make this work.   

            // add the second round of chars:
            strOutput += GenCharRange(0xE000, 0xFFFD);

            return strOutput;
        }
    }

    namespace CharacterBags
    {
        public class AsciiPrintable : CharacterBag
        {
            public AsciiPrintable()
                : base()
            {
                Value = GenAsciiChars();
            }
        }

        public class AsciiPrintablePath : AsciiPrintable
        {
            public AsciiPrintablePath()
                : base()
            {
                Remove(acPathExclude);
            }
        }

        public class UnicodePrintable : CharacterBag
        {
            public UnicodePrintable()
                : base()
            {
                Value = GenUnicodeChars();
            }
        }

        public class UnicodeHighSurrogate : CharacterBag
        {
            public UnicodeHighSurrogate()
                : base()
            {
                Value = GenCharRange(0xD800, 0xDBFF);
            }
        }

        public class UnicodeLowSurrogate : CharacterBag
        {
            public UnicodeLowSurrogate()
                : base()
            {
                Value = GenCharRange(0xDC00, 0xDFFF);
            }
        }

        public class AllPrintable : UnicodePrintable
        {
            public AllPrintable()
                : base()
            {
                Value += GenAsciiChars();
            }
        }

        public class AllPrintablePath : AllPrintable
        {
            public AllPrintablePath()
                : base()
            {
                Remove(acPathExclude);
            }
        }

        public class EnglishAlphabet : CharacterBag
        {
            public EnglishAlphabet()
                : base()
            {
                Value = GenAlphaChars();
            }
        }

        public class EnglishAlphaNumeric : EnglishAlphabet
        {
            public EnglishAlphaNumeric()
                : base()
            {
                Value += "0123456789";
            }
        }

        public class Octal : CharacterBag
        {
            public Octal()
                : base()
            {
                Value = "01234567";
            }
        }

        public class Decimal : Octal
        {
            public Decimal()
                : base()
            {
                Value += "89";
            }
        }

        public class Hexadecimal : Decimal
        {
            public Hexadecimal()
                : base()
            {
                Value += "ABCDEF";
            }
        }

        // the following were created from information at:
        // http://www.unicode.org/charts/

        public class ArmenianLigatures : CharacterBag
        {
            public ArmenianLigatures()
                : base()
            {
                CultureIdentifier = 0x002B;

                char[] acExclude = { 
                    (char)0xFB37, 
                    (char)0xFB3D, 
                    (char)0xFB3F, 
                    (char)0xFB42, 
                    (char)0xFB45 };

                Value = GenCharRange(0xFB00, 0xFB06);
                Value += GenCharRange(0xFB13, 0xFB17);
                Value += GenCharRange(0xFB1D, 0xFB4F);

                Remove(acExclude);
            }
        }

        public class ArmenianAlphabet : ArmenianLigatures
        {
            public ArmenianAlphabet()
                : base()
            {
                CultureIdentifier = 0x002B;

                char[] acExclude = { 
                    (char)0x0557, 
                    (char)0x0558, 
                    (char)0x0560, 
                    (char)0x0588 };

                Value += GenCharRange(0x0531, 0x058A);

                Remove(acExclude);
            }
        }

        public class ArabicAlphabet : CharacterBag
        {
            public ArabicAlphabet()
                : base()
            {
                CultureIdentifier = 0x0001;

                char[] acExclude = { 
                    (char)0x0604, 
                    (char)0x0605, 
                    (char)0x0606, 
                    (char)0x0607, 
                    (char)0x0608, 
                    (char)0x0609, 
                    (char)0x060A, 
                    (char)0x0616, 
                    (char)0x0617, 
                    (char)0x0618, 
                    (char)0x0619, 
                    (char)0x061A, 
                    (char)0x061C, 
                    (char)0x061D, 
                    (char)0x0620, 
                    (char)0x063B, 
                    (char)0x063C, 
                    (char)0x063D, 
                    (char)0x063E, 
                    (char)0x063F, 
                    (char)0x065F };

                Value = GenCharRange(0x0600, 0x06FF);

                Remove(acExclude);
            }
        }

        public class KoreanHangulSyllables : CharacterBag
        {
            public KoreanHangulSyllables()
                : base()
            {
                CultureIdentifier = 0x0412;

                Value = GenCharRange(0xAC00, 0xD7A3);
            }
        }
    }

    public class StringFuzzer
    {
        public enum FieldSizes
        {
            Guid = 38,
            MaxPath = 259,
            MaxInt16 = 0x7FFF,
            MaxUint16 = 0xFFFF
        };

        /// <summary>
        /// returns a string containing all of the possible character
        /// combinations possible using the bagArray parameter
        /// </summary>
        /// <param name="bagArray"></param>
        /// <returns></returns>
        public static String MultipleBagTest(
            CharacterBag bag )
        {
            StringBuilder sbOutput = new StringBuilder();
            
            if ( bag.Surrogate == null )
            {
                foreach ( char cItem in bag.Value.ToCharArray() )
                {
                    sbOutput.Append( cItem );
                }
            }
            else
            {
                foreach ( char cItem in bag.Value.ToCharArray() )
                {
                    foreach ( char csItem in bag.Surrogate.Value.ToCharArray() )
                    {
                        sbOutput.Append( cItem );
                        sbOutput.Append( csItem );
                    }
                }
            }

            return sbOutput.ToString();
        }

        /// <summary>
        /// Generates a fuzzed string
        /// </summary>
        /// <param name="size">size of the fuzzed string</param>
        /// <param name="bag">character bag to use</param>
        /// <returns>fuzzed string</returns>
        public static String Generate( 
            UInt32 size, 
            CharacterBag bag )
        {
            return Generate( size, bag.Value );
        } 

        /// <summary>
        /// Generates a fuzzed string
        /// </summary>
        /// <param name="size">size of the fuzzed string</param>
        /// <param name="bag">character bag to use</param>
        /// <param name="bag">overlay set to use</param>
        /// <returns>fuzzed string</returns>
        public static String Generate( 
            UInt32 size, 
            CharacterBag bag,
            OverlaySet overlaySet )
        {
            String strOutput = Generate( size, bag.Value );
            
            strOutput = overlaySet.Apply( strOutput );

            return strOutput;
        } 

        /// <summary>
        /// Generates a fuzzed string
        /// </summary>
        /// <param name="size">size of the fuzzed string</param>
        /// <param name="bagText">character bag string to use</param>
        /// <returns>fuzzed string</returns>
        public static String Generate( 
            UInt32 size, 
            string bagText ) 
        {
            StringBuilder sbOutput = new StringBuilder( (int)size );

            return RandomString( size, sbOutput, bagText );
        }

        /// <summary>
        /// Generates a fuzzed string
        /// </summary>
        /// <param name="size">size of the fuzzed string</param>
        /// <param name="bagText">character bag string to use</param>
        /// <param name="bag">overlay set to use</param>
        /// <returns>fuzzed string</returns>
        public static String Generate( 
            UInt32 size, 
            string bagText,
            OverlaySet overlaySet ) 
        {
            String strOutput = Generate( size, bagText );
            
            strOutput = overlaySet.Apply( strOutput );

            return strOutput;
        }


        /// <summary>
        /// generate a fuzzed string from multiple character bags: 
        /// </summary>
        /// <param name="size">size of the fuzzed string</param>
        /// <param name="standAloneBag">stand-alone character bag</param>
        /// <param name="bagArray">array of other character bags (and their optional surrogates)</param>
        /// <returns>fuzzed string</returns>
        public static String Generate( 
            UInt32 size, 
            CharacterBag standAloneBag,
            CharacterBag[] bagArray ) 
        {
            StringBuilder sbOutput = new StringBuilder( (int)size );

            return RandomMultiBagString( 
                size, sbOutput, standAloneBag, bagArray );
        }

        /// <summary>
        /// generate a fuzzed string from multiple character bags: 
        /// </summary>
        /// <param name="size">size of the fuzzed string</param>
        /// <param name="standAloneBag">stand-alone character bag</param>
        /// <param name="bagArray">array of other character bags (and their optional surrogates)</param>
        /// <param name="bag">overlay set to use</param>
        /// <returns></returns>
        public static String Generate( 
            UInt32 size, 
            CharacterBag standAloneBag,
            CharacterBag[] bagArray,
            OverlaySet overlaySet ) 
        {
            String strOutput = Generate( size, standAloneBag, bagArray );
            
            strOutput = overlaySet.Apply( strOutput );

            return strOutput;
        }

        private class Randomizer
        {
            public const uint PROV_RSA_FULL = 1;
            public const uint CRYPT_VERIFYCONTEXT = 0xf0000000;

            [DllImport("Advapi32.dll", CharSet = CharSet.Unicode)] 
                public static extern bool CryptAcquireContext(
                    ref IntPtr phProv, 
                    string pszContainer, 
                    string pszProvider,
                    uint dwProvType, 
                    uint dwFlags );

            [ DllImport( "Advapi32.dll" ) ] 
                public static extern bool CryptReleaseContext( 
                    IntPtr hProv, 
                    uint dwFlags );

            [ DllImport( "Advapi32.dll" ) ] 
                public static extern bool CryptGenRandom(
                    IntPtr hProv, 
                    int dwLen, 
                    byte[] pbBuffer );
                    
            private IntPtr hCryptProv = IntPtr.Zero;

            public Randomizer()
            {
                // get crypto provider handle:
                if ( !CryptAcquireContext(
                        ref hCryptProv, null, null, 
                        PROV_RSA_FULL, CRYPT_VERIFYCONTEXT ) )
                {
                    throw new SystemException( 
                        "CryptAcquireContext() failed" );
                }
            }
            
            public int RandomIndex(
                int nFieldSize )
            {
                UInt32 nIndex = 0; 
                byte[] abOctets = new byte[ 4 ];
            
                // generate a cryptographically random number:
                if ( !CryptGenRandom( hCryptProv, abOctets.Length, abOctets ) )
                {
                    throw new SystemException( 
                        "CryptGenRandom() failed" );
                }
                else
                {
                    // clear the sign bit of the MSB 
                    // (since string.Length is a signed int 
                    // and we do not want to generate negative indices):
                    abOctets[ 3 ] &= 0x7F;
                                                
                    nIndex =  
                        ( (UInt32)abOctets[ 0 ]         ) | 
                        ( (UInt32)abOctets[ 1 ] << 0x08 ) | 
                        ( (UInt32)abOctets[ 2 ] << 0x10 ) | 
                        ( (UInt32)abOctets[ 3 ] << 0x18 );
                }
                
                // apply modular to restrict nIndex within range:
                return (int)( nIndex % (UInt32)nFieldSize );
            }    
            
            ~Randomizer()
            {
                // release the crypto provider handle:
                if ( hCryptProv != IntPtr.Zero )
                {
                    CryptReleaseContext( hCryptProv, 0 );
                }
            }                    
                    
        }

        private static String RandomString(
            UInt32 nLength, 
            StringBuilder sbOutput, 
            string bagText )
        {
            if ( bagText.Length <= 0 )
            {
                throw new SystemException( 
                    "ERROR: Character bag is empty" );
            }
            
            Randomizer randomizer = new Randomizer();

            for ( int nIndex = 0; nIndex < nLength; nIndex++ )
            {
                // add random character to string:
                sbOutput.Append( 
                    bagText[ randomizer.RandomIndex( 
                        bagText.Length ) ] );
            }
            
            return sbOutput.ToString();
        }
        
        private static String RandomMultiBagString(
            UInt32 nLength, 
            StringBuilder sbOutput, 
            CharacterBag standAloneBag,
            CharacterBag[] bagArray )
        {
            if ( standAloneBag.Value.Length <= 0 )
            {
                throw new SystemException( 
                    "ERROR: StandAlone CharacterBag is empty" );
            }

            if ( standAloneBag.Surrogate != null )
            {
                throw new SystemException( 
                    "ERROR: Stand-alone CharacterBag must not have a surrogate CharacterBag" );
            }

            foreach ( CharacterBag bag in bagArray )
            {
                if ( bag.Surrogate != null )
                {
                    if ( bag.Surrogate.Value.Length <= 0 )
                    {
                        throw new SystemException( 
                            "ERROR: Character bag is empty" );
                    }
                }

                if ( bag.Value.Length <= 0 )
                {
                    throw new SystemException( 
                        "ERROR: Character bag is empty" );
                }
            }

            Randomizer randomizer = new Randomizer();

            for ( int nIndex = 0; nIndex < nLength; nIndex++ )
            {
                // choose between the standalone or array of character bags,
                // only if there is room for at least one surrogate character in the output:
                if ( ( ( randomizer.RandomIndex( 2 ) ) == 0 ) && ( ( nIndex + 1 ) < nLength ) )
                {
                    // choose one randomly from the array:
                    CharacterBag bag = 
                        bagArray[ 
                            randomizer.RandomIndex( 
                                bagArray.Length ) ];
                    
                    // append a random character from the bag:
                    sbOutput.Append( 
                        bag.Value[ randomizer.RandomIndex( 
                            bag.Value.Length ) ] );
                            
                    // see if there is a surrogate:
                    if ( bag.Surrogate != null )
                    {
                        // advance the index:
                        nIndex++; 

                        // append a random character from the surrogate bag:
                        sbOutput.Append( 
                            bag.Surrogate.Value[ randomizer.RandomIndex( 
                                bag.Surrogate.Value.Length ) ] );
                    }
                }
                else
                {
                    // append a random character from the standalone bag:
                    sbOutput.Append( 
                        standAloneBag.Value[ randomizer.RandomIndex( 
                            standAloneBag.Value.Length ) ] );
                }
            }
            
            return sbOutput.ToString();
        }
    }
    public class OverlaySet
    {
        private class OverlayCharacter
        {
            public int m_nIndex;
            public char m_cValue;

            public OverlayCharacter(
                int index,
                char value)
            {
                m_nIndex = index;
                m_cValue = value;
            }
        }

        // overlay characters:
        private LinkedList<OverlayCharacter> OverlayCharacters = new LinkedList<OverlayCharacter>();

        /// <summary>
        /// Constructs an OverlaySet
        /// </summary>
        public OverlaySet()
        {
        }

        /// <summary>
        /// Adds OverlayCharacters to the OverlaySet
        /// </summary>
        /// <param name="index">The character index</param>
        /// <param name="value">The character value</param>
        public void Add(
            int index,
            char value)
        {
            OverlayCharacter ocNew = new OverlayCharacter(index, value);
            OverlayCharacters.AddLast(ocNew);
        }

        /// <summary>
        /// Applies the overlay set to the given string.
        /// </summary>
        /// <param name="input">string to be modified</param>
        /// <returns>String</returns>
        public String Apply(
            String input)
        {
            foreach (OverlayCharacter ocItem in OverlayCharacters)
            {
                int index = ocItem.m_nIndex;

                if (index < 0)
                {
                    // translate negative index to distance from end of string:
                    index = input.Length + index;
                }

                if ((index >= 0) && (index < input.Length))
                {
                    // remove the character:
                    input = input.Remove(index, 1);

                    // insert its replacement:
                    input = input.Insert(index, ocItem.m_cValue.ToString());
                }
            }

            return input;
        }
    }

    namespace OverlaySets
    {
        public class Guid : OverlaySet
        {
            public Guid()
                : base()
            {
                Add(0, '{');
                Add(9, '-');
                Add(14, '-');
                Add(19, '-');
                Add(24, '-');

                // add to the end of the fuzzed string:
                Add(-1, '}');
            }
        }

        public class PathRoot : OverlaySet
        {
            public PathRoot()
                : base()
            {
                Add(1, ':');
                Add(2, '\\');
            }
        }

        public class UncRoot : OverlaySet
        {
            public UncRoot()
                : base()
            {
                Add(0, '\\');
                Add(1, '\\');
                Add(10, '\\');
            }
        }

        public class UrlDotCom : OverlaySet
        {
            public UrlDotCom()
                : base()
            {
                Add(0, 'h');
                Add(1, 't');
                Add(2, 't');
                Add(3, 'p');
                Add(4, ':');
                Add(5, '/');
                Add(6, '/');

                // add to the end of the fuzzed string:
                Add(-4, '.');
                Add(-3, 'c');
                Add(-2, 'o');
                Add(-1, 'm');
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\StressAvatar.cs ===
using System;
using System.Threading;
using System.Collections;
using System.Globalization;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Storage;
using xonline.common.config;
using XblUser = live.common.XblUser;
using System.Net;
using System.IO;

namespace XStoreTest
{
    [StressInstantiate]
    public class StressAvatarWrite : TestBase
    {
        override protected void Execute()
        {
            bool fail = false;
            string writeUrl;
            uint titleID = 0;
            // get file off of queue and write...
            if (XStoreTest.syncdAvatarFileQ.Count >= XStoreTest.MaxQueueLength)
            {
                try
                {
                    QueueUrlObject tempUrlObject = (QueueUrlObject)XStoreTest.syncdAvatarFileQ.Dequeue();
                    writeUrl = tempUrlObject.Url;
                    titleID = tempUrlObject.TitleId;
                }
                catch (InvalidOperationException)
                {
                    // if we fail to read, generate a new one to play with
                    uint randomIndex = (uint)XStoreTest.randomInstance.Next();
                    writeUrl = String.Format("//avatar/u:{0}{1}/stress.png", XStoreTest.MachineID, XStoreTest.GetNextFakeXUID());
                }
            }
            else
            {
                // if the queue is not full, generate a new one to play with
                uint randomIndex = (uint)XStoreTest.randomInstance.Next();
                writeUrl = String.Format("//avatar/u:{0}{1}/stress.png", XStoreTest.MachineID, XStoreTest.GetNextFakeXUID());
            }

            XRLWriteFile writeReq = new XRLWriteFile("ServiceAddr", writeUrl, XStoreTest.AvatarFile, true);
            byte[] rand = new byte[(XStoreTest.AvatarFile < 8) ? XStoreTest.AvatarFile : 8];
            XStoreTest.rng.GetBytes(rand);
            rand.CopyTo(writeReq.blobData, 0);
            if (writeReq.Execute())
            {
                // Put the file at the end of the queue.  Recycling is good. 
                if (XStoreTest.syncdAvatarFileQ.Count < XStoreTest.MaxQueueLength)
                {
                    XStoreTest.syncdAvatarFileQ.Enqueue(new QueueUrlObject(writeReq.uiTitleId, writeUrl));
                }
            }
            else
            {
                XStoreTest.Safetw.WriteLine(DateTime.Now.ToString() + ":WriteFile request failed:" + writeUrl + " - 0x" + writeReq.XErr.ToString("x"));
                fail = true;
            }

            if (!fail)
                ResultCode = TEST_RESULTS.PASSED;

        }
    }

    [StressInstantiate]
    public class StressAvatarRead : TestBase
    {
        override protected void Execute()
        {
            bool fail = false;
            string readUrl;
            uint titleID = 0;
            // get file off of queue and read...
            try
            {
                QueueUrlObject tempUrlObject = (QueueUrlObject)XStoreTest.syncdAvatarFileQ.Dequeue();
                readUrl = tempUrlObject.Url;
                titleID = tempUrlObject.TitleId;
            }
            catch  // if we fail to read, generate a new one to play with
            {
                uint randomIndex = (uint)XStoreTest.randomInstance.Next();
                readUrl = String.Format("//avatar/u:{0}{1}/stress.png", XStoreTest.MachineID, XStoreTest.GetNextFakeXUID());

                XRLWriteFile writeReq = new XRLWriteFile("ServiceAddr", readUrl, XStoreTest.AvatarFile, true);
                byte[] rand = new byte[(XStoreTest.AvatarFile < 8) ? XStoreTest.AvatarFile : 8];
                XStoreTest.rng.GetBytes(rand);
                rand.CopyTo(writeReq.blobData, 0);
                writeReq.Execute();
            }

            XRLReadFileResponse readResp;
            XRLReadFile readReq = new XRLReadFile(readUrl);

            if (!readReq.Execute(true, Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out readResp))
            {
                XStoreTest.Safetw.WriteLine(DateTime.Now.ToString() + ":ReadFile request failed:" + readUrl + " - 0x" + readReq.XErr.ToString("x"));
                fail = true;
            }

            // Put the file at the end of the queue immediately.  Recycling is good. 
            if (XStoreTest.syncdAvatarFileQ.Count < XStoreTest.MaxQueueLength)
            {
                XStoreTest.syncdAvatarFileQ.Enqueue(new QueueUrlObject(titleID, readUrl));
            }

            if (!fail)
                ResultCode = TEST_RESULTS.PASSED;

        }
    }

    [StressInstantiate]
    public class StressAvatarGateway : TestBase
    {
        override protected void Execute()
        {
            string readUrl = "";

            uint TitleID = 0xfffe07d1; //4294838225
            string hexTitleID = TitleID.ToString("x");

            string storageFileName = "tile/0/11069";
            ResultCode = ExecuteTestCase(hexTitleID, storageFileName, out readUrl);
        }

        public TEST_RESULTS ExecuteTestCase(string hexTitleID, string storageFileName, out string readURL)
        {
            TEST_RESULTS result = TEST_RESULTS.FAILED;
            readURL = "";

            string domain = "/global";
            string qualifier = "/t:" + hexTitleID;

            string writeXrl = "/" + domain + qualifier + "/" + storageFileName;

            readURL = AvatarHelper.GetReadURLGlobal(hexTitleID, ("/" + storageFileName));
            //Global.RO.Info(string.Format(" URL to read from - \n {0}  ", readURL));

            if (CheckFileExists(readURL))
            {
                result = TEST_RESULTS.PASSED;
            }
            return result;
        }

        private bool CheckFileExists(string readUrl)
        {
            WebRequest request = null;
            WebResponse response = null;

            System.Net.Cache.RequestCachePolicy policy = new System.Net.Cache.RequestCachePolicy(System.Net.Cache.RequestCacheLevel.BypassCache);
            request = WebRequest.Create(readUrl);
            request.CachePolicy = policy;

            response = request.GetResponse();
            Stream rcvStrm = response.GetResponseStream();

            if (!response.ContentType.Contains("png"))
            {
                Global.RO.Fatal("Content type incorrect (should be image/png): {0}", response.ContentType);
                return false;
            }

            rcvStrm.Close();
            request = null;
            response.Close();
            response = null;
            return true;
        }

    }

    [StressInstantiate]
    public class StressAvatarGatewayBad : TestBase
    {
        override protected void Execute()
        {
            string readURL;
            //string GamerTag = DateTime.Now.ToString("tyyyyMMddhhmmssfffffff");
            string GamerTag = "BUgi0raaqaaaeqa";
            string storageFileName = "avatar-body.png";
            TEST_RESULTS result = TEST_RESULTS.FAILED;
            readURL = AvatarHelper.GetReadURLAvatar(GamerTag, ("/" + storageFileName));
            //Global.RO.Info(readURL);
            if (CheckFileExists(readURL))
            {
                result = TEST_RESULTS.PASSED;
            }
            ResultCode = result;
        }
        private bool CheckFileExists(string readUrl)
        {
            WebRequest request = null;
            WebResponse response = null;

            System.Net.Cache.RequestCachePolicy policy = new System.Net.Cache.RequestCachePolicy(System.Net.Cache.RequestCacheLevel.BypassCache);
            request = WebRequest.Create(readUrl);
            request.CachePolicy = policy;

            response = request.GetResponse();
            Stream rcvStrm = response.GetResponseStream();

            if (!response.ContentType.Contains("png"))
            {
                Global.RO.Fatal("Content type incorrect (should be image/png): {0}", response.ContentType);
                return false;
            }

            rcvStrm.Close();
            request = null;
            response.Close();
            response = null;

            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\FuncXeStatsWF.cs ===
using System;
using System.Globalization;
using System.Text;
using System.Net;
using System.IO;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Storage;
using ServerTestFramework.LiveService.Signature;
using ServerTestFramework.Utilities;
using xonline.common.config;

namespace XStoreTest
{
	internal abstract class XeStatsWFTestBase : TestBase
	{
		//    send WriteFile request first; then send readfile;verifies the response
		protected bool WriteFileSendAndVerify(XRLWriteFile WriteFileReq)
		{
			bool fPassed=WriteFileReq.Execute();
			if (!fPassed)
			{
				Global.RO.Warn("Failed to send WriteFile request ");
				return false;
			}

			XRLReadFileResponse    ReadFileResp;
			XRLReadFile            ReadFileReq = new XRLReadFile(WriteFileReq.accessToken.baseAT.pathName);
			ReadFileReq.Slot.titleId = ReadFileReq.uiTitleId = WriteFileReq.uiTitleId;
			ReadFileReq.Slot.titleVersion = ReadFileReq.uiTitleVersion = WriteFileReq.uiTitleVersion;
			if (ReadFileReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out ReadFileResp))
			{
				if ((!ReadFileResp.Compare(WriteFileReq)) || (!WriteFileReq.Verify()))
				{
					Global.RO.Warn("WriteFile request is not set correctly in the db");
					return false;
				}
			}
			else
			{
				Global.RO.Warn("Failed to send ReadFile request");
				return false;
			}
			return true;
		}
	}
	internal abstract class XeStatsWFNegTestBase : TestBase
	{
		//    send WriteFile request first; then send readfile;verifies the response
		protected bool WriteFileTestNegative(XRLWriteFile WriteFileReq,uint XErr)
		{
			if (WriteFileReq.Execute())
			{
				Global.RO.Warn("Negative WriteFile request succeed unexpectedly");
				return false;
			}
			if(WriteFileReq.XErr != XErr)
			{
				Global.RO.Warn("Wrong error code returned " + Global.XErrToString(WriteFileReq.XErr));
				return false;
			}
			// now we need to check the file is not written to the DB
			XRLReadFileResponse    ReadFileResp;
			XRLReadFile            ReadFileReq = new XRLReadFile(WriteFileReq.accessToken.baseAT.pathName);
			ReadFileReq.Slot.titleId = ReadFileReq.uiTitleId = WriteFileReq.uiTitleId;
			ReadFileReq.Slot.titleVersion = ReadFileReq.uiTitleVersion = WriteFileReq.uiTitleVersion;
			if (!ReadFileReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out ReadFileResp))
			{
				if(ReadFileResp != null)
				{
					Global.RO.Warn("File is being written to DB unexpectedly");
					return false;
				}
			}
			else
			{
				Global.RO.Warn("ReadFile request succeed with S_OK unexpectedly");
				return false;
			}
			return true;
		}
	}
    [TestGroup, Owner("JKonkle"), TestFrequency("Regression"), TestCasePriority(1)]
	public class FuncXeStatsWF : TestNode
	{
		/***********************************************************************
		 * Wire Protocol Testing
		 * *********************************************************************/
		[TestCase, Description("Write a file with all valid parameters including attributes")]
			class PNormalCase : XeStatsWFTestBase
		{
			override protected void Execute()
			{
				uint    randomTitleID = (uint)new Random().Next();
				string    sTitleID = randomTitleID.ToString("x");
				string url= "//xestats."+sTitleID+"/u:6666/"+sTitleID+"/"+ new Random().Next().ToString("x");

				XRLWriteFile    req = new XRLWriteFile("Owner",url);
				req.attributes = new byte[100];
				new Random().NextBytes(req.attributes);
				req.attributesLen = (ushort)req.attributes.Length;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write a 1k file")]
			class PSmallFileSize : XeStatsWFTestBase
		{
			override protected void Execute()
			{
				uint    randomTitleID = (uint)new Random().Next();
				string    sTitleID = randomTitleID.ToString("x");
				string url= "//xestats."+sTitleID+"/u:6666/"+sTitleID+"/"+ new Random().Next().ToString("x");
				XRLWriteFile    req = new XRLWriteFile("Owner",url);
				req.blobData = new byte[1024];
				new Random().NextBytes(req.blobData);
				req.blobDataLen = req.uiBlobSizeCompressed = (uint)req.blobData.Length;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write a 100k file")]
			class PMediumFileSize : XeStatsWFTestBase
		{
			override protected void Execute()
			{
				uint    randomTitleID = (uint)new Random().Next();
				string    sTitleID = randomTitleID.ToString("x");
				string url= "//xestats."+sTitleID+"/u:6666/"+sTitleID+"/"+ new Random().Next().ToString("x");

				XRLWriteFile    req = new XRLWriteFile("Owner",url);
				req.blobData = new byte[1024*100];
				new Random().NextBytes(req.blobData);
				req.blobDataLen = req.uiBlobSizeCompressed = (uint)req.blobData.Length;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write a large file size: 1MB")]
			class PLargeFileSize : XeStatsWFTestBase
		{
			override protected void Execute()
			{
				uint    randomTitleID = (uint)new Random().Next();
				string    sTitleID = randomTitleID.ToString("x");
				string url= "//xestats."+sTitleID+"/u:6666/"+sTitleID+"/"+ new Random().Next().ToString("x");

				XRLWriteFile    req = new XRLWriteFile("Owner",url);
				req.blobData = new byte[1*1024*1024];
				new Random().NextBytes(req.blobData);
				req.blobDataLen = req.uiBlobSizeCompressed = (uint)req.blobData.Length;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write a file with userPUID set to max value")]
			class PMaxUserPUIDTitleID : XeStatsWFTestBase
		{
			override protected void Execute()
			{
				string url= "//xestats.ffffffff/u:ffffffffffffffff/ffffffff/" + new Random().Next().ToString("x");
				XRLWriteFile    req = new XRLWriteFile("Owner",url);

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Write a file with userPUID set to min value")]
			class PMinUserPUIDTitleID : XeStatsWFTestBase
		{
			override protected void Execute()
			{
				string url= "//xestats.1/u:1/1/" + new Random().Next().ToString("x");
				XRLWriteFile    req = new XRLWriteFile("Owner",url);

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		// npdb: t_storage_domain: 11mb
		[TestCase, Description("Write a max size file")]
			class PBlobDataMaxSize : XeStatsWFTestBase
		{
			override protected void Execute()
			{
				uint    randomTitleID = (uint)new Random().Next();
				string    sTitleID = randomTitleID.ToString("x");
				string url= "//xestats."+sTitleID+"/u:6666/"+sTitleID+"/"+ new Random().Next().ToString("x");

				XRLWriteFile    req = new XRLWriteFile("Owner",url);
				req.blobData = new byte[11*1024*1024];
				new Random().NextBytes(req.blobData);
				req.blobDataLen = req.uiBlobSizeCompressed = (uint)req.blobData.Length;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass attributes with 256 byte")]
			class PMaxAttributeSize : XeStatsWFTestBase
		{
			override protected void Execute()
			{
				uint    randomTitleID = (uint)new Random().Next();
				string    sTitleID = randomTitleID.ToString("x");
				string url= "//xestats."+sTitleID+"/u:6666/"+sTitleID+"/"+ new Random().Next().ToString("x");

				XRLWriteFile    req = new XRLWriteFile("Owner",url);
				uint attLen = Constants.maxSizeAttributes;
				req.attributes = new byte[attLen];
				new Random().NextBytes(req.attributes);
				req.attributesLen = (ushort)req.attributes.Length;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass 0 attributeslen")]
			class PMinAttributeSize : XeStatsWFTestBase
		{
			override protected void Execute()
			{
				uint    randomTitleID = (uint)new Random().Next();
				string    sTitleID = randomTitleID.ToString("x");
				string url= "//xestats."+sTitleID+"/u:6666/"+sTitleID+"/"+ new Random().Next().ToString("x");

				XRLWriteFile    req = new XRLWriteFile("Owner",url);
				req.attributes = null;
				req.attributesLen = 0;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass 0 fileExpirationTime in the accessToken")]
			class PAccessTokenZeroFileExpTime : XeStatsWFTestBase
		{
			override protected void Execute()
			{
				uint    randomTitleID = (uint)new Random().Next();
				string    sTitleID = randomTitleID.ToString("x");
				string url= "//xestats."+sTitleID+"/u:6666/"+sTitleID+"/"+ new Random().Next().ToString("x");

				XRLWriteFile    req = new XRLWriteFile("Owner",url);
				req.accessToken.writeAT.fileExpirationDate = 0;
				req.accessToken.writeAT.tokenExpirationDate = System.DateTime.UtcNow.AddHours(1).ToFileTimeUtc();

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass 0 AccessTokenExpirationTime in the accessToken")]
			class PAccessTokenZeroATExpTime : XeStatsWFTestBase
		{
			override protected void Execute()
			{
				uint    randomTitleID = (uint)new Random().Next();
				string    sTitleID = randomTitleID.ToString("x");
				string url= "//xestats."+sTitleID+"/u:6666/"+sTitleID+"/"+ new Random().Next().ToString("x");

				XRLWriteFile    req = new XRLWriteFile("Owner",url);
				req.accessToken.writeAT.tokenExpirationDate = 0;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("pass 0 for uncompressed blob size and null blobdata")]
			class PEmptyFile : XeStatsWFTestBase
		{
			override protected void Execute()
			{
				uint    randomTitleID = (uint)new Random().Next();
				string    sTitleID = randomTitleID.ToString("x");
				string url= "//xestats."+sTitleID+"/u:6666/"+sTitleID+"/"+ new Random().Next().ToString("x");

				XRLWriteFile    req = new XRLWriteFile("Owner",url);
				req.blobDataLen = req.uiBlobSizeCompressed = 0;
				req.blobData = null;

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("try to write a file that is bigger than max allowed"), TestCasePriority(2)]
			class NBiggerThanMaxFile : XeStatsWFNegTestBase
		{
			override protected void Execute()
			{
				uint    randomTitleID = (uint)new Random().Next();
				string    sTitleID = randomTitleID.ToString("x");
				string url= "//xestats."+sTitleID+"/u:6666/"+sTitleID+"/"+ new Random().Next().ToString("x");

				XRLWriteFile    req = new XRLWriteFile("Owner",url);
				req.blobData = new byte[11*1024*1024+1];
				new Random().NextBytes(req.blobData);
				req.blobDataLen = req.uiBlobSizeCompressed = (uint)req.blobData.Length;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_FILE_IS_TOO_BIG))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass non-existent compression type"), TestCasePriority(2)]
			class NInvalidCompressionType : XeStatsWFNegTestBase
		{
			override protected void Execute()
			{
				uint    randomTitleID = (uint)new Random().Next();
				string    sTitleID = randomTitleID.ToString("x");
				string url= "//xestats."+sTitleID+"/u:6666/"+sTitleID+"/"+ new Random().Next().ToString("x");

				XRLWriteFile    req = new XRLWriteFile("Owner",url);
				req.bCompressionType = (byte)Constants.CompressionType.Invalid;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass non-existent content type"), TestCasePriority(2)]
			class NInvalidContentType : XeStatsWFNegTestBase
		{
			override protected void Execute()
			{
				uint    randomTitleID = (uint)new Random().Next();
				string    sTitleID = randomTitleID.ToString("x");
				string url= "//xestats."+sTitleID+"/u:6666/"+sTitleID+"/"+ new Random().Next().ToString("x");

				XRLWriteFile    req = new XRLWriteFile("Owner",url);
				req.uiContentType = (uint)Constants.ContentType.Invalid;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass NULL for blob hash"), TestCasePriority(2)]
			class NNullBlobHash : XeStatsWFNegTestBase
		{
			override protected void Execute()
			{
				uint    randomTitleID = (uint)new Random().Next();
				string    sTitleID = randomTitleID.ToString("x");
				string url= "//xestats."+sTitleID+"/u:6666/"+sTitleID+"/"+ new Random().Next().ToString("x");

				XRLWriteFile    req = new XRLWriteFile("Owner",url);
				req.ManualArraySize = true;
				req.blobHash = null;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_FILE_IS_TOO_BIG))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass <20 byte for blob hash"), TestCasePriority(2)]
			class NInvalidBlobHash1 : XeStatsWFNegTestBase
		{
			override protected void Execute()
			{
				uint    randomTitleID = (uint)new Random().Next();
				string    sTitleID = randomTitleID.ToString("x");
				string url= "//xestats."+sTitleID+"/u:6666/"+sTitleID+"/"+ new Random().Next().ToString("x");

				XRLWriteFile    req = new XRLWriteFile("Owner",url);
				req.ManualArraySize = true;
				req.blobHash = new byte[Constants.sizeHash - 1];
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_FILE_IS_TOO_BIG))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass >20 byte for blob hash"), TestCasePriority(2)]
			class NInvalidBlobHash2 : XeStatsWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//xestats.125626/u:9999/125626/" + new Random().Next().ToString("x");
				XRLWriteFile    req = new XRLWriteFile("Owner",url);
				req.ManualArraySize = true;
				req.blobHash = new byte[Constants.sizeHash + 1];
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("uncompressed size is smaller than compressed size"), TestCasePriority(2)]
			class NWrongCompressedSize : XeStatsWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//xestats.125626/u:9999/125626/" + new Random().Next().ToString("x");
				XRLWriteFile    req = new XRLWriteFile("Owner",url);
				req.uiBlobSizeCompressed = req.blobDataLen + 1;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass non-null for Attributes, but AttribLen is zero"), TestCasePriority(2)]
			class NMismatchedAttributes : XeStatsWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//xestats.125626/u:9999/125626/" + new Random().Next().ToString("x");
				XRLWriteFile    req = new XRLWriteFile("Owner",url);
				req.ManualArraySize = true;
				req.attributesLen = 0;
				req.attributes = new byte[16];
				for(int i = 0; i < 16; i++)
					req.attributes[i] = (byte)i;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("Attributes size is greater than the actual size"), TestCasePriority(2)]
			class NTruncateAttributes : XeStatsWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//xestats.125626/u:9999/" + new Random().Next().ToString("x");
				XRLWriteFile    req = new XRLWriteFile("Owner",url);
				req.ManualArraySize = true;
				req.attributesLen +=1;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("Attributes size is smaller than the actual size"), TestCasePriority(2)]
			class NOverflowAttributes1 : XeStatsWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//xestats.125626/u:9999/125626/" + new Random().Next().ToString("x");
				XRLWriteFile    req = new XRLWriteFile("Owner",url);
				req.ManualArraySize = true;
				req.attributes = new Byte[16];
				req.attributesLen = 15;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("Attributes is null but attribLen is nonzero"), TestCasePriority(2)]
			class NOverflowAttributes2 : XeStatsWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//xestats.125626/u:9999/125626/" + new Random().Next().ToString("x");
				XRLWriteFile    req = new XRLWriteFile("Owner",url);
				req.ManualArraySize = true;
				req.attributes = null;
				req.attributesLen = 16;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("Attributes is null but attribLen is greater than maxallowed(256)"), TestCasePriority(2)]
			class NOverflowAttributes3 : XeStatsWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//xestats.125626/u:9999/125626/" + new Random().Next().ToString("x");
				XRLWriteFile    req = new XRLWriteFile("Owner",url);
				req.ManualArraySize = true;
				req.attributes = null;
				req.attributesLen = 257;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("Attributes is larger than max allowed256bytes"), TestCasePriority(2)]
			class NOverflowAttributes4 : XeStatsWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//xestats.125626/u:9999/125626/" + new Random().Next().ToString("x");
				XRLWriteFile    req = new XRLWriteFile("Owner",url);
				ushort            attribLen = Constants.maxSizeAttributes + 1;
				req.attributes = new Byte[attribLen];
				req.attributesLen = attribLen;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass special attributeLen = 0xffff"), TestCasePriority(2)]
			class NOverflowAttributes5 : XeStatsWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//xestats.125626/u:9999/125626/" + new Random().Next().ToString("x");
				XRLWriteFile    req = new XRLWriteFile("Owner",url);
				req.attributes = new Byte[0xffff];
				req.attributesLen = 0xffff;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass null for AccessToken"), TestCasePriority(2)]
			class NNullAccessToken : XeStatsWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//xestats.125626/u:9999/125626/" + new Random().Next().ToString("x");
				XRLWriteFile    WriteFileReq = new XRLWriteFile("Owner",url);
				WriteFileReq.ManualArraySize = true;
				WriteFileReq.accessToken = null;
				if (!WriteFileReq.Execute())
				{
					if((WriteFileReq.XErr != HResult.XONLINE_E_STORAGE_INVALID_REQUEST)&&
						(WriteFileReq.XErr != HResult.XONLINE_E_SERVER_ERROR))
						Global.RO.Warn("Wrong error code returned " + Global.XErrToString(WriteFileReq.XErr));
					else
						ResultCode=TEST_RESULTS.PASSED;
				}
				else
					Global.RO.Warn("Negative WriteFile request succeed unexpectedly");
			}
		}
        [TestCase, Description("pass null for Blob data, but blobLen is non-zero"), TestCasePriority(2)]
			class NNullBlobData : XeStatsWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//xestats.125626/u:9999/125626/" + new Random().Next().ToString("x");
				XRLWriteFile    req = new XRLWriteFile("Owner",url);
				req.ManualArraySize = true;
				req.blobData = null;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass 0 for compressed blob size, but non-null blobdata"), TestCasePriority(2)]
			class NEmptyCompressedFile : XeStatsWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//xestats.125626/u:9999/125626/" + new Random().Next().ToString("x");
				XRLWriteFile    req = new XRLWriteFile("Owner",url);
				req.uiBlobSizeCompressed = 0;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("uncompressed blob size is greater than the actual file size"), TestCasePriority(2)]
			class NTruncateFile : XeStatsWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//xestats.125626/u:9999/125626/" + new Random().Next().ToString("x");
				XRLWriteFile    req = new XRLWriteFile("Owner",url);
				req.ManualArraySize = true;
				req.blobDataLen += 1;
				req.uiBlobSizeCompressed +=1;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("uncompressed blob size is smaller than the actual file size"), TestCasePriority(2)]
			class NOverflowFile : XeStatsWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//xestats.125626/u:9999/125626/" + new Random().Next().ToString("x");
				XRLWriteFile    req = new XRLWriteFile("Owner",url);
				req.ManualArraySize = true;
				req.blobDataLen -= 1;
				req.uiBlobSizeCompressed -=1;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("Expiration date is before the current time"), TestCasePriority(2)]
			class NAccessTokenInvalidExpTime1 : XeStatsWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//xestats.125626/u:9999/125626/" + new Random().Next().ToString("x");
				XRLWriteFile    req = new XRLWriteFile("Owner",url);
				req.accessToken.writeAT.fileExpirationDate = System.DateTime.UtcNow.AddDays(-1).ToFileTimeUtc();

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass an access Token that is greater than 255+baseAT"), TestCasePriority(2)]
			class NAccessTokenOverflowAT : XeStatsWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//xestats.125626/u:9999/125626/" + new Random().Next().ToString("x");
				StringBuilder    pathName = new StringBuilder(url);
				int        i = 0, numCharToAdd = 256 - url.Length;
				while(i < numCharToAdd)
				{
					pathName.Append('a');
					i++;
				}
				XRLWriteFile    req = new XRLWriteFile("Owner",pathName.ToString());

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("Access Token version is invalid"), TestCasePriority(2)]
			class NAccessTokenInvalidTokenVersion : XeStatsWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//xestats.125626/u:9999/125626/" + new Random().Next().ToString("x");
				XRLWriteFile    req = new XRLWriteFile("Owner",url);
				req.accessToken.baseAT.version = Constants.accessTokenVersion + 1;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("Operation in AT is non-write"), TestCasePriority(2)]
			class NAccessTokenMismatchedOperation : XeStatsWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//xestats.125626/u:9999/125626/" + new Random().Next().ToString("x");
				XRLWriteFile    req = new XRLWriteFile("Owner",url);
				req.accessToken.baseAT.operation = (ushort)Constants.Operation.FileRead;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		//bug 33842
		[TestCase, Description("ServiceID in AT is not zero for XeStats")]
			class PAccessTokenNonZeroServiceID : XeStatsWFTestBase
		{
			override protected void Execute()
			{
				string url= "//xestats.125626/u:9999/125626/" + new Random().Next().ToString("x");
				XRLWriteFile    req = new XRLWriteFile("Owner",url);
				req.accessToken.baseAT.serviceId = (uint)XOService.Storage;

				if(this.WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		// This will be caught by xrlscan.ini: needs to double check
        [TestCase, Description("the actual file size is greater than the dwMaxFileSize in AT"), TestCasePriority(2)]
			class NAccessTokenOverflowFileData1 : TestBase
		{
			override protected void Execute()
			{
				string url= "//xestats.125626/u:9999/125626/" + new Random().Next().ToString("x");
				XRLWriteFile    req = new XRLWriteFile("Owner",url);
				uint            maxFileSize = req.accessToken.writeAT.maxFileSize;
				req.blobData = new byte[maxFileSize + 1];
				for (int i = 0; i < maxFileSize + 1; i++)
					req.blobData[i] = (byte)i;
				req.blobDataLen = maxFileSize + 1;
				req.uiBlobSizeCompressed = maxFileSize + 1;

				// 404 returned back to client
				if(!req.Execute())
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		// This will be caught by xrlscan.ini
        [TestCase, Description("actual file size bigger than maxFileSize, but compressedSizeLen is smaller"), TestCasePriority(2)]
			class NAccessTokenOverflowFileData2 : TestBase
		{
			override protected void Execute()
			{
				string url= "//xestats.125626/u:9999/125626/" + new Random().Next().ToString("x");
				XRLWriteFile    req = new XRLWriteFile("Owner",url);
				uint            maxFileSize = req.accessToken.writeAT.maxFileSize;
				req.blobData = new byte[maxFileSize + 1];
				for (int i = 0; i < maxFileSize + 1; i++)
					req.blobData[i] = (byte)i;
				req.blobDataLen = maxFileSize + 1;
				//    req.uiBlobSizeCompressed = maxFileSize + 1;

				// 404 returned back to client
				if(!req.Execute())
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the pathnameLen is greater than the actual size"), TestCasePriority(2)]
			class NAccessTokenTruncatePathname : XeStatsWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//xestats.125626/u:9999/125626/" + new Random().Next().ToString("x");
				XRLWriteFile    req = new XRLWriteFile("Owner",url);
				req.accessToken.baseAT.ManualArraySize = true;
				req.accessToken.baseAT.pathNameLen += 1;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED) ||
					WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the pathnameLen is less than the actual size"), TestCasePriority(2)]
			class NAccessTokenOverflowPathname : XeStatsWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//xestats.125626/u:9999/125626/" + new Random().Next().ToString("x");
				XRLWriteFile    req = new XRLWriteFile("Owner",url);
				req.accessToken.baseAT.ManualArraySize = true;
				req.accessToken.baseAT.pathNameLen -= 1;
				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the flags in AT is non-zero"), TestCasePriority(2)]
			class NAccessTokenInvalidFlags : XeStatsWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//xestats.125626/u:9999/125626/" + new Random().Next().ToString("x");
				XRLWriteFile    req = new XRLWriteFile("Owner",url);
				req.accessToken.baseAT.flags = 1;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		
		/***********************************************************************
		* Pathname Testing
		* *********************************************************************/
		[TestCase, Description("pass no IP part for the pathname")]
			class PPathnameNoIPPart : XeStatsWFTestBase
		{
			override protected void Execute()
			{
				string url= "//xestats.125626/u:9999/125626/" + new Random().Next().ToString("x");
				XRLWriteFile    req = new XRLWriteFile("Owner",url);

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("only specify domain in <Domain-part> (xestats),no optional information")]
			class PPathnameNoOptionalDomainSpecifier : XeStatsWFTestBase
		{
			override protected void Execute()
			{
				string url= "//xestats/u:125626/125626/" + new Random().Next().ToString("x");
				XRLWriteFile    req = new XRLWriteFile("Owner",url);

				if(WriteFileSendAndVerify(req))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass a pathname that one null char in the middle of <Domain-part>"), TestCasePriority(2)]
			class NPathnameBadString1 : XeStatsWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//xestats.125626/u:9999/125626/" + new Random().Next().ToString("x"),newurl;
				newurl = url.Insert(8,'\0'.ToString());
				XRLWriteFile    writeReq = new XRLWriteFile("Owner",newurl);

				//TODO: need to return xonline_e_storage_domain_not_supported
				if(WriteFileTestNegative(writeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass a pathname that two null char in the middle of <Domain-part>"), TestCasePriority(2)]
			class NPathnameBadString2 : XeStatsWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//xestats.125626/u:9999/125626/" + new Random().Next().ToString("x"),newurl,temp;
				temp = '\0'.ToString() + '\0'.ToString();
				newurl = url.Insert(8,'\0'.ToString());
				XRLWriteFile    writeReq = new XRLWriteFile("Owner",newurl);

				//TODO: need to return xonline_e_storage_domain_not_supported
				if(WriteFileTestNegative(writeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass one nullchar in the middle of <titleID>"), TestCasePriority(2)]
			class NPathnameBadString3 : XeStatsWFNegTestBase
		{
            private RandomEx RandGen = new RandomEx();

			override protected void Execute()
			{
				string url= "//xestats.125626/u:9999/125626/" + new Random().Next().ToString("x"),newurl;
				newurl = url.Insert(28,'\0'.ToString());
                XRLWriteFile writeReq = new XRLWriteFile("Owner", newurl, 1024, false, (uint)RandGen.Next(), 125626);

				if(WriteFileTestNegative(writeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass one nullchar in the middle of <pathpart>"), TestCasePriority(2)]
			class NPathnameBadString4 : XeStatsWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//xestats.125626/u:9999/125626/" + new Random().Next().ToString("x"),newurl;
				newurl = url.Insert(32,'\0'.ToString());
				XRLWriteFile    writeReq = new XRLWriteFile("Owner",newurl);

				if(WriteFileTestNegative(writeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass one nullchar at the end of <pathpart>"), TestCasePriority(2)]
			class NPathnameBadString5 : XeStatsWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//xestats.125626/u:9999/125626/" + new Random().Next().ToString("x"),newurl;
				newurl = url + '\0'.ToString();
				XRLWriteFile    writeReq = new XRLWriteFile("Owner",newurl);

				if(WriteFileTestNegative(writeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass no titleID"), TestCasePriority(2)]
			class NPathnameNoTitleID : XeStatsWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//xestats/u:9999/" + new Random().Next().ToString("x");
				XRLWriteFile    writeReq = new XRLWriteFile("Owner",url);

				if(WriteFileTestNegative(writeReq,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("<Domain-part> is missing in pathname"), TestCasePriority(2)]
			class NPathnameNoDomainPart : XeStatsWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "/u:125626/125626/" + new Random().Next().ToString("x");
				XRLWriteFile    req = new XRLWriteFile("Owner",url);

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass a pathname that has no ID namespace (u)"), TestCasePriority(2)]
			class NPathnameNoIDNameSpace : XeStatsWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//xestats.125626/125626/" + new Random().Next().ToString("x");
				XRLWriteFile    req = new XRLWriteFile("Owner",url);

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass a pathname that is greater than 255"), TestCasePriority(2)]
			class NPathnameOverflowPathname : XeStatsWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//xestats.125626/u:9999/125626/" + new Random().Next().ToString("x");
				StringBuilder    pathName = new StringBuilder(url);
				int        i = 0, numCharToAdd = 256 - url.Length;
				while(i < numCharToAdd)
					pathName.Append(i++);

				XRLWriteFile    req = new XRLWriteFile("Owner",pathName.ToString());

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("pass a pathname that has special chars"), TestCasePriority(2)]
			class NPathnameWrongCharSet : XeStatsWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//xestats/u:9999/125626/12g9";

				XRLWriteFile    req = new XRLWriteFile("Owner",url);

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_INVALID_REQUEST))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		
		/*****************************************************************
		 *  Other Testing
		 *****************************************************************/
		// bug 38096
		[TestCase, Description("Check X-Delay in the http response")]
			class PThrottling : XeStatsWFTestBase
		{
			override protected void Execute()
			{
				string url= "//xestats/u:1234/7878/" + new Random().Next().ToString("x");
				XRLWriteFile    req = new XRLWriteFile("Owner",url);

				int Xdelay= 3000;
				Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage,"exec :stfd SetXDelay "+req.uiTitleId.ToString("X")+" writefile "+Xdelay);

				if(WriteFileSendAndVerify(req) && (req.XDelay == Xdelay))
					ResultCode=TEST_RESULTS.PASSED;

				Global.XEnv.ExecuteXmgmtCommand(Interface.stfd_storage,"exec :stfd ReloadThrottleConfig");
			}
		}
        //[TestCase, Description("XenonStorage does not support familyTitleID:the titleID in the request is not the acutal logged on title"), TestCasePriority(2)]
		//According to SLamb, xenon client will not support it, but server still does.
		class NFamilyTitleID : XeStatsWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//xestats.1234/u:123554/1234/" + new Random().Next().ToString("x");
				XRLWriteFile    req = new XRLWriteFile("Owner",url);
				req.Slot.titleId = 0x89898;
				req.Slot.altTitleId1 = 0x1234;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("update an existing file;old blob will be deleted")]
			class PUpdateExistingFile1 : TestBase
		{
			override protected void Execute()
			{
				uint    randomTitleID = (uint)new Random().Next();
				string    sTitleID = randomTitleID.ToString("x");
				string url= "//xestats."+sTitleID+"/u:6666/"+sTitleID+"/"+ new Random().Next().ToString("x");

				XRLWriteFile    req1 = new XRLWriteFile("Owner",url), req2 = new XRLWriteFile("Owner",url);

				// make sure the two blobs are different
				req2.blobData[1] = (byte)(req1.blobData[1]+1);
				req2.blobHash[1] = (byte)(req1.blobHash[1]+1);

				if(req1.Execute())
				{    // update the same file
					if(req2.Execute())
					{
						// read the file
						XRLReadFileResponse    ReadFileResp;
						XRLReadFile            ReadFileReq = new XRLReadFile(url);
						ReadFileReq.Slot.titleId = ReadFileReq.uiTitleId = randomTitleID;
						ReadFileReq.Slot.titleVersion = ReadFileReq.uiTitleVersion = req2.uiTitleVersion;
						if (ReadFileReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out ReadFileResp))
						{
							if ((ReadFileResp.Compare(req2)) || (req2.Verify()))
								ResultCode=TEST_RESULTS.PASSED;
						}
					}
				}
			}
		}
		[TestCase, Description("update an existing file;old blob still exisits(have reference)")]
			class PUpdateExistingFile2 : TestBase
		{
			override protected void Execute()
			{
				uint    randomTitleID = (uint)new Random().Next();
				string    sTitleID = randomTitleID.ToString("x");
				string url1= "//xestats."+sTitleID+"/u:6666/"+sTitleID+"/"+ new Random().Next(200,300).ToString("x");
				string url2= "//xestats."+sTitleID+"/u:6666/"+sTitleID+"/"+ new Random().Next(1,100).ToString("x");

				XRLWriteFile    req1 = new XRLWriteFile("Owner",url1), req2 = new XRLWriteFile("Owner",url2);

				// make sure the two blob are identical; so we will have two referencs for the same blob
				req2.blobDataLen = req1.blobDataLen;
				req2.uiBlobSizeCompressed = req1.uiBlobSizeCompressed;
				for(int i = 0; i < req1.blobDataLen; i++)
					req2.blobData[i] = req1.blobData[i];
				for(int i = 0; i < Constants.sizeHash; i++)
					req2.blobHash[i] = req1.blobHash[i];

				if(req1.Execute() && req2.Execute())
				{
					// use one of the url to update the blob
					XRLWriteFile    updateReq = new XRLWriteFile("Owner",url1);
					// make sure the two blobs are different
					updateReq.blobHash[1] = (byte)(req1.blobHash[1]+1);

					if(updateReq.Execute())
					{    // the old blob's i_ref_count will be decremented; blob still exists
						// a new blob will be created with i_ref_count is 1
						// read the old blob with url2
						XRLReadFileResponse        ReadOldBlobResp, ReadNewBlobResp;
						XRLReadFile            ReadOldBlobReq = new XRLReadFile(url2),ReadNewBlobReq=new XRLReadFile(url1);
						ReadOldBlobReq.Slot.titleId = ReadOldBlobReq.uiTitleId = randomTitleID;
						ReadOldBlobReq.Slot.titleVersion = ReadOldBlobReq.uiTitleVersion = req2.uiTitleVersion;
						if (ReadOldBlobReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out ReadOldBlobResp))
						{
							if ((ReadOldBlobResp.Compare(req2)) || (req2.Verify()))
							{
								// old blob still exist; check the new blob
								ReadNewBlobReq.Slot.titleId = ReadNewBlobReq.uiTitleId = randomTitleID;
								ReadNewBlobReq.Slot.titleVersion = ReadNewBlobReq.uiTitleVersion = updateReq.uiTitleVersion;
								if(ReadNewBlobReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out ReadNewBlobResp))
									ResultCode=TEST_RESULTS.PASSED;
							}
						}
					}
				}
			}
		}
		[TestCase, Description("data blob are identical,userPUID are the same so mapped to same webstore partition")]
			class PSameFileUploadTwice : XeStatsWFTestBase
		{
			override protected void Execute()
			{
				uint    randomTitleID = (uint)new Random().Next();
				string    sTitleID = randomTitleID.ToString("x");
				string url1= "//xestats."+sTitleID+"/u:6666/"+sTitleID+"/"+ new Random().Next(1,50).ToString("x");
				string url2= "//xestats."+sTitleID+"/u:6666/"+sTitleID+"/"+ new Random().Next(60,90).ToString("x");
				XRLWriteFile    req1 = new XRLWriteFile("Owner",url1), req2 = new XRLWriteFile("Owner",url2);

				req2.blobDataLen = req1.blobDataLen;
				req2.uiBlobSizeCompressed = req1.uiBlobSizeCompressed;
				for(int i = 0; i < req1.blobDataLen; i++)
					req2.blobData[i] = req1.blobData[i];

				for(int i = 0; i < Constants.sizeHash; i++)
					req2.blobHash[i] = req1.blobHash[i];

				if((WriteFileSendAndVerify(req1)) && (WriteFileSendAndVerify(req2)))
				{
					// do other  additional check
					if(req1.CheckRefCount(req2,2, true))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		// need to use userPUID so that they mapped to same logical partition
		[TestCase, Description("same fileSize and hash, but blob are different")]
			class PSameHashDiffrentFileContent : XeStatsWFTestBase
		{
			override protected void Execute()
			{
				uint    randomTitleID = (uint)new Random().Next();
				string    sTitleID = randomTitleID.ToString("x");
				string url1= "//xestats."+sTitleID+"/u:6666/"+sTitleID+"/1";
				string url2= "//xestats."+sTitleID+"/u:6666/"+sTitleID+"/2";
				XRLWriteFile    req1 = new XRLWriteFile("Owner",url1), req2 = new XRLWriteFile("Owner",url2);

				req2.blobDataLen = req1.blobDataLen;
				req2.uiBlobSizeCompressed = req1.uiBlobSizeCompressed;

				// reenforce the two files to have different contents
				req2.blobData[9] = (byte)((int)req1.blobData[9]+ 1);

				for(int i = 0; i < Constants.sizeHash; i++)
					req2.blobHash[i] = req1.blobHash[i];

				if((WriteFileSendAndVerify(req1)) && (WriteFileSendAndVerify(req2)))
				{
					// do other additional check
					if(req1.CheckRefCount(req2,1,false))
						ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		// This is how webstore repartition works; there will be two rows
		// added in both t_files and t_blobs
		[TestCase, Description("data blob are identical, but different userPUID and xrl for two writeFile requests")]
			class PSameFileUploadTwiceByDifferenxestats : XeStatsWFTestBase
		{
			override protected void Execute()
			{
				uint    randomTitleID = (uint)new Random().Next();
				string    sTitleID = randomTitleID.ToString("x");
				string url1= "//xestats."+sTitleID+"/u:6666/"+sTitleID+"/"+ new Random().Next().ToString("x");
				string url2= "//xestats."+sTitleID+"/u:66664/"+sTitleID+"/"+ new Random().Next().ToString("x");
				XRLWriteFile    req1 = new XRLWriteFile("Owner",url1), req2 = new XRLWriteFile("Owner",url2);

				req2.blobDataLen = req1.blobDataLen;
				req2.uiBlobSizeCompressed = req1.uiBlobSizeCompressed;
				for(int i = 0; i < req1.blobDataLen; i++)
					req2.blobData[i] = req1.blobData[i];
				for(int i = 0; i < Constants.sizeHash; i++)
					req2.blobHash[i] = req1.blobHash[i];

				if((WriteFileSendAndVerify(req1)) && (WriteFileSendAndVerify(req2)))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		
		[TestCase, Description("write file 50 times")]
			class PWriteFileMultiTimes : XeStatsWFTestBase
		{
			override protected void Execute()
			{
				uint            uiFailedReq = 0;
				for(int i = 0; i < 50; i++)
				{
					uint    randomTitleID = (uint)new Random().Next();
					string    sTitleID = randomTitleID.ToString("x");
					string url= "//xestats."+sTitleID+"/u:6666/"+sTitleID+"/"+ new Random().Next().ToString("x");

					XRLWriteFile    writeReq = new XRLWriteFile("Owner",url);
					if(!WriteFileSendAndVerify(writeReq))
						uiFailedReq++;
				}
				if(uiFailedReq == 0)
					ResultCode=TEST_RESULTS.PASSED;
				else
					Global.RO.Warn("It failed " + uiFailedReq.ToString() + " times");
			}
		}
		/***********************************************************************
		* Quota testing: quota check will be enabled for xenon game clips
		* bug 20764: disable quota check
		***********************************************************************/
//		[TestCase, Description("create max allowed # of files;remove some files; check quota being updated")]
//			class PQuotaMaxFiles : TestBase
//		{
//			override protected void Execute()
//			{
//				uint	randomTitleID = (uint)new Random().Next();
//				string	sTitleID = randomTitleID.ToString("x");
//				string [] removedUrls = new string[5];
//				uint	[] removedFileSize = new uint[5];
//
//				// create a file for this title first to fill out the t_quotas table
//				string url= "//xestats."+sTitleID+"/u:8989/"+sTitleID+"/"+ new Random().Next().ToString("x");
//				removedUrls[0] = url;
//				XRLWriteFile	req = new XRLWriteFile("Owner",url);
//				req.attributes = new byte[100];
//				new Random().NextBytes(req.attributes);
//				req.attributesLen = (ushort)req.attributes.Length;
//				if(req.Execute())
//					removedFileSize[0] = req.blobDataLen;
//
//				XRLGetQuota		getQuotaReq = new XRLGetQuota((uint)Constants.StorageDomain.xestats,randomTitleID,(uint)Constants.IdType.UserId,0x8989);
//				XRLGetQuotaResponse	getQuotaResp;
//				ulong			maxFileSize=0;
//				ulong			totalBytesMax=0;
//				uint			totalFilesMax=0;
//				ulong			start_BytesUsed=0, actualBytesUsed=0, removedBytes = 0;
//				uint			start_FilesUsed=0, removedFiles = 0;
//				if(getQuotaReq.Execute(out getQuotaResp))
//				{
//					maxFileSize = getQuotaResp.maxFileSize;
//					totalBytesMax = getQuotaResp.totalBytesMax;
//					totalFilesMax = getQuotaResp.totalFilesMax;
//					start_BytesUsed = getQuotaResp.totalBytesUsed;
//					start_FilesUsed = getQuotaResp.totalFilesUsed;
//				}
//				else
//				{
//					Global.RO.Warn("GetQuota request1 failed");
//					return;
//				}
//				uint failed = 0;
//				for(int i = 1; i <= (totalFilesMax-start_FilesUsed); i++)
//				{
//					url= "//xestats."+sTitleID+"/u:8989/"+sTitleID+"/" + i;
//					req = new XRLWriteFile("Owner",url);
//					req.blobData = new byte[2];
//					new Random().NextBytes(req.blobData);
//					req.blobDataLen = req.uiBlobSizeCompressed = (uint)req.blobData.Length;
//					if(!req.Execute())
//					{
//						failed++;
//						return;
//					}
//					actualBytesUsed += req.blobDataLen;
//					if(i < 5)
//					{
//						removedUrls[i] = url;
//						removedFileSize[i] = req.blobDataLen;
//					}
//				}
//				if(failed == 0) // max # of files created for this title
//				{	// check quota again
//					XRLGetQuota		gQReq = new XRLGetQuota((uint)Constants.StorageDomain.xestats,randomTitleID,(uint)Constants.IdType.UserId ,0x8989);
//					XRLGetQuotaResponse	gQResp;
//					if(gQReq.Execute(out gQResp))
//					{
//						if((gQResp.totalFilesUsed == gQResp.totalFilesMax) &&
//							(gQResp.totalBytesUsed == (start_BytesUsed+actualBytesUsed)))
//						{// remove some files then check quota again
//							for(int i = 0; i < 5; i++)
//							{
//								XRLRemoveFile	removeReq = new XRLRemoveFile(removedUrls[i],randomTitleID,"ServiceAddr");
//								if(removeReq.Execute())
//								{
//									removedFiles++;
//									removedBytes += removedFileSize[i];
//								}
//							}
//							// check quota again
//							XRLGetQuota		gQReq2 = new XRLGetQuota((uint)Constants.StorageDomain.xestats,randomTitleID,(uint)Constants.IdType.UserId ,0x8989);
//							XRLGetQuotaResponse	gQResp2;
//							if(gQReq2.Execute(out gQResp2))
//							{
//								if(gQResp2.totalFilesUsed == (gQResp2.totalFilesMax-removedFiles)&&
//									(gQResp2.totalBytesUsed == (start_BytesUsed+actualBytesUsed-removedBytes)))
//									ResultCode=TEST_RESULTS.PASSED;
//							}
//						}
//					}
//				}
//			}
//		}
//		[TestCase, Description("create 2 empty files and check total_bytes_used and total_files_used")]
//			class PQuotaEmptyFiles : TestBase
//		{
//			override protected void Execute()
//			{
//				uint	randomTitleID = (uint)new Random().Next();
//				string	sTitleID = randomTitleID.ToString("x");
//
//				// create a file for this title first to fill out the t_quotas table
//				string url= "//xestats."+sTitleID+"/u:8989/"+sTitleID+"/"+ new Random().Next().ToString("x");
//				XRLWriteFile	req = new XRLWriteFile("Owner",url);
//				ulong			maxFileSize=0;
//				ulong			totalBytesMax=0;
//				uint			totalFilesMax=0;
//				ulong			start_BytesUsed=0;
//				uint			start_FilesUsed=0;
//				if(req.Execute())
//				{
//					XRLGetQuota		getQuotaReq = new XRLGetQuota((uint)Constants.StorageDomain.xestats,randomTitleID,(uint)Constants.IdType.UserId,0x8989);
//					XRLGetQuotaResponse	getQuotaResp;
//					if(getQuotaReq.Execute(out getQuotaResp))
//					{
//						maxFileSize = getQuotaResp.maxFileSize;
//						totalBytesMax = getQuotaResp.totalBytesMax;
//						totalFilesMax = getQuotaResp.totalFilesMax;
//						start_BytesUsed = getQuotaResp.totalBytesUsed;
//						start_FilesUsed = getQuotaResp.totalFilesUsed;
//					}
//					else
//					{
//						Global.RO.Warn("GetQuota request1 failed");
//						return;
//					}
//				}
//				uint failed = 0;
//				// write two empty files
//				for(int i = 0; i < 2; i++)
//				{
//					url= "//xestats."+sTitleID+"/u:8989/"+sTitleID+"/" + i;
//					req = new XRLWriteFile("Owner",url);
//					req.blobData = null;
//					req.blobDataLen = req.uiBlobSizeCompressed = 0;
//					if(!req.Execute())
//					{
//						failed++;
//						return;
//					}
//				}
//				if(failed == 0)
//				{	// check quota again
//					XRLGetQuota		gQReq = new XRLGetQuota((uint)Constants.StorageDomain.xestats,randomTitleID,(uint)Constants.IdType.UserId ,0x8989);
//					XRLGetQuotaResponse	gQResp;
//					if(gQReq.Execute(out gQResp))
//					{
//						if((gQResp.totalFilesUsed == (start_FilesUsed+2)) &&
//							(gQResp.totalBytesUsed == start_BytesUsed))
//							ResultCode=TEST_RESULTS.PASSED;
//					}
//				}
//			}
//		}
//		[TestCase, Description("create a file with multi ref, check quota; remove one ref check quota again")]
//			class PQuotaFilesWithMultiRef : TestBase
//		{
//			override protected void Execute()
//			{
//				uint	randomTitleID = (uint)new Random().Next();
//				string	sTitleID = randomTitleID.ToString("x");
//
//				ulong			maxFileSize=0;
//				ulong			totalBytesMax=0;
//				uint			totalFilesMax=0;
//				ulong			start_BytesUsed=0;
//				uint			start_FilesUsed=0;
//				// create a file for this title first to fill out the t_quotas table
//				string url= "//xestats."+sTitleID+"/u:8989/"+sTitleID+"/"+ new Random().Next().ToString("x");
//				XRLWriteFile	req = new XRLWriteFile("Owner",url);
//				if(req.Execute())
//				{
//					XRLGetQuota		getQuotaReq = new XRLGetQuota((uint)Constants.StorageDomain.xestats,randomTitleID,(uint)Constants.IdType.UserId ,0x8989);
//					XRLGetQuotaResponse	getQuotaResp;
//					if(getQuotaReq.Execute(out getQuotaResp))
//					{
//						maxFileSize = getQuotaResp.maxFileSize;
//						totalBytesMax = getQuotaResp.totalBytesMax;
//						totalFilesMax = getQuotaResp.totalFilesMax;
//						start_BytesUsed = getQuotaResp.totalBytesUsed;
//						start_FilesUsed = getQuotaResp.totalFilesUsed;
//					}
//					else
//					{
//						Global.RO.Warn("GetQuota request1 failed");
//						return;
//					}
//				}
//				else
//					return;
//				// create a blob with two references
//				string url1= "//xestats."+sTitleID+"/u:8989/"+sTitleID+"/" + new Random().Next(10,200).ToString("x");
//				string url2= "//xestats."+sTitleID+"/u:8989/"+sTitleID+"/" + new Random().Next(300,500).ToString("x");
//				XRLWriteFile	req1 = new XRLWriteFile("Owner",url1), req2 = new XRLWriteFile("Owner",url2);
//
//				req2.blobDataLen = req1.blobDataLen;
//				req2.uiBlobSizeCompressed = req1.uiBlobSizeCompressed;
//				for(int i = 0; i < req1.blobDataLen; i++)
//					req2.blobData[i] = req1.blobData[i];
//				for(int i = 0; i < Constants.sizeHash; i++)
//					req2.blobHash[i] = req1.blobHash[i];
//
//				if(req1.Execute() && req2.Execute())
//				{
//					XRLGetQuota		gQReq = new XRLGetQuota((uint)Constants.StorageDomain.xestats,randomTitleID,(uint)Constants.IdType.UserId ,0x8989);
//					XRLGetQuotaResponse	gQResp;
//					if(gQReq.Execute(out gQResp))
//					{
//						if((gQResp.totalFilesUsed == (start_FilesUsed+2)) &&
//							(gQResp.totalBytesUsed == (start_BytesUsed+req1.blobDataLen+req2.blobDataLen)))
//						{// remove one ref then check quota again
//							XRLRemoveFile	removeReq = new XRLRemoveFile(url1,randomTitleID,"ServiceAddr");
//							if(removeReq.Execute())
//							{		// check quota again
//								XRLGetQuota		gQReq2 = new XRLGetQuota((uint)Constants.StorageDomain.xestats,randomTitleID,(uint)Constants.IdType.UserId ,0x8989);
//								XRLGetQuotaResponse	gQResp2;
//								if(gQReq2.Execute(out gQResp2))
//								{	// totalBytesUsed and fileUsed should be changed.
//									if(gQResp2.totalFilesUsed == (start_FilesUsed+1)&&
//										(gQResp2.totalBytesUsed == (start_BytesUsed+req2.blobDataLen)))
//										ResultCode=TEST_RESULTS.PASSED;
//								}
//							}
//						}
//					}
//				}
//			}
//		}
//		[TestCase, Description("goto quota and replace last file")]
//			class PReplaceLastFileWhenQuotaReached : TestBase
//		{
//			override protected void Execute()
//			{
//
//				uint	randomTitleID = (uint)new Random().Next();
//				string	sTitleID = randomTitleID.ToString("x");
//
//				// create a file for this title first to fill out the t_quotas table
//				string url= "//xestats."+sTitleID+"/u:8989/"+sTitleID+"/" + new Random().Next().ToString("x");
//				XRLWriteFile	req = new XRLWriteFile("Owner",url);
//				req.attributes = new byte[100];
//				new Random().NextBytes(req.attributes);
//				req.attributesLen = (ushort)req.attributes.Length;
//
//				// get the quota
//				XRLGetQuota		getQuotaReq = new XRLGetQuota((uint)Constants.StorageDomain.xestats,randomTitleID,(uint)Constants.IdType.UserId,0x8989);
//				XRLGetQuotaResponse	getQuotaResp;
//				ulong			maxFileSize=0;
//				ulong			totalBytesMax=0;
//				uint			totalFilesMax=0;
//				ulong			start_BytesUsed=0, actualBytesUsed=0;
//				uint			start_FilesUsed=0;
//				if(getQuotaReq.Execute(out getQuotaResp))
//				{
//					maxFileSize = getQuotaResp.maxFileSize;
//					totalBytesMax = getQuotaResp.totalBytesMax;
//					totalFilesMax = getQuotaResp.totalFilesMax;
//					start_BytesUsed = getQuotaResp.totalBytesUsed;
//					start_FilesUsed = getQuotaResp.totalFilesUsed;
//				}
//				else
//				{
//					Global.RO.Warn("GetQuota request1 failed");
//					return;
//				}
//
//				//Fill the quota
//				uint failed = 0;
//				for(int i = 1; i <= (totalFilesMax-start_FilesUsed); i++)
//				{
//					url= "//xestats."+sTitleID+"/u:8989/"+sTitleID+"/" + new Random().Next().ToString("x");
//					req = new XRLWriteFile("Owner",url);
//					req.blobData = new byte[2];
//					new Random().NextBytes(req.blobData);
//					req.blobDataLen = req.uiBlobSizeCompressed = (uint)req.blobData.Length;
//					if(!req.Execute())
//					{
//						failed++;
//						return;
//					}
//					actualBytesUsed += req.blobDataLen;
//				}
//
//				//Update the last file again
//				if (failed==0)
//				{
//					req.attributes = new byte[10]{1,2,3,4,5,6,7,8,9,0};
//					req.attributesLen = 10;
//					if(!req.Execute())
//					{
//						return;	// fail
//					}
//				}
//
//				ResultCode=TEST_RESULTS.PASSED;
//			}
//		}
//		[TestCase, Description("create >max # allowed files, but byteUsed still within limit "), TestCasePriority(2)]
//			class NQuotaOverflowTotalFiles : GlobalTitleWFNegTestBase
//		{
//			override protected void Execute()
//			{
//				// This test assume no files/bytes exist for this title
//				uint	randomTitleID = (uint)new Random().Next();
//				string	sTitleID = randomTitleID.ToString("x");
//				ulong	actualBytesUsed = 0;
//				uint	totalFilesMax = 1000;	//xestats max file is 1000
//				ulong	totalBytesMax = 64*1024;
//
//				uint failed = 0;
//				for(int i = 0; i < totalFilesMax; i++)
//				{
//					string url= "//xestats."+sTitleID+"/u:8989/"+sTitleID+"/" + new Random().Next().ToString("x");
//					XRLWriteFile	req = new XRLWriteFile("Owner",url);
//					req.blobDataLen = req.uiBlobSizeCompressed= 30;
//					req.blobData = new byte[30];
//					new Random().NextBytes(req.blobData);
//					if(!req.Execute())
//					{
//						failed++;
//						return;
//					}
//					actualBytesUsed += req.blobDataLen;
//				}
//				if(failed == 0) // max # of files created for this title
//				{	// create another file
//					string url= "//xestats."+sTitleID+"/u:8989/"+sTitleID+"/" + new Random().Next().ToString("x");
//					XRLWriteFile	req = new XRLWriteFile("Owner",url);
//					ulong	totalActualBytes = actualBytesUsed+req.blobDataLen;
//					if(totalActualBytes<=totalBytesMax)
//						if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_QUOTA_EXCEEDED))
//							ResultCode=TEST_RESULTS.PASSED;
//						else
//							Global.RO.Warn("Total number of files used is over limit");
//				}
//			}
//		}
//		[TestCase, Description("create >max allowed bytes, but # of filesUsed still within limit "), TestCasePriority(2)]
//			class NQuotaOverflowTotalBytes : GlobalTitleWFNegTestBase
//		{
//			override protected void Execute()
//			{
//				// This test assume no files/bytes exist for this title
//				uint	randomTitleID = (uint)new Random().Next();
//				string	sTitleID = randomTitleID.ToString("x");
//				ulong	actualBytesUsed = 0;
//
//				// for Xenon game clips: bytesMax is 64KB, maxFiles is 1000,
//				// so create 4 files each one is 16KB, then create aother one with 1 byte, which should fail
//				uint failed = 0;
//				for(int i = 0; i < 4; i++)
//				{
//					string url= "//xestats."+sTitleID+"/u:8989/"+sTitleID+"/" + new Random().Next().ToString("x");
//					XRLWriteFile	req = new XRLWriteFile("Owner",url);
//					req.blobDataLen = req.uiBlobSizeCompressed = 16*1024;
//					req.blobData = new byte[16*1024];
//					new Random().NextBytes(req.blobData);
//					if(!req.Execute())
//					{
//						failed++;
//						return;
//					}
//					actualBytesUsed += req.blobDataLen;
//				}
//				if(failed == 0) // maxBytes created for the title
//				{	// create another file
//					string url= "//xestats."+sTitleID+"/u:8989/"+sTitleID+"/" + new Random().Next().ToString("x");
//					XRLWriteFile	req = new XRLWriteFile("Owner",url);
//					req.blobDataLen = req.uiBlobSizeCompressed = 1;
//					req.blobData = new byte[1];
//					new Random().NextBytes(req.blobData);
//
//					if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_QUOTA_EXCEEDED))
//						ResultCode=TEST_RESULTS.PASSED;
//					else
//						Global.RO.Warn("Total bytes used is over limit");
//				}
//			}
//		}
		/***********************************************************************
		* SG Auth Data testing
		***********************************************************************/
        [TestCase, Description("the userPUID in SGAuth response is not_found user"), TestCasePriority(2)]
			class NSGAuthNotFoundUser : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//xestats/u:8989/12345/" + new Random().Next().ToString("x");
				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.Slot.UserExists = 0;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_SERVER_ERROR))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the userPUID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidUser : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//xestats/u:8989/12345/" + new Random().Next().ToString("x");
				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.Slot.userPuid0++;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the TitleID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidTitleID : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//xestats/u:8989/12345/" + new Random().Next().ToString("x");
				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.Slot.titleId++;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_INVALID_TITLE_ID))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the XBoxPUID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidXBoxPUID : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//xestats/u:8989/12345/" + new Random().Next().ToString("x");
				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.Slot.machinePuid++;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the TitleVersion in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidTitleVersion : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//xestats/u:8989/12345/" + new Random().Next().ToString("x");
				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.Slot.titleVersion++;

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
        [TestCase, Description("the CountryID in SGAuth response is different than the one in the WriteFile request"), TestCasePriority(2)]
			class NSGAuthInvalidCountryID : UserTitleWFNegTestBase
		{
			override protected void Execute()
			{
				string url= "//xestats/u:8989/12345/" + new Random().Next().ToString("x");
				XRLWriteFile	req = new XRLWriteFile("Owner",url);
				req.Slot.userFlag0 = (uint)((req.Slot.userFlag0>>8+1)<<8);

				if(WriteFileTestNegative(req,HResult.XONLINE_E_STORAGE_ACCESS_DENIED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\StressMsgWR.cs ===
using System;
using System.Threading;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Storage;
using xonline.common.config;

namespace XStoreTest
{
    [StressInstantiate]
	public class StressMsgWrite : TestBase
	{
		override protected void Execute()
		{
			string writeUrl;
            uint titleID = 0;
            bool fail = false;

            // get file off of queue and write...
            if (XStoreTest.syncdMsgFileQ.Count >= XStoreTest.MaxQueueLength)
            {
                try
                {
                    QueueUrlObject tempUrlObject = (QueueUrlObject)XStoreTest.syncdMsgFileQ.Dequeue();
                    writeUrl = tempUrlObject.Url;
                    titleID = tempUrlObject.TitleId;
                }
                catch (InvalidOperationException)
                {
                    // if we fail to read, generate a new one to play with
                    ulong randomUserPUID = (ulong)(XStoreTest.randomInstance.NextDouble() * 0xffffffffffffffff);
                    if (randomUserPUID == 0)
                        randomUserPUID = (ulong)(XStoreTest.randomInstance.Next(1, 20000));
                    string sUserPUID = randomUserPUID.ToString("x");
                    writeUrl = "//msg.ab/u:" + sUserPUID + "/" + Guid.NewGuid().ToString();
                }
            }
            else
            {
                // if the queue is not full, generate a new one to play with
                ulong randomUserPUID = (ulong)(XStoreTest.randomInstance.NextDouble() * 0xffffffffffffffff);
                if (randomUserPUID == 0)
                    randomUserPUID = (ulong)(XStoreTest.randomInstance.Next(1, 20000));
                string sUserPUID = randomUserPUID.ToString("x");
                writeUrl = "//msg.ab/u:" + sUserPUID + "/" + Guid.NewGuid().ToString();
            }

            XRLRemoveFile removeReq = new XRLRemoveFile(writeUrl, titleID, "ServiceAddr");
            removeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage));

            XRLWriteFile	writeReq = new XRLWriteFile("All",writeUrl,XStoreTest.MsgFile,true);
			byte [] rand = new byte[(XStoreTest.MsgFile<8)? XStoreTest.MsgFile : 8];
			XStoreTest.rng.GetBytes(rand);
			rand.CopyTo(writeReq.blobData,0);

            if (writeReq.Execute())
            {
                if (XStoreTest.syncdMsgFileQ.Count < XStoreTest.MaxQueueLength)
                {
                    XStoreTest.syncdMsgFileQ.Enqueue(new QueueUrlObject(writeReq.uiTitleId, writeUrl, writeReq.uiTitleVersion));
                }
            }
            else
            {
                XStoreTest.Safetw.WriteLine(DateTime.Now.ToString() + ":Msg WriteFile request failed: " + writeUrl + " : " + writeReq.XErr.ToString("x"));
                fail = true;
            }

            if (!fail)
                ResultCode = TEST_RESULTS.PASSED;
		}
	}

    [StressInstantiate]
    public class StressMsgRead : TestBase
    {
        override protected void Execute()
        {
            string readUrl;
            uint titleID;
            uint titleVersion;
            bool fail = false;

            try
            {
                QueueUrlObject tempUrlObject = (QueueUrlObject)XStoreTest.syncdMsgFileQ.Dequeue();
                readUrl = tempUrlObject.Url;
                titleID = tempUrlObject.TitleId;
                titleVersion = tempUrlObject.TitleVersion;
            }
            catch (InvalidOperationException)
            {
                // if we fail to read, generate a new one to play with
                ulong randomUserPUID = (ulong)(XStoreTest.randomInstance.NextDouble() * 0xffffffffffffffff);
                if (randomUserPUID == 0)
                    randomUserPUID = (ulong)(XStoreTest.randomInstance.Next(1, 20000));
                string sUserPUID = randomUserPUID.ToString("x");
                readUrl = "//msg.ab/u:" + sUserPUID + "/" + Guid.NewGuid().ToString();
                XRLWriteFile writeReq = new XRLWriteFile("All", readUrl, XStoreTest.MsgFile, true);
                byte[] rand = new byte[(XStoreTest.MsgFile < 8) ? XStoreTest.MsgFile : 8];
                XStoreTest.rng.GetBytes(rand);
                rand.CopyTo(writeReq.blobData, 0);

                writeReq.Execute();
                titleID = writeReq.uiTitleId;
                titleVersion = writeReq.uiTitleVersion;
            }

            XRLReadFileResponse readResp;
            XRLReadFile readReq = new XRLReadFile(readUrl);
            readReq.Slot.titleId = readReq.uiTitleId = titleID;
            readReq.Slot.titleVersion = readReq.uiTitleVersion = titleVersion;
            if (!readReq.Execute(true, Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out readResp))
            {
                XStoreTest.Safetw.WriteLine(DateTime.Now.ToString() + ":ReadFile request failed:" + readReq.XErr.ToString("x"));
                fail = true;
            }

            if (XStoreTest.syncdMsgFileQ.Count < XStoreTest.MaxQueueLength)
            {
                XStoreTest.syncdMsgFileQ.Enqueue(new QueueUrlObject(titleID, readUrl, titleVersion));
            }

            if (!fail)
            {
                ResultCode = TEST_RESULTS.PASSED;
            }
        }
    }

    [StressInstantiate]
    public class StressMsgRemove : TestBase
    {
        override protected void Execute()
        {
            string removeUrl;
            uint titleID;
            uint titleVersion;
            bool fail = false;

            try
            {
                QueueUrlObject tempUrlObject = (QueueUrlObject)XStoreTest.syncdMsgFileQ.Dequeue();
                removeUrl = tempUrlObject.Url;
                titleID = tempUrlObject.TitleId;
                titleVersion = tempUrlObject.TitleVersion;
            }
            catch (InvalidOperationException)
            {
                // if we fail to read, generate a new one to play with
                ulong randomUserPUID = (ulong)(XStoreTest.randomInstance.NextDouble() * 0xffffffffffffffff);
                if (randomUserPUID == 0)
                    randomUserPUID = (ulong)(XStoreTest.randomInstance.Next(1, 20000));
                string sUserPUID = randomUserPUID.ToString("x");
                removeUrl = "//msg.ab/u:" + sUserPUID + "/" + Guid.NewGuid().ToString();
                XRLWriteFile writeReq = new XRLWriteFile("All", removeUrl, XStoreTest.MsgFile, true);
                byte[] rand = new byte[(XStoreTest.MsgFile < 8) ? XStoreTest.MsgFile : 8];
                XStoreTest.rng.GetBytes(rand);
                rand.CopyTo(writeReq.blobData, 0);

                writeReq.Execute();
                titleID = writeReq.uiTitleId;
                titleVersion = writeReq.uiTitleVersion;
            }

            XRLRemoveFile removeReq = new XRLRemoveFile(removeUrl, titleID, "ServiceAddr");
            removeReq.Slot.titleId = removeReq.uiTitleId = titleID;
            //removeReq.Slot.titleVersion = removeReq.uiTitleVersion = titleVersion;
            if (!removeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
            {
                XStoreTest.Safetw.WriteLine(DateTime.Now.ToString() + ":RemoveFile request failed:" + removeReq.XErr.ToString("x"));
                fail = true;
            }

            if (!fail)
            {
                ResultCode = TEST_RESULTS.PASSED;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\StressNameResolver.cs ===
using System;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Storage;
using xonline.common.config;

namespace XStoreTest
{
    [StressInstantiate]
	public class StressNameResolver : TestBase
	{
		override protected void Execute()
		{
			XRLNameResolverResponse		resp;
			string	pathName = "stats";
			XRLNameResolver		req = new XRLNameResolver(pathName);

			if(req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_name_resolution), out resp))
				ResultCode = TEST_RESULTS.PASSED;
		//	else
		//		XStoreTest.Safetw.WriteLine(DateTime.Now.ToString()+":NameResolver request failed:"+req.XErr.ToString("x"));
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\StressReadTitleFiles.cs ===
using System;
using System.Threading;
using System.Collections;
using System.Globalization;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Storage;
using xonline.common.config;
using XblUser = live.common.XblUser;

namespace XStoreTest
{
    [StressInstantiate]
    public class StressRead25TitleFiles : TestBase
	{
        override protected void Execute()
        {
            FuncAchievementsRF.InitializeData();
            const int nTiles = 25;
            uint uiTitleId = FuncAchievementsRF.uiTitleId;
            uint[] ids = new uint[nTiles];
            for (int i = 0; i < ids.Length; i++)
            {
                ids[i] = (uint)(FuncAchievementsRF.uiInitialTileId + i);
            }
            XRLReadAchievementsResponse dummyResponse;
            string desc = "TitleId: " + uiTitleId + ", Achievement Count: " + nTiles.ToString() + ", Tiles: " + FuncAchievementsRF.ArrayToCSV(ids);

            ResultCode = TEST_RESULTS.PASSED;
            if (!FuncAchievementsRF.CallReadAchievements(uiTitleId, out dummyResponse, string.Empty, ids, FuncAchievementsRF.ValidationType.Full, null))
            {
                Global.RO.Error("Failed to get the valid tiles.");
                ResultCode = TEST_RESULTS.PASSED;
            }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\StressTeamWR.cs ===
using System;
using System.Threading;
using System.Collections;
using System.Globalization;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Storage;
using xonline.common.config;

namespace XStoreTest
{
    [StressInstantiate]
	public class StressTeamWrite : TestBase
	{
		override protected void Execute()
		{
			uint	titleID;
			string  writeUrl;
			bool	fail = false;

            // get file off of queue and write...
            if (XStoreTest.syncdTeamFileQ.Count >= XStoreTest.MaxQueueLength)
            {
                try
                {
                    QueueUrlObject tempUrlObject = (QueueUrlObject)XStoreTest.syncdTeamFileQ.Dequeue();
                    writeUrl = tempUrlObject.Url;
                    titleID = tempUrlObject.TitleId;
                }
                catch (InvalidOperationException)
                {
                    // if we fail to read, generate a new one to play with
                    titleID = (uint)XStoreTest.randomInstance.Next(1, (int)XStoreTest.numOfTitles);
                    string sTitleID = titleID.ToString("x");
                    uint teamPUID = (uint)XStoreTest.randomInstance.Next();
                    string sTeamPUID = teamPUID.ToString("x");
                    ulong userPUID = (ulong)(XStoreTest.randomInstance.NextDouble() * 0xffffffffffffffff);
                    while (userPUID == 0)
                    {
                        userPUID = (ulong)(XStoreTest.randomInstance.NextDouble() * 0xffffffffffffffff);
                    }
                    string sUserPUID = userPUID.ToString("x");
                    writeUrl = "//tteam." + sTitleID + "/u:" + sTeamPUID + "/" + sTitleID + "/" + sUserPUID + "/Shuyin";
                }
            }
            else
            {
                // if the queue is not full, generate a new one to play with
                titleID = (uint)XStoreTest.randomInstance.Next(1, (int)XStoreTest.numOfTitles);
                string sTitleID = titleID.ToString("x");
                uint teamPUID = (uint)XStoreTest.randomInstance.Next();
                string sTeamPUID = teamPUID.ToString("x");
                ulong userPUID = (ulong)(XStoreTest.randomInstance.NextDouble() * 0xffffffffffffffff);
                while (userPUID == 0)
                {
                    userPUID = (ulong)(XStoreTest.randomInstance.NextDouble() * 0xffffffffffffffff);
                }
                string sUserPUID = userPUID.ToString("x");
                writeUrl = "//tteam." + sTitleID + "/u:" + sTeamPUID + "/" + sTitleID + "/" + sUserPUID + "/Shuyin";
            }

            XRLWriteFile writeReq = new XRLWriteFile("Team", writeUrl, XStoreTest.TeamFile, true);
			byte [] rand = new byte[(XStoreTest.TeamFile<8)? XStoreTest.TeamFile : 8];
			XStoreTest.rng.GetBytes(rand);
			rand.CopyTo(writeReq.blobData,0);

//			writeReq.accessToken.writeAT.fileExpirationDate = (long)System.DateTime.UtcNow.AddMinutes(5).ToFileTimeUtc();
//			writeReq.accessToken.writeAT.tokenExpirationDate = (long)System.DateTime.UtcNow.AddMinutes(3).ToFileTimeUtc();

            if (writeReq.Execute())
            {
                if (XStoreTest.syncdTeamFileQ.Count < XStoreTest.MaxQueueLength)
                {
                    XStoreTest.syncdTeamFileQ.Enqueue(new QueueUrlObject(titleID, writeUrl));
                }
            }
            else
            {
                XStoreTest.Safetw.WriteLine(DateTime.Now.ToString() + ":WriteFile request failed:" + writeReq.XErr.ToString("x"));
                fail = true;
            }

			if(!fail)
				ResultCode = TEST_RESULTS.PASSED;
		}
	}

    [StressInstantiate]
    public class StressTeamRead : StressTestBase
    {
        override protected void Execute()
        {
            uint titleID;
            string readUrl;
            bool fail = false;

            // get file off of queue...
            try
            {
                QueueUrlObject tempUrlObject = (QueueUrlObject)XStoreTest.syncdTeamFileQ.Dequeue();
                readUrl = tempUrlObject.Url;
                titleID = tempUrlObject.TitleId;
            }
            catch (InvalidOperationException)
            {
                // if we fail to read, generate a new one to play with
                titleID = (uint)XStoreTest.randomInstance.Next(1, (int)XStoreTest.numOfTitles);
                string sTitleID = titleID.ToString("x");
                uint teamPUID = (uint)XStoreTest.randomInstance.Next();
                string sTeamPUID = teamPUID.ToString("x");
                ulong userPUID = (ulong)(XStoreTest.randomInstance.NextDouble() * 0xffffffffffffffff);
                while (userPUID == 0)
                {
                    userPUID = (ulong)(XStoreTest.randomInstance.NextDouble() * 0xffffffffffffffff);
                }
                string sUserPUID = userPUID.ToString("x");
                readUrl = "//tteam." + sTitleID + "/u:" + sTeamPUID + "/" + sTitleID + "/" + sUserPUID + "/Shuyin";
                XRLWriteFile writeReq = new XRLWriteFile("Team", readUrl, XStoreTest.TeamFile, true);
                byte[] rand = new byte[(XStoreTest.TeamFile < 8) ? XStoreTest.TeamFile : 8];
                XStoreTest.rng.GetBytes(rand);
                rand.CopyTo(writeReq.blobData, 0);

                writeReq.Execute();
            }

            XRLReadFileResponse readResp;
            XRLReadFile readReq = new XRLReadFile(readUrl);
            //	readReq.Slot.titleId = readReq.uiTitleId = randomTitleID;
            //	readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
            if (!readReq.Execute(true, Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out readResp))
            {
                XStoreTest.Safetw.WriteLine(DateTime.Now.ToString() + ":ReadFile request failed:" + readReq.XErr.ToString("x"));
                fail = true;
            }

            //Add it back to the queue
            if (XStoreTest.syncdTeamFileQ.Count < XStoreTest.MaxQueueLength)
            {
                XStoreTest.syncdTeamFileQ.Enqueue(new QueueUrlObject(titleID, readUrl));
            }

            if (!fail)
                ResultCode = TEST_RESULTS.PASSED;
        }
    }

    [StressInstantiate]
    public class StressTeamRemove : TestBase
    {
        override protected void Execute()
        {
            uint titleID;
            string removeUrl;
            bool fail = false;

            // get file off of queue...
            try
            {
                QueueUrlObject tempUrlObject = (QueueUrlObject)XStoreTest.syncdTeamFileQ.Dequeue();
                removeUrl = tempUrlObject.Url;
                titleID = tempUrlObject.TitleId;
            }
            catch (InvalidOperationException)
            {
                // if we fail to read, generate a new one to play with
                titleID = (uint)XStoreTest.randomInstance.Next(1, (int)XStoreTest.numOfTitles);
                string sTitleID = titleID.ToString("x");
                uint teamPUID = (uint)XStoreTest.randomInstance.Next();
                string sTeamPUID = teamPUID.ToString("x");
                ulong userPUID = (ulong)(XStoreTest.randomInstance.NextDouble() * 0xffffffffffffffff);
                while (userPUID == 0)
                {
                    userPUID = (ulong)(XStoreTest.randomInstance.NextDouble() * 0xffffffffffffffff);
                }
                string sUserPUID = userPUID.ToString("x");
                removeUrl = "//tteam." + sTitleID + "/u:" + sTeamPUID + "/" + sTitleID + "/" + sUserPUID + "/Shuyin";
                XRLWriteFile writeReq = new XRLWriteFile("Team", removeUrl, XStoreTest.TeamFile, true);
                byte[] rand = new byte[(XStoreTest.TeamFile < 8) ? XStoreTest.TeamFile : 8];
                XStoreTest.rng.GetBytes(rand);
                rand.CopyTo(writeReq.blobData, 0);

                writeReq.Execute();
            }

            XRLRemoveFile removeReq = new XRLRemoveFile(removeUrl, titleID, "Team");
            if (!removeReq.Execute())
            {
                XStoreTest.Safetw.WriteLine(DateTime.Now.ToString() + ":RemoveFile request failed:" + removeReq.XErr.ToString("x"));
                fail = true;
            }
            if (!fail)
                ResultCode = TEST_RESULTS.PASSED;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\StressXBoxGameClips.cs ===
using System;
using System.Threading;
using System.Collections;
using System.Globalization;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Storage;
using xonline.common.config;

namespace XStoreTest
{
    [StressInstantiate]
	public class StressStatsWrite : TestBase
	{
		override protected void Execute()
		{
			bool	fail = false;
			uint	titleID;
			string	writeUrl;

            // get file off of queue and write...
            if (XStoreTest.syncdXBoxClipFileQ.Count >= XStoreTest.MaxQueueLength)
            {
                try
                {
                    QueueUrlObject tempUrlObject = (QueueUrlObject)XStoreTest.syncdXBoxClipFileQ.Dequeue();
                    writeUrl = tempUrlObject.Url;
                    titleID = tempUrlObject.TitleId;
                }
                catch (InvalidOperationException)
                {
                    // if we fail to read, generate a new one to play with
                    titleID = (uint)XStoreTest.randomInstance.Next(1, (int)XStoreTest.numOfTitles);
                    string sTitleID = titleID.ToString("x");
                    ulong randomPartitionKeyValue = (ulong)(XStoreTest.randomInstance.NextDouble() * 0xffffffffffffffff);
                    writeUrl = "//stats." + sTitleID
                        + "/u:" + randomPartitionKeyValue.ToString("x") + "/" + sTitleID + "/" + Guid.NewGuid().ToString();
                }
            }
            else
            {
                // if the queue is not full, generate a new one to play with
                titleID = (uint)XStoreTest.randomInstance.Next(1, (int)XStoreTest.numOfTitles);
                string sTitleID = titleID.ToString("x");
                ulong randomPartitionKeyValue = (ulong)(XStoreTest.randomInstance.NextDouble() * 0xffffffffffffffff);
                writeUrl = "//stats." + sTitleID
                    + "/u:" + randomPartitionKeyValue.ToString("x") + "/" + sTitleID + "/" + Guid.NewGuid().ToString();
            }

            XRLRemoveFile removeReq = new XRLRemoveFile(writeUrl, titleID, "ServiceAddr");
            removeReq.Execute();

            XRLWriteFile writeReq = new XRLWriteFile("ServiceToken", writeUrl, XStoreTest.XboxClipFile, true);
			byte [] rand = new byte[(XStoreTest.XboxClipFile<8)? XStoreTest.XboxClipFile : 8];
			XStoreTest.rng.GetBytes(rand);
			rand.CopyTo(writeReq.blobData,0);

            if (writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
            {
                if (XStoreTest.syncdXBoxClipFileQ.Count < XStoreTest.MaxQueueLength)
                {
                    XStoreTest.syncdXBoxClipFileQ.Enqueue(new QueueUrlObject(titleID, writeUrl));
                }
            }
            else
            {
                XStoreTest.Safetw.WriteLine(DateTime.Now.ToString() + ":XBox Game Clips:WriteFile request failed:" + writeReq.XErr.ToString("x"));
                fail = true;
            }

			if(!fail)
				ResultCode = TEST_RESULTS.PASSED;
		}
	}

    [StressInstantiate]
    public class StressStatsRead : TestBase
    {
        override protected void Execute()
        {
            bool fail = false;
            uint titleID;
            string readUrl;

            try
            {
                QueueUrlObject tempUrlObject = (QueueUrlObject)XStoreTest.syncdXBoxClipFileQ.Dequeue();
                readUrl = tempUrlObject.Url;
                titleID = tempUrlObject.TitleId;
            }
            catch (InvalidOperationException)
            {
                // if we fail to read, generate a new one to play with
                titleID = (uint)XStoreTest.randomInstance.Next(1, (int)XStoreTest.numOfTitles);
                string sTitleID = titleID.ToString("x");
                ulong randomPartitionKeyValue = (ulong)(XStoreTest.randomInstance.NextDouble() * 0xffffffffffffffff);
                readUrl = "//stats." + sTitleID
                    + "/u:" + randomPartitionKeyValue.ToString("x") + "/" + sTitleID + "/" + Guid.NewGuid().ToString();

                XRLWriteFile writeReq = new XRLWriteFile("ServiceToken", readUrl, XStoreTest.XboxClipFile, true);
                byte[] rand = new byte[(XStoreTest.XboxClipFile < 8) ? XStoreTest.XboxClipFile : 8];
                XStoreTest.rng.GetBytes(rand);
                rand.CopyTo(writeReq.blobData, 0);

                writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage));
            }

            XRLReadFileResponse readResp;
            XRLReadFile readReq = new XRLReadFile(readUrl);
            readReq.Slot.titleId = readReq.uiTitleId = titleID;
            if (!readReq.Execute(true, Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out readResp))
            {
                XStoreTest.Safetw.WriteLine(DateTime.Now.ToString() + ":XBox Game Clips:ReadFile request failed:" + readReq.XErr.ToString("x"));
                fail = true;
            }
            if (XStoreTest.syncdXBoxClipFileQ.Count < XStoreTest.MaxQueueLength)
            {
                XStoreTest.syncdXBoxClipFileQ.Enqueue(new QueueUrlObject(titleID, readUrl));
            }

            if (!fail)
                ResultCode = TEST_RESULTS.PASSED;
        }
    }

    [StressInstantiate]
    public class StressStatsRemove : TestBase
    {
        override protected void Execute()
        {
            bool fail = false;
            uint titleID;
            string removeUrl;

            try
            {
                QueueUrlObject tempUrlObject = (QueueUrlObject)XStoreTest.syncdXBoxClipFileQ.Dequeue();
                removeUrl = tempUrlObject.Url;
                titleID = tempUrlObject.TitleId;
            }
            catch (InvalidOperationException)
            {
                // if we fail to read, generate a new one to play with
                titleID = (uint)XStoreTest.randomInstance.Next(1, (int)XStoreTest.numOfTitles);
                string sTitleID = titleID.ToString("x");
                ulong randomPartitionKeyValue = (ulong)(XStoreTest.randomInstance.NextDouble() * 0xffffffffffffffff);
                removeUrl = "//stats." + sTitleID
                    + "/u:" + randomPartitionKeyValue.ToString("x") + "/" + sTitleID + "/" + Guid.NewGuid().ToString();

                XRLWriteFile writeReq = new XRLWriteFile("ServiceToken", removeUrl, XStoreTest.XboxClipFile, true);
                byte[] rand = new byte[(XStoreTest.XboxClipFile < 8) ? XStoreTest.XboxClipFile : 8];
                XStoreTest.rng.GetBytes(rand);
                rand.CopyTo(writeReq.blobData, 0);

                writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage));
            }

            XRLRemoveFile removeReq = new XRLRemoveFile(removeUrl, titleID, "ServiceAddr");
            if (!removeReq.Execute())
            {
                XStoreTest.Safetw.WriteLine(DateTime.Now.ToString() + ":RemoveFile request failed:" + removeReq.XErr.ToString("x"));
                fail = true;
            }

            if (!fail)
                ResultCode = TEST_RESULTS.PASSED;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\StressXeStats.cs ===
using System;
using System.Threading;
using System.Collections;
using System.Globalization;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Storage;
using xonline.common.config;

namespace XStoreTest
{
    [StressInstantiate]
	public class StressXeStatsWrite : TestBase
	{
		override protected void Execute()
		{
			bool	fail = false;
			uint	titleID;
            string  writeUrl;

            // get file off of queue and write...
            if (XStoreTest.syncdXeClipFileQ.Count >= XStoreTest.MaxQueueLength)
            {
                try
                {
                    QueueUrlObject tempUrlObject = (QueueUrlObject)XStoreTest.syncdXeClipFileQ.Dequeue();
                    writeUrl = tempUrlObject.Url;
                    titleID = tempUrlObject.TitleId;
                }
                catch (InvalidOperationException)
                {
                    // if we fail to read, generate a new one to play with
                    titleID = (uint)XStoreTest.randomInstance.Next(1, (int)XStoreTest.numOfTitles);
                    string sTitleID = titleID.ToString("x");
                    ulong randomPartitionKeyValue = (ulong)(XStoreTest.randomInstance.NextDouble() * 0xffffffffffffffff);
                    writeUrl = "//xestats." + sTitleID + "/u:" + randomPartitionKeyValue.ToString("x") + "/" +
                        sTitleID + "/" + XStoreTest.randomInstance.Next().ToString("x");
                }
            }
            else
            {
                // if the queue is not full, generate a new one to play with
                titleID = (uint)XStoreTest.randomInstance.Next(1, (int)XStoreTest.numOfTitles);
                string sTitleID = titleID.ToString("x");
                ulong randomPartitionKeyValue = (ulong)(XStoreTest.randomInstance.NextDouble() * 0xffffffffffffffff);
                writeUrl = "//xestats." + sTitleID + "/u:" + randomPartitionKeyValue.ToString("x") + "/" +
                    sTitleID + "/" + XStoreTest.randomInstance.Next().ToString("x");
            }

            XRLWriteFile writeReq = new XRLWriteFile("Owner", writeUrl, XStoreTest.XenonClipFile, true);
			byte [] rand = new byte[(XStoreTest.XenonClipFile<8)? XStoreTest.XenonClipFile : 8];
			XStoreTest.rng.GetBytes(rand);
			rand.CopyTo(writeReq.blobData,0);

            if (writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
            {
                if (XStoreTest.syncdXeClipFileQ.Count < XStoreTest.MaxQueueLength)
                {
                    XStoreTest.syncdXeClipFileQ.Enqueue(new QueueUrlObject(titleID, writeUrl));
                }
            }
            else
            {
                XStoreTest.Safetw.WriteLine(DateTime.Now.ToString() + ":WriteFile request failed:" + writeReq.XErr.ToString("x"));
                fail = true;
            }

            if(!fail)
				ResultCode = TEST_RESULTS.PASSED;
		}
	}

    [StressInstantiate]
    public class StressXeStatsRead : TestBase
    {
        override protected void Execute()
        {
            bool fail = false;
            uint titleID;
            string readUrl;
            try
            {
                QueueUrlObject tempUrlObject = (QueueUrlObject)XStoreTest.syncdXeClipFileQ.Dequeue();
                readUrl = tempUrlObject.Url;
                titleID = tempUrlObject.TitleId;
            }
            catch (InvalidOperationException)
            {
                // if we fail to read, generate a new one to play with
                titleID = (uint)XStoreTest.randomInstance.Next(1, (int)XStoreTest.numOfTitles);
                string sTitleID = titleID.ToString("x");
                ulong randomPartitionKeyValue = (ulong)(XStoreTest.randomInstance.NextDouble() * 0xffffffffffffffff);
                readUrl = "//xestats." + sTitleID + "/u:" + randomPartitionKeyValue.ToString("x") + "/" +
                    sTitleID + "/" + XStoreTest.randomInstance.Next().ToString("x");

                XRLWriteFile writeReq = new XRLWriteFile("Owner", readUrl, XStoreTest.XenonClipFile, true);
                byte[] rand = new byte[(XStoreTest.XenonClipFile < 8) ? XStoreTest.XenonClipFile : 8];
                XStoreTest.rng.GetBytes(rand);
                rand.CopyTo(writeReq.blobData, 0);

                writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage));
            }

            XRLReadFileResponse readResp;
            XRLReadFile readReq = new XRLReadFile(readUrl);
            readReq.Slot.titleId = readReq.uiTitleId = titleID;
            if (!readReq.Execute(true, Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out readResp))
            {
                XStoreTest.Safetw.WriteLine(DateTime.Now.ToString() + ":ReadFile request failed:" + readReq.XErr.ToString("x"));
                fail = true;
            }
            if (XStoreTest.syncdXeClipFileQ.Count < XStoreTest.MaxQueueLength)
            {
                XStoreTest.syncdXeClipFileQ.Enqueue(new QueueUrlObject(titleID, readUrl));
            }

            if (!fail)
                ResultCode = TEST_RESULTS.PASSED;
        }
    }

    [StressInstantiate]
    public class StressXeStatsRemove : TestBase
    {
        override protected void Execute()
        {
            bool fail = false;
            uint titleID;
            string removeUrl;
            try
            {
                QueueUrlObject tempUrlObject = (QueueUrlObject)XStoreTest.syncdXeClipFileQ.Dequeue();
                removeUrl = tempUrlObject.Url;
                titleID = tempUrlObject.TitleId;
            }
            catch (InvalidOperationException)
            {
                // if we fail to read, generate a new one to play with
                titleID = (uint)XStoreTest.randomInstance.Next(1, (int)XStoreTest.numOfTitles);
                string sTitleID = titleID.ToString("x");
                ulong randomPartitionKeyValue = (ulong)(XStoreTest.randomInstance.NextDouble() * 0xffffffffffffffff);
                removeUrl = "//xestats." + sTitleID + "/u:" + randomPartitionKeyValue.ToString("x") + "/" +
                    sTitleID + "/" + XStoreTest.randomInstance.Next().ToString("x");

                XRLWriteFile writeReq = new XRLWriteFile("Owner", removeUrl, XStoreTest.XenonClipFile, true);
                byte[] rand = new byte[(XStoreTest.XenonClipFile < 8) ? XStoreTest.XenonClipFile : 8];
                XStoreTest.rng.GetBytes(rand);
                rand.CopyTo(writeReq.blobData, 0);

                writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage));
            }

            XRLRemoveFile removeReq = new XRLRemoveFile(removeUrl, titleID, "ServiceAddr");
            if (!removeReq.Execute())
            {
                XStoreTest.Safetw.WriteLine(DateTime.Now.ToString() + ":RemoveFile request failed:" + removeReq.XErr.ToString("x"));
                fail = true;
            }

            if (!fail)
                ResultCode = TEST_RESULTS.PASSED;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\StressUserTitle.cs ===
using System;
using System.Threading;
using System.Collections;
using System.Globalization;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Storage;
using xonline.common.config;

namespace XStoreTest
{
    [StressInstantiate]
	public class StressTUserWrite : TestBase
	{
		override protected void Execute()
		{
			string	writeUrl;
			bool	fail;
			uint	titleID;
			ulong	userPUID;
			fail = false;

            // get file off of queue and write...
            if (XStoreTest.syncdUserFileQ.Count >= XStoreTest.MaxQueueLength)
            {
                try
                {
                    QueueUrlObject tempUrlObject = (QueueUrlObject)XStoreTest.syncdUserFileQ.Dequeue();
                    writeUrl = tempUrlObject.Url;
                    titleID = tempUrlObject.TitleId;
                }
                catch (InvalidOperationException)
                {
                    // if we fail to read, generate a new one to play with
                    titleID = (uint)XStoreTest.randomInstance.Next(1, (int)XStoreTest.numOfTitles);
                    userPUID = (ulong)(XStoreTest.randomInstance.NextDouble() * 0xffffffffffffffff);
                    if (userPUID == 0)
                        userPUID = (ulong)(XStoreTest.randomInstance.NextDouble() * 0xffffffffffffffff);
                    string sTitleID = titleID.ToString("x"), sUserPUID = userPUID.ToString("x");
                    writeUrl = "//tuser." + sTitleID + "/u:" + sUserPUID + "/" + sTitleID + "/" + Guid.NewGuid().ToString();
                }
            }
            else
            {
                // if the queue is not full, generate a new one to play with
                titleID = (uint)XStoreTest.randomInstance.Next(1, (int)XStoreTest.numOfTitles);
                userPUID = (ulong)(XStoreTest.randomInstance.NextDouble() * 0xffffffffffffffff);
                if (userPUID == 0)
                    userPUID = (ulong)(XStoreTest.randomInstance.NextDouble() * 0xffffffffffffffff);
                string sTitleID = titleID.ToString("x"), sUserPUID = userPUID.ToString("x");
                writeUrl = "//tuser." + sTitleID + "/u:" + sUserPUID + "/" + sTitleID + "/" + Guid.NewGuid().ToString();
            }

            XRLWriteFile writeReq = new XRLWriteFile("Owner", writeUrl, XStoreTest.UserFile, true);
			byte [] rand = new byte[(XStoreTest.UserFile<8)? XStoreTest.UserFile : 8];
			XStoreTest.rng.GetBytes(rand);
			rand.CopyTo(writeReq.blobData,0);

            if (writeReq.Execute())
            {
                if (XStoreTest.syncdUserFileQ.Count < XStoreTest.MaxQueueLength)
                {
                    XStoreTest.syncdUserFileQ.Enqueue(new QueueUrlObject(titleID, writeUrl));
                }
            }
            else
            {
                XStoreTest.Safetw.WriteLine(DateTime.Now.ToString() + ":WriteFile request failed:" + writeReq.XErr.ToString("x"));
                fail = true;
            }

            if(!fail)
				ResultCode = TEST_RESULTS.PASSED;
		}
	}

    [StressInstantiate]
    public class StressTUserRead : TestBase
    {
        override protected void Execute()
        {
            string readUrl;
            bool fail;
            uint titleID;
            fail = false;

            try
            {
                QueueUrlObject tempUrlObject = (QueueUrlObject)XStoreTest.syncdUserFileQ.Dequeue();
                readUrl = tempUrlObject.Url;
                titleID = tempUrlObject.TitleId;
            }
            catch (InvalidOperationException)
            {
                titleID = (uint)XStoreTest.randomInstance.Next(1, (int)XStoreTest.numOfTitles);
                ulong userPUID = (ulong)(XStoreTest.randomInstance.NextDouble() * 0xffffffffffffffff);
                if (userPUID == 0)
                    userPUID = (ulong)(XStoreTest.randomInstance.NextDouble() * 0xffffffffffffffff);
                string sTitleID = titleID.ToString("x"), sUserPUID = userPUID.ToString("x");
                readUrl = "//tuser." + sTitleID + "/u:" + sUserPUID + "/" + sTitleID + "/" + Guid.NewGuid().ToString();
                XRLWriteFile writeReq = new XRLWriteFile("Owner", readUrl, XStoreTest.UserFile, true);
                byte[] rand = new byte[(XStoreTest.UserFile < 8) ? XStoreTest.UserFile : 8];
                XStoreTest.rng.GetBytes(rand);
                rand.CopyTo(writeReq.blobData, 0);

                writeReq.Execute();
            }

            XRLReadFileResponse readResp;
            XRLReadFile readReq = new XRLReadFile(readUrl);
            readReq.Slot.titleId = readReq.uiTitleId = titleID;
            //	readReq.Slot.titleVersion = readReq.uiTitleVersion = writeReq.uiTitleVersion;
            if (!readReq.Execute(true, Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out readResp))
            {
                XStoreTest.Safetw.WriteLine(DateTime.Now.ToString() + ":ReadFile request failed:" + readReq.XErr.ToString("x"));
                fail = true;
            }
            if (XStoreTest.syncdUserFileQ.Count < XStoreTest.MaxQueueLength)
            {
                XStoreTest.syncdUserFileQ.Enqueue(new QueueUrlObject(titleID, readUrl));
            }

            if (!fail)
                ResultCode = TEST_RESULTS.PASSED;
        }
    }

    [StressInstantiate]
    public class StressTUserRemove : TestBase
    {
        override protected void Execute()
        {
            string removeUrl;
            bool fail;
            uint titleID;
            fail = false;

            try
            {
                QueueUrlObject tempUrlObject = (QueueUrlObject)XStoreTest.syncdUserFileQ.Dequeue();
                removeUrl = tempUrlObject.Url;
                titleID = tempUrlObject.TitleId;
            }
            catch (InvalidOperationException)
            {
                titleID = (uint)XStoreTest.randomInstance.Next(1, (int)XStoreTest.numOfTitles);
                ulong userPUID = (ulong)(XStoreTest.randomInstance.NextDouble() * 0xffffffffffffffff);
                if (userPUID == 0)
                    userPUID = (ulong)(XStoreTest.randomInstance.NextDouble() * 0xffffffffffffffff);
                string sTitleID = titleID.ToString("x"), sUserPUID = userPUID.ToString("x");
                removeUrl = "//tuser." + sTitleID + "/u:" + sUserPUID + "/" + sTitleID + "/" + Guid.NewGuid().ToString();
                XRLWriteFile writeReq = new XRLWriteFile("Owner", removeUrl, XStoreTest.UserFile, true);
                byte[] rand = new byte[(XStoreTest.UserFile < 8) ? XStoreTest.UserFile : 8];
                XStoreTest.rng.GetBytes(rand);
                rand.CopyTo(writeReq.blobData, 0);

                writeReq.Execute();
            }

            XRLRemoveFile removeReq = new XRLRemoveFile(removeUrl, titleID, "Owner");
            if (!removeReq.Execute())
            {
                XStoreTest.Safetw.WriteLine(DateTime.Now.ToString() + ":RemoveFile request failed:" + removeReq.XErr.ToString("x"));
                fail = true;
            }
            if (!fail)
                ResultCode = TEST_RESULTS.PASSED;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\UnitTestsWriteFile.cs ===
using System;
using System.Net;
using System.Text;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Storage;
using xonline.common.config;
using System.Diagnostics;
using System.IO;
using System.Collections.Generic;

namespace XStoreTest
{

    internal  class WriteFilesHelper 
    {

        public static bool Send(string writeXrl, string hexTitleID, int fileExpirationDate, out XRLWriteFile[] writeReqs)
        {
            return Send(writeXrl, hexTitleID, fileExpirationDate, GetDataRandom(50), out writeReqs);
        }


        public static bool Send(string writeXrl, string hexTitleID, int fileExpirationDate, string fileName , out XRLWriteFile[] writeReqs)
        {
            return Send(writeXrl, hexTitleID, fileExpirationDate, GetDataFromFile(fileName) , out writeReqs);
        }


        public static bool Send(string writeXrl, string hexTitleID, int fileExpirationDate, byte[] data, out XRLWriteFile[] writeReqs)
        {

            Global.RO.Info("WriteFiles: XRL= " + writeXrl);
            return WriteFilesSend(hexTitleID, writeXrl, 1, fileExpirationDate, data , out writeReqs);
        }




        protected static bool WriteFilesSend(string hexTitleID, string xrl, uint numFiles, int fileExpirationDate, byte[] data, out XRLWriteFile[] writeReqs)
        {
            writeReqs = new XRLWriteFile[numFiles];
          

            // write files for this title
            for (int i = 0; i < numFiles; i++)
            {
                writeReqs[i] = new XRLWriteFile("ServiceAddr", xrl);
                writeReqs[i].accessToken.writeAT.fileExpirationDate = fileExpirationDate;
                if (i % 2 == 0)
                {
                    writeReqs[i].blobData = data;
                    writeReqs[i].blobDataLen = (uint)data.Length;
                    writeReqs[i].uiBlobSizeCompressed = (uint)data.Length; ;

                    writeReqs[i].attributes = GetDataRandom(50);
                    writeReqs[i].attributesLen = 50;
                }
                if (!writeReqs[i].Execute())
                {
                    Global.RO.Warn("WriteFile request failed: 0x" + writeReqs[i].XErr.ToString("x"));
                    return false;
                }
            }
            return true;
        }

        public static bool WriteFilesSend(string hexTitleID, string xrl, uint numFiles, int fileExpirationDate, out XRLWriteFile[] writeReqs)
        {
            return WriteFilesSend(hexTitleID, xrl, numFiles, fileExpirationDate, GetDataRandom(50), out writeReqs);
        }



        public static byte[] GetDataRandom(int length)
        {
            byte[] data = new byte[length];

            new Random().NextBytes(data);

            return data;
        }

        public static byte[] GetDataFromFile(string fileName)
        {
            //Sample FIleName = "C:\\ESP\\titlevault\\ffff0072\\halo2.png"
            FileStream fs = new FileStream(fileName, FileMode.Open);
            long FileSize = fs.Length;


            byte[] Buffer = new byte[(int)FileSize];
            fs.Read(Buffer, 0, (int)FileSize);
            fs.Close();

            return Buffer;
        }

    }

    internal  class EnumerateFilesHelper 
    {

        public  static bool Send(uint titleID, string enumXrl, uint expectedFilesTotal, uint expectedFilesReturn, bool checkEachFile, long modifiedSince, XRLWriteFile[] writeReqs, int numOfCalls)
        {
            XRLEnumFiles enumReq = new XRLEnumFiles(enumXrl, titleID, 0, 1, modifiedSince);

            Global.RO.Info("EnumFiles: XRL= " + enumXrl);

            for (int i = 1; i < numOfCalls; i++)
            {
                if (!EnumFilesSendMeasured(enumReq, writeReqs, expectedFilesTotal, expectedFilesReturn, checkEachFile))
                    return false;

            }

            return true;
        }


        private static bool EnumFilesSendMeasured(XRLEnumFiles enumReq, XRLWriteFile[] writeReqs, uint expectedFilesTotal, uint expectedFilesReturn, bool checkEachFile )
        {
            TimeSpan firstCallDuration;

            DateTime beforeFirstCall, afterFirstCall;
            firstCallDuration = new TimeSpan(0);


            beforeFirstCall = DateTime.Now;
            if (!EnumFilesSend(enumReq, writeReqs, expectedFilesTotal, expectedFilesReturn, checkEachFile))
                return false;
            afterFirstCall = DateTime.Now;
            firstCallDuration = afterFirstCall - beforeFirstCall;

            Global.RO.Info("EnumFiles: Time taken for API calls = " + firstCallDuration);

            return true;

        }

        private static bool EnumFilesSend(XRLEnumFiles enumReq, XRLWriteFile[] writeReqs, uint expectedFilesTotal, uint expectedFilesReturn, bool checkEachFile)
        {
            XRLEnumFilesResponse enumResp;
            bool callResult = enumReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out enumResp);

            if (callResult)
            {

                //Log results:
                XRLSingleEnumFileResult result;
                //Global.RO.Info("EnumFile response: NumofFiles = " + enumResp.numFilesTotal.ToString());
                for (int i = 0; i < enumResp.results.Length; i++)
                {
                    result = enumResp.results[i];
                    //Global.RO.Info(String.Format("EnumFile response: File[{1}]: CreationDate={2}", DateTime.Now.ToString(), i, result.lCreationDate));
                    //Global.RO.Info(String.Format("EnumFile response: File[{1}]: ModificationDate={2}", DateTime.Now.ToString(), i, result.lModifiedDate));

                }

                uint respNumFilesTotal = enumResp.numFilesTotal;
                uint respResultsLen = enumResp.resultsLen;

                if (enumResp.numFilesTotal != expectedFilesTotal)
                {
                    Global.RO.Warn(String.Format("numFilesTotal is not correct Expected={0} , Actual={1}", expectedFilesTotal, enumResp.numFilesTotal));
                    return false;
                }
                if (enumResp.resultsLen != expectedFilesReturn)
                {
                    Global.RO.Warn(String.Format("numFiles returned is not correct - Expected={0} , Actual={1}", expectedFilesReturn, enumResp.resultsLen));
                    return false;
                }
                // check each returned file
                if (checkEachFile)
                {
                    for (int i = 0; i < expectedFilesReturn; i++)
                    {
                        if (!enumResp.results[i].Compare(writeReqs[i]))
                        {
                            Global.RO.Warn("The returned file is not correct");
                            return false;
                        }
                    }
                }
                return true;
            }
            else
            {
                Global.RO.Warn("Failed send EnumFiles request");
                return false;
            }
        }

    }

    internal class PerfCounterHelper
    {
        // added machine name so we aren't connecting to the local machine to find counters on the storage FD...
        public static PerformanceCounter GetCounter(string machineName, string categoryName, string counterName, string instanceName)
        {
            PerformanceCounter perfCounter;

            ValidateCounterDefinition(machineName, counterName, categoryName);
            
            //Get the current PerfCOunterr Instance if it already exists
            if (PerformanceCounterCategory.InstanceExists(instanceName, categoryName, machineName))
            {
                perfCounter = new PerformanceCounter(categoryName, counterName, instanceName, machineName);
            }
            else
            {
                //Need to create this instance

                perfCounter = new PerformanceCounter();

                // Have to use default constructor and then set these fields. Can't do 
                // InstanceLifetime any other way.
                perfCounter.MachineName = machineName;
                perfCounter.CategoryName = categoryName;
                perfCounter.CounterName = counterName;
                perfCounter.InstanceName = instanceName;
                perfCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Global;
                perfCounter.ReadOnly = false;

                //Set this last
                perfCounter.RawValue = 0;

            }

            return perfCounter;

        }

        public static void ValidateCounterDefinition(string machineName, string counterName, string categoryName)
        {
            if (!PerformanceCounterCategory.CounterExists(counterName, categoryName, machineName))
            {
                string message = String.Format("Failed to create performance counter wrapper on {0}. " +
                        "The counters may have not been installed correctly. Verify if the user " +
                        "account used by the service has enough permissions.", machineName);

                throw new ArgumentException(message);

            }
        }
    }


    [TestGroup, Owner("JKonkle"), TestFrequency("Regression"), TestCasePriority(1)]
    class UnitTestsWriteFiles : TestNode
    {

        [TestCase, Description("UnitTest - WriteFile - Title domain")]
        class PWFTitleDomain : TestBase
        {
            override protected void Execute()
            {

                //uint TitleID = (uint)new Random().Next();
                //uint TitleID = (uint)Convert.ToUInt32("0xfffe07d1", 16);              
                //long modifiedSince = (long)System.DateTime.UtcNow.AddHours(-1).ToFileTimeUtc();
                //string enumXrl = "//title." + hexTitleID + "/t:" + hexTitleID + "/*";

                uint TitleID = 0xfffe07d1; //4294838225
                string hexTitleID = TitleID.ToString("x");

                string fileName = "/mediasite.xzp";
                string writeXrl = "//title." + hexTitleID + "/t:" + hexTitleID + fileName;
                string enumXrl = "//title." + hexTitleID + "/t:" + hexTitleID + fileName;

                XRLRemoveFile removeReq = new XRLRemoveFile(enumXrl, TitleID, "ServiceAddr");
                removeReq.Execute();

                XRLWriteFile[] writeReqs;
                try
                {
                    if (WriteFilesHelper.Send(writeXrl, hexTitleID, 0, out writeReqs))
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("Failed to write to Title Domain: {0}-{1}", e.Source, e.Message);
                }
            }


        }


        [TestCase, Description("UnitTest - WriteFile - Msg domains")]
        class PWFMsgDomain : TestBase
        {
            override protected void Execute()
            {

                //uint TitleID = (uint)new Random().Next();
                //uint TitleID = (uint)Convert.ToUInt32("0xfffe07d1", 16);              
                //long modifiedSince = (long)System.DateTime.UtcNow.AddHours(-1).ToFileTimeUtc();
                //string enumXrl = "//title." + hexTitleID + "/t:" + hexTitleID + "/*";

                uint TitleID = 0xfffe07d1; //4294838225
                string hexTitleID = TitleID.ToString("x");

                string fileName = "/voicemail1.mp3";
                string writeXrl = "//msg." + hexTitleID + "/t:" + hexTitleID + fileName;
                string enumXrl = "//msg." + hexTitleID + "/t:" + hexTitleID + fileName;

                //MSG won't overwrite by default in TestNet so it must be removed to be re-runnable
                XRLRemoveFile removeReq = new XRLRemoveFile(enumXrl, TitleID, "ServiceAddr");
                removeReq.Execute();

                XRLWriteFile[] writeReqs;
                try
                {
                    if (WriteFilesHelper.Send(writeXrl, hexTitleID, 0, out writeReqs))
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("Failed to write to Msg Domain: {0}-{1}", e.Source, e.Message);    
                }
            }


        }


        [TestCase, Description("UnitTest - WriteFile - Simulate API failure and measure PerfCounters")]
        class PWFPerfCounterFailure : TestBase
        {
            override protected void Execute()
            {

                uint TitleID = 0xfffe07d1; //4294838225
                string hexTitleID = TitleID.ToString("x");

                string fileName = "/mediasite.xzp";
                string writeXrl = "//title." + hexTitleID + "/t:" + hexTitleID + fileName;

                string categoryName = "Xbox Live Storage Service";
                string counterName = "WriteFile Current Requests";
                string counterName2 = "WriteFile Total Requests";
                string instanceName = "_total_";

                // JK: This really needs to find the STFD servers and not assume that the STFD are on the local machine...
                string[] servers = Config.GetServerListByInterface(Interface.stfd_storage);

                List<PerformanceCounter> CurrentReqCounter = new List<PerformanceCounter>(servers.Length);
                List<PerformanceCounter> TotalReqCounter = new List<PerformanceCounter>(servers.Length);
                long startTotalReq = 0;

                for (int i = 0; i < servers.Length;i++)
                {
                    CurrentReqCounter.Add(PerfCounterHelper.GetCounter(servers[i], categoryName, counterName, instanceName));
                    Global.RO.Info(CurrentReqCounter[i].RawValue.ToString());
                    TotalReqCounter.Add(PerfCounterHelper.GetCounter(servers[i], categoryName, counterName2, instanceName));
                    Global.RO.Info(TotalReqCounter[i].RawValue.ToString());
                    startTotalReq += TotalReqCounter[i].RawValue;
                }

                XRLWriteFile[] writeReqs;

                if (!WriteFilesHelper.Send(writeXrl, hexTitleID, 0, out writeReqs))
                {
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }

                //Global.RO.Warn(String.Format("WriteFile : Counter '{0}' = {1} ", counterName2, perfCounter2.RawValue.ToString()));
                long CurrentReqCnt=0;
                long TotalReqCnt = 0;
                for (int i = 0; i < servers.Length; i++)
                {
                    CurrentReqCnt += CurrentReqCounter[i].RawValue;
                    TotalReqCnt += TotalReqCounter[i].RawValue;
                }
                TotalReqCnt -= startTotalReq;
                if (TotalReqCnt != 1)
                {
                    Global.RO.Error("Total Request Count = {0}.  Should be 1.", TotalReqCnt);
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }

                if (CurrentReqCnt != 0)
                {
                    Global.RO.Error("Current Request Count = {0}.  Should be 0.", TotalReqCnt);
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }

                ResultCode = TEST_RESULTS.PASSED;
            }



        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\UnitAvatarRegEx.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using System.Text.RegularExpressions;
using xonline.common.config;

namespace XStoreTest
{
    [TestGroup, Owner("jkonkle"), TestFrequency("Regression"), TestCasePriority(1)]
    public class UnitAvatarRegEx : TestNode
    {
        //static string filePathRegexSpec = @"/(?<domain>\w+)/(?:((?<gamertag>(\w+\s*)*)|(?<keytype>[u]).(?<keyval>[0-9a-fA-F]{1,16})|(?<keytype>[t]).(?<keyval>[0-9a-fA-F]{1,8})))(?<path>/[^\p{Cc}]+)$";

        [CompoundCase("Tile1", "/global/t.54540817/tile/0/f10016", "global", "", "t", "54540817", "/tile/0/f10016")]
        [CompoundCase("Tile2", "/global/t.415607f2/tile/0/2000e", "global", "", "t", "415607f2", "/tile/0/2000e")]
        [CompoundCase("Avatar1", "/avatar/TestGuy/avatarpic-l.png", "avatar", "TestGuy", "", "", "/avatarpic-l.png")]
        [TestCase, Description("Check the avatar RegEx expression")]
        public class PCheckAvatarRegEx : TestBase
        {
            override protected void Execute()
            {
                string filePathRegexSpec = Global.XEnv.GetSetting(Setting.storageModule_urlPathRegEx);
                Regex FilePathRegex = new Regex(filePathRegexSpec, RegexOptions.IgnoreCase | RegexOptions.Compiled);

                Match pathMatch = FilePathRegex.Match((string)MyValues[0]);

                if (!pathMatch.Success)
                {
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }

                if ((String.IsNullOrEmpty(pathMatch.Groups["domain"].Value) || pathMatch.Groups["domain"].Value != (string)MyValues[1]) ||
                    (pathMatch.Groups["gamertag"].Value != (string)MyValues[2]) ||
                    (pathMatch.Groups["keytype"].Value != (string)MyValues[3]) ||
                    (pathMatch.Groups["keyval"].Value != (string)MyValues[4]) ||
                    (String.IsNullOrEmpty(pathMatch.Groups["path"].Value) || pathMatch.Groups["path"].Value != (string)MyValues[5]))
                {
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }

                ResultCode = TEST_RESULTS.PASSED;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\UnitTestsAvatar.cs ===
using System;
using System.Net;
using System.Text;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Storage;
using xonline.common.config;
using System.Diagnostics;

using live.common;
//using XblUser=live.common.XblUser;
using live.lfm;
using live.server;
using System.IO;
using ServerTestFramework.LiveService.UserAccount;
using System.Collections.Generic;

namespace XStoreTest
{


    [TestGroup, Owner("jkonkle"), TestFrequency("Regression"), TestCasePriority(1)]
    public class UnitTestsAvatarWriteFiles : TestNode
    {

        [TestCase, Description("UnitTest - Avatar WriteFile - Path Gamertag")]
        public class PWFAvatarE2E : TestBase
        {
            override protected void Execute()
            {
                string file = @"suites\halo2.png";
                string readUrl = "";

                string storageFileName = "Avatarpic-l.png";
                ResultCode = ExecuteTestCase(file, storageFileName, out readUrl);

                AvatarHelper.LaunchIE(readUrl);
            }

            public static TEST_RESULTS ExecuteTestCase(string inFileName, string storageFileName, out string readURL)
            {
                TEST_RESULTS result = TEST_RESULTS.FAILED;
                readURL = "";

                //Create User
                XeUser user = new XeUser();
                user.Create();
                string XUID = user.UserPuid.ToString("X");
                string GamerTag = user.Gamertag;

                Global.RO.Info(string.Format("Created User- Gamertag: {0} , XUID: {1}", GamerTag, XUID));

                uint TitleID = 0xfffe07d1; //4294838225
                string hexTitleID = TitleID.ToString("x");
                string writeXrl = String.Format("//avatar/u:{0}/{1}", XUID, storageFileName);

                XRLWriteFile[] writeReqs;
                if (!WriteFilesHelper.Send(writeXrl, hexTitleID, 0, inFileName, out writeReqs))
                {
                    result = TEST_RESULTS.FAILED;
                    Global.RO.Error("Failed to write Avatar.");
                    return result;
                }

                Global.RO.Info(string.Format(" URL to read from - \n {0}  ", readURL));
                readURL = AvatarHelper.GetReadURLAvatar(GamerTag, ("/" + storageFileName));
                Global.RO.Info(readURL);
                Global.RO.Info(string.Format(" Sleeping for 30 sec - Waiting for XCache to pick up the user info ...."));
                Thread.Sleep(30000);
                if (AvatarHelper.CheckFileExists(readURL))
                {
                    result = TEST_RESULTS.PASSED;
                }
                return result;
            }
        }

        [TestCase, Description("UnitTest - Avatar WriteFile - Cache invalidation")]
        public class PWFAvatarCaching : TestBase
        {
            override protected void Execute()
            {
                string file = @"suites\halo2.png";
                string file2 = @"suites\win.png";
                string readUrl = "";

                string storageFileName = "Avatarpic-l.png";
                ResultCode = ExecuteTestCase(file, file2, storageFileName, out readUrl);

                AvatarHelper.LaunchIE(readUrl);
            }

            public static TEST_RESULTS ExecuteTestCase(string FileName, string FileName2, string storageFileName, out string readURL)
            {
                TEST_RESULTS result = TEST_RESULTS.FAILED;
                readURL = "";

                //Create User
                XeUser user = new XeUser();
                user.Create();
                string XUID = user.UserPuid.ToString("X");
                string GamerTag = user.Gamertag;
                Global.RO.Info(string.Format("Created User- Gamertag: {0} , XUID: {1}", GamerTag, XUID));

                uint TitleID = 0xfffe07d1; //4294838225
                string hexTitleID = TitleID.ToString("x");
                string writeXrl = String.Format("//avatar/u:{0}/{1}", XUID, storageFileName);
                
                XRLWriteFile[] writeReqs;
                if (!WriteFilesHelper.Send(writeXrl, hexTitleID, 0, FileName, out writeReqs))
                {
                    result = TEST_RESULTS.FAILED;
                    Global.RO.Error("Failed to write Avatar.");
                    return result;
                }

                Global.RO.Info(string.Format(" URL to read from - \n {0}  ", readURL));
                readURL = AvatarHelper.GetReadURLAvatar(GamerTag, ("/" + storageFileName));
                Global.RO.Info(readURL);

                Global.RO.Info(string.Format(" Sleeping for 30 sec - Waiting for XCache to pick up the user info ...."));
                Thread.Sleep(30000);
                DateTime lastMod = DateTime.Now.AddYears(-1);
                if (!AvatarHelper.CompareFile(readURL, WriteFilesHelper.GetDataFromFile(FileName), ref lastMod))
                {
                    Global.RO.Fatal("Original image does not match file!");
                    return result;
                }

                Global.RO.Info("Writing new image after initial pull.");
                if (!WriteFilesHelper.Send(writeXrl, hexTitleID, 0, FileName2, out writeReqs))
                {
                    result = TEST_RESULTS.FAILED;
                    Global.RO.Error("Failed to write Avatar - File2.");
                    return result;
                }
                if (!AvatarHelper.CompareFile(readURL, WriteFilesHelper.GetDataFromFile(FileName2), ref lastMod))
                {
                    Global.RO.Fatal("Overwrite image does not match file in storage!");
                    return result;
                }

                result = TEST_RESULTS.PASSED;
                return result;
            }
        }
      
        [TestCase, Description("UnitTest - Avatar default images")]
        public class PDefaultImages : TestBase
        {
            override protected void Execute()
            {
                ResultCode = ExecuteTestCase();
            }

            public static TEST_RESULTS ExecuteTestCase()
            {
                TEST_RESULTS result = TEST_RESULTS.FAILED;
                string readURL = "";

                //Create User
                //XblUser user = TestUser.Create();
                XeUser user = new XeUser();
                user.Create();
                string XUID = user.UserPuid.ToString("X");
                string GamerTag = user.Gamertag;

                Global.RO.Info(string.Format("Created User- Gamertag: {0} , XUID: {1}", GamerTag, XUID));
                Global.RO.Info(string.Format(" Sleeping for 30 sec - Waiting for XBanc to pick up the user info ...."));
                Thread.Sleep(30000);
                
                readURL = AvatarHelper.GetReadURLAvatar(GamerTag, ("/avatar-body.png")  );
                Global.RO.Info(string.Format(" URL to read from - \n {0}  ", readURL));
                if (!AvatarHelper.CheckFileExists(readURL))
                {
                    result = TEST_RESULTS.FAILED;
                    return result;
                }
                readURL = AvatarHelper.GetReadURLAvatar(GamerTag, ("/avatarpic-s.png")  );
                Global.RO.Info(string.Format(" URL to read from - \n {0}  ", readURL));
                if (!AvatarHelper.CheckFileExists(readURL))
                {
                    result = TEST_RESULTS.FAILED;
                    return result;
                }
                readURL = AvatarHelper.GetReadURLAvatar(GamerTag, ("/avatarpic-l.png")  );
                Global.RO.Info(string.Format(" URL to read from - \n {0}  ", readURL));
                if (!AvatarHelper.CheckFileExists(readURL))
                {
                    result = TEST_RESULTS.FAILED;
                    return result;
                }

                return TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("UnitTest - Avatar default images")]
        public class PDefaultImageNonexistTag : TestBase
        {
            override protected void Execute()
            {
                ResultCode = ExecuteTestCase();
            }

            public static TEST_RESULTS ExecuteTestCase()
            {
                TEST_RESULTS result = TEST_RESULTS.FAILED;
                string readURL = "";

                string GamerTag = "ThisUserNotHere";

                readURL = AvatarHelper.GetReadURLAvatar(GamerTag, ("/avatar-body.png"));
                Global.RO.Info(string.Format(" URL to read from - \n {0}  ", readURL));
                if (!AvatarHelper.CheckFileExists(readURL))
                {
                    result = TEST_RESULTS.FAILED;
                    return result;
                }
                readURL = AvatarHelper.GetReadURLAvatar(GamerTag, ("/avatarpic-s.png"));
                Global.RO.Info(string.Format(" URL to read from - \n {0}  ", readURL));
                if (!AvatarHelper.CheckFileExists(readURL))
                {
                    result = TEST_RESULTS.FAILED;
                    return result;
                }
                readURL = AvatarHelper.GetReadURLAvatar(GamerTag, ("/avatarpic-l.png"));
                Global.RO.Info(string.Format(" URL to read from - \n {0}  ", readURL));
                if (!AvatarHelper.CheckFileExists(readURL))
                {
                    result = TEST_RESULTS.FAILED;
                    return result;
                }

                return TEST_RESULTS.PASSED;
            }
        }


        [TestCase, Description("UnitTest - Read Title pics via Gateway")]
        public class PWFReadTitlePics : TestBase
        {
            override protected void Execute()
            {
                string readUrl = "";

                uint TitleID = 0xfffe07d1; //4294838225
                string hexTitleID = TitleID.ToString("x");

                string storageFileName = "tile/0/11069";
                ResultCode = ExecuteTestCase(hexTitleID, storageFileName, out readUrl);

                AvatarHelper.LaunchIE(readUrl);

            }

            public static TEST_RESULTS ExecuteTestCase(string hexTitleID, string storageFileName, out string readURL)
            {
                TEST_RESULTS result = TEST_RESULTS.FAILED;
                readURL = "";

                string domain = "/global";
                string qualifier = "/t:" + hexTitleID;

                string writeXrl = "/" + domain + qualifier + "/" + storageFileName;


                readURL = AvatarHelper.GetReadURLGlobal(hexTitleID, ("/" + storageFileName));
                Global.RO.Info(string.Format(" URL to read from - \n {0}  ", readURL));


                if (AvatarHelper.CheckFileExists(readURL))
                {
                    result = TEST_RESULTS.PASSED;
                }
                return result;
            }
        }

        [TestCase, Description("UnitTest - 304 Not Modified")]
        public class PWF304NotModified : TestBase
        {
            override protected void Execute()
            {
                string file = @"suites\halo2.png";
                string readUrl = "";

                string storageFileName = "Avatarpic-l.png";
                ResultCode = ExecuteTestCase(file, storageFileName, out readUrl);

                
            }

            public static TEST_RESULTS ExecuteTestCase(string inFileName, string storageFileName, out string readURL)
            {
                TEST_RESULTS result = TEST_RESULTS.FAILED;
                readURL = "";

                //Create User
                XeUser user = new XeUser();
                user.Create();
                string XUID = user.UserPuid.ToString("X");
                string GamerTag = user.Gamertag;

                Global.RO.Info(string.Format("Created User- Gamertag: {0} , XUID: {1}", GamerTag, XUID));

                uint TitleID = 0xfffe07d1; //4294838225
                string hexTitleID = TitleID.ToString("x");
                string writeXrl = String.Format("//avatar/u:{0}/{1}", XUID, storageFileName);

                XRLWriteFile[] writeReqs;
                if (!WriteFilesHelper.Send(writeXrl, hexTitleID, 0, inFileName, out writeReqs))
                {
                    result = TEST_RESULTS.FAILED;
                    Global.RO.Error("Failed to write Avatar.");
                    return result;
                }

                Global.RO.Info(string.Format(" URL to read from - \n {0}  ", readURL));
                readURL = AvatarHelper.GetReadURLAvatar(GamerTag, ("/" + storageFileName));
                Global.RO.Info(readURL);
                Global.RO.Info(string.Format(" Sleeping for 30 sec - Waiting for XCache to pick up the user info ...."));
                Thread.Sleep(30000);
                if (AvatarHelper.CheckFileExists(readURL))
                {
                    Dictionary<string, string> headers = new Dictionary<string, string>();
                    headers.Add("If-Modified-Since", DateTime.Now.ToString());
                    if (AvatarHelper.CheckFile(readURL, headers, "304"))
                    {
                        result = TEST_RESULTS.PASSED;
                    }
                }
                return result;
            }
        }


        [TestCase, Description("Negative UnitTest - Try to read achievements via Gateway"), TestCasePriority(2)]
        public class NWFReadTitlePics : TestBase
        {
            override protected void Execute()
            {
                string readUrl = "";

                uint TitleID = 0xfffe07d1; //4294838225
                string hexTitleID = TitleID.ToString("x");

                string storageFileName = "ach/1/20080826180232";
                ResultCode = ExecuteTestCase(hexTitleID, storageFileName, out readUrl);
            }

            public static TEST_RESULTS ExecuteTestCase(string hexTitleID, string storageFileName, out string readURL)
            {
                TEST_RESULTS result = TEST_RESULTS.FAILED;
                readURL = "";

                string domain = "/global";
                string qualifier = "/t:" + hexTitleID;

                string writeXrl = "/" + domain + qualifier + "/" + storageFileName;


                readURL = AvatarHelper.GetReadURLGlobal(hexTitleID, ("/" + storageFileName));
                Global.RO.Info(string.Format(" URL to read from - \n {0}  ", readURL));

                if (!AvatarHelper.CheckFileExists(readURL))
                {
                    result = TEST_RESULTS.PASSED;
                }
                return result;
            }
        }
    }

    public static class AvatarHelper
    {
        public static string GetReadURLAvatar(string GamerTag, string fileName)
        {
            string urlPath = "/avatar/" + GamerTag + fileName;

            IPEndPoint stfd = new IPEndPoint(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).Address,
                                                Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).Port);

            IPEndPoint authSG = new IPEndPoint(Global.XEnv.GetVirtualInterface(VirtualInterface.authsg).Address,
                                                Global.XEnv.GetVirtualInterface(VirtualInterface.authsg).Port);

            //ToDO: Port seems to be returned as 80 instead of 13100(value in NPDB).
            // Changed this back to not use 13100 since it should be hitting port 80.
            string webAddress = authSG.Address.ToString() + ":" + authSG.Port.ToString(); // +":13100";


            string readURL = "http://" + webAddress + urlPath;
            return readURL;
        }

        public static string GetReadURLGlobal(string hexTitleID, string fileName)
        {
            string urlPath = "/global/" + "t." + hexTitleID + fileName;

            IPEndPoint stfd = new IPEndPoint(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).Address,
                                                Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage).Port);

            IPEndPoint authSG = new IPEndPoint(Global.XEnv.GetVirtualInterface(VirtualInterface.authsg).Address,
                                                Global.XEnv.GetVirtualInterface(VirtualInterface.authsg).Port);

            //ToDO: Port seems to be returned as 80 instead of 13100(value in NPDB) 
            // Changed this back since it should be hitting port 80
            string webAddress = authSG.Address.ToString() + ":" + authSG.Port.ToString(); // +":13100";


            string readURL = "http://" + webAddress + urlPath;
            return readURL;
        }

        public static bool CheckFile(string readUrl, Dictionary<string, string> headers, string expectedResponse)
        {
            bool found = false;
            try
            {
                System.Net.Cache.RequestCachePolicy policy = new System.Net.Cache.RequestCachePolicy(System.Net.Cache.RequestCacheLevel.BypassCache);
                WebRequest request = WebRequest.Create(readUrl);
                request.CachePolicy = policy;

                // We can't add the "If-Modified-Since" header directly.  It only allows access via the HttpWebRequest object as a DATETIME!!! <GRR>
                if (headers.ContainsKey("If-Modified-Since"))
                {
                    ((HttpWebRequest)request).IfModifiedSince = DateTime.Parse(headers["If-Modified-Since"]);
                    headers.Remove("If-Modified-Since");
                }
                
                foreach (KeyValuePair<string,string> header in headers)
                {
                    request.Headers.Add(header.Key, header.Value);
                }

                using (WebResponse response = request.GetResponse())
                {
                    using (Stream rcvStrm = response.GetResponseStream())
                    {
                        Encoding encode = System.Text.Encoding.GetEncoding("utf-8");
                        using (StreamReader readStream = new StreamReader(rcvStrm, encode))
                        {
                            string line;
                            while ((line = readStream.ReadLine()) != null)
                            {
                                found = found || line.Contains(expectedResponse);
                            }
                        }
                    }
                }
            }
            catch (System.Net.WebException e)
            {
                if (e.Message.Contains(expectedResponse))
                {
                    return true;
                }
                Global.RO.Info(e.Message);
                return false;
            }

            return found;
        }

        public static bool CheckFileExists(string readUrl)
        {
            return CheckFileExists(readUrl, new Dictionary<string, string>());
        }

        public static bool CheckFileExists(string readUrl, Dictionary<string, string> headers)
        {
            try
            {
                System.Net.Cache.RequestCachePolicy policy = new System.Net.Cache.RequestCachePolicy(System.Net.Cache.RequestCacheLevel.BypassCache);
                WebRequest request = WebRequest.Create(readUrl);
                request.CachePolicy = policy;
                foreach (KeyValuePair<string, string> header in headers)
                {
                    request.Headers.Add(header.Key, header.Value);
                }

                using (WebResponse response = request.GetResponse())
                {
                    using (Stream rcvStrm = response.GetResponseStream())
                    {
                        if (!response.ContentType.Contains("png"))
                        {
                            Global.RO.Fatal("Content type incorrect (should be image/png): {0}", response.ContentType);
                            return false;
                        }
                    }
                }
            }
            catch (System.Net.WebException e)
            {
                Global.RO.Info(e.Message);
                return false;
            }
            
            return true;
        }

        public static bool CompareFile(string readUrl, byte[] file, ref DateTime lastModified)
        {
            try
            {
                System.Net.Cache.RequestCachePolicy policy = new System.Net.Cache.RequestCachePolicy(System.Net.Cache.RequestCacheLevel.BypassCache);
                WebRequest request = WebRequest.Create(readUrl);
                if (lastModified != null)
                {
                    ((HttpWebRequest)request).IfModifiedSince = lastModified;
                }
                request.CachePolicy = policy;

                using (WebResponse response = request.GetResponse())
                {
                    lastModified = ((HttpWebResponse)response).LastModified;
                    using (Stream rcvStrm = response.GetResponseStream())
                    {

                        if (!response.ContentType.Contains("png"))
                        {
                            Global.RO.Fatal("Content type incorrect (should be image/png): {0}", response.ContentType);
                            return false;
                        }

                        using (BinaryReader readStream = new BinaryReader(rcvStrm))
                        {
                            byte[] httpFile = readStream.ReadBytes(file.Length);

                            for (int i = 0; i < file.Length; i++)
                            {
                                if (httpFile[i] != file[i])
                                {
                                    Global.RO.Fatal("CompareFile: HTTP and local file do not match!");
                                    return false;
                                }
                            }
                        }
                    }
                }
            }
            catch (System.Net.WebException e)
            {
                Global.RO.Info(e.Message);
                return false;
            }
            
            return true;
        }

        public static void LaunchIE(string url)
        {
            //string fileName = "C:\Program Files\Internet Explorer\iexplore.exe";
            Global.RO.Info(string.Format(" Launching  ...." + url));
            Process.Start(url);

        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XUATest\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xstoretest_none_12.4.56.0_none_05748e6faba3b1c2
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xstoretest_no-public-key_12.4.56.0_x-ww_5647a7de
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xstoretest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xstoretest_no-public-key_12.4.56.0_x-ww_5647a7de
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xstoretest_no-public-key_12.4.56.0_x-ww_5647a7de.manifest
XP_MANIFEST_PATH=manifests\msil_xstoretest_no-public-key_12.4.56.0_x-ww_5647a7de.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xstoretest_no-public-key_12.4.56.0_x-ww_5647a7de.cat
XP_CATALOG_PATH=manifests\msil_xstoretest_no-public-key_12.4.56.0_x-ww_5647a7de.cat
XP_PAYLOAD_PATH=msil_xstoretest_no-public-key_12.4.56.0_x-ww_5647a7de
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xstoretest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xstoretest_none_12.4.56.0_none_05748e6faba3b1c2
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xstoretest_no-public-key_12.4.56.0_x-ww_5647a7de
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xstoretest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xstoretest_no-public-key_12.4.56.0_x-ww_5647a7de
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xstoretest_no-public-key_12.4.56.0_x-ww_5647a7de.manifest
XP_MANIFEST_PATH=manifests\msil_xstoretest_no-public-key_12.4.56.0_x-ww_5647a7de.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xstoretest_no-public-key_12.4.56.0_x-ww_5647a7de.cat
XP_CATALOG_PATH=manifests\msil_xstoretest_no-public-key_12.4.56.0_x-ww_5647a7de.cat
XP_PAYLOAD_PATH=msil_xstoretest_no-public-key_12.4.56.0_x-ww_5647a7de
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xstoretest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XStoreTest\XStoreTest.cs ===
using System;
using System.IO;
using System.Xml;
using System.Collections;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using ServerTestFramework;
using ServerTestFramework.LiveService.Storage;
using xonline.common.config;

using XOn = ServerTestFramework.LiveService.XOn;

[assembly: RootNode(typeof(XStoreTest.XStoreTest))]

namespace XStoreTest
{
    [Owner("maliagu"), TestFrequency("Regression"), TestCasePriority(3)]
    public class XStoreTest : TestNode
    {
        public XStoreTest()
        {
            //stress
            foreach (System.Type t in GetStressTests())
            {
                TestNode n=TestNode.ConstructFromType(t);
                n.Name="XStoreTest "+n.Name;
                AddChild(n, false, true);
            }
        }

        /************************************************************************
         * These are for functional tests
         ************************************************************************/


        /************************************************************************
         * These are for stress tests
         ************************************************************************/
        public const    uint    MaxQueueLength = 1000;
        public static    uint    XboxClipPreloadFiles = 0, UserPreloadFiles = 0, TeamPreloadFiles = 0,
                                MsgPreloadFiles = 0, TitlePreloadFiles = 0, CrossTitlePreloadFiles=0, XenonClipPreloadFiles=0, AvatarPreloadFiles=0;
        public static    uint    XboxClipFile = 0,TitleFile =0, UserFile = 0, TeamFile = 0, MsgFile = 0, CrossTitleFile = 0, XenonClipFile=0, AvatarFile=0;
        public static    TextWriter    Safetw;        // thread safe
        public static    uint    numOfTitles = 0;
        public static    uint    numOfUsers = 0;
        [ThreadStatic]
        private static Random _randomInstance;
        public static Random randomInstance
        {
            get
            {
                if (_randomInstance == null)
                {
                    _randomInstance = new Random();
                }
                return _randomInstance;
            }
        }
        [ThreadStatic]
        private static RNGCryptoServiceProvider _rng;
        public static RNGCryptoServiceProvider rng
        {
            get
            {
                if (_rng == null)
                {
                    _rng = new RNGCryptoServiceProvider();
                }
                return _rng;
            }
        }
        public static Queue userFileQueue = new Queue(), teamFileQueue = new Queue(), msgFileQueue = new Queue(), titleFileQueue = new Queue(), XBoxClipFileQueue = new Queue(),
                                xenonClipFileQueue = new Queue(), crossTitleFileQueue = new Queue(), avatarFileQueue = new Queue();
        public static    Queue    syncdUserFileQ = Queue.Synchronized(userFileQueue), syncdTeamFileQ = Queue.Synchronized(teamFileQueue),
                                syncdMsgFileQ = Queue.Synchronized(msgFileQueue), syncdTitleFileQ = Queue.Synchronized(titleFileQueue),
                                syncdXBoxClipFileQ = Queue.Synchronized(XBoxClipFileQueue),
                                syncdXeClipFileQ = Queue.Synchronized(xenonClipFileQueue),syncdCrossTitleFileQ = Queue.Synchronized(crossTitleFileQueue),
                                syncdAvatarFileQ = Queue.Synchronized(avatarFileQueue);


        public static string MachineID;

        public override void OneTimeSetup(RUN_TYPE runType)
        {
            if (runType != RUN_TYPE.STRESS)
            {
                return;
            }

            XmlDocument config = Global.Config;

            Safetw = TextWriter.Synchronized(File.CreateText("XStoreError.txt"));

            // Set MachineID for running on multiple machines.
            string substr = System.Net.Dns.GetHostName();
            MachineID = substr.Substring(substr.Length - 3);
            uint iMachineID;
            if (!uint.TryParse(MachineID, System.Globalization.NumberStyles.HexNumber, null, out iMachineID))
            {
                iMachineID = (uint)randomInstance.Next();
                substr = iMachineID.ToString("x");
                MachineID = substr.Substring(substr.Length - 3);
            }
            Global.RO.Info("Machine ID: {0}", MachineID);

            // get number of preload files for each storage domain
            XboxClipPreloadFiles = Convert.ToUInt32(GetXMLValue(config,"/stf/config/stress/option[@name='XboxClipPreloadFiles']","0"));
            UserPreloadFiles = Convert.ToUInt32(GetXMLValue(config,"/stf/config/stress/option[@name='UserPreloadFiles']","0")); // Convert.ToUInt32(optionNode1.Attributes["value"].Value);
            TeamPreloadFiles = Convert.ToUInt32(GetXMLValue(config, "/stf/config/stress/option[@name='TeamPreloadFiles']", "0"));
            MsgPreloadFiles = Convert.ToUInt32(GetXMLValue(config, "/stf/config/stress/option[@name='MsgPreloadFiles']", "0"));
            TitlePreloadFiles = Convert.ToUInt32(GetXMLValue(config, "/stf/config/stress/option[@name='TitlePreloadFiles']", "0"));
            XenonClipPreloadFiles = Convert.ToUInt32(GetXMLValue(config, "/stf/config/stress/option[@name='XenonClipPreloadFiles']", "0"));
            CrossTitlePreloadFiles = Convert.ToUInt32(GetXMLValue(config, "/stf/config/stress/option[@name='CrossTitlePreloadFiles']", "1000"));
            AvatarPreloadFiles = Convert.ToUInt32(GetXMLValue(config, "/stf/config/stress/option[@name='AvatarPreloadFiles']", "0"));

            // get filesize for each storage domain
            XboxClipFile = Convert.ToUInt32(GetXMLValue(config, "/stf/config/stress/option[@name='XboxClipFileSize']", "8000"));
            TitleFile = Convert.ToUInt32(GetXMLValue(config, "/stf/config/stress/option[@name='GlobalTitleFileSize']", "8000"));
            MsgFile = Convert.ToUInt32(GetXMLValue(config, "/stf/config/stress/option[@name='msgFileSize']", "8000"));
            TeamFile = Convert.ToUInt32(GetXMLValue(config, "/stf/config/stress/option[@name='TeamFileSize']", "8000"));
            UserFile = Convert.ToUInt32(GetXMLValue(config, "/stf/config/stress/option[@name='UserTitleFileSize']", "8000"));
            CrossTitleFile = Convert.ToUInt32(GetXMLValue(config, "/stf/config/stress/option[@name='CrossTitleFileSize']", "8000"));
            XboxClipFile = Convert.ToUInt32(GetXMLValue(config,"/stf/config/stress/option[@name='XenonClipFileSize']", "8000"));
            AvatarFile = Convert.ToUInt32(GetXMLValue(config, "/stf/config/stress/option[@name='AvatarFileSize']", "38839"));

            // Always have 1 user and title by default...
            numOfTitles = Convert.ToUInt32(GetXMLValue(config, "/stf/config/stress/option[@name='numOfTitles']", "1"));
            numOfUsers = Convert.ToUInt32(GetXMLValue(config, "/stf/config/stress/option[@name='numOfUsers']", "1"));

            // create XboxClipPreloadFiles/UserPreloadFiles in the stdb first
            Global.RO.Info("XboxClipPreloadFiles - [1/8] : Number requested: {0}", XboxClipPreloadFiles);
            for(int j = 0; j < XboxClipPreloadFiles; j++)
            {
                uint    randomTitleID = (uint)XStoreTest.randomInstance.Next(1,(int)XStoreTest.numOfTitles);
                string    sTitleID = randomTitleID.ToString("x");
                ulong    randomPartitionKeyValue = (ulong)(XStoreTest.randomInstance.NextDouble() * 0xffffffffffffffff);
                string    url = "//stats."+sTitleID
                    + "/u:" + randomPartitionKeyValue.ToString("x") + "/"+ sTitleID + "/"+Guid.NewGuid().ToString();

                XRLWriteFile    writeReq = new XRLWriteFile("ServiceToken",url,XStoreTest.XboxClipFile,true);
                byte[] rand = new byte[(XboxClipFile < 8) ? XboxClipFile : 8];
                rng.GetBytes(rand);
                rand.CopyTo(writeReq.blobData,0);
                if (writeReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage)))
                    XBoxClipFileQueue.Enqueue(new QueueUrlObject(writeReq.uiTitleId, url));
            }
            Global.RO.Info("UserPreloadFiles - [2/8] : Number requested: {0}", UserPreloadFiles);
            for(int k = 0; k < UserPreloadFiles; k++)
            {
                uint    randomTitleID = (uint)randomInstance.Next(1,(int)numOfTitles);;
                ulong    randomUserPUID = (ulong)(randomInstance.NextDouble() * 0xffffffffffffffff);
                if(randomUserPUID == 0)
                    randomUserPUID = (ulong)(randomInstance.NextDouble() * 0xffffffffffffffff);
                string sTitleID = randomTitleID.ToString("x"), sUserPUID = randomUserPUID.ToString("x");
                string url= "//tuser."+sTitleID+"/u:"+sUserPUID+"/"+sTitleID+"/" + Guid.NewGuid().ToString();

                XRLWriteFile writeReq = new XRLWriteFile("Owner",url,UserFile,true);
                byte [] rand = new byte[(UserFile<8)? UserFile : 8];
                rng.GetBytes(rand);
                rand.CopyTo(writeReq.blobData,0);
                if(writeReq.Execute())
                    userFileQueue.Enqueue(new QueueUrlObject(writeReq.uiTitleId, url));
            }
            Global.RO.Info("TeamPreloadFiles - [3/8] : Number requested: {0}", TeamPreloadFiles);
            for(int k = 0; k < TeamPreloadFiles; k++)
            {
                uint    randomTitleID = (uint)randomInstance.Next(1,(int)numOfTitles);;
                ulong    randomUserPUID = (ulong)(randomInstance.NextDouble() * 0xffffffffffffffff);
                if(randomUserPUID == 0)
                    randomUserPUID = (ulong)(randomInstance.NextDouble() * 0xffffffffffffffff);
                string sTitleID = randomTitleID.ToString("x"), sUserPUID = randomUserPUID.ToString("x");
                uint    randomTeamPUID = (uint)XStoreTest.randomInstance.Next();
                string  sTeamPUID =randomTeamPUID.ToString("x");
                string url= "//tteam."+sTitleID+"/u:"+sTeamPUID+"/"+sTitleID+"/"+sUserPUID+"/Shuyin";

                XRLWriteFile    writeReq = new XRLWriteFile("Team",url,TeamFile,true);
                byte [] rand = new byte[(TeamFile<8)? TeamFile : 8];
                rng.GetBytes(rand);
                rand.CopyTo(writeReq.blobData,0);
                if(writeReq.Execute())
                    teamFileQueue.Enqueue(new QueueUrlObject(writeReq.uiTitleId, url));
            }
            Global.RO.Info("MsgPreloadFiles - [4/8] : Number requested: {0}", MsgPreloadFiles);
            for(int k = 0; k < MsgPreloadFiles; k++)
            {
                ulong    randomUserPUID = (ulong)(randomInstance.NextDouble() * 0xffffffffffffffff);
                if(randomUserPUID == 0)
                    randomUserPUID = (ulong)(randomInstance.NextDouble() * 0xffffffffffffffff);
                string sUserPUID = randomUserPUID.ToString("x");
                string url= "//msg.ab/u:"+sUserPUID+"/" + Guid.NewGuid().ToString();

                XRLWriteFile    writeReq = new XRLWriteFile("All",url,MsgFile,true);
                byte [] rand = new byte[(MsgFile<8)? MsgFile : 8];
                rng.GetBytes(rand);
                rand.CopyTo(writeReq.blobData,0);
                if(writeReq.Execute())
                    msgFileQueue.Enqueue(new QueueUrlObject(writeReq.uiTitleId, url));
            }
            Global.RO.Info("TitlePreloadFiles - [5/8] : Number requested: {0}", TitlePreloadFiles);
            for (int k = 0; k < TitlePreloadFiles; k++)
            {
                //uint    randomTitleID = (uint)randomInstance.Next(1,(int)numOfTitles);
                uint randomTitleID = XOn.XENON_DASH_TITLE_ID;

                string sTitleID = randomTitleID.ToString("x");
                string    url= "//title."+sTitleID+"/t:"+sTitleID+"/shuyinz";

                XRLWriteFile    writeReq = new XRLWriteFile("ServiceAddr",url, TitleFile,true);
                byte [] rand = new byte[(TitleFile<8)? TitleFile : 8];
                rng.GetBytes(rand);
                rand.CopyTo(writeReq.blobData,0);
                if(writeReq.Execute())
                    titleFileQueue.Enqueue(new QueueUrlObject(writeReq.uiTitleId, url));

                if (k != 0 && k % 5 == 0)
                {
                    Global.RO.Info(".");
                }
            }
            Global.RO.Info("CrossTitlePreloadFiles - [6/8] : Number requested: {0}", CrossTitlePreloadFiles);
            // Check to see if they already exist...
            XRLEnumFiles enumReq = new XRLEnumFiles("//global/t:FFFE07D1/ach/1/*", 0xFFFE07D1, 0, CrossTitlePreloadFiles, 0);
            XRLEnumFilesResponse enumResp;
            if (enumReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out enumResp))
            {    // check returned results
                for (int i = 0; i < enumResp.resultsLen; i++ )
                {
                    crossTitleFileQueue.Enqueue(enumResp.results[i].pathName);
                }
            }
            Global.RO.Info(" - using {0} Existing files", crossTitleFileQueue.Count);
            // make any extra we need...
            for(int k = crossTitleFileQueue.Count; k < CrossTitlePreloadFiles; k++)
            {
                uint randomIndex = (uint)randomInstance.Next();
                string url= "//global/t:FFFE07D1/ach/1/" + randomIndex.ToString("x");

                XRLWriteFile    writeReq = new XRLWriteFile("ServiceAddr",url,CrossTitleFile,true);
                byte [] rand = new byte[(CrossTitleFile<8)? CrossTitleFile : 8];
                rng.GetBytes(rand);
                rand.CopyTo(writeReq.blobData,0);
                if(writeReq.Execute())
                    crossTitleFileQueue.Enqueue(url);
            }
            Global.RO.Info(" - created and reused {0} files total", crossTitleFileQueue.Count);
            // next
            Global.RO.Info("XenonClipPreloadFiles - [7/8] : Number requested: {0}", XenonClipPreloadFiles);
            for(int k = 0; k < XenonClipPreloadFiles; k++)
            {
                uint randomTitleID = (uint)randomInstance.Next();
                string    sTitleID = randomTitleID.ToString("x");
                ulong    randomUserPUID = (ulong)(randomInstance.NextDouble() * 0xffffffffffffffff);
                if(randomUserPUID == 0)
                    randomUserPUID = (ulong)(randomInstance.NextDouble() * 0xffffffffffffffff);
                string sUserPUID = randomUserPUID.ToString("x");
                string url = "//xestats." + sTitleID + "/u:" + sUserPUID + "/" + sTitleID + "/" +
                    randomInstance.Next().ToString("x");

                XRLWriteFile    writeReq = new XRLWriteFile("Owner",url,XenonClipFile,true);
                byte [] rand = new byte[(XenonClipFile<8)? XenonClipFile : 8];
                rng.GetBytes(rand);
                rand.CopyTo(writeReq.blobData,0);
                if(writeReq.Execute())
                    xenonClipFileQueue.Enqueue(new QueueUrlObject(writeReq.uiTitleId, url));
            }
            Global.RO.Info("AvatarPreloadFiles - [8/8] : Number requested: {0}", AvatarPreloadFiles);
            for (int k = 0; k < AvatarPreloadFiles; k++)
            {
                string url = String.Format("//avatar/u:{0}{1}/stress.png", XStoreTest.MachineID, XStoreTest.GetNextFakeXUID());

                XRLWriteFile writeReq = new XRLWriteFile("ServiceAddr", url, XStoreTest.AvatarFile, true);
                byte[] rand = new byte[(XStoreTest.AvatarFile < 8) ? XStoreTest.AvatarFile : 8];
                XStoreTest.rng.GetBytes(rand);
                rand.CopyTo(writeReq.blobData, 0);
                if(writeReq.Execute())
                    avatarFileQueue.Enqueue(new QueueUrlObject(writeReq.uiTitleId, url));
            }
        }

        public System.Collections.Generic.List<System.Type> GetStressTests()
        {
            System.Collections.Generic.List<System.Type> tests = new System.Collections.Generic.List<System.Type>();

            //tests.Add(typeof(StressNameResolver)); // Depricated API
            tests.Add(typeof(StressAvatarWrite));
            tests.Add(typeof(StressAvatarRead));
            //tests.Add(typeof(StressAvatarEnum)); // Enum supported on AvatarDB but never happens
            //tests.Add(typeof(StressAvatarRemove)); // Remove supported on AvatarDB but never happens (offensive are overwritten with a default)
            tests.Add(typeof(StressAvatarGateway));
            tests.Add(typeof(StressAvatarGatewayBad));

            tests.Add(typeof(StressGlobalTitleEnum));
            tests.Add(typeof(StressGlobalWrite));
            tests.Add(typeof(StressGlobalRead));
            tests.Add(typeof(StressGlobalEnum));
            tests.Add(typeof(StressGlobalRemove));

            tests.Add(typeof(StressTitleWrite));
            tests.Add(typeof(StressTitleRead));
            tests.Add(typeof(StressTitleEnum));
            tests.Add(typeof(StressTitleRemove));

            tests.Add(typeof(StressMsgWrite));
            tests.Add(typeof(StressMsgRead));
            //tests.Add(typeof(StressMsgEnum)); // Enum not supported on MsgDB. See t_storage_domains
            tests.Add(typeof(StressMsgRemove));

            tests.Add(typeof(StressTUserWrite));
            tests.Add(typeof(StressTUserRead));
            //tests.Add(typeof(StressTUserEnum)); // Enum not supported on TUserDB. See t_storage_domains
            tests.Add(typeof(StressTUserRemove));

            tests.Add(typeof(StressStatsWrite));
            tests.Add(typeof(StressStatsRead));
            //tests.Add(typeof(StressStatsEnum)); // Enum not supported on stats. See t_storage_domains
            tests.Add(typeof(StressStatsRemove));

            tests.Add(typeof(StressXeStatsWrite));
            tests.Add(typeof(StressXeStatsRead));
            //tests.Add(typeof(StressXeStatsEnum)); // Enum not supported on xestats. See t_storage_domains
            tests.Add(typeof(StressXeStatsRemove));

            return tests;
        }

        public override void  Dispose()
        {
            Safetw.Flush();
            Safetw.Close();
            base.Dispose();
        }

        private string GetXMLValue(XmlDocument doc, string path, string defaultValue)
        {
            XmlNode node = doc.SelectSingleNode(path);
            if (node != null)
            {
                if (node.Attributes["value"] != null)
                    return node.Attributes["value"].Value;
                else
                    return defaultValue;
            }
            else
            {
                return defaultValue;
            }
        }

        /// <summary>
        /// Holds the value for the fake XUID
        /// </summary>k
        private static ulong _fakeXUID=0;
        /// <summary>
        /// Generates a fake XUID for putting a file in the Avatar Domain.  They are of the format
        /// </summary>
        /// <returns>String representation of the next XUID</returns>
        public static string GetNextFakeXUID()
        {
            Object _lock = new Object();
            lock (_lock)
            {
                _fakeXUID++;
                if (_fakeXUID > 0xFFFF)
                {
                    _fakeXUID = 0;
                }
                return _fakeXUID.ToString("X");
            }
        }

        private static XmlDocument stressMix;
        public static uint GetRandomDomainFileSize(int Domain)
        {
            // if mix isn't loaded, load it up...
            if (stressMix == null)
            {
                stressMix = new XmlDocument();
                stressMix.Load(@"Suites\StressMix.xml");
            }
            return 0;

        }
    }

    public class QueueUrlObject
    {
        public uint TitleId;
        public string Url;
        public uint TitleVersion;

        public QueueUrlObject(uint titleID, string url)
        {
            TitleId = titleID;
            Url = url;
            TitleVersion = 0;
        }
        public QueueUrlObject(uint titleID, string url, uint titleVersion)
        {
            TitleId = titleID;
            Url = url;
            TitleVersion = titleVersion;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StutilTest\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XUATest\NewFile.cs ===
using System;
using System.IO;


namespace XUATest1
{
	/// <summary>
	/// Summary description for NewFile.
	/// </summary>
	public class FileClass
	{
		
		public string uniname;
		public static void NewFileText(string StrSite, int i, int j, string uniname)
		{
			FileWrite(StrSite, i, j, uniname);
		}
		//
			
		
 
		public static void FileWrite(string StrSite, int i, int j, string uniname)
		{
			StreamWriter SW;
			SW=File.CreateText("c:\\" + uniname + i + ".html");
			SW.Close();
			Console.WriteLine("Creation of file" + uniname + i + " successful");
			return;
			
			
			
		}
		public class FileAppendClass
		{
			public static void FileApp(string output, int i, int j, string uniname)
			{
				FileAppend(output, i, j, uniname);
			}
			public static void FileAppend(string output, int i, int j, string uniname)
			{
				StreamWriter SW;
				SW=File.AppendText("c:\\" + uniname + i + ".html");
				SW.WriteLine(output);
				SW.Close();
					
				return;
				
			}
			
		} 

		


	}		
	//
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XUATest\Unifile.cs ===
using System;

using Microsoft.WebRunner;
//using ServerTestFramework;
using System.Xml;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Collections;
using System.Net;
using System.Threading;
using System.Text;
using System.Resources;
using System.Reflection;
using System.Globalization;
//using ServerTestFramework.Database;
//using ServerTestFramework.LiveService.Notification;
//using ServerTestFramework.LiveService.Presence;
//using ServerTestFramework.LiveService.PresNotiCommon;
//using ServerTestFramework.Utilities;
using Microsoft.WebRunner.Loggers;
namespace XUATest1
{
	/// <summary>
	/// Summary description for Unifile.
	/// </summary>
	public class unifile
	{
		public static string uniname;
		public static void Unifile(string output, int i, int j, string uniname)
	

		{
			//
			

			if (j == 0)
			{
				XUATest1.unifile.uniname = "Catalog";
			}
			else if (j == 1)
			{
				XUATest1.unifile.uniname = "Spidy1";
			}
			else if (j == 2)
			{
				XUATest1.unifile.uniname = "Spidy2";
			}
			else if (j == 3)
			{
				XUATest1.unifile.uniname = "Home";
			}
			return;
			//
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XUATest\TC.cs ===
using System;
using System.Xml;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Collections;

using System.Net;
using System.Threading;
using System.Text;
using System.Resources;
using System.Reflection;
using System.Globalization;
using Microsoft.WebRunner;
using ServerTestFramework;
using Microsoft.WebRunner.Loggers;


namespace XUATest1
{
	/// <summary>
	[TestGroup]
	/// </summary>
	public class TC : TestNode
	{
				public static WebRunnerSDK mySDK;
				public static System.Threading.Timer myPopUpTimer;
				public static WebRunnerSDK XHTMLVal = new WebRunnerSDK(); 
				//Starting up the application to test my account with console serial number
		static void PopUpHandler(object i)
	
		{
			string uname;
			string udrive;
			string umark = "\\";
			string usite;
			
			udrive = "c:";
			uname = ".html";
			usite = (udrive + umark + XUATest1.unifile.uniname + (int) i + uname);
			
			// dismiss the alarm
			myPopUpTimer.Dispose();
			
			// handle popup by selecting file
			TC.XHTMLVal.AttachTo(Win32Special.Embedded,"name=Choose file");
			TC.XHTMLVal.InputText(Win32UIObj.Text,@"TextToInput=" + usite + "&&name=File name:");
			
			
			TC.XHTMLVal.PressKey("TextToInput=[Enter]");

			// return focus to IE window
			TC.XHTMLVal.AttachTo(Win32Special.Window, "name=W3C Markup Validation Service: Upload Files&&exactmatch=false");

		}


				[TestCase, Description("This test case passes")]
					class GoodTest1 : TestBase
				{
					protected override void Execute()
					{
						bool Results = XMain.XHTMLMain(0);
				
						if (Results) 
						{
							ResultCode = TEST_RESULTS.PASSED;
						}
						else 
						{ 
							ResultCode = TEST_RESULTS.FAILED;
						}
					}
				}
		
		public static void XHTMLValidate(int i, string uniname)
		{

			string Pcmd;
			Pcmd = @"/C c:\Activeperl\bin\perl.exe -w c:\Catalog0.html c:\W3C\Bundle-W3C-Validator-0.6.5\Makefile.PL >> C:\\" + uniname + i + ".csv 2>&1";
			System.Threading.Thread.Sleep(150);
			System.Diagnostics.Process.Start("cmd.exe", Pcmd);
			System.Threading.Thread.Sleep(150);
			
			 return;
		}			
		public class XHTMLValidator : TestSuite

		{
			public override void Initialize(System.Xml.XmlDocument config)
			{
				//	base.Initialize (config);
								 
			}

			// functional test for BasicTest

			public override InitializerInfo GetRequiredResources()

			{

				// need to use fakesg service

				InitializerInfo ii= new InitializerInfo();
				
				ii.UseFakeSG = false;
				
				XMain.Initializer();		
				
				return ii;

			}

 

			// stress test for BasicTest

			public override InitializerInfo GetStressRequiredResources()

			{

				// besides using fakeSG service, this stress test also need to

				// createUsers before testing start, also need certificates

				InitializerInfo   ii = new InitializerInfo();

				ii.UseFakeSG = false;

				ii.CreateUsers = false;

				ii.Certificates = false;

				return ii;

			}

		}		
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StutilTest\Class1.cs ===
#define UI


using System;
using System.ServiceProcess;
using System.Diagnostics;
using System.Windows.Forms;

namespace stutil_test
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	class stutil_test_main
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		
		private static Form1 StutilUIForm;

		[STAThread]
		static int Main(string[] args)
		{
			//
			// TODO: Add code to start application here
					
			#if(UI)
			{
				StutilUIForm = new Form1();
				Application.Run(StutilUIForm);
				return 0;
			}
			#else
			{

				if (args.Length != 3)
				{
					Console.WriteLine("Incorrect usage!!");	
					Usage();
					return -1;
				}
				ulong titleid = 0xfffe07d1;
				switch(args[0].ToLower())
				{
					case "read": 
					{
						ReadFileFromStorage(args[1],args[2],titleid);
						break;
					}
					case "write":
					{
						WriteFileToStorage(args[1],args[2],titleid);
						break;
					}
				}
				return 0;
			}
			#endif
		}

		public static void WriteFileToStorage(string localFileName, string storageFileName, ulong titleID)
		{
			string arguments;
			if (titleID == 0)
			{
				arguments = string.Format("-a:write -f:{0} -p:{1} -y", localFileName, storageFileName);
			}
			else
			{
				arguments = string.Format("-a:write -f:{0} -p:{1} -t:0x{2:x8} -y", localFileName, storageFileName, titleID);
			}

			Process stutil = new Process();
			stutil.StartInfo.FileName = "stutil.exe";
			stutil.StartInfo.Arguments = arguments;
			stutil.StartInfo.UseShellExecute = false;
			stutil.StartInfo.RedirectStandardOutput = true;

			stutil.Start();
			#if UI
			{
				StutilUIForm.WriteLog(stutil.StartInfo.FileName+ " " + stutil.StartInfo.Arguments);
				StutilUIForm.WriteLog(stutil.StandardOutput.ReadToEnd());
			}
			#endif
		
			Console.WriteLine();
			Console.WriteLine("{0} {1}", stutil.StartInfo.FileName, stutil.StartInfo.Arguments);
			Console.WriteLine(stutil.StandardOutput.ReadToEnd());
		
			stutil.WaitForExit();
            
			if(stutil.ExitCode == 0) // success
			{
#if UI
				StutilUIForm.WriteLog("Success!!");
#endif
				Console.WriteLine("Success!!");
			}     
			else
			{
#if UI
				StutilUIForm.WriteLog("Failure!!");
#endif
				Console.WriteLine("Failure!!");
			}
		}

		public static void ReadFileFromStorage(string localFileName, string storageFileName, ulong titleID)
		{
	            
			string arguments;
			if (titleID == 0)
			{
				arguments = string.Format("-a:read -f:{0} -p:{1} -y", localFileName, storageFileName);
			}
			else
			{
				arguments = string.Format("-a:read -f:{0} -p:{1} -t:0x{2:x8} -y", localFileName, storageFileName, titleID);
			}

			Process stutil = new Process();
			stutil.StartInfo.FileName = "stutil.exe";
			stutil.StartInfo.Arguments = arguments;
			stutil.StartInfo.UseShellExecute = false;
			stutil.StartInfo.RedirectStandardOutput = true;

			stutil.Start();
#if UI
		{
			StutilUIForm.WriteLog(stutil.StartInfo.FileName+ " " + stutil.StartInfo.Arguments);
			StutilUIForm.WriteLog(stutil.StandardOutput.ReadToEnd());
		}
#endif
			Console.WriteLine();
			Console.WriteLine("{0} {1}", stutil.StartInfo.FileName, stutil.StartInfo.Arguments);
			Console.WriteLine(stutil.StandardOutput.ReadToEnd());

			stutil.WaitForExit();
            
			if(stutil.ExitCode == 0) // success
			{
#if UI
				StutilUIForm.WriteLog("Success!!");
#endif
				Console.WriteLine("Success!!");
			}     
			else
			{
#if UI
				StutilUIForm.WriteLog("Failure!!");
#endif
				Console.WriteLine("Failure!!");
			}
		}

		public static void RemoveFileFromStorage(string storagePathName, ulong titleID)
		{
			string arguments;
			if (titleID == 0)
			{
				arguments = string.Format("-a:remove -p:{0} -y", storagePathName);
			}
			else
			{
				arguments = string.Format("-a:remove -p:{0} -t:0x{1:x8} -y", storagePathName, titleID);
			}

			Process stutil = new Process();
			stutil.StartInfo.FileName = "stutil.exe";
			stutil.StartInfo.Arguments = arguments;
			stutil.StartInfo.UseShellExecute = false;
			stutil.StartInfo.RedirectStandardOutput = true;

			stutil.Start();
#if UI
		{
			StutilUIForm.WriteLog(stutil.StartInfo.FileName+ " " + stutil.StartInfo.Arguments);
			StutilUIForm.WriteLog(stutil.StandardOutput.ReadToEnd());
		}
#endif
			Console.WriteLine();
			Console.WriteLine("{0} {1}", stutil.StartInfo.FileName, stutil.StartInfo.Arguments);
			Console.WriteLine(stutil.StandardOutput.ReadToEnd());

			stutil.WaitForExit();
            
			if(stutil.ExitCode == 0) // success
			{
#if UI
				StutilUIForm.WriteLog("Success!!");
#endif
				Console.WriteLine("Success!!");
			}     
			else
			{
#if UI
				StutilUIForm.WriteLog("Failure!!");
#endif
				Console.WriteLine("Failure!!");
			}
		}

		public static void EnumerateFilesFromStorage(string storagePathName, int maxResults, ulong titleID)
		{
			string arguments;
			if (titleID == 0 && maxResults == 0)
			{
				arguments = string.Format("-a:enum -p:{0}", storagePathName);
			}
			else if(maxResults == 0)
			{
				arguments = string.Format("-a:enum -p:{0} -t:0x{1:x8}", storagePathName, titleID);
			}
			else if(titleID == 0)
			{	
				arguments = string.Format("-a:enum -p:{0} -n:{1}", storagePathName, maxResults);
			}
			else
			{
				arguments = string.Format("-a:enum -p:{0} -t:0x{1:x8} -n:{2}", storagePathName, titleID, maxResults);
			}

			Process stutil = new Process();
			stutil.StartInfo.FileName = "stutil.exe";
			stutil.StartInfo.Arguments = arguments;
			stutil.StartInfo.UseShellExecute = false;
			stutil.StartInfo.RedirectStandardOutput = true;

			stutil.Start();
#if UI
		{
			StutilUIForm.WriteLog(stutil.StartInfo.FileName+ " " + stutil.StartInfo.Arguments);
			StutilUIForm.WriteLog(stutil.StandardOutput.ReadToEnd());
		}
#endif
			Console.WriteLine();
			Console.WriteLine("{0} {1}", stutil.StartInfo.FileName, stutil.StartInfo.Arguments);
			Console.WriteLine(stutil.StandardOutput.ReadToEnd());

			stutil.WaitForExit();
            
			if(stutil.ExitCode == 0) // success
			{
#if UI
				StutilUIForm.WriteLog("Success!!");
#endif
				Console.WriteLine("Success!!");
			}     
			else
			{
#if UI
				StutilUIForm.WriteLog("Failure!!");
#endif
				Console.WriteLine("Failure!!");
			}
		}

		protected static void Usage()
		{
			Console.Write(" \n Usage: stutil_test <action> <localFileName> <StoragePathName> \n" +
				          " where action - read/write, localFileName - file to be uploaded \n" + 
						  " StoragePathName - //title/t:fffe07d1/icon/0/800 & titleID - fffe07d1");
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\TestTracker\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//        When specifying the KeyFile, the location of the KeyFile should be
//        relative to the "project output directory". The location of the project output
//        directory is dependent on whether you are working with a local or web project.
//        For local projects, the project output directory is defined as
//       <Project Directory>\obj\<Configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//        For web projects, the project output directory is defined as
//       %HOMEPATH%\VSWebCache\<Machine Name>\<Project Directory>\obj\<Configuration>.
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\surge\httpclient\httpclient.h ===
/*

Copyright (C) 1999-2000 Microsoft Corporation

Module Name:

    HttpClient.h

Abstract:

    

Author:

    Josh Poley (jpoley) 1-1-1999

Revision History:

*/
#ifndef _HTTPCLIENT_H_
#define _HTTPCLIENT_H_

// NOTE: Be sure to call WSAStartup() and WSACleanup() in the parent 
//       application.
//
//       Example:
//      
//       WSADATA wsaData;
//       WSAStartup(0x0101, &wsaData);
//        ... // your program code here
//       WSACleanup();
//
// NOTE: If you plan on using SSL you may wish to load the dlls in your main 
//       program, this will keep CHttpClient from loading and unloading all
//       the security libraries.
//
//       Example:
//
//       HINSTANCE hSecuritydll = LoadLibrary("security.dll");
//        ... // your program code here
//       FreeLibrary(hSecuritydll);
//
// NOTE: The debug version of this dll (#define _DEBUG) will dump log 
//       information to the file specified by DEBUGLOG. An extensive
//       amount of data is written to this file.
//
// NOTE: Include files with error codes
//       SSL       <issperr.h> 
//       Sockets   <winsock2.h>
//       HTTP      <wininet.h>
//

#include <winsock2.h>
#include <time.h>

#include "SecureSocketLayer.h"

#define DATA_SIZE 65536

class __declspec( dllexport ) Cookie
    {
    public:
        char *name;
        char *value;
        char *domain;
        char *path;

        Cookie *next;

        char *localname;
        char *localvalue;
        size_t localnameLen;
        size_t localvalueLen;

    public:
        Cookie();
        Cookie(char *n, char *v=NULL, char *d=NULL);
        ~Cookie();

    public:
        Cookie* Find(char *n, char *d=NULL);
        Cookie* Add(char *n, char *v, char *d);
        Cookie* Add(char *setcookie, char *d);
        BOOL Remove(char *n, char *d=NULL);

        void Eval(char *dest, char *d=NULL);
    };

class CHttpClient
    {
    private:
        SOCKET sock;
        SOCKET nextsock;
        SOCKADDR_IN dest;

        WORD wPort;

        // Proxy Settings
        BOOL bUseProxy;
        WORD wProxyPort;
        char szProxyServerName[1024];

        // SSL stuffs
        CSecureSocketLayer *SSL;

        // timeouts
        TIMEVAL timeout;

		// timers
        time_t sendTime;
        time_t ttfbTime;        // Time to First Byte
        time_t ttlbTime;        // Time to Last Byte

    public: // send and receive buffer
        char data[DATA_SIZE+1];
        int dataLen;

    public:
        __declspec( dllexport ) int GetHTTPStatus(void);
        __declspec( dllexport ) char* GetBody(void);
        __declspec( dllexport ) char* GetData(void);
        __declspec( dllexport ) int GetDataLen(void);

    public:
// #pragma push_macro("ParseURL")
#undef ParseURL
        __declspec( dllexport ) int ParseURL(const char *url, char *server, char *site, BOOL* ssl);
// #pragma pop_macro("ParseURL")
        __declspec( dllexport ) int GrabCookies(Cookie *jar, char *source, char *domain=NULL);
        __declspec( dllexport ) int GetCookieRules(void);
        __declspec( dllexport ) void SetCookieRules(int i);
        __declspec( dllexport ) int URLEncode(char *dest, const char *source);
        __declspec( dllexport ) int URLDecode(char *dest, const char *source);
        __declspec( dllexport ) int POSTEncode(char *dest, const char *source);

    public:
        __declspec( dllexport ) long Open(void);
        __declspec( dllexport ) long Connect(IN_ADDR server, const char *serverName);
        __declspec( dllexport ) long Connect(const char *serverName);
        __declspec( dllexport ) long Disconnect(void);
        __declspec( dllexport ) long HardDisconnect(void);

        __declspec( dllexport ) long Send(const char *senddata, int len);
        __declspec( dllexport ) long Send(void); // send what is already in the 'data' buffer
        __declspec( dllexport ) long Receive(BOOL readAll=FALSE);

        __declspec( dllexport ) BOOL IsDataAvailable(void);
        __declspec( dllexport ) BOOL IsSendAvailable(void);

    public: // socket / connection options
        __declspec( dllexport ) long SetLinger(BOOL linger, WORD timeout);
        __declspec( dllexport ) long SetKeepAlive(BOOL keepalive);
        __declspec( dllexport ) long SetSSL(LPSTR pszUserName=NULL, DWORD dwProtocol=SP_PROT_SSL2, ALG_ID aiKeyExch=CALG_RSA_KEYX);
        __declspec( dllexport ) long SetProxy(const char *serverName, WORD port);
        __declspec( dllexport ) void SetRecvTimeout(UINT sec, UINT msec);
        __declspec( dllexport ) void SetDefaultPort(WORD newPort);

    public: // information
        __declspec( dllexport ) BOOL DNSLookup(char *address, char *output, size_t bufferlen);
        __declspec( dllexport ) time_t GetTime(unsigned char timeToReturn);

    public: // constructor / destructor
        __declspec( dllexport ) CHttpClient();
        __declspec( dllexport ) ~CHttpClient();
    };

#endif // _HTTPCLIENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XUATest\XMain.cs ===
using System;
using Microsoft.WebRunner;
//using ServerTestFramework;
using System.Xml;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Collections;
using System.Net;
using System.Threading;
using System.Text;
using System.Resources;
using System.Reflection;
using System.Globalization;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.Utilities;
using Microsoft.WebRunner.Loggers;

namespace XUATest1
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	public class XMain

	{
		/// <summary>
		/// The main entry point for the application.
		
		static string StrUA;
		static int nCntr;
		static string StrSite;
		static string fullURL;
		public static ArrayList UAS = new ArrayList();
		public static ArrayList UA1 = new ArrayList();
		public string [] UA;
		public string [] UASS;
		public string uniname;
		/// </summary>
		

		public static void Initializer()
		{
			XUATest1.XMain.XHTMLMain(nCntr);
		}
		public static bool XHTMLMain(int nCntr)
		{
			bool Results = true;
			
			XmlDocument Reg = new XmlDocument();
			//Create an XmlNamespaceManager for resolving namespaces.
			XmlNamespaceManager NsMgr = new XmlNamespaceManager(Reg.NameTable);
			//NsMgr.AddNamespace(Tests, sitetest);

			// user agents put into an array to be used int he WebRequest for testing.
			
			Reg.Load("UA.xml");
			
			int i = 0;
			int j = 0;
			XmlElement root = Reg.DocumentElement;
			XmlNodeList ObjNode1 = Reg.SelectNodes("/Tests/sitetest/userag/useragent", NsMgr);
			foreach(XmlNode ObjNodes in ObjNode1)
			{
				StrUA = ObjNodes.Attributes["ua"].Value;
				
				UA1.Add(StrUA);
				i = i + 1;
				
			}
			i = 0;
			//XmlDocument Reg1 = new XmlDocument();
			//XmlNamespaceManager NsMgr1 = new XmlNamespaceManager(Reg1.NameTable);
			XmlElement root1 = Reg.DocumentElement;
			XmlNodeList ObjNode2 = Reg.SelectNodes("/Tests/sitetest/sites/uasites", NsMgr);
			foreach(XmlNode ObjNodes in ObjNode2)
			{
				StrSite = ObjNodes.Attributes["uas"].Value;
				UAS.Add(StrSite);
				j = j + 1;
			}
			j = 0;
			

			//  Now we go to the web site with each of the user agent strings
			//  to verify if they work or not.  Putting the results into a Console.Writeline response.
			//  
			
			foreach(string StrSite in UAS)
			{
				foreach(string StrUA in UA1)
				
				{
					
					
					string output = null;
					XUATest1.unifile.Unifile(output, i, j, XUATest1.unifile.uniname);
					XUATest1.FileClass.NewFileText(StrSite, i, j, XUATest1.unifile.uniname);
					//fullURL = "http://clairejdev:85/?Sample=Catalog/" + UA1[i];
					fullURL = UAS[j] + "/" + UA1[i];
					HttpWebRequest myReq = (HttpWebRequest)WebRequest.Create(fullURL);						
			
					// Create an http connection
				
					WebHeaderCollection whc = myReq.Headers;
					myReq.AllowAutoRedirect = true;
					System.Threading.Thread.Sleep(150);
							
					//StreamReader myReader = new StreamReader(myResp.GetResponseStream(),true);
					//using (StreamReader myReader1 = new StreamReader(myResp.GetResponseStream(), true))

					HttpWebResponse myResp;
			
					try
					{
				
						myResp = (HttpWebResponse)myReq.GetResponse();
					}
					catch (System.Net.WebException exc)
					{
						myResp = (HttpWebResponse)exc.Response;
					}
			
			

					// Create a stream reader to read the response
					try 
					{
				

						WebClient myRequest = new WebClient();
	
					

						// Save the response text
					
					} 
					catch(Exception) 
					{
						Console.WriteLine("\r\nThe request URI could not be found or was malformed");
					}
					
			
			
			
					StreamReader myReader = new StreamReader(myResp.GetResponseStream());
					//String output = null;
				
					while ((output = myReader.ReadLine()) != null)
					{
						XUATest1.FileClass.FileAppendClass.FileAppend(output, i, j, XUATest1.unifile.uniname);
						System.Threading.Thread.Sleep(1000);
						
					
					}
					
					
					myReader.Close();
					myResp.Close();
					XUATest1.TC.XHTMLValidate(i, XUATest1.unifile.uniname);
					i = i + 1;
				}
								
			}					
		return Results;
		}
		
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\TacticsLog\StdAfx.h ===
//-----------------------------------------------------------------------------
// Microsoft User Profile Store
//
// File:			stdafx.h
//
// Copyright:		Copyright (c) 2000-2001 Microsoft Corporation
//
// Comments: 		include file for standard system include files,
//  				or project specific include files that are used frequently, but
//      			are changed infrequently
//
// History:		3/31/2000	JohnBlac	Created
//				4/19/2001	JohnBlac	last revised
//
//-----------------------------------------------------------------------------

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#define _WIN32_DCOM

// Imported from DSSpammer StdAfx.h
#include <Windows.h>
#include <assert.h>
#include <time.h>
#include <shellapi.h>
#include <atlbase.h>         // ATL core
#include <atlcom.h>
#include <atldbcli.h>

// reference additional headers your program requires here
#include "stringutl.h"
#include "TLDBroutines.h"

// Helpful Macros
#define NUMELEM(p1) (sizeof(p1) / sizeof(*p1))

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StutilTest\Form1.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Globalization;

namespace stutil_test
{
	/// <summary>
	/// Summary description for Form1.
	/// </summary>
	public class Form1 : System.Windows.Forms.Form
	{
		private System.Windows.Forms.Label FileNameLabel;
		private System.Windows.Forms.TextBox FileNameBox;
		private System.Windows.Forms.Button ExecuteButton;
		private System.Windows.Forms.Button BrowseButton;
		private System.Windows.Forms.Label PathLabel;
		private System.Windows.Forms.TextBox PathBox;
		private System.Windows.Forms.CheckBox WriteCheckBox;
		private System.Windows.Forms.CheckBox ReadCheckBox;
		private System.Windows.Forms.CheckBox RemoveCheckBox;
		private System.Windows.Forms.TextBox StutilLogBox;
		private System.Windows.Forms.Label OutputLabel;
		private System.Windows.Forms.Timer timer;

		private string FileName;
		private string ActionItem;
		private ArrayList Log;
		private bool UpdateLog;

		private System.Windows.Forms.Label TitleIDLabel;
		private System.Windows.Forms.TextBox TitleIDBox;
		private System.Windows.Forms.CheckBox EnumerateCheckBox;
		private System.Windows.Forms.Label MaxResultsLabel;
		private System.Windows.Forms.TextBox MaxResultsTextBox;
		private System.Windows.Forms.Button ClearButton;
		private System.ComponentModel.IContainer components;

		public Form1()
		{
			//
			// Required for Windows Form Designer support
			//
			FileName = null;
			ActionItem = null;
			Log = new ArrayList();
			UpdateLog = true;

			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.components = new System.ComponentModel.Container();
			this.FileNameLabel = new System.Windows.Forms.Label();
			this.FileNameBox = new System.Windows.Forms.TextBox();
			this.BrowseButton = new System.Windows.Forms.Button();
			this.PathLabel = new System.Windows.Forms.Label();
			this.PathBox = new System.Windows.Forms.TextBox();
			this.WriteCheckBox = new System.Windows.Forms.CheckBox();
			this.ReadCheckBox = new System.Windows.Forms.CheckBox();
			this.RemoveCheckBox = new System.Windows.Forms.CheckBox();
			this.StutilLogBox = new System.Windows.Forms.TextBox();
			this.OutputLabel = new System.Windows.Forms.Label();
			this.ExecuteButton = new System.Windows.Forms.Button();
			this.timer = new System.Windows.Forms.Timer(this.components);
			this.TitleIDLabel = new System.Windows.Forms.Label();
			this.TitleIDBox = new System.Windows.Forms.TextBox();
			this.EnumerateCheckBox = new System.Windows.Forms.CheckBox();
			this.MaxResultsLabel = new System.Windows.Forms.Label();
			this.MaxResultsTextBox = new System.Windows.Forms.TextBox();
			this.ClearButton = new System.Windows.Forms.Button();
			this.SuspendLayout();
			// 
			// FileNameLabel
			// 
			this.FileNameLabel.Location = new System.Drawing.Point(8, 24);
			this.FileNameLabel.Name = "FileNameLabel";
			this.FileNameLabel.Size = new System.Drawing.Size(56, 16);
			this.FileNameLabel.TabIndex = 0;
			this.FileNameLabel.Text = "FileName:";
			// 
			// FileNameBox
			// 
			this.FileNameBox.Location = new System.Drawing.Point(64, 16);
			this.FileNameBox.Name = "FileNameBox";
			this.FileNameBox.Size = new System.Drawing.Size(328, 20);
			this.FileNameBox.TabIndex = 1;
			this.FileNameBox.Text = "<FileName>";
			// 
			// BrowseButton
			// 
			this.BrowseButton.Location = new System.Drawing.Point(416, 16);
			this.BrowseButton.Name = "BrowseButton";
			this.BrowseButton.Size = new System.Drawing.Size(56, 23);
			this.BrowseButton.TabIndex = 2;
			this.BrowseButton.Text = "Browse";
			this.BrowseButton.Click += new System.EventHandler(this.BrowseButton_Click);
			// 
			// PathLabel
			// 
			this.PathLabel.Location = new System.Drawing.Point(0, 88);
			this.PathLabel.Name = "PathLabel";
			this.PathLabel.Size = new System.Drawing.Size(120, 32);
			this.PathLabel.TabIndex = 12;
			this.PathLabel.Text = "PathName(//domain/t:titleid/path)";
			// 
			// PathBox
			// 
			this.PathBox.Location = new System.Drawing.Point(64, 80);
			this.PathBox.Name = "PathBox";
			this.PathBox.Size = new System.Drawing.Size(328, 20);
			this.PathBox.TabIndex = 4;
			this.PathBox.Text = "<Path Name>";
			// 
			// WriteCheckBox
			// 
			this.WriteCheckBox.Location = new System.Drawing.Point(16, 160);
			this.WriteCheckBox.Name = "WriteCheckBox";
			this.WriteCheckBox.Size = new System.Drawing.Size(56, 24);
			this.WriteCheckBox.TabIndex = 6;
			this.WriteCheckBox.Text = "Write";
			this.WriteCheckBox.CheckedChanged += new System.EventHandler(this.WriteChkBox_Changed);
			// 
			// ReadCheckBox
			// 
			this.ReadCheckBox.Location = new System.Drawing.Point(104, 160);
			this.ReadCheckBox.Name = "ReadCheckBox";
			this.ReadCheckBox.Size = new System.Drawing.Size(72, 24);
			this.ReadCheckBox.TabIndex = 7;
			this.ReadCheckBox.Text = "Read";
			this.ReadCheckBox.CheckedChanged += new System.EventHandler(this.ReadChkBox_Changed);
			// 
			// RemoveCheckBox
			// 
			this.RemoveCheckBox.Location = new System.Drawing.Point(176, 160);
			this.RemoveCheckBox.Name = "RemoveCheckBox";
			this.RemoveCheckBox.Size = new System.Drawing.Size(72, 24);
			this.RemoveCheckBox.TabIndex = 8;
			this.RemoveCheckBox.Text = "Remove";
			this.RemoveCheckBox.CheckedChanged += new System.EventHandler(this.RemoveChkBox_Changed);
			// 
			// StutilLogBox
			// 
			this.StutilLogBox.Dock = System.Windows.Forms.DockStyle.Bottom;
			this.StutilLogBox.Location = new System.Drawing.Point(0, 238);
			this.StutilLogBox.MaxLength = 1048576;
			this.StutilLogBox.Multiline = true;
			this.StutilLogBox.Name = "StutilLogBox";
			this.StutilLogBox.ReadOnly = true;
			this.StutilLogBox.ScrollBars = System.Windows.Forms.ScrollBars.Both;
			this.StutilLogBox.Size = new System.Drawing.Size(496, 256);
			this.StutilLogBox.TabIndex = 13;
			this.StutilLogBox.Text = "";
			// 
			// OutputLabel
			// 
			this.OutputLabel.Location = new System.Drawing.Point(0, 216);
			this.OutputLabel.Name = "OutputLabel";
			this.OutputLabel.Size = new System.Drawing.Size(72, 16);
			this.OutputLabel.TabIndex = 15;
			this.OutputLabel.Text = "Stutil Output";
			// 
			// ExecuteButton
			// 
			this.ExecuteButton.Location = new System.Drawing.Point(296, 192);
			this.ExecuteButton.Name = "ExecuteButton";
			this.ExecuteButton.TabIndex = 10;
			this.ExecuteButton.Text = "Execute";
			this.ExecuteButton.Click += new System.EventHandler(this.ExecuteButton_Click);
			// 
			// timer
			// 
			this.timer.Enabled = true;
			this.timer.Interval = 500;
			this.timer.Tick += new System.EventHandler(this.Timer_Tick);
			// 
			// TitleIDLabel
			// 
			this.TitleIDLabel.Location = new System.Drawing.Point(8, 56);
			this.TitleIDLabel.Name = "TitleIDLabel";
			this.TitleIDLabel.Size = new System.Drawing.Size(56, 16);
			this.TitleIDLabel.TabIndex = 16;
			this.TitleIDLabel.Text = "TitleID";
			// 
			// TitleIDBox
			// 
			this.TitleIDBox.Location = new System.Drawing.Point(64, 48);
			this.TitleIDBox.Name = "TitleIDBox";
			this.TitleIDBox.TabIndex = 3;
			this.TitleIDBox.Text = "0";
			// 
			// EnumerateCheckBox
			// 
			this.EnumerateCheckBox.Location = new System.Drawing.Point(272, 160);
			this.EnumerateCheckBox.Name = "EnumerateCheckBox";
			this.EnumerateCheckBox.Size = new System.Drawing.Size(80, 24);
			this.EnumerateCheckBox.TabIndex = 9;
			this.EnumerateCheckBox.Text = "Enumerate";
			this.EnumerateCheckBox.CheckedChanged += new System.EventHandler(this.EnumerateChkBox_Changed);
			// 
			// MaxResultsLabel
			// 
			this.MaxResultsLabel.Location = new System.Drawing.Point(0, 128);
			this.MaxResultsLabel.Name = "MaxResultsLabel";
			this.MaxResultsLabel.Size = new System.Drawing.Size(72, 32);
			this.MaxResultsLabel.TabIndex = 14;
			this.MaxResultsLabel.Text = "Max Results (For enum)";
			// 
			// MaxResultsTextBox
			// 
			this.MaxResultsTextBox.Location = new System.Drawing.Point(64, 128);
			this.MaxResultsTextBox.Name = "MaxResultsTextBox";
			this.MaxResultsTextBox.Size = new System.Drawing.Size(32, 20);
			this.MaxResultsTextBox.TabIndex = 5;
			this.MaxResultsTextBox.Text = "0";
			// 
			// ClearButton
			// 
			this.ClearButton.Location = new System.Drawing.Point(104, 208);
			this.ClearButton.Name = "ClearButton";
			this.ClearButton.Size = new System.Drawing.Size(56, 23);
			this.ClearButton.TabIndex = 11;
			this.ClearButton.Text = "Clear";
			this.ClearButton.Click += new System.EventHandler(this.ClearButton_Clicked);
			// 
			// Form1
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(496, 494);
			this.Controls.Add(this.ClearButton);
			this.Controls.Add(this.MaxResultsTextBox);
			this.Controls.Add(this.MaxResultsLabel);
			this.Controls.Add(this.EnumerateCheckBox);
			this.Controls.Add(this.TitleIDBox);
			this.Controls.Add(this.TitleIDLabel);
			this.Controls.Add(this.ExecuteButton);
			this.Controls.Add(this.OutputLabel);
			this.Controls.Add(this.StutilLogBox);
			this.Controls.Add(this.RemoveCheckBox);
			this.Controls.Add(this.ReadCheckBox);
			this.Controls.Add(this.WriteCheckBox);
			this.Controls.Add(this.PathBox);
			this.Controls.Add(this.PathLabel);
			this.Controls.Add(this.BrowseButton);
			this.Controls.Add(this.FileNameBox);
			this.Controls.Add(this.FileNameLabel);
			this.Name = "Form1";
			this.Text = "StutilUI";
			this.Load += new System.EventHandler(this.Form1_Load);
			this.ResumeLayout(false);

		}
		#endregion

		// Entry point to starting tests
		private void BrowseButton_Click(object sender, System.EventArgs e)
		{
			
			OpenFileDialog ofd = new OpenFileDialog();
			if(ofd.ShowDialog() == DialogResult.OK)
			{
				FileName = ofd.FileName;
				FileNameBox.Text = FileName;
			}
			
		}

		private void ClearButton_Clicked(object sender, System.EventArgs e)
		{
			Log.Clear();
			UpdateLog = true;
		}
		private void ExecuteButton_Click(object sender, System.EventArgs e)
		{
			ulong titleID;
			int maxResults;
			
			if (this.TitleIDBox.Text == "")
				this.TitleIDBox.Text = "0";
			if (this.MaxResultsTextBox.Text == "")
				this.MaxResultsTextBox.Text = "0";
	
			switch(ActionItem)
			{
				case "Write":
				{
					WriteLog("Writing " + this.FileName + " to the path: " + this.PathBox.Text + "\n" );
					titleID = (ulong) Int64.Parse(this.TitleIDBox.Text,NumberStyles.HexNumber);
					stutil_test_main.WriteFileToStorage(this.FileName, this.PathBox.Text,titleID);
					break;	
				}

				case "Read":
				{
					WriteLog("Reading from path: " + this.PathBox.Text + " to the file: " + FileNameBox.Text + "\n" );
					titleID = (ulong) Int64.Parse(this.TitleIDBox.Text,NumberStyles.HexNumber);
					stutil_test_main.ReadFileFromStorage(FileNameBox.Text, this.PathBox.Text,titleID);
					break;	
				}

				case "Remove":
				{
					WriteLog("Removing from path: " + this.PathBox.Text + "\n" );
					titleID = (ulong) Int64.Parse(this.TitleIDBox.Text,NumberStyles.HexNumber);
					stutil_test_main.RemoveFileFromStorage(this.PathBox.Text,titleID);
					break;	
				}
				case "Enumerate":
				{
					WriteLog("Enumerating from path: " + this.PathBox.Text + "\n");
					titleID = (ulong) Int64.Parse(this.TitleIDBox.Text,NumberStyles.HexNumber);
					try
					{
						maxResults = (int) Int32.Parse(this.MaxResultsTextBox.Text, NumberStyles.Integer);
					}
					catch(Exception ex)
					{
						WriteLog("Invalid value, exception occurred: " + ex.ToString());
						break;
					}
					stutil_test_main.EnumerateFilesFromStorage(this.PathBox.Text, maxResults, titleID);
					break;
				}

				default:
				{
					WriteLog("No Action Item checked!! \n");
					break;
				}
			}
		}
		
		private void WriteChkBox_Changed(object sender, System.EventArgs e)
		{
			if(this.WriteCheckBox.CheckState == CheckState.Checked)
			{
				this.ReadCheckBox.Enabled = false;
				this.RemoveCheckBox.Enabled = false;
				this.EnumerateCheckBox.Enabled = false;
				this.MaxResultsTextBox.Enabled = false;
				ActionItem = "Write";
			}
			else
			{
				this.RemoveCheckBox.Enabled = true;
				this.ReadCheckBox.Enabled = true;
				this.EnumerateCheckBox.Enabled = true;
				this.MaxResultsTextBox.Enabled = true;
				ActionItem = null;
			}
		}

		private void ReadChkBox_Changed(object sender, System.EventArgs e)
		{
			if(this.ReadCheckBox.CheckState == CheckState.Checked)
			{
				this.RemoveCheckBox.Enabled = false;
				this.WriteCheckBox.Enabled = false;
				this.EnumerateCheckBox.Enabled = false;
				this.MaxResultsTextBox.Enabled = false;
				ActionItem = "Read";
			}
			else
			{
				this.WriteCheckBox.Enabled = true;
				this.RemoveCheckBox.Enabled = true;
				this.EnumerateCheckBox.Enabled = true;
				this.MaxResultsTextBox.Enabled = true;
				ActionItem = null;
			}
		}

		private void RemoveChkBox_Changed(object sender, System.EventArgs e)
		{
			if(this.RemoveCheckBox.CheckState == CheckState.Checked)
			{
				this.WriteCheckBox.Enabled = false;
				this.ReadCheckBox.Enabled = false;
				this.EnumerateCheckBox.Enabled = false;
				this.MaxResultsTextBox.Enabled = false;
				this.FileNameBox.Enabled = false;
				this.BrowseButton.Enabled = false;
				ActionItem = "Remove";
			}
			else
			{
				this.WriteCheckBox.Enabled = true;
				this.ReadCheckBox.Enabled = true;
				this.EnumerateCheckBox.Enabled = true;
				this.MaxResultsTextBox.Enabled = true;
				this.FileNameBox.Enabled = true;
				this.BrowseButton.Enabled = true;
				ActionItem = null;
			}
		}

		private void EnumerateChkBox_Changed(object sender, System.EventArgs e)
		{
			if(this.EnumerateCheckBox.CheckState == CheckState.Checked)
			{
				this.WriteCheckBox.Enabled = false;
				this.ReadCheckBox.Enabled = false;
				this.RemoveCheckBox.Enabled = false;
				this.FileNameBox.Enabled = false;
				this.BrowseButton.Enabled = false;
				ActionItem = "Enumerate";
			}
			else
			{
				this.WriteCheckBox.Enabled = true;
				this.ReadCheckBox.Enabled = true;
				this.RemoveCheckBox.Enabled = true;
				this.FileNameBox.Enabled = true;
				this.BrowseButton.Enabled = true;
				ActionItem = null;
			}
		}

		private void Timer_Tick(object sender, System.EventArgs e)
		{
			UpdateStutilLogBox();
		}

		private void Form1_Load(object sender, System.EventArgs e)
		{
		
		}
		
		public void UpdateStutilLogBox()
		{
			if(UpdateLog)
			{
				this.StutilLogBox.Text = "";

				foreach(string s in Log)
				{
					this.StutilLogBox.Text += s + "\r\n";
				}
				UpdateLog = false;
			}
		}

		public void WriteLog(string s)
		{
			Log.Add(s + "\n");
			UpdateLog = true;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\TacticsLog\TacticsLog.cpp ===
//-----------------------------------------------------------------------------
// XBox Online
//
// File:			TacticsLog.cpp
//
// Copyright:		Copyright (c) 2001 Microsoft Corporation
//
// Comments: 	This is a piece of demo code to show testers how to use the TLDBroutines
//				includes to add test case info to Tactics.
//
// Dependencies - Tactics Database
//
// History:		9/17/2001	JohnBlac	Created
//
//-----------------------------------------------------------------------------

#ifdef UNICODE
#ifndef _UNICODE
#define _UNICODE    1
#endif
#endif

#include "stdafx.h"
#include "TacticsLog.h"

// Globals
CTLDBRoutines *g_pTLDBRoutines = NULL;	//Accessing the TacticsLog databases on SQL server.

//-----------------------------------------------------------------------------
//
// TacticsLogInit
//
// Allocates memory for global data structures required throughout the program
//
HRESULT TacticsLogInit()
{
	HRESULT hr = S_OK;

	//Create and initialize the g_pTLDBRoutines object
	g_pTLDBRoutines = new CTLDBRoutines;
	if ( NULL == g_pTLDBRoutines )
	{
		wprintf(L"TacticsLogInit() - Failed to allocate g_pTLDBRoutines.\n");
		return E_OUTOFMEMORY;
	}

	return S_OK;
}


//-----------------------------------------------------------------------------
//
// Usage
//
// Simply outputs the command line useage for this program.
//
void Usage()
{
	wprintf(L"Usage: TacticsLog\n");
	wprintf(L"Example: %s\\>TacticsLog\n");
}


//-----------------------------------------------------------------------------
//
// Main
//
// Duh...
//
int WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
{
	// USES_CONVERSION;
	HRESULT hr = S_OK;		// HResult for local functions	
	DWORD iReturn = 0;		// Return value

	CTestData g_CTestData;
	TestRow	g_sTestInfo;
	
	// Initialize COM
	if(FAILED(CoInitializeEx(NULL, COINIT_MULTITHREADED)))
	{
		wprintf(L"Failed to initialize COM. Test Aborted.\n");
		goto Error;
	}

	// Initialize TacticsLog
	hr = TacticsLogInit();
	if( FAILED(hr) )
	{
		wprintf(L"Failed to initialize TacticsLog hr = %x. Test Aborted.\n", hr );
		goto Error;
	}

	// Make connection to SQL server
	hr = g_pTLDBRoutines->Init();
	if ( FAILED(hr) )
	{
		wprintf(L"g_pTLDBRoutines->Init() failed. Error code %x.\n", hr );
		wprintf(L"Failed to read test data, check the name of the test in the ini file.\n");
		goto Error;
	}

	g_sTestInfo.nTestCase = 532;
	hr = g_pTLDBRoutines->GetTestData(&g_sTestInfo);
	if(FAILED(hr))
	{
		wprintf(L"g_pTLDBRoutines->GetTestInfo failed. Error code %x.\n", hr );
		wprintf(L"Failed to fetch info for test case. %d\n", g_sTestInfo.nTestCase);
		goto Error;
	}

	// Fill out test case info:
	g_CTestData.m_nTestCase = 144;
	g_CTestData.m_nConfig = 1;
	g_CTestData.m_nMethod = 6;	
	g_CTestData.m_nMilestone = 10;	
	g_CTestData.m_nStatus = 1;
	g_CTestData.m_nType = 31;
	MySnPrintf(g_CTestData.m_szBuild, k_ui32Buffer, "1111.123456");
	MySnPrintf(g_CTestData.m_szPassNum, k_ui32Buffer, "7");
	MySnPrintf(g_CTestData.m_szComments, k_ui1000Buffer, "comments");

	hr = g_pTLDBRoutines->AddTestResult(&g_CTestData, L"aaronlie");
	if(FAILED(hr))
	{
		wprintf(L"g_pTLDBRoutines->AddTestCase() failed. Error code %x.\n", hr );
		wprintf(L"Failed to submit new log info for test case. %d\n", g_CTestData.m_nTestCase);
		goto Error;
	}
	
	wprintf(L"Test case info submitted successfully.\n");

Cleanup:
	CoUninitialize();

	delete g_pTLDBRoutines;

	return iReturn;
Error:
	iReturn = 0;
	wprintf(L"TacticsLog failed to add the test case... Quitting\n");
	// This acts as a marker for Test Enterprise to know that the test is done.
	goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\TacticsLog\TacticsLog.h ===
//-----------------------------------------------------------------------------
// XBox Online
//
// File:			TacticsLog.h
//
// Copyright:		Copyright (c) 2000-2001 Microsoft Corporation
//
// Comments: 		Struct and function declarations for TacticsLog.
//
// History:		9/17/2001	JohnBlac	Created
//
//-----------------------------------------------------------------------------

#ifndef _TacticsLog_h_
#define _TacticsLog_h_

// Function declarations
BOOL
ParseCommandLine (
	LPCTSTR lpCmdLine, 
	WCHAR* pwszIniFile);

DWORD
ReadIni (
	WCHAR* ThisIniFile);

void 
Usage();

HRESULT
TacticsLogInit();

#endif // _TacticsLog_h_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\TestTracker\PageDefaults.cs ===
using System;
using System.Web.UI;
using System.Web.UI.HtmlControls;
using System.Web.SessionState;
using System.Collections;
using System.Collections.Specialized;
using System.Data;
using System.Data.Odbc;

namespace TestTracker
{
	/// <summary>
	/// Summary description for PageDefaults.
	/// </summary>
	public class PageDefaults : System.Web.UI.Page
	{
		public static string PSDBAddUpdateString = "Add/Update";
		public static string PSDBDeleteString = "Delete";

		protected NameValueCollection nvc;

		protected BugManager bugs = new BugManager();
		protected Hashtable TestSuites  = new Hashtable();

		protected int TestSuiteID = -1;

		public PageDefaults()
		{
			// this.HasChildViewState = false;
			// this.IsTrackingViewState = false;
			this.EnableViewState = false;

			nvc = (NameValueCollection) System.Configuration.ConfigurationSettings.GetConfig("Connections");
		}

		public OdbcConnection RegressionDB()
		{
			System.Data.Odbc.OdbcConnection con = new OdbcConnection("DRIVER={SQL Server};SERVER=" + nvc["RegressionDBServer"] + ";DATABASE=" + nvc["RegressionDB"] + ";UID=;PWD=;NETWORK=dbmssocn");
			con.Open();
			
			return con;
		}

		enum BugsForSuiteFields
		{
			ComponentID,
			TestGroupID,
			TestCaseID,
			Component,
			TestGroup,
			TestCase,
			BugDBID,
			BugID,
		};

		#region public string CleanUrl
		public string CleanUrl
		{
			get 
			{
				string s = Request.Url.AbsoluteUri;
				s.Substring(s.Length - Request.Url.Query.Length);
				return s;
			}
		}
		#endregion

		#region protected void GetTestSuites(OdbcConnection con, BugManager bugs)
		protected void GetTestSuites(OdbcConnection con, BugManager bugs)
		{
			OdbcCommand com = con.CreateCommand();
			com.CommandType = CommandType.StoredProcedure;
			com.CommandText = "{ call sp_BugsForSuites }";

			OdbcDataReader reader = com.ExecuteReader();
			try
			{
				int lastcompid = -1, lasttgid = -1, lasttcid = -1;
				int compid, tgid, tcid;
				TestSuite curts = null;
				TestGroup curtg = null;
				TestCase curtc = null;
				while(reader.Read())
				{
					compid = reader.GetInt32((int) BugsForSuiteFields.ComponentID);
					tgid = reader.GetInt32((int) BugsForSuiteFields.TestGroupID);
					tcid = reader.IsDBNull((int) BugsForSuiteFields.TestCaseID) ? -1 : reader.GetInt32((int) BugsForSuiteFields.TestCaseID);
					if(compid != lastcompid)
					{
						curts = new TestSuite(bugs, compid, reader.GetString((int) BugsForSuiteFields.Component));
						TestSuites[compid] = curts;
						lastcompid = compid;
					}
					if(tgid != lasttgid)
					{
						curtg = curts.Add(tgid, reader.GetString((int) BugsForSuiteFields.TestGroup));
						lasttgid = tgid;
					}
					if(tcid != lasttcid)
					{
						curtc = curtg.Add(tcid, reader.GetString((int) BugsForSuiteFields.TestCase));
						lasttcid = tcid;
					}
					int bugdb = reader.GetInt32((int) BugsForSuiteFields.BugDBID);
					int bugid = reader.GetInt32((int) BugsForSuiteFields.BugID);
					// Not a bug, no more work to do so skip
					if(bugdb == -1 || bugid == -1)
						continue;
					if(curtc != null)
						curtc.Bug(bugdb, bugid);
					if(curtg != null)
						curtg.Bug(bugdb, bugid);
					if(curts != null)
						curts.Bug(bugdb, bugid);
				}
			}
			finally
			{
				reader.Close();
			}
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\TestTracker\Iterations.cs ===
using System;

namespace TestTracker
{
	/// <summary>
	/// Summary description for Iterations.
	/// </summary>
	public class Iterations
	{
		public Iterations()
		{
			//
			// TODO: Add constructor logic here
			//
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\TestTracker\Global.asax.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Web;
using System.Web.SessionState;

namespace TestTracker 
{
	/// <summary>
	/// Summary description for Global.
	/// </summary>
	public class Global : System.Web.HttpApplication
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		public Global()
		{
			InitializeComponent();
		}	
		
		protected void Application_Start(Object sender, EventArgs e)
		{

		}
 
		protected void Session_Start(Object sender, EventArgs e)
		{

		}

		protected void Application_BeginRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_EndRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_AuthenticateRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_Error(Object sender, EventArgs e)
		{

		}

		protected void Session_End(Object sender, EventArgs e)
		{

		}

		protected void Application_End(Object sender, EventArgs e)
		{

		}
			
		#region Web Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.components = new System.ComponentModel.Container();
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\TestTracker\default.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Data.Odbc;
using System.Text;

namespace TestTracker
{
	/// <summary>
	/// Summary description for WebForm1.
	/// </summary>
	public class Tracker : PageDefaults
	{
		protected System.Web.UI.WebControls.Label body;
		protected System.Web.UI.WebControls.Label bodytitle;
		protected System.Web.UI.WebControls.Label leftnav;

		bool Admin = false;
		private void Page_Load(object sender, System.EventArgs e)
		{
			if(Request.QueryString["Admin"] != null)
			{
				try
				{
					Admin = Convert.ToInt32(Request.QueryString["Admin"]) != 0;
				}
				catch
				{
				}
			}

			if(Request.QueryString["TestSuiteID"] != null)
			{
				try
				{
					TestSuiteID = Convert.ToInt32(Request.QueryString["TestSuiteID"]);
				}
				catch
				{
				}
			}

			OdbcConnection con = RegressionDB();
			try
			{
				GetTestSuites(con, bugs);
				bugs.PopulateBugs(con);
				PopulateLeftNav();
				PopulateBody();
			}
			finally
			{
				con.Close();
			}
		}

		#region void PopulateLeftNav()
		void PopulateLeftNav()
		{
			BugStats cumulative;
			StringBuilder sb = new StringBuilder();
			sb.Append("<table width=100% border=0>\n<tr><td colspan=3><a href=\"" + CleanUrl + "\">Home</a></td></tr>\n");
			sb.Append("<table width=100% border=0>\n<tr><td colspan=3><a href=\"" + CleanUrl + "?Admin=1\">Admin</a></td></tr>\n");
			// Loop here
			foreach(TestSuite ts in TestSuites.Values)
			{
				if(TestSuiteID >= 0 && ts.ID != TestSuiteID)
					continue;
				ts.CalculateBugStats();
				// Test Suite info:
				sb.Append("<tr><td colspan=3 CLASS=\"TDTESTSUITE\">\n<A CLASS=\"TESTSUITE\" HREF=\"default.aspx?TestSuiteID=").Append(ts.ID).Append("\">");
				sb.Append(ts.Name);
				sb.Append("</A> <B>*</B> <SPAN CLASS=\"SUBCOUNT\">Groups: ");
				sb.Append(ts.TestGroups.Count.ToString());
				sb.Append("</SPAN> ");
				cumulative = ts.CumulativeStats;
				sb.Append(cumulative.HtmlDisplayString(BugStatus.Active | BugStatus.Resolved | BugStatus.Closed, "TestSuiteID=" + ts.ID.ToString()));
				sb.Append("</td></tr>\n");
				// Test Groups:
				foreach(TestGroup tg in ts.TestGroups.Values)
				{
					sb.Append("<tr><td CLASS=\"LEFTNAVINDENT\" width=15>&nbsp;</td><td colspan=2 CLASS=\"TDTESTGROUP\">\n<SPAN CLASS=\"TESTGROUP\">");
					sb.Append(tg.Name);
					sb.Append("</SPAN> <B>*</B> <SPAN CLASS=\"SUBCOUNT\">Cases: ");
					sb.Append(tg.TestCases.Count.ToString());
					sb.Append("</SPAN> ");
					cumulative = tg.CumulativeStats;
					sb.Append(cumulative.HtmlDisplayString(BugStatus.Active | BugStatus.Resolved | BugStatus.Closed, "TestSuiteID=" + ts.ID.ToString()));
					sb.Append("</td></tr>\n");
					if(TestSuiteID != ts.ID)
						continue;

					foreach(TestCase tc in tg.TestCases.Values)
					{
						sb.Append("<tr><td CLASS=\"LEFTNAVINDENT\" width=15>&nbsp;</td><td CLASS=\"LEFTNAVINDENT\" width=15>&nbsp;</td><td CLASS=\"TDTESTCASE\">\n<SPAN CLASS=\"TESTCASE\">");
						sb.Append("");
						sb.Append(tc.Name);
						sb.Append("</SPAN> ");
						cumulative = tc.CumulativeStats;
						if(cumulative.Active + cumulative.Resolved + cumulative.Closed + cumulative.Unknown > 0)
							sb.Append("<B>*</B> ");
						sb.Append(cumulative.HtmlDisplayString(BugStatus.Active | BugStatus.Resolved | BugStatus.Closed, "TestSuiteID=" + ts.ID.ToString()));
						sb.Append("</td></tr>\n");
					}
				}
			}
			sb.Append("</table>\n");
			leftnav.Text = sb.ToString();
		}

		#endregion

		#region void PopulateBody()
		void PopulateBody()
		{
			BugStats cumulative;
			StringBuilder sb = new StringBuilder();
			int fieldcount = 0;
			if(Admin)
			{
				bodytitle.Text = "<SPAN CLASS=\"BODYTITLE\">Administration</SPAN>";
				sb.Append("<p>This administration page allows modifying the databases available for adding bugs to test cases.  Be VERY CAREFUL deleting databases as doing so will also delete ALL BUGS for that database.</p>");
				sb.Append("<p>Current Product Studio databases:\n");
				sb.Append("<CENTER>\n");
				sb.Append("\t<table border=1>\n");
				sb.Append("\t\t<tr><th>Name</th><th>Server</th><th>Database</th><th>Bugs</th><th>Delete</th></tr>\n");
				foreach(int dbid in bugs.AllDatabaseIDs)
				{
					sb.Append("\t\t<tr><td>").Append(bugs.DBName(dbid)).Append("</td>");
					sb.Append("<td>").Append(bugs.DBServer(dbid)).Append("</td>");
					sb.Append("<td>").Append(bugs.DBDatabase(dbid)).Append("</td>");
					sb.Append("<td align=center>").Append(bugs.DBBugCount(dbid)).Append("</td>");
					sb.Append("<td><br><form name=\"DELETE_").Append(bugs.DBName(dbid)).Append("\" action=\"PSDB.aspx?\" method=\"get\"><input type=\"hidden\" name=\"Name\" value=\"");
					sb.Append(bugs.DBName(dbid)).Append("\"></input><button name=\"Submit\" value=\"Submit\" type=\"submit\">");
					sb.Append(PSDBDeleteString).Append("</button></form></td></tr>\n");
				}
				sb.Append("\t</table>\n");
				sb.Append("</CENTER>\n");

				sb.Append("<p>To get the current product studio server and database, you can use the web site at <a href=\"http://pssupport/\">Product Studio Support</a> to retrieve server and database information for two-tier access (which is used in this site to retrieve bug data from Product Studio--you may need to request two-tier access from your Product Studio admin).</p>\n");

				sb.Append("<form name=\"AddPSDB\" action=\"PSDB.aspx\" method=\"get\">\n");
				sb.Append("\t<table border=0>\n");
				sb.Append("\t\t<tr><td colspan=3>Add/Update Product Studio Database:</td></tr>");
				sb.Append("\t\t<tr><td width=30>&nbsp;</td><td>Name:</td><td><input name=\"Name\" size=\"30\" /></td></tr>\n");
				sb.Append("\t\t<tr><td width=30>&nbsp;</td><td>Server:</td><td><input name=\"Server\" size=\"30\" /></td></tr>\n");
				sb.Append("\t\t<tr><td width=30>&nbsp;</td><td>Database:</td><td><input name=\"Database\" size=\"30\" /></td></tr>\n");
				sb.Append("\t\t<tr><td width=30>&nbsp;</td><td>&nbsp;</td><td><button name=\"Submit\" value=\"Submit\" type=\"submit\">").Append(PSDBAddUpdateString).Append("</button></td></tr>\n");
				sb.Append("\t</table>\n");
				sb.Append("</form>\n");
				body.Text = sb.ToString();
				return;
			}

			bodytitle.Text = "<SPAN CLASS=\"BODYTITLE\">Home</SPAN>";
			if(TestSuiteID < 0)
			{
				fieldcount = BugInfo.FieldsInHtmlDisplay + 2;
			}
			else
			{
				fieldcount = BugInfo.FieldsInHtmlDisplay + 3;
			}


			sb.Append("<table width=100% border=0 cellpadding=0 cellspacing=0>\n");
			// Loop here
			foreach(TestSuite ts in TestSuites.Values)
			{
				// Set the body title text.
				if(TestSuiteID > 0 && TestSuiteID != ts.ID)
					continue;
				if(TestSuiteID == ts.ID)
					bodytitle.Text = "<SPAN CLASS=\"BODYTITLE\">Test Suite: " + ts.Name + "</SPAN>";
				if(TestSuiteID < 0 && ts.DatabaseIDs.Count == 0)
					continue;
				// Test Suite info:
				sb.Append("<tr><td colspan=").Append(fieldcount).Append(" CLASS=\"TDTESTSUITE\">\n<SPAN CLASS=\"TESTSUITE\">");
				sb.Append(ts.Name);
				sb.Append("</SPAN> <B>*</B> <SPAN CLASS=\"SUBCOUNT\">Groups: ");
				sb.Append(ts.TestGroups.Count.ToString());
				sb.Append("</SPAN> ");
				cumulative = ts.CumulativeStats;
				sb.Append(cumulative.HtmlDisplayString(BugStatus.Active | BugStatus.Resolved | BugStatus.Closed, "TestSuiteID=" + ts.ID.ToString()));
				sb.Append("</td></tr>\n");

				foreach(int dbid in ts.DatabaseIDs)
				{
					sb.Append("<tr><td CLASS=\"BODYINDENT\" width=15>&nbsp;</td><td colspan=").Append(fieldcount - 1).Append(" CLASS=\"TDBUGDATABASE\">\n<SPAN CLASS=\"BUGDATABASE\">Product Studio Database: ");
					sb.Append(ts.DBName(dbid));
					sb.Append("</SPAN></td></tr>\n");
					foreach(BugInfo bi in ts.Bugs(dbid))
					{
						sb.Append("<tr><td CLASS=\"BODYINDENT\" width=15>&nbsp;</td><td CLASS=\"BODYINDENT\" width=15>&nbsp;</td>");
						sb.Append(bi.HtmlDisplayString);
						sb.Append("</tr>\n");
					}
				}

				if(TestSuiteID != ts.ID)
					continue;
/*
				foreach(TestGroup tg in ts.TestGroups.Values)
				{
				}
*/			}
			sb.Append("</table>\n");
			body.Text = sb.ToString();
		}
		#endregion

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.ID = "Page";
			this.Load += new System.EventHandler(this.Page_Load);

		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\TestTracker\TestData.cs ===
using System;
using System.Collections;
using System.Data.Odbc;
using System.Text;

namespace TestTracker
{
	/// <summary>
	/// Summary description for TestData.
	/// </summary>
	public class TestData : BugManager
	{
		int myid = -1;
		string myname = null;
		BugManager mybm;
		Hashtable mybugstats = new Hashtable();
		BugStats cumulative = new BugStats();
		public TestData(BugManager bm, int id, string name)
		{
			mybm = bm;
			myid = id;
			myname = name;
		}
		#region Accessors
		public BugManager BugMgr
		{
			get{return mybm;}
		}
		public string Name
		{
			get{return myname;}
		}
		public int ID
		{
			get{return myid;}
		}
		public Hashtable BugStats
		{
			get{return mybugstats;}
		}
		public BugStats CumulativeStats
		{
			get{return cumulative;}
		}
		#endregion

		#region public override string DBName(int id)
		public override string DBName(int id)
		{
			return mybm.DBName(id);
		}
		#endregion

		#region public void CalculateBugStats()
		public void CalculateBugStats()
		{
			foreach(int dbid in DatabaseIDs)
			{
				BugStats bs = (BugStats) mybugstats[DBName(dbid)];
				if(bs == null)
				{
					bs = new BugStats();
					mybugstats[DBName(dbid)] = bs;
				}
				foreach(BugInfo bi in Bugs(dbid))
				{
					switch(bi.Status)
					{
						case BugStatus.Active:
							cumulative.Active++;
							bs.Active++;
							break;
						case BugStatus.Resolved:
							cumulative.Resolved++;
							bs.Resolved++;
							break;
						case BugStatus.Closed:
							cumulative.Closed++;
							bs.Closed++;
							break;
						case BugStatus.Unknown:
							cumulative.Unknown++;
							bs.Unknown++;
							break;
					};
				}
			}
			RecurseCalculate();
		}
		#endregion

		#region protected virtual void RecurseCalculate()
		protected virtual void RecurseCalculate()
		{
		}
		#endregion

		#region public BugInfo Bug(int db, int id)
		public override BugInfo Bug(int db, int id)
		{
			BugInfo bi = (BugInfo) mybm.Bug(db, id);
			Bug(bi);
			return bi;
		}
		#endregion
	}

	#region public class TestSuite : TestData
	public class TestSuite : TestData
	{
		Hashtable testgroups = new Hashtable();

		public TestSuite(BugManager bm, int id, string name) : base(bm, id, name)
		{
		}

		public TestGroup Add(int id, string name)
		{
			TestGroup tg = (TestGroup) testgroups[id];
			if(tg == null)
			{
				tg = new TestGroup(BugMgr, id, name);
				testgroups[id] = tg;
			}
			return tg;
		}

		public Hashtable TestGroups
		{
			get{ return testgroups; }
		}

		public TestGroup Get(int id)
		{
			return (TestGroup) testgroups[id];
		}

		protected override void RecurseCalculate()
		{
			foreach(TestGroup tg in testgroups.Values)
			{
				tg.CalculateBugStats();
			}
		}
	}
	#endregion

	#region public class TestGroup : TestData
	public class TestGroup : TestData
	{
		Hashtable testcases = new Hashtable();

		public TestGroup(BugManager bm, int id, string name) : base(bm, id, name)
		{
		}

		protected override void RecurseCalculate()
		{
			foreach(TestCase tc in testcases.Values)
			{
				tc.CalculateBugStats();
			}
		}

		public Hashtable TestCases
		{
			get{ return testcases; }
		}

		public TestCase Add(int id, string name)
		{
			TestCase tc = (TestCase) testcases[id];
			if(tc == null)
			{
				tc = new TestCase(BugMgr, id, name);
				testcases[id] = tc;
			}
			return tc;
		}

		public TestCase Get(int id)
		{
			return (TestCase) testcases[id];
		}
	}
	#endregion

	#region public class TestCase : TestData
	public class TestCase : TestData
	{
		public TestCase(BugManager bm, int id, string name) : base(bm, id, name)
		{
		}
	}
	#endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\TestTracker\PSDB.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Data.Odbc;

namespace TestTracker
{
	/// <summary>
	/// Summary description for AddPSDB.
	/// </summary>
	public class AddPSDB : PageDefaults
	{
		private void Page_Load(object sender, System.EventArgs e)
		{
			string name = Request.QueryString["Name"];
			string server = Request.QueryString["Server"];
			string db = Request.QueryString["Database"];
			string action = Request.QueryString["Submit"];
			if( (action != PSDBAddUpdateString && action != PSDBDeleteString) ||
				(action == PSDBAddUpdateString && 
				 (name == null || name == "" ||
				  server == null || server == "" ||
				  db == null || db == "")) ||
				(action == PSDBDeleteString &&
				 (name == null || name == "")))
			{
				Response.Write("Only valid operations are add/update and delete.<br>\n");
				Response.Write("All of the following query string parameters are required for adding/updating a database: Name, Server, and Database.<br>\n");
				Response.Write("All of the following query string parameters are required for deleting a database: Name.<br>\n");
				Response.Write("This request failed.");
				Response.End();
			}

			OdbcConnection con = RegressionDB();
			try
			{
				OdbcCommand com = con.CreateCommand();
				com.CommandType = CommandType.StoredProcedure;
				if(action == PSDBAddUpdateString)
				{
					com.CommandText = "{ call sp_InsertPSDatabase(?, ?, ?) }";
					com.Parameters.Add("@Name", name);
					com.Parameters.Add("@Server", server);
					com.Parameters.Add("@DB", db);
				}
				else if(action == PSDBDeleteString)
				{
						com.CommandText = "{ call sp_DeletePSDatabase(?) }";
						com.Parameters.Add("@Name", name);
				}
				com.ExecuteNonQuery();
				Response.Redirect(Request.UrlReferrer.AbsoluteUri, false);
			}
			catch(System.Exception ex)
			{
				Response.Write("<pre>");
				Response.Write(ex.ToString());
				Response.Write("</pre>");

			}
			finally
			{
				con.Close();
			}
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Load += new System.EventHandler(this.Page_Load);
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\TestTracker\Bugs.cs ===
using System;
using System.Collections;
using System.Data.Odbc;
using System.Data;
using System.Text;
using System.Web;

namespace TestTracker
{
	public enum BugQueryFields : int
	{
		BugID = 0,
		Title = 1,
		Status = 2,
		AssignedTo = 3,
		Severity = 4,
		Priority = 5,
		ChangedDate = 6,
		TreePath = 7,
		FieldCount = 8
	};

	public enum BugStatus
	{
		Unknown = 1,
		Active = 2,
		Resolved = 4,
		Closed = 8
	};

	#region public class BugStats
	public class BugStats
	{
		public uint Active;
		public uint Resolved;
		public uint Closed;
		public uint Unknown;
		public BugStats()
		{
			Active = Resolved = Closed = Unknown = 0;
		}

		public void Add(BugStats bs)
		{
			Active += bs.Active;
			Resolved += bs.Resolved;
			Closed += bs.Closed;
			Unknown += bs.Unknown;
		}

		#region public string HtmlDisplayString(BugStatus flags)
		public string HtmlDisplayString(BugStatus flags, string querystring)
		{
			if((((flags & BugStatus.Active) == BugStatus.Active) ? Active : 0) + 
				(((flags & BugStatus.Resolved) == BugStatus.Resolved) ? Resolved : 0) + 
				(((flags & BugStatus.Closed) == BugStatus.Closed) ? Closed : 0) + 
				(((flags & BugStatus.Unknown) == BugStatus.Unknown) ? Unknown : 0) == 0)
				return "";
			StringBuilder sb = new StringBuilder();
			if(querystring != null)
				sb.Append("<A HREF=\"psq.aspx?").Append(querystring).Append("\"");
			else
				sb.Append("<SPAN");
			sb.Append(" CLASS=\"BUGSTATUS\">Bugs: ");
			if(Active > 0)
			{
				sb.Append("<SPAN CLASS=\"BUGACTIVE\"> ");
				sb.Append(Active.ToString());
				sb.Append(" </SPAN>");
			}
			if(Resolved > 0)
			{
				sb.Append("<SPAN CLASS=\"BUGRESOLVED\"> ");
				sb.Append(Resolved.ToString());
				sb.Append(" </SPAN>");
			}
			if(Closed > 0)
			{
				sb.Append("<SPAN CLASS=\"BUGCLOSED\"> ");
				sb.Append(Closed.ToString());
				sb.Append(" </SPAN>");
			}
			if(Unknown > 0)
			{
				sb.Append("<SPAN CLASS=\"BUGUNKNOWN\"> ");
				sb.Append(Unknown.ToString());
				sb.Append(" </SPAN>");
			}
			if(querystring != null)
				sb.Append("</A>\n");
			else
				sb.Append("</SPAN>\n");
			return sb.ToString();
		}
		#endregion 
	}
	#endregion

	public class BugManager
	{
		Hashtable bugdbs = new Hashtable();
		Hashtable dbinfo = new Hashtable();

		protected Hashtable GetBugDB(int bugdb)
		{
			Hashtable bugs = (Hashtable) bugdbs[bugdb];
			if(bugs == null)
			{
				bugs = new Hashtable();
				bugdbs[bugdb] = bugs;
			}
			return bugs;
		}

		public virtual BugInfo Bug(int bugdb, int bugid)
		{
			Hashtable bugs = GetBugDB(bugdb);
			BugInfo bi = (BugInfo) bugs[bugid];
			if(bi == null)
			{
				bi = new BugInfo(bugdb, bugid);
				bugs[bugid] = bi;
			}

			return bi;
		}

		// Used by inherited classes to add bugs to their local store of bugs.
		protected void Bug(BugInfo bi)
		{
			Hashtable bugs = GetBugDB(bi.BugDB);
			BugInfo lookup = (BugInfo) bugs[bi.BugID];
			if(lookup != null)
				return;
			bugs[bi.BugID] = bi;
		}

		public int DBBugCount(int dbid)
		{
			Hashtable ht = (Hashtable) bugdbs[dbid];
			if(ht == null)
				return 0;
			return ht.Count;
		}

		public ICollection AllDatabaseIDs
		{
			get {return dbinfo.Keys; }
		}

		public ICollection DatabaseIDs
		{
			get { return bugdbs.Keys; }
		}

		public ICollection Bugs(int dbid)
		{
			Hashtable ht = (Hashtable) bugdbs[dbid];
			if(ht == null)
				return null;
			return ht.Values;
		}

		class PSDB
		{
			public int id;
			public string name;
			public string server;
			public string db;
			public string user;
			public string pwd;
		};

		public virtual string DBName(int id)
		{
			PSDB db = ((PSDB) dbinfo[id]);
			return (db == null ? null : db.name);
		}

		public virtual string DBServer(int id)
		{
			PSDB db = ((PSDB) dbinfo[id]);
			return (db == null ? null : db.server);
		}

		public virtual string DBDatabase(int id)
		{
			PSDB db = ((PSDB) dbinfo[id]);
			return (db == null ? null : db.db);
		}

		/// <summary>
		/// Generates the PSQ file and uses the HttpResponse object to set headers and send the data to the client.
		/// </summary>
		/// <param name="response">HttpResponse object for the user to send the response to</param>
		#region public void SendPSQ(HttpResponse response)
		public void SendPSQ(HttpResponse response)
		{
			if(DatabaseIDs.Count == 0)
			{
				response.Write("There are no bugs to generate a Product Studio Query file for.");
				response.End();
			}

			response.Clear();
			response.CacheControl = "Public";
			response.ContentType = "application/x-productstudio";
			response.AddHeader("content-disposition", "attachment;filename=testtracker.psq"); 
			response.ExpiresAbsolute = new DateTime(0);
			response.Cache.SetNoServerCaching();
			
			bool dbpass1 = true;
			StringBuilder sb = new StringBuilder();
			sb.Append("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
			sb.Append("<!-- If this file is displaying in Internet Explorer and not opening up Product Studio, click on <a href=\"psq.reg\">Product Studio registration file</a> -->\n");
			sb.Append("<Data Application=\"Product Studio\" Type=\"Query\" Version=\"2.1\">\n");
			foreach(int dbid in DatabaseIDs)
			{
				if(dbpass1)
				{
					sb.Append("\t<Query Product=\"").Append(DBName(dbid)).Append("\" CurrentMode=\"Bugs\" CurrentTree=\"1\">\n");
					sb.Append("\t\t<Mode Type=\"Bugs\" ModeFormat=\"QueryBuilder\">\n");
					sb.Append("\t\t\t<QueryBuilder>\n");
					sb.Append("\t\t\t\t<Expression AttachWith=\"\" Field=\"Product\" Operator=\"Equals\" Value=\"").Append(DBName(dbid)).Append("\"/>\n");
					dbpass1 = false;
				}
				else
				{
					sb.Append("\t\t\t\t<Expression AttachWith=\"Or\" Field=\"Product\" Operator=\"Equals\" Value=\"").Append(DBName(dbid)).Append("\"/>\n");
				}
				bool bugpass1 = true;
				foreach(BugInfo bi in Bugs(dbid))
				{
					sb.Append("\t\t\t\t<Expression AttachWith=\"").Append(bugpass1 ? "And" : "Or").Append("\" Field=\"ID\" Operator=\"Equals\" Value=\"").Append(bi.BugID).Append("\"/>\n");
					bugpass1 = false;
				}
			}
			sb.Append("\t\t\t</QueryBuilder>\n");
			sb.Append("\t\t\t<ResultList>\n");
			sb.Append("\t\t\t\t<DisplayColumns>\n");
			sb.Append("\t\t\t\t\t<Column Name=\"ID\" Width=\"60\"/>\n");
			sb.Append("\t\t\t\t\t<Column Name=\"Priority\" Width=\"61\"/>\n");
			sb.Append("\t\t\t\t\t<Column Name=\"Severity\" Width=\"69\"/>\n");
			sb.Append("\t\t\t\t\t<Column Name=\"Status\" Width=\"71\"/>\n");
			sb.Append("\t\t\t\t\t<Column Name=\"Changed Date\" Width=\"112\"/>\n");
			sb.Append("\t\t\t\t\t<Column Name=\"Assigned to\" Width=\"99\"/>\n");
			sb.Append("\t\t\t\t\t<Column Name=\"Title\" Width=\"556\"/>\n");
			sb.Append("\t\t\t\t</DisplayColumns>\n");
			sb.Append("\t\t\t\t<SortColumns>\n");
			sb.Append("\t\t\t\t\t<Column Name=\"Status\" Ascending=\"-1\"/>\n");
			sb.Append("\t\t\t\t\t<Column Name=\"Assigned to\" Ascending=\"-1\"/>\n");
			sb.Append("\t\t\t\t\t<Column Name=\"Priority\" Ascending=\"-1\"/>\n");
			sb.Append("\t\t\t\t\t<Column Name=\"Severity\" Ascending=\"-1\"/>\n");
			sb.Append("\t\t\t\t\t<Column Name=\"ID\" Ascending=\"-1\"/>\n");
			sb.Append("\t\t\t\t</SortColumns>\n");
			sb.Append("\t\t\t</ResultList>\n");
			sb.Append("\t\t</Mode>\n");
			sb.Append("\t</Query>\n");
			sb.Append("</Data>\n");

			response.Write(sb.ToString());
			response.End();
		}
		#endregion

		/// <summary>
		/// First stage and only publicly visible method for populating the bugs.
		/// Takes all of the bugs added and given the connection to the regression database looks up the bug status for all bugs.
		/// </summary>
		/// <param name="regdb">Odbc Connection to the regression database</param>
		#region public void PopulateBugs(OdbcConnection regdb)
		public void PopulateBugs(OdbcConnection regdb)
		{
			OdbcDataReader reader = null;
			try
			{
				OdbcCommand com = regdb.CreateCommand();
				com.CommandText = "{ call sp_PSDatabases }";
				com.CommandType = CommandType.StoredProcedure;
				reader = com.ExecuteReader();
				while(reader.Read())
				{
					PSDB db = new PSDB();
					db.id = reader.GetInt32(0);
					db.name = reader.GetString(1).Trim();
					db.server = reader.GetString(2).Trim();
					db.db = reader.GetString(3).Trim();
					db.user = reader.IsDBNull(4) ? "" : reader.GetString(4).Trim();
					db.pwd = reader.IsDBNull(5) ? "" : reader.GetString(5).Trim();
					dbinfo[db.id] = db;
				}
			}
			finally
			{
				if(reader != null)
					reader.Close();
			}

			foreach(int id in bugdbs.Keys)
			{
				PopulateBugs((PSDB) dbinfo[id], (Hashtable) bugdbs[id]);
			}
		}
		#endregion

		/// <summary>
		/// Second stage of the population of bug status which takes a particular product studio database and it's associated bug set for lookups.
		/// </summary>
		/// <param name="db">PS database to lookup against</param>
		/// <param name="bugs">Hashtable of bugs to populate</param>
		#region void PopulateBugs(PSDB db, Hashtable bugs)
		void PopulateBugs(PSDB db, Hashtable bugs)
		{
			OdbcConnection con = new OdbcConnection("DRIVER={SQL Server};SERVER=" + db.server + ";DATABASE=" + db.db + ";UID=" + db.user + ";PWD=" + db.pwd + ";NETWORK=dbmssocn");
			con.Open();

			StringBuilder sb = null;
			int count = 0;
			foreach(int bugid in bugs.Keys)
			{
				// Building the query.  I'm only going to query up to 100 bugs at a time to prevent a SQL query length limit in which
				// case only an error would come back.
				if(count == 0)
				{
					sb = new StringBuilder();
					sb.Append("SELECT ");
					// Dynamic, just in case the fields desired changes above.
					for(int i = 0; i < (int) BugQueryFields.FieldCount; ++i)
					{
						if(i != 0)
							sb.Append(", ");
						sb.Append(((BugQueryFields) i).ToString());
					}
					sb.Append("\nFROM Bugs Where BugID in(\n");
				}
				else
				{
					// prepend a comma only if it is not the first.
					sb.Append(", ");
				}
				// Add the bug id
				sb.Append(bugid.ToString());
				count++;
				if(count >= 100)	// If I'm over 100 bug ids, do the query and clear the count (which will reinitialize the list)
				{
					PopulateBugs(con, sb, bugs);
					count = 0;
				}
			}

			 // I have to do this again since I may not have exactly 100 at the end of the loop.
			if(count > 0)
			{
				PopulateBugs(con, sb, bugs);
				count = 0;
			}
		}
		#endregion

		/// <summary>
		/// Third and final stage where the bugs are actually queried and the bugs updated.
		/// </summary>
		/// <param name="con">Connection to the product studio database</param>
		/// <param name="sb">Stringbuilder containing the command so far</param>
		/// <param name="bugs">The hashtable of bugs</param>
		#region void PopulateBugs(OdbcConnection con, StringBuilder sb, Hashtable bugs)
		void PopulateBugs(OdbcConnection con, StringBuilder sb, Hashtable bugs)
		{
			OdbcDataReader reader = null;
			try
			{
				sb.Append(")\n");
				OdbcCommand com = con.CreateCommand();
				com.CommandText = sb.ToString();
				com.CommandType = CommandType.Text;
				reader = com.ExecuteReader();
				while(reader.Read())
				{
					int id = reader.GetInt32((int) BugQueryFields.BugID);
					BugInfo bi = (BugInfo) bugs[id];
					bi.ReadData(reader);
				}
			}
			finally
			{
				if(reader != null)
					reader.Close();
			}
		}
		#endregion
	};

	#region public class BugInfo
	public class BugInfo
	{
		int db = -1;
		int id = -1;

		string title = "";
		BugStatus status = BugStatus.Unknown;
		DateTime dtchanged = new DateTime(0);
		int priority = -1, severity = -1;
		string assignedto = "";
		string treepath = "";

		public BugInfo(int bugdb, int bugid)
		{
			db = bugdb;
			id = bugid;
		}

		#region Accessors
		public static ulong FullID(int db, int id)
		{
			ulong t = 0; t |= (uint) db; t <<= 32; t |= (uint) id; return t;
		}
		public ulong ID
		{
			get {return FullID(db, id);}
		}

		public int BugDB
		{
			get {return db;}
		}
		public int BugID
		{
			get {return id;}
		}
		public string Title
		{
			get {return title;}
		}
		public BugStatus Status
		{
			get {return status;}
		}
		public string AssignedTo
		{
			get {return assignedto;}
		}
		public int Priority
		{
			get {return priority;}
		}
		public int Severity
		{
			get {return severity;}
		}
		public DateTime ChangeDate
		{
			get {return dtchanged;}
		}
		public string TreePath
		{
			get {return treepath;}
		}

		#endregion

		static public int FieldsInHtmlDisplay
		{
			get{return 7;}
		}
		public string HtmlDisplayString
		{
			get
			{
				StringBuilder sb = new StringBuilder();
				sb.Append("<TD CLASS=\"BUGSTATE_").Append(status.ToString()).Append("\"><SPAN CLASS=\"BUGID\">").Append(id.ToString()).Append("</SPAN></TD>\n");
				sb.Append("<TD CLASS=\"BUGSTATE_").Append(status.ToString()).Append("\"><SPAN CLASS=\"BUGSTATE\">").Append(status.ToString()).Append("</SPAN></TD>\n");
				sb.Append("<TD CLASS=\"BUGSTATE_").Append(status.ToString()).Append("\"><SPAN CLASS=\"BUGPRIORITY\">").Append((priority < 0) ? "-" : priority.ToString()).Append("</SPAN></TD>\n");
				sb.Append("<TD CLASS=\"BUGSTATE_").Append(status.ToString()).Append("\"><SPAN CLASS=\"BUGSEVERITY\">").Append((severity < 0) ? "-" : severity.ToString()).Append("</SPAN></TD>\n");
				sb.Append("<TD CLASS=\"BUGSTATE_").Append(status.ToString()).Append("\"><SPAN CLASS=\"BUGASSIGNEDTO\">").Append(assignedto).Append("</SPAN></TD>\n");
				sb.Append("<TD CLASS=\"BUGSTATE_").Append(status.ToString()).Append("\"><SPAN CLASS=\"BUGCHANGED\">").Append(dtchanged.ToString("s")).Append("</SPAN></TD>\n");
				sb.Append("<TD CLASS=\"BUGSTATE_").Append(status.ToString()).Append("\"><SPAN CLASS=\"BUGTITLE\">").Append(title).Append("</SPAN></TD>\n");
				return sb.ToString();

			}
		}

		#region public void ReadData(OdbcDataReader reader)
		public void ReadData(OdbcDataReader reader)
		{
			int bugid = reader.GetInt32((int) BugQueryFields.BugID);
			if(bugid != id)
				throw new Exception("Mismatch between Product Studio bug database row and this bug info object.  Got BugID: " + bugid.ToString() + " expected BugID: " + id.ToString());
			title = reader.GetString((int) BugQueryFields.Title);
			assignedto = reader.GetString((int) BugQueryFields.AssignedTo);
			dtchanged = reader.GetDateTime((int) BugQueryFields.ChangedDate);
			treepath = reader.GetString((int) BugQueryFields.TreePath);
			string s = reader.GetString((int) BugQueryFields.Status);
			switch(s)
			{
				case "Active":
					status = BugStatus.Active;
					break;
				case "Closed":
					status = BugStatus.Closed;
					break;
				case "Resolved":
					status = BugStatus.Resolved;
					break;
				default:
					status = BugStatus.Unknown;
					break;
			};
			string t;
			if(!reader.IsDBNull((int) BugQueryFields.Severity))
			{
				t = reader.GetString((int) BugQueryFields.Severity);
				severity = Convert.ToInt32(t);
			}
			if(!reader.IsDBNull((int) BugQueryFields.Priority))
			{
				t = reader.GetString((int) BugQueryFields.Priority);
				priority = Convert.ToInt32(t);
			}
		}
		#endregion
	}
	#endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\TestTracker\PSQ.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Data.Odbc;

namespace TestTracker
{
	/// <summary>
	/// Summary description for PSQ.
	/// </summary>
	public class PSQ : PageDefaults
	{
		private void Page_Load(object sender, System.EventArgs e)
		{
			if(Request.QueryString["TestSuiteID"] != null)
			{
				try
				{
					TestSuiteID = Convert.ToInt32(Request.QueryString["TestSuiteID"]);
				}
				catch
				{
				}
			}

			if(TestSuiteID < 0)
			{
				Response.Write("No TestSuiteID was specified!<br>No PSQ file for you!");
				Response.End();
			}

			OdbcConnection con = RegressionDB();
			try
			{
				GetTestSuites(con, bugs);
				bugs.PopulateBugs(con);
				TestSuite ts = (TestSuite) TestSuites[TestSuiteID];
				if(ts == null)
				{
					Response.Write("An invalid TestSuiteID was specified!<br>No PSQ file for you!");
					Response.End();
				}
				ts.SendPSQ(Response);
			}
			finally
			{
				con.Close();
			}
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Load += new System.EventHandler(this.Page_Load);
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\AgeNewChild\Program.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using live.server;
using live.common;
using live.client;
using live.protocol;

namespace AgeNewChild
{
    class MyPrivs : Privileges
    {
        static List<Privilege> neverOn = null;
        new public bool Get(int index)
        {
            return base.Get(index);
        }

        public void Set(int index, bool value)
        {
            base.UnsafeSet(index, value);
        }

        public override bool Equals(object obj)
        {
            MyPrivs p = (MyPrivs)obj;

            for (int i = XOn.XPRIVILEGE_MIN; i <= XOn.XPRIVILEGE_MAX; i++)
            {
                if (neverOn.Contains((Privilege)i))
                {
                    continue;
                }
                if (p.Get(i) != Get(i))
                {
                    return false;
                }
            }

            return true;
        }

        public override int GetHashCode()
        {
            return _data.GetHashCode();
        }

        public MyPrivs(Privileges source)
            : base(source)
        {
        }

        public MyPrivs()
            : base()
        {
            if (neverOn == null)
            {
                neverOn = new List<Privilege>();
                neverOn.Add(Privilege.TesterAccess);
                neverOn.Add(Privilege.TradeContent);
                neverOn.Add(Privilege.PreviousLiveProtocols);
                neverOn.Add(Privilege.CrossPlatformMultiplayer);
                neverOn.Add(Privilege.Xbox1LiveAccess);
                neverOn.Add(Privilege.VideoMessagingSend);
                neverOn.Add(Privilege.MultiplayerEnabledByTier);
                neverOn.Add(Privilege.MultiplayerSessions);
            }
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            bool ageChild = false, setPermission = false;
            List<string> myargs = new List<string>(args);
            if (myargs.Contains("-p"))
            {
                myargs.Remove("-p");
                setPermission = true;
            }

            if (myargs.Contains("-a"))
            {
                myargs.Remove("-a");
                ageChild = true;
            }

            Xbox360Client client = new Xbox360Client();
            XblUser user = null;


            if (myargs.Count == 4 || myargs.Count ==5 )
            {

                CountryId country = CountryId.US;

                if (myargs.Count == 5) 
                {
                    country = (CountryId)Enum.Parse(typeof(CountryId), myargs[4], true);
                    if (!Enum.IsDefined(typeof(CountryId), country) )
                    {
                        Console.WriteLine("Invalid country code: {0}", myargs[4]);
                        return;
                    }
                }

                PaymentInstrumentTypeEnum payment = PaymentInstrumentTypeEnum.None;
                if (myargs[3].ToUpper() == "CC")
                {
                    payment = PaymentInstrumentTypeEnum.CreditCard;
                }
                else if (myargs[3].ToUpper() != "NONE")
                {
                    Usage();
                    return;
                }

                XblUserTier tier = XblUserTier.Silver;
                if (myargs[2].ToUpper() == "GOLD")
                {
                    tier = XblUserTier.Gold;
                }
                else if (myargs[2].ToUpper() != "SILVER")
                {
                    Usage();
                    return;
                }

                Console.Write("Creating User....");
                try
                {
                    user = CreateUser(client, tier, country, payment, myargs[0], myargs[1]);
                }
                catch (Exception e)
                {
                    Console.WriteLine("Could not Create User");
                    Console.WriteLine(e);
                    return;
                }
                Console.WriteLine("Done");
            }
            else if (myargs.Count == 2)
            {
                try
                {
                    PassportInfo pi = new PassportInfo();
                    pi.MemberName = myargs[0];
                    pi.Password = myargs[1];
                    byte[] token = UACS.XePassportLogin(client, pi);
                    Recovered rec = UACS.XeRecoverAccount(client, token);
                    user = new XblUser(rec.UserPuid, rec.Gamertag);
                    user.Settings = new XblUserSettings(XblUserTier.Silver, PassportType.Existing);
                    pi.SessionToken = token;
                    user.Settings.UserPassportInfo = pi;
                    client.UserLoggingOn(user);
                }
                catch (Exception e)
                {
                    Console.WriteLine("Could not process passport info to get gamertag and User UID");
                    Console.WriteLine(e);

                }

            }
            else
            {
                Usage();
                return;
            }

            if (ageChild)
            {
                Console.Write("Aging User.....");
                try
                {
                    AgeUser(client, user);
                }
                catch (Exception e)
                {
                    Console.WriteLine("Could not Age User");
                    Console.WriteLine(e);
                    return;
                }
                Console.WriteLine("Done");
            }

            if (setPermission)
            {
                Console.Write("Setting Permission.....");
                try
                {
                    MyPrivs privs = new MyPrivs();
                    privs.Set(225, true);
                    UACS.XeUpdateParentalControls(client, user, privs, new Privileges(), "AgeNewChild");
                }
                catch (Exception e)
                {
                    Console.WriteLine("Could not SetPermission");
                    Console.WriteLine(e);
                    return;
                }
                Console.WriteLine("Done");
            }
           

        }

        private static void AgeUser(IClient client, XblUser user)
        {

            int age = 21;
            DateTime newBirthdate = DateTime.UtcNow.AddYears(-age).AddDays(-5).Date;
            user.Settings.PersonalInfo.BirthDate = newBirthdate;

            UACS.XeSetAccountInfo(client, user, user.Settings.PersonalInfo);

            //double check Birthdate
            PersonalInfo info = UACS.XeGetAccountInfo(client, user);
            if (info.BirthDate != newBirthdate)
            {
                Console.WriteLine("User {0} was not aged!", user);
                throw new Exception("User was not aged properly!");
            }
        }


        private static void Usage()
        {
            Console.Write("Usage:\n  AgeNewChild [-p] [-a] <gamertag> <password> <Silver|Gold> <CC|None> [Country]\n");
            Console.WriteLine("  AgeNewChild [-p] [-a] <passportemail> <password>");
            Console.WriteLine("\t\tGold or SIlver is the user type");
            Console.WriteLine("\t\tCC or None is the payment instrument type");
            Console.WriteLine("\t\t-a\tAge Child");
            Console.WriteLine("\t\t-p\tSets GraduateUser permission bit");
            Console.WriteLine("\t\tCountry\t sets the country code uses US if omiited.");

        }

        private static XblUser CreateUser(Xbox360Client client, XblUserTier userType, CountryId country, PaymentInstrumentTypeEnum paymentInstrument, string gamertag, string password)
        {
            XblUser user;
            PaymentInstrumentBase pib = null;
            PassportInfo parentPassportInfo = new PassportInfo();
            parentPassportInfo.PassportType = PassportType.Real;
            PassportUtils.CreatePassportAccount(client, parentPassportInfo);

            XblUserSettings settings = new XblUserSettings(userType, PassportType.Real);
            Randomizer.SetCountry(country);
            settings.PersonalInfo = Randomizer.Persons.RegularUserInfo;

            settings.PersonalInfo.ParentalControlGroupId = XOn.PARENTAL_CONTROL_GROUP_RESTRICTED;
            settings.PersonalInfo.BirthDate = DateTime.UtcNow.AddYears(-15);
            settings.UserPassportInfo.BirthDate = DateTime.UtcNow.AddYears(-15);
            settings.UserPassportInfo.CountryId = country;
            settings.OwnerPassportInfo = parentPassportInfo;
            settings.UserPassportInfo.Password = password;
            settings.UserPassportInfo.MemberName = "PP-GU-" + gamertag.ToLower() + PassportUtils.PassportMemberDomain;

            Console.WriteLine("Creating Passport: {0}", settings.UserPassportInfo.MemberName);
            PassportUtils.CreatePassportAccount(client, settings.UserPassportInfo);
            if (paymentInstrument != PaymentInstrumentTypeEnum.None)
            {
                if (userType == XblUserTier.Gold)
                {
                    settings.BillingInfo.OfferId = Offers.GetOfferId(Offers.BaseOffers.GoldCC1Month);
                }
                if (paymentInstrument == PaymentInstrumentTypeEnum.CreditCard)
                {
                    CreditCardInfo cc = Randomizer.CreditCards.CardInfoForPerson(CreditCardType.Visa, settings.PersonalInfo);
                    pib = cc;
                    Console.WriteLine("Credit Card Info:\n\tHolder Name:{0}\n\tNumber: {1}\n\tCCV: \t{2}\n\tExp: \t{3}/{4}", cc.AccountHolderName, cc.AccountNumber, cc.CcvNumber, cc.ExpirationDate.Month, cc.ExpirationDate.Year);
                    Console.WriteLine("\tAddress: {0} {1} {2}, {3} {4} {5}", cc.AddressInfo.Street1, cc.AddressInfo.Street2, cc.AddressInfo.City, cc.AddressInfo.District, cc.AddressInfo.State, cc.AddressInfo.PostalCode);
                    Console.WriteLine("\tPhone: {0}-{1}x{2}", cc.PhoneInfo.PhonePrefix, cc.PhoneInfo.PhoneNumber, cc.PhoneInfo.PhoneExtension);
                    settings.BillingInfo.AddCreditCard(cc);
                }
            }
            else if (userType == XblUserTier.Gold)
            {
                settings.BillingInfo.OfferId = Offers.GetOfferId(Offers.BaseOffers.GoldPP13Month);
                settings.BillingInfo.BillingToken = Offers.GetPrepaidVoucherCode(Offers.BaseOffers.GoldPP13Month);
            }

            settings.PersonalInfo.Gamertag = gamertag;

            if (settings.PersonalInfo.LanguageId > 12)
            {
                settings.PersonalInfo.LanguageId = 1;
            }

            uint hr = UACS.XeCreateLiveAccount(client, settings, out user);
            if (hr != 0)
            {
                throw new Exception("Failed to create user; hr = " + HResult.XErrToString(hr));
            }
            client.UserLoggingOn(user);

            if (pib != null)
            {
                string[] ids = UACS.XeGetPaymentInstruments(client, user, 5);
                if (ids.GetLength(0) > 0)
                {
                    pib.PaymentInstrumentId = ids[0];
                }
            }

            return user;

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\AgeNewChild\Properties\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("AgeNewChild")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("MS")]
[assembly: AssemblyProduct("AgeNewChild")]
[assembly: AssemblyCopyright("Copyright  MS 2007")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("d4fcdb24-fef2-450f-8417-87c55535b460")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\ANS\ANS\ans.cs ===
#define TRACE

using System;
using System.Security.Permissions;
using System.Data.SqlTypes;
using System.IO;
using System.Diagnostics;
using System.Xml;
using Microsoft.Win32;

namespace Microsoft.XBoxLive.Test.ANS
{
    /// <summary>
    /// Summary description for Class1.
    /// </summary>
    /// 

    class CAnsClient
    {

        //private static TargetServersType targetServers = new TargetServersType();

        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]

        static int Main(string[] args)
        {
            // Uncomment the following 2 lines to test data extraction.
            //CAnsScenario.ExtractAndSaveData(17192, "josephfo");
            //return 0;




            #region Verify Process does not already exist.
            Process[] allProcesses;
            Process currentProcess;

            string currentProcessName;

            currentProcess = Process.GetCurrentProcess();
            currentProcessName = currentProcess.ProcessName;
            allProcesses = Process.GetProcessesByName(currentProcessName);

            if (allProcesses.Length > 1)
            {
                Console.WriteLine("Another " + currentProcessName +
                    " is running, cannot run multiple instances.");
                return (2);
            }
            #endregion

            if (args.Length < 1)
            {
                Console.WriteLine("Need to supply configuration file.");
                Console.WriteLine("Use -n flag after configuration file to rebuild 1-box whenever newer passing BVT is available.");
                return 1;
            }

            string ConfigFile = args[0];
            if (!File.Exists(ConfigFile))
            {
                Console.WriteLine("Config file " + ConfigFile + " does not exist.");
                return 1;
            }

            // Setup TraceListeners
            // Create a file for output named ANSLogyyyymmdd.txt
            Stream ANSLogFile = null;
            string LogFileName = "";

            XmlDocument AnsConfig = new XmlDocument();

            LogFileName = "ANSLog" + DateTime.Now.Year.ToString("0000") + "-" + DateTime.Now.Month.ToString("00") + "-" + DateTime.Now.Day.ToString("00") + "T" + DateTime.Now.Hour.ToString("00") + DateTime.Now.Minute.ToString("00") + DateTime.Now.Second.ToString("00") + ".txt";
            ANSLogFile = File.Create(LogFileName);

            // Create a new text writer using the output stream, and add it to the trace listeners.
            TextWriterTraceListener ANSTextList = new TextWriterTraceListener(ANSLogFile);
            Trace.Listeners.Add(ANSTextList);
            //Create a text writer that writes to the console screen, and add it to the trace listeners
            TextWriterTraceListener ANSWriter = new TextWriterTraceListener(System.Console.Out);
            Trace.Listeners.Add(ANSWriter);

            Trace.AutoFlush = true;

            ANSLog("Starting ANSClient.");

            try
            {
                AnsConfig.Load(ConfigFile);
            }
            catch (XmlException ex)
            {
                throw new Exception("Failed to load ANSConfig.", ex);
            }

            ANSLog("Reading Config File");

            XmlNode ScenarioActions, CurrentScenario;
            try
            {
                ScenarioActions = AnsConfig.SelectSingleNode("ANSConfig/ScenarioActions");
            }
            catch (Exception e)
            {
                ANSLog("Error finding ScenarioActions section: " + e);
                throw;
            }

            try
            {
                CurrentScenario = AnsConfig.SelectSingleNode("ANSConfig/ScenarioList").FirstChild;
            }
            catch (Exception e)
            {
                ANSLog("Error finding first item in ScenarioList: " + e);
                throw;
            }

            while (CurrentScenario.NodeType == XmlNodeType.Comment)
            {
                CurrentScenario = CurrentScenario.NextSibling;
            }
            ANSLog("Print CurrentScenario: " + CurrentScenario);

            //bool isCustomTest=false;
            //bool IsPerfTest=false; 
            bool DoRebuild = false;
            string LastDir = String.Empty;

            string ScenarioName, DesiredBuild, ServerName, ExtractVersionFileName, Password, CurrentlyInstalledBuild;
            string ScenarioLastTestedOnBuild, TesterAlias, ArchiveLocation, Release, Product, ActProjectFile;
            string currVariable = "Unassigned";
            string DataSource;

            try
            {
                ScenarioName = CurrentScenario.Attributes.GetNamedItem("Name").Value;
                DesiredBuild = AnsConfig.SelectSingleNode("ANSConfig").Attributes.GetNamedItem("BuildNumber").Value;
                ServerName = AnsConfig.SelectSingleNode("ANSConfig").Attributes.GetNamedItem("ServerName").Value;
                ExtractVersionFileName = AnsConfig.SelectSingleNode("ANSConfig").Attributes.GetNamedItem("ExtractVersionFileName").Value;
                DataSource = AnsConfig.SelectSingleNode("ANSConfig").Attributes.GetNamedItem("DataSource").Value;
                Password = AnsConfig.SelectSingleNode("ANSConfig").Attributes.GetNamedItem("Password").Value;
                CurrentlyInstalledBuild = GetExistingBuildNumber(ServerName, Password, ExtractVersionFileName);
                ANSLog("Existing Build number found to be: " + CurrentlyInstalledBuild);                
                ScenarioLastTestedOnBuild = CurrentScenario.Attributes.GetNamedItem("LastBuildTested").Value;
                TesterAlias = AnsConfig.SelectSingleNode("ANSConfig").Attributes.GetNamedItem("TesterAlias").Value;
                ArchiveLocation = AnsConfig.SelectSingleNode("ANSConfig").Attributes.GetNamedItem("ArchiveLocation").Value;
                Release = AnsConfig.SelectSingleNode("ANSConfig").Attributes.GetNamedItem("Release").Value;
                //SCGTestRelease = AnsConfig.SelectSingleNode("ANSConfig").Attributes.GetNamedItem("SCGTestRelease").Value;
                Product = AnsConfig.SelectSingleNode("ANSConfig").Attributes.GetNamedItem("Product").Value;
                ActProjectFile = AnsConfig.SelectSingleNode("ANSConfig").Attributes.GetNamedItem("ActSuite").Value;
            }
            catch (Exception e)
            {
                string errString = "Error reading value for variable [" + currVariable + "] from config file: " + e;
                ANSLog(errString);
                throw;
            }
            ANSLog("First Scenario: " + ScenarioName);

            try
            {
                //-- find the correct ScenarioActions node to go with the selected CurrentScenario
                //get the name of the action that goes with the current scenario
                string scenarioName = CurrentScenario.Attributes["Name"].Value;
                string stressSettingFile = CurrentScenario.Attributes["StressSettingsFile"].Value;
                string stressSuiteDll = CurrentScenario.Attributes["StressSuiteDll"].Value;
                ANSLog("Current Scenario:" + scenarioName);
                string actionName = "";
                try
                {
                    // get the ScenarioActionsName for the current scenario
                    actionName = CurrentScenario.Attributes.GetNamedItem("ScenarioActionsName").Value;
                }
                catch (Exception e)
                {
                    // the Name attribute wasn't included
                    ANSLog("No 'ScenarioActionsName' attribute defined for Scenario [" + scenarioName + "]");
                    throw (e);
                }

                ANSLog("ScenarioActions: " + actionName);

                // search for action with the same name
                try
                {
                    while (ScenarioActions.Attributes.GetNamedItem("Name").Value != actionName)
                    {
                        ScenarioActions = ScenarioActions.NextSibling;
                    }
                }
                catch (Exception e)	// catch the error if it iterates off the end and can't find a match
                {
                    throw new Exception(String.Format("Failed to find associated ScenarioActions for Scenario [{0}] with name [{1}]\nError: ",
                        scenarioName, actionName), e);
                }

                ANSLog("Found ScenarioActions named [" + actionName + "] for Scenario [" + scenarioName + "]");

                /* Need to handle this inside the Scenario Actions.
                if( null == CurrentScenario.Attributes.GetNamedItem("ActSuite") )
                {
                    isCustomTest = true;
                }
                else
                {
                    isCustomTest = false;
                    ActProjectFile = CurrentScenario.Attributes.GetNamedItem("ActSuite").Value;
                }
                */

                if (DesiredBuild == "[GET_LATEST_PASSING_BVT]")
                {
                    ANSLog("Inside GET_LATEST_PASSING_BVT condition. Attempting to get latest passing bvt build number.");
                    // logic: Get the latest passing BVT from AutoEx database.
                    // If that build number is different from what is already installed,
                    // then do a rebuild.
                    ANSLog("Getting Latest Passing BVT...");

                    // not yet implemented for xbl. comment out for now:
                    //DesiredBuild = CBuildProvider.GetLatestGoodBuild(Product, SCGTestRelease);
                    ANSLog("Latest passing BVT is: " + DesiredBuild);
                }


                // This is the case if BVT team is not doing daily builds - so we do not know
                // if the latest build is passing.  Need to add Build Drop location to db.
                if (DesiredBuild == "[GET_LATEST_BUILD]")
                {
                    ANSLog("Inside GET_LATEST_BUILD");
                    DesiredBuild = CBuildProvider.GetLatestBuild(Release, DataSource);
                    ANSLog("GET_LATEST_BUILD found to be: " + DesiredBuild);
                }

                if (ScenarioLastTestedOnBuild == DesiredBuild)
                {
                    // No need to retest this scenario on the same build.
                    ANSLog("Scenario was last tested on the desired build.  No need to retest.");
                    return 0;
                }

                if (DesiredBuild != CurrentlyInstalledBuild)
                {
                    DoRebuild = true;
                    ANSLog("DesiredBuild " + DesiredBuild.ToString() + " is not equal to the Currently Installed Build " + CurrentlyInstalledBuild.ToString() + " REBUILD = TRUE");
                }
                else
                {
                    DoRebuild = false;
                    ANSLog("DesiredBuild " + DesiredBuild.ToString() + " is equal to the currently installed build " + CurrentlyInstalledBuild.ToString() + " REBUILD = FALSE");
                }

                LastDir = DateTime.Now.Year.ToString("0000") + "-" + DateTime.Now.Month.ToString("00") + "-" + DateTime.Now.Day.ToString("00") + "_" + DesiredBuild + "_" + ScenarioName;
                ArchiveLocation = ArchiveLocation + "\\" + LastDir;
                //IsPerfTest = Convert.ToBoolean(CurrentScenario.Attributes.GetNamedItem("IsPerfTest").Value);

                if (TesterAlias.Length > 10)
                {
                    ANSLog("TesterAlias exceeded allowed length.");
                    return 0;
                }

                //TestSuiteID is added to AchiveLocation inside ANSEngine (CAnsScenario).
                CAnsScenario oScenario = new CAnsScenario(ScenarioName, ServerName, Password, ActProjectFile, DesiredBuild, TesterAlias, ArchiveLocation, Product, Release, DataSource, stressSettingFile, stressSuiteDll);

                /*  I think better is to have a single constructor.  Pass in a dummy ACT Suite if not using one.
                if( isCustomTest )
                {
                    oScenario = new CAnsScenario(ScenarioName, CAnsClient.targetServers, DesiredBuild, TesterAlias, ArchiveLocation, Product, Release);

                }
                else
                {
                    oScenario = new CAnsScenario(ScenarioName, CAnsClient.targetServers, ActProjectFile, DesiredBuild, TesterAlias, ArchiveLocation, Product, Release);
                } */



                //update ArchiveLocation here
                ArchiveLocation = oScenario.ArchiveLocation;
                ANSLog("About to rebuild if necessary");

                if (DoRebuild)
                {
                    ANSLog("Rebuilding remote box.");
                    XmlNodeList RebuildActions = AnsConfig.SelectNodes("ANSConfig/RebuildActions//Action");
                    foreach (XmlNode Action in RebuildActions)
                    {
                        // skip node if it is a comment.
                        if (Action.NodeType == XmlNodeType.Comment) continue;
                        ANSLog("Starting Rebuild Action: " + Action.OuterXml.ToString());
                        oScenario.DoAction(Action.Clone());
                    }
                }

                foreach (XmlNode Action in ScenarioActions)
                {
                    // skip node if it is a comment.
                    if (Action.NodeType == XmlNodeType.Comment) continue;
                    ANSLog("Starting Action: " + Action.OuterXml.ToString());
                    if (oScenario.DoAction(Action.Clone()) == -1)
                    {
                        ANSLog("Looks like " + ScenarioName + " has already been run max. permissible times on current build. Therefore, not running it again...");
                        break;
                    }
                }

                ANSLog(" - ANSClient Complete.");
            }
            catch (SqlTruncateException e)
            {
                ANSLog(e.Message);
                ANSLog(e.StackTrace);
            }
            catch (Exception exception)
            {
                ANSLog("Exception Occurred: " + exception.ToString());
            }
            finally
            {
                ANSLog("Inside finally.");
                if (ANSLogFile != null)
                {
                    ANSLog("Attempting to close ANS Log file.  ANSLogFile is not null.");
                    ANSLogFile.Close();
                    // Check ArchiveLocation has been defined.  Fixes crash when already tested this scenario on this build.
                    if (!Directory.Exists(ArchiveLocation) && (ArchiveLocation.Length > 0))
                    {
                        Directory.CreateDirectory(ArchiveLocation);
                    }
                    Console.WriteLine("Moving ANSLogFile to archive location");
                    File.Move(LogFileName, ArchiveLocation + "\\" + LogFileName);
                }
            }

            // If "LastBuildTested" is null, put in that node.
            if (CurrentScenario.Attributes.GetNamedItem("LastBuildTested") == null)
            {
                CurrentScenario.Attributes.Append(AnsConfig.CreateAttribute("LastBuildTested"));
            }

            // Set the Scenario Last Tested On Build.      
            CurrentScenario.Attributes["LastBuildTested"].Value = DesiredBuild;

            // Move Current Scenario to end of list. Should always happen, even if
            // current scenario throws some exception.
            Console.WriteLine("Moving current scenario to end of list");
            AnsConfig.SelectSingleNode("/ANSConfig/ScenarioList").RemoveChild(CurrentScenario);
            AnsConfig.SelectSingleNode("/ANSConfig/ScenarioList").AppendChild(CurrentScenario);
            Console.WriteLine(String.Format("Saving ANSConfigFile [{0}]", ConfigFile));
            AnsConfig.Save(ConfigFile);
            Console.WriteLine(String.Format("Completed saving ANSConfigFile [{0}]", ConfigFile));
            return 0;
        }

        public static string GetVersionDllInfoName(XmlNode NodeVerDllName)
        {

            //Default dll name to get version info from
            string verInfoDll = @"d:\Program Files\Microsoft SPS\bin\bdksvr2.dll";

            //If a different dll name is specified in the config xml then use that
            if (null != NodeVerDllName)
            {
                verInfoDll = NodeVerDllName.Value;
            }

            return verInfoDll;

        }
        public static void ANSLog(string msg)
        {
            Console.WriteLine(msg);
            Trace.WriteLine(DateTime.Now.ToString("G") + " Main: " + msg);
        }

        static string GetExistingBuildNumber(string RemoteServer, string Password, string FilePathName)
        {
            ANSLog("Inside GetExistingBuildNumber");

            // net use to the remote box so we can access the file.
            //ANSLog("net use to remote machine.");
            //Process p = new Process();
            //string filename = Environment.ExpandEnvironmentVariables(@"%windir%\system32\cmd.exe");
            //p.StartInfo.FileName = filename;
            //p.StartInfo.Arguments = @"/c net use \\" + RemoteServer + " " + Password + @" /u:administrator";
            //p.Start();
            //p.WaitForExit();

            String fn = @"\\" + RemoteServer + @"\" + FilePathName.Replace(@":", @"$");

            if (!File.Exists(fn))
            {
                // file does not exist. Just return 0 for existing build number, and box will be re-built.
                ANSLog("File not found: " + fn);
                return "0";
            }


            ANSLog("Getting file information");



            FileVersionInfo fvi;
            try
            {
                fvi = FileVersionInfo.GetVersionInfo(fn);
            }
            catch (System.IO.FileNotFoundException ex)
            {
                throw new Exception("Do not have access to file specified!!", ex);
            }
            string BuildNumber = fvi.FileBuildPart.ToString();

            ANSLog("Build number set to: " + fvi.FileVersion);

            return fvi.FileVersion;
        }

        /*
        static string GetDWNumber(string RemoteServer, string Password, string RegistryPathName)
        {
            ANSLog("Inside GetDWNumber");

            ANSLog("net use to remote machine.");
            Process p = new Process();
            string filename = Environment.ExpandEnvironmentVariables(@"%windir%\system32\cmd.exe");
            p.StartInfo.FileName = filename;
            p.StartInfo.Arguments = @"/c net use \\" + RemoteServer + " " + Password + @" /u:administrator";
            p.Start();
            p.WaitForExit();	

            ANSLog("Getting file information by reading Registry key on remote box");
            // open registry key HKLM\Software\Microsoft\Subscriptions\Warehouse\JobLatency on remote machine.

            RegistryKey SUBKEY,PARKEY;
            object buildNumber;

            try
            {
                PARKEY = RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive.LocalMachine,@"\\"+RemoteServer);
                SUBKEY = PARKEY.OpenSubKey(RegistryPathName); 
                buildNumber = SUBKEY.GetValue("BuildNumber");
                ANSLog("Build number set to: " + buildNumber.ToString());
                return buildNumber.ToString();
            }
            catch
            {
                ANSLog("Could not find build number on remote machine!");
                return "";
            }
        }
        */
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\ANS\ANS\blgAccess.cs ===
#define TRACE

using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Diagnostics;
using System.Collections;

namespace Microsoft.XBoxLive.Test.ANS
{


	public enum DataType {Min, Max, Avg};


	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	///


	public class blgAccess
	{
		private DateTime startTime;
		private DateTime endTime;
		private PdhTimeInfo timeRange;
		private String blgFile;
		private Hashtable counterData = new Hashtable();	// key = CounterPath   value=ArrayList of data

		private int hQuery = 0;				// handle to the blg file.
		private Hashtable counterHandles = new Hashtable();   // key = CounterPath value = pdh int handle to counter.

		private bool startTimeSet = false;
		private bool endTimeSet = false;

		[DllImport("pdh.dll", CharSet=CharSet.Unicode)]
		public static extern int PdhOpenQuery (
			string lpBuffer,
			ref int dwUserData, ref int hQuery );
        
		//hQuery,szCounterPath,0,&hCounter
		[DllImport("pdh.dll", CharSet=CharSet.Unicode)]
		public static extern int PdhAddCounter (
			int hQuery,
			string szCounterPath,
			int DontKnow,
			ref int hCounter);

		[DllImport("pdh.dll", CharSet=CharSet.Unicode)]
		public static extern int PdhCollectQueryData (int hQuery);

        [DllImport("pdh.dll", CharSet = CharSet.Unicode)]
        public static extern int PdhRemoveCounter(int hCounter);


		[ StructLayout( LayoutKind.Sequential )]
			public class PdhCounterValue 
		{
			public int cStatus;
			public double Value;
		}

		[ StructLayout( LayoutKind.Sequential )]
			public class PdhTimeInfo 
		{
			public Int64 StartTime;
			public Int64 EndTime;
			public int SampleCount;
		}

		[DllImport("pdh.dll", CharSet=CharSet.Unicode)]
		public static extern int PdhGetFormattedCounterValue (
			int hCounter,
			int dwFormat,
			int lpdwType,
			PdhCounterValue pValue
			);

		[DllImport("pdh.dll", CharSet=CharSet.Unicode)]
		public static extern int PdhSetQueryTimeRange (
			int hQuery,
			PdhTimeInfo pTimeInfo
			);
		
		[DllImport("pdh.dll", CharSet=CharSet.Unicode)]
		public static extern int PdhCloseQuery (int hQuery);

		public blgAccess(string BlgFile)
		{
			myLog("Accessing log file: " + BlgFile);
			if (File.Exists(BlgFile))
			{
				this.blgFile = BlgFile;				
			}
			else
			{
				throw new FileNotFoundException("log file " + BlgFile + " does not exist");
			}	
		}

		public void ExtractData()
		{
			// Open query here to allow for multiple calls to ExtractData
			int i = 0;
			int rc = PdhOpenQuery(blgFile, ref i, ref hQuery);
			myLog(String.Format("rc from PdhOpenQuery on log file [{0}]: {1}", blgFile,rc.ToString("x")) );

			counterHandles.Clear();

			if (!startTimeSet | !endTimeSet)
				throw new Exception("Need to set startTime and endTime before calling ExtractData");

			// Set time range.
			DateTime UTCTime = new DateTime(1601,1,1,0,0,0);

			Int64 llStartTime = this.StartTime.Ticks - UTCTime.Ticks;
			Int64 llEndTime = this.EndTime.Ticks - UTCTime.Ticks;

			timeRange = new PdhTimeInfo();
			timeRange.StartTime = llStartTime;
			timeRange.EndTime = llEndTime;
			myLog("Setting StartTime to: " + this.StartTime.ToString("G"));
			myLog("Setting EndTime to: " + this.EndTime.ToString("G"));
			rc = PdhSetQueryTimeRange(hQuery,timeRange);
			myLog("rc from PdhSetQueryTimeRange: " + rc.ToString("x"));

			// get the data
			foreach (String Counter in counterData.Keys)
			{
				int hCounter = 0;
				myLog(String.Format("Looking for counter [{0}] hQuery [{1}] hCounter[{2}]", Counter,hQuery,hCounter));
				try
				{
					rc = PdhAddCounter(hQuery,Counter,0,ref hCounter);
				}
				catch (Exception e)
				{
					myLog(String.Format("Error retrieving counter information for {0}.  Error: {1}",Counter,e) );
				}
				string errorcode = rc.ToString("x");
				// if rc = 0xc0000bcd then counter not found
				if (errorcode.Equals("c0000bcd"))
				{
					myLog("Counter not found in log file: " + Counter);
				} 
				else
				{
					counterHandles.Add(Counter, hCounter);
				}
			}


			// read the first data value.  Throw if unable to read.
			rc = PdhCollectQueryData(hQuery);
			if (rc != 0)
			{
				myLog("rc from PdhCollectQueryData: " + rc.ToString("x"));
				rc = PdhCloseQuery(hQuery);
				myLog("rc from PdhCloseQuery: " + rc.ToString("x"));

				// we are seeing missing counters in the first line of the blg file 
				//throw new Exception("Unable to read first value from blg file.");				
			}

			PdhCounterValue aVal = new PdhCounterValue();
			// foreach row (look at first datapoint for data for every counter)
			int rowNum = 1;
			while (rc == 0)
			{
				// foreach counter
				foreach (string Counter in counterHandles.Keys)
				{
					rc = PdhGetFormattedCounterValue((Int32) counterHandles[Counter],0x00000200,0,aVal);
					if (rc != 0)
					{
						myLog(String.Format("rc returned from PdhGetFormattedCounterValue value[{0}] for counter [{1}] for rowNum [{2}]",
							rc.ToString("x"), Counter, rowNum));
					}
					((ArrayList) counterData[Counter]).Add(aVal.Value);
				}
				// get next row
				rc = PdhCollectQueryData(hQuery);
				rowNum++;
			}

            // now that data is extracted, close all handles to counters.
            // required, or else pdh.dll will attempt to do this recursivley on shutdown
            // and crash with a stack overflow.
            foreach (Int32 hCounter in counterHandles.Values)
            {
                PdhRemoveCounter(hCounter);
            }
		}


		public double GetDeltaValue(String CounterPath)
		{
			ArrayList data = (ArrayList) counterData[CounterPath];

			double first = (double) data[0];
			double last = (double) data[data.Count - 1];

			return last - first;

		}

		public double GetMaxValue(String CounterPath)
		{
			ArrayList data = (ArrayList) counterData[CounterPath];
			double Max = (double) data[0];

			foreach (double val in data)
			{
				if (val > Max) Max = val;
			}
			return Max;
		}

		public double GetMinValue(String CounterPath)
		{
			ArrayList data = (ArrayList) counterData[CounterPath];
			double Min = (double) data[0];

			foreach (double val in data)
			{
				if (val < Min) Min = val;
			}
			return Min;
		}

		public double GetAvgValue(String CounterPath)
		{
			ArrayList data = (ArrayList) counterData[CounterPath];

			double sum = 0;

            Int32 trueCount = 0;

			foreach (double val in data)
			{
                // ignore latency with value 0.0.
                if (CounterPath.Contains("execution time") && val==0.0)
                {
                    continue;
                }
                trueCount++;
				sum += val;
			}
			return (sum / trueCount);
		}

		public void AddCounter(String CounterPath)
		{
			counterData.Add(CounterPath, new ArrayList());
		}


		public DateTime StartTime
		{
			get { return this.startTime; }
			set
			{
				this.startTime = value;
				this.startTimeSet = true;
			}
		}

		public DateTime EndTime
		{
			get { return this.endTime; }
			set
			{ 
				this.endTime = value;
				this.endTimeSet = true;
			}
		}

		public static void myLog(string msg)
		{
			Trace.WriteLine(DateTime.Now.ToString("G") + " blgAccess: " + msg);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\ANS\ANS\anstypes.cs ===
using System;
using System.Collections;

namespace Microsoft.XBoxLive.Test.ANS
{

    public class TargetServersType : System.Collections.CollectionBase
    {

        public TargetServerType Add( TargetServerType TargetServer )
        {
            this.List.Add( TargetServer );

            return TargetServer;
        }

        public TargetServerType this[ int index ]
        {
            get{ return ( TargetServerType ) this.List[ index ]; }
        }


    }
    
    public class TargetServerType
	{
        private string machineName = string.Empty;
        private string getVersionInfoDllName = string.Empty;
        private string password = string.Empty;

        private bool stringIsValid( string validateString )
        {
            return ( null != validateString && validateString.Length > 0 );
        }

		private TargetServerType()
		{

		}

        public TargetServerType(string MachineName, string GetVersionInfoDllName, string Password)
        {
            if( this.stringIsValid( MachineName ) && 
                this.stringIsValid( GetVersionInfoDllName ) &&
                this.stringIsValid( Password ) )
            {
                this.machineName = MachineName;
                this.getVersionInfoDllName = GetVersionInfoDllName;
                this.password = Password;
            }
            else
            {
                throw new Exception( "Invalid parameter: MachineName='" + MachineName + 
                    "' GetVersionInfoDllName='" + GetVersionInfoDllName +
                    "' Password='" + Password + "'");
            }
               
           
        }

        public string MachineName{ get{ return this.machineName; } }
        public string VersionInfoDllName{ get { return this.getVersionInfoDllName; } }
        public string Password{ get { return this.password; } }

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\ANS\ANS\EventCompressor.cs ===
#define TRACE

using System;
using System.Threading;
using System.Diagnostics;
using System.Data;
using System.Data.SqlClient;
using System.Xml;
using System.Text;
using System.IO;
using System.Runtime.InteropServices;
using System.Collections;


namespace Microsoft.XBoxLive.Test.ANS
{
	/// <summary>
	/// Summary description for CAnsScenario.
	/// </summary>
	public class EventCompressor
	{


		public static void CompressEvents(string path)
		{
			Hashtable htEvents = new Hashtable();
			Hashtable htEventsCount = new Hashtable();
			

			String eventsFile = path + "\\Events.xml";
			if (!File.Exists(eventsFile))
				return;

			XmlDocument events = new XmlDocument();
			events.Load(eventsFile);

			XmlNodeList eventsList = events.SelectNodes("/Events/Event");
			foreach (XmlNode eventNode in eventsList)
			{
				Event evt = new Event(eventNode);
				if (htEvents.ContainsKey(evt.Key))
				{
					// event already exists.  Increment the count for this event.
					htEventsCount[evt.Key] = ((Int32) htEventsCount[evt.Key]) + 1;
				}
				else
				{
					// this is a new event.  Add it to both hash tables.
					htEvents.Add(evt.Key, evt);
					htEventsCount.Add(evt.Key, 1); // this is the first event.
				}
			}

			XmlTextWriter writer = new XmlTextWriter(path + "\\CompressedEvents.xml", Encoding.UTF8);
			writer.WriteStartDocument();
			writer.WriteStartElement("Events");

			// now create the new compressed events file.
			IDictionaryEnumerator evts = htEvents.GetEnumerator();
			while (evts.MoveNext())
			{
			  	String EventId = (String) evts.Key;
				Event evt = (Event) evts.Value;
				Int32 eventCount = (Int32) htEventsCount[EventId];
				writer.WriteStartElement("Event");
				writer.WriteElementString("EventCount", eventCount.ToString());
				writer.WriteElementString("ID", EventId);
				writer.WriteElementString("Type", evt.EventType);
				writer.WriteElementString("Source", evt.Source);
				writer.WriteElementString("Description", evt.Message);
				writer.WriteEndElement();
			}
			writer.WriteEndElement();
			writer.WriteEndDocument();
			writer.Close();           
		}
	}

	public class Event
	{
		private Int64 id;
		private String eventType;
		private DateTime timeGenerated;
        private String source;
		private String message;
		private String key;

		public Event(Int64 ID, String EventType, DateTime TimeGenerated, String Source, String Message)
		{
			this.id = ID;
			this.eventType = EventType;
			this.timeGenerated = TimeGenerated;
			this.source = Source;
			this.message = Message;
			SetKey();
		}

		public Event(XmlNode eventNode)
		{
			this.id = Int64.Parse(eventNode.SelectSingleNode("ID").InnerText);
			this.eventType = eventNode.SelectSingleNode("Type").InnerText;
			this.timeGenerated = DateTime.Parse(eventNode.SelectSingleNode("TimeGenerated").InnerText);
			this.source = eventNode.SelectSingleNode("Source").InnerText;
			this.message = eventNode.SelectSingleNode("Message").InnerText;
			SetKey();
		}

		private void SetKey()
		{
			if ((this.source == "PerfServer") || (this.source == "SPS Service"))
			{
				this.key = GetErrorCode(this.message);
			}
			else
			{
				this.key = this.id.ToString();
			}
		}

		private String GetErrorCode (String message)
		{
			// Sample message for SPS Service.  Need to parse out Hr.
			//<Message>API: GetSubscriptions Hr: -2146231998 BDK Id: OcAPAAAAAAAAAAAA Partner: spsp_sign_c Exception: System.Xml

			// Sample message for PerfServer: Need to parse out Hr.
			// <ErrorHResult>0x80042713</ErrorHResult>

			String Hr = String.Empty;

			try
			{
				if (this.source == "SPS Service")
				{
					Int32 startHr = message.IndexOf("Hr:");
					if (-1 == startHr)
					{
						Hr = this.id.ToString();
					}
					else
					{
						Int32 endHr = message.IndexOf("BDK Id:") - 1;
						Hr = message.Substring(startHr + 4, endHr - (startHr + 4));
					}
				}
				else
				{
					Int32 startHr = message.IndexOf("<ErrorHResult>");
					if (-1 == startHr)
					{
						Hr = this.id.ToString();
					}
					else
					{
						Int32 endHr = message.IndexOf("</ErrorHResult>");
						Hr = message.Substring(startHr + 14, endHr - (startHr+14) );				
					}
				}
			}
			catch (Exception)
			{
				// If anything fails, just return the eventID as the key.
				// don't rethrow.
				Hr = this.id.ToString();
			}
			return Hr;
		}

		public String Key
		{
			get { return this.key; }
		}

		public Int64 ID
		{
			get { return this.id; }
		}

		public String EventType
		{
			get { return this.eventType; }
		}

		public DateTime TimeGenerated
		{
			get { return this.timeGenerated; }
		}

		public String Source
		{
			get { return this.source; }
		}

		public String Message
		{
			get { return this.message; }
		}


	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\ANS\ANS\EventCollector.cs ===
#define TRACE

using System;
using System.Xml;
using System.Diagnostics;
using System.Collections;
using System.Security.Principal;
using System.Runtime.InteropServices;


namespace Microsoft.XBoxLive.Test.ANS
{
	/// <summary>
	/// Collects events on remote machine.
	/// </summary>
	public class EventCollectorClass
	{
		// define interop structures and functions for getting remote time.
		[ StructLayout( LayoutKind.Sequential )]
			public class TIME_OF_DAY_INFO 
		{
			public int tod_elapsedt;
			public int tod_msecs;
			public int tod_hours;
			public int tod_mins;
			public int tod_secs;
			public int tod_hunds;
			public int tod_timezone;
			public int tod_tinterval;
			public int tod_day;
			public int tod_month;
			public int tod_year;
			public int tod_weekday;
		}
		
		[DllImport("NETAPI32.DLL", CharSet=CharSet.Unicode)]
		public static extern int NetRemoteTOD (string RemoteBox, ref TIME_OF_DAY_INFO tod);

		private string MachineName;
		private string LogName;
		private ArrayList TypeSourceArrayList;
		private DateTime StartTime;
		private string password;

		public EventCollectorClass(string LogName, string MachineName, int LastXMinutes, string password)
		{
			this.MachineName = MachineName;
			this.password = password;
			this.LogName = LogName;
			this.StartTime = GetRemoteTime().AddMinutes(-LastXMinutes);

			// initialize ArrayList
			TypeSourceArrayList = new ArrayList();

/*
			switch (Type)
			{
				case "Information":
					this.Type = EventLogEntryType.Information;
					break;
				case "Warning":
					this.Type = EventLogEntryType.Warning;
					break;
				case "Error":
					this.Type = EventLogEntryType.Error;
					break;
				case "Success Audit":
					this.Type = EventLogEntryType.SuccessAudit;
					break;
				case "Failure Audit":
					this.Type = EventLogEntryType.FailureAudit;
					break;
				default:
					throw new Exception("Bad Entry Type passed to EventCollectorClass Constructor.");
			}
*/
		}

		public void AddFilter(string LogType, string Source)
		{
			TypeSourceArrayList.Add(LogType + "~" + Source);
		}

		private DateTime GetRemoteTime()
		{
			// Need to connect to remote box first.
			//RunLocalCmd(@"net use \\" + this.MachineName + " /d /y", true);
			//WindowsIdentity user = WindowsIdentity.GetCurrent();
			//RunLocalCmd(@"net use \\" + this.MachineName + " " + this.password + " /u:" + user.Name, true);
			myLog("Inside GetRemoteTime()");
			//int ExitCode = RunLocalCmd(@"net use \\" + this.MachineName + " " + this.password + " /u:administrator", true);
			//if (ExitCode != 0)
			//	throw new Exception(@"Command returned non-zero: net use \\" + this.MachineName + " " + this.password + " /u:administrator");
            
			TIME_OF_DAY_INFO tod = new TIME_OF_DAY_INFO();
			NetRemoteTOD(this.MachineName, ref tod);
			DateTime dt;
			try
			{

				dt = new DateTime(tod.tod_year,tod.tod_month, tod.tod_day, tod.tod_hours, tod.tod_mins, tod.tod_secs);
			}
			catch (System.NullReferenceException ex)
			{
				throw new Exception("Unable to get time from remote server. Probably 'net use' did not work.",ex);
			}

			// need to subtract timezone (minutes) to adjust for location.
			dt = dt.AddMinutes((double)-tod.tod_timezone);

			myLog("Exiting GetRemoteTime with: " + dt.ToString());
			return dt;
		}

		private int RunLocalCmd(string Command, bool WaitToFinish)
		{
			Process myProcess = new Process();
			string filename = Environment.ExpandEnvironmentVariables(@"%windir%\system32\cmd.exe");
			myProcess.StartInfo.FileName = filename;
			myProcess.StartInfo.Arguments = @"/c " + Command;
			myProcess.StartInfo.UseShellExecute = false;
			myProcess.StartInfo.RedirectStandardOutput = true;
			myProcess.Start();

			if (WaitToFinish)
			{
				string output = myProcess.StandardOutput.ReadToEnd();
				myProcess.WaitForExit();
				return myProcess.ExitCode;
			}

			return 0;
		}

		public void WriteEvents(XmlDocument xml)
		{
			// Need to connect to remote box first.
			myLog("Inside WriteEvents");
			//int ExitCode = RunLocalCmd(@"net use \\" + this.MachineName + " " + this.password + " /u:administrator", true);
			//if (ExitCode != 0)
			//	throw new Exception(@"Command returned non-zero: net use \\" + this.MachineName + " " + this.password + " /u:administrator");
            
			XmlNode EventsNode = xml.SelectSingleNode("/Events");
			myLog("Creating EventLog object.");
			EventLog el = new EventLog(this.LogName, MachineName);

			myLog("Creating EventLogEntryCollection object.");
			EventLogEntryCollection elec = el.Entries;
			el.Close();

			int EventCount;
			try
			{
				myLog("Attempting to get EventLog Count.");
				EventCount = elec.Count;
				myLog("Got EventLog Count successfully: " + EventCount);
			}
			catch (Exception e)
			{
				throw new Exception("Unable to set EventCount.  elec.Count property failed.",e);
			}

			for(int i = 0; i < EventCount; i++)
			{
				try
				{
					EventLogEntry entry = elec[i];
					foreach (string TypeSource in TypeSourceArrayList)
					{
						string [] tmp = TypeSource.Split('~');
						string Type = tmp[0];
						string Source = tmp[1];
						if (((entry.EntryType.ToString() == Type) && (entry.Source == Source) && (entry.TimeGenerated > StartTime)) ||
							((entry.EntryType.ToString() == Type) && (Source == "All") && (entry.TimeGenerated > StartTime)))
						{
							// Create new elements
							XmlElement newEvent = xml.CreateElement("Event");
					
							XmlElement elemID = xml.CreateElement("ID");
							elemID.InnerText = entry.InstanceId.ToString();
							XmlElement elemType = xml.CreateElement("Type");
							elemType.InnerText = entry.EntryType.ToString();
							XmlElement elemDateTime = xml.CreateElement("TimeGenerated");
							elemDateTime.InnerText = entry.TimeGenerated.ToString("G");
							XmlElement writtenTime = xml.CreateElement("TimeWritten");
							writtenTime.InnerText = entry.TimeWritten.ToString("G");
							XmlElement elemSource = xml.CreateElement("Source");
							elemSource.InnerText = entry.Source;
							XmlElement elemMessage = xml.CreateElement("Message");
							elemMessage.InnerText = entry.Message;

							// Add SubElements to new Node
							newEvent.AppendChild(elemID);
							newEvent.AppendChild(elemType);
							newEvent.AppendChild(elemDateTime);
							newEvent.AppendChild(writtenTime);
							newEvent.AppendChild(elemSource);
							newEvent.AppendChild(elemMessage);

							// Add new node to Events Node.
							EventsNode.AppendChild(newEvent);
						}	// end if				
					} // end foreach
				} // end try
				catch(System.Exception e)
				{
					XmlElement err = xml.CreateElement("EventCollectorError");
					err.InnerText = "Error occurred in event #" + i.ToString() + ". Exception message: " + e.Message;
					EventsNode.AppendChild(err);
				}
			}

			/*try
			{
				Console.WriteLine("Total number of entries in log: {0}", elec.Count);
							

				foreach (EventLogEntry entry in elec)
				{
					++i;
					//if (i % 1500 == 0)
					//{
						Console.WriteLine("Got through first {0} entries.", i);
					//}
					if ((entry.Source == Source) && (entry.EntryType == Type) && (entry.TimeGenerated > StartTime))
					{
						// Create new elements
						XmlElement newEvent = xml.CreateElement("Event");
					
						XmlElement elemID = xml.CreateElement("ID");
						elemID.InnerText = entry.EventID.ToString();
						XmlElement elemType = xml.CreateElement("Type");
						elemType.InnerText = entry.EntryType.ToString();
						XmlElement elemDateTime = xml.CreateElement("TimeGenerated");
						elemDateTime.InnerText = entry.TimeGenerated.ToString("G");
						XmlElement writtenTime = xml.CreateElement("TimeWritten");
						writtenTime.InnerText = entry.TimeWritten.ToString("G");
						XmlElement elemSource = xml.CreateElement("Source");
						elemSource.InnerText = entry.Source;
						XmlElement elemMessage = xml.CreateElement("Message");
						elemMessage.InnerText = entry.Message;

						// Add SubElements to new Node
						newEvent.AppendChild(elemID);
						newEvent.AppendChild(elemType);
						newEvent.AppendChild(elemDateTime);
						newEvent.AppendChild(writtenTime);
						newEvent.AppendChild(elemSource);
						newEvent.AppendChild(elemMessage);

						// Add new node to Events Node.
						EventsNode.AppendChild(newEvent);
					}
				}
				RunLocalCmd(@"net use \\" + this.MachineName + " /d /y", true);
			}
			catch (System.UnauthorizedAccessException e)
			{
				Console.WriteLine("Total number of entries in log: {0}", elec.Count);
				Console.WriteLine(e.Message);
				Console.WriteLine(e.StackTrace);
			}
			catch (System.Exception e)
			{
				Console.WriteLine(e.Message);
				Console.WriteLine(e.StackTrace);
			}
			*/
		}

		public static void myLog(string msg)
		{
			Trace.WriteLine(DateTime.Now.ToString("G") + " EventCollector: " + msg);
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\ANS\ANS\sspDB.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Collections;


namespace Microsoft.XBoxLive.Test.ANS
{

	public class sspSuite
	{
		private string buildNumber;
		private string suiteName;
		private string scenarioName;
		private string bedName;
		private string testerAlias;
		private string m_Product;
		private string m_Release;
		private int m_SuiteID;
        private DateTime testDateTime;
		private bool IsPerfTest;
        private string m_DataSource;
		private ArrayList TestList = new ArrayList();

		const string g_cnString = "initial catalog=PerformanceSummaries;data source={0};Connect Timeout=30;Integrated Security=True";

		public sspSuite(string SuiteName, string BedName, string TesterAlias, string ScenarioName, string BuildNumber, DateTime TestDateTime, string Product, string Release, bool IsPerfTest, string DataSource)
		{
			suiteName = SuiteName;
			buildNumber = BuildNumber;
			bedName = BedName;
			testerAlias = TesterAlias;
			testDateTime = TestDateTime;
			scenarioName = ScenarioName;
			this.IsPerfTest = IsPerfTest;

			this.m_Product = Product;
			this.m_Release = Release;
            this.m_DataSource = DataSource;

			//set testsuite ID here by creating a new testsuite in DB
            SqlConnection myConnection = new SqlConnection(string.Format(g_cnString, m_DataSource));


			// just throw the exception if exists.
			myConnection.Open();

				SqlCommand AddSuiteCmd = new SqlCommand("AddSuite",myConnection);
				AddSuiteCmd.CommandType = CommandType.StoredProcedure;
			
				SqlParameter tmpParam = AddSuiteCmd.Parameters.Add("@ScenarioName", SqlDbType.VarChar);
				tmpParam.Value = this.scenarioName;

				tmpParam = AddSuiteCmd.Parameters.Add("@BuildNumber", SqlDbType.VarChar);
				tmpParam.Value = this.buildNumber;

				tmpParam = AddSuiteCmd.Parameters.Add("@TestDate", SqlDbType.DateTime);
				tmpParam.Value = this.testDateTime;

				tmpParam = AddSuiteCmd.Parameters.Add("@TesterAlias", SqlDbType.VarChar);
				tmpParam.Value = this.testerAlias;

				tmpParam = AddSuiteCmd.Parameters.Add("@BedName", SqlDbType.VarChar);
				tmpParam.Value = this.bedName;

				tmpParam = AddSuiteCmd.Parameters.Add("@Release", SqlDbType.VarChar);
				tmpParam.Value = this.m_Release;

				tmpParam = AddSuiteCmd.Parameters.Add("@Product", SqlDbType.VarChar);
				tmpParam.Value = this.m_Product;

				tmpParam = AddSuiteCmd.Parameters.Add("@IsPerfTest", SqlDbType.Bit);
				if (this.IsPerfTest)
					tmpParam.Value = 1;
				else
					tmpParam.Value = 0;
	
				tmpParam = AddSuiteCmd.Parameters.Add("RETURN_VALUE", SqlDbType.Int);
				tmpParam.Direction = ParameterDirection.ReturnValue;

				SqlDataReader tmp = AddSuiteCmd.ExecuteReader();

				int TestSuiteID = (int) AddSuiteCmd.Parameters["RETURN_VALUE"].Value;
				this.m_SuiteID = TestSuiteID;
				tmp.Close();
				myConnection.Close();
		}

		public ArrayList TestRuns
		{
			get
			{
				return this.TestList;
			}
		}

		public int SuiteID
		{
			get
			{
				return this.m_SuiteID;
			}
		}

		public void AddTest(sspTest aTest)
		{
			TestList.Add(aTest);
		}


		public void ClearTests()
		{
			TestList.Clear();	
		}

		public void AddSuiteToDatabase()
		{
			// Add Suite first, then tests with that SuiteID.
			//string myConnectionString = "Initial Catalog=PerformanceSummaries;Data Source=mpgperfweb;User ID=PerfUser;Pwd=PerfUser";
			#region add new suite to DB -- moved to constructor
			/*SqlConnection myConnection = new SqlConnection(g_cnString);
			myConnection.Open();

			SqlCommand AddSuiteCmd = new SqlCommand("AddSuite",myConnection);
			AddSuiteCmd.CommandType = CommandType.StoredProcedure;
			
			SqlParameter tmpParam = AddSuiteCmd.Parameters.Add("@ScenarioName", SqlDbType.VarChar);
			tmpParam.Value = this.scenarioName;

			tmpParam = AddSuiteCmd.Parameters.Add("@BuildNumber", SqlDbType.VarChar);
			tmpParam.Value = this.buildNumber;

			tmpParam = AddSuiteCmd.Parameters.Add("@TestDate", SqlDbType.DateTime);
			tmpParam.Value = this.testDateTime;

			tmpParam = AddSuiteCmd.Parameters.Add("@TesterAlias", SqlDbType.VarChar);
			tmpParam.Value = this.testerAlias;

			tmpParam = AddSuiteCmd.Parameters.Add("@BedName", SqlDbType.VarChar);
			tmpParam.Value = this.bedName;

			tmpParam = AddSuiteCmd.Parameters.Add("@Release", SqlDbType.VarChar);
			tmpParam.Value = this.m_Release;

			tmpParam = AddSuiteCmd.Parameters.Add("@IsPerfTest", SqlDbType.Bit);
			if (this.IsPerfTest)
				tmpParam.Value = 1;
			else
				tmpParam.Value = 0;

			tmpParam = AddSuiteCmd.Parameters.Add("RETURN_VALUE", SqlDbType.Int);
            tmpParam.Direction = ParameterDirection.ReturnValue;

            SqlDataReader tmp = AddSuiteCmd.ExecuteReader();

			int TestSuiteID = (int) AddSuiteCmd.Parameters["RETURN_VALUE"].Value;
			this.m_SuiteID = TestSuiteID;
			tmp.Close();
			*/
			#endregion

            SqlConnection cn = new SqlConnection(string.Format(g_cnString, m_DataSource));
			cn.Open();

			foreach (sspTest aTest in TestList)
			{
				SqlCommand cmd = new SqlCommand("AddTestRun", cn);
				cmd.CommandType = CommandType.StoredProcedure;

				SqlParameter p1 = new SqlParameter("@SuiteID", SqlDbType.Int);
				p1.Value = this.SuiteID;
				cmd.Parameters.Add(p1);

                SqlParameter p2 = new SqlParameter("@ThreadCount", SqlDbType.Int);
				p2.Value = aTest.ThreadCount;
				cmd.Parameters.Add(p2);

				SqlParameter p3 = new SqlParameter("@StartTime", SqlDbType.DateTime);
				p3.Value = aTest.StartTime;
				cmd.Parameters.Add(p3);

				SqlParameter p4 = new SqlParameter("@EndTime", SqlDbType.DateTime);
				p4.Value = aTest.EndTime;
				cmd.Parameters.Add(p4);

				SqlParameter p5 = new SqlParameter("@returnValue", SqlDbType.Int);
				p5.Direction = ParameterDirection.ReturnValue;
				cmd.Parameters.Add(p5);

				cmd.ExecuteNonQuery();

				// save the TestRunID to be used later when adding data values.
				aTest.TestRunID = (Int32) p5.Value;

				
			}
			cn.Close();
		}

		private int GetBedID(string BedName)
		{
			// given the name of the bed, return the BedID.
			return 1;
		}


	}


	public class sspTest
	{
		private string testName;
		DateTime startTime;
		DateTime endTime;
		Int32 threadCount;
		Int32 testRunID;

		public sspTest(string TestName, int ThreadCount)
		{
			this.testName = TestName;
			startTime = new DateTime(DateTime.Now.Ticks);			 
			endTime = new DateTime(DateTime.Now.Ticks);
			threadCount = ThreadCount;
		}

		public Int32 TestRunID
		{
			get
			{
				return this.testRunID;
			}
			set
			{
				this.testRunID = value;
			}
		}

		public string TestName
		{
			get
			{
				return testName;
			}
			set
			{
				testName = value;
			}
		}

		public int ThreadCount
		{
			get
			{
				return threadCount;
			}
			set
			{
				threadCount = value;
			}
		}

		public DateTime StartTime
		{
			get
			{
				return startTime;
			}
			set
			{
				startTime = value;
			}
		}

		public DateTime EndTime
		{
			get
			{
				return endTime;
			}
			set
			{
				endTime = value;
			}
		}



	}

	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\ANS\ANS\GetLatestGoodBuild.cs ===
#define TRACE

using System;
using System.Net;
using System.IO;
using System.Text;
using System.Data.SqlClient;
using System.Data;
using System.Diagnostics;
using Microsoft.Win32;
using System.Collections.Generic;
using System.Collections;

namespace Microsoft.XBoxLive.Test.ANS
{
	class CBuildProvider
	{

        public static string GetLatestBuild(string Release, string DataSource)
        {
            string buildVersion = string.Empty;

            string cnString = "user id=PerfUser;password=PerfUser;initial catalog=PerformanceSummaries;data source={0};Connect Timeout=30";
            SqlConnection cn = new SqlConnection(string.Format(cnString, DataSource));
            cn.Open();

            SqlCommand cmd = new SqlCommand("SELECT DropLocation FROM Releases WHERE Release='" + Release + "'", cn);
            Object objBuildLoc = cmd.ExecuteScalar();
            if (objBuildLoc is DBNull)
            {
                throw new Exception("Unable to get latest build since PerformanceSummaries..Releases.DropLocation is null.");
            }

            String BuildLoc = (String)objBuildLoc;

            if (!Directory.Exists(BuildLoc))
            {
                throw new Exception("The build location does not exist: " + BuildLoc);
            }

            if (!Directory.Exists(BuildLoc + "\\latest.tst"))
            {
                throw new Exception("latest.tst folder does not exist at the build location.");
            }

            DirectoryInfo di = new DirectoryInfo(BuildLoc + "\\latest.tst");

            FileInfo[] fi = di.GetFiles("08*.*");

            // there should only be one file that starts with 08*
            // return the file name as the latest version.
            string[] versionParts = fi[0].Name.Split('.');
            Int32 majorVersion = Int32.Parse(versionParts[0]);
            Int32 minorVersion = Int32.Parse(versionParts[1]);
            Int32 build = Int32.Parse(versionParts[2]);
            Int32 dot = Int32.Parse(versionParts[3]);

            string version = majorVersion.ToString() + "." + minorVersion.ToString() + "." + build.ToString() + "." + dot.ToString();
            return version;                        
        }

        public static string GetLatestGoodBuild(string Product, string Release)
        {
			string LatestPassingBVTBuildNumber;

            SqlConnection cn = new SqlConnection("server=SPGAuto;database=SCGTest;User ID=sa;Password=Ad994me#");
			try
			{
				myLog("Attempting to open database connection to sas.");
				cn.Open();
				SqlCommand cmd = new SqlCommand("GetLatestPassingBVT",cn);
				cmd.CommandType = CommandType.StoredProcedure;

				SqlParameter param = cmd.Parameters.Add("@Product",SqlDbType.VarChar,50);
				param.Value = Product;
				param = cmd.Parameters.Add("@Release",SqlDbType.VarChar,50);
				param.Value = Release;

				param = cmd.Parameters.Add("@OutputBuildNumber", SqlDbType.Real, 4);
				param.Direction = ParameterDirection.Output;
                
				myLog("Attempting to execute sp to get latest passing bvt.");
				cmd.ExecuteNonQuery();

				LatestPassingBVTBuildNumber = cmd.Parameters["@OutputBuildNumber"].Value.ToString();
				myLog("Latest passing BVT build number set to: " + LatestPassingBVTBuildNumber);
				RegistryKey regKey = RegistryKey.OpenRemoteBaseKey(RegistryHive.LocalMachine,String.Empty);
				regKey.CreateSubKey( "SOFTWARE\\Microsoft\\ANS" ).SetValue( "LatestGoodBuild", LatestPassingBVTBuildNumber);			
				return LatestPassingBVTBuildNumber;
			}
			catch (Exception e)
			{
				myLog("Failure while getting latest passing BVT (error below). Returning cached BVT value.");
				myLog(e.Source + " - " + e.Message);
				myLog(e.StackTrace);
				//Read from cache (registry)
				RegistryKey regKey = RegistryKey.OpenRemoteBaseKey( RegistryHive.LocalMachine, String.Empty );
				LatestPassingBVTBuildNumber = regKey.OpenSubKey("SOFTWARE\\Microsoft\\ANS" ).GetValue( "LatestGoodBuild" ).ToString();
				myLog("Latest passing BVT from cache is: " + LatestPassingBVTBuildNumber);
			}

			return LatestPassingBVTBuildNumber;

        }

		public static void myLog(string msg)
		{
			Trace.WriteLine(DateTime.Now.ToString("G") + " CBuildProvider: " + msg);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\BillingNotificationPoster\main.cs ===
using System;
using System.Xml;
using System.ComponentModel;
using System.Collections.Generic;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.UserAccount;

namespace BillingNotifications
{
    class BillingNotificationPoster
    {
        [STAThread]
        static void Main(string[] args)
        {
            //Parameters
            string envName = "";
            string mode = "";
            bool showHelp=(args.Length==0);
            int caseNumber=-1;
            string []users=new string[4];
            for (int i=0; i<4; ++i)
            {
                users[i]="";
            }
            int postCount=3;
            int daysOffset=0;
            byte ccType=0;
            short ccNum=0;
            byte ccReason=0;

            //Route all output from the root to debug output and consoleX
            ServerTestFramework.Report.GetRoot().AddReportDestination(new DebugOutputReportDestination());
            ServerTestFramework.Report.GetRoot().AddReportDestination(new ConsoleReportDestination());

            //Parse command line
            for (int i=0; i<args.Length; ++i)
            {
                if (args[i].StartsWith("-") || args[i].StartsWith("/"))
                {
                    string commandArg=args[i].Substring(1, args[i].Length-1);
                    string command=commandArg;
                    string param="";
                    int indParam=commandArg.IndexOf(":");
                    if (indParam!=-1)
                    {
                        command=command.Substring(0, indParam);
                        param=commandArg.Substring(indParam+1);
                    }

                    string commandLower=command.ToLower();
                    string paramLower=param.ToLower();

                    if (commandLower=="?" || commandLower=="help" || commandLower=="h")
                    {
                        showHelp=true;
                        break;
                    }
                    else if (commandLower=="env")
                    {
                        envName=param;
                    }
                    else if (commandLower=="mode")
                    {
                        mode=paramLower;
                    }
                    else if (commandLower=="case")
                    {
                        caseNumber=int.Parse(paramLower);
                    }
                    else if (commandLower=="user")
                    {
                        users[0]=param;
                    }
                    else if (commandLower=="user2")
                    {
                        users[1]=param;
                    }
                    else if (commandLower=="user3")
                    {
                        users[2]=param;
                    }
                    else if (commandLower=="user4")
                    {
                        users[3]=param;
                    }
                    else if (commandLower=="count")
                    {
                        postCount=int.Parse(paramLower);
                    }
                    else if (commandLower=="days")
                    {
                        daysOffset=int.Parse(paramLower);
                    }
                    else if (commandLower=="cctype")
                    {
                        ccType=byte.Parse(paramLower);
                    }
                    else if (commandLower=="ccnum")
                    {
                        ccNum=short.Parse(paramLower);
                    }
                    else if (commandLower=="ccreason")
                    {
                        ccReason=byte.Parse(paramLower);
                    }
                    else
                    {
                        Global.RO.Error("Unknown argument: "+commandArg);
                        return;
                    }
                }
                else
                {
                    Global.RO.Error("Malformed argument: "+args[i]);
                    return;
                }
            }

            //Show commandline arguments
            if (showHelp)
            {
                Console.WriteLine("Usage: (client test case mode)");
                Console.WriteLine("  BillingNotificationPoster -mode:test -env:Name -case:Number -user:Gamertag [-user2:Gamertag] [-user3:Gamertag] [-user4:Gamertag]");
                Console.WriteLine("");
                Console.WriteLine("Usage: (direct post subscription expiration mode)");
                Console.WriteLine("  BillingNotificationPoster -mode:postse -env:Name -user:Gamertag [-days:Number]");
                Console.WriteLine("");
                Console.WriteLine("Usage: (direct post credit card decline mode)");
                Console.WriteLine("  BillingNotificationPoster -mode:postccd -env:Name -user:Gamertag [-count:Number] [-cctype:Number] [-ccnum:Number] [-ccreason:Number]");
                Console.WriteLine("Usage: (clear all notifications mode)");
                Console.WriteLine("  BillingNotificationPoster -mode:clear -env:Name -user:Gamertag");
                Console.WriteLine("");
                Console.WriteLine("");
                Console.WriteLine("Parameters:");
                Console.WriteLine("  -env: The name of the environment in stf.xml to run against.");
                Console.WriteLine("  -mode: Run mode for the app.");
                Console.WriteLine("  -case: Test case identifier from the client test.");
                Console.WriteLine("  -user: The gamertag of the user.");
                Console.WriteLine("  -count: The number of notifications to add.");
                Console.WriteLine("  -days: Number of days to add to the current date to use for the expiration date.");
                Console.WriteLine("  -cctype: Credit card type.");
                Console.WriteLine("  -ccnum: Credit card number.");
                Console.WriteLine("  -ccreason: Reason code for the decline.");
                Console.WriteLine("");
                Console.WriteLine("Examples:");
                Console.WriteLine("  BillingNotificationPoster -mode:test -env:testnet -case:17 -user:XeGamertagFoo");
                Console.WriteLine("  BillingNotificationPoster -mode:postse -env:testnet -user:XeGamertagFoo -days:5");
                Console.WriteLine("  BillingNotificationPoster -mode:postccd -env:testnet -user:XeGamertagFoo -cctype:1 -ccnum:1234 -ccreason:2");
                Console.WriteLine("  BillingNotificationPoster -mode:clear -env:testnet -user:XeGamertagFoo");
                return;
            }

            //Verify common parameters
            if (envName.Length==0)
            {
                Global.RO.Error("env parameter is required.");
                return;
            }

            if (mode.Length==0)
            {
                Global.RO.Error("mode parameter is required.");
                return;
            }

            //Initialize the STF
            XmlDocument config=new XmlDataDocument();
            try
            {
                config.Load("stf.xml");
            }
            catch (System.IO.FileNotFoundException)
            {
                Console.WriteLine("Error: Unable to find config file \"stf.xml\" in the current directory.");
                return;
            }
            CoreGlobal.Initialize(config);

            bool found=false;
            foreach (EnvironmentSetting envSetting in Global.EnvironmentList)
            {
                if (envSetting.Environment.ToLower()==envName.ToLower())
                {
                    Global.CurrentEnvironment=envSetting;
                    found=true;
                }
            }
            if (!found)
            {
                Global.RO.Error("Error - unknown environment '{0}' specified (not in stf.xml?).", envName);
                return;
            }

            Global.ResetEnvironment();

            //be verbose in adds
            BillingNotificationHelpers.VerboseNotificationAdds=true;

            //lookup the puids for each user specified
            Global.RO.Debug("Looking up puids...");
            List<ulong> puids=new List<ulong>();
            foreach (string gtag in users)
            {
                ulong puid=0;
                if (gtag.Length>0)
                {
                    object ret=UodbWS.ExecuteSQLScalar("select bi_user_puid from t_user_names where vc_gamertag='"+gtag.Replace("'","''")+"'", gtag);
                    if (ret==null)
                    {
                        Global.RO.Error("User '"+gtag+"' NOT FOUND in t_user_names.");
                        return;
                    }
                    puid=(ulong)(long)ret;
                    Global.RO.Debug("User '"+gtag+"' is Puid 0x"+Hexer.tohex(puid));
                }

                puids.Add(puid);
            }

            //Process commands
            if (mode=="postse") //command to add a subscription expiration
            {
                BillingNotificationHelpers.AddUserBillingNotificationSubscriptionExpire(puids[0], System.Guid.NewGuid(), System.DateTime.UtcNow, 0, System.DateTime.UtcNow+new System.TimeSpan(daysOffset, 0, 0, 0));
            }
            else if (mode=="postccd") //command to add a credit card decline
            {
                for (int i=0; i<postCount; ++i)
                {
                    BillingNotificationHelpers.AddUserBillingNotificationCCDecline(puids[0], System.Guid.NewGuid(), System.DateTime.UtcNow, 0, ccType, ccNum, ccReason);
                }
            }
            else if (mode=="clear")
            {
                ResetUser(puids.ToArray()[0]);
            }
            else if (mode=="test") //command to populate based on the client test case scenario
            {
                if (caseNumber==-1)
                {
                    Global.RO.Error("case parameter is required.");
                    return;
                }

                //wipe out all existing notifications and ticket flags
                foreach (ulong puid in puids)
                {
                    if (puid!=0)
                    {
                        ResetUser(puid);
                    }
                }

                //run scenario
                try
                {
                    ClientScenarios.RunScenario(caseNumber, puids.ToArray());
                }
                catch (System.Exception e)
                {
                    Global.RO.Error("Exception: "+e);
                    return;
                }
            }
            else
            {
                Global.RO.Error("Unknown operation mode specified: "+mode);
            }
        }

        private static void ResetUser(ulong puid)
        {
            Global.RO.Debug("Clearing notifications and ticket flag for user=0x"+Hexer.tohex(puid));

            UodbWS.ExecuteSQLNonQuery("delete from t_user_billing_notifications where bi_user_puid="+(long)puid, puid);

            UserEditor ue=UserEditor.FromPuid(puid);
            ue.ExtraTicketFlags&=0x7fff;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\ANS\ANS\ANSEngine.cs ===
#define TRACE

using System;
using System.Reflection;
using System.Threading;
using ActApplicationLIB;
using System.Diagnostics;
using System.Data;
using System.Data.SqlClient;
using System.Xml;
using System.Text;
using System.Management;
using System.IO;
using System.Net.Mail;
using System.Runtime.InteropServices;
using System.Collections.Specialized;
using System.Security.Principal;
using System.Collections;

namespace Microsoft.XBoxLive.Test.ANS
{
    /// <summary>
    /// Summary description for CAnsScenario.
    /// </summary>
    public class CAnsScenario
    {
        // define interop structures and functions for getting remote time.
        [ StructLayout( LayoutKind.Sequential )]
            public class TIME_OF_DAY_INFO
        {
            public int tod_elapsedt;
            public int tod_msecs;
            public int tod_hours;
            public int tod_mins;
            public int tod_secs;
            public int tod_hunds;
            public int tod_timezone;
            public int tod_tinterval;
            public int tod_day;
            public int tod_month;
            public int tod_year;
            public int tod_weekday;
        }

        [DllImport("NETAPI32.DLL", CharSet=CharSet.Unicode)]
        public static extern int NetRemoteTOD (string RemoteBox, ref TIME_OF_DAY_INFO tod);

        string m_ScenarioName, m_ActSuite, m_BuildNumber, m_TesterAlias, m_ArchiveLocation;
        string m_StressSettingsFile, m_StressSuiteDll;
		string m_Release, m_Product, m_MachineName, m_Password;
		string m_DataSource;

        //const int MAX_MACHINES_SUPPORTED = 2;
        //string m_MachineName = new string[MAX_MACHINES_SUPPORTED];
		//string m_Password = new string[MAX_MACHINES_SUPPORTED];
        //string m_MachineName;
        //string m_Password;


        bool m_CountersOn;
        bool m_IsPerfTest;

        //Topology tp;

        private sspSuite suite;

        const string g_cnString = "initial catalog=PerformanceSummaries;data source={0};Connect Timeout=30;Integrated Security=True";

		public CAnsScenario()
		{
		
		}

        public CAnsScenario(string ScenarioName, string MachineName, string Password, string ActSuite, string BuildNumber, string TesterAlias, string ArchiveLocation, string Product, string Release, string DataSource, string StressSettingsFile, string StressSuiteDll)
        {
            myLog("Inside CAnsScenario Constructor.");
            this.m_ScenarioName = ScenarioName;
            this.m_MachineName = MachineName;
            this.m_Password = Password;
            this.m_ActSuite = ActSuite;
            this.m_TesterAlias = TesterAlias;
            this.m_Product = Product;
            this.m_Release = Release;
            this.m_IsPerfTest = IsPerfTest;
            this.m_StressSettingsFile = StressSettingsFile;
            this.m_StressSuiteDll = StressSuiteDll;


            this.m_BuildNumber = BuildNumber;
            this.m_DataSource = DataSource;

			myLog("Name = " + this.m_ScenarioName);
			myLog("ActSuite = " + this.m_ActSuite);
            myLog("TesterAlias = " + this.m_TesterAlias);
            myLog("Product = " + this.m_Product);
            myLog("Release = " + this.m_Release);
            myLog("IsPerfTest = " + this.m_IsPerfTest.ToString());
            myLog("Build Number = " + this.m_BuildNumber);

			try
			{
                suite = new sspSuite(this.m_ScenarioName, this.m_MachineName, this.m_TesterAlias, this.m_ScenarioName, this.m_BuildNumber, DateTime.Now, this.m_Product, this.m_Release, this.m_IsPerfTest, m_DataSource);
			}
			catch (Exception ex)
			{
				throw new Exception("Failed to create test suite. " + ex.Message, ex);
			}

            myLog("Test Suite ID = " + suite.SuiteID.ToString());

            m_ArchiveLocation = ArchiveLocation + "_" + suite.SuiteID.ToString();

            //as soon as archive location is known, should update the database.

            // Update blgLocation in TestSuites table - only if we have a suiteID
            if (this.suite.SuiteID > 0)
            {
                SqlConnection cn = new SqlConnection(string.Format(g_cnString, m_DataSource));
                cn.Open();
                string sql = "UPDATE TestSuites SET blgLocation='" + this.m_ArchiveLocation + "' WHERE TestSuiteID=" + this.suite.SuiteID.ToString();
                SqlCommand cmd = new SqlCommand(sql, cn);
                cmd.ExecuteNonQuery();
                cn.Close();
            }
            myLog("Archive Location = " + this.m_ArchiveLocation);

            m_CountersOn = false;

            myLog("Exiting CAnsScenario Constructor.");
        }

        public string ArchiveLocation
        {
            get
            {
                return this.m_ArchiveLocation;
            }
        }

        private void FixBuildNumber()
        { 
            // need to change 8.1.4.0 to 08.01.0004.00
            string[] buildVers = this.m_BuildNumber.Split('.');
            Int32 MajorVer = Int32.Parse(buildVers[0]);
            Int32 MinorVer = Int32.Parse(buildVers[1]);
            Int32 Build = Int32.Parse(buildVers[2]);
            Int32 Dot = Int32.Parse(buildVers[3]);

            string fixedBuild = MajorVer.ToString("00") + "." + MinorVer.ToString("00") + "." + Build.ToString("0000") + "." + Dot.ToString("00");
            this.m_BuildNumber = fixedBuild;
        }

        public int DoAction(XmlNode ActionNode)
        {
            myLog("Inside DoAction");
            // Do text replacement first...
            FixBuildNumber();
            foreach (XmlAttribute att in ActionNode.Attributes)
            {
                att.Value = att.Value.Replace("[BUILDNUMBER]",this.m_BuildNumber);
                att.Value = att.Value.Replace("[MACHINENAME]",this.m_MachineName);
                att.Value = att.Value.Replace("[SCENARIONAME]",this.m_ScenarioName);
                att.Value = att.Value.Replace("[PASSWORD]",this.m_Password);
                att.Value = att.Value.Replace("[TESTERALIAS]",this.m_TesterAlias);
                att.Value = att.Value.Replace("[ARCHIVELOCATION]", this.ArchiveLocation);
                att.Value = att.Value.Replace("[RELEASE]", this.m_Release);
                att.Value = att.Value.Replace("[PRODUCT]", this.m_Product);
                att.Value = att.Value.Replace("[STRESSSUITEDLL]", this.m_StressSuiteDll);
                att.Value = att.Value.Replace("[STRESSSETTINGSFILE]", this.m_StressSettingsFile);
            }
            string Type = ActionNode.Attributes.GetNamedItem("Type").Value;
            string Command, startStop, Name, LengthUnits;
			int Threads, TestLength, PollSeconds;
            bool WaitToFinish, UseIterations;

            switch (Type)
            {
                case "FixStfXml":
                    String IP = ActionNode.Attributes.GetNamedItem("XBlobIP").Value;
                    String stfXmlFile = ActionNode.Attributes.GetNamedItem("StfXmlFile").Value;
                    FixStfXml(IP, stfXmlFile);
                    break;
                case "KillProcess":
                    String processName = ActionNode.Attributes.GetNamedItem("ProcessName").Value;
                    this.KillProcess(processName);
                    break;
                case "RunLocalCmdTest":
                    this.RunLocalCmdTest(ActionNode);
                    break;
				case "WaitForWakeUp":
					this.WaitForWakeUp( ActionNode );
					break;
				case "WaitForShutdown":
					this.WaitForShutdown( ActionNode );
					break;
                case "RunRemoteTATest":
					myLog("Inside case " + Type);
					Command = ActionNode.Attributes.GetNamedItem("Command").Value;
					Threads = Convert.ToInt16(ActionNode.Attributes.GetNamedItem("Threads").Value);
					WaitToFinish = Convert.ToBoolean(ActionNode.Attributes.GetNamedItem("WaitToFinish").Value);
					if (WaitToFinish)
						PollSeconds = Convert.ToInt32(ActionNode.Attributes.GetNamedItem("PollSeconds").Value);
					else
						PollSeconds = 0;

					this.RunRemoteTATest(Command,WaitToFinish, Threads, PollSeconds);
					break;
                case "RunRemoteCmd":
                    myLog("Inside case " + Type);
                    Command = ActionNode.Attributes.GetNamedItem("Command").Value;
                    WaitToFinish = Convert.ToBoolean(ActionNode.Attributes.GetNamedItem("WaitToFinish").Value);

					if (WaitToFinish)
						PollSeconds = Convert.ToInt32(ActionNode.Attributes.GetNamedItem("PollSeconds").Value);
					else
						PollSeconds = 0;

                    this.RunRemoteCmd(Command,WaitToFinish, PollSeconds);
                    break;
                case "RunLocalCmd":
                    myLog("Inside case RunLocalCmd");
                    Command = ActionNode.Attributes.GetNamedItem("Command").Value;
                    WaitToFinish = Convert.ToBoolean(ActionNode.Attributes.GetNamedItem("WaitToFinish").Value);
                    Int32 returnCode = this.RunLocalCmd(Command, WaitToFinish);
                    if (returnCode != 0)
                    {
                        throw new ApplicationException("RunLocalCmd ran and returned a non-zero value indicating failure.");
                    }
                    break;
				case "RunCustomTest":
					this.RunCustomTest( ActionNode );
					break;
                case "RunSTFGuiTest":
                    this.RunSTFGuiTest(ActionNode);
                    break;
                case "RunActTest":
					myLog("Inside case " + Type);                    
					Name = ActionNode.Attributes.GetNamedItem("Name").Value;
					Threads = Convert.ToInt16(ActionNode.Attributes.GetNamedItem("Threads").Value);
					TestLength = Convert.ToInt16(ActionNode.Attributes.GetNamedItem("TestLength").Value);
					LengthUnits = ActionNode.Attributes.GetNamedItem("LengthUnits").Value;
					if (LengthUnits.ToUpper() == "MINUTES")
						UseIterations = false;
					else
						UseIterations = true;
					WaitToFinish = Convert.ToBoolean(ActionNode.Attributes.GetNamedItem("WaitToFinish").Value);
					this.RunActTest(Name,Threads,TestLength,UseIterations,WaitToFinish);
					break;
                case "DeployCounters":
                    myLog("Inside case DeployCounters");
                    String counterFile = ActionNode.Attributes.GetNamedItem("CounterFile").Value;
                    String sampleRate = ActionNode.Attributes.GetNamedItem("SampleRate").Value;
                    this.DeployCounters(counterFile, sampleRate);
                    break;
                case "StartCounters":
                    myLog("Inside case StartCounters");
                    this.StartCounters();
                    break;
                case "StopCounters":
                    myLog("Inside case StopCounters");
                    this.StopCounters();
                    break;
                case "Sleep":
                    myLog("Inside case Sleep.");
                    int DurationSeconds = Convert.ToInt16(ActionNode.Attributes.GetNamedItem("DurationSeconds").Value);
                    this.Sleep(DurationSeconds);
                    break;
                case "ClearEvents":
                    myLog("Inside case ClearEvents.");
                    /* Check to see if glaive folder already exists for same test, for same build number *
                     * If so, do not run this test
                     * Assumes that */
                    int tmpcount = 0; // = CountScenarioFolders(this.m_ScenarioName, this.m_BuildNumber);
                    if (tmpcount >= 2)
                    {
                        myLog("Encountered " + tmpcount + " previous run folders of " + this.m_ScenarioName + " with build " + this.m_BuildNumber);
                        return 0; //return -1 here if you want to avoid additional runs...
                    }

                    string Log = ActionNode.Attributes.GetNamedItem("Log").Value;
                    ClearEvents(Log);
                    break;
                case "GetEvents":
                    myLog("Inside case GetEvents.");
                    this.GetEvents(ActionNode);
                    break;
                case "ProfileWithLOP":
                    myLog("Inside case ProfileWithLOP");
                    startStop = ActionNode.Attributes.GetNamedItem("StartStop").Value;
                    this.ProfileWithLOP(startStop);
					/*
					if (startStop.ToLower().Equals("stop"))
					{
						dws.ArchiveSpecialFileTypes(this,@"C$\LOP1.1","lop");
					}
					*/
                    break;
                case "ArchiveLogs":
                    myLog("Inside case ArchiveLogs");
                    bool ExtractData = Convert.ToBoolean(ActionNode.Attributes.GetNamedItem("ExtractData").Value);
                    this.ArchiveLogs( ActionNode, ExtractData );
                    break;
                case "SendMail":
					this.GetMailInfoAndSend( ActionNode );
                    break;
                case "RecordTests":
                    myLog("Inside case RecordTests");
                    suite.AddSuiteToDatabase();
                    //suite.ClearTests();  // not sure why we did this.  Need testruns for data extration.
                    break;	
            }
            return 0;
        }

        private void FixStfXml(String IP, String StfXmlFile)
        {
            if (!File.Exists(StfXmlFile))
            {
                throw new ApplicationException("Stf.xml file not found at: " + StfXmlFile);
            }
            XmlDocument stfXml = new XmlDocument();
            stfXml.Load(StfXmlFile);

            stfXml.SelectSingleNode("/stf/config/configenv[@environment='Xblob']").Attributes["npdbip"].Value = IP;
            stfXml.Save(StfXmlFile);
        }
        

        private void KillProcess(String ProcessName)
        {
            Process[] processes = Process.GetProcesses();
            foreach (Process p in processes)
            {
                if (p.ProcessName.Equals(ProcessName))
                {
                    p.Kill();
                    return;
                }
            }
        }

		private void WaitForShutdown( XmlNode ActionNode )
		{
			myLog( MethodInfo.GetCurrentMethod() );

			string wakeUpFile = @"\\" + this.m_MachineName + @"\d$\";
			wakeUpFile += ActionNode.Attributes.GetNamedItem( "WakeUpFile" ).Value;

			int timeOutMinutes = Convert.ToInt32( ActionNode.Attributes.GetNamedItem( "TimeOutMinutes" ).Value );
			DateTime dtStart = DateTime.Now;

			do
			{
				DateTime dtNow = DateTime.Now;
				TimeSpan ts = dtNow - dtStart;
				
				
				myLog( "Waiting for shutdown - " + ts.TotalSeconds + " seconds elapsed. Timeout = " +
					timeOutMinutes + " minutes.");

				Thread.Sleep( 5000 ); //Sleep five seconds

				if( ts.Minutes > timeOutMinutes )
				{
					throw new Exception( "Timeout while waiting for Shutdown." );
				}

			}while( RemoteMachineIsAwake( wakeUpFile ) );
		}

		private void WaitForWakeUp( XmlNode ActionNode )
		{
			myLog( MethodInfo.GetCurrentMethod() );

			string wakeUpFile = @"\\" + this.m_MachineName + @"\d$\";
			int timeOutMinutes = Convert.ToInt32( ActionNode.Attributes.GetNamedItem( "TimeOutMinutes" ).Value );
			int minutesElapsed = 0;

			wakeUpFile += ActionNode.Attributes.GetNamedItem( "WakeUpFile" ).Value;

			myLog( "wakeUpFile = " + wakeUpFile );
			myLog( "timeOutMinutes = " + timeOutMinutes );

			while( ! RemoteMachineIsAwake( wakeUpFile ) )
			{
				myLog( "Waiting for wakeup - " + minutesElapsed + " minutes elapsed. Timeout = " +
					   timeOutMinutes );

				Thread.Sleep( 60000 ); //Sleep one minute

				if( ++minutesElapsed > timeOutMinutes )
				{
					throw new Exception( "Timeout while waiting for wakeup." );
				}

			}

			myLog( "Machine " + this.m_MachineName + " is awake." );

		}

		private void GetMailInfoAndSend( XmlNode ActionNode )
		{
			myLog( MethodBase.GetCurrentMethod());
			string alias = ActionNode.Attributes.GetNamedItem("Alias").Value;
			string subject = ActionNode.Attributes.GetNamedItem("Subject").Value;
			string body = String.Empty;

			if( null != ActionNode.Attributes.GetNamedItem("MsgBody") )
			{
				body = "Archive Location: \"" + this.GetArchiveLocation + "\"\n\r";
				body += "\n\r" + ActionNode.Attributes.GetNamedItem("MsgBody").Value;
			}
				
			this.SendMail( alias, subject, body );
		}

		private bool RemoteMachineIsAwake( string WakeUpFile )
		{
			return File.Exists( WakeUpFile );
		}

        private void Sleep(int SecondsToSleep)
        {
            myLog("Inside Sleep");
            Thread.Sleep(SecondsToSleep * 1000);
            myLog("Leaving Sleep");
            return;
        }

        private void RunRemoteTATest(string Command, bool WaitToFinish, int Threads, int PoleSeconds)
        {
            myLog("Inside RunRemoteTATest.");
            sspTest tmpTest = new sspTest("SomeName", Threads);
            myLog("Getting and Setting test start time from remote system time.");
            tmpTest.StartTime = GetRemoteTime();
            this.RunRemoteCmd(Command, WaitToFinish, PoleSeconds);
            myLog("Getting and Setting test end time from remote system time.");
            tmpTest.EndTime = GetRemoteTime();

			// only add this test to suite if counters are on.
            if (this.m_CountersOn)
            {
                myLog("Adding test to suite since counters are on.");
                suite.AddTest(tmpTest);
            }
        }

        private void RunRemoteCmd(string Command, bool WaitToFinish, int PollSeconds)
        {
            myLog( "Inside RunRemoteCmd." );
            myLog( "Target machine = " + this.m_MachineName );
			myLog( "Command = " + Command );
            int ProcessID = RemoteExecute( Command );

            if (WaitToFinish)
            {
                myLog("Waiting for process " + ProcessID + " to finish on remote box.");
                while (ProcessExists(ProcessID))
                {
                    Thread.Sleep(PollSeconds * 1000);
                }
				myLog("Process " + ProcessID.ToString() + " has finished.");
            }
            else
            {
                myLog("Not waiting for remote process to finish.");
            }

            myLog("Leaving RunRemoteCmd");
            return;
        }

        private int RunLocalCmd(string Command, bool WaitToFinish)
        {
            return RunLocalCmd(Command, WaitToFinish, "C:\\", false);
        }

        private int RunLocalCmd(string Command, bool WaitToFinish, string workingDirectory, Boolean ShowOutput)
        {
            myLog("Inside RunLocalCmd, executing: " + Command);
            Process myProcess = new Process();
            string filename = Environment.ExpandEnvironmentVariables(@"%windir%\system32\cmd.exe");
            myProcess.StartInfo.FileName = filename;
            myProcess.StartInfo.Arguments = @"/c " + Command;
            myProcess.StartInfo.UseShellExecute = false;
            myProcess.StartInfo.RedirectStandardOutput = true;
            myProcess.StartInfo.WorkingDirectory = workingDirectory;
            
            myProcess.Start();

            if (WaitToFinish)
            {
                myLog("Waiting for Process" + myProcess.Id + " to finish.");
                string output = String.Empty;
                output = myProcess.StandardOutput.ReadToEnd();
                myProcess.WaitForExit();

                // Why is 'showing output' bad?  At the end of a local test, it usually takes
                // a long time to display all the output from the test to the console.  This
                // time is added to the test duration, and this skews the results when ANS 
                // extracts the data from the blg file.  There is several seconds of inactivity.

                if (ShowOutput)
                    myLog(output);

                myLog("Command has Finished.  ExitCode is " + myProcess.ExitCode);
                myLog("Leaving RunLocalCmd");
                return myProcess.ExitCode;
            }


            myLog("Not waiting for cmd to finish.");
            myLog("Leaving RunLocalCmd");
            return 0;
        }

		private void obtainProfileIDifPresent(ref string taTestName, ref int profileid)
		{
			string prof = "profileid";
			int tmp = taTestName.ToLower().IndexOf(prof);
			myLog("Inside obtainProfileIDifPresent");
			if (tmp == -1) return;
			profileid = Convert.ToInt32(taTestName.Substring(tmp+prof.Length,taTestName.Length-tmp-prof.Length));
			taTestName = taTestName.Substring(0,tmp);
			return;
		}

        private void RunLocalCmdTest(XmlNode ActionNode)
        {
            myLog(MethodInfo.GetCurrentMethod());
            int threadCount = Convert.ToInt32(ActionNode.Attributes.GetNamedItem("Threads").Value);
            string localCmd = ActionNode.Attributes.GetNamedItem("localCommand").Value;
            string testName = ActionNode.Attributes.GetNamedItem("Name").Value;
            string workingDir = ActionNode.Attributes.GetNamedItem("WorkingDirectory").Value;

            // create the test.
            sspTest customTest = new sspTest(testName, threadCount);

            // Set the start time for the test.
            customTest.StartTime = GetRemoteTime();

            myLog(" - Start Local cmd test: " + testName);

            this.RunLocalCmd(localCmd, true, workingDir, false);  // Always wait for the test to finish.

            customTest.EndTime = GetRemoteTime();

            // only add this test to suite if counters are on.
            if (this.m_CountersOn)
            {
                myLog("Adding test to suite since counters are on.");
                suite.AddTest(customTest);
            }
            else
            {
                myLog("Not adding test to suite because counters are not on.");
            }

        }

        private void RunSTFGuiTest(XmlNode ActionNode)
        {
            // things to do:
            //  1. Update components .stress_xml file to define which scenario gets run
            //  2. Update STFGui.xml to set test duration and autorun
            //  3. Start stfgui.exe passing in component.dll
            //  4. Wait for StfGui.exe to finish

            myLog(MethodInfo.GetCurrentMethod());

            Int32 threadCount = Convert.ToInt32(ActionNode.Attributes.GetNamedItem("Threads").Value);
            string testDuration = ActionNode.Attributes.GetNamedItem("TestDuration").Value;
            string stressSuiteDll = ActionNode.Attributes.GetNamedItem("StressSuiteDll").Value;
            string testNameInSuiteDll = ActionNode.Attributes.GetNamedItem("TestNameInSuiteDll").Value;
            string pathToStfGui = ActionNode.Attributes.GetNamedItem("PathToStfGui").Value;
            string stressSettingsFile = ActionNode.Attributes.GetNamedItem("StressSettingsFile").Value;
            
            UpdateStfGuiXml(pathToStfGui, testDuration, stressSettingsFile);
            UpdateStressSettingsFile(stressSettingsFile, testNameInSuiteDll, threadCount);

            // create the test.
            sspTest tmpTest = new sspTest("SomeName", threadCount);


            tmpTest.StartTime = GetRemoteTime();
            RunLocalCmd("StfGui.exe " + stressSuiteDll, true, pathToStfGui, true);
            tmpTest.EndTime = GetRemoteTime();

            // only add this test to suite if counters are on.
            if (this.m_CountersOn)
                suite.AddTest(tmpTest);     

            
        }

        private void UpdateStressSettingsFile(String StressSettingsFile, String TestNameInSuiteDll, Int32 ThreadCount)
        {
            /*
             * Sample Stress settings file.  Walk through Jobs, and set Scale to zero except for TestNameInSuiteDll=1
                <StressSettings>
                  <MainSettings>
                    <Scheduler>ServerTestFramework.Runner.StressSchedulerPriority</Scheduler>
                  </MainSettings>
                  <SchedulerSettings>
                    <MaxThreads>1</MaxThreads>
                  </SchedulerSettings>
                  <Jobs>
                    <Job Name="StringServTest.StringServTest GetString" Scale="0" />
                    <Job Name="StringServTest.StringServTest GetMultipleString" Scale="0" />
                    <Job Name="StringServTest.StringServTest AddString" Scale="1" />
                    <Job Name="StringServTest.StringServTest VetString" Scale="0" />
                    <Job Name="StringServTest.StringServTest GetTitle" Scale="0" />
                    <Job Name="StringServTest.StringServTest GetMultipleTitle" Scale="0" />
                    <Job Name="StringServTest.StringServTest XeAddString" Scale="0" />
                    <Job Name="StringServTest.StringServTest XeGetString" Scale="0" />
                    <Job Name="StringServTest.StringServTest XeGetMultipleString" Scale="0" />
                    <Job Name="StringServTest.StringServTest XeVetString" Scale="0" />
                    <Job Name="StringServTest.StringServTest XeLogString" Scale="0" />
                    <Job Name="StringServTest.StringServTest XeFailureLogString" Scale="0" />
                    <Job Name="StringServTest.StringServTest XeMeasurementLogString" Scale="0" />
                  </Jobs>
                </StressSettings>
             */
            XmlDocument xml = new XmlDocument();
            xml.Load(StressSettingsFile);
            XmlNodeList jobNodes = xml.SelectNodes("//Job");
            Boolean found = false;

            foreach (XmlNode job in jobNodes)
            {
                string name = job.Attributes["Name"].Value;
                if (name.Contains(TestNameInSuiteDll))
                {
                    if (true == found)
                    {
                        string moreErrMsg = Environment.NewLine + "StressSettingsFile: " + StressSettingsFile;
                        moreErrMsg += Environment.NewLine + "Test suite name: " + TestNameInSuiteDll;
                        throw new ApplicationException("Found two Job nodes in the stress settings file with test name." + moreErrMsg);
                    }
                    job.Attributes["Scale"].Value = "1";
                    found = true;
                }
                else
                {
                    job.Attributes["Scale"].Value = "0";
                }
            }

            if (false == found)
            {
                string moreErrMsg = Environment.NewLine + "StressSettingsFile: " + StressSettingsFile;
                moreErrMsg += Environment.NewLine + "Test suite name: " + TestNameInSuiteDll;
                throw new ApplicationException("Test suite not found in stress settings file. " + moreErrMsg);
            }

            xml.SelectSingleNode("/StressSettings/SchedulerSettings/MaxThreads").InnerText = ThreadCount.ToString();

            xml.Save(StressSettingsFile);
        }

        private void UpdateStfGuiXml(String StfGuiXmlPath, String TestDuration, String StressSettingsFile)
        {
            XmlDocument xml = new XmlDocument();

            string stfGuiFile = StfGuiXmlPath + "\\StfGui.xml";
            if (File.Exists(stfGuiFile))
            {
                xml.Load(stfGuiFile);
            }
            else
            {                
                xml.Load("StfGuiDefault.xml");
            }
            
            // create the node if it does not exist.
            XmlNode automationNode = xml.SelectSingleNode("/STFGui/Plugins/STFGui.Plugins.StressPlugin/Automation");
            if (automationNode == null)
            {
                XmlNode newAutoNode = xml.CreateElement("Automation");
                newAutoNode.AppendChild(xml.CreateElement("Enabled"));
                newAutoNode.AppendChild(xml.CreateElement("RunTime"));
                newAutoNode.AppendChild(xml.CreateElement("WarmUpTime"));
                newAutoNode.AppendChild(xml.CreateElement("CoolDownTime"));
                newAutoNode.AppendChild(xml.CreateElement("ResultsFile"));
                newAutoNode.AppendChild(xml.CreateElement("ConfigurationFile"));
                newAutoNode.AppendChild(xml.CreateElement("LogFile"));
                xml.SelectSingleNode("/STFGui/Plugins/STFGui.Plugins.StressPlugin").AppendChild(newAutoNode);
                automationNode = xml.SelectSingleNode("/STFGui/Plugins/STFGui.Plugins.StressPlugin/Automation");
            }
            automationNode.SelectSingleNode("Enabled").InnerText = "1";            
            automationNode.SelectSingleNode("RunTime").InnerText = TestDuration;
            automationNode.SelectSingleNode("WarmUpTime").InnerText = "00:00:00";
            automationNode.SelectSingleNode("CoolDownTime").InnerText = "00:00:00";
            automationNode.SelectSingleNode("ResultsFile").InnerText = "resultsFile.xml";
            automationNode.SelectSingleNode("ConfigurationFile").InnerText = StressSettingsFile;
            automationNode.SelectSingleNode("LogFile").InnerText = "LogFile.xml";

            xml.SelectSingleNode("/STFGui/Plugins/STFGui.Plugins.StressPlugin/MainSettings/Scheduler").InnerText = "ServerTestFramework.Runner.StressSchedulerPriority";

            xml.Save(stfGuiFile);        
        }

        private void RunCustomTest( XmlNode ActionNode ) 
        {

            myLog( MethodInfo.GetCurrentMethod() );

            int threadCount = Convert.ToInt32( ActionNode.Attributes.GetNamedItem( "Threads" ).Value );
            int PollSeconds = 0;
            string customTestFileSpec = ActionNode.Attributes.GetNamedItem( "TestFileSpec" ).Value;
            string testName = ActionNode.Attributes.GetNamedItem( "Name" ).Value;

            bool waitToFinish = Convert.ToBoolean( ActionNode.Attributes.GetNamedItem( "WaitToFinish" ).Value );

            if (waitToFinish)
                PollSeconds = Convert.ToInt32(ActionNode.Attributes.GetNamedItem("PollSeconds").Value);
            else
                PollSeconds = 0;


            /*
            if( null != ActionNode.Attributes.GetNamedItem( "TestLength" ) )
            {
                testDurationInMinutes = Convert.ToInt32( ActionNode.Attributes.GetNamedItem( "TestLength" ).Value );
                pollSeconds = ( testDurationInMinutes * 60 );
            }
            */

            Trace.WriteLine( "Parameters:" );

			Trace.WriteLine( "CustomTestFileSpec: " + customTestFileSpec );
			Trace.WriteLine( "ThreadCount       : " + threadCount.ToString() );
			//Trace.WriteLine( "Duration          : " + testDurationInMinutes );
			Trace.WriteLine( "WaitToFinish      : " + waitToFinish );

			// create the test.
			sspTest customTest = new sspTest( testName, threadCount);



			// Set the start time for the test.
			customTest.StartTime = GetRemoteTime();

			myLog( " - Start custom test run: " + testName );

			//oController.StartTest(MyProj,aTest,false);


		//if wait for finish

                this.RunRemoteCmd(customTestFileSpec, waitToFinish, PollSeconds);
            

				customTest.EndTime = GetRemoteTime();

				// only add this test to suite if counters are on.
				if (this.m_CountersOn)
				{
					myLog("Adding test to suite since counters are on.");
					suite.AddTest( customTest );
				}
				else
				{
					myLog("Not adding test to suite because counters are not on.");
				}
			

			myLog("Leaving " + MethodInfo.GetCurrentMethod().Name );

			return;
		}

        private void FindAndKillProcess(string name)
        {
            myLog("Attempting to kill process: " + name);
            foreach (Process clsProcess in Process.GetProcesses())
            {
                if (clsProcess.ProcessName.StartsWith(name))
                {
                    myLog("Found process with name: " + clsProcess.ProcessName + ". Attempting to kill it.");                    
                    clsProcess.Kill();
                }
            }        
        }

        private void RunActTest(string ActTestName, int ThreadCount, int TestLength, bool UseIterations, bool WaitForFinish)
        {
           
            myLog("Inside RunActTest");
            string ActProjectFilename = Path.GetFileName(this.m_ActSuite);
            string ActProjectPath = Path.GetDirectoryName(this.m_ActSuite);
            // Enter ACT.
            // Create necessary Project and controller objects to run ACT.
            myLog(" - Inside RunActTest with parameters:");
            Trace.WriteLine("ActProjectPath: " + ActProjectPath);
            Trace.WriteLine("ActProjectFilename: " + ActProjectFilename);
            Trace.WriteLine("ActTestName: " + ActTestName);
            Trace.WriteLine("ThreadCount: " + ThreadCount.ToString());
            Trace.WriteLine("Duration: " + TestLength.ToString());
            Trace.WriteLine("UseIterations: " + UseIterations.ToString());

            // create the test.
            sspTest tmpTest = new sspTest("SomeName", ThreadCount);

            Project MyProj = new Project();
            try
            {
                MyProj.Open(ActProjectPath, ActProjectFilename, false);
            }
            catch (Exception ex)
            {
                myLog(" - Unable to open ACT project file.  Probably bad path or file name provided.");
                myLog(" - Path is: " + ActProjectPath);
                myLog(" - Filename is: " + ActProjectFilename);
                throw new Exception("Bad ACT project file.",ex);
            }

            Controller oController = new ControllerClass();

            Tests oTests = MyProj.Tests;

            try
            {
				
                ActApplicationLIB.Test aTest = oTests[ActTestName];

                TestProperty propIterations = aTest.Properties["TestProperties:Iterations"];
                propIterations.Value = TestLength;

                TestProperty propDuration = aTest.Properties["TestProperties:Duration"];
                propDuration.Value = TestLength * 60;       // Must convert minutes to seconds.

                TestProperty propThreadCount = aTest.Properties["DynamicTest:NumberOfThreads"];
                propThreadCount.Value = ThreadCount;


                TestProperty propUseIterations = aTest.Properties["TestProperties:UseIterations"];
                if (UseIterations)
                    propUseIterations.Value = true;
                else
                    propUseIterations.Value = false;

                // Set the start time for the test.
                tmpTest.StartTime = GetRemoteTime();

                myLog(" - Start test: " + aTest.Name);
                oController.StartTest(MyProj,aTest,false);

            }
            catch (System.ArgumentException ex)
            {
                myLog(" - Error... Bad Act Test Name");
                Trace.WriteLine("ACT test name in ANSConfig.xml must match exactly to that in ACT project.");
                myLog("Leaving RunActTest");
                MyProj.Close();
                throw new Exception("Bad ACT test name.",ex);
            }
            catch (System.Exception ex)
            {
                myLog("Error... " + ex.Message);
                MyProj.Close();
                throw new Exception("Unknown System Exception.",ex);
            }

            if (oController.TestIsRunning)
            {
                myLog(" - Successfully started ACT test:");
                myLog(" - ProjectName: " + ActProjectFilename);
                myLog(" - TestName: " + ActTestName);
            }
            else
            {
                myLog(" - FAILED to start ACT test:");
                myLog(" - ProjectName: " + ActProjectFilename);
                myLog(" - TestName: " + ActTestName);
                myLog("Leaving RunActTest");
                throw new Exception("Failed to Start ACT test.");
            }


            if (WaitForFinish)
            {
                myLog("Waiting for test to finish...");
                // Wait for test to finish.
                while (oController.TestIsRunning)
                {
                    Thread.Sleep(1000);
                }
                myLog("Test has finished.");
                // Test is now complete. Add the test to the suite after setting end time.
                myLog("Getting and Setting test end time from remote system time.");
                tmpTest.EndTime = GetRemoteTime();

                // only add this test to suite if counters are on.
                if (this.m_CountersOn)
                {
                    myLog("Adding test to suite since counters are on.");
                    suite.AddTest(tmpTest);
                }
                else
                {
                    myLog("Not adding test to suite because counters are not on.");
                }
            }
            else
            {
                myLog("Test is running, but not waiting for finish.");
                if (UseIterations)
                    myLog("WARNING: Unable to write test to ANS database because you are using 'Iterations' and not waiting for test to finish.");
                else
                {
                    // Setting End time of test, and adding to suite since I know the test duration is minutes.
                    tmpTest.EndTime = GetRemoteTime();
                    // only add this test to suite if counters are on.
                    if (this.m_CountersOn)
                        suite.AddTest(tmpTest);
                }
            }

            MyProj.Close();
            myLog("Leaving RunActTest");
            return;
        }

        private DateTime GetRemoteTime()
        {
            myLog("Inside GetRemoteTime.");
            // verify connection to remote box first. Its OK if it already exists.
            TIME_OF_DAY_INFO tod = new TIME_OF_DAY_INFO();

            // this failed once with:
            //4/22/2009 3:31:14 PM Main: Exception Occurred: System.NullReferenceException: Object reference not set to an instance of an object.
            //at Microsoft.XBoxLive.Test.ANS.CAnsScenario.NetRemoteTOD(String RemoteBox, TIME_OF_DAY_INFO& tod)
            //at Microsoft.XBoxLive.Test.ANS.CAnsScenario.GetRemoteTime() in c:\Enlistments\xonline_r2\private\test\tools\ANS\ANS\ANSEngine.cs:line 912
            NetRemoteTOD(this.m_MachineName,ref tod);
            DateTime dt = new DateTime(tod.tod_year,tod.tod_month, tod.tod_day, tod.tod_hours, tod.tod_mins, tod.tod_secs);
            // need to subtract timezone (minutes) to adjust for location.
            dt = dt.AddMinutes((double)-tod.tod_timezone);
            return dt;
        }       

        private void StartCounters()
        {
            LogMan.StartCounters(this.m_MachineName, "ansLog");
            this.m_CountersOn = true;
            return;
        }

        private void StopCounters()
        {
            LogMan.StopCounters(this.m_MachineName, "ansLog");
            // don't think I need to do this.
            this.m_CountersOn = false;
            return;
        }

        private void DeployCounters(String CounterFile, String SampleRate)
        {
            LogMan.DeployCounters(this.m_MachineName, CounterFile, SampleRate, "ansLog");
            return;
        }

        private void GetEvents(XmlNode ActionNode)
        {
            myLog("Inside GetEvents");

            // Create Xml container for events
            XmlDocument doc = new XmlDocument();
            doc.LoadXml("<Events></Events>");

            // Get Log name and duration from ActionNode parameter
            string Log = ActionNode.Attributes.GetNamedItem("Log").Value;
            int LastXMinutes = Convert.ToInt32(ActionNode.Attributes.GetNamedItem("LastXMinutes").Value);

            myLog("Creating EventCollectorClass");
            EventCollectorClass ecc = new EventCollectorClass(Log,this.m_MachineName,LastXMinutes,this.m_Password);

            // Add filters defined in ActionNode
            foreach (XmlElement elem in ActionNode.SelectNodes("//Collect"))
            {
                string Type = elem.Attributes.GetNamedItem("Type").Value;
                string Source = elem.Attributes.GetNamedItem("Source").Value;
                myLog("Adding Filter: " + Type + " - " + Source);
                ecc.AddFilter(Type, Source);
            }

            // Populate the xml container with event information.
            myLog("Calling EventCollectorClass.WriteEvents()");
            ecc.WriteEvents(doc);

            //  Place the events xml file in the Archive Location.  Create folder if it doesn't exist.
            myLog("Writing events file to Archive Location");
            RunLocalCmd("md " + this.m_ArchiveLocation, true);
            doc.Save(this.m_ArchiveLocation + "\\Events.xml");

            EventCompressor.CompressEvents(this.ArchiveLocation);
			
			//compress files
			//this.convertToXML("cmpdEvents.xml");
			//this.convertToXML("cmpdErrorEvents.xml");
			//this.convertToXML("cmpdWarningEvents.xml");
        }

        private void ClearEvents(string Log)
        {
            myLog("Inside ClearEvents");
            // Create remote event log object, and clear events.
            EventLog el = new EventLog(Log,this.m_MachineName);
            el.Clear();

            // Clear method does not throw an exception if Log name is invalid.
            // Don't know how to handle errors here.
        }

        private void ArchiveLogs(XmlNode ActionNode, bool ExtractData)
        {
            myLog("Inside ArchiveLogs.");

            myLog("ArchiveLogs:: Connecting to topology machines. tp.ConnectionMachines");

            //append the suiteID to ArchiveLocation.
            //m_ArchiveLocation = this.m_ArchiveLocation + "_" + Suite.SuiteID.ToString();
            myLog("ArchiveLocation = " + this.m_ArchiveLocation);

            // Lets find the newest blg file and assume that is the correct file.
            string path = @"\\" + this.m_MachineName + @"\c$\PerfLogs\Admin";
            string[] blgFiles = Directory.GetFiles(path, "*.blg");

            string latestBlg = String.Empty;
            DateTime latestTime = DateTime.MinValue;

            foreach (string blgFile in blgFiles)
            {
                if (File.GetCreationTime(blgFile) > latestTime)
                {
                    latestBlg = blgFile;
                    latestTime = File.GetCreationTime(blgFile);
                }
            }

            if (!Directory.Exists(this.m_ArchiveLocation))
            {
                Directory.CreateDirectory(this.m_ArchiveLocation);
            }

            string newFile = this.m_ArchiveLocation + "\\" + m_MachineName + ".blg";
            File.Move(latestBlg, newFile);

			if (ExtractData)
			{
				myLog("Extraction set to true. Attempting to Extract Data.");
				ExtractAndSaveData(this.SuiteID, this.m_DataSource);				
			}
            myLog("Leaving ArchiveLogs.");
            return;
        }

		public static void ExtractAndSaveData(Int32 TestSuiteID, string DataSource)
		{
			SqlConnection cn = new SqlConnection(string.Format(g_cnString, DataSource));
			cn.Open();

			myLog("Inside ExtractAndSaveData");
			ArrayList testRuns = GetTestRuns(TestSuiteID, DataSource);
            ClearExistingData(TestSuiteID, DataSource);
            string blgFileName = GetPerfLogFileName(TestSuiteID, ".blg", DataSource);
            ArrayList CollectTheseCounters = GetCounterList(TestSuiteID, DataSource);
			blgAccess blg = new blgAccess(blgFileName);

			foreach (PerformanceCounter p in CollectTheseCounters)
			{
				blg.AddCounter(p.PerfCounterName);
			}

			foreach (sspTest t in testRuns)
			{
				blg.StartTime = t.StartTime;
				blg.EndTime = t.EndTime;

				blg.ExtractData();
				
				foreach (PerformanceCounter p in CollectTheseCounters)
				{
					double val = 0.0;
					switch (p.DataType)
					{
						case "AVG":
							try
							{
								val = blg.GetAvgValue(p.PerfCounterName);
                                // convert latency to ms                                
                                if (p.PerfCounterName.Contains("execution time"))
                                {
                                    val = val * 1000;
                                }
								SaveTestResult(p.PerfCounterID, t.TestRunID, (float) val, p.DataType, cn);
								myLog("Successfully saved AVG value: " + (float) val + " " + p.PerfCounterName);
							}
							catch (Exception ex)
							{
								myLog("Failed to get AVG performance counter value - continuing.");
								myLog("CounterName: " + p.PerfCounterName);
								myLog(ex.Message);
								myLog(ex.StackTrace);
							}
							break;
						case "MAX":
							try
							{
								val = blg.GetDeltaValue(p.PerfCounterName);
								SaveTestResult(p.PerfCounterID, t.TestRunID, (float) val, p.DataType, cn);
								myLog("Successfully saved DELTA value: " + (float) val + " " + p.PerfCounterName);
							}
							catch (Exception ex)
							{
								myLog("Failed to get MAX performance counter value - continuing.");
								myLog("CounterName: " + p.PerfCounterName);
								myLog(ex.Message);
								myLog(ex.StackTrace);
							}
							break;
					}
				}
			}
		}


		private static void ClearExistingData(Int32 TestSuiteID, string DataSource)
		{
            SqlConnection cn = new SqlConnection(string.Format(g_cnString, DataSource));
			cn.Open();

			SqlCommand cmd = new SqlCommand("ClearExistingData", cn);
			cmd.CommandType = CommandType.StoredProcedure;

			SqlParameter p1 = new SqlParameter("@TestSuiteId", SqlDbType.Int);
			p1.Value = TestSuiteID;
			cmd.Parameters.Add(p1);

			cmd.ExecuteNonQuery();
			cn.Close();
		}

		private static string GetPerfLogFileName(Int32 TestSuiteID, string format, string DataSource)
		{
            SqlConnection cn = new SqlConnection(string.Format(g_cnString, DataSource));
			cn.Open();

            SqlCommand cmd = new SqlCommand("GetPerfLogFileName", cn);
			cmd.CommandType = CommandType.StoredProcedure;

			SqlParameter p1 = new SqlParameter("@TestSuiteId", SqlDbType.Int);
			p1.Value = TestSuiteID;
			cmd.Parameters.Add(p1);

            SqlParameter p2 = new SqlParameter("@Format", SqlDbType.VarChar);
            p2.Value = format;
            cmd.Parameters.Add(p2);

            String blgFileName = (String) cmd.ExecuteScalar();
			cn.Close();
			return blgFileName;
		}

		private static ArrayList GetTestRuns(Int32 TestSuiteID, string DataSource)
		{
			ArrayList testRuns = new ArrayList();

            SqlConnection cn = new SqlConnection(string.Format(g_cnString, DataSource));
			cn.Open();

			SqlCommand cmd = new SqlCommand("GetTestRuns", cn);
			cmd.CommandType = CommandType.StoredProcedure;

			SqlParameter p1 = new SqlParameter("@TestSuiteId", SqlDbType.Int);
			p1.Value = TestSuiteID;
			cmd.Parameters.Add(p1);

			SqlDataReader dr = cmd.ExecuteReader();
			while (dr.Read())
			{
				sspTest t = new sspTest("test_" + dr.GetInt32(2), dr.GetInt32(2));
				t.TestRunID = dr.GetInt32(0);
				t.StartTime = dr.GetDateTime(3);
				t.EndTime = dr.GetDateTime(4);
				testRuns.Add(t);
			}
			cn.Close();

			return testRuns;			
		}

		private static void SaveTestResult(Int32 PerformanceCounterID, Int32 TestRunID, float Value, string DataType, SqlConnection cn)
		{
			SqlCommand cmd = new SqlCommand("AddDataValue", cn);
			cmd.CommandType = CommandType.StoredProcedure;

			SqlParameter p1 = new SqlParameter("@PerformanceCounterID", SqlDbType.Int);
			p1.Value = PerformanceCounterID;
			cmd.Parameters.Add(p1);

			SqlParameter p2 = new SqlParameter("@DataType", SqlDbType.VarChar, 3);
			p2.Value = DataType;
			cmd.Parameters.Add(p2);

			SqlParameter p3 = new SqlParameter("@TestRunID", SqlDbType.Int);
			p3.Value = TestRunID;
			cmd.Parameters.Add(p3);

			SqlParameter p4 = new SqlParameter("@DataValue", SqlDbType.Float);
			p4.Value = Value;
			cmd.Parameters.Add(p4);

			cmd.ExecuteNonQuery();
		}


		private static ArrayList GetCounterList(Int32 TestSuiteID, string DataSource)
		{			
			// returns an ArrayList of Counters to collect for this suite.
			ArrayList CounterList = new ArrayList();

            SqlConnection cn = new SqlConnection(string.Format(g_cnString, DataSource));
			cn.Open();

			SqlCommand cmd = new SqlCommand("GetCounters", cn);
			cmd.CommandType = CommandType.StoredProcedure;

			SqlParameter p1 = new SqlParameter("@TestSuiteID", SqlDbType.Int);
			p1.Value = TestSuiteID;
			cmd.Parameters.Add(p1);

			SqlDataReader dr = cmd.ExecuteReader();
			
			while (dr.Read())
			{
				PerformanceCounter p = new PerformanceCounter(dr.GetInt32(0), dr.GetString(1), dr.GetString(2));
				CounterList.Add(p);
			}
			cn.Close();

			return CounterList;
		}

		/*
		private blgAccess.customConfigClass GetCustomConfig( XmlNode ActionNode )
		{
			blgAccess.customConfigClass customConfig = new blgAccess.customConfigClass();
			blgAccess.customConfigClass.customFilterKeys customKey = blgAccess.customConfigClass.customFilterKeys.None;

			if( ActionNode != null )
			{
				foreach( XmlNode xmlNode in ActionNode.SelectNodes( "CustomQueryFilters/Filter" ) )
				{
					string key = xmlNode.Attributes.GetNamedItem( "nameKey" ).Value;
					string filter = xmlNode.InnerText;


					switch( key.ToLower() )
					{
							// Valid keys to date
						case "tps":
							customKey = blgAccess.customConfigClass.customFilterKeys.TPS;
							break;

						case "latency":
							customKey = blgAccess.customConfigClass.customFilterKeys.Latency;
							break;

						default:
							customKey = blgAccess.customConfigClass.customFilterKeys.None;
							break;
					}

					customConfig.Add( customKey, filter );

				}
			}

			return customConfig;
		}
		*/

		//Preserving legacy SendMail signature
		private void SendMail(string ToAlias, string Subject )
		{
			this.SendMail( ToAlias, Subject, String.Empty );
		}

		//New SendMail signature takes (message)Body which can be null
        private void SendMail(string ToAlias, string Subject, string Body)
        {
            myLog("Inside SendMail.");
            try
            {
                String from = this.TesterAlias + "@microsoft.com";
                String to = this.TesterAlias + "@microsoft.com";

                MailMessage oMsg = new MailMessage(from, to, Subject, Body);

                oMsg.Headers.Add("http://schemas.microsoft.com/cdo/configuration/smtpauthenticate", "2");

				// there should only be one log file.
                string[] files = System.IO.Directory.GetFiles(this.ArchiveLocation,"ANSLog*.txt");
                Attachment att = null;
				
				// attach the log if it exists.
				if (files.Length > 0)
				{
					att = new Attachment(files[0]);
					oMsg.Attachments.Add(att);
				}

				if( null != Body && Body != String.Empty )
				{
					oMsg.Body = Body;
				}

                System.Net.Mail.SmtpClient client = new SmtpClient("smpthost");
                client.Send(oMsg);
            }
            catch (Exception ex)
            {
                myLog("Failed to send email. " + ex.Message);
                throw new Exception("Failed to send email.",ex);
            }
            myLog("Leaving SendMail.");
            return;
        }


        private int RemoteExecute(string cmd)
        {
            myLog("Inside RemoteExecute.");
            // returns processID of remote process.
            myLog("Attempting Remote Execute " + cmd + " on " + this.m_MachineName);

            try
            {
				//const double CREATE_BREAKAWAY_FROM_JOB = 16777216;

				// Define the Connection Options
				ConnectionOptions options = new ConnectionOptions();
				options.Username = "Administrator";
				options.Password = this.m_Password;
				//options.Impersonation = ImpersonationLevel.Delegate;

				// Define the ManagementPath
				ManagementPath MgmtPath = new ManagementPath();
				MgmtPath.Path = "\\\\" + this.m_MachineName + "\\root\\cimv2";

				// Define the ManagementScope
				ManagementScope scope = new ManagementScope();
				scope.Path = MgmtPath;
				scope.Options = options;

				ManagementClass process = new ManagementClass("Win32_Process");
				process.Scope = scope; 

				ManagementBaseObject inParams = process.GetMethodParameters("Create");
				inParams.SetPropertyValue("CommandLine", cmd);
				//inParams.SetPropertyValue("CurrentDirectory", null);
				//inParams.SetPropertyValue("CreateFlags", CREATE_BREAKAWAY_FROM_JOB);

				ManagementBaseObject outParams = process.InvokeMethod("Create", inParams, null);

				int procID = Convert.ToInt32(outParams.GetPropertyValue("ProcessID").ToString());
				myLog(" - Command started successfully: " + cmd + "\r\nProcess started on box " + this.m_MachineName + "\r\nProcessID: " + procID.ToString());
				myLog("Leaving RemoteExecute.");
				return procID;
				//Debug.Assert(procID.CompareTo(Convert.ToUInt32(0)), "Remote ProcessID is not greater than 0.", "Something went wrong during remote execution.");
            }

            catch (System.UnauthorizedAccessException ex)
            {
                myLog("Error!!! Unable to execute command on " + this.m_MachineName + ". Unauthorized Access Exception.");
                myLog("Leaving RemoteExecute.");
                throw new Exception("Unauthorized Access Exception",ex);
            }

            catch (System.ExecutionEngineException ex)
            {
                myLog("Leaving RemoteExecute.");
                myLog("Error!!! System.ExecutionEngineException");
                throw new Exception("ExecutionEngineException",ex);
            }

            catch (Exception ex)
            {
                if (ex.Message == "Access is denied.")
                {
                    myLog("Invalid UserName or Password provided. Cannot connect to remote box.");
                    myLog("Leaving RemoteExecute.");
                    throw new Exception("Access is denied.",ex);
                }
                else
                {
                    myLog("Exception caught: " + ex.Message);
                    myLog("Leaving RemoteExecute.");
                    throw new Exception("Some unknown error when creating process.  Possibly bad command.",ex);
                }
            }
            //return 0;
        }

        private bool ProcessExists(int ProcessID)
        {
            // Define the Connection Options
            ConnectionOptions options = new ConnectionOptions();
            options.Username = "Administrator";
            options.Password = this.m_Password;

            //options.Impersonation = ImpersonationLevel.Delegate;

            ManagementPath MgmtPath = new ManagementPath();
            MgmtPath.Path = "\\\\" + this.m_MachineName + "\\root\\cimv2";

            ManagementScope scope = new ManagementScope();
            scope.Path = MgmtPath;
            scope.Options = options;

            //Request the collection of files on the d: drive
            string qry = "SELECT * FROM WIN32_Process WHERE ProcessID=" + ProcessID;
            //myLog(" - Query: " + qry);

            ManagementObjectSearcher s = new ManagementObjectSearcher(scope, new SelectQuery(qry));

            try
            {
                foreach (ManagementObject oProcess in s.Get())
                {
                    myLog("ProcessID: " + oProcess.GetPropertyValue("ProcessID"));
                    return true;
                }
            }
            catch (Exception e)
            {
                myLog("Caught Exception in ManagementObjectSearcher.Get, but safely ignoring. Assume Process Still exists.");
                myLog("Exception ToString: " + e.ToString());
                return true;
            }

            // If code gets here, then the process doesn't exist.
            return false;
        }

        private void ProfileWithLOP(string startStop)
        {
			string str="";
			ConnectionOptions oConn = new ConnectionOptions(); 
			oConn.Username = "administrator";
			oConn.Password = this.m_Password;

			ManagementPath MgmtPath = new ManagementPath();
			MgmtPath.Path = "\\\\" + this.m_MachineName + "\\root\\cimv2";

			ManagementScope scope = new ManagementScope();
			scope.Path = MgmtPath;
			scope.Options = oConn;

			//get Process objects 
			System.Management.ObjectQuery oQuery = new System.Management.ObjectQuery("Select * from Win32_Process"); 
			ManagementObjectSearcher oSearcher = new ManagementObjectSearcher(scope,oQuery); 

			//Get the results
			ManagementObjectCollection oReturnCollection = oSearcher.Get();
			foreach( ManagementObject oReturn in oReturnCollection ) 
			{ 
				//Name of process 
				if (!(oReturn["Name"].ToString().ToLower().Equals("w3wp.exe"))) continue;
				string[] o = new String[2];                 
				//Invoke the method and populate the o var with the user name and domain 
				oReturn.InvokeMethod("GetOwner",(object[])o); //this will get the user name
				if (o[0].ToLower().Equals("mpfclientacct"))
				{
					if (startStop.ToLower().Equals("start"))
					{
						str = @"cmd /c pushd C:\LOP1.1 & twexec.exe /attach " + oReturn["ProcessId"].ToString() + @" /output " + this.m_ScenarioName + ".lop";
						this.RunRemoteCmd(str, false, 0);
						myLog("Starting profiling with LOP...");
					}
					else
					{
						str = @"cmd /c pushd C:\LOP1.1 & twexec.exe /detach " + oReturn["ProcessId"].ToString();
						this.RunRemoteCmd(str, true, 5);
						myLog("Stopping profiling with LOP...");
					}
					return;
				}
			}
			myLog("Did not see any w3wp process with username=MPFClientAcct");
			return;
		}


        public static void myLog(string msg)
        {
            Trace.WriteLine(DateTime.Now.ToString("G") + " CAnsScenario: " + msg);
        }

		public static void myLog( MethodBase Method )
		{
			myLog( "Inside: " + Method.Name );
		}

		/*
        private void SetTargetMachine(XmlNode ActionNode)
        {
            if (ActionNode.Attributes.GetNamedItem("TargetMachine") != null)
            {
                myLog("Inside SetTargetMachine: setting TargetMachine to: " + ActionNode.Attributes.GetNamedItem("TargetMachine").Value.ToString());
                SetTargets(ActionNode.Attributes.GetNamedItem("TargetMachine").Value.ToString());
            }
            else
                SetTargets(this.m_MachineName[0]);
        }
		*/

		/*
        private void SetTargets(string targetName)
        {
            this.m_MachineName = targetName;
            int loc = GetLocation(targetName);
            if (loc < 0)
                myLog("setTargets: Problem with machine name - it has not been specified before!");
            else
                this.m_Password = this.m_Password[GetLocation(targetName)];
        }
		*/

		/*
        private int GetLocation(string targetName)
        {
            for (int i=0; i<this.m_NumMachines; i++)
                if (this.m_MachineName[i].Equals(targetName)) return i;
            return -1;
        }
		*/

		public string GetArchiveLocation
		{
			get{ return this.m_ArchiveLocation; }
		}

        private int CountScenarioFolders(string Name, string BuildNumber)
        {
            int count=0;
            string [] dirs = Directory.GetDirectories(@"\\glaive\sps\xr3\Stress\ANS");
            foreach(string dir in dirs)
            {
                string[] dir1 = dir.Split('_');
                if (String.Equals(BuildNumber,dir1[1]) && String.Equals(Name,dir1[2]))
                {
                    count++;
                    if (count >= 2) return count;
                }
            }
            return count;
        }

		private double obtainAcctNeeded()
		{
            SqlConnection cn = new SqlConnection(string.Format("server={0};database=PerformanceSummaries;User ID=PerfUser;Password=PerfUser", m_DataSource));
			cn.Open();
			double j=0;
			string[] releaseName = new string[2];
			releaseName[0] = this.m_Release;
			releaseName[1] = "SCS 4.0 (Upgrade) (W2K)";

			for (int i=0; i<=1; i++)
			{
				//If we have a max TPS number for this scenario in this release, use that (in first iteration of loop)
				// else proceed to use SCS 4.0 max TPS numbers for the scenario
				string query = "SELECT MAX(datavalue)AS dv FROM [Testresults] " +
					"INNER JOIN [Testruns] ON [Testresults].testrunid = [Testruns].testrunid " +
					"INNER JOIN [Testsuites] ON [Testruns].testsuiteid = [testsuites].testsuiteid WHERE " +
					"[Testsuites].release = '" + releaseName[i] + "' AND datatype='AVG' AND " +
					"performancecounterid = (SELECT performancecounterid FROM performancecounters WHERE " +
					"counterpath LIKE '\\Scenario Counters(" + this.m_ScenarioName + ")\\Success Rate')";
				SqlCommand testType = new SqlCommand(query, cn);
				SqlDataReader dr = testType.ExecuteReader();
				if (dr.Read())
					j = (dr.IsDBNull(0)) ? 0 : dr.GetDouble(0);
				dr.Close();
				if (j!=0) return j;
			}
			
			return 3.0; //if this is a new scenario, pick a dummy value
		}

		private void convertToXML(string fileName)
		{
			myLog("Inside convertToXML for file " + fileName);
			string evtle;
			if (!File.Exists(this.m_ArchiveLocation + @"\" + fileName))
			{
				myLog("File " + this.m_ArchiveLocation + @"\" + fileName + " does not exist... Returning from convertToXML");
				return;
			}
			StreamReader sr = new StreamReader(this.m_ArchiveLocation + @"\" + fileName); 
			StreamWriter sw = new StreamWriter(this.m_ArchiveLocation + @"\tmp" + fileName);
			while ((evtle = sr.ReadLine()) != null) 
			{
				evtle = evtle.Replace("&amp;lt;","<");
				evtle = evtle.Replace("&amp;gt;",">");
				evtle = evtle.Replace("&amp;","&");

				evtle = evtle.Replace("&lt;","<");
				evtle = evtle.Replace("&gt;",">");
				sw.WriteLine(evtle);
			}
			sr.Close();sw.Close();
			File.Copy(this.m_ArchiveLocation + @"\tmp" + fileName,this.m_ArchiveLocation + @"\" + fileName, true);
			File.Delete(this.m_ArchiveLocation + @"\tmp" + fileName);
			return;
		}

        public string Release
        {
            get { return this.m_Release; }
        }

		public string ServerName
		{
			get { return this.m_MachineName; }
		}

        public string BuildNumber
        {
            get { return this.m_BuildNumber; }
        }

        public string Product
        {
            get { return this.m_Product; }
        }

        public bool IsPerfTest
        {
            get { return this.m_IsPerfTest; }
        }

        public string TesterAlias
        {
            get { return this.m_TesterAlias; }
        }

        public Int32 SuiteID
        {
            get { return suite.SuiteID; }
        }

		public sspSuite Suite
		{
			get {return this.suite; }
		}

    }

	public class PerformanceCounter
	{

		private string perfCounterName;
		private Int32 perfCounterID;
		private string dataType;

		public PerformanceCounter(Int32 CounterID, string CounterName, string DataType)
		{
			this.perfCounterName = CounterName;
			this.perfCounterID = CounterID;
			this.dataType = DataType;
		}

		public string PerfCounterName
		{
			get
			{
				return this.perfCounterName;
			}
		}

		public Int32 PerfCounterID
		{
			get
			{
				return this.perfCounterID;
			}
		}

		public string DataType
		{
			get
			{
				return this.dataType;
			}
		}






	
	
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\BillingNotificationPoster\ClientTestScenarios.cs ===
using System;
using System.Collections.Generic;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.UserAccount;

namespace BillingNotifications
{
    public class ClientScenarios
    {
        // Populates notifications for the billing notification client tests.  The scenario number comes from the values in the client tests.
        public static void RunScenario(int scenario, ulong []puids)
        {
            if (scenario==0) //no notifications
            {
            }
            else if (scenario==1) //unread notification for subscription expiring in 30 days on user0
            {
                BillingNotificationHelpers.AddUserBillingNotificationSubscriptionExpire(puids[0], System.Guid.NewGuid(), System.DateTime.UtcNow, 0, System.DateTime.UtcNow+new System.TimeSpan(30, 0, 0, 0));
            }
            else if (scenario==2) //unread notification 3 days ago for subscription expiring 30 days ago on user0
            {
                BillingNotificationHelpers.AddUserBillingNotificationSubscriptionExpire(puids[0], System.Guid.NewGuid(), System.DateTime.UtcNow-new System.TimeSpan(3, 0, 0, 0), 0, System.DateTime.UtcNow-new System.TimeSpan(30, 0, 0, 0));
            }
            else if (scenario==3) //unread sub exp in 10 days on user0, nothing on user1, read sub exp on user2, unread sub exp in 5 days on user3
            {
                BillingNotificationHelpers.AddUserBillingNotificationSubscriptionExpire(puids[0], System.Guid.NewGuid(), System.DateTime.UtcNow, 0, System.DateTime.UtcNow+new System.TimeSpan(10, 0, 0, 0));
                BillingNotificationHelpers.AddUserBillingNotificationSubscriptionExpire(puids[2], System.Guid.NewGuid(), System.DateTime.UtcNow, 1, System.DateTime.UtcNow+new System.TimeSpan(15, 0, 0, 0));
                BillingNotificationHelpers.AddUserBillingNotificationSubscriptionExpire(puids[3], System.Guid.NewGuid(), System.DateTime.UtcNow, 0, System.DateTime.UtcNow+new System.TimeSpan(5, 0, 0, 0));
            }
            else if (scenario==4) //user0 has a cc decline with min values
            {
                BillingNotificationHelpers.AddUserBillingNotificationCCDecline(puids[0], System.Guid.NewGuid(), System.DateTime.UtcNow, 0, 0, 0000, 0);
                BillingNotificationHelpers.AddUserBillingNotificationCCDecline(puids[0], System.Guid.NewGuid(), System.DateTime.UtcNow, 0, 0, 0000, 0);
                BillingNotificationHelpers.AddUserBillingNotificationCCDecline(puids[0], System.Guid.NewGuid(), System.DateTime.UtcNow, 0, 0, 0000, 0);
            }
            else if (scenario==5) //user0 has a cc decline with max valid values
            {
                BillingNotificationHelpers.AddUserBillingNotificationCCDecline(puids[0], System.Guid.NewGuid(), System.DateTime.UtcNow, 0, 255, 9999, 255);
                BillingNotificationHelpers.AddUserBillingNotificationCCDecline(puids[0], System.Guid.NewGuid(), System.DateTime.UtcNow, 0, 255, 9999, 255);
                BillingNotificationHelpers.AddUserBillingNotificationCCDecline(puids[0], System.Guid.NewGuid(), System.DateTime.UtcNow, 0, 255, 9999, 255);
            }
            else if (scenario==6) //user0 has a cc decline with max invalid account last four
            {
                BillingNotificationHelpers.AddUserBillingNotificationCCDecline(puids[0], System.Guid.NewGuid(), System.DateTime.UtcNow, 0, 1, unchecked((short)65535), 2);
                BillingNotificationHelpers.AddUserBillingNotificationCCDecline(puids[0], System.Guid.NewGuid(), System.DateTime.UtcNow, 0, 1, unchecked((short)65535), 2);
                BillingNotificationHelpers.AddUserBillingNotificationCCDecline(puids[0], System.Guid.NewGuid(), System.DateTime.UtcNow, 0, 1, unchecked((short)65535), 2);
            }
            else if (scenario==7) //user0 has both a cc decline and a subscription expiration
            {
                BillingNotificationHelpers.AddUserBillingNotificationCCDecline(puids[0], System.Guid.NewGuid(), System.DateTime.UtcNow, 0, 1, 2345, 2);
                BillingNotificationHelpers.AddUserBillingNotificationCCDecline(puids[0], System.Guid.NewGuid(), System.DateTime.UtcNow, 0, 1, 2345, 2);
                BillingNotificationHelpers.AddUserBillingNotificationCCDecline(puids[0], System.Guid.NewGuid(), System.DateTime.UtcNow, 0, 1, 2345, 2);

                BillingNotificationHelpers.AddUserBillingNotificationSubscriptionExpire(puids[0], System.Guid.NewGuid(), System.DateTime.UtcNow, 0, System.DateTime.UtcNow+new System.TimeSpan(30, 0, 0, 0));
            }
            else if (scenario==8) //user0 has cc declines, but not enough to trigger a notification
            {
                BillingNotificationHelpers.AddUserBillingNotificationCCDecline(puids[0], System.Guid.NewGuid(), System.DateTime.UtcNow, 0, 0, 1234, 0);
            }
            else
            {
                Global.RO.Error("Unknown scenario case: "+scenario);
                return;
            }
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\BillingNotificationPoster\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\ANS\ANS\LogMan.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Diagnostics;

namespace Microsoft.XBoxLive.Test.ANS
{
    class LogMan
    {
        static string WORKINGDIR = Environment.ExpandEnvironmentVariables("C:\\windows\\system32");
        static string FILENAME = "logman.exe";

        public static void StartCounters(string MachineName, string LogName)
        {
            string args = "start -s " + MachineName + " -n " + LogName;
            CheckReturnVal(StartProcess(WORKINGDIR, FILENAME, args));            
        }

        public static Int32 StopCounters(string MachineName, string LogName)
        {
            string args = "stop -s " + MachineName + " -n " + LogName;
            Int32 returnVal = StartProcess(WORKINGDIR, FILENAME, args);
            return returnVal;
        }

        public static void DeployCounters(string MachineName, string CounterFile, string SampleRate, string LogName)
        {
            // first, delete any existing counter set with the same name.
            DeleteCounters(MachineName, LogName);

            string args = "create counter -s " + MachineName + " -cf " + CounterFile + " -si " + SampleRate + " -n " + LogName;
            CheckReturnVal(StartProcess(WORKINGDIR, FILENAME, args));
        }

        public static Int32 DeleteCounters(string MachineName, string LogName)
        { 
            // first, stop in case it is running.
            Int32 returnVal = StopCounters(MachineName, LogName);
            // ignore return value since the counter set may not exist.

            StartProcess("c:\\windows\\system32", "cmd.exe", "/C del \\\\" + MachineName + "\\c$\\PerfLogs\\Admin\\*.* /Q");

            string args = "delete -s " + MachineName + " -n " + LogName;
            returnVal = StartProcess(WORKINGDIR, FILENAME, args);
            return returnVal;
        }

        private static void CheckReturnVal(Int32 ReturnValue)
        {
            if (ReturnValue != 0)
            {
                throw new ApplicationException("LogMan command failed.  Check text above and stack to debug.");
            }
        }

        protected static Int32 StartProcess(String WorkingDir, String FileName, String Arguments)
        {
            Process MyProc = new Process();
            MyProc.StartInfo.WorkingDirectory = Environment.ExpandEnvironmentVariables(WorkingDir);
            MyProc.StartInfo.FileName = Environment.ExpandEnvironmentVariables(WorkingDir) + "\\" + FileName;
            MyProc.StartInfo.UseShellExecute = false;
            MyProc.StartInfo.RedirectStandardError = true;
            MyProc.StartInfo.RedirectStandardInput = true;
            MyProc.StartInfo.RedirectStandardOutput = true;
            MyProc.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;

            MyProc.StartInfo.Arguments = Arguments;

            MyProc.Start();
            String stdOut = MyProc.StandardOutput.ReadToEnd();
            String stdErr = MyProc.StandardError.ReadToEnd();
            MyProc.WaitForExit();
            Int32 exitCode = MyProc.ExitCode;
            MyProc.Close();
            Trace.WriteLine("Command line used:");
            Trace.WriteLine(Environment.ExpandEnvironmentVariables(WorkingDir) + "\\" + FileName + " " + Arguments);
            Trace.WriteLine("stdOut: " + stdOut);
            Trace.WriteLine("stdErr: " + stdErr);
            return exitCode;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\BillingNotificationPoster\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\BillingNotificationPoster\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_billingnotificationposter_none_12.4.56.0_none_9279babe053f99e4
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_billingnotificationposter_no-public-key_12.4.56.0_x-ww_97938bb6
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=billingnotificationposter
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_billingnotificationposter_no-public-key_12.4.56.0_x-ww_97938bb6
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_billingnotificationposter_no-public-key_12.4.56.0_x-ww_97938bb6.manifest
XP_MANIFEST_PATH=manifests\msil_billingnotificationposter_no-public-key_12.4.56.0_x-ww_97938bb6.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_billingnotificationposter_no-public-key_12.4.56.0_x-ww_97938bb6.cat
XP_CATALOG_PATH=manifests\msil_billingnotificationposter_no-public-key_12.4.56.0_x-ww_97938bb6.cat
XP_PAYLOAD_PATH=msil_billingnotificationposter_no-public-key_12.4.56.0_x-ww_97938bb6
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=billingnotificationposter,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\apscp2\Program.cs ===
using System;
using System.IO;

namespace scp2
{
    class Program
    {
        static int Main(string[] args)
        {


            if (args.Length < 8)
            {
                Console.WriteLine("This is a dummy scp2 replacement for testing APDispatcher with Xblob");
                Console.WriteLine(@"Refer to http://xblwiki/default.aspx/XboxLive/APDispatcher.html");
                return 1;
            }

            // Get the arguments
            String dstStr = args[7];
            string []parts = dstStr.Split(new char[] { '@', ':' });
            
            string server = parts[1];
            string dst = @"\\" + server + @"\ToolsMgmtUpload\" + parts[2] + @"\";

            string src = args[6];

            DirectoryInfo srcDir = new DirectoryInfo(src);
            string dstDir = dst + srcDir.Name;
            Directory.CreateDirectory(dstDir);

            String[] files = Directory.GetFiles(src);
            foreach (String f in files)
            {
                try
                {
                    FileInfo fi = new FileInfo(f);
                    File.Copy(f, dstDir + @"\" + fi.Name);
                }
                catch (Exception e)
                {
                    using (StreamWriter sw = new StreamWriter("scp2.err"))
                    {
                        sw.WriteLine(e.ToString());
                    }
                }
            }

            return 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\BulkConsoleIds\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\BulkConsoleIds\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\BulkAchievements\BulkAchievements.cs ===
//#define BULKACHIEVEMENTS_DEBUG

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;

using ServerTestFramework;
using ServerTestFramework.LiveService.Achievement;
using ServerTestFramework.Utilities.AsyncUtils;

namespace BulkAchievements
{
    class Program
    {
        /// <summary>
        /// Contains the information needed to give achievements.
        /// </summary>
        class Info
        {
            public ulong basePuid;
            public ulong count;
            public uint titleID;
            public ushort modVal;

            /// <summary>
            /// Sets the default values for the info.
            /// </summary>
            public Info ()
            {
                basePuid = 0;
                count = 0;
                titleID = 0;
                modVal = 1;
            }
        }

        /// <summary>
        /// The main entry point for BulkAchievements.
        /// </summary>
        /// <param name="args">The command line parameters.</param>
        static void Main (string[] args)
        {
#if BULKACHIEVEMENTS_DEBUG
            Console.WriteLine("DEBUG MODE :: NO ACHIEVEMENTS ADDED");
#endif
            Info info = new Info();
            uint threads = 10;

            // No arguments gives help text
            if (args.Length == 0)
            {
                PrintUsage();
                System.Environment.Exit(0);
            }

            // Process command line arguments
            for (int i = 0; i < args.Length; ++i)
            {
                if (args[i] == "-b")
                {
                    ++i;

                    try
                    {
                        if (args[i].StartsWith("0x"))
                        {
                            info.basePuid = ulong.Parse(args[i].Substring(2), NumberStyles.AllowHexSpecifier);
                        }
                        else
                        {
                            info.basePuid = ulong.Parse(args[i]);
                        }
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine("Error parsing base PUID: " + e.Message);
                        PrintUsage();
                        System.Environment.Exit(1);
                    }
                }
                else if (args[i] == "-c")
                {
                    try
                    {
                        info.count = ulong.Parse(args[++i]);
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine("Error parsing count: " + e.Message);
                        PrintUsage();
                        System.Environment.Exit(1);
                    }
                }
                else if (args[i] == "-t")
                {
                    ++i;

                    try
                    {
                        if (args[i].StartsWith("0x"))
                        {
                            info.titleID = uint.Parse(args[i].Substring(2), NumberStyles.AllowHexSpecifier);
                        }
                        else
                        {
                            info.titleID = uint.Parse(args[i]);
                        }
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine("Error parsing title ID: " + e.Message);
                        PrintUsage();
                        System.Environment.Exit(1);
                    }
                }
                else if (args[i] == "-m")
                {
                    try
                    {
                        info.modVal = ushort.Parse(args[++i]);

                        if (info.modVal > 150)
                        {
                            Console.WriteLine("Your modulus, {0}, will give some users more than 150 achievements.  This will most likely break.", info.modVal);
                        }
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine("Error parsing mod value: " + e.Message);
                        PrintUsage();
                        System.Environment.Exit(1);
                    }
                }
                else if (args[i] == "-h")
                {
                    try
                    {
                        threads = uint.Parse(args[++i]);
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine("Error parsing threads value: " + e.Message);
                        PrintUsage();
                        System.Environment.Exit(1);
                    }
                }
                else
                {
                    Console.WriteLine("Unknown flag: " + args[i]);
                    PrintUsage();
                    System.Environment.Exit(1);
                }
            }

            // Set up STF
            Global.Initialize("stf.xml");

            // Give our users their achievements, they've earned them
            DateTime startTime = DateTime.Now;

            ParallelRunner.Status status = ParallelRunner.RunAsync(SyncAch, (uint) info.count, threads, info);

            while (status.IsStillRunning)
            {
                System.Threading.Thread.Sleep(100);

                try
                {
                    if (status.NumberFinished != 0)
                    {
                        TimeSpan tempTime = DateTime.Now.Subtract(startTime);
                        double avgTime = tempTime.TotalSeconds / status.NumberFinished;
                        TimeSpan expected = TimeSpan.FromSeconds(avgTime * info.count);
                        Console.Write("{0:00.000} ms avg per; {1:00}:{2:00}:{3:00} total; {4:00}:{5:00}:{6:00} expected.   \r", 
                            avgTime * 1000, tempTime.Hours, tempTime.Minutes, tempTime.Seconds,
                            expected.Hours, expected.Minutes, expected.Seconds);
                    }
                }
                catch (Exception e)
                {
                    Console.WriteLine("Weird: " + e.Message);
                }
            }

            // Check for an error
            if (status.WasError)
            {
                Console.WriteLine("\nAn error occured: " + status.GetError.Message);
                System.Environment.Exit(1);
            }

            Console.WriteLine("\nDone adding achievements.");
        }

        /// <summary>
        /// Prints the usage information to the console.
        /// </summary>
        /// <param name="prog">The name of the program that is running.</param>
        private static void PrintUsage ()
        {
            Console.WriteLine("BulkAchievements usage:");
            Console.WriteLine("  Flags:");
            Console.WriteLine("    -b:  Base PUID");
            Console.WriteLine("    -c:  Count (users [base puid, base puid + count) will get achievements)");
            Console.WriteLine("    -t:  Title ID to give achievements for");
            Console.WriteLine("    -m:  Modulus (user 'x' will get the first 'x % modulus' achievements)");
            Console.WriteLine("    -h:  Maximum threads to run [default is 10]");
        }

        /// <summary>
        /// A function to sync the achievements
        /// </summary>
        /// <param name="i"></param>
        /// <param name="o"></param>
        private static void SyncAch (uint i, object o)
        {
#if BULKACHIEVEMENTS_DEBUG
            System.Threading.Thread.Sleep(8);
#else
            Info info = (Info) o;
            uint modded = (ushort) ((info.basePuid + i) % info.modVal);

            XRLSyncAchievements request = new XRLSyncAchievements();

            request.TitleId = info.titleID;
            request.UserId = info.basePuid + i;
            request.AchievementsLen = (ushort) modded;
            request.Achievements = new AchievementWD[modded];

            for (uint j = 0; j < modded; ++j)
            {
                request.Achievements[j] = new AchievementWD();
                request.Achievements[j].Achieved = DateTime.UtcNow.AddHours(-1);
                request.Achievements[j].AchievementId = j + 1;
                request.Achievements[j].Flags = 0x00020000;   // XACHIEVEMENT_DETAILS_ACHIEVED
            }
            
            SyncAchievementsResponse response = request.Execute();

            if (response.xResult != 0)
            {
                throw new Exception(String.Format("A SyncAchievements call got an xResult of [{0:X8}]", response.xResult));
            }
#endif
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\BulkConsoleIds\main.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;


using xonline.common.sql.webstore;
using xonline.common.config;
using Microsoft.Webstore.WstClient;

namespace BulkMachines
{
    class BulkMachines
    {
        static void Main(string[] args)
        {           
            int             count = 1;
            string          envName  = "xblob";
            HashSet<string> consoleIds = new HashSet<string>();

            // Route all reports form the root to debug output and consoleX
            ServerTestFramework.Report.GetRoot().AddReportDestination(new DebugOutputReportDestination());
            ServerTestFramework.Report.GetRoot().AddReportDestination(new ConsoleReportDestination());

            // Parse params
            for (int i = 0; i < args.Length; i++)
            {
                args[i] = args[i].ToLower();

                if (args[i].StartsWith("-") || args[i].StartsWith("/"))
                {
                    string command = args[i].Substring(1, args[i].Length-1);
                    string param = null;
                    if (i+1 < args.Length)
                    {
                        param = args[i+1];
                    }

                    // -f filename
                    if (command.ToLower() == "f" && param != null)
                    {
                        try
                        {
                            using (StreamReader sr = new StreamReader(param))
                            {
                                string line;

                                while ( (line = sr.ReadLine()) != null)
                                {
                                    line = line.ToLower();
                                    if (line.StartsWith("xe.") == false)
                                    {
                                        Console.WriteLine("{0}: Not a valid xenon console id", line);
                                    }
                                    if (consoleIds.Contains(line) == false)
                                    {
                                        consoleIds.Add(line);
                                    }
                                }
                            }
                        }
                        catch (Exception e)
                        {
                            Console.WriteLine("Exception while loading {0}", param);
                            Console.WriteLine("Exception: {0}", e.ToString() );
                            continue;
                        }
                        i++;  // consume param
                    }
                    // - env envName
                    else if (command.ToLower() == "env")
                    {
                        ++i;
                        envName = param;
                    }
                    else if (command.ToLower().StartsWith("c") && param != null)
                    {
                        ++i; // consume param
                        count = Int32.Parse(param);
                    }
                }
                else if (args[i].StartsWith("xe."))
                {
                    if (consoleIds.Contains(args[i]) == false)
                    {
                        consoleIds.Add(args[i]);
                    }
                }
                else
                {
                    Console.WriteLine("{0}: Not a valid xenon console id", args[i]);
                }
            }

            // Show commandline arguments
            if (consoleIds.Count == 0)
            {
                Console.WriteLine("Usage: BulkConsoleIds [-f <file>] [-env environment] <xe.consoleid>");
                Console.WriteLine("  -f: File with 1 console id per line.");
                Console.WriteLine("  -env: the name of the environment in stf.xml to run against.  Default is StressNet.");
                Console.WriteLine("");
                Console.WriteLine("    Simple example: bulkconsoleids -env stressnet xe.234611341184");
                return;
            }

            // Initialize the STF
            XmlDocument config = new XmlDataDocument();
            try
            {
                config.Load("stf.xml");
            }
            catch (System.IO.FileNotFoundException)
            {
                Console.WriteLine("Error: Unable to find config file \"stf.xml\" in the current directory.");
                return;
            }
            CoreGlobal.Initialize(config);

            bool found = false;
            foreach (EnvironmentSetting npdbSetting in Global.EnvironmentList)
            {
                if (npdbSetting.Environment.ToLower() == envName.ToLower())
                {
                    Global.CurrentEnvironment = npdbSetting;
                    found = true;
                }
            }
            if (!found)
            {
                Console.WriteLine("Error - unknown environment '{0}' specified (not in stf.xml?).", envName);
                return;
            }

            Global.ResetEnvironment();

            // Create machines
            foreach (string consoleId in consoleIds)
            {
                MachineEditor me = MachineEditor.CreateOrUseExistingName( consoleId, null);

                Console.WriteLine(
                    "{0} -> {1}", 
                    consoleId, 
                    me.Id.ToString("x")
                    );
                for (int i = 1; i < count; ++i)
                {
                    MachineEditor dupe = MachineEditor.CreateDuplicateXbox360( consoleId );
                    Console.WriteLine(
                        "{0} -> {1}", 
                        consoleId, 
                        dupe.Id.ToString("x")
                        );
                }
            }
            Global.RO.Info("Done.");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\BillingNotificationPoster\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_billingnotificationposter_none_12.4.56.0_none_9279babe053f99e4
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_billingnotificationposter_no-public-key_12.4.56.0_x-ww_97938bb6
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=billingnotificationposter
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_billingnotificationposter_no-public-key_12.4.56.0_x-ww_97938bb6
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_billingnotificationposter_no-public-key_12.4.56.0_x-ww_97938bb6.manifest
XP_MANIFEST_PATH=manifests\msil_billingnotificationposter_no-public-key_12.4.56.0_x-ww_97938bb6.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_billingnotificationposter_no-public-key_12.4.56.0_x-ww_97938bb6.cat
XP_CATALOG_PATH=manifests\msil_billingnotificationposter_no-public-key_12.4.56.0_x-ww_97938bb6.cat
XP_PAYLOAD_PATH=msil_billingnotificationposter_no-public-key_12.4.56.0_x-ww_97938bb6
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=billingnotificationposter,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\BulkFriends\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\BulkFriends\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\BulkFriends\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_bulkfriends_none_12.4.56.0_none_d246e1b287269eec
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_bulkfriends_no-public-key_12.4.56.0_x-ww_28e75cc6
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=bulkfriends
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_bulkfriends_no-public-key_12.4.56.0_x-ww_28e75cc6
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_bulkfriends_no-public-key_12.4.56.0_x-ww_28e75cc6.manifest
XP_MANIFEST_PATH=manifests\msil_bulkfriends_no-public-key_12.4.56.0_x-ww_28e75cc6.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_bulkfriends_no-public-key_12.4.56.0_x-ww_28e75cc6.cat
XP_CATALOG_PATH=manifests\msil_bulkfriends_no-public-key_12.4.56.0_x-ww_28e75cc6.cat
XP_PAYLOAD_PATH=msil_bulkfriends_no-public-key_12.4.56.0_x-ww_28e75cc6
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=bulkfriends,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\BulkFriends\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_bulkfriends_none_12.4.56.0_none_d246e1b287269eec
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_bulkfriends_no-public-key_12.4.56.0_x-ww_28e75cc6
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=bulkfriends
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_bulkfriends_no-public-key_12.4.56.0_x-ww_28e75cc6
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_bulkfriends_no-public-key_12.4.56.0_x-ww_28e75cc6.manifest
XP_MANIFEST_PATH=manifests\msil_bulkfriends_no-public-key_12.4.56.0_x-ww_28e75cc6.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_bulkfriends_no-public-key_12.4.56.0_x-ww_28e75cc6.cat
XP_CATALOG_PATH=manifests\msil_bulkfriends_no-public-key_12.4.56.0_x-ww_28e75cc6.cat
XP_PAYLOAD_PATH=msil_bulkfriends_no-public-key_12.4.56.0_x-ww_28e75cc6
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=bulkfriends,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\BulkFriends\main.cs ===
using System;
using System.Xml;
using System.ComponentModel;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities.AsyncUtils;
using ServerTestFramework.LiveService.Achievement;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.UserAccount;
using xonline.common.sql.webstore;

namespace BulkFriends
{
    class BulkFriends
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main(string[] args)
        {			
            // Parameters
             string  envName     = "FuncNet";


            // Route all reports form the root to debug output and consoleX
            ServerTestFramework.Report.GetRoot().AddReportDestination(new DebugOutputReportDestination());
            ServerTestFramework.Report.GetRoot().AddReportDestination(new ConsoleReportDestination());

            // Parse params

            if (args.Length != 3)
            {
                Usage();
                return;
            }

            string gamerTag = args[0];
            uint numOfFriends = 0;
            uint numOfRecentPlayers = 0;
            try
            {
                numOfFriends = Convert.ToUInt32(args[1], 10);
                numOfRecentPlayers = Convert.ToUInt32(args[2], 10);
            }
            catch
            {
                Usage();
                return;
            }
			
            //
            // Initialize the STF
            //

            XmlDocument config = new XmlDataDocument();
            try
            {
                config.Load("stf.xml");
            }
            catch (System.IO.FileNotFoundException)
            {
                Console.WriteLine("Error: Unable to find config file \"stf.xml\" in the current directory.");
                return;
            }
            CoreGlobal.Initialize(config);

            bool found = false;
            foreach (EnvironmentSetting npdbSetting in Global.EnvironmentList)
            {
                if (npdbSetting.Environment.ToLower() == envName.ToLower())
                {
                    Global.CurrentEnvironment = npdbSetting;
                    found = true;
                }
            }
            if (!found)
            {
                Console.WriteLine("Error - unknown environment '{0}' specified (not in stf.xml?).", envName);
                return;
            }

            Global.ResetEnvironment();

            // We need fakeSG for achievements stuff to work apparently.
            GlobalFakeSG.FakeSG = new FakeSGClient("FakeSGClient");
            if(!GlobalFakeSG.FakeSG.ConnectToService())
            {
                Console.WriteLine("Failed to connect to FakeSG Service... achievement setting will likely fail.");
            }
            else
            {
                GlobalFakeSG.FakeSG.SetStateEndpoint(Global.XEnv.GetVirtualInterface(xonline.common.config.VirtualInterface.xpnfd_presence).ToString());
            }

            //
            // retrieve users
            //
            Console.WriteLine("Retrieving {0} user in UODB with prefix...", gamerTag);

            ulong userMe = UodbWS.GetUserIDFromGamerTag(gamerTag);

            if (0 == userMe)
            {
                Console.WriteLine("User {0} does not exist.", gamerTag);
                return;
            }

            FriendsCommon fc = new FriendsCommon();
            UacsCommon uc = new UacsCommon();

            // Make some friends
            try
            {
                CPUIDList p = uc.CreatePrivateUsers("BF", (int)(numOfFriends + numOfRecentPlayers));
                for (uint i = 0; i < numOfFriends; i++)
                {
                    fc.MakeFriendFast(userMe, p[(int)i].Puid);
                }
                ulong[] affiliates = new ulong[numOfRecentPlayers];
                for (uint i = 0; i < numOfRecentPlayers; i++)
                {
                    affiliates[(int)i] = p[(int)(i + numOfFriends)].Puid;
                }
                AddAffiliates(userMe, affiliates, fc);
            }
            catch (Exception e)
            {
                Global.RO.Error("Error while making friends: " + e.Message);
            }
            Console.WriteLine("Done");

        }

        static public PNUser GetPNUser(ulong puid)
        {
            string gamerTag = UodbWS.GetGamertag(puid).Trim();
            if (gamerTag.Length > 0)
            {
                return new PNUser(gamerTag, puid);
            }
            else
            {
                return null;
            }
        }

        static public bool AddAffiliates(ulong userId, ulong[] affiliates, FriendsCommon fc)
        {
            const int c_maxUserInChuck = 16;
            uint titleId = 0xFFFF0072;
            uint flags = (uint)AffiliateFlags.CompletedGame;

            PNUser user = GetPNUser(userId);
            PNXbox x = new PNXbox(titleId, xonline.common.protocol.XboxVersion.FEB_2005_ALPHA_XEDK, true);

            fc.LogonUser(user, x);



            int affiliateLength = affiliates.Length;
            for (int index = 0; index < affiliateLength; index += c_maxUserInChuck)
            {
                int numberOfElementsToCopy = affiliateLength - index;
                numberOfElementsToCopy = numberOfElementsToCopy < c_maxUserInChuck ? numberOfElementsToCopy : c_maxUserInChuck;
                ulong[] affiliatesInChuck = new ulong[numberOfElementsToCopy];
                for (int j = 0; j < numberOfElementsToCopy; j++)
                {
                    affiliatesInChuck[j] = affiliates[index + j];
                }
                PMsgAddAffiliates req = new PMsgAddAffiliates(
                    user,
                    flags,
                    titleId,
                    affiliatesInChuck);
                req.TransactFD();
            }
            // add the calling user to affiliate list of the called user for complete game and encountered
            ulong[] userInArray = new ulong[] { userId };
            for (int i = 0; i < affiliateLength; i++)
            {
                PNUser newUser = GetPNUser(affiliates[i]);

                x = new PNXbox(titleId, xonline.common.protocol.XboxVersion.FEB_2005_ALPHA_XEDK, true);
                fc.LogonUser(newUser, x);

                PMsgAddAffiliates req = new PMsgAddAffiliates(
                    newUser,
                    flags,
                    titleId,
                    userInArray);
                req.TransactFD();
            }

            return true;
        }

        static private void Usage()
        {
            Console.WriteLine("Usage: BulkFriends gametag NumberOfFriends NumberOfRecentPlayers");
            Console.WriteLine("       example: bulkFriends MyGamerTag 100 50");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\BulkMachines\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\BulkMachines\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\BulkUser2WebUser\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\BulkMachines\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_bulkmachines_none_12.4.56.0_none_e5da6fa03ee34dae
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_bulkmachines_no-public-key_12.4.56.0_x-ww_d7bee2d4
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=bulkmachines
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_bulkmachines_no-public-key_12.4.56.0_x-ww_d7bee2d4
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_bulkmachines_no-public-key_12.4.56.0_x-ww_d7bee2d4.manifest
XP_MANIFEST_PATH=manifests\x86_bulkmachines_no-public-key_12.4.56.0_x-ww_d7bee2d4.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_bulkmachines_no-public-key_12.4.56.0_x-ww_d7bee2d4.cat
XP_CATALOG_PATH=manifests\x86_bulkmachines_no-public-key_12.4.56.0_x-ww_d7bee2d4.cat
XP_PAYLOAD_PATH=x86_bulkmachines_no-public-key_12.4.56.0_x-ww_d7bee2d4
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=bulkmachines,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\BulkMachines\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_bulkmachines_none_12.4.56.0_none_e5da6fa03ee34dae
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_bulkmachines_no-public-key_12.4.56.0_x-ww_d7bee2d4
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=bulkmachines
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_bulkmachines_no-public-key_12.4.56.0_x-ww_d7bee2d4
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_bulkmachines_no-public-key_12.4.56.0_x-ww_d7bee2d4.manifest
XP_MANIFEST_PATH=manifests\x86_bulkmachines_no-public-key_12.4.56.0_x-ww_d7bee2d4.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_bulkmachines_no-public-key_12.4.56.0_x-ww_d7bee2d4.cat
XP_CATALOG_PATH=manifests\x86_bulkmachines_no-public-key_12.4.56.0_x-ww_d7bee2d4.cat
XP_PAYLOAD_PATH=x86_bulkmachines_no-public-key_12.4.56.0_x-ww_d7bee2d4
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=bulkmachines,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\BulkMachines\main.cs ===
using System;
using System.Xml;
using System.ComponentModel;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities.AsyncUtils;

using xonline.common.sql.webstore;
using xonline.common.config;
using Microsoft.Webstore.WstClient;

namespace BulkMachines
{
    class BulkMachines
    {
        static MachineType machineType=MachineType.Xbox360;
        static string panoramaVoucher="PPPPP-BBBBB-UUUUU-LLLLL-KKKKK";
        static ulong panoramaVoucherOffer=0x585207D10FF00001;
        static int machineCount=0;
        static string outFilename="";

        static void Main(string[] args)
        {
            string envName="StressNet";

            // Route all reports form the root to debug output and consoleX
            ServerTestFramework.Report.GetRoot().AddReportDestination(new DebugOutputReportDestination());
            ServerTestFramework.Report.GetRoot().AddReportDestination(new ConsoleReportDestination());

            // Parse params
            for (int i=0; i<args.Length; ++i)
            {
                if (args[i].StartsWith("-") || args[i].StartsWith("/"))
                {
                    string command=args[i].Substring(1, args[i].Length-1);

                    string param=null;
                    if (i+1<args.Length)
                    {
                        param=args[i+1];
                    }

                    // -c nummachines
                    if (command.ToLower()=="c" && param!=null)
                    {
                        ++i;  // consume param
                        machineCount=(int)TypeDescriptor.GetConverter(machineCount).ConvertFromString(param);
                    }
                    // -p platform
                    else if (command.ToLower()=="p" && param!=null) // no param here
                    {
                        if (param=="xbox1") machineType=MachineType.Xbox1;
                        else if (param=="xbox360") machineType=MachineType.Xbox360;
                        else if (param=="pc") machineType=MachineType.PC;
                        else if (param=="phone") machineType=MachineType.Phone;
                        else throw new Exception("Invalid platform specified.");
                    }
                    // - env envName
                    else if (command.ToLower()=="env")
                    {
                        ++i;
                        envName=param;
                    }
                    // - outfile filename
                    else if (command.ToLower()=="outfile")
                    {
                        ++i;
                        outFilename = param;
                    }
                }
            }

            // Show commandline arguments
            if (machineCount<=0)
            {
                Global.RO.Info("Usage: BulkMachiness -c <num> [-env environment]");
                Global.RO.Info("  -c: number of machines to create.  This will be rounded to the nearest 100.");
                Global.RO.Info("  -p: name of the platform (xbox1, xbox360, pc, phone)");
                Global.RO.Info("  -env: the name of the environment in stf.xml to run against.  Default is StressNet.");
                Global.RO.Info("  -outfile: writes all of the individual machine puids to a text file");
                Global.RO.Info("");
                Global.RO.Info("    Simple example: bulkmachines -c 1000000 -p xbox360 -env stressnet");
                return;
            }

            // Initialize the STF
            XmlDocument config=new XmlDataDocument();
            try
            {
                config.Load("stf.xml");
            }
            catch (System.IO.FileNotFoundException)
            {
                Global.RO.Error("Error: Unable to find config file \"stf.xml\" in the current directory.");
                return;
            }
            CoreGlobal.Initialize(config);

            bool found=false;
            foreach (EnvironmentSetting npdbSetting in Global.EnvironmentList)
            {
                if (npdbSetting.Environment.ToLower()==envName.ToLower())
                {
                    Global.CurrentEnvironment=npdbSetting;
                    found=true;
                }
            }
            if (!found)
            {
                Global.RO.Error("Error - unknown environment '{0}' specified (not in stf.xml?).", envName);
                return;
            }

            Global.ResetEnvironment();

            Global.RO.Debug("MachineType: "+machineType);

            // Create the panorama voucher if needed
            if (machineType==MachineType.PC)
            {
                byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(panoramaVoucher);
                Global.RO.Debug(string.Format("Panorama Voucher: {0}, Hash=0x{1}, OfferId=0x{2:X16}", panoramaVoucher, Hexer.tohex(voucherHash), panoramaVoucherOffer));
                VoucherEditor.CreateOrUseExistingHash(voucherHash, panoramaVoucherOffer);
            }

            // Allocate a puid range to use
            ulong puidStart=MachineEditor.AllocateMachinePuid(machineType, (uint)machineCount);
            Global.RO.Debug("Puid range start: "+string.Format("0x{0:X16}", puidStart));
            Global.RO.Debug("Puid range length: "+machineCount);

            // Create machines
            Global.RO.Info("Beginning creation...", machineCount);

            EditorCommon.EnableCachingByDefaultForNewInstances=true; //allow the DB editors to cache per-instance data

            uint partitionCount=1;
            using (WSClient ws=new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                partitionCount=(uint)ws.PhysicalPartitions;
            }

            ParallelRunner.Run(MakeMachine, (uint)machineCount, partitionCount*2, puidStart);

            Global.RO.Info("Finished creation.", machineCount);
            Global.RO.Info("Puid range start: "+string.Format("0x{0:X16}", puidStart));
            Global.RO.Info("Puid range length: "+machineCount);

            // Write to file
            if (outFilename!=null && outFilename.Length>0)
            {
                Global.RO.Info("Writing all puids to file: "+outFilename+" ...");
                using (System.IO.FileStream fstream=new System.IO.FileStream(outFilename, System.IO.FileMode.Create))
                {
                    using (System.IO.StreamWriter fileWriter=new System.IO.StreamWriter(fstream))
                    {
                        for (ulong i=0; i<(ulong)machineCount; ++i)
                        {
                            ulong myPuid=puidStart+i;

                            fileWriter.Write(string.Format("0x{0:X16}", myPuid)+"\r\n");
                        }
                    }
                }
                Global.RO.Info("Finished writing: "+outFilename);
            }
        }

        //adds a machine
        static private void MakeMachine(uint num, object basePuidObject)
        {
            //progress
            if ((num%1000)==0)
            {
                Global.RO.Debug("Finished "+num+" of "+machineCount);
            }

            //do create
            ulong myPuid=(ulong)basePuidObject+num;

            for (int tryCount=0; tryCount<5; ++tryCount)
            {
                try
                {
                    MachineEditor.CreateOrUseExistingId(myPuid);
                }
                catch (System.Exception e)
                {
                    if (tryCount==4)
                    {
                        throw;
                    }
                    else
                    {
                        Global.RO.Warn("Machine creation for puid=0x"+string.Format("{0:X16}", myPuid)+" failed on try "+(tryCount+1)+" of 5: "+e.Message);
                        System.Threading.Thread.Sleep(5000);
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\BulkUsers\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\BulkUsers\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_bulkusers_none_12.4.56.0_none_27d3fb7122ea974f
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_bulkusers_no-public-key_12.4.56.0_x-ww_e4b2e339
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=bulkusers
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_bulkusers_no-public-key_12.4.56.0_x-ww_e4b2e339
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_bulkusers_no-public-key_12.4.56.0_x-ww_e4b2e339.manifest
XP_MANIFEST_PATH=manifests\msil_bulkusers_no-public-key_12.4.56.0_x-ww_e4b2e339.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_bulkusers_no-public-key_12.4.56.0_x-ww_e4b2e339.cat
XP_CATALOG_PATH=manifests\msil_bulkusers_no-public-key_12.4.56.0_x-ww_e4b2e339.cat
XP_PAYLOAD_PATH=msil_bulkusers_no-public-key_12.4.56.0_x-ww_e4b2e339
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=bulkusers,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\BulkUsers\main.cs ===
using System;
using System.Xml;
using System.ComponentModel;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities.AsyncUtils;
using ServerTestFramework.LiveService.Achievement;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using xonline.common.sql.webstore;

namespace BulkUsers
{
    class BulkUsers
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main(string[] args)
        {			
            // Parameters
            int     UserCount   = 0;
            byte[]  KEK         = null;
            int     KEKVersion  = 1;
            string  Prefix      = "BU";
            ulong   Offer       = 0xFFFE000080000008;   // 0xFFFE000080000008 is StarterKit12Month
            System.Guid OfferInstanceGuid = new System.Guid("8000000A-0067-4003-8000-0000FFFE07D1");
            System.Guid OfferGuid = new System.Guid("8000000A-0000-4000-8000-0000FFFE07D1");
            bool    Xenon       = false;
            uint    achievementCount   = 1;
            float   achievementChance  = 0.25f;
            uint    ACHIEVEMENT_TITLE  = 0xFFFF07A3;
            uint    friendsMin  = 0;
            uint    friendsMax  = 1;
            bool    billAccount = false;
            float   vbanChance  = 0.05f;
            string  envName     = "StressNet1";
            bool    rawKeyFromPuid=false;
            bool    partnerOptIn = false;


            // Route all reports form the root to debug output and consoleX
            ServerTestFramework.Report.GetRoot().AddReportDestination(new DebugOutputReportDestination());
            ServerTestFramework.Report.GetRoot().AddReportDestination(new ConsoleReportDestination());

            // Parse params
            for (int i = 0; i < args.Length; i++)
            {
                if (args[i].StartsWith("-") || args[i].StartsWith("/"))
                {
                    string command = args[i].Substring(1, args[i].Length-1);

                    string param = null;
                    if (i+1 < args.Length)
                    {
                        param = args[i+1];
                    }

                    // -c numusers
                    if (command.ToLower() == "c" && param != null)
                    {
                        i++;  // consume param
                        UserCount = (int)TypeDescriptor.GetConverter(UserCount).ConvertFromString(param);
                    }
                    // -p prefix
                    else if (command.ToLower() == "p" && param != null)
                    {
                        i++;  // consume param
                        Prefix = param;
                        if (Prefix.Length != 2)
                        {
                            Prefix = null;  // force help screen
                        }
                    }
                    // -o prefix
                    else if (command.ToLower() == "o" && param != null)
                    {
                        i++;  // consume param
                        int numbase = 10;
                        if (param.IndexOf("0x") != -1)
                        {
                            numbase = 16;
                        }
                        Offer = Convert.ToUInt64(param, numbase);
                    }
                    // -og prefix
                    else if (command.ToLower() == "og" && param != null)
                    {
                        i++;  // consume param
                        OfferGuid = new System.Guid(param);
                    }
                    // -oig prefix
                    else if (command.ToLower() == "oig" && param != null)
                    {
                        i++;  // consume param
                        OfferInstanceGuid = new System.Guid(param);
                    }
                    // -k key_encryption_key
                    else if (command.ToLower() == "k" && param != null)
                    {
                        i++; // consume param
                        KEK = Hexer.unhex(param);
                    }
                    // -x 
                    else if (command.ToLower() == "x") // no param here
                    {
                        Xenon = true;
            			Offer = 0xFFFE07D18000000A;   // 0xFFFE07D18000000A is Xbox360 Gold 12 month
                    }
                    // - achCount numachievements
                    else if (command.ToLower() == "achcount")
                    {
                        ++i;
                        achievementCount = uint.Parse(param);
                        if (achievementCount>30)
                        {
                            throw new System.Exception("Max achievements per user is 30.");
                        }
                    }
                    // - achChance chanceforachievements
                    else if (command.ToLower() == "achchance")
                    {
                        ++i;
                        achievementChance = float.Parse(param);
                        if (achievementChance<0)
                        {
                            throw new System.Exception("Achievement chance cannot be less than none.");
                        }
                        if (achievementChance>1)
                        {
                            throw new System.Exception("Achievement chance can't be more than always.");
                        }
                    }
                    // - frMin minfriends
                    else if (command.ToLower() == "frmin")
                    {
                        ++i;
                        friendsMin = uint.Parse(param);
                    }
                    // - frMax maxfriends
                    else if (command.ToLower() == "frmax")
                    {
                        ++i;
                        friendsMax = uint.Parse(param);
                        if (friendsMax<friendsMin)
                        {
                            throw new System.Exception("Max Friends may not be less than Min Friends.");
                        }
                        if (friendsMax>99)
                        {
                            throw new System.Exception("Max Friends may not be more than 99.");
                        }
                    }
                    // - b
                    else if (command.ToLower() == "b")
                    {
                        billAccount = true;
                    }
                    // - vbanChance voicebanchance
                    else if (command.ToLower() == "vbanchance")
                    {
                        ++i;
                        vbanChance = float.Parse(param);
                        if (vbanChance<0)
                        {
                            throw new System.Exception("Voiceban chance cannot be less than none.");
                        }
                        if (vbanChance>1)
                        {
                            throw new System.Exception("Voiceban chance can't be more than always.");
                        }
                    }
                    // - env envName
                    else if (command.ToLower() == "env")
                    {
                        ++i;
                        envName = param;
                    }
                    else if (command.ToLower()=="keyfrompuid")
                    {
                        rawKeyFromPuid=true;
                    }
                    else if (command.ToLower() == "optin")
                    {
                        partnerOptIn = true;
                    }

                }
            }

            // Show commandline arguments
            if (UserCount <= 0 || Prefix == null)
            {
                Console.WriteLine("Usage: BulkUsers -c <numusers> [-p prefix] [-o offer_id] [-k key_encryption_key]");
                Console.WriteLine("  -c: number of users to create. Required.");
                Console.WriteLine("  -p: 2 letter user prefix. Default is BU.");
                Console.WriteLine("  -o: hex offer id. Default is 0xFFFE000080000008.");
                Console.WriteLine("  -og: guid offer id. Default is 8000000A-0000-4000-8000-0000FFFE07D1.");
                Console.WriteLine("  -oig: guid instance offer id. Default is 8000000A-0067-4003-8000-0000FFFE07D1.");
                Console.WriteLine("  -k: hex key_encryption_key. A 32 byte (64 hex character) key. By default,");
                Console.WriteLine("      the proper key will be used if available on your machine. Don't use");
                Console.WriteLine("      this setting unless you REALLY know what you are doing.");
                Console.WriteLine("  -x: specify this flag to create Xenon users.");
                Console.WriteLine("  -achChance: the probability a user will be given achievements. Default is 0.5");
                Console.WriteLine("  -achCount: the number of achievements a user should be given. Default is 1");
                Console.WriteLine("  -frMin: the minimum number of friends each user will make. Default is 0");
                Console.WriteLine("  -frMax: the maximum number of friends each user will make. Default is 1");
                Console.WriteLine("  -b: if specified, the users will have a billing account associated with them");
                Console.WriteLine("  -vbanChance: the chance that a user will be voice-banned.  Default is 0.05");
                Console.WriteLine("  -env: the name of the environment in stf.xml to run against.  Default is StressNet1.");
                Console.WriteLine("  -keyfromname: generate raw user keys from gamertag instead of from puid");
                Console.WriteLine("  -optin: if specified, the users will have the partner Opt-In flag set to true");
                Console.WriteLine("");
                Console.WriteLine("    Simple example: bulkusers -c 1000000");
                Console.WriteLine("Not simple example: bulkusers -x -c 1000000 -p BU -o 0xFFFE07D18000000A -env QFENet");
                return;
            }

            //
            // Initialize the STF
            //

            XmlDocument config = new XmlDataDocument();
            try
            {
                config.Load("stf.xml");
            }
            catch (System.IO.FileNotFoundException)
            {
                Console.WriteLine("Error: Unable to find config file \"stf.xml\" in the current directory.");
                return;
            }
            CoreGlobal.Initialize(config);

            bool found = false;
            foreach (EnvironmentSetting npdbSetting in Global.EnvironmentList)
            {
                if (npdbSetting.Environment.ToLower() == envName.ToLower())
                {
                    Global.CurrentEnvironment = npdbSetting;
                    found = true;
                }
            }
            if (!found)
            {
                Console.WriteLine("Error - unknown environment '{0}' specified (not in stf.xml?).", envName);
                return;
            }

            Global.ResetEnvironment();

            // We need fakeSG for achievements stuff to work apparently.
            GlobalFakeSG.FakeSG = new FakeSGClient("FakeSGClient");
            if(!GlobalFakeSG.FakeSG.ConnectToService())
            {
                Console.WriteLine("Failed to connect to FakeSG Service... achievement setting will likely fail.");
            }
            else
            {
                GlobalFakeSG.FakeSG.SetStateEndpoint(Global.XEnv.GetVirtualInterface(xonline.common.config.VirtualInterface.xpnfd_presence).ToString());
            }

            //
            // Create users
            //
            Console.WriteLine("Creating {0} users in UODB with prefix {1}", UserCount, Prefix);

            BulkUserSet userSet = null;
            try
            {
                //use the environment's known key if it's not set, since nobody ever has the crypto stuff set up
                if (KEK == null)
                {
                    KEK = ServiceKeys.GetServiceKey(ServiceKeys.Key_KEK);
                }

                UodbWS.ReserveName_KEK = KEK;
                UodbWS.ReserveName_KEKVersion = KEKVersion;

                UodbWS.CreateBulkUsersExt(Prefix, (uint)UserCount, Offer, 103, Xenon, out userSet, !rawKeyFromPuid, partnerOptIn, OfferInstanceGuid, OfferGuid);
                Console.WriteLine("Done.");
            }
            finally
            {
                if (userSet != null)
                {
                    Console.WriteLine("BasePuid: 0x{0:x}, Count: {1}, Prefix: {2}, OfferId: {3:x}, OfferInstance: {4}, OfferGuid: {5}",
                        userSet.Base, userSet.Count, userSet.Prefix, userSet.OfferId, userSet.OfferInstanceIdGuid, userSet.OfferIdGuid);
                }
            }

            // Add "interesting" attributes to the users
            if (userSet != null)
            {
                // Add achievements
                try
                {
                    if (achievementChance>0 && achievementCount>0)
                    {
                        Global.RO.Info("Adding " + achievementCount + " achievements to " + (achievementChance*100.0f).ToString("f0") + "% of users...");

                        AddAchievementParamData passer=new AddAchievementParamData();
                        passer.BasePuid=userSet.Base;
                        passer.Chance=achievementChance;
                        passer.NumAchievements=achievementCount;
                        passer.Title=ACHIEVEMENT_TITLE;
                        passer.TotalUsers=userSet.Count;

                        ParallelRunner.Run(DoAddUserAchievement, userSet.Count, 8, passer, 0);
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("Error while adding achievement to users:\n" + e.Message);
                }

                // Make some friends
                try
                {
                    if (friendsMax>0)
                    {
                        Global.RO.Info("Giving each user between " + friendsMin + " and " + friendsMax + " friends...");
                        
                        FriendMakerParamData passer=new FriendMakerParamData();
                        passer.BasePuid=userSet.Base;
                        passer.TotalUsers=userSet.Count;
                        passer.Min=friendsMin;
                        passer.Max=friendsMax;

                        ParallelRunner.Run(DoMakeUserFriends, userSet.Count, 8, passer, 0);
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("Error while making friends: " + e.Message);
                }

                // Voice ban some users
                try
                {
                    if (vbanChance>0)
                    {
                        Global.RO.Info("Voice banning " + (vbanChance*100.0f).ToString("f0") + "% of users...");

                        VoiceBanParamData passer=new VoiceBanParamData();
                        passer.BasePuid=userSet.Base;
                        passer.TotalUsers=userSet.Count;
                        passer.Chance=vbanChance;

                        ParallelRunner.Run(DoVoiceBanUser, userSet.Count, 8, passer, 0);
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("Error while voice banning: " + e.Message);
                }

                // Setup billing accounts
                if (billAccount)
                {
                    Global.RO.Warn("\nTODO: -b not yet implemented\n");
                }
            }

            // Finally at the end, re-spit out the user range info
            if (userSet != null)
            {
                Console.WriteLine("\nUsers:");
                Console.WriteLine("BasePuid: 0x{0:x}, Count: {1}, Prefix: {2}, OfferId: {3:x}, OfferInstance: {4}, OfferGuid: {5}", userSet.Base, userSet.Count, userSet.Prefix, userSet.OfferId, userSet.OfferInstanceIdGuid, userSet.OfferIdGuid);
            }
        }

        // Add's a set of achievements to a user
        private class AddAchievementParamData
        {
            public ulong BasePuid;
            public float Chance;
            public uint NumAchievements;
            public uint Title;
            public uint TotalUsers;
        }
        static private void DoAddUserAchievement(uint num, object obj) //obj is AddAchievementParamData
        {
            // Output status every 2000
            AddAchievementParamData passer=(AddAchievementParamData)obj;
            if (num%2000==1999)
            {
                Global.RO.Info("Achievement progress: " + (num+1) + " of " + passer.TotalUsers);
            }

            // Don't do it based on deterministic chance
            if (((num*23)%100)/100.0f>passer.Chance)
            {
                return;
            }

            //
            XRLSyncAchievements request = new XRLSyncAchievements();

            request.TitleId = passer.Title;
            request.UserId = passer.BasePuid + num;
            request.AchievementsLen = (ushort)passer.NumAchievements;
            request.Achievements = new AchievementWD[request.AchievementsLen];

            for (uint i=0; i<request.AchievementsLen; ++i)
            {
                request.Achievements[i] = new AchievementWD();
                request.Achievements[i].Achieved = DateTime.UtcNow.AddHours(-1);
                request.Achievements[i].AchievementId = i+1;
                request.Achievements[i].Flags = 0x00020000;   // XACHIEVEMENT_DETAILS_ACHIEVED
            }
            
            SyncAchievementsResponse response = request.Execute();

            if (response.xResult != 0)
            {
                throw new Exception(String.Format("A SyncAchievements call got an xResult of [{0:X8}]", response.xResult));
            }
        }

        // Makes a set of friends for a user
        private class FriendMakerParamData
        {
            public ulong BasePuid;
            public uint TotalUsers;
            public uint Min;
            public uint Max;
        }
        static private void DoMakeUserFriends(uint num, object obj) //obj is FriendMakerParamData
        {
            // Output status every 2000
            FriendMakerParamData passer=(FriendMakerParamData)obj;
            if (num%2000==1999)
            {
                Global.RO.Info("Friend progress: " + (num+1) + " of " + passer.TotalUsers);
            }

            // Decide how many friends we will make
            uint numFriends=passer.Min;
            if (passer.Max-passer.Min>0)
            {
                numFriends+=(num*59)%(passer.Max-passer.Min+1);
            }
            if (numFriends==0)
            {
                return;
            }

            // Make friends with random other users
            FriendsCommon fc=new FriendsCommon();

            ulong userMe=passer.BasePuid+num;

            for (uint count=0; count<numFriends; ++count)
            {
                uint friendNum=(num*8191 + count*131071)%passer.TotalUsers;
                if (num==friendNum)
                {
                    continue;
                }

                ulong userThem=passer.BasePuid+friendNum;

                // Friend them up.  This is a non-vital and just to make the users more interesting, so ignore failures.
                try
                {
                    fc.MakeFriendFast(userMe, userThem);
                }
                catch (Exception e)
                {
                    // If it's a failure because they're already our friend or our list is full, ignore it; else warn about it.
                    bool showWarn=true;

                    if (e.Message.Contains("Violation of PRIMARY KEY constraint"))
                    {
                        showWarn=false;
                    }
                    if (e.Message.Contains("_LIST_FULL"))
                    {
                        showWarn=false;
                    }
                    
                    if (showWarn)
                    {
                        Global.RO.Warn("MakeFriendFast failed(ignoring) between users " + userMe + " and " + userThem +": " + e.Message);
                    }
                }
            }
        }

        // Voice bans a user
        private class VoiceBanParamData
        {
            public ulong BasePuid;
            public uint TotalUsers;
            public float Chance;
        }
        static private void DoVoiceBanUser(uint num, object obj) //obj is VoiceBanParamData
        {
            // Output status every 5000
            VoiceBanParamData passer=(VoiceBanParamData)obj;
            if (num%5000==4999)
            {
                Global.RO.Info("Voiceban progress: " + (num+1) + " of " + passer.TotalUsers);
            }

            // Don't do it based on deterministic chance
            if (((num*29)%100)/100.0f>passer.Chance)
            {
                return;
            }

            // Update uodb's user for the voice resume and voice ban length
            ulong puid=passer.BasePuid+num;

            WSClient ws = new WSClient(xonline.common.config.ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE);
            ws.PartitionType = Microsoft.Webstore.WstClient.WstPartitionType.Logical;
            ws.SetHashVal(puid);

            ws.CommandSql = "UPDATE dbo.t_users SET dt_voice_resume_date=DATEADD(day, 60, getdate()), i_voice_ban_length=60 WHERE bi_user_puid="+puid;

            ws.Execute();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\BulkUser2WebUser\TitleSet.cs ===
using System;
using System.Collections;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Achievement;
using ServerTestFramework.LiveService.UserSettings;

namespace BulkUserSyncSettings
{
	/// <summary>
	/// Summary description for TitleSet.
	/// </summary>
	public class TitleSet
	{
		#region // I N N E R   C L A S S E S //////////////////////////////////////////
		public struct _Title
		{
			public uint TitleID;
			public AchievementWD [] Achievements;
		}
		#endregion

		#region // P R I V A T E   M E M B E R S //////////////////////////////////////
		private _Title [] _Titles;
		private const int _kLocale = 1033;
		private const int _kMaxAchievementsPerTitle = 100;
		#endregion 

		#region // P R I V A T E   M E T H O D S //////////////////////////////////////
		private int [] _GetIndiciesForUser (uint uUserIndex, int nMaxIndex)
		{
			lock (this)
			{
				// Create a new Random number generator using the user index as the seed,
				// this will assure that every random number we ask for will always be
				// the same for this user
				Random rnd = new Random ((int)uUserIndex);

				// Figure out how many indicies the user has
				int nNumIndicesForUser = rnd.Next (nMaxIndex);

				// Very good, now what titles does he have?
				ArrayList rgIndices = new ArrayList (nNumIndicesForUser);
				for (int nTitle = 0; nTitle < nNumIndicesForUser; nTitle++)
					rgIndices.Add (rnd.Next (nMaxIndex));

				// Done
				return (int[])rgIndices.ToArray (typeof (int));
			}
		}

		private static AchievementWD [] _GetAchievementsForTitle (uint uTitleID, ulong uUserPuid)
		{
			// Get the list of available achievements for the title.  We don't
			// care if the user has achieved them or not, he's just a dummy to
			// let us get a list of the achievements
			XRLEnumAchievement xrlRequest = new XRLEnumAchievement (uTitleID, uUserPuid, uUserPuid, _kLocale, 0, _kMaxAchievementsPerTitle);
			AchievementEnumResponse respAchievements = xrlRequest.Execute ();

			// Create an array of Achievement IDs
			if (0 == respAchievements.xResult)
			{
				return respAchievements.Achievements;
			}

			// Done
			return new AchievementWD []{};
		}

		#endregion

		#region // P U B L I C   M E T H O D S ////////////////////////////////////////
		public TitleSet(_Title [] theTitles)
		{
			_Titles = theTitles;
		}

		/// <summary>
		/// Returns an array of indices of the titles that a particular user has
		/// </summary>
		/// <param name="nUserIndex">The user's BulkUserSet index</param>
		/// <returns>Array of title indices</returns>
		public int [] GetTitlesForUser (uint uUserIndex)
		{
			return _GetIndiciesForUser (uUserIndex, _Titles.Length);
		}

		/// <summary>
		/// Returns an array of indices of the achievements for a particular 
		/// title that a particular user has.
		/// </summary>
		/// <param name="nUserIndex">The user's BulkUserSet index</param>
		/// <returns>Array of achivement indices</returns>
		public int [] GetAchievementsForUserForTitle (uint uUserIndex, int nTitleIdx)
		{
			// Get the number of achievements in that particular title
			int nNumAchievements = _Titles[nTitleIdx].Achievements.Length;
			return _GetIndiciesForUser (uUserIndex, nNumAchievements);
		}

		#endregion

		#region // P U B L I C   S T A T I C   M E T H O D S //////////////////////////
		/// <summary>
		/// Creates a new TitleSet based on title information in an XML file
		/// </summary>
		/// <param name="sFilename">XML file name</param>
		/// <param name="uUserPuid">Moronic parameter.  It seems we can't actually
		/// enumerate achievements unless we specify a user.  Swell.</param>
		/// <returns>A freshly created TitleSet</returns>
		public static TitleSet CreateTitleSetFromXML (string sFilename, ulong uUserPuid)
		{
			// Read in the XML file
			XmlDocument xmlConfig = new XmlDocument ();
			xmlConfig.Load (sFilename);

			// Read in all the culture nodes
			XmlNodeList nodeList;
			XmlElement xmlRoot = xmlConfig.DocumentElement;
			nodeList = xmlRoot.SelectNodes ("/config/titles/title");

			// Parse each node
			ArrayList theTitles = new ArrayList (nodeList.Count);
			foreach (XmlNode xml in nodeList)
			{
				TitleSet._Title aTitle = new TitleSet._Title ();

				// Read in the title ID
				aTitle.TitleID = UInt32.Parse (xml.Attributes.GetNamedItem ("id").Value, System.Globalization.NumberStyles.HexNumber);

				// Enumerate all the achievements for this title
				aTitle.Achievements = _GetAchievementsForTitle (aTitle.TitleID, uUserPuid);

				// Add the title to the set
				theTitles.Add (aTitle);
			}

			// Done
			return new TitleSet ((TitleSet._Title [])theTitles.ToArray (typeof (TitleSet._Title)));
		}

		public int AssignAchievementsToUser (uint uUserIndex, ulong uUserPuid)
		{
			// Get the user's list of titles
			int [] rgTitles = GetTitlesForUser (uUserIndex);

			// Add achievements for each titles.  Why not use a for loop since I
			// still need a running count of order of the title in the array?
			// Basically because I don't want to write:
			// _Titles[rgTitles[nIdx]] all opver the place.
			// Yes yes, I could always do:
			// nTitleIdx = rgTitles[nIdx] and then do _Titles[nTitleIdx]
			// but I don't want to ok?
			bool bSuccess = true;
			uint uSequenceNumber = 0;
			int nTotalScore = 0;
			foreach (int nTitleIdx in rgTitles)
			{
				int nScoreForGame = 0;
				// Get the user's achievements for this title
				int [] rgAchievements = this.GetAchievementsForUserForTitle (uUserIndex, nTitleIdx);

				// Figure out the player's score for this title
				foreach (int nAchIdx in rgAchievements)
					nScoreForGame += _Titles[nTitleIdx].Achievements[nAchIdx].Cred;

				// Add each achievement to the user
				if ((bSuccess = _AddAchievementToUser (uUserPuid, _Titles[nTitleIdx].TitleID, _Titles[nTitleIdx].Achievements, rgAchievements)) == false)
					break;

				// Mark the user as having played this title
				if ((bSuccess = _UserPlayedGame (uUserPuid, 
									 			 _Titles[nTitleIdx].TitleID, 
												 (uint)nScoreForGame, 
												 (ushort)rgAchievements.Length,
												 (ushort)TitleSet._kLocale,
												 uSequenceNumber)) == false)
					break;

				uSequenceNumber++;
				nTotalScore += nScoreForGame;
			}
			
			// Done
			return nTotalScore;
		}

		private bool _AddAchievementToUser (ulong uUserPuid, uint uTitleID, AchievementWD [] rgAchievements, int [] rgAchIndices)
		{
			// Make a copy of the achievements and mark them as achieved
			const int XACHIEVEMENT_DETAILS_ACHIEVED_ONLINE = 0x00010000;
			AchievementWD [] newAchievements = new AchievementWD[rgAchIndices.Length];
			for (int nIndex = 0; nIndex < rgAchIndices.Length; nIndex++)
			{
				int nAchIndex = rgAchIndices[nIndex];
				// Populate the achievements data
				AchievementWD theAchievement = rgAchievements[nAchIndex];
				newAchievements[nIndex] = new AchievementWD (theAchievement.AchievementId, (uint)nAchIndex);
				newAchievements[nIndex].Type = theAchievement.Type;
				newAchievements[nIndex].Flags= theAchievement.Flags | XACHIEVEMENT_DETAILS_ACHIEVED_ONLINE;
				newAchievements[nIndex].Achieved = DateTime.UtcNow;
			}

			// Send the request
			XRLSyncAchievements xrlRequest = new XRLSyncAchievements(uTitleID, uUserPuid, newAchievements, DateTime.UtcNow);
			SyncAchievementsResponse response = xrlRequest.Execute();
			return (0 == response.xResult);
		}

		private bool _UserPlayedGame(ulong uUserPuid, uint uTitleID, uint uTotalCred, ushort uTotalAch, ushort uLocaleID, uint uSequenceNumber)
		{
			// Create a new title for the user to have played
			UserTitle[] TitlePlayed = new ServerTestFramework.LiveService.UserSettings.UserTitle[]
			{
				new ServerTestFramework.LiveService.UserSettings.UserTitle (uTitleID, System.DateTime.UtcNow, uTotalCred, uTotalAch, uSequenceNumber)
			};

			// Send in the request
			SyncTitlesRequest request = new SyncTitlesRequest(uUserPuid, uLocaleID, System.DateTime.UtcNow, TitlePlayed);
			SyncTitlesResponse response = request.Execute();
			return (response.XError == 0);
		}


		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\BulkUsers\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_bulkusers_none_12.4.56.0_none_27d3fb7122ea974f
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_bulkusers_no-public-key_12.4.56.0_x-ww_e4b2e339
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=bulkusers
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_bulkusers_no-public-key_12.4.56.0_x-ww_e4b2e339
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_bulkusers_no-public-key_12.4.56.0_x-ww_e4b2e339.manifest
XP_MANIFEST_PATH=manifests\msil_bulkusers_no-public-key_12.4.56.0_x-ww_e4b2e339.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_bulkusers_no-public-key_12.4.56.0_x-ww_e4b2e339.cat
XP_CATALOG_PATH=manifests\msil_bulkusers_no-public-key_12.4.56.0_x-ww_e4b2e339.cat
XP_PAYLOAD_PATH=msil_bulkusers_no-public-key_12.4.56.0_x-ww_e4b2e339
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=bulkusers,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\BulkUsers\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\BulkUser2WebUser\Class1.cs ===
using System;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Feedback;
using ServerTestFramework.LiveService.UserAccount;
//using ServerTestFramework.LiveService.UserSettings;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.common.service;
using xonline.common.diagnostics;
using xonline.common.protocol;

using xonline.common.mgmt;
using xonline.common.sql.sqlclient;
using xonline.common.xboxcom;

namespace BulkUserSyncSettings
{
	public enum StatsProfileSetting
	{
		//Gamer profile
		GamercardZone = 268697604,
		GamercardTile = 1080295439,
		GamercardMotto = 1076625425,
		GamercardRep = 1342439435,
		GamercardCred = 268697606,

		GamerTier = 268697658,
		GamerType = 268697601,
		GamerCountry = 268697605
	}

	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	class BulkUserSyncSettings
	{

		public enum GamercardZones : int
		{
			RR = 1,
			Pro,
			Family,
			Underground,
			NumZones = Underground
		}


		static private BulkUserSet _Users;
		static private TitleSet _TitleSet;
		static private string _BaseGamerTile;
		static private int _TileID;
		static private uint _NumTiles;
		static private string _UserPrefix;
		static private ulong _BaseUser;
		static private uint _NumUsers;

        static private bool _bSyncSettings = false;
        static private bool _bUpdateXboxComActivity = false;
        static private bool _bAchievements = false;

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{
			if (args.Length < 2 || (args[0].IndexOf ("?") > -1))
			{
				Console.WriteLine ("Usage: BulkUserSyncSettings <stf???.xml> <config.xml>");
                Console.WriteLine("Optional:");
                Console.WriteLine("\t-sync: call SyncSettings for every user");
                Console.WriteLine("\t-update: update Xbox.com activity for every user");
                Console.WriteLine("\t-titles: adds titles and achievements to every user");

				return;
			}
			try
			{
				InitializerInfo ii = new InitializerInfo ();
				ii.UseUodb = true;
				ii.UseFakeSG = true;
				ServerTestFramework.STF.Initialize (ii, args[0]);
				_ReadSettings (args[1]);
				_DoWork ();
			}
			catch (Exception x)
			{
				Console.WriteLine ("Aborting! " + x.Message);
			}
		}

		static private void _ReadSettings (string sFilename)
		{
			// Read in the config file
			XmlConfigFile Config = new XmlConfigFile (sFilename);

			// Read the base tile id, then we strip off the last 4 digits.  This is so we can then
			// increment it to get other tiles
			_BaseGamerTile = Config["/BaseTile"];
			_TileID = int.Parse (_BaseGamerTile.Substring (_BaseGamerTile.Length - 4, 4));
			_BaseGamerTile = _BaseGamerTile.Substring (0, _BaseGamerTile.Length - 4);
			_NumTiles = uint.Parse (Config["/NumTiles"]);

			// Read in the Bulk User info
			_BaseUser = UInt64.Parse (Config["/BaseUser"]);
			_NumUsers = UInt32.Parse (Config["/UserCount"]);
			_UserPrefix = Config["/UserPrefix"];

			// Set up the Bulk Users
			_Users = new BulkUserSet (_UserPrefix);
			_Users.Base = _BaseUser;
			_Users.Count = _NumUsers;

			// Set up the TitleSet
			_TitleSet = TitleSet.CreateTitleSetFromXML (sFilename, _Users.IndexToPuid(0));

            // Read the command line for options
            _bSyncSettings = Environment.CommandLine.IndexOf("-sync") > -1;
            _bUpdateXboxComActivity = Environment.CommandLine.IndexOf("-update") > -1;
            _bAchievements = Environment.CommandLine.IndexOf("-titles") > -1;
        }

		static private void _DoWork ()
		{
			// Let's create 10 threads for each 100,000 users
			//			uint nNumThreads = _NumUsers / 100000;
			uint nNumThreads = 4;
		
			// If the number of users is not divisible by 100,000, add an
			// extra thread to pick up the slack
			nNumThreads += (uint) (((_NumUsers % 100000) == 0) ? 0 : 1);

			// Used by the thread to select the next user index
			SafeCounter Counter = new SafeCounter ();
			ManualResetEvent StopEvent = new ManualResetEvent (false);

			// Set up the threads and fire them up
			Console.WriteLine ("Creating {0} thread(s) to sync {1} user(s)", nNumThreads, _NumUsers);
			SyncSettingThread [] theThreads = new SyncSettingThread[nNumThreads];
			for (int nThread = 0; nThread < nNumThreads; nThread++)
			{
				theThreads[nThread] = new SyncSettingThread (_Users, _TitleSet, Counter, StopEvent, 
                                                            _bSyncSettings,
                                                            _bUpdateXboxComActivity,
                                                            _bAchievements);
				theThreads[nThread].Go ();
			}

			// Monitor the threads and report on the progress of the operation
			// Blatantly ripped off from CreateBulkUsers
			const uint REPORT_INTERVAL = 10;
			uint lastSyncd    = 0;
			uint syncd        = 0;
			DateTime started    = DateTime.Now;
			DateTime lastReport = DateTime.Now;
			DateTime reportAt   = DateTime.Now.AddSeconds(REPORT_INTERVAL);
			TimeSpan elapsed;
			TimeSpan totalElapsed;

			while(!StopEvent.WaitOne(0, false) && (uint)Counter.Value < _NumUsers + nNumThreads)
			{
				if(DateTime.Now > reportAt)
				{
					syncd      = (uint)Counter.Value - lastSyncd;
					lastSyncd  = (uint)Counter.Value;
					reportAt     = DateTime.Now.AddSeconds(REPORT_INTERVAL);
					elapsed      = DateTime.Now - lastReport;
					totalElapsed = DateTime.Now - started;
					lastReport   = DateTime.Now;

					Console.WriteLine ("Sync'd: {0}, rate {1}/s, elapsed: {2}", 
						Counter.Value, 
						(float)syncd / ((float)elapsed.TotalSeconds + 0.0001f),
						totalElapsed.ToString());
				}
				Thread.Sleep(250);
			}

			// Count users actually syncd
			uint totalUsersSyncd = 0;
			for(int nThread = 0; nThread < theThreads.Length; ++nThread)
			{
				totalUsersSyncd += theThreads[nThread]._UsersSyncd;
			}
            
			totalElapsed = DateTime.Now - started;
			Console.WriteLine ("Finished calling SyncSettings on {0} out of {1}, avg.rate: {2}/s, elapsed: {3}", 
				totalUsersSyncd,
				_Users.Count,
				(float)Counter.Value / (totalElapsed.TotalSeconds + 0.0001f),
				totalElapsed.ToString());
		}

		class SyncSettingThread : ThreadBase 
		{
			public BulkUserSet      _UserSet;
			public TitleSet			_TitleSet;
			public SafeCounter      _Counter;
			public ManualResetEvent _StopEvent;
			public uint				_UsersSyncd;
            private bool            _bSyncSettings;
            private bool            _bUpdateXboxComActivity;
            private bool            _bAchievments;

			static private UserSetting[] _SetupSyncSettings (string sGamertag, ulong uPuid, string sGamerTile, uint nGamerZone, int nScore)
			{
				UserSettingBuilder usb = new UserSettingBuilder (uPuid);
				usb.AddIntSetting (StatsProfileSetting.GamercardZone, (int)nGamerZone);
				usb.AddStringSetting (StatsProfileSetting.GamercardMotto, sGamertag);
				usb.AddStringSetting (StatsProfileSetting.GamercardTile, sGamerTile);
//				usb.AddIntSetting (StatsProfileSetting.GamercardCred, nScore);

				return usb.ToUserSettingArray ();
			}
		
			static private SyncSettingsResponse _SyncSettings (ulong callingLivepuid, UserSetting[] settings)
			{   
				const uint TITLE_ID = XOn.WEB_TITLE_ID;
               
				if (settings == null)
				{
					throw new ArgumentNullException("settings");
				}

				if (settings.Length == 0)
				{
					// not asking for anything. Mock up an empty response
					SyncSettingsResponse emptySyncResp = new SyncSettingsResponse();
					emptySyncResp.Version = DateTime.MinValue;
					emptySyncResp.TotalSettings = 0;
					emptySyncResp.SettingsLen = 0;
					emptySyncResp.Settings = new UserSetting[0];
					return emptySyncResp;
				}

				// Do a quick check that we're setting values for the callingLivepuid.
				// This is not an exhastive check, but should catch this case for standard
				// usage.
				if (callingLivepuid != settings[0].UserId)
				{
					throw new ArgumentException("The UserId for whom settings are being set does not match the calling UserId.", "settings");
				}

				xonline.common.protocol.SyncSettingsRequest syncReq = new xonline.common.protocol.SyncSettingsRequest();
				syncReq.Settings = settings;
				syncReq.TitleId = TITLE_ID;
				syncReq.UserId = callingLivepuid;
				syncReq.Version = XOn.MinDateTime;
				syncReq.StartinIndex = 0;
                                
				// really we want to invalidate the user for whom we are applying the settings, but that should always be
				// the same as the calling user
				LivecacheDependency invalidates = new LivecacheDependency(callingLivepuid);
				LivecacheRequest lcReq = new LivecacheRequest (callingLivepuid, LcserviceId.SyncSettings, syncReq, null, invalidates);
            
				uint hr = HResult.S_OK;
				do
				{
					hr = lcReq.Send();
					if (HResult.XONLINE_E_TASK_THROTTLED == hr)
					{
						System.Threading.Thread.Sleep (5);
						continue;
					}
					if(hr!=HResult.S_OK)
					{
						throw new XRLException(hr,XOn.XeventCommFailedError, "Error syncing profile settings to Stats FD.");
					}
				} while (HResult.XONLINE_E_TASK_THROTTLED == hr);

				SyncSettingsResponse syncResp = new xonline.common.protocol.SyncSettingsResponse();  
				syncResp.SetBytes(lcReq.ResponseData);
				return syncResp;
			}

			public SyncSettingThread (BulkUserSet UserSet, TitleSet Titles, SafeCounter Counter, ManualResetEvent StopEvent, 
                                      bool bSyncSettings, bool bUpdateXboxComActivity, bool bAchievements )
			{
				_UserSet = UserSet;
				_TitleSet = Titles;
				_Counter = Counter;
				_StopEvent = StopEvent;
				_UsersSyncd = 0;
                _bSyncSettings = bSyncSettings;
                _bUpdateXboxComActivity = bUpdateXboxComActivity;
                _bAchievments = bAchievements;
			}

			protected override void ThreadBody()
			{
				// Loop until we run out of users
				while (true)
				{
					// Get the next user in line
					uint nUserIdx = (uint)_Counter.Increment () - 1;
					if (nUserIdx >= _UserSet.Count)
						break;

					// Get a user
					string sGamertag = _Users.IndexToGamertag (nUserIdx);
					ulong uPuid = _Users.IndexToPuid (nUserIdx);

					// Give the user some titles and achievements
					int nScore = 0;
                    if (_bAchievements)
                    {
                        try
                        {
                            nScore = _TitleSet.AssignAchievementsToUser(nUserIdx, uPuid);
                        }
                        catch (Exception x)
                        {
                            Console.WriteLine(x.Message);
                            return;
                        }
                    }

                    if (_bSyncSettings)
                    {
                        // Populate the SyncSetting request with the following data:
                        // Motto is the same as the Gamertag
                        // Gamertile is the next available one, we wrap around
                        // Gamerzone is RR, Pro, Family, or Underground sequetially, wrap around
                        string sGamerTile = String.Format("{0}{1:0000}", _BaseGamerTile, (nUserIdx % _NumTiles) + _TileID);
                        uint nGamerZone = nUserIdx % (uint)GamercardZones.NumZones + (uint)GamercardZones.RR;
                        SyncSettingsResponse syncResp = _SyncSettings(uPuid, _SetupSyncSettings(sGamertag, uPuid, sGamerTile, nGamerZone, nScore));
                    }

                    if (_bUpdateXboxComActivity)
                    {
                        // Update dt_last_web_activity so that we don't get redirected to the account creation page
                        XRLXeUpdateXboxComActivity xrlActivityRequest = new XRLXeUpdateXboxComActivity();
                        try
                        {
                            xrlActivityRequest.UserPuid = uPuid;
                            if (!xrlActivityRequest.Execute())
                                throw new Exception(String.Format("Error: {2} -- Cannot update user {0}(puid:{1}) activity on Xbox.com", sGamertag, uPuid, xrlActivityRequest.XErr));
                        }
                        catch (Exception e)
                        {
                            Console.WriteLine(e.Message);
                            return;
                        }
                    }

					_UsersSyncd++;
				}
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\c2m\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\BulkUser2WebUser\UserSettingBuilder.cs ===
using System;
using System.Text;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Feedback;
using ServerTestFramework.LiveService.UserAccount;
//using ServerTestFramework.LiveService.UserSettings;
using ServerTestFramework.Utilities;

using xonline.common.config;
using xonline.common.service;
using xonline.common.protocol;

namespace BulkUserSyncSettings
{
	/// <summary>
	/// Assists in building an array of common.protocol.UserSetting objects.
	/// </summary>
	public class UserSettingBuilder
	{
		private const int defaultInitialCapacity = 10;
		ArrayList settings;

		/// <summary>
		/// Constructs a UserSettingBuilder with a default initial capacity
		/// </summary>
		public UserSettingBuilder(ulong targetLivepuid) : this(targetLivepuid, defaultInitialCapacity)
		{
		}

		/// <summary>
		/// Constructs a UserSettingBuilder with the specified initial capacity.
		/// </summary>
		/// <param name="targetLivepuid">The live PUID of the user we want to get information about.</param>
		/// <param name="initialCapacity">Initial capacity of the UserSettingBuilder</param>
		public UserSettingBuilder(ulong targetLivepuid, int initialCapacity)
		{
			settings = new ArrayList(initialCapacity);
			_userId  = targetLivepuid;
		}

		/// <summary>
		/// Gets or sets the source that will be used when adding settings
		/// </summary>
		public uint Source 
		{
			get {return _source ;}
			set {_source  = value;}
		}
		private uint _source = XOn.XSOURCE_DEFAULT;

		/// <summary>
		/// Gets the user that the setting is being requested for.
		/// </summary>
		/// <remarks>
		/// This value is set by the constructor. Since we only want to make a request
		/// for a single user's settings, this helps to enforce only having one user defined
		/// in the resulting UserSetting array.</remarks>
		public ulong UserId 
		{
			get {return _userId ;}
		}
		private ulong _userId = 0;

		public void AddByteSetting(StatsProfileSetting setting, byte value)
		{
			byte[] byteValue = new byte[1];
			byteValue[0] = value;

			UserSetting newSetting = new UserSetting(UserId, Source); //, (uint) setting, byteValue);
			newSetting.SettingId = (uint)setting;
			newSetting.Value = byteValue;
			settings.Add(newSetting);
		}

		public void AddIntSetting(StatsProfileSetting setting, int value)
		{
			byte[] byteValue = BitConverter.GetBytes(value);
			UserSetting newSetting = new UserSetting(UserId, Source); //, (uint) setting, byteValue);
			newSetting.SettingId = (uint)setting;
			newSetting.Value = byteValue;
			settings.Add(newSetting);
		}

		public void AddUIntSetting(StatsProfileSetting setting, uint value)
		{
			byte[] byteValue = BitConverter.GetBytes(value);
			UserSetting newSetting = new UserSetting(UserId, Source); //, (uint) setting, byteValue);
			newSetting.SettingId = (uint)setting;
			newSetting.Value = byteValue;
			settings.Add(newSetting);
		}

		public void AddStringSetting(StatsProfileSetting setting, string value)
		{
			Encoding unicode = Encoding.Unicode;
            
			int byteCount = unicode.GetByteCount(value);

			byte[] byteValue = new byte[byteCount + 2];
			unicode.GetBytes(value, 0, value.Length, byteValue, 0);
			byteValue[byteCount] = 0;
			byteValue[byteCount + 1] = 0;

			UserSetting newSetting = new UserSetting(UserId, Source); //, (uint) setting, byteValue);
			newSetting.SettingId = (uint)setting;
			newSetting.Value = byteValue;
			settings.Add(newSetting);
		}

		public void AddFloatSetting(StatsProfileSetting setting, float value)
		{
			byte[] byteValue = BitConverter.GetBytes(value);
			UserSetting newSetting = new UserSetting(UserId, Source); //, (uint) setting, byteValue);
			newSetting.SettingId = (uint)setting;
			newSetting.Value = byteValue;
			settings.Add(newSetting);
		}

		public UserSetting[] ToUserSettingArray()
		{
			UserSetting[] settingsArray = new UserSetting[settings.Count];

			settings.CopyTo(settingsArray);

			return settingsArray;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\codecoverage\octopus\Common\msisupport.h ===
#pragma once

UINT GetPropertyValue(MSIHANDLE hInstall, LPWSTR pwszProperty, LPWSTR *ppwszValue, DWORD *pcchValue);

typedef UINT (CALLBACK * PropertyAction)(MSIHANDLE hInstall, LPWSTR pwszProperty);
UINT ForEachPropertyInList(MSIHANDLE hInstall, LPWSTR pwszListProperty, PropertyAction pfAction);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\codecoverage\octopus\Common\MsiSupport.cpp ===
#include "stdafx.h"

UINT GetPropertyValue(MSIHANDLE hInstall, LPWSTR pwszProperty, LPWSTR *ppwszValue, DWORD *pcchValue)
{
    *ppwszValue = NULL;
    *pcchValue = 0;

    DWORD cchValue = 0;

    UINT ret = MsiGetPropertyW(hInstall, pwszProperty, L"", &cchValue);
    if (ERROR_MORE_DATA == ret)
    {
        // Buffer Size returned does not include terminating NULL.
        // If we DON'T include it, the next MsiGetPropertyW will fail,
        // and if it didn't, we'd crash horribly later on... so we must
        // make room:
        ++cchValue;

        LPWSTR pwszValue = new wchar_t[cchValue];
        if (NULL != pwszValue)
        {
            ret = MsiGetPropertyW(hInstall, pwszProperty, pwszValue, &cchValue);
            if (ERROR_SUCCESS == ret)
            {
                *ppwszValue = pwszValue;
                *pcchValue = cchValue;
            }
        }
        else
        {
            ret = ERROR_OUTOFMEMORY;
        }
    }

    return ret;
}

typedef UINT (CALLBACK * PropertyAction)(MSIHANDLE hInstall, LPWSTR pwszProperty);
UINT ForEachPropertyInList(MSIHANDLE hInstall, LPWSTR pwszListProperty, PropertyAction pfAction)
{
    LPWSTR pwszSqlStrings = NULL;
    DWORD cchSqlStrings = 0;

    UINT ret = GetPropertyValue(hInstall, pwszListProperty, &pwszSqlStrings, &cchSqlStrings);
    if (ERROR_SUCCESS == ret)
    {
        DWORD idxStart = 0;
        DWORD idxEnd   = 0;

        while (idxStart < cchSqlStrings)
        {
            // Move idxEnd to a seperator token ',' or '\0'
            for(idxEnd = idxStart; idxEnd != L',' && idxEnd != L'\0'; ++idxEnd)
                ;

            // Terminate the string
            pwszSqlStrings[idxEnd] = L'\0';

            // From start to \0 is the name of the property whose contents we need to operate on
            ret = pfAction(hInstall, &pwszSqlStrings[idxStart]);
            if (ERROR_SUCCESS != ret)
            {
                // Attempt to set a property so the installer can log which property
                // caused us to die, and bail from the loop.

                MsiSetPropertyW(hInstall, L"SVLASTPROPERTY", &pwszSqlStrings[idxStart]);
                break;
            }

            // Leapfrog idxStart forward
            idxStart = idxEnd + 1;
        }

        delete[] pwszSqlStrings;
    }

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\c2m\c2m.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace C2M
{
    class C2M 
    {
        static private bool _reverse = false;

        static int Main(string[] args)
        {
            string outValue;
            ArgParser _args = null;

            try
            {
                string[] _cmdLineTags = {
                    "?",            // Usage text
                    "id",           // Console id or machine id
                    "reverse",      // Reverse the conversion
                    "file"          // Process the given text file containing a list of ids
                };
                _args = new ArgParser(_cmdLineTags);

                _args.Parse(args);
            }
            catch (Exception ex)
            {
                Console.WriteLine("An error occurred while parsing the command line:\r\n");
                Console.WriteLine(ex.Message);
                Console.WriteLine("\r\nPlease check the usage and try again.");
                return -1;
            }

            if (_args.Count == 0 || _args["?"] != null)
            {
                Usage();
                return 0;
            }

            _reverse = (_args["reverse"] != null);

            if (_args["file"] != null)
            {
                string file = Path.GetFullPath(_args["file"]);
                ProcessBatchFile(file);
            }
            else if (_args["id"] != null)
            {
                if (_reverse)
                    outValue = MachineNameToConsoleId(_args["id"]);
                else
                    outValue = ConsoleIdToMachineName(_args["id"]);

                // Output the result
                if (outValue != null)
                {
                    if (_reverse)
                    {
                        Console.WriteLine("Machine Name: {0}\r\n" +
                                          "Console ID:   {1}", _args["id"], outValue);
                    }
                    else
                    {
                        Console.WriteLine("Console ID:   {0}\r\n" +
                                          "Machine Name: {1}", _args["id"], outValue);
                    }
                }
            }
            else
            {
                Console.WriteLine("Nothing to do: Please check the Usage and try again.");
            }

            return 0;
        }

        static void ProcessBatchFile(string fileName)
        {
            string outFileName = Path.Combine(Path.GetDirectoryName(fileName),
                Path.GetFileNameWithoutExtension(fileName) + ".csv");

            if (!File.Exists(fileName))
            {
                Console.WriteLine("Can't find '{0}'", fileName);
                return;
            }

            try
            {
                using (StreamReader reader = new StreamReader(fileName))
                {
                    using (StreamWriter writer = new StreamWriter(outFileName))
                    {
                        string line;
                        string output;
                        while ((line = reader.ReadLine()) != null)
                        {
                            if (_reverse)
                                output = MachineNameToConsoleId(line);
                            else
                                output = ConsoleIdToMachineName(line);
                            if (output != null)
                            {
                                writer.WriteLine(output);
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("Fatal error while processing '{0}': {1}",
                    Path.GetFileName(fileName), ex.Message);
                return;
            }
        }

        static void ProcessXAppAdminFile(string fileName)
        {
            string outFileName = Path.Combine(Path.GetDirectoryName(fileName),
                Path.GetFileNameWithoutExtension(fileName) + ".csv");

            using (StreamReader reader = new StreamReader(fileName))
            {
                using (StreamWriter writer = new StreamWriter(outFileName))
                {
                    // Each line in the XAppAdmin file has this form:
                    //
                    // <gamertag> <consoleId>[,<consoleId>[,...]]
                    //
                    string line;
                    while ((line = reader.ReadLine()) != null)
                    {
                        string gamerTag;
                        string[] consoles;
                        string cid;
                        int idStart = line.IndexOf("XE.");
                        if (idStart > 0)
                        {
                            gamerTag = line.Substring(0, idStart - 1).Trim();
                            consoles = line.Substring(idStart).Split(new char[] { ',' });

                            // Begin output
                            StringBuilder output = new StringBuilder();
                            StringBuilder csvLine1 = new StringBuilder();
                            StringBuilder csvLine2 = new StringBuilder();

                            csvLine1.Append(gamerTag);
                            csvLine1.Append(',');
                            csvLine2.Append(',');
                            output.Append(gamerTag);
                            output.Append(' ', 20 - gamerTag.Length);
                            foreach (string consoleId in consoles)
                            {
                                cid = MachineNameToConsoleId(consoleId);

                                csvLine1.Append(consoleId);
                                csvLine1.Append(',');
                                csvLine2.AppendFormat("\"{0}\",",cid);
                                output.Append(cid);
                                output.Append(',');
                            }
                            output.Length--;
                            csvLine1.Length--;
                            csvLine2.Length--;

                            writer.WriteLine(csvLine1.ToString());
                            writer.WriteLine(csvLine2.ToString());
                            Console.WriteLine(output.ToString());
                        }
                    }
                }
            }
        }

        static string ConsoleIdToMachineName(string paramValue)
        {
            ulong consoleId = 0;
            ulong machineId = 0;
            ushort checkDigit = 0;

            if (ulong.TryParse(paramValue, out consoleId) == false)
            {
                Console.WriteLine("Invalid console ID: {0}", paramValue);
                return null;
            }

            // detach the last 4 bits - this is the check digit
            checkDigit = (ushort)(consoleId & 0xf);
            machineId = consoleId >> 4;

            // Build the machine name
            return "XE." + machineId.ToString("D11") + checkDigit.ToString();
        }

        static string MachineNameToConsoleId(string paramValue)
        {
            string machineName;
            int i;
            ulong digit;
            ulong checkDigit = 0;
            ulong consoleId = 0;

            if (paramValue.StartsWith("XE."))
            {
                machineName = paramValue.Substring(3);
            }
            else
            {
                machineName = paramValue;
            }

            // Machine names must be 12 digits long
            if (machineName.Length < 12)
            {
                Console.WriteLine("Error: Invalid machine name: {0}", paramValue);
                return null;
            }

            for (i = 0; i < machineName.Length - 1; i++)
            {
                if (!char.IsDigit(machineName[i]))
                {
                    Console.WriteLine("Error: Invalid machine name: {0}", paramValue);
                    return null;
                }
                digit = (ulong)(machineName[i] - '0');
                consoleId = (consoleId * 10) + digit;
            }

            if (!char.IsDigit(machineName[i]))
            {
                Console.WriteLine("Error: Invalid machine name: {0}", paramValue);
                return null;
            }
            checkDigit = (ulong)(machineName[i] - '0');

            consoleId = (consoleId << 4) + checkDigit;
            return consoleId.ToString();
        }

        static void Usage()
        {
            Console.WriteLine("Converts a console ID to a machine name and vice-versa.");
            Console.WriteLine("Usage:");
            Console.WriteLine("    c2m.exe /?");
            Console.WriteLine("    c2m.exe /id:<consoleId> [/reverse]");
            Console.WriteLine("    c2m.exe /xappadmin:<filename>\r\n");
            Console.WriteLine("Where:");
            Console.WriteLine("    /?                       Display this usage text.");
            Console.WriteLine("    /id:<consoleId>          The Console ID value to convert.");
            Console.WriteLine("    /reverse                 Reverses the conversion. If this flag is specified,");
            Console.WriteLine("                             the id parameter is treated as a Machine Name");
            Console.WriteLine("    /file:<filename>         Processes the specified text file containing a list of ids.");
            Console.WriteLine("    Console ID               The console id as seen in the Genealogy database.");
            Console.WriteLine("    Machine Name             The machine name. This is a 12-digit value and may");
            Console.WriteLine("                             be prefixed with 'XE.'");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\c2m\ArgParser.cs ===
using System;
using System.Collections.Generic;
using System.Text;

/// <summary>
/// Command line parser based on the NamedArgParser class used in all the tools.
/// </summary>
public class ArgParser
{
    private static char[] _defaultDelimiters = { '/', '-' };

    private Dictionary<string, string> _args;
    private char[] _delimiters;
    private string[] _tags;
    private bool _ignoreCase = true;

    public ArgParser() : this(null, _defaultDelimiters) { }
    public ArgParser(string[] tags) : this(tags, _defaultDelimiters) { }
    public ArgParser(string[] tags, char[] delimiters)
    {
        _args = new Dictionary<string, string>();
        _tags = tags;
        _delimiters = delimiters;
    }

    public string[] Tags
    {
        get { return _tags; }
        set { _tags = value; }
    }

    public char[] Delimiters
    {
        get { return _delimiters; }
        set { _delimiters = value; }
    }

    public bool IgnoreCase
    {
        get { return _ignoreCase; }
        set { _ignoreCase = value; }
    }

    public string this[string tag]
    {
        get
        {
            if (_args.ContainsKey(tag))
                return _args[tag];
            else
                return null;
        }
        set { _args[tag] = value; }
    }

    public int Count
    {
        get { return _args.Count; }
    }

    public void Parse(string[] commandLine)
    {
        if (commandLine.Length == 0)
        {
            throw new ArgumentException("Trying to parse an empty command line.");
        }

        string tag;
        string value;
        int valueSep;

        foreach (string arg in commandLine)
        {
            // Get the tag
            tag = GetTag(arg);
            if (tag.Length == 0)
            {
                // Invalid argument
                throw new ArgumentException("Invalid command line argument.", arg);
            }

            // Get the value associated with the tag (if any)
            value = "";
            valueSep = arg.IndexOf(':');
            if (valueSep > 0)
            {
                value = arg.Substring(valueSep + 1);
            }

            if (_ignoreCase)
                tag = tag.ToLower();

            // Add the tag/value pair
            _args.Add(tag, value);
        }
    }

    private string GetTag(string arg)
    {
        int i;
        int valueIndex;
        string tag = "";
        bool isValid = false;

        // Look for one of the valid delimiters
        for (i = 0; i < _delimiters.Length; i++)
        {
            if (arg[0] == _delimiters[i]) break;
        }

        if (i >= _delimiters.Length)
            return "";

        valueIndex = arg.IndexOf(':');
        if (valueIndex > 0)
        {
            tag = arg.Substring(1, valueIndex - 1);
        }
        else
        {
            tag = arg.Substring(1);
        }

        // Validate the tag against the list of valid tags
        if (_tags != null)
        {
            foreach (string validTag in _tags)
            {
                if (String.Compare(validTag, tag, _ignoreCase) == 0)
                {
                    isValid = true;
                    break;
                }
            }
        }

        return (isValid ? tag : "");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\codecoverage\octopus\MagHelper\MagHelper.cpp ===
// MagHelper.cpp : Defines the entry point for the DLL application.
//

#include "stdafx.h"


#ifdef _MANAGED
#pragma managed(push, off)
#endif

BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
					 )
{
    return TRUE;
}

#ifdef _MANAGED
#pragma managed(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\codecoverage\octopus\MagHelper\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
// MagHelper.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\codecoverage\octopus\MagHelper\stdafx.h ===
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

// Modify the following defines if you have to target a platform prior to the ones specified below.
// Refer to MSDN for the latest info on corresponding values for different platforms.
#ifndef WINVER				// Allow use of features specific to Windows XP or later.
#define WINVER 0x0501		// Change this to the appropriate value to target other versions of Windows.
#endif

#ifndef _WIN32_WINNT		// Allow use of features specific to Windows XP or later.                   
#define _WIN32_WINNT 0x0501	// Change this to the appropriate value to target other versions of Windows.
#endif						

#ifndef _WIN32_WINDOWS		// Allow use of features specific to Windows 98 or later.
#define _WIN32_WINDOWS 0x0410 // Change this to the appropriate value to target Windows Me or later.
#endif

#ifndef _WIN32_IE			// Allow use of features specific to IE 6.0 or later.
#define _WIN32_IE 0x0600	// Change this to the appropriate value to target other versions of IE.
#endif

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
// Windows Header Files:
#include <windows.h>



#include <msi.h>
#include <msiquery.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\codecoverage\octopus\SqlHelper\internal.h ===
#pragma once

typedef struct tagINSTALL_SETTINGS {

    LPWSTR pwszNpdbServer;

    LPWSTR pwszCcdbServer;

    LPWSTR pwszSqlToolsDir;

    LPWSTR pwszConfigShare;
    size_t cchConfigShare;

    LPWSTR pwszTraceShare;
    size_t cchTraceShare;

    LPWSTR pwszComponentShare;
    size_t cchComponetShare;

    LPWSTR pwszCustomBuildVersion;

    LPWSTR pwszReportingServer;
    LPWSTR pwszReportingDatabase;

    LPWSTR *rgwszDatabaseList;

} INSTALLSETTINGS, *LPINSTALLSETTINGS, *PINSTALLSETTINGS, &RINSTALLSETTINGS;

typedef CONST INSTALLSETTINGS *LPCINSTALLSETTINGS, *PCINSTALLSETTINGS, &RCINSTALLSETTINGS;
 
typedef CONST WCHAR *LPCWCH, *PCWCH;

DWORD InternalInstall(RCINSTALLSETTINGS settings);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\codecoverage\octopus\SqlHelper\MsiLogger.h ===
#pragma once

#define MAX_MESSAGE 1000

enum MESSAGETYPE
{
    MT_INFO    = INSTALLMESSAGE_INFO,
    MT_WARNING = INSTALLMESSAGE_WARNING,
    MT_ERROR   = INSTALLMESSAGE_ERROR
};

class CMsiLogger
{
public:
    static HRESULT Init(MSIHANDLE hInstall);
    static HRESULT Close(void);
   
    static DWORD CMsiLogger::WriteMessage(MESSAGETYPE eMessageType, LPCWSTR pcwszFormat, ...);
    static DWORD CMsiLogger::WriteMessage(MESSAGETYPE eMessageType, HRESULT hresult, LPCWSTR pcwszFormat, ...);

private:
     CMsiLogger(void);
    ~CMsiLogger(void);

    static DWORD CMsiLogger::InternalWriteMessage(MESSAGETYPE eMessageType, LPCWSTR pcwszFormat, va_list vargs);
    static DWORD Fatal(void);

    static MSIHANDLE m_hInstall;
    static MSIHANDLE m_hRecord;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\codecoverage\octopus\SqlHelper\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by SqlHelper.rc
//
#define IDS_SQL_NPDB_DBSERVERS               101

#define IDS_SQLCC_CONFIG_FORMAT              201
// 1) Component Name
// 2) Custom Version
// 3) Component Share
// 4) Reporting Database: Server Name
// 5) Reporting Database: Database Name
// 6) Target Database: Server Name
// 7) Target Database: Database Name
// 8) Trace Share

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\codecoverage\octopus\SqlHelper\MsiLogger.cpp ===
#include "StdAfx.h"
#include "MsiLogger.h"

MSIHANDLE CMsiLogger::m_hInstall = NULL;
MSIHANDLE CMsiLogger::m_hRecord  = NULL;

HRESULT CMsiLogger::Init(MSIHANDLE hInstall)
{
    HRESULT hr = E_ABORT;

    if (NULL == m_hInstall)
    {
        hr = S_OK;
        m_hInstall = hInstall;

        // Create record
        m_hRecord = MsiCreateRecord(2);
    }

    return hr;
}

HRESULT CMsiLogger::Close(void)
{
    HRESULT hr = E_ABORT;

    if (NULL != m_hInstall)
    {
        // Free record
        MsiCloseHandle(m_hRecord);

        m_hRecord = NULL;
        m_hInstall = NULL;

        hr = S_OK;
    }

    return hr;
}

DWORD CMsiLogger::Fatal(void)
{
    return MsiProcessMessage(m_hInstall, INSTALLMESSAGE_FATALEXIT, NULL);
}

DWORD CMsiLogger::InternalWriteMessage(MESSAGETYPE eMessageType, LPCWSTR pcwszFormat, va_list vargs)
{
    HRESULT hr = S_OK;

    LPWSTR pwszMessage = new wchar_t[MAX_MESSAGE];
    if (NULL != pwszMessage)
    {
        hr = StringCchVPrintfW(pwszMessage, MAX_MESSAGE, pcwszFormat, vargs);
        if (SUCCEEDED(hr))
        {
            hr = ERROR_INVALID_DATA;
            int idxErrorTable = 0;
            switch (eMessageType)
            {
            case MT_INFO:
                idxErrorTable = 4;
                break;
            case MT_WARNING:
                idxErrorTable = 2;
                break;
            case MT_ERROR:
                idxErrorTable = 1;
                break;
            default:
                return ERROR_INVALID_DATA;
            }

            // Error Message Table Index
            hr = MsiRecordSetInteger(m_hRecord, 1, idxErrorTable);
            if (ERROR_SUCCESS == hr)
            {
                // Custom Text
                hr = MsiRecordSetStringW(m_hRecord, 2, pwszMessage);
                if (ERROR_SUCCESS == hr)
                {
                    hr = MsiProcessMessage(m_hInstall, (INSTALLMESSAGE)eMessageType, m_hRecord);
                }
            }
        }

        delete[] pwszMessage;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if (ERROR_SUCCESS != HRESULT_CODE(hr))
    {
        Fatal();
    }

    return HRESULT_CODE(hr);
}

DWORD CMsiLogger::WriteMessage(MESSAGETYPE eMessageType, LPCWSTR pcwszFormat, ...)
{
    va_list argptr;
    va_start(argptr, pcwszFormat);

    return InternalWriteMessage(eMessageType, pcwszFormat, argptr);
}

DWORD CMsiLogger::WriteMessage(MESSAGETYPE eMessageType, HRESULT hresult, LPCWSTR pcwszFormat, ...)
{
    size_t cchFormat;
    HRESULT hr = StringCchLengthW(pcwszFormat, MAX_MESSAGE, &cchFormat);
    {
        size_t cchnewFormat = cchFormat + 8 + 5 + 1;
        LPWSTR pwsznewFormat = new wchar_t[cchnewFormat];
        if (NULL != pwsznewFormat)
        {
            hr = StringCchPrintfW(pwsznewFormat, cchnewFormat, L"(0x%08X) %s", hresult, pcwszFormat);
            if (SUCCEEDED(hr))
            {
                va_list argptr;
                va_start(argptr, pcwszFormat);

                hr = InternalWriteMessage(eMessageType, pwsznewFormat, argptr);
            }

            delete[] pwsznewFormat;
        }
        else
        {
            hr = ERROR_OUTOFMEMORY;
        }
    }

    return HRESULT_CODE(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\codecoverage\octopus\SqlHelper\SqlConnection.cpp ===
#include "StdAfx.h"
#include "SqlConnection.h"

CSqlConnection::CSqlConnection(void)
{
}

CSqlConnection::~CSqlConnection(void)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\codecoverage\octopus\SqlHelper\internal.cpp ===
#include "stdafx.h"

#include "internal.h"
#include "sqlnclih.h"

#include "MsiLogger.h"
#include "StringResources.h"

#include <shellapi.h>

// Internal HRESULTS //
#define STRCMP_E_TOO_MANY_CHARACTERS MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x200)

// This function will overwrite the current HRESULT on failure, so be sure
// things have succeeded *before* calling this function as the original HRESULT
// may be lost.
//
// This a convenience function to allow specific failures to be logged
// and alleviate the need to check HRESULTS between each verification.
//
void VerifyCch(LPCWSTR pcwszVarName, size_t cchVar, size_t cchMax, HRESULT *pHR)
{
    if (cchVar > cchMax)
    {
        *pHR = E_INVALIDARG;

        CMsiLogger::WriteMessage(
            MT_ERROR
          , L"%s exceeded %d characters!"
          , pcwszVarName
          , cchMax
        );
    }
}

HRESULT InitBindings(DBBINDING *pBindings, int nBindings)
{
    HRESULT hr = S_OK;
    
    SecureZeroMemory(pBindings, sizeof(DBBINDING) * nBindings);

    // Initialize Default Bindings
    //
    // Defaults are:
    // * Array is in the same order as values are expected/returned
    // * Bindings contain only 'value' definintions
    // * Memory is Client-Owned
    //
    for (int i = 0; i < nBindings; ++i)
    {
        pBindings[i].iOrdinal   = i + 1;
        pBindings[i].dwPart     = DBPART_VALUE;
        pBindings[i].dwMemOwner = DBMEMOWNER_CLIENTOWNED;
    }

    return hr;
}

// The columns are of type NVARCHAR(65), the +1 is to leave room for a trailing L'\0'
const size_t MAX_SETTING_CCH = 65 + 1;
typedef struct dbmap_s {

    wchar_t pwszDatabase[MAX_SETTING_CCH];
    size_t  cchDatabase;

    wchar_t pwszServer[MAX_SETTING_CCH];
    size_t  cchServer;

} dbmap_t;

HRESULT GetDbMappingsFromNpdb(IUnknown *punkConnection, dbmap_t **ppDbMappings, size_t *pcDbMappings)
{
    HRESULT hr;

    *ppDbMappings = NULL;
    *pcDbMappings = 0;

    ICommandText *pICommandText;
    hr = SqlCreateCommand(punkConnection, IID_ICommandText, (IUnknown **)&pICommandText);
    if (SUCCEEDED(hr))
    {
        hr = pICommandText->SetCommandText(
            DBGUID_SQL
          , gc_pcwszSqlGetDbServersCommand
        );

        if (SUCCEEDED(hr))
        {
            // Execute
            IRowset *pIRowset;
            DBROWCOUNT cRowsAffected;
            hr = pICommandText->Execute(NULL, IID_IRowset, NULL, &cRowsAffected, (IUnknown **)&pIRowset);
            if (SUCCEEDED(hr))
            {
                HROW *rghRows = NULL;

                DBCOUNTITEM cRows;
                hr = pIRowset->GetNextRows(DB_NULL_HCHAPTER, 0, DBPROP_MAXOPENROWS, &cRows, &rghRows);
                if (SUCCEEDED(hr) && cRows > 0)
                {
                    // Set up IAccessor
                    IAccessor *pIAccessor;
                    hr = pIRowset->QueryInterface(IID_IAccessor, (void **)&pIAccessor);
                    if (SUCCEEDED(hr))
                    {
                        // Create and fill array from results
                        dbmap_t *rows = new dbmap_t[cRows];

                        static DBBINDING Bindings[2] = {
                             {
                                // Server String //
                                1                               // Ordinal
                              , offsetof(dbmap_t, pwszServer)   // Value  Binding (used: DBPART_VALUE)
                              , offsetof(dbmap_t, cchServer)    // Length Binding (used: DBPART_LENGTH)
                              , 0                               // Status Binding (ignored: DBPART_STATUS)
                              , NULL                            // Type Info (reserved, must be NULL)
                              , NULL                            // Object (none)
                              , NULL                            // Extensions (reserved, must be NULL)
                              , DBPART_VALUE | DBPART_LENGTH    // Bindings to use
                              , DBMEMOWNER_CLIENTOWNED          // Memory Ownership (ignored: not byref)
                              , DBPARAMIO_NOTPARAM              // Not used in reading rowsets
                              , sizeof(rows[0].pwszServer)      // Size of memory allocated for Value
                              , 0                               // Flags
                              , DBTYPE_WSTR                     // DB Type
                              , 0                               // Precision (none)
                              , 0                               // Scale (none)
                            }
                          , {
                                // Database String //
                                2                               // Ordinal
                              , offsetof(dbmap_t, pwszDatabase) // Value  Binding (used: DBPART_VALUE)
                              , offsetof(dbmap_t, cchDatabase)  // Length Binding (used: DBPART_LENGTH)
                              , 0                               // Status Binding (ignored: DBPART_STATUS)
                              , NULL                            // Type Info (reserved, must be NULL)
                              , NULL                            // Object (none)
                              , NULL                            // Extensions (reserved, must be NULL)
                              , DBPART_VALUE | DBPART_LENGTH    // Bindings to use
                              , DBMEMOWNER_CLIENTOWNED          // Memory Ownership (ignored: not byref)
                              , DBPARAMIO_NOTPARAM              // Not used in reading rowsets
                              , sizeof(rows[0].pwszDatabase)    // Size of memory allocated for Value
                              , 0                               // Flags
                              , DBTYPE_WSTR                     // DB Type
                              , 0                               // Precision (none)
                              , 0                               // Scale (none)
                            }
                        };

                        HACCESSOR hAccessor;
                        hr = pIAccessor->CreateAccessor(
                            DBACCESSOR_ROWDATA      // Accessor Type
                          , ARRAYLEN(Bindings)      // Count of Bindings
                          , Bindings                // Bindings Array
                          , 0                       // Row Size (ignored when fetching rowset data)
                          , &hAccessor              // Created Accessor
                          , NULL                    // DBBINDSTATUS -- this could be really useful for proper error reporting
                        );
                        
                        if (SUCCEEDED(hr))
                        {
                            for (DBCOUNTITEM idxRow = 0; idxRow < cRows; ++idxRow)
                            {
                                hr = pIRowset->GetData(rghRows[idxRow], hAccessor, (void *)& rows[idxRow]);
                                if (FAILED(hr)){ break; }
                            }

                            if (SUCCEEDED(hr))
                            {
                                *ppDbMappings = rows;
                                *pcDbMappings = cRows;
                            }
                        }
                        else
                        {
                            CMsiLogger::WriteMessage(MT_ERROR, L"Failed to create accessor");
                        }

                        if (FAILED(hr))
                        {
                            delete[] rows;
                        }
                    }

                    CoTaskMemFree(rghRows);
                }
            }
            else
            {
                CMsiLogger::WriteMessage(MT_ERROR, L"Failed Executing SQL command");
            }
        }

        pICommandText->Release();
    }

    return hr;
}

HRESULT StringCompare(LPCWSTR pcwszLeft, size_t cchLeft, LPCWSTR pcwszRight, size_t cchRight)
{
    HRESULT hr = STRCMP_E_TOO_MANY_CHARACTERS;

    size_t cchMax = (cchLeft < cchRight) ? cchLeft : cchRight;

    size_t i;
    for (i = 0; i < cchMax; ++i)
    {
        if (pcwszLeft[i] != pcwszRight[i])
        {
            hr = S_FALSE;
            break;
        }

        // At this point we know ch_left == ch_right
        if (pcwszLeft[i] == L'\0')
        {
            hr = S_OK;
            break;
        }
    }

    return hr;
}

HRESULT CreateConfigFile(
    RCINSTALLSETTINGS settings
  , LPCWSTR pcwszTargetServer   , size_t cchTargetServer
  , LPCWSTR pcwszTargetDatabase , size_t cchTargetDatabase
  , LPCWSTR *ppcwszPath         , size_t *pcchPath
)
{
    HRESULT hr;

    size_t cchComponentName = cchTargetServer + cchTargetDatabase - 2 + 1 + 1;
    LPWSTR pwszComponentName = new wchar_t[cchComponentName];
    hr = StringCchPrintfW(pwszComponentName, cchComponentName, L"%s-%s"
      , pcwszTargetDatabase
      , pcwszTargetServer
    );
    if (SUCCEEDED(hr))
    {
        // Create Path
        //               string - L'\0' ,                string - L'\0' ,       path,extension,trailing L'\0'
        size_t cchPath = settings.cchComponetShare - 1 + cchComponentName - 1 + 1 + 7 + 1;
        LPWSTR pwszPath = new wchar_t[cchPath];
        hr = StringCchPrintfW(pwszPath, cchPath, L"%s\\%s.config", settings.pwszConfigShare, pwszComponentName);
        if (SUCCEEDED(hr))
        {
            FILE *pFile;
            errno_t error = _wfopen_s(&pFile, pwszPath, L"w");
            if (!error)
            {
                int ret = fwprintf(pFile, gc_pcwszConfigFormat,
                    pwszComponentName               // 1) Component Name
                  , settings.pwszCustomBuildVersion // 2) Custom Version
                  , settings.pwszComponentShare     // 3) Component Share
                  , settings.pwszReportingServer    // 4) Reporting Database: Server Name
                  , settings.pwszReportingDatabase  // 5) Reporting Database: Database Name
                  , pcwszTargetServer               // 6) Target Database: Server Name
                  , pcwszTargetDatabase             // 7) Target Database: Database Name
                  , settings.pwszTraceShare         // 8) Trace Share
                );
                if (ret > 0)
                {
                    *ppcwszPath = static_cast<LPCWSTR>(pwszPath);
                    *pcchPath   = cchPath;
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());

                    CMsiLogger::WriteMessage(
                        MT_ERROR
                      , L"Couldn't write to file %s"
                      , pwszPath
                    );
                }

                fclose(pFile);
            }
            else
            {
                hr = HRESULT_FROM_WIN32(error);

                CMsiLogger::WriteMessage(
                    MT_ERROR
                  , L"Failed opening file: %s"
                  , pwszPath
                );
            }
        }
        else
        {
            CMsiLogger::WriteMessage(MT_ERROR, L"Failed to create path string");
        }

        delete[] pwszComponentName;
    }
    else
    {
        CMsiLogger::WriteMessage(MT_ERROR, L"Failed to generate component name");
    }

    return hr;
}

#define HINSTANCE_TO_INT(h) ((int)(((unsigned long long)h) & 0xFFFFFFFF))

// Prevent double-closing of handles by
// zeroing the handle after the CloseHandle() call.
void SafeCloseHandle(PHANDLE pHandle)
{
    if (*pHandle)
    {
        CloseHandle(*pHandle);
        pHandle = NULL;
    }
}

DWORD LogProcessExecution(HANDLE hProc, HANDLE hStream, PDWORD pdwResult)
{
    DWORD ec = ERROR_SUCCESS;

    *pdwResult = ERROR_SUCCESS;

    // Size to grow our buffer on each realloc
    DWORD cbBuffer = 256;

    // Metrics to track buffer size/usage
    size_t idxCmpl = 0;
    size_t cbCmpl  = 0;

    // Growable buffer to collect process output.
    // We use a growable buffer here because the output is expected
    // in lines of data.  We want to be sure not to output partial lines
    // and this approach saves us detailed parsing at the expense of memory
    // usage.
    PBYTE buffer_cmpl = NULL;
    BOOL fDone = FALSE;
    while (!fDone)
    {
        // Grow the input buffer as needed
        DWORD cbAvailable = (DWORD) (cbCmpl - idxCmpl);
        if (cbAvailable < cbBuffer/2)
        {
            cbCmpl += cbBuffer;
            // Every time we realloc we make sure to leave ONE spot open on the
            // end, so the buffer can always be NULL-terminated
            PBYTE tmp = (PBYTE) realloc(buffer_cmpl, cbCmpl + 1);
            if (tmp)
            {
                buffer_cmpl = tmp;
            }
            else
            {
                // Couldn't allocate the requested memory
                // we are now in an error stat and about to bail.
                ec = ERROR_OUTOFMEMORY;
                break;
            }

            cbAvailable += cbBuffer;
        }

        // Fill buffer with output from the process
        DWORD cbRead;
        if (ReadFile(hStream, &buffer_cmpl[idxCmpl], cbAvailable, &cbRead, NULL))
        {
            idxCmpl += cbRead;                  
        }
        else
        {
            ec = GetLastError();
            if (ERROR_BROKEN_PIPE == ec)
            {
                // This is what we expect to happen when the child process
                // completes execution.
                ec = ERROR_SUCCESS;
            }

            // If there was any sort of error on the pipe, we're done
            // hopefully it was just the pipe closing.
            fDone = TRUE;
        }
    }

    if (fDone && ERROR_SUCCESS == ec)
    {
        // NULL-terminate the buffer (aren't we glad we left
        // that spot open now?)
        buffer_cmpl[idxCmpl] = '\0';

        // Write output to logfile, one line at a time.
        PCHAR ctx = NULL;
        PCHAR line = strtok_s((PCHAR)buffer_cmpl, "\r\n", &ctx);
        while (NULL != line)
        {
            // Trim out empty tokens
            if (*line != '\0')
            {
                CMsiLogger::WriteMessage(MT_INFO, L"\t%S", line);
                line = strtok_s(NULL, "\r\n", &ctx);
            }
        }
    }
    else
    {
        CMsiLogger::WriteMessage(MT_WARNING, L"Failed to read process output.");
    }

    // Log process exit code:
    DWORD dwExitCode;
    if (GetExitCodeProcess(hProc, &dwExitCode))
    {
        CMsiLogger::WriteMessage(MT_INFO, L"Process Exit Code: %d", dwExitCode);
        *pdwResult = dwExitCode;
    }
    else
    {
        ec = GetLastError();
        CMsiLogger::WriteMessage(MT_ERROR, L"Couldn't read Process Exit Code! (%d)", ec);
    }

    // The buffer may never have gotten allocated
    // let's only free it if there is something to free.
    if (buffer_cmpl) { free(buffer_cmpl); }

    return ec;
}

// pwszParams cannot be const due to CreateProcessW() occasionally feeling the need to modify the string >.<
DWORD ExecuteAndLog(LPCWSTR pcwszPath, LPCWSTR pcwszExe, LPWSTR pwszParams, DWORD *pdwResult)
{
    DWORD ec = ERROR_SUCCESS;

    SECURITY_ATTRIBUTES sa;
    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.bInheritHandle       = TRUE;
    sa.lpSecurityDescriptor = NULL;

    HANDLE hReadStreamTmp, hReadStream, hOutputStream, hErrorStream;
    if (CreatePipe(&hReadStreamTmp, &hOutputStream, &sa, 0))
    {
        HANDLE hProc = GetCurrentProcess();

        // Duplicate the handle to the write end of the pipe so it can be used for both STDIN and STDERR
        if (DuplicateHandle(hProc, hOutputStream, hProc, &hErrorStream, 0, TRUE, DUPLICATE_SAME_ACCESS))
        {
            // Duplicate the read stream, but remove the ability to inherit... we don't want the child process
            // picking up this handle and being unable to close it.
            if (DuplicateHandle(hProc, hReadStreamTmp, hProc, &hReadStream, 0, FALSE, DUPLICATE_SAME_ACCESS))
            {
                // We don't want this getting inherited, after all that was the whole point
                // of the DuplicateHandle() call.
                SafeCloseHandle(&hReadStreamTmp);

                //
                // Start the Process with redirected STDOUT and STDERR
                //
                STARTUPINFOW si = {0};
                si.cb = sizeof(STARTUPINFOW);
                si.dwFlags     = STARTF_USESTDHANDLES;
                si.hStdInput   = GetStdHandle(STD_INPUT_HANDLE);
                si.hStdOutput  = hOutputStream;
                si.hStdError   = hErrorStream;
                si.wShowWindow = SW_HIDE;

                PROCESS_INFORMATION pi = {0};

                const size_t cchCommandline = 255;
                wchar_t pwszCommandline[cchCommandline];
                HRESULT hr = StringCchPrintfW(pwszCommandline, cchCommandline, L"\"%s%s\" %s", pcwszPath, pcwszExe, pwszParams);
                if (SUCCEEDED(hr))
                {
                    CMsiLogger::WriteMessage(MT_INFO, L"Executing: %s", pwszCommandline);

                    if (CreateProcessW(
                        NULL
                      , pwszCommandline
                      , NULL
                      , NULL
                      , TRUE
                      , CREATE_NEW_CONSOLE
                      , NULL
                      , NULL
                      , &si
                      , &pi
                    )) {
                        // Close the write ends of the pipe
                        // If we keep them open here, we want the
                        // child to have the only references so that when
                        // it closes them, we know about it.
                        SafeCloseHandle(&hOutputStream);
                        SafeCloseHandle(&hErrorStream);

                        ec = LogProcessExecution(pi.hProcess, hReadStream, pdwResult);

                        // Close handles opened by CreateProcess()
                        CloseHandle(pi.hThread);
                        CloseHandle(pi.hProcess);
                    }
                    else
                    {
                        ec = GetLastError();
                    }
                }
                else
                {
                    CMsiLogger::WriteMessage(MT_ERROR, hr, L"Couldn't create exe string.");
                    ec = HRESULT_CODE(hr);
                }

                SafeCloseHandle(&hReadStream);
            }

            SafeCloseHandle(&hErrorStream);
        }

        SafeCloseHandle(&hReadStreamTmp);
        SafeCloseHandle(&hOutputStream);
    }

    return ec;
}

//
// Calls SqlccCover.exe to instrument databases based
// upon the content of the config file which lives at the
// passed location.
//
HRESULT InstrumentDb(RCINSTALLSETTINGS settings, LPCWSTR pcwszConfigPath, size_t cchConfigPath)
{
    HRESULT hr = E_OUTOFMEMORY;

    // Build parameters
    size_t cchParameters = cchConfigPath + 8;
    LPWSTR pwszParameters = new wchar_t[cchParameters];
    if (pwszParameters)
    {
        hr = StringCchPrintfW(pwszParameters, cchParameters, L"-c \"%s\" -f", pcwszConfigPath);
        if (SUCCEEDED(hr))
        {
            DWORD dwResult;
            DWORD ec = ExecuteAndLog(settings.pwszSqlToolsDir, L"SqlccCover.exe", pwszParameters, &dwResult);
            if (ERROR_SUCCESS == ec)
            {
                ec = dwResult;
                if (ERROR_SUCCESS != ec)
                {
                    CMsiLogger::WriteMessage(MT_ERROR, L"Failed to instrument the database, ec = %d", ec);
                }
            }

            hr = HRESULT_FROM_WIN32(ec);
        }

        delete[] pwszParameters;
    }

    return hr;
}

const size_t MAX_CCH_DB_PARAM     = 65  + 1;
const size_t MAX_CCH_SERVER_PARAM = 65  + 1;
const size_t MAX_CCH_PATH_PARAM   = 255 + 1;

#pragma pack(push, 4)
typedef struct tagASCPARAMS {

    long lReturnValue;

    HRESULT hrDatabase;
    wchar_t wszDatabase[MAX_CCH_DB_PARAM];
    
    HRESULT hrServer;
    wchar_t wszServer[MAX_CCH_SERVER_PARAM];
    
    HRESULT hrPath;
    wchar_t wszPath[MAX_CCH_PATH_PARAM];
    
} ASCPARAMS;
#pragma pack(pop)

HRESULT AddSqlComponent(
    IUnknown *punkCcdb
  , LPCWSTR pcwszServer     , size_t cchServer
  , LPCWSTR pcwszDatabase   , size_t cchDatabase
  , LPCWSTR pcwszConfigPath , size_t cchConfigPath
)
{
    HRESULT hr = S_OK;

    VerifyCch( L"Server"      , cchServer     , MAX_CCH_SERVER_PARAM , &hr );
    VerifyCch( L"Database"    , cchDatabase   , MAX_CCH_DB_PARAM     , &hr );
    VerifyCch( L"Config Path" , cchConfigPath , MAX_CCH_PATH_PARAM   , &hr );

    if (SUCCEEDED(hr))
    {
        ICommandText *pICommandText;
        hr = SqlCreateCommand(punkCcdb, IID_ICommandText, (IUnknown **)&pICommandText);
        if (SUCCEEDED(hr))
        {
            hr = pICommandText->SetCommandText(DBGUID_DBSQL, L"{rpc p_add_sql_component}");
            if (SUCCEEDED(hr))
            {
                ICommandWithParameters *pICommandWithParameters;
                hr = pICommandText->QueryInterface(IID_ICommandWithParameters, (void **) &pICommandWithParameters);
                if (SUCCEEDED(hr))
                {
                    /*
                    Describe the command parameters (parameter name, provider
                    specific name of the parameter's data type, and so on.) in an array of 
                    DBPARAMBINDINFO structures.  This information is then used by
                    SetParameterInfo().
                    */
                    const int nParams = 4;
                    DBPARAMBINDINFO rgParamBindInfo[nParams];
                    ULONG           rgParamOrdinals[nParams];

                    // Add Return Value to parameters
                    rgParamOrdinals[0] = 1;
                    rgParamBindInfo[0].pwszDataSourceType = L"DBTYPE_I4";
                    rgParamBindInfo[0].pwszName = L"@rv";
                    rgParamBindInfo[0].ulParamSize = sizeof(long);
                    rgParamBindInfo[0].dwFlags = DBPARAMFLAGS_ISOUTPUT;
                    rgParamBindInfo[0].bPrecision = 11;
                    rgParamBindInfo[0].bScale = 0;
                    
                    // Add Database to parameters
                    rgParamOrdinals[1] = 2;
                    rgParamBindInfo[1].pwszDataSourceType = L"DBTYPE_WVARCHAR";
                    rgParamBindInfo[1].pwszName = L"@vc_database";
                    rgParamBindInfo[1].ulParamSize = 64;
                    rgParamBindInfo[1].dwFlags = DBPARAMFLAGS_ISINPUT;
                    rgParamBindInfo[1].bPrecision = 0;
                    rgParamBindInfo[1].bScale = 0;

                    // Add Server to parameters
                    rgParamOrdinals[2] = 3;
                    rgParamBindInfo[2].pwszDataSourceType = L"DBTYPE_WVARCHAR";
                    rgParamBindInfo[2].pwszName = L"@vc_server";
                    rgParamBindInfo[2].ulParamSize = 64;
                    rgParamBindInfo[2].dwFlags = DBPARAMFLAGS_ISINPUT;
                    rgParamBindInfo[2].bPrecision = 0;
                    rgParamBindInfo[2].bScale = 0;

                    // Add ConfigPath to parameters
                    rgParamOrdinals[3] = 4;
                    rgParamBindInfo[3].pwszDataSourceType = L"DBTYPE_WVARCHAR";
                    rgParamBindInfo[3].pwszName = L"@vc_config_path";
                    rgParamBindInfo[3].ulParamSize = 255;
                    rgParamBindInfo[3].dwFlags = DBPARAMFLAGS_ISINPUT;
                    rgParamBindInfo[3].bPrecision = 0;
                    rgParamBindInfo[3].bScale = 0;
                    
                    // Add Parameter Bindings
                    hr = pICommandWithParameters->SetParameterInfo(nParams, rgParamOrdinals, rgParamBindInfo);
                    if (SUCCEEDED(hr))
                    {
                        // Create Param Accessor Struct and set defaults
                        DBBINDING rgParamBindings[nParams];
                        InitBindings(rgParamBindings, nParams);

                        // Return Value
                        rgParamBindings[0].obValue    = offsetof(ASCPARAMS, lReturnValue);
                        rgParamBindings[0].eParamIO   = DBPARAMIO_OUTPUT;
                        rgParamBindings[0].cbMaxLen   = sizeof(long);
                        rgParamBindings[0].wType      = DBTYPE_I4;
                        rgParamBindings[0].bPrecision = 11;

                        // Database
                        rgParamBindings[1].dwPart  |= DBPART_STATUS;
                        rgParamBindings[1].obStatus = offsetof(ASCPARAMS, hrDatabase);
                        rgParamBindings[1].obValue  = offsetof(ASCPARAMS, wszDatabase);
                        rgParamBindings[1].eParamIO = DBPARAMIO_INPUT;
                        rgParamBindings[1].cbMaxLen = sizeof(wchar_t) * MAX_CCH_DB_PARAM;
                        rgParamBindings[1].wType    = DBTYPE_WSTR;

                        // Server
                        rgParamBindings[1].dwPart  |= DBPART_STATUS;
                        rgParamBindings[1].obStatus = offsetof(ASCPARAMS, hrServer);
                        rgParamBindings[2].obValue  = offsetof(ASCPARAMS, wszServer);
                        rgParamBindings[2].eParamIO = DBPARAMIO_INPUT;
                        rgParamBindings[2].cbMaxLen = sizeof(wchar_t) * MAX_CCH_SERVER_PARAM;
                        rgParamBindings[2].wType    = DBTYPE_WSTR;

                        // Path
                        rgParamBindings[1].dwPart  |= DBPART_STATUS;
                        rgParamBindings[1].obStatus = offsetof(ASCPARAMS, hrPath);
                        rgParamBindings[3].obValue  = offsetof(ASCPARAMS, wszPath);
                        rgParamBindings[3].eParamIO = DBPARAMIO_INPUT;
                        rgParamBindings[3].cbMaxLen = sizeof(wchar_t) * MAX_CCH_PATH_PARAM;
                        rgParamBindings[3].wType    = DBTYPE_WSTR;

                        // Get Accessor
                        IAccessor *pIAccessorIn;
                        hr = pICommandText->QueryInterface(IID_IAccessor, (void **)&pIAccessorIn);
                        if (SUCCEEDED(hr))
                        {
                            // Create Accessor
                            HACCESSOR hAccessorIn;
                            hr = pIAccessorIn->CreateAccessor(
                                DBACCESSOR_PARAMETERDATA
                              , nParams
                              , rgParamBindings
                              , sizeof(ASCPARAMS)
                              , &hAccessorIn
                              , NULL
                            );
                            if (SUCCEEDED(hr))
                            {
                                // Define Parameters
                                ASCPARAMS params;
                                StringCchCopyW( params.wszDatabase , MAX_CCH_DB_PARAM     , pcwszDatabase   );
                                StringCchCopyW( params.wszServer   , MAX_CCH_SERVER_PARAM , pcwszServer     );
                                StringCchCopyW( params.wszPath     , MAX_CCH_PATH_PARAM   , pcwszConfigPath );

                                // Indicate that all values are valid and should be read.
                                params.hrDatabase = params.hrPath = params.lReturnValue = S_OK;

                                // Store Paramters and Accessor and Execute Command
                                DBPARAMS dbpIn = {&params, 1, hAccessorIn};

                                LONG cNumRows;
                                IRowset *pIRowset;
                                
                                hr = pICommandText->Execute(
                                    NULL
                                  , IID_IRowset
                                  , &dbpIn
                                  , &cNumRows
                                  , (IUnknown **) &pIRowset
                                );
                                if (SUCCEEDED(hr))
                                {
                                    // RetVal not set until Rowset read or releaed!
                                    if (pIRowset) { pIRowset->Release(); }

                                    // No rowset(s) returned, only RetVal set...
                                    hr = (HRESULT) params.lReturnValue;
                                    if (SUCCEEDED(hr))
                                    {
                                        CMsiLogger::WriteMessage(
                                            MT_INFO
                                          , hr
                                          , L"Config Path Saved: '%s/%s' => %s"
                                          , pcwszServer
                                          , pcwszDatabase
                                          , pcwszConfigPath
                                        );
                                    }
                                    else
                                    {
                                        CMsiLogger::WriteMessage(
                                            MT_ERROR
                                          , L"Failed trying to save config path for '%s\\%s' to the database (%s)"
                                          , pcwszServer
                                          , pcwszDatabase
                                          , pcwszConfigPath
                                        );
                                    }
                                }
                                else if (DB_E_INTEGRITYVIOLATION == hr)
                                {
                                    CMsiLogger::WriteMessage(
                                        MT_WARNING
                                      , L"Config path for '%s\\%s' already exists in database (%s)."
                                      , pcwszServer
                                      , pcwszDatabase
                                      , pcwszConfigPath
                                    );

                                    hr = S_OK;
                                }
                                else
                                {
                                    CMsiLogger::WriteMessage(
                                        MT_ERROR
                                      , L"Error attempting to save config path for '%s\\%s' to the database (%s)."
                                      , pcwszServer
                                      , pcwszDatabase
                                      , pcwszConfigPath
                                    );
                                }
   
                                pIAccessorIn->ReleaseAccessor(hAccessorIn, NULL);
                            }

                            pIAccessorIn->Release();
                        }
                    }

                    pICommandWithParameters->Release();
                }
            }

            pICommandText->Release();
        }
    }

    return hr;
}

HRESULT ProcessDatabase(
    RCINSTALLSETTINGS settings
  , IUnknown *punkCcdb
  , LPCWSTR pcwszServer   , size_t cchServer
  , LPCWSTR pcwszDatabase , size_t cchDatabase
)
{
    HRESULT hr = E_FAIL;

    // Verify we are interested in this Database
    LPWSTR pwszCurrent;
    bool bDbIsInList = false;
    for ( int i = 0 ; NULL != (pwszCurrent = settings.rgwszDatabaseList[i]) ; ++i )
    {
        // StringCompare() returns S_OK on match, S_FALSE on no match
        hr = StringCompare(pwszCurrent, MAX_SETTING_CCH, pcwszDatabase, cchDatabase);
        if (S_OK == hr)
        {
            bDbIsInList = true;
            break;
        }
        else if (STRCMP_E_TOO_MANY_CHARACTERS == hr)
        {
            CMsiLogger::WriteMessage(
                MT_WARNING
              , L"Process Database: Attempted to match a string longer than %d characters"
              , cchDatabase
            );

            // We don't want this to cause our untimely death
            hr = S_OK;
        }
        else if (FAILED(hr))
        {
            CMsiLogger::WriteMessage(
                MT_ERROR
              , L"Process Database: StringCompare() failed"
            );
        }
        // else, simply not a match.  Nothing to do here.
    }
    
    if (bDbIsInList)
    {
        // Create Config File @ ConfigPath
        LPCWSTR pcwszConfigPath;
        size_t  cchConfigPath;

        hr = CreateConfigFile(
            settings
          , pcwszServer      , cchServer
          , pcwszDatabase    , cchDatabase
          , &pcwszConfigPath , &cchConfigPath
        );

        if (SUCCEEDED(hr))
        {
            // Instrument Database using Config File
            CMsiLogger::WriteMessage(
                MT_INFO
              , L"Instrumenting Database: %s\\%s with: %s"
              , pcwszServer
              , pcwszDatabase
              , pcwszConfigPath
            );

            hr = InstrumentDb(settings, pcwszConfigPath, cchConfigPath);
            if (SUCCEEDED(hr))
            {
                // Save Component to CCDB
                hr = AddSqlComponent(
                    punkCcdb
                  , pcwszServer     , cchServer
                  , pcwszDatabase   , cchDatabase
                  , pcwszConfigPath , cchConfigPath
                );
            }

            delete[] pcwszConfigPath;
        }
    }
    else
    {
        // If StringCchCompare() found no match, this still constitutes an 'S_OK'
        // as far as the rest of the code goes, no need to muddy the waters
        // with an 'S_FALSE'

        hr = S_OK;
    }

    return hr;
}

DWORD InternalInstall(RCINSTALLSETTINGS settings)
{
    HRESULT hr;

    CMsiLogger::WriteMessage(MT_INFO, L"Entering Install");

    // Open npdb
    IUnknown *punkNpdb;
    hr = SqlOpenConnection(settings.pwszNpdbServer, L"npdb", &punkNpdb);
    if (SUCCEEDED(hr))
    {
        // Get DB Server <=> DB Mappings from NPDB
        dbmap_t *pDbMappings = NULL;
        size_t cDbMappings   = 0;
        hr = GetDbMappingsFromNpdb(punkNpdb, &pDbMappings, &cDbMappings);
        if (SUCCEEDED(hr))
        {
            // Open ccdb
            IUnknown *punkCcdb;
            hr = SqlOpenConnection(settings.pwszCcdbServer, L"ccdb", &punkCcdb);
            if (SUCCEEDED(hr))
            {
                for (size_t i = 0; i < cDbMappings; ++i)
                {
                    CMsiLogger::WriteMessage(
                        MT_INFO
                      , L"Processing Database %d of %d (%s\\%s)"
                      , i + 1
                      , cDbMappings
                      , pDbMappings[i].pwszServer
                      , pDbMappings[i].pwszDatabase
                    );

                    hr = ProcessDatabase(
                        settings
                      , punkCcdb
                      , pDbMappings[i].pwszServer   , pDbMappings[i].cchServer
                      , pDbMappings[i].pwszDatabase , pDbMappings[i].cchDatabase
                    );
                    if (FAILED(hr))
                    {
                        // If we couldn't process the database, it's time to die.
                        break;
                    }
                }

                punkCcdb->Release();
            }
            else
            {
                CMsiLogger::WriteMessage(
                    MT_ERROR
                  , L"Couldn't connect to %s\\ccdb"
                  , settings.pwszNpdbServer
                );
            }

            delete[] pDbMappings;
        }
        else
        {
            CMsiLogger::WriteMessage(
                MT_ERROR
              , L"Couldn't get database mappings from %s\\npdb"
              , settings.pwszNpdbServer
            );
        }

        punkNpdb->Release();
    }
    else
    {
        CMsiLogger::WriteMessage(
            MT_ERROR
          , L"Couldn't connect to %s\npdb"
          , settings.pwszNpdbServer
        );
    }

    CMsiLogger::WriteMessage(MT_INFO, L"Exiting Install, hr = 0x%08X", hr);

    return HRESULT_CODE(hr);
}

//////////////////////////////////////////////////////////////////////////////////
// Test Hooks
//
#ifdef TEST_HOOKS

HRESULT GetDbMappingsFromNpdbTest(IUnknown *punkConnection, thdbmap_t **ppDbMappings, size_t *pcDbMappings)
{
    return GetDbMappingsFromNpdb(
        punkConnection
      , (dbmap_t **)ppDbMappings
      , pcDbMappings
    );
}

HRESULT AddSqlComponentTest(
    IUnknown *punkCcdb
  , LPCWSTR pcwszServer     , size_t cchServer
  , LPCWSTR pcwszDatabase   , size_t cchDatabase
  , LPCWSTR pcwszConfigPath , size_t cchConfigPath
)
{
    return AddSqlComponent(
        punkCcdb
      , pcwszServer     , cchServer
      , pcwszDatabase   , cchDatabase
      , pcwszConfigPath , cchConfigPath
    );
}

HRESULT InstrumentDbTest(LPCWSTR pcwszConfigPath, size_t cchConfigPath)
{
    return InstrumentDb(
        pcwszConfigPath
      , cchConfigPath
    );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\codecoverage\octopus\SqlHelper\SqlConnection.h ===
#pragma once

class CSqlCommand;.

class CSqlConnection
{
public:
    CSqlConnection(LPCWSTR pcwszConnectionString);
    virtual ~CSqlConnection(void);

    HRESULT Connect();
    HRESULT Disconnect();

    operator IUnknown *()
    {
        return m_punkConnection;
    }

private:
    LPWSTR m_pwszConnectionString;
    IUnknown *m_punkConnection;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\codecoverage\octopus\SqlHelper\sqlnclih.h ===
#pragma once

#ifndef ARRAYLEN
#define ARRAYLEN(a) ( sizeof(a) / sizeof(a[0]) )
#endif

HRESULT SqlOpenConnection(LPCWSTR pcwszConnectionString, IUnknown **ppunkConnection);
HRESULT SqlOpenConnection(LPCWSTR pcwszServer, LPWSTR pcwszDatabase, IUnknown **ppunkConnection);

HRESULT SqlCreateCommand(IUnknown *punkConnection, const IID &riid, IUnknown **ppunkCommand);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\codecoverage\octopus\SqlHelper\sqlnclih.cpp ===
#include "StdAfx.h"
#include "sqlnclih.h"

HRESULT SqlOpenConnection(LPCWSTR pcwszConnectionString, IUnknown **ppunkConnection)
{
    HRESULT hr;

    IDBInitialize *pIDBInitialize = NULL;
    hr = CoCreateInstance(
        CLSID_SQLNCLI,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IDBInitialize,
        (void **)&pIDBInitialize
    );

    if (SUCCEEDED(hr))
    {
        IDBProperties *pIDBProperties;
        hr = pIDBInitialize->QueryInterface(IID_IDBProperties, (void **)&pIDBProperties);
        if (SUCCEEDED(hr))
        {
            // See DBPROP structure for more information on InitProperties
            DBPROP rgInitProperties[1];
            for (int i = 0; i < ARRAYLEN(rgInitProperties); ++i)
            {
                VariantInit(&rgInitProperties[i].vValue);
            }

            // Connection String
            rgInitProperties[0].dwPropertyID   = DBPROP_INIT_PROVIDERSTRING;
            rgInitProperties[0].vValue.vt      = VT_BSTR;
            rgInitProperties[0].vValue.bstrVal = SysAllocString(pcwszConnectionString);
            rgInitProperties[0].dwOptions      = DBPROPOPTIONS_REQUIRED;
            rgInitProperties[0].colid          = DB_NULLID;

            // Construct the DBPROPSET structure
            // This structure is used to pass an array of DBPROP structures to the SetProperties method.
            DBPROPSET rgInitPropSet[1];
            rgInitPropSet[0].guidPropertySet = DBPROPSET_DBINIT;
            rgInitPropSet[0].cProperties     = ARRAYLEN(rgInitProperties);
            rgInitPropSet[0].rgProperties    = rgInitProperties;

            hr = pIDBProperties->SetProperties(1, rgInitPropSet);
            if ( SUCCEEDED(hr) && hr != DB_S_ERRORSOCCURRED )
            {
                hr = pIDBInitialize->Initialize();
                if ( SUCCEEDED(hr) && hr != DB_S_ERRORSOCCURRED )
                {
                    *ppunkConnection = pIDBInitialize;
                    (*ppunkConnection)->AddRef();
                }
            }

            // Clean up the memory used by the property variants
            for (int i = 0; i < ARRAYLEN(rgInitProperties); ++i)
            {
                VariantClear(&rgInitProperties[i].vValue);
            }

            pIDBProperties->Release();
        }

        pIDBInitialize->Release();
    }

    return hr;
}

HRESULT SqlOpenConnection(LPCWSTR pcwszServer, LPWSTR pcwszDatabase, IUnknown **ppunkConnection)
{
    HRESULT hr;

    static LPCWSTR      pcwszConnectionFormat = L"Server=%s;Database=%s;Trusted_Connection=yes";
    static const size_t cchConnectionFormat   = wcslen(pcwszConnectionFormat);

    size_t cchServer;
    hr = StringCchLengthW(pcwszServer, 80, &cchServer);
    if (SUCCEEDED(hr))
    {
        size_t cchDatabase;
        hr = StringCchLength(pcwszServer, 80, &cchDatabase);
        if (SUCCEEDED(hr))
        {
            size_t cchConnectionString = cchConnectionFormat + cchServer + cchDatabase + 1;
            LPWSTR pwszConnectionString = new wchar_t[cchConnectionString];
            if (NULL != pwszConnectionString)
            {
                hr = StringCchPrintfW(
                    pwszConnectionString
                  , cchConnectionString
                  , pcwszConnectionFormat
                  , pcwszServer
                  , pcwszDatabase
                );
                
                if (SUCCEEDED(hr))
                {
                    hr = SqlOpenConnection(pwszConnectionString, ppunkConnection);
                }

                delete[] pwszConnectionString;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    return hr;
}

HRESULT SqlCreateCommand(IUnknown *punkConnection, const IID &riid, IUnknown **ppunkCommand)
{
    HRESULT hr;

    IDBCreateSession *pIDBCreateSession;
    hr = punkConnection->QueryInterface(IID_IDBCreateSession, (void **)&pIDBCreateSession);
    if (SUCCEEDED(hr))
    {
        IDBCreateCommand *pIDBCreateCommand;
        hr = pIDBCreateSession->CreateSession(
            NULL
          , IID_IDBCreateCommand
          , (IUnknown **)&pIDBCreateCommand
        );

        if (SUCCEEDED(hr))
        {
            hr = pIDBCreateCommand->CreateCommand(
                NULL
              , riid
              , ppunkCommand
            );

            pIDBCreateCommand->Release();
        }

        pIDBCreateSession->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\codecoverage\octopus\SqlHelper\SqlHelper.cpp ===
// SqlHelper.cpp : Defines the entry point for the DLL application.
//

#include "stdafx.h"
#include "..\common\msisupport.h"
#include "internal.h"

#include "MsiLogger.h"

DWORD GetValueForKey(LPCWSTR pcwszKeyValueList, LPCWSTR pcwszKey, LPWSTR *ppwszValue);
DWORD GetValueForKey(LPCWSTR pcwszKeyValueList, LPCWSTR pcwszKey, LPWSTR *ppwszValue, size_t *pcchValue);
DWORD TokenizeList(LPWSTR pwszList, LPWSTR pwszSeperators, LPWSTR **prgwszTokens);

extern "C"
{
    #pragma comment(linker, "/EXPORT:Install=_Install@4")
    UINT _stdcall Install(MSIHANDLE hInstall)
    {
        CMsiLogger::Init(hInstall);

        LPWSTR pwszKeyValueList;
        DWORD  cchKeyValueList;

        CMsiLogger::WriteMessage(MT_INFO, L"Getting CustomActionData");

        UINT ev = GetPropertyValue(hInstall, L"CustomActionData", &pwszKeyValueList, &cchKeyValueList);
        if (ERROR_SUCCESS == ev)
        {
            INSTALLSETTINGS settings;

            CMsiLogger::WriteMessage(MT_INFO, L"Parsing CustomActionData: %s", pwszKeyValueList);

            ev = GetValueForKey(pwszKeyValueList, L"SqlToolsDir", &settings.pwszSqlToolsDir);
            if (ERROR_SUCCESS == ev)
            {
                CMsiLogger::WriteMessage(MT_INFO, L"* SqlToolsDir = '%s'", settings.pwszSqlToolsDir);

                ev = GetValueForKey(pwszKeyValueList, L"NpdbServer", &settings.pwszNpdbServer);
                if (ERROR_SUCCESS == ev)
                {
                    CMsiLogger::WriteMessage(MT_INFO, L"* NpdbServer = '%s'", settings.pwszNpdbServer);

                    ev = GetValueForKey(pwszKeyValueList, L"CcdbServer", &settings.pwszCcdbServer);
                    if (ERROR_SUCCESS == ev)
                    {
                        CMsiLogger::WriteMessage(MT_INFO, L"* CcdbServer = '%s'", settings.pwszCcdbServer);

                        ev = GetValueForKey(
                            pwszKeyValueList
                          , L"ConfigShare"
                          , &settings.pwszConfigShare
                          , &settings.cchConfigShare
                        );
                        if (ERROR_SUCCESS == ev)
                        {
                            CMsiLogger::WriteMessage(MT_INFO, L"* ConfigShare = '%s'", settings.pwszConfigShare);

                            ev = GetValueForKey(pwszKeyValueList, L"DbName", &settings.pwszReportingDatabase);
                            if (ERROR_SUCCESS == ev)
                            {
                                CMsiLogger::WriteMessage(MT_INFO, L"* DbName = '%s'", settings.pwszReportingDatabase);

                                ev = GetValueForKey(pwszKeyValueList, L"DbServer", &settings.pwszReportingServer);
                                if (ERROR_SUCCESS == ev)
                                {
                                    CMsiLogger::WriteMessage(MT_INFO, L"* DbServer = '%s'", settings.pwszReportingServer);

                                    ev = GetValueForKey(pwszKeyValueList, L"BuildVersion", &settings.pwszCustomBuildVersion);
                                    if (ERROR_SUCCESS == ev)
                                    {
                                        CMsiLogger::WriteMessage(MT_INFO, L"* BuildVersion = '%s'", settings.pwszCustomBuildVersion);

                                        ev = GetValueForKey(
                                            pwszKeyValueList
                                          , L"TraceShare"
                                          , &settings.pwszTraceShare
                                          , &settings.cchTraceShare
                                        );
                                        if (ERROR_SUCCESS == ev)
                                        {
                                            CMsiLogger::WriteMessage(MT_INFO, L"* TraceShare = '%s'", settings.pwszTraceShare);

                                            ev = GetValueForKey(
                                                pwszKeyValueList
                                              , L"ComponentShare"
                                              , &settings.pwszComponentShare
                                              , &settings.cchComponetShare
                                            );
                                            if (ERROR_SUCCESS == ev)
                                            {
                                                CMsiLogger::WriteMessage(MT_INFO, L"* ComponentShare = '%s'", settings.pwszComponentShare);

                                                LPWSTR pwszDatabaseList;
                                                ev = GetValueForKey(pwszKeyValueList, L"DbList", &pwszDatabaseList);
                                                if (ERROR_SUCCESS == ev)
                                                {
                                                    CMsiLogger::WriteMessage(MT_INFO, L"* DbList = '%s'", pwszDatabaseList);

                                                    ev = TokenizeList(pwszDatabaseList, L",", &settings.rgwszDatabaseList);
                                                    if (ERROR_SUCCESS == ev)
                                                    {
                                                        LPWSTR * ppwszDatabase = settings.rgwszDatabaseList;
                                                        while(NULL != *ppwszDatabase)
                                                        {
                                                            CMsiLogger::WriteMessage(MT_INFO, L"\t- %s", *ppwszDatabase);
                                                            ++ppwszDatabase;
                                                        }

                                                        ev = InternalInstall(settings);

                                                        // Deleteing an array of strings (arrays)...
                                                        // Array is NULL-terminated
                                                        for (int i = 0; settings.rgwszDatabaseList[i] != NULL; ++i)
                                                        {
                                                            delete[] settings.rgwszDatabaseList[i];
                                                        }

                                                        delete[] settings.rgwszDatabaseList;
                                                    }

                                                    delete[] pwszDatabaseList;
                                                }

                                                delete[] settings.pwszComponentShare;
                                            }

                                            delete[] settings.pwszTraceShare;
                                        }

                                        delete[] settings.pwszCustomBuildVersion;
                                    }

                                    delete[] settings.pwszReportingDatabase;
                                }

                                delete[] settings.pwszReportingServer;
                            }

                            delete[] settings.pwszConfigShare;
                        }

                        delete[] settings.pwszCcdbServer;
                    }

                    delete[] settings.pwszNpdbServer;
                }

                delete[] settings.pwszSqlToolsDir;
            }

            delete[] pwszKeyValueList;
        }

        CMsiLogger::Close();

        return ev;
    }

    #pragma comment(linker, "/EXPORT:Uninstall=_Uninstall@4")
    UINT _stdcall Uninstall(MSIHANDLE hInstall)
    {
        (void *)&hInstall;

        return ERROR_INVALID_FUNCTION;
    }

    #pragma comment(linker, "/EXPORT:Rollback=_Rollback@4")
    UINT _stdcall Rollback(MSIHANDLE hInstall)
    {
        (void *)&hInstall;

        return ERROR_INVALID_FUNCTION;
    }
}

DWORD GetValueForKey(LPCWSTR pcwszKeyValueList, LPCWSTR pcwszKey, LPWSTR *ppwszValue)
{
    size_t cch;
    return GetValueForKey(pcwszKeyValueList, pcwszKey, ppwszValue, &cch);
}

DWORD GetValueForKey(LPCWSTR pcwszKeyValueList, LPCWSTR pcwszKey, LPWSTR *ppwszValue, size_t *pcchValue)
{
    DWORD ev = ERROR_INVALID_PARAMETER;

    bool fDone  = false;

    int idxCur = 0;
    int idxKey = 0;

    int idxValueStart = -1;

    enum STATE {
        STATE_LFK   // Looking for Key
      , STATE_PKM   // Possible Key Match
      , STATE_KM    // Key Match
      , STATE_IV    // In Value
      , STATE_VE    // Value End
      , STATE_NKM   // No Key Match
    } state = STATE_LFK;

    while (!fDone && pcwszKeyValueList[idxCur] != L'\0')
    {
        switch (state)
        {
        case STATE_LFK:
            if (pcwszKeyValueList[idxCur] == pcwszKey[idxKey])
            {
                state = STATE_PKM;
            }
            break;

        case STATE_PKM:
            ++idxKey;

            if (pcwszKeyValueList[idxCur] != pcwszKey[idxKey])
            {
                if ( pcwszKey[idxKey] == L'\0' && pcwszKeyValueList[idxCur] == L'=' )
                {
                    state = STATE_KM;
                }
                else
                {
                    idxKey = 0;
                    state = STATE_LFK;
                }
            }
            break;

        case STATE_KM:
            idxValueStart = idxCur;

            state = STATE_IV;
            // Fall-Through
            //
        case STATE_IV:
            if (pcwszKeyValueList[idxCur] == L';')
            {
                // Decriment to offset the garunteed
                // increment at the end of this loop.
                --idxCur;

                fDone = true;
            }

            break;
        }

        ++idxCur;
    }

    size_t cchValue = 0;
    LPWSTR pwszValue = NULL;
    if ( STATE_KM == state )
    {
        // Empty value at EOL
        ev = ERROR_NO_DATA;
    }
    else if ( STATE_IV == state )
    {
        ev = ERROR_NO_DATA;

        // Let the character be character we terminated on
        // (either the L';' or L'\0') and compute the count of characters.
        // The terminating character will be replaced with L'\0'
        cchValue = idxCur - idxValueStart + 1;

        // Make sure the string is more than just a terminating character
        if (cchValue > 1)
        {
            ev = ERROR_OUTOFMEMORY;
            pwszValue = new WCHAR[cchValue];
            if (NULL != pwszValue)
            {
                // Copy value to new string, minus the terminating character
                for (size_t i = 0; i < cchValue - 1; ++i)
                {
                    pwszValue[i] = pcwszKeyValueList[idxValueStart + i];
                }

                // Terminate the string properly
                pwszValue[cchValue - 1] = L'\0';

                ev = ERROR_SUCCESS;
            }
        }
    }

    *ppwszValue = pwszValue;
    *pcchValue  = cchValue;

    return ev;
}

DWORD TokenizeList(LPWSTR pwszList, const LPWSTR pcwszSeperators, LPWSTR **prgwszTokens)
{
	// NULL the output as a safety measure
	*prgwszTokens = NULL;

    size_t cchList;
    HRESULT hr = StringCchLengthW(pwszList, 65 + 1, &cchList);
    if (SUCCEEDED(hr) && cchList > 0)
    {
		++cchList;
        LPWSTR pwszTokenString = new wchar_t[cchList];

        hr = StringCchCopyW(pwszTokenString, cchList, pwszList);
        if (SUCCEEDED(hr))
        {
            // since each entry has to be seperated with a ',', the max
            // number of entries (each of length 1) is half the number of
            // characters in the string.
            size_t cTokens = cchList/2;
            LPWSTR *rgwszTokens = new LPWSTR[cTokens + 1];
            if (NULL != rgwszTokens)
            {
                size_t idxToken = 0;

                wchar_t *context = NULL;
                wchar_t *token = wcstok_s(pwszTokenString, pcwszSeperators, &context);

                while (SUCCEEDED(hr) && idxToken < cTokens && NULL != token)
                {
                    rgwszTokens[idxToken] = token;

                    token = wcstok_s(NULL, pcwszSeperators, &context);
                    ++idxToken;
                }

				// Allocate minimum space needed and copy to output
				*prgwszTokens = new LPWSTR[idxToken + 1];
				for (size_t i = 0; i < idxToken; ++i)
				{
                    LPWSTR token = rgwszTokens[i];

                    // We have to copy the token into the array and free it here
                    // because to do otherwise breaks the delete[] pattern used
                    // everywhere else in the code.
                    size_t cchToken;
                    HRESULT hrInt = StringCchLength(token, 255, &cchToken);
                    if (SUCCEEDED(hr))
                    {
                        // Leave room for the trailing L'\0'
                        ++cchToken;
                        
                        // Allocate room and copy the token into the array
					    (*prgwszTokens)[i] = new wchar_t[cchToken];
                        hrInt = StringCchCopy((*prgwszTokens)[i], cchToken, token);
                    }

                    // Bail from the loop on a failure
                    if (FAILED(hr))
                    {
                        break;
                    }
				}

                // Terminate the array with a NULL pointer
                (*prgwszTokens)[idxToken] = NULL;

				// Free temp var.
				delete[] rgwszTokens;
            }
        }
    }

    return HRESULT_CODE(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\codecoverage\octopus\SqlHelper\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
// SqlHelper.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\codecoverage\octopus\SqlHelper\StringResources.h ===
#pragma once

extern const wchar_t * gc_pcwszSqlGetDbServersCommand;
extern const wchar_t * gc_pcwszConfigFormat;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\codecoverage\octopus\SqlHelper\stdafx.h ===
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

// Modify the following defines if you have to target a platform prior to the ones specified below.
// Refer to MSDN for the latest info on corresponding values for different platforms.
#ifndef WINVER				// Allow use of features specific to Windows XP or later.
#define WINVER 0x0501		// Change this to the appropriate value to target other versions of Windows.
#endif

#ifndef _WIN32_WINNT		// Allow use of features specific to Windows XP or later.                   
#define _WIN32_WINNT 0x0501	// Change this to the appropriate value to target other versions of Windows.
#endif						

#ifndef _WIN32_WINDOWS		// Allow use of features specific to Windows 98 or later.
#define _WIN32_WINDOWS 0x0410 // Change this to the appropriate value to target Windows Me or later.
#endif

#ifndef _WIN32_IE			// Allow use of features specific to IE 6.0 or later.
#define _WIN32_IE 0x0600	// Change this to the appropriate value to target other versions of IE.
#endif

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <stddef.h>


// Windows Header Files:
#include <windows.h>


// Safe String Functions //
#include <strsafe.h>


// Windows Installer //
#include <msi.h>
#include <msiquery.h>


// SQL Native Client (OLEDB) //
#define _SQLNCLI_OLEDB_
#include <sqlncli.h>
#include <oledberr.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\codecoverage\octopus\SqlHelper\StringResources.cpp ===
#include "stdafx.h"
#include "StringResources.h"

const wchar_t * gc_pcwszSqlGetDbServersCommand = L"\
select s.vc_server, i.vc_dbname\n\
from t_servers s\n\
inner join t_server_type_interfaces sti\n\
on s.vc_server_type = sti.vc_server_type\n\
inner join t_interfaces i\n\
on sti.vc_interface = i.vc_interface\n\
inner join t_environments e\n\
on s.vc_environment = e.vc_environment\n\
where i.vc_dbname is not null and e.b_current = 1\n\
and s.vc_server_state = 'online'\n\
group by s.vc_server, i.vc_dbname\
";

const wchar_t * gc_pcwszConfigFormat = L"\
<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n\
<SqlccComponent\n\
  xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"\n\
  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\
  xmlns=\"http://schemas.microsoft.com/test/sql/sqlcc/v3.0\"\n\
>\n\
  <ComponentName>%s</ComponentName>\n\
  <CustomVersion>%s</CustomVersion>\n\
  <ComponentShare>%s</ComponentShare>\n\
  <ReportingDatabase>\n\
    <ServerName>%s</ServerName>\n\
    <DatabaseName>%s</DatabaseName>\n\
    <UserName />\n\
    <UserPassword />\n\
    <Type>Sqlcc</Type>\n\
  </ReportingDatabase>\n\
  <Database>\n\
    <ServerName>%s</ServerName>\n\
    <DatabaseName>[%s]</DatabaseName>\n\
    <UserName />\n\
    <UserPassword />\n\
    <TraceShare>%s</TraceShare>\n\
  </Database>\n\
</SqlccComponent>\
";
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\codecoverage\octopus\SqlHelper\test_internal.h ===
#pragma once
#define TEST_HOOKS

#define TH_MAX_SETTING_CCH (65 + 1)

typedef struct thdbmap_s {

    wchar_t pwszDatabase[TH_MAX_SETTING_CCH];
    size_t  cchDatabase;

    wchar_t pwszServer[TH_MAX_SETTING_CCH];
    size_t  cchServer;

} thdbmap_t;


extern "C"
{
    #pragma comment(linker, "/EXPORT:GetDbMappingsFromNpdbTest=_GetDbMappingsFromNpdbTest@12")
    HRESULT GetDbMappingsFromNpdbTest(
        IUnknown   * punkConnection
      , thdbmap_t ** ppDbMappings
      , size_t     * pcDbMappings
    );

    #pragma comment(linker, "/EXPORT:AddSqlComponentTest=_AddSqlComponentTest@24")
    HRESULT AddSqlComponentTest(
        IUnknown * punkCcdb
      , LPCWSTR    pcwszServer     , size_t cchServer
      , LPCWSTR    pcwszDatabase   , size_t cchDatabase
      , LPCWSTR    pcwszConfigPath , size_t cchConfigPath
    );

    #pragma comment(linker, "/EXPORT:InstrumentDbTest=_InstrumentDbTest@8")
    HRESULT InstrumentDbTest(
        LPCWSTR pcwszConfigPath
      , size_t  cchConfigPath
    );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\codecoverage\octopus\SqlValidation\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
// SqlValidation.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\codecoverage\plugin\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\codecoverage\octopus\SqlValidation\stdafx.h ===
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

// Modify the following defines if you have to target a platform prior to the ones specified below.
// Refer to MSDN for the latest info on corresponding values for different platforms.
#ifndef WINVER				// Allow use of features specific to Windows XP or later.
#define WINVER 0x0501		// Change this to the appropriate value to target other versions of Windows.
#endif

#ifndef _WIN32_WINNT		// Allow use of features specific to Windows XP or later.                   
#define _WIN32_WINNT 0x0501	// Change this to the appropriate value to target other versions of Windows.
#endif						

#ifndef _WIN32_WINDOWS		// Allow use of features specific to Windows 98 or later.
#define _WIN32_WINDOWS 0x0410 // Change this to the appropriate value to target Windows Me or later.
#endif

#ifndef _WIN32_IE			// Allow use of features specific to IE 6.0 or later.
#define _WIN32_IE 0x0600	// Change this to the appropriate value to target other versions of IE.
#endif

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
// Windows Header Files:
#include <windows.h>



#include <msi.h>
#include <msiquery.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\codecoverage\octopus\SqlValidation\SqlValidation.cpp ===
// SqlValidation.cpp : Defines the entry point for the DLL application.
//

#include "stdafx.h"
#include "..\common\msisupport.h"

UINT CALLBACK VerifySqlElement(MSIHANDLE hInstall, LPWSTR pwszPropertyName);
UINT CALLBACK EscapeSqlString(MSIHANDLE hInstall, LPWSTR pwszPropertyName);

extern "C"
{
    // [IN] SQLELEMENTS
    #pragma comment(linker, "/EXPORT:VerifySqlElements=_VerifySqlElements@4")
    UINT _stdcall VerifySqlElements(MSIHANDLE hInstall)
    {
        UINT ret = ForEachPropertyInList(hInstall, L"SQLELEMENTS", (PropertyAction)VerifySqlElement);
        return ret;
    }

    // [IN] SQLSTRINGS
    #pragma comment(linker, "/EXPORT:EscapeSqlStrings=_EscapeSqlStrings@4")
    UINT _stdcall EscapeSqlStrings(MSIHANDLE hInstall)
    {
        MsiSetPropertyW(hInstall, L"ESS", L"0");

        UINT ret = ForEachPropertyInList(hInstall, L"SQLSTRINGS", (PropertyAction)EscapeSqlString);

        wchar_t errorcode[25];
        wsprintfW(errorcode, L"%d", ret);

        MsiSetPropertyW(hInstall, L"ESS", errorcode);

        return ret;
    }
}

UINT CALLBACK EscapeSqlString(MSIHANDLE hInstall, LPWSTR pwszPropertyName)
{
    LPWSTR pwszSqlStringIn = NULL;
    DWORD cchSqlStringIn = 0;

    UINT ret = GetPropertyValue(hInstall, pwszPropertyName, &pwszSqlStringIn, &cchSqlStringIn);
    if (ERROR_SUCCESS == ret)
    {
        LPWSTR pwszSqlStringOut = new wchar_t[cchSqlStringIn*2+1];
        if (NULL != pwszSqlStringOut)
        {
            DWORD idxOut = 0;
            for(DWORD idxIn = 0; idxIn < cchSqlStringIn; ++idxIn)
            {
                if (pwszSqlStringIn[idxIn] == L'\'')
                {
                    // Escape the single quote.
                    pwszSqlStringOut[idxOut++] = L'\'';
                }

                pwszSqlStringOut[idxOut++] = pwszSqlStringIn[idxIn];
            }

            // Verify null-termination of string
            pwszSqlStringOut[idxOut] = L'\0';

            ret = MsiSetPropertyW(hInstall, pwszPropertyName, pwszSqlStringOut);

            delete[] pwszSqlStringOut;
        }

        delete[] pwszSqlStringIn;
    }

    return ret;
}

UINT CALLBACK VerifySqlElement(MSIHANDLE hInstall, LPWSTR pwszPropertyName)
{
    LPWSTR pwszSqlElement = NULL;
    DWORD cchSqlElement = 0;

    UINT ret = GetPropertyValue(hInstall, pwszPropertyName, &pwszSqlElement, &cchSqlElement);
    if (ERROR_SUCCESS == ret)
    {
        ret = ERROR_INVALID_DATA;
        DWORD idxElement = 0;

        // Accept variable names...
        if ( pwszSqlElement[idxElement] == L'@' )
        {
            ++idxElement;
        }


        if ( iswalpha(pwszSqlElement[idxElement]) )
        {
            for(/* idxElement */; idxElement < cchSqlElement; ++idxElement)
            {
                if ( !iswalnum(pwszSqlElement[idxElement]) )
                {
                    break;
                }
            }

            // If the for-loop caught invalid data, we'll never
            // reach this point.
            ret = ERROR_SUCCESS;
        }
    }

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\codecoverage\plugin\Coverage.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Net;

using System.ComponentModel;
using System.Diagnostics;

using System.Text.RegularExpressions;
using System.IO;

using ServerTestFramework;
using ServerTestFramework.LiveService;

using xonline.common.config;

namespace CodeCoverage
{
    internal static class SystemErrorCode
    {
        public const int FILE_NOT_FOUND = 9009;
    }

    internal class CoverageExecutionException : Exception
    {
        private string _args;
        private Dictionary<string, int> _errors;

        public CoverageExecutionException(string args)
            :this(args, new Dictionary<string,int>())
        { }

        public CoverageExecutionException(string args, string server, 
                                          int error)
        {
            _args = args;

            _errors = new Dictionary<string, int>();
            _errors[server] = error;
        }

        public CoverageExecutionException(string args, 
                                          Dictionary<string, int> errors)
        {
            _errors = errors;
            _args = args;
        }

        public override string Message
        {
            get
            {
                return String.Format(
                    "CoverCmd({0}) failed on the following server{1}:\n{2}"
                  , _args
                  , _errors.Count > 1 ? "s" : String.Empty
                  , ErrorsToString()
                );
            }
        }

        public Dictionary<string, int> Errors
        {
            get
            {
                return _errors;
            }
        }

        private string ErrorsToString()
        {
            StringBuilder sb = new StringBuilder();

            foreach (KeyValuePair<string, int> kvp in _errors)
            {
                sb.Append(String.Format("Server: {0}, ErrorCode 0x{1:X8} " +
                                        "({1})\n", kvp.Key, kvp.Value));
            }

            return sb.ToString();
        }
    }

    internal interface ICoverageCollector
    {
        void Initialize(String runId);

        void Start(string traceName);

        void Close();

        void Reset();

        void Save();

        void Import();

        bool SupportsSaveToFile{get;}
        void SaveToFile(string fileName);
    }

    internal class CoverageManager
    {
        private List<ICoverageCollector> _collectors = 
        new List<ICoverageCollector>();
        
        public int CollectorCount
        {
            get
            {
                return _collectors.Count;
            }
        }

        private int _savedTraceCount;
        public int SavedTraceCount
        {
            get
            {
                return _savedTraceCount;
            }
        }

        private bool _isSaved = false;
        private bool _isClosed = false;
        private bool _isCollecting = false;
        public bool IsCollecting
        {
            get
            {
                return _isCollecting;
            }
        }

        public CoverageManager()
        {
            ResetTraceCount();
        }

        public CoverageManager(ICoverageCollector[] collectors)
        {
            _collectors.AddRange(collectors);
            ResetTraceCount();
        }

        public void AddCollector(ICoverageCollector collector)
        {
            _collectors.Add(collector);
        }

        public void AddCollectors(params ICoverageCollector[] collectors)
        {
            _collectors.AddRange(collectors);
        }

        public void RemoveCollector(ICoverageCollector collector)
        {
            _collectors.Remove(collector);
        }

        public void ClearCollectors()
        {
            _collectors.Clear();
        }

        public void ResetTraceCount()
        {
            _savedTraceCount = 0;
        }

        public void Initialize()
        {
            Guid runId = Guid.NewGuid();           
            foreach (ICoverageCollector collector in _collectors)
            {
                collector.Initialize(runId.ToString());
            }
        }

        public void Start(string traceName)
        {
            if (_isCollecting || _isClosed)
            {
                throw new InvalidOperationException();
            }

            _isCollecting = true;

            foreach (ICoverageCollector collector in _collectors)
            {
                collector.Start(traceName);
            }
            
        }

        public void Reset()
        {
            if (!_isCollecting)
            {
                throw new InvalidOperationException();
            }

            foreach (ICoverageCollector collector in _collectors)
            {
                collector.Reset();
            }
        }

        public void Close()
        {
            if (!_isCollecting)
            {
                throw new InvalidOperationException();
            }

            foreach (ICoverageCollector collector in _collectors)
            {
                collector.Close();
            }

            _isCollecting = false;
            _isClosed = true;
        }

        public void Save()
        {
            if (!_isClosed)
            {
                throw new InvalidOperationException();
            }

            foreach (ICoverageCollector collector in _collectors)
            {
                collector.Save();
            }

            _isClosed = false;
            _isSaved = true; 

            ++_savedTraceCount;
        }

        public void Import()
        {
            if (!_isSaved)
            {
                throw new InvalidOperationException();
            }

            foreach (ICoverageCollector collector in _collectors)
            {
                collector.Import();
            }

            _isSaved = false;
        }

    }

    internal class MagellanCC : ICoverageCollector
    {
        public const String DEFAULT_DB_SERVER = "EDGE-SQL-01";
        public const String DEFAULT_DB_NAME = "Cov_Xonline";

        private static Report RO = new Report("Code Coverage > Magellan");

        private DbInfo _db;
        private List<string> _targets = new List<string>();

        private string _traceName;

        /// <summary>
        /// Create the ICoverageCollector for Magellan on this Environment.
        /// Do not execute if there is no valid environment.
        /// </summary>
        /// <returns>Magellan ICoverageCollector</returns>
        static public ICoverageCollector CreateCollector()
        {
            MagellanCC c = new MagellanCC();
            if (c._targets.Count == 0)
            {
                c = null;
            }

            return c;
        }

        private MagellanCC()
        {
            String output;
            
            if (SystemErrorCode.FILE_NOT_FOUND != 
                CCExecute(String.Empty, out output))
            {
                String dbServerUri = String.Empty;
                String dbName = String.Empty;

                try
                {
                    dbServerUri = Global.XEnv.GetSetting("magcc_db_server");
                }
                catch (Exception)
                {
                }

                if (dbServerUri == String.Empty)
                {
                    RO.Info("NPDB settings for Magellan Databse Server " +
                            "not found. Using default : " + DEFAULT_DB_SERVER);
                    dbServerUri = DEFAULT_DB_SERVER;
                }
                else
                {
                    RO.Info("Using NPDB settings for Magellan Database " + 
                            "Server: " + dbServerUri);
                }

                
                try
                {
                    dbName = Global.XEnv.GetSetting("magcc_db_name");
                }
                catch (Exception)
                {
                }
                
                if (dbName == String.Empty)
                {                    
                    RO.Info("NPDB settings for Magellan Database Name " +
                            "not found. Using default : " + DEFAULT_DB_NAME);
                    dbName = DEFAULT_DB_NAME;
                }
                else
                {
                    RO.Info("Using NPDB settings for Magellan Database Name: "+
                            dbName);
                }

                DbInfo db = new DbInfo();
                
                db.ServerUri = dbServerUri;
                db.Name = dbName;
                
                _db = db;
                
                // Every server should have the xmgmtsrv running, 
                // so by executing the following command
                // we should get a list of every server in the Environment.
                string[] servers = 
                    Global.XEnv.GetServerListByInterface("xmgmtsrv");
                foreach (string server in servers)
                {
                    if (VerifyServiceForServer(server))
                    {
                        _targets.Add(server);
                    }
                    else
                    {
                        RO.Warn(String.Format(
                                    "Skipping Server: {0}, " + 
                                    "CC Service not running.", 
                                    server));
                    }
                }

                if (_targets.Count == 0)
                {
                    RO.Warn("CoverMon is not running on any servers " + 
                            "in the environment");
                    RO.Warn("OR CoverCmd is not installed on this client.");
                }
            }
            else
            {
                RO.Warn("CoverCmd not installed!");
            }
        }

        public bool IsInstalled
        {
            get
            {
                bool ret = true;

                String output;
                int ec = CCExecute("reset", out output);

                if (ec == 2)
                {
                    // Executable file wasn't found.
                    ret = false;
                }

                return ret;
            }
        }

        private bool VerifyServiceForServer(string server)
        {
            string exeArgs = String.Format(
                "/reset /machine:{0}"
              , server
            );

            // TODO: Refine this, perhaps some failure cases would 
            // still be 'success' ?
            String output;
            int ec = CCExecute(exeArgs, out output);
            return ec == 0 ? true : false;
        }

        #region Internal Methods

        private const string _exePath = "CoverCmd.exe";
        private static int CCExecute(string args, out String output)
        {
            int ec = 0;

            Process proc = new Process();
            output = String.Empty;
            
            try
            {
                proc.EnableRaisingEvents = false;

                proc.StartInfo.CreateNoWindow = true;
                proc.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
                proc.StartInfo.FileName = _exePath;
                proc.StartInfo.Arguments = args;
                proc.StartInfo.RedirectStandardOutput = true;
                proc.StartInfo.UseShellExecute = false;

                proc.Start();
                
                output = proc.StandardOutput.ReadToEnd();
                                
                proc.WaitForExit();

                ec = proc.ExitCode;
            }
            catch (Win32Exception e)
            {
                ec = e.NativeErrorCode;
            }

            return ec;
        }

        private void ExecuteCoverCmd(string action)
        {
            ExecuteCoverCmd(action, String.Empty);
        }

        private void ExecuteCoverCmd(string action, string args)
        {
            Dictionary<string, int> missedTargets = 
                new Dictionary<string, int>();

            foreach (string targetUri in _targets)
            {
                string exeArgs = String.Format(
                    "/{0} /machine:{1} {2}"
                  , action
                  , targetUri
                  , args
                );

                ServerTestFramework.Global.RO.Debug(
                    String.Format(
                        "[Code Coverage]: *** > {0} {1}", _exePath, exeArgs));

                String output = String.Empty;
                int ec = CCExecute(exeArgs, out output);
                if (ec != 0)
                {
                    missedTargets[targetUri] = ec;
                }                
            }

            if (missedTargets.Count > 0)
            {
                throw new CoverageExecutionException(args, missedTargets);
            }
        }

        private String GetCoveragePath(String server)
        {
            // Get the path of the coverage data from the server
            String output;
            int ec = CCExecute("/Getpath /machine:" + server, out output);

            if (ec != 0)
            {
                return String.Empty;
            }

            String path = String.Empty;
            String[] lines = output.Split(new char[] { '\n' });
            foreach (String line in lines)
            {
                Match m = Regex.Match(line, @"^'([^']*)'");
                if (m.Success)
                {
                    path = m.Groups[1].Value;
                    break;
                }
            }

            return path;
        }       

       
        private String GetUNCPath(String server, String path)
        {
            // Convert the path to UNC share name if it's not already one
            if (!path.StartsWith("\\\\"))
            {
                return "\\\\" + server + "\\" + path[0] + "$" + 
                    path.Substring(2);
            }
            else
            {
                return path;
            }
        }

        private int ImportDataFrom(String server)
        {
            String path = GetCoveragePath(server);

            if (path == String.Empty)
            {
                RO.Warn(server + ": Could not get coverage data path");
                return SystemErrorCode.FILE_NOT_FOUND;
            }

            path = GetUNCPath(server, path);

            // Upload all data in the directory
            // Get all the sub-directories and upload data from all of them
            if (!Directory.Exists(path))
            {
                RO.Warn("Could not access : " + path);
                return SystemErrorCode.FILE_NOT_FOUND;
            }

            String[] binaryPaths = Directory.GetDirectories(path);
            bool failed = false;
            foreach (String binaryPath in binaryPaths)
            {               
                String[] files = Directory.GetFiles(binaryPath, "*.covdata");

                foreach (String file in files)
                {                    
                    // Execute covdata to import the data to the database
                    if (ExecuteCovData(file) != 0)
                    {
                        failed = true;
                    }
                }
            }

            if (failed)
            {
                return 1;
            }
            else
            {
                return 0;
            }
        }

        private int ExecuteCovData(String file)
        {
            int ec = 0;

            Process proc = new Process();
           
            try
            {
                proc.EnableRaisingEvents = false;

                proc.StartInfo.CreateNoWindow = true;
                proc.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
                proc.StartInfo.FileName = "Covdata.exe";
                proc.StartInfo.Arguments = "/i \"" + file + "\" /db \"Server="+
                    _db.ServerUri + ";Database=" + _db.Name + "\"";
                proc.StartInfo.UseShellExecute = false;

                proc.Start();
                proc.WaitForExit();

                ec = proc.ExitCode;
            }
            catch (Win32Exception e)
            {
                ec = e.NativeErrorCode;
            }

            return ec;
        }        

        private void DeleteCoverageData(String server)
        {
            // Get the coverage path
            String path = GetCoveragePath(server);

            if (path == String.Empty)
            {
                return;
            }
            
            // Close coverage session before deleting just to be sure
            String args = "/close /machine:" + server;
            String output;
            CCExecute(args, out output);
            
            // Convert path to UNC path
            path = GetUNCPath(server, path);

            if (Directory.Exists(path))
            {
                Directory.Delete(path, true);
            }
        }

        private void SetRunId(String server, String runId)
        {
            String path = GetCoveragePath(server);

            if (path != String.Empty)
            {
                String[] components = path.Split(new char[] { '\\' });
                if ((components.Length > 1) && 
                    (components[components.Length - 1].ToLower() 
                     != "coverage"))
                {
                    String newPath = String.Empty;
                    for (int i = 0;i < components.Length - 1;i++)
                    {
                        newPath += components[i];

                        if (i != components.Length - 2)
                        {
                            newPath += "\\";
                        }
                    }

                    path = newPath;
                }


                path += "\\" + runId;

                String output;
                int ec = CCExecute("/Setpath \"" + path + "\" /machine:" + 
                                   server, out output);            
            }
        }

        #endregion // Internal Methods

        #region ICoverageCollector Members

        void ICoverageCollector.Initialize(String runId)
        {
            RO.Info("Using Run ID : " + runId);
            foreach (string targetServer in _targets)
            {
                SetRunId(targetServer, runId);
            }
        }

        void ICoverageCollector.Start(string traceName)
        {
            _traceName = traceName;

            ExecuteCoverCmd("reset");
        }

        void ICoverageCollector.Close()
        {
            ExecuteCoverCmd("close");
        }

        void ICoverageCollector.Reset()
        {
            ExecuteCoverCmd("reset");
        }

        void ICoverageCollector.Save()
        {
            ExecuteCoverCmd(
                "save",
                String.Format("/as \"{0}\"",
                              _traceName));
        }

        void ICoverageCollector.Import()
        {
            // Go through the targets
            // and import all the data in them
            foreach (string targetServer in _targets)
            {
                int ec = ImportDataFrom(targetServer);

                if (ec == 0)
                {
                    DeleteCoverageData(targetServer);
                }
                else
                {
                    RO.Error("Import failed from '" + targetServer + 
                             "'. Trace files collected at '" + 
                             GetUNCPath(targetServer, 
                                        GetCoveragePath(targetServer)));
                }
            }
        }

        bool ICoverageCollector.SupportsSaveToFile{get { return false; }}
        void ICoverageCollector.SaveToFile(string fileName)
        {
            throw new Exception("The method or operation is not implemented.");
        }

        #endregion // ICoverageCollector Members
    }

    internal class SqlCC : ICoverageCollector
    {
        private static Report RO = new Report("Code Coverage > SQL");

        private string _configFilePath;

        private string _traceName;

        /// <summary>
        /// Creates ICoverageCollectors for all Sql Components
        /// </summary>
        /// <returns>An array of ICoverageCollectors</returns>
        public static ICoverageCollector[] CreateCollectors()
        {
            ICoverageCollector[] ret = null;

            if ((SystemErrorCode.FILE_NOT_FOUND != 
                 CCExecute(_exeCollectPath, String.Empty)) && 
                (SystemErrorCode.FILE_NOT_FOUND != 
                 CCExecute(_exeImportPath, String.Empty)))
            {
                List<ICoverageCollector> collectors = 
                    new List<ICoverageCollector>();

                // get list of sql config files
                /*
                CCDB ccdb = new CCDB("npdb");
                foreach (SqlComponent component in ccdb.ActiveSqlComponents)
                {
                    // create collector and add it to the list
                    // TODO: log?
                    ICoverageCollector sqlCC = 
                        (ICoverageCollector) 
                        new SqlCC(component.ConfigFilePath);
                    
                    collectors.Add(sqlCC);
                }
                */

                // TODO : This works for Xblobs. Need to change this to target
                // specific DBs in expanded environments
                string[] servers = 
                    Global.XEnv.GetServerListByInterface("xmgmtsrv");
                int i = 0;
                foreach (string server in servers)
                {
                    // Replace the template with the server name
                    String configFilePath = CreateTemplateFile(server, i);

                    ICoverageCollector sqlCC = 
                        (ICoverageCollector) 
                        new SqlCC(configFilePath);
                    
                    collectors.Add(sqlCC);
                    i++;
                }

                if (collectors.Count > 0)
                {
                    ret = collectors.ToArray();
                }
                else
                {
                    RO.Warn("Could not find any SQL databases");
                }
            }
            else
            {
                RO.Warn("SqlCC tools not installed!");
            }

            return ret;           
        }

        private SqlCC(string configFilePath)
        {
            _configFilePath = configFilePath ?? "sqlcc-config.xml";
        }

        private static String GetVersion(String server)
        {
            String version;
            IInterfaceInfo tmp = Config.GetInterface(server, 
                                                     Interface.xmgmtsrv);

            String ip = tmp.IPAddress.ToString();
            ManagementConsole.Execute(new IPEndPoint(tmp.IPAddress, tmp.Port), 
                                      "e :xmgmtsrv getversion", 
                                      out version);
            version = version.Trim();
            return version;
        }

        private static String CreateTemplateFile(string server, int index)
        {
            // Get the current build version
            string version = GetVersion(server);

            // Open the template and replace server name and version
            String configFilePath = "sqlcc-config-" + index.ToString() + 
                ".xml";
            
            using (StreamReader r = File.OpenText("sqlcc-config-template.xml"))
            {
                using (StreamWriter w = File.CreateText(configFilePath))
                {
            
                    String line = r.ReadLine();
                    while (line != null)
                    {                                                
                        // Replace %VERSION% and %XBLOB%
                        line = line.Replace("%VERSION%", version);
                        line = line.Replace("%XBLOB%", server);
                        
                        w.WriteLine(line);

                        line = r.ReadLine();
                    }
                }
            }
            
            return configFilePath;
        }


        #region Internal Methods

        private const string _exeInstrumentPath = "sqlccinstrument.bat";
        private const string _exeCollectPath = "sqlcctrace.bat";
        private const string _exeImportPath  = "sqlccimport.bat";

        private static int CCExecute(string exe, string args)
        {
            int ec = 0;

            Process proc = new Process();
            try
            {
                proc.EnableRaisingEvents = false;

                proc.StartInfo.CreateNoWindow = true;
                proc.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
                proc.StartInfo.FileName  = exe;
                proc.StartInfo.Arguments = args;
                proc.StartInfo.UseShellExecute = false;
                proc.StartInfo.RedirectStandardOutput = true;

                proc.Start();

                using (StreamReader r = proc.StandardOutput)
                {
                    String line = r.ReadLine();
                    while (line != null)
                    {
                        // RO.Info(line);
                        line = r.ReadLine();
                    }
                }

                proc.WaitForExit();

                ec = proc.ExitCode;
            }
            catch (Win32Exception e)
            {
                ec = e.NativeErrorCode;
            }

            return ec;
        }

        private enum CommandType
        {
            Instrument,
            Trace,
            Import
        }

        private void ExecuteCmd(CommandType commandType, string command)
        {
            ExecuteCmd(commandType, command, null);
        }

        private void ExecuteCmd(CommandType commandType, 
                                string command, 
                                string extra)
        {
            string exe = null;
            switch (commandType)
            {
                case CommandType.Instrument:
                    exe  = _exeInstrumentPath;
                    break;

                case CommandType.Trace:
                    exe  = _exeCollectPath;
                    break;

                case CommandType.Import:
                    exe  = _exeImportPath;
                    break;
            }
            
            string args = String.Format(
                "-c {0} {1} {2} {3}"
              , _configFilePath
              , command
              , _traceName
              , extra ?? String.Empty
            );

            ServerTestFramework.Global.RO.Debug(
                String.Format("[Code Coverage]: *** > {0} {1}", exe, args));

            int ec = CCExecute(exe, args);
            if (ec != 0)
            {
                // Ignore error code 2 in instrumentation
                // It just means DB is already instrumented
                if ((commandType != CommandType.Instrument) || (ec != 2))
                {
                    throw new CoverageExecutionException(args, "SqlCC", ec);
                }
            }
        }

        #endregion // Internal Methods

        #region ICoverageCollector Members

        void ICoverageCollector.Initialize(String runId)
        {
            // Instrument the SQL DBs
            _traceName = String.Empty;
            
            ExecuteCmd(CommandType.Instrument, "");
        }

        void ICoverageCollector.Start(string traceName)
        {
            _traceName = traceName;

            // Close to ensure that the trace file isn't being held-open by a 
            // previous command
            // Close will not throw even if the file DNE, so this is safe to do
            // Force-Create (overwrite any existing trace with the same name)
            ExecuteCmd( CommandType.Trace , "-Close"        );
            ExecuteCmd( CommandType.Trace , "-Create", "-f" );
            ExecuteCmd( CommandType.Trace , "-Start"        );
        }

        void ICoverageCollector.Close()
        {
            ExecuteCmd(CommandType.Trace, "-Close");
        }

        void ICoverageCollector.Reset()
        {
            ExecuteCmd(CommandType.Trace, "-Reset");
        }

        void ICoverageCollector.Save()
        {
            ExecuteCmd(CommandType.Import, "-i", "-as " + _traceName);
        }

        void ICoverageCollector.Import()
        {
            // empty
        }

        bool ICoverageCollector.SupportsSaveToFile
        {
            get { return false; }
        }

        void ICoverageCollector.SaveToFile(string fileName)
        {
            throw new Exception("The method or operation is not implemented.");
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\codecoverage\plugin\ccdb.cs ===
using System;
using System.Collections.Generic;
using System.Text;

using System.Data;
using System.Data.Sql;
using System.Data.SqlClient;

namespace CodeCoverage
{
    enum SettingType
    {
        Magellan
      , SQL
    }

    class SqlComponent
    {
        public SqlComponent(string server, string database, string configFilePath)
        {
            _serverName     = server;
            _databaseName   = database;
            _configFilePath = configFilePath;
        }

        private string _serverName;
        public string ServerName
        {
            get
            {
                return _serverName;
            }
        }

        private string _databaseName;
        public string DatabaseName
        {
            get
            {
                return _databaseName;
            }
        }

        private string _configFilePath;
        public string ConfigFilePath
        {
            get
            {
                return _configFilePath;
            }
        }
    }

    class CCDB
    {
        SqlConnection _con;

        public CCDB(string server)
        {
            _con = new SqlConnection("Server=" + server + ";Database=ccdb;Trusted_Connection=sspi");
            _con.Open();
        }

        public string ReadSetting(SettingType type, string name)
        {
            string typeName = null;
            switch (type)
            {
                case SettingType.Magellan:
                    typeName = "mag";
                    break;

                case SettingType.SQL:
                    typeName = "sql";
                    break;

                default:
                    throw new ArgumentException("Unkown type", "type");
            }

            SqlCommand command = new SqlCommand("p_get_setting", _con);
            command.CommandType = CommandType.StoredProcedure;

            command.Parameters.AddWithValue("@vc_type", typeName);
            command.Parameters.AddWithValue("@vc_name", name);

            return (string) command.ExecuteScalar();
        }

        public SqlComponent[] ActiveSqlComponents
        {
            get
            {
                List<SqlComponent> components = new List<SqlComponent>();

                SqlCommand command = new SqlCommand("p_list_active_sql_components", _con);
                command.CommandType = CommandType.StoredProcedure;

                SqlDataReader reader = command.ExecuteReader();
                while (reader.Read())
                {
                    // 0: database  1: server  2: config path

                    string database   = reader.GetString(0);
                    string server     = reader.GetString(1);
                    string configPath = reader.GetString(2);

                    components.Add(new SqlComponent(server, database, configPath));
                }

                return components.ToArray();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\codecoverage\plugin\Listener.cs ===
using System;
using System.Collections.Generic;
using System.Text;

using STFGui;
using ServerTestFramework.Runner;


namespace CodeCoverage
{
    internal delegate void ListenerCallback(TestEventArgs args);

    internal class Listener : TestEventListener
    {
        public Listener()
        {
        }

        /// <summary>
        /// 
        /// </summary>
        public event ListenerCallback TestPassStarting = null;
        protected virtual void OnTestPassStarting(TestEventArgs args)
        {
            if (TestPassStarting != null)
            {
                TestPassStarting(args);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public event ListenerCallback TestNodeStarting = null;
        protected virtual void OnTestNodeStarting(TestEventArgs args)
        {
            if (TestNodeStarting != null)
            {
                TestNodeStarting(args);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public event ListenerCallback TestNodeFinished = null;
        protected virtual void OnTestNodeFinished(TestEventArgs args)
        {
            if (TestNodeFinished != null)
            {
                TestNodeFinished(args);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public event ListenerCallback TestPassFinished = null;
        protected virtual void OnTestPassFinished(TestEventArgs args)
        {
            if (TestPassFinished != null)
            {
                TestPassFinished(args);
            }
        }

        #region TestEventListener Members

        public void OnTestEvent(TestEventArgs args)
        {
            switch (args.Action)
            {
                case TestAction.StartAll:
                    OnTestPassStarting(args);
                    break;

                case TestAction.Start:
                    OnTestNodeStarting(args);
                    break;

                case TestAction.Pass:
                case TestAction.Fail:
                case TestAction.Ignore: // TestCase has been skipped
                    OnTestNodeFinished(args);
                    break;

                case TestAction.StopAll:
                    OnTestPassFinished(args);
                    break;
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\codecoverage\plugin\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\codecoverage\plugin\DbInfoCollection.cs ===
using System;
using System.Collections.Generic;

namespace CodeCoverage
{
    internal class DbInfo
    {
        public string Name;
        public string ServerUri;

        public static bool operator ==(DbInfo lhs, DbInfo rhs)
        {
            bool ret = Object.ReferenceEquals(lhs, rhs);

            if (!ret)
            {
                if ((object)rhs != null && (object)lhs != null)
                {
                    ret = (lhs.Name == rhs.Name && lhs.ServerUri == rhs.ServerUri);
                }
            }

            return ret;
        }

        public static bool operator !=(DbInfo lhs, DbInfo rhs)
        {
            return !(lhs == rhs);
        }

        public override int GetHashCode()
        {
            return this.ToString().GetHashCode();
        }

        public override bool Equals(object obj)
        {
            return base.Equals(obj);
        }

        public override string ToString()
        {
            return String.Format("{0} ({1})", Name, ServerUri);
        }
    }

    internal class DbInfoCollection : List<DbInfo>
    {
        public DbInfoCollection()
            : base() { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\codecoverage\plugin\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_codecoverageplugin_none_12.4.56.0_none_5f9857a78a9f006d
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_codecoverageplugin_no-public-key_12.4.56.0_x-ww_a72a2eeb
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=codecoverageplugin
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_codecoverageplugin_no-public-key_12.4.56.0_x-ww_a72a2eeb
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_codecoverageplugin_no-public-key_12.4.56.0_x-ww_a72a2eeb.manifest
XP_MANIFEST_PATH=manifests\msil_codecoverageplugin_no-public-key_12.4.56.0_x-ww_a72a2eeb.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_codecoverageplugin_no-public-key_12.4.56.0_x-ww_a72a2eeb.cat
XP_CATALOG_PATH=manifests\msil_codecoverageplugin_no-public-key_12.4.56.0_x-ww_a72a2eeb.cat
XP_PAYLOAD_PATH=msil_codecoverageplugin_no-public-key_12.4.56.0_x-ww_a72a2eeb
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=codecoverageplugin,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\codecoverage\plugin\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\codecoverage\plugin\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_codecoverageplugin_none_12.4.56.0_none_5f9857a78a9f006d
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_codecoverageplugin_no-public-key_12.4.56.0_x-ww_a72a2eeb
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=codecoverageplugin
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_codecoverageplugin_no-public-key_12.4.56.0_x-ww_a72a2eeb
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_codecoverageplugin_no-public-key_12.4.56.0_x-ww_a72a2eeb.manifest
XP_MANIFEST_PATH=manifests\msil_codecoverageplugin_no-public-key_12.4.56.0_x-ww_a72a2eeb.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_codecoverageplugin_no-public-key_12.4.56.0_x-ww_a72a2eeb.cat
XP_CATALOG_PATH=manifests\msil_codecoverageplugin_no-public-key_12.4.56.0_x-ww_a72a2eeb.cat
XP_PAYLOAD_PATH=msil_codecoverageplugin_no-public-key_12.4.56.0_x-ww_a72a2eeb
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=codecoverageplugin,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\codecoverage\plugin\Settings.cs ===
using System;
using System.Collections.Generic;
using System.Text;

using System.Xml;
using System.Xml.XPath;

namespace CodeCoverage
{
    internal class Settings
    {
        private DbInfo _lastUsedDb;

        public bool PrivateXblobRun = false;

        /// <summary>
        /// 
        /// </summary>
        public DbInfo LastUsedDatabase
        {
            get
            {
                return _lastUsedDb;
            }

            set
            {
                _lastUsedDb = value;

                if (!DatabaseHistory.Contains(_lastUsedDb))
                {
                    DatabaseHistory.Add(_lastUsedDb);
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public DbInfoCollection DatabaseHistory = new DbInfoCollection();

        /// <summary>
        /// 
        /// </summary>
        public Settings() : this(null)
        { }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="xmlSettings"></param>
        public Settings(XmlNode xmlSettings)
        {
            Load(xmlSettings);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="xmlSettings"></param>
        public void Load(XmlNode xmlSettings)
        {
            DatabaseHistory.Clear();
            _lastUsedDb = null;

            if (xmlSettings != null)
            {
                XPathNavigator nav = xmlSettings.CreateNavigator();

                //
                // Last Used Database
                //
                if (nav.MoveToChild("dbLastUsed", String.Empty))
                {
                    DbInfo last = new DbInfo();
                    last.Name = nav.GetAttribute("name", String.Empty);
                    last.ServerUri = nav.GetAttribute("server", String.Empty);

                    _lastUsedDb = last;

                    nav.MoveToParent();
                }

                //
                // Database History
                //
                if (nav.MoveToChild("dbHistoryList", String.Empty))
                {
                    if (nav.MoveToFirstChild())
                    {
                        do
                        {
                            if (nav.Name == "dbHistoryItem")
                            {
                                DbInfo db = new DbInfo();
                                db.Name      = nav.GetAttribute( "name"   , String.Empty );
                                db.ServerUri = nav.GetAttribute( "server" , String.Empty );

                                DatabaseHistory.Add(db);
                            }
                        } while (nav.MoveToNext(XPathNodeType.Element));

                        nav.MoveToParent();
                    }

                    nav.MoveToParent();
                }

                //
                // Private Xblob Run?
                //
                if (nav.MoveToChild("privateXblobRun", String.Empty))
                {
                    this.PrivateXblobRun = 
                        (nav.GetAttribute("value", String.Empty).ToLower() == 
                         "true");
                    nav.MoveToParent();
                }

            }
        }

        private XmlElement CreateDbXmlElement(XmlDocument doc, string elementName, DbInfo db)
        {
            XmlElement ele = null;

            XmlAttribute name = doc.CreateAttribute("name");
            if (name != null)
            {
                name.Value = db.Name;

                XmlAttribute server = doc.CreateAttribute("server");
                if (server != null)
                {
                    server.Value = db.ServerUri;

                    ele = doc.CreateElement(elementName);
                    if (ele != null)
                    {
                        ele.Attributes.Append(name);
                        ele.Attributes.Append(server);
                    }
                }
            }

            return ele;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="xmlSettings"></param>
        public void Save(XmlNode xmlSettings)
        {
            XmlDocument doc = xmlSettings.OwnerDocument;
            if (doc != null)
            {
                //
                // Clear previous settings
                //
                xmlSettings.RemoveAll();

                //
                // Save Last Used Database
                //
                if (_lastUsedDb != null)
                {
                    XmlElement lastUsed = CreateDbXmlElement(doc, "dbLastUsed", _lastUsedDb);
                    if (lastUsed != null)
                    {
                        xmlSettings.AppendChild(lastUsed);
                    }
                }

                //
                // Save the Complete Database History
                //
                XmlElement dbHistoryList = doc.CreateElement("dbHistoryList");
                if (dbHistoryList != null)
                {
                    foreach (DbInfo db in DatabaseHistory)
                    {
                        XmlElement dbHistoryItem = CreateDbXmlElement(doc, "dbHistoryItem", db);
                        if (dbHistoryItem != null)
                        {
                            dbHistoryList.AppendChild(dbHistoryItem);
                        }
                    }

                    xmlSettings.AppendChild(dbHistoryList);
                }

                XmlAttribute valueAttrib = doc.CreateAttribute("value");
                
                if (this.PrivateXblobRun)
                {
                    valueAttrib.Value = "true";
                }
                else
                {
                    valueAttrib.Value = "false";
                }
                
                XmlElement element = doc.CreateElement("privateXblobRun");
                element.Attributes.Append(valueAttrib);

                xmlSettings.AppendChild(element);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\CreateUser\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\codecoverage\plugin\UI\Plugin_UI.cs ===
using System;
using System.Collections.Generic;
using System.Text;

using System.Windows.Forms;
using System.Xml;

namespace CodeCoverage
{
    internal class UI
    {
        public MenuItem CCMenu;

        private Form _parent;

        private Settings _settings;
        private MenuItem _selectedDatabase;

        public UI(Form parent, Settings settings)
        {
            _parent   = parent;
            _settings = settings;

            CCMenu = parent != null ? InitMenu() : null;
        }

        //
        // Forward declarations
        //
        private MenuItem _miCodeCoverage                  = new MenuItem();
        private MenuItem _miCodeCoverage_CollectMagTraces = new MenuItem();
        private MenuItem _miCodeCoverage_CollectSqlTraces = new MenuItem();
        private MenuItem _miCodeCoverage_PrivateXblobRun  = new MenuItem();

        protected MenuItem InitMenu()
        {
            // 
            // miCodeCoverage
            // 
            _miCodeCoverage.MenuItems.AddRange(new MenuItem[] {
                _miCodeCoverage_PrivateXblobRun
              , _miCodeCoverage_CollectMagTraces
              , _miCodeCoverage_CollectSqlTraces
            //, _miCodeCoverage_Database
            });
            _miCodeCoverage.Name = "miCodeCoverage";
            _miCodeCoverage.Text = "Code Coverage";

            // 
            // miCodeCoverage_PrivateXblobRun
            // 
            _miCodeCoverage_PrivateXblobRun.Name = "miCodeCoverage_PrivateXblobRun";
            _miCodeCoverage_PrivateXblobRun.Text = "Private Xblob";
            _miCodeCoverage_PrivateXblobRun.Click += new EventHandler(_miCodeCoverage_CollectTraces_Click);
            _miCodeCoverage_PrivateXblobRun.Checked = _settings.PrivateXblobRun;
            
            
            // 
            // miCodeCoverage_CollectMagTraces
            // 
            _miCodeCoverage_CollectMagTraces.Name = "miCodeCoverage_CollectMagTraces";
            _miCodeCoverage_CollectMagTraces.Text = "Magellan";
            _miCodeCoverage_CollectMagTraces.Click += new EventHandler(_miCodeCoverage_CollectTraces_Click);

            // 
            // miCodeCoverage_CollectSqlTraces
            // 
            _miCodeCoverage_CollectSqlTraces.Name = "miCodeCoverage_CollectSqlTraces";
            _miCodeCoverage_CollectSqlTraces.Text = "SQL";
            _miCodeCoverage_CollectSqlTraces.Checked = false;
            _miCodeCoverage_CollectSqlTraces.Click += new EventHandler(_miCodeCoverage_CollectTraces_Click);

            return _miCodeCoverage;
        }

        void _miCodeCoverage_CollectTraces_Click(object sender, EventArgs e)
        {
            MenuItem miCheckBox = (MenuItem)sender;

            // Toggle Ze Checkmark!
            miCheckBox.Checked = !miCheckBox.Checked;

            if (miCheckBox.Name == "miCodeCoverage_PrivateXblobRun")
            {
                _settings.PrivateXblobRun = miCheckBox.Checked;
            }
        }

        void _miCodeCoverage_Database_SelectionChange(object sender, EventArgs e)
        {
            MenuItem miDb = (MenuItem)sender;
            if (miDb != null)
            {
                if (_selectedDatabase != null)
                {
                    _selectedDatabase.Checked = false;
                }

                _selectedDatabase = miDb;
                _selectedDatabase.Checked = true;
            }
        }

        public bool PrivateXblobRun
        {
            get
            {
                return _miCodeCoverage_CollectMagTraces.Checked;
            }

            set
            {
                _miCodeCoverage_CollectMagTraces.Checked = value;
            }
        }

        public bool ShouldCollectMagellanTraces
        {
            get
            {
                return _miCodeCoverage_CollectMagTraces.Checked;
            }

            set
            {
                _miCodeCoverage_CollectMagTraces.Checked = value;
            }
        }

        public bool ShouldCollectSqlTraces
        {
            get
            {
                return _miCodeCoverage_CollectSqlTraces.Checked;
            }

            set
            {
                _miCodeCoverage_CollectSqlTraces.Checked = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\codecoverage\plugin\Plugin_Main.cs ===
using System;
using System.Collections.Generic;
using System.Text;

using System.Xml;
using System.Windows.Forms;

using ServerTestFramework;
using ServerTestFramework.Plugins;
using ServerTestFramework.Runner;

using STFGui;
using STFGui.Plugins;

namespace CodeCoverage
{
    public partial class CodeCoveragePlugin : 
    IPluginSetup, IPluginGui, 
    IPluginExtension<FunctionalPlugin>
    {
        protected Report RO = new Report("CodeCoverage");

        private UI _ui = null;

        private Settings _settings = null;

        private Listener _listener = null;
        
        private bool _collectTraces = false;
        private CoverageManager _cov = null;
        
        private FunctionalPlugin _funcPlugin = null;
        
        #region Plugin Implementation

        #region IPluginSetup Members

        /// <summary>
        /// Initialize the plug-in.
        /// </summary>
        /// <param name="pluginSettings">Xml for plug-in settings</param>
        public void Initialize(XmlNode pluginSettings, 
                               string[] commandlineParameters)
        {
            //
            // Settings
            //
            _settings = new Settings(pluginSettings);

            //
            // Event Listener for the Functional Plug-in
            //
            _listener = new Listener();

            _listener.TestPassStarting += TestPassStarting;
            _listener.TestNodeStarting += TestNodeStarting;
            _listener.TestNodeFinished += TestNodeFinished;
            _listener.TestPassFinished += TestPassFinished;

            //
            // User Interface
            //
            if (GuiHooks != null)
            {
                // Running with StfGui (UI)
                _ui = new UI(GuiHooks.MainForm, _settings);
            }
            else
            {
                // Running in StfConsole (no UI)
                _ui = new UI(null, _settings);
            }
            
            _ui.ShouldCollectMagellanTraces = true;
            _ui.ShouldCollectSqlTraces      = true;
        }

        /// <summary>
        /// Clean up resources and save settings when we are going away.
        /// </summary>
        /// <param name="pluginSettings">Xml for plug-in settings</param>
        public void Shutdown(XmlNode pluginSettings)
        {
            if (_settings != null)
            {
                _settings.Save(pluginSettings);
            }
        }

        #endregion

        #region IPluginExtension<FunctionalPlugin> Members

        /// <summary>
        /// Hook the functional plug-in.
        /// </summary>
        /// <param name="plugin">Functional Plug-in</param>
        public void PluginLoaded(FunctionalPlugin plugin)
        {
            // Do not allow Async Execution (it will invalidate
            // any attempts at trace collection).
            plugin.OverrideNoParallelRunning(this, /*allow=*/true);

            // Register for events so we can collect traces per test case
            plugin.FunctionalEvents.Add(_listener);

            // Keep an instance of the plug-in we're extending
            _funcPlugin = plugin;
        }

        #endregion

        #region IPluginGui Members
        
        /// <summary>
        /// Add a CC menu to the UI.
        /// </summary>
        /// <returns>Menu structure to be added to the UI</returns>
        public MenuItem GetNewMenu()
        {
            return _ui.CCMenu;
        }

        public MainGuiHooks GuiHooks
        {
            get;
            set;
        }

        public TabPage GetNewTabPage ()
        {
            return null;
        }

        public void OnGuiShown ()
        {
        }

        #endregion // IPluginGui Members

        #endregion // Plugin Implementation

        #region Listener Event Handlers

        /// <summary>
        /// Callback Method
        /// Called each time a test pass is started.
        /// </summary>
        /// <param name="args">Event Arguments including the current node.
        /// </param>
        private void TestPassStarting(TestEventArgs args)
        {
            _collectTraces = false;
            
            if (_ui.ShouldCollectMagellanTraces || _ui.ShouldCollectSqlTraces)
            {
                if (!_funcPlugin.SchedulerSettings.AllowAsync)
                {
                    if (Global.IsEnvironmentInternal)
                    {
                        _cov = new CoverageManager();

                        // Magellan Code Coverage //
                        if (_ui.ShouldCollectMagellanTraces)
                        {
                            ICoverageCollector magCC = 
                                MagellanCC.CreateCollector();
                            
                            if (magCC != null)
                            {
                                RO.Info("Collecting Magellan Traces...");
                                _cov.AddCollector(magCC);
                            }
                            else
                            {
                                RO.Warn("Cannot collect Magellan Traces:");
                            }
                        }

                        
                        // Sql Code Coverage //
                        if (_ui.ShouldCollectSqlTraces)
                        {
                             //TODO: Update this to load all SQL config files
                            ICoverageCollector[] sqlCollectors = 
                                SqlCC.CreateCollectors();
                            
                            if (sqlCollectors != null && 
                                sqlCollectors.Length > 0)
                            {
                                RO.Info("Collecting SQL Traces...");
                                _cov.AddCollectors(sqlCollectors);
                            }
                            else
                            {
                                RO.Warn("Cannot collect SQL Traces:");
                            }
                        }
                        

                        if (_cov.CollectorCount > 0)
                        {
                            _collectTraces = true;
                            _cov.Initialize();
                        }
                        else
                        {
                            RO.Warn("No traces being collected!");
                        }
                    }
                    else
                    {
                        RO.Warn("Cannot collect traces without an " + 
                                "environment selected, or when " + 
                                "running externally.");
                    }
                }
                else
                {
                    RO.Warn("Cannot collect traces when " + 
                            "asynchronous execution is enabled, " + 
                            "please disable and try again...");
                }
            }
        }

        /// <summary>
        /// Callback Method
        /// Called at the start of execution for each node.
        /// Leaf nodes are test cases.
        /// </summary>
        /// <param name="args">Event Arguments including the current node.
        /// </param>
        private void TestNodeStarting(TestEventArgs args)
        {
            // Verify this is a leaf node (test case)
            if (_collectTraces && args.Node.ChildrenCount == 0)
            {
                String traceName;

                // Mangle traceName so that sqlcc doesn't choke on names
                // with format _NNN
                traceName = args.Node.FullName + "_t";

                // Replace space in test nodes with _
                traceName = traceName.Replace(" ", "_");

                _cov.Start(traceName);
            }
        }

        /// <summary>
        /// Callback Method
        /// Called at the completion of execution for each node.
        /// Leaf nodes are test cases.
        /// </summary>
        /// <param name="args">Event Arguments including the current node.
        /// </param>
        private void TestNodeFinished(TestEventArgs args)
        {
            // Verify this is a leaf node (test case)
            if (_collectTraces && args.Node.ChildrenCount == 0)
            {
                _cov.Close();
                _cov.Save();
            }
        }

        /// <summary>
        /// Callback Method
        /// Called at the completion of a test pass.
        /// </summary>
        /// <param name="args">Event Arguments including the current node.
        /// </param>
        private void TestPassFinished(TestEventArgs args)
        {
            if (_collectTraces)
            {
                RO.Info("Finished Collecting Traces.");
                RO.Info(String.Format("{0} Traces Saved.", 
                                      _cov.SavedTraceCount));

                // Upload saved traces
                RO.Info("Importing Collected Traces...");
                
                _cov.Import();

                //_settings.LastUsedDatabase = _cov.DB;
                _settings.PrivateXblobRun = _ui.PrivateXblobRun;
                _cov = null;
            }
        }

        #endregion // Listener Event Handlers
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\CreateUser\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_createuser_none_12.4.56.0_none_e1054784a1947658
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_createuser_no-public-key_12.4.56.0_x-ww_73cf784a
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=createuser
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_createuser_no-public-key_12.4.56.0_x-ww_73cf784a
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_createuser_no-public-key_12.4.56.0_x-ww_73cf784a.manifest
XP_MANIFEST_PATH=manifests\msil_createuser_no-public-key_12.4.56.0_x-ww_73cf784a.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_createuser_no-public-key_12.4.56.0_x-ww_73cf784a.cat
XP_CATALOG_PATH=manifests\msil_createuser_no-public-key_12.4.56.0_x-ww_73cf784a.cat
XP_PAYLOAD_PATH=msil_createuser_no-public-key_12.4.56.0_x-ww_73cf784a
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=createuser,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\CreateUser\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\dbdiff\CompareDB\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\CreateUser\CreateUser.cs ===
using System;
using System.Diagnostics;
using System.Globalization;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Utilities;
using PassportUser = ServerTestFramework.LiveService.UserAccount.UacsCommon.PassportUser;

namespace ServerTestFramework
{
    /// <summary>
    /// Summary description for Class1.
    /// </summary>
    class Class1
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main(string[] args)
        {
            CreateUserApp app = new CreateUserApp();
            app.Run(args);
            Console.WriteLine("Done.");
        }
    }

    public class CreateUserApp
    {
        public enum UserType { XboxCom, Xbox1Unlinked, Xbox1Linked, Silver, Gold, GoldMigrated };

        UacsCommon UC = new UacsCommon();

        public void Run(string[] args)
        {
            // Parse command line arguments
            UserType userType;
            bool UseRealPassport;
            string gamerTag;
            ulong passportPuid = 0;
            uint UserCount = 0;
            try
            {
                if (!ParseArguments(args, out userType, out UseRealPassport, out gamerTag, out passportPuid, out UserCount))
                {
                    DisplayHelp();
                    return;
                }
            }
            catch(Exception e)
            {
                DbgWriteLine(e.ToString());
                DbgWriteLine("");
                DisplayHelp();
                return;
            }

            // Initialization
            DbgWriteLine("Initializing...");
            CoreGlobal.Initialize("stf.xml");

            // Create a user
            DbgWriteLine("Creating a " + userType.ToString() + " user with " + (UseRealPassport ? "real" : "fake") + " Passport credentials.");
            try
            {
                ulong puid;
                if (UserCount == 0)
                    puid = CreateUser(userType, UseRealPassport, gamerTag, passportPuid);
                else
                {
                    string first3chars;
                    if(gamerTag.Length>4)
                        first3chars=gamerTag.Substring(0, 4);
                    else
                        first3chars=gamerTag;

                    for (int i = 0; i < UserCount; i++)
                    {
                        puid = CreateUser(userType, UseRealPassport, first3chars + i, 0);
                    }
                }
                DbgWriteLine("User successfully created.");
            }
            catch (Exception e)
            {
                DbgWriteLine("Error :- "+e.ToString());
            }
            

            // Clean-up
            CoreGlobal.Uninitialize();
        }

        private void DisplayHelp()
        {
            DbgWriteLine("");
            DbgWriteLine("CreateUser.exe Help");
            DbgWriteLine("");
            DbgWriteLine("Use 1 of:      /xboxcom /xbox1linked /xbox1unlinked /silver /gold /goldmigrated");
            DbgWriteLine("Also use 1 of: /realpp /fakepp");
            DbgWriteLine("\tWith /gold or /silver optionally use /gamertag <Tag>");
            DbgWriteLine("\tWith /gold or /silver optionally use /gamertag <3 chars only> /count 10"); 
            DbgWriteLine("\tWith /gold or /silver AND /fakepp optionally use /passportpuid <Puid>"); 
            DbgWriteLine("");
            DbgWriteLine("The only exception is when using /xbox1unlinked, do not specify /realpp or /fakepp");
            DbgWriteLine("");
            DbgWriteLine("Example 1: CreateUser.exe /xbox1unlinked");
            DbgWriteLine("Example 2: CreateUser.exe /xbox1linked /fakepp");
            DbgWriteLine("Example 3: CreateUser.exe /gold /realpp");
            DbgWriteLine("Example 4: CreateUser.exe /gold /realpp");
            DbgWriteLine("Example 5: CreateUser.exe /gold /realpp");
            DbgWriteLine("Example 6: CreateUser.exe /gold /realpp /gamertag Foo1");
            DbgWriteLine("Example 6: CreateUser.exe /gold /fakepp /gamertag \"Foo Two\"");
            DbgWriteLine("Example 6: CreateUser.exe /gold /fakepp /gamertag \"Foo Two\"");
        }

        private bool ParseArguments(string[] args, out UserType UsrType, out bool UseRealPassport, out string gamerTag, out ulong passportPuid, out uint userCount)
        {
            UsrType = UserType.Gold;
            UseRealPassport = false;
            gamerTag = String.Empty;
            passportPuid = 0;
            userCount = 0;

            // Only Xbox 1 unlinked users are allowed to have a single command line parameter
            if (args.Length == 1)
            {
                if (args[0].ToLower() == "/xbox1unlinked")
                {
                    UsrType = UserType.Xbox1Unlinked;
                    return(true);
                }

                if (args[0] == "/?")
                {
                    return(false);
                }
            }

            // Otherwise we require both a user type and a passport type always
            if (args.Length < 2)
            {
                throw new Exception("2 command line parameters minimum are required (only 1 when using /xbox1unlinked).");
            }

            bool UserTypeSet = false;
            bool PassportTypeSet = false;
            bool GamerTagNext = false;
            bool PassportPuidNext = false;
            bool UserCountNext = false;
           

            foreach (string rawarg in args)
            {
                string arg = rawarg.ToLower();
                if (arg == "/xbox1linked")
                {
                    UsrType = UserType.Xbox1Linked;
                    UserTypeSet = true;
                }
                else if (arg == "/xboxcom")
                {
                    UsrType = UserType.XboxCom;
                    UserTypeSet = true;
                }
                else if (arg == "/silver")
                {
                    UsrType = UserType.Silver;
                    UserTypeSet = true;
                }
                else if (arg == "/gold")
                {
                    UsrType = UserType.Gold;
                    UserTypeSet = true;
                }
                else if (arg == "/goldmigrated")
                {
                    UsrType = UserType.GoldMigrated;
                    UserTypeSet = true;
                }
                else if (arg == "/realpp")
                {
                    UseRealPassport = true;
                    PassportTypeSet = true;
                }
                else if (arg == "/fakepp")
                {
                    UseRealPassport = false;
                    PassportTypeSet = true;
                }
                else if (arg == "/gamertag")
                {
                    GamerTagNext = true;
                }
                else if (arg == "/passportpuid")
                {
                    PassportPuidNext = true;
                }
                else if (arg == "/count")
                {
                    UserCountNext = true;
                }
                else if (GamerTagNext)
                {
                    GamerTagNext = false;
                    gamerTag = arg;
                }
                else if (UserCountNext)
                {
                    UserCountNext = false;
                    if (arg.Length>2 && arg.Substring(0, 2).ToLower() == "0x")
                        userCount = UInt32.Parse(arg.Substring(2), NumberStyles.HexNumber);
                    else
                        userCount = UInt32.Parse(arg); // assume decimal
                }
                else if (PassportPuidNext)
                {
                    PassportPuidNext = false;
                    
                    if (arg.Substring(0,2).ToLower() == "0x" )
                        passportPuid = UInt64.Parse(arg.Substring(2), NumberStyles.HexNumber);
                    else
                        passportPuid = UInt64.Parse(arg); // assume decimal
                }
                else
                {
                    throw new Exception("Invalid command line parameter: " + arg);
                }
            }
            if (!UserTypeSet || !PassportTypeSet)
            {
                throw new Exception("Must specify both a user type and a passport type.");
            }
            if (GamerTagNext || PassportPuidNext)
            {
                throw new Exception("Must specify a GamerTag or PassportPuid if option(s) was selected.");
            }
            if (userCount > 0 && gamerTag.Length == 0)
            {
                throw new Exception("Must specify Usercount and GamerTag if option(s) was selected.");
            }
            if (userCount > 0 && passportPuid != 0)
            {
                throw new Exception("Cannot specify Usercount and PassportPuid if option(s) was selected.");
            }
            return(true);
        }

        public ulong CreateUser(UserType UsrType, bool UseRealPassport, string gamerTag, ulong passportPuid)
        {
            ulong puid;
            if (UsrType == UserType.Xbox1Linked)
            {
                puid = CreateXbox1User(true, UseRealPassport);
            }
            else if (UsrType == UserType.Xbox1Unlinked)
            {
                puid = CreateXbox1User(false, false);
            }
            else if (UsrType == UserType.XboxCom)
            {
                puid = CreateXboxComUser(UseRealPassport);
            }
            else if (UsrType == UserType.Silver)
            {
                puid = Create360User(false, UseRealPassport, gamerTag, passportPuid);
            }
            else if (UsrType == UserType.Gold)
            {
                puid = Create360User(true, UseRealPassport, gamerTag, passportPuid);
            }
            else if (UsrType == UserType.GoldMigrated)
            {
                puid = Create360GoldMigratedUser(UseRealPassport);
            }
            else
            {
                throw new Exception("User type not implemented yet.");
            }
            return(puid);
        }

        private ulong CreateXbox1User(bool LinkToPassport, bool UseRealPassport)
        {
            Owner owner = CreateOwner();
            ulong puid = owner.UserPuid;

            PassportUser ppUser = null;
            ulong ppPuid = 0;

            if (LinkToPassport)
            {
                if (UseRealPassport)
                {
                    ppUser = LinkOwnerToRealPassport(owner);
                }
                else
                {
                    ppPuid = LinkOwnerToFakePassport(owner);
                }
            }

            DumpUserInfo(puid);
            DumpCCInfo(owner);
            if (LinkToPassport)
            {
                if (UseRealPassport)
                {
                    DumpPassportInfo(ppUser);
                }
                else
                {
                    DbgWriteLine("\tFake Passport User Puid: 0x{0:X} ({0})", ppPuid);
                }
            }

            return(puid);
        }

        private Owner CreateOwner()
        {
            Owner owner = UC.GenerateOwner();
            ulong puid = owner.Create();
            if (puid == 0)
            {
                throw new Exception("Failed to create Xbox user.  Puid == 0; " + owner.GetDumpString());
            }
            return(owner);
        }

        private ulong LinkOwnerToFakePassport(Owner owner)
        {
            ulong ppPuid = PassportUtilities.GenerateRandomULong();
            owner.LinkToPassport(ppPuid);
            return(ppPuid);
        }

        private PassportUser LinkOwnerToRealPassport(Owner owner)
        {
            PassportUser ppUser = UC.CreatePassportUser(owner.gamertag + Global.PassportMemberDomain, (byte)XeUser.Country.US);
            owner.LinkToPassport(ppUser.PassportPuid);
            return(ppUser);
        }

        public ulong CreateXboxComUser(bool UseRealPassport)
        {
            XRLXeCreateXboxComAccount request = new XRLXeCreateXboxComAccount();
            XRLXeCreateXboxComAccountResponse response = new XRLXeCreateXboxComAccountResponse();

            PassportUser ppUser = null;
            if (UseRealPassport)
            {
                ppUser = UC.CreatePassportUser(request.Gamertag + Global.PassportMemberDomain, (byte)XeUser.Country.US);
                request.UserPassportPuid = ppUser.PassportPuid;
                request.OwnerPassportPuid = request.UserPassportPuid;

            }
            else
            {
                request.UserPassportPuid = PassportUtilities.GenerateRandomULong();
                request.OwnerPassportPuid = request.UserPassportPuid;
            }

            if (!request.Execute(out response))
                throw new UnexpectedTestResultException("XeCreateXboxComAccount failed: " + request.GetDumpString());

            if (request.XErr != HResult.S_OK)
                throw new UnexpectedTestResultException(String.Format("XeCreateXboxComAccount returned XErr=0x{0:x}", request.XErr));

            if (response.UserPuid == 0)
                throw new UnexpectedTestResultException("User puid returned was 0.");

            DumpUserInfo(response.UserPuid);
            if (UseRealPassport)
            {
                DumpPassportInfo(ppUser);
            }
            else
            {
                DbgWriteLine("\tFake Passport User Puid: 0x{0:X} ({0})", request.UserPassportPuid);
            }
            return(response.UserPuid);
        }

        public ulong Create360User(bool CreateAsGold, bool UseRealPassport, string gamerTag, ulong passportPuid)
        {
            Random RandGen = new Random();

            XeUser user = null;

            if(gamerTag != null && gamerTag.Length > 0)
                user = new XeUser(UseRealPassport, gamerTag);
            else
                user = new XeUser(UseRealPassport);
            
            user.CreateAsGold = CreateAsGold;
            user.MachinePuid = XOn.XboxId.XenonMachineBase | (~XOn.XboxId.Mask & 
                new RandomEx().NextUlong());

            // Only allow overridden Passport info if using FakePassport...
            if(!UseRealPassport && passportPuid != 0)
            {
                user.PassportUserPuid = passportPuid;
                user.PassportOwnerPuid = passportPuid;
            }

            ulong puid = user.Create();
            if (puid == 0)
            {
                throw new Exception("Failed to create Xenon user.  Puid == 0; " + user.GetDumpString());
            }

            DumpUserInfo(puid);
            DumpCCInfo(user);
            if (UseRealPassport)
            {
                DumpPassportInfo(user);
            }
            else
            {
                DbgWriteLine("\tFake Passport User Puid: 0x{0:X} ({0})", user.PassportUserPuid);
            }
            DbgWriteLine("\t*********************");
            return(puid);
        }

        public ulong Create360GoldMigratedUser(bool UseRealPassport)
        {
            // Create an Xbox 1 user
            Owner owner = CreateOwner();
            ulong puid = owner.UserPuid;

            // Create a passport and link it
            XRLXeMigrateXbox1User request = new XRLXeMigrateXbox1User();
            XRLXeMigrateXbox1UserResponse response = new XRLXeMigrateXbox1UserResponse();
            
            PassportUser ppUser = null;
            ulong ppPuid = 0;
            if (UseRealPassport)
            {
                ppUser = LinkOwnerToRealPassport(owner);
                request.SignedUserPassportPuid = PassportUtilities.GenerateSessionToken(ppUser.PassportPuid, request.Slot.Key);
                request.SignedParentPassportPuid = request.SignedUserPassportPuid;
                request.UserPassportMemberName = ppUser.MemberName;
            }
            else
            {
                ppPuid = LinkOwnerToFakePassport(owner);
                request.SignedUserPassportPuid = PassportUtilities.GenerateSessionToken(ppPuid, request.Slot.Key);
                request.SignedParentPassportPuid = request.SignedUserPassportPuid;
                request.UserPassportMemberName = owner.gamertag + Global.PassportMemberDomain;
            }

            // Migrate
            if (!request.Execute(out response))
                throw new UnexpectedTestResultException("XRLXeMigrateXbox1User failed: " + request.GetDumpString());
            if (request.XErr != HResult.S_OK)
                throw new UnexpectedTestResultException(String.Format("XRLXeMigrateXbox1User returned XErr=0x{0:x}", request.XErr));

            DumpUserInfo(puid);
            DumpCCInfo(owner);
            if (UseRealPassport)
            {
                DumpPassportInfo(ppUser);
            }
            else
            {
                DbgWriteLine("\tFake Passport User Puid: 0x{0:X} ({0})", ppPuid);
            }

            return(puid);
        }

        private static void DbgWriteLine(string str, params object[] arg)
        {
            Console.WriteLine(str, arg);
        }

        private static void DumpUserInfo(ulong Puid)
        {
            UserInfo uinfo;
            bool ret = UodbWS.GetUserInfo(Puid, out uinfo);
            if (!ret)
            {
                throw new UnexpectedTestResultException("Call to GetUserInfo() failed.");
            }
            DbgWriteLine("\tUsername: "+ uinfo.nickname);
            DbgWriteLine("\tPuid: 0x{0:X} ({0})", uinfo.puid);
            DbgWriteLine("\tOwner puid: 0x{0:X} ({0})", uinfo.ownerPuid);
            DbgWriteLine("\tQueued: " + uinfo.queued);
            DbgWriteLine("\tServer: " + uinfo.server);

            UserSubInfo[] subs;
            ret = UodbWS.GetUserSubs(Puid, out subs);
            if (ret)
            {
                foreach (UserSubInfo sub in subs)
                {
                    DbgWriteLine("\tSubscription: 0x{0:X} {1} {2} {3}", sub.offerId, sub.friendlyName, sub.serviceInstanceId, sub.subStatus);
                }
            }
            else
            {
                DbgWriteLine("\tNo user subscription found.");
            }
        }

        private static void DumpCCInfo(Owner owner)
        {
            DbgWriteLine("\tCredit Card Type: " + owner.cardTypeId);
            DbgWriteLine("\tCredit Card Holder: " + owner.cardHolder);
            DbgWriteLine("\tCredit Card Number: " + owner.cardNumber);
            DbgWriteLine("\tCredit Card Expiration: " + owner.cardExpiration);
        }

        private static void DumpCCInfo(XeUser user)
        {
            DbgWriteLine("\tCredit Card Type: " + user.CreditCardInfo.CardType);
            DbgWriteLine("\tCredit Card Holder: " + user.CreditCardInfo.AccountHolderName);
            DbgWriteLine("\tCredit Card Number: " + user.CreditCardInfo.AccountNumber);
            DbgWriteLine("\tCredit Card Expiration: " + user.CreditCardInfo.ExpirationDate.ToString());
        }

        private static void DumpPassportInfo(PassportUser ppUser)
        {
            Debug.Assert(ppUser != null, "DumpPassportInfo can only be called for real Passport users.");
            DbgWriteLine("\tPassport User Puid: 0x{0:X} ({0})", ppUser.PassportPuid);
            DbgWriteLine("\tPassport Member Name: " + ppUser.MemberName);
            DbgWriteLine("\tPassport Password: " + ppUser.Password);
        }

        private static void DumpPassportInfo(XeUser user)
        {
            DbgWriteLine("\tPassport User Puid: 0x{0:X} ({0})", user.PassportUserPuid);
            DbgWriteLine("\tPassport Member Name: " + user.PassportMemberName);
            DbgWriteLine("\tPassport Password: as13as13!!we421");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\CreateUser\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_createuser_none_12.4.56.0_none_e1054784a1947658
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_createuser_no-public-key_12.4.56.0_x-ww_73cf784a
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=createuser
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_createuser_no-public-key_12.4.56.0_x-ww_73cf784a
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_createuser_no-public-key_12.4.56.0_x-ww_73cf784a.manifest
XP_MANIFEST_PATH=manifests\msil_createuser_no-public-key_12.4.56.0_x-ww_73cf784a.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_createuser_no-public-key_12.4.56.0_x-ww_73cf784a.cat
XP_CATALOG_PATH=manifests\msil_createuser_no-public-key_12.4.56.0_x-ww_73cf784a.cat
XP_PAYLOAD_PATH=msil_createuser_no-public-key_12.4.56.0_x-ww_73cf784a
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=createuser,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\dbdiff\DBDiff\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\dbdiff\CompareDB\CompareDB.cs ===
using System;
using DBDiff_NS;

namespace CompareDB
{
	/// <summary>
	/// Summary description for CompareDB.
	/// </summary>
	public class CompareDB
	{
		public CompareDB()
		{
			
		}

		internal static void Usage()
		{
			Console.WriteLine();
			Console.WriteLine("USAGE:");
			Console.WriteLine();
			Console.WriteLine("CompareDB /s1:<SQL_Server1> /d1:<DB1> [/s2:<SQL_Server2>] /d2:<DB2> [/fast]");
			Console.WriteLine("CompareDB /s1:<SQL_Server1> /d1:<DB1> [/s2:<SQL_Server2>] /d2:<DB2> [/ShowRows:n]");
			Console.WriteLine();			
			Console.WriteLine("Description:");
			Console.WriteLine("Compares the data in both DBs and returns a list of " +
				"mismatched and identical tables. The output is saved to a log file.");
			Console.WriteLine();			
			Console.WriteLine("Optional Parameters:");
			Console.WriteLine("/s2:<SQL_Server2> is the name of the SQL server containing the second DB. "
				+ "If not specified, the same SQL server is used for both DBs.");
			Console.WriteLine();
			Console.WriteLine("/fast is used to compare the data based on aggregate table checksums which is "
				+ "faster than outer joins. However, "
				+ "the checksum method is not very accurate and does not garantee discovering all the "
				+ "differences.");			
			Console.WriteLine();
			Console.WriteLine("/ShowRows:n specifies the maximum number of rows to return in the row comparisons. " +
				"The limit is 100 which is the default setting also. This option is not available for the " +
				"/fast method.");
			Console.WriteLine();
			Console.WriteLine("NOTES:");
			Console.WriteLine("1. SQL server name must be the name of the machine - localhost is not supported.");
			Console.WriteLine("2. Non-comparable SQL data types (text, ntext, image) are excluded "
				+ "from the comparison.");
			Console.WriteLine("3. This tool does not compare the schema.");
			Console.WriteLine("4. You must have administrative privileges on both SQL servers.");
			Console.WriteLine();
		}

		internal static void ParseArgs(string[] args,ref string srv1,ref string db1,ref string srv2,
			ref string db2,ref bool chksm,ref int maxRowsNum)
		{
			chksm = false;
			srv2 = "";
			if (args.Length <= 0)
				throw new Exception("No arguments were supplied.");

			foreach (string arg in args)
			{
				char[] delim = new char[]{':'};
				if (arg.ToLower().StartsWith("/s1:"))
				{
					string[] s = arg.Split(delim,2);
					srv1 = s[1];
				}
				else if (arg.ToLower().StartsWith("/s2:"))
				{
					string[] s = arg.Split(delim,2);
					srv2 = s[1];
				}
				else if (arg.ToLower().StartsWith("/d1:"))
				{
					string[] s = arg.Split(delim,2);
					db1 = s[1];
				}
				else if (arg.ToLower().StartsWith("/d2:"))
				{
					string[] s = arg.Split(delim,2);
					db2 = s[1];
				}
				else if (arg.ToLower() == "/fast")
				{
					chksm = true;
				}
				else if (arg.ToLower().StartsWith("/showrows:"))
				{
					string[] s = arg.Split(delim,2);
					maxRowsNum = Convert.ToInt32(s[1]);
				}
			}
			if (srv2 == "") srv2 = srv1;
		}

		internal static void ValidateArgs(string srv1,string db1,string srv2,string db2)
		{
			if (srv1 == "")
				throw new Exception("You must specify a server name.");
			if ((srv1.ToLower() == "localhost") || (srv2.ToLower() == "localhost"))
				throw new Exception("Please specify the name of the machine; localhost is not "
					+ "supported.");
			if ((db1 == "") || (db2 == ""))
				throw new Exception("You must specify a database name.");
		}

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{			
			if (args.Length < 3)
			{
				Usage();
				return;
			}
			
			//
			// Get and validate arguments
			//
			string srv1="", srv2="", db1="", db2="";			
			bool chksm=false;
			int maxRowsNum=-1;
			ParseArgs(args,ref srv1,ref db1,ref srv2,ref db2,ref chksm,ref maxRowsNum);
			ValidateArgs(srv1,db1,srv2,db2);

			try
			{				
				if (chksm)
				{
					// Checksum method
					Console.WriteLine("Fast method - ");
					DBDiffChecksum diff = new DBDiffChecksum(srv1,db1,srv2,db2);
					diff.Compare();
					
					// TESTING
					/*Console.WriteLine("Iterating through empty tables.");
					foreach (string s in diff.EmptyTables)
					{
						Console.WriteLine(s);
					}					
					Console.WriteLine("Iterating through identical tables.");
					foreach (string s in diff.IdenticalTables)
					{
						Console.WriteLine(s);
					}
					Console.WriteLine("Iterating through mismatched tables.");					
					foreach (DBDiff_NS.MismatchedTable t in diff.MismatchedTables)
					{
						Console.WriteLine(t.tableName + " " + t.checksumDB1 + " " + t.checksumDB2);
					}					
					Console.WriteLine("Total: {0}", diff.NumTablesTotal);
					Console.WriteLine("Total: {0}", diff.NumTablesEmpty);
					Console.WriteLine("Mismatched: {0}", diff.NumTablesMismatched);
					Console.WriteLine("Identical: {0}", diff.NumTablesIdentical);*/					
					// END TEST

					diff.PrintSummary();
				}
				else
				{
					// Outer join method
					Console.WriteLine("Outer join method - ");
					DBDiffJoin diff = new DBDiffJoin(srv1,db1,srv2,db2);
					// set maxRows if specified
					if (maxRowsNum > -1) diff.MaxRows=maxRowsNum;
					diff.Compare();

					// TESTING					
					/*Console.WriteLine("Iterating through identical tables.");
					foreach (string s in diff.IdenticalTables)
					{
						Console.WriteLine(s);
					}
					Console.WriteLine("Iterating through mismatched tables.");
					foreach (string s in diff.MismatchedTables)
					{
						Console.WriteLine(s);
					}
					Console.WriteLine("Total: {0}", diff.NumTablesTotal);					
					Console.WriteLine("Mismatched: {0}", diff.NumTablesMismatched);
					Console.WriteLine("Identical: {0}", diff.NumTablesIdentical);*/					
					// END TEST

					diff.PrintSummary();					
				}
			}
			catch(Exception e)
			{
				Console.WriteLine("An exception occurred:");
				Console.WriteLine(e.ToString());
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\dbdiff\DBDiff\DBDiff.cs ===
using System;
using System.Text;
using System.Data;
using System.Data.SqlClient;
using System.Collections;
using System.IO;

namespace DBDiff_NS
{

	public abstract class DBDiff
	{
		public abstract void PrintSummary();

		public abstract void Compare();							
		
		// check if we linked the server. Used in order to know
		// if it is necessary to remove the link at cleanup time.
		protected bool IsServer2Added()
		{
			return (m_Server2Added);
		}	

		protected ArrayList GetSortedTableList(string server, string DB)
		{
			SqlConnection conn = new SqlConnection();
			conn.ConnectionString = "Data Source=" + server + ";Initial Catalog=" 
				+ DB + ";Trusted_Connection=True";
			conn.Open();
			SqlCommand cmd = new SqlCommand();
			cmd.Connection = conn;
			cmd.CommandType = CommandType.Text;
			cmd.CommandText = "select [name] from sysobjects where [xtype]='U' " +
				"order by [name]";
			SqlDataReader reader = cmd.ExecuteReader();
			ArrayList list = new ArrayList();
			while (reader.Read())
			{
				list.Add(reader.GetSqlString(0));
			}
			reader.Close();
			conn.Close();
			return list;
		}

		protected ArrayList GetCommonTables(ArrayList TableList1, ArrayList TableList2)
		{
			ArrayList Common = new ArrayList();
			// table lists are sorted, so just compare one by one
			int i;
			for (i=0;i<TableList1.Count;i++)
			{
				if (TableList2.BinarySearch(TableList1[i]) >= 0)
					Common.Add(TableList1[i].ToString());
			}
			m_NumTablesTotal = Common.Count;
			return Common;
		}

		internal StreamWriter m_SW;
		protected SQLDMO.SQLServer m_SqlServer;
		protected SQLDMO._Database m_Database;
		protected string m_Server1, m_Server2;
		protected string m_DBName1;
		protected string m_DBName2;		
		
		public int NumTablesTotal
		{
			get {return m_NumTablesTotal;}			
		}
		protected int m_NumTablesTotal;				

		public int NumTablesMismatched
		{
			get {return m_NumTablesMismatched;}
		}
		protected int m_NumTablesMismatched;

		public int NumTablesIdentical
		{
			get {return m_NumTablesIdentical;}
		}
		protected int m_NumTablesIdentical;
		
		public ArrayList IdenticalTables
		{
			get {return m_IdenticalTables;}
		}
		protected ArrayList m_IdenticalTables;

		public ArrayList MismatchedTables
		{
			get {return m_MismatchedTables;}
		}		
		protected ArrayList m_MismatchedTables;	
		
		/*public bool Server2Added
		{
			get {return m_Server2Added;}
		}*/
		protected bool m_Server2Added;	
		public int MaxRows
		{
			get {return m_MaxRows;}
			set {if (value>=0) m_MaxRows=value;}
		}
		protected int m_MaxRows;					
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\codecoverage\plugin\Properties\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("CodeCoverage")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("CodeCoverage")]
[assembly: AssemblyCopyright("Copyright  Microsoft 2007")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("9f85c91c-ba1a-451c-b173-0223c2c93544")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\DBLookup\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\DBLookup\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\dbdiff\DBDiff\DBDiffChecksum.cs ===
using System;
using System.Text;
using System.Data;
using System.Data.SqlClient;
using System.Collections;
using System.IO;


namespace DBDiff_NS
{

	public class MismatchedTable
	{
		public MismatchedTable(string tName,string chk1, string chk2)
		{
			m_tableName = tName;
			m_checksumDB1 = chk1;
			m_checksumDB2 = chk2;
		}

		public string tableName
		{
			get{return m_tableName;}
		}
		private string m_tableName;
		public string checksumDB1
		{
			get {return m_checksumDB1;}
		}			
		private string m_checksumDB1;
		public string checksumDB2
		{
			get {return m_checksumDB2;}
		}
		private string m_checksumDB2;
	}
	
	/// <summary>
	/// Summary description for DBDiffChecksum.
	/// </summary>
	public class DBDiffChecksum : DBDiff
	{
		public DBDiffChecksum(string server1, string DBName1, string server2, string DBName2)			
		{
			m_Server1 = server1;
			m_Server2 = server2;
			m_DBName1 = DBName1;
			m_DBName2 = DBName2;
			m_MaxRows=100; //default value	
			m_IdenticalTables = new ArrayList();
			m_MismatchedTables = new ArrayList();			
			
			// Create log file stream
			string path = "DBDiff_" + 
				DateTime.Now.ToString("MM_dd_yyyy_HH_mm") + ".log";
			m_SW = File.CreateText(path);
			m_SW.AutoFlush = true;

			// Add linked server if necessary
			if (m_Server1 != m_Server2) 
				if (!Util.IsAlreadyLinkedServer(m_Server1,m_DBName1,m_Server2))
				{
					Util.AddLinkedServer(m_Server1,m_DBName1,m_Server2);
					Util.Print("Linked server " + m_Server1 + " and " + m_Server2 + ".",m_SW);			
					m_Server2Added = true;
				}

			m_EmptyTables = new ArrayList();
			m_MismatchedTablesOutput = new ArrayList();
		}

		~DBDiffChecksum()
		{
			// Close log file stream
			m_SW.Close();
			// Remove linked server if it was added
			if (IsServer2Added()) 
			{
				Util.RemoveLinkedServer(m_Server1,m_DBName1,m_Server2);
				Util.Print("Dropped Linked server " + m_Server2 + ".",m_SW);
			}
		}

		public override void PrintSummary()
		{
			Util.Print("",m_SW);
			Util.Print("S U M M A R Y:",m_SW);
			Util.Print("______________",m_SW);
			Util.Print("",m_SW);
			Util.Print("MISMATCHED TABLES:",m_SW);
			Util.Print("__________________",m_SW);
			if (m_MismatchedTablesOutput.Count > 0)
			{
				Util.Print("TABLE                         CHECKSUM DB1        CHECKSUM DB2",m_SW);				
				foreach (object o in m_MismatchedTablesOutput)
				{
					Util.Print(o.ToString(),m_SW);
				}
			}
			else
			{
				Util.Print("No mismatched tables found.",m_SW);
			}

			Util.Print("\r\n",m_SW);
			Util.Print("IDENTICAL TABLES:",m_SW);
			Util.Print("_________________",m_SW);
			if (m_IdenticalTables.Count > 0)
			{
				foreach (object o in m_IdenticalTables)
				{
					Util.Print(o.ToString(),m_SW);
				}
			}
			else
			{
				Util.Print("No identical tables found.",m_SW);
			}
			// Empty tables
			if (m_EmptyTables.Count > 0)
			{
				Util.Print("\r\nThe following tables are empty in both databases:",m_SW);
				foreach (object o in m_EmptyTables)
				{
					Util.Print(o.ToString(),m_SW);
				}
			}
	
			Util.Print("\r\nNumber of Identical Tables: " + 
				(m_NumTablesIdentical).ToString(),m_SW);
			Util.Print("Number of Mismatched Tables: " + m_NumTablesMismatched,m_SW);
			if (m_NumTablesEmpty > 0)
				Util.Print("Number of Empty Tables: " + m_NumTablesEmpty,m_SW);
			Util.Print("Number of Tables in Common: " + m_NumTablesTotal,m_SW);
		}		

		/// <summary>
		/// Clean up the temporary tables that were created to store the checksums
		/// </summary>
		private void CleanUpTempDB()
		{
			SqlConnection conn = new SqlConnection();
			conn.ConnectionString = "Data Source=" + m_Server1 + ";Initial Catalog=" 
				+ "tempdb;Trusted_Connection=True";
			conn.Open();
			SqlCommand cmd = new SqlCommand();
			cmd.Connection = conn;
			cmd.CommandType = CommandType.Text;
			// check if the table exists before deleting it
			cmd.CommandText = "select [name] from sysobjects where [name]=" +
				"'DB1Checksum' and xtype='U'";
			SqlDataReader reader = cmd.ExecuteReader();
			if (reader.Read())
			{			
				if (reader.GetValue(0).ToString() == "DB1Checksum")
				{
					reader.Close();
					cmd.CommandType = CommandType.Text;
					cmd.CommandText = "Drop Table dbo.DB1CheckSum";
					cmd.ExecuteNonQuery();
				}
				else
					reader.Close();
			}
			else
				reader.Close();
			cmd.CommandText = "";
			cmd.CommandText = "select [name] from sysobjects where [name]=" +
				"'DB2Checksum' and xtype='U'";
			reader = cmd.ExecuteReader();
			if (reader.Read())
			{
				if (reader.GetValue(0).ToString() == "DB2Checksum")
				{
					reader.Close();
					cmd.CommandType = CommandType.Text;
					cmd.CommandText = "Drop Table dbo.DB2Checksum";
					cmd.ExecuteNonQuery();
				}
				else
					reader.Close();
			}
			else
				reader.Close();
			conn.Close();
		}

		private void Init()
		{
			m_NumTablesTotal = 0;
			m_NumTablesMismatched = 0;
			m_NumTablesEmpty = 0;
			m_Server2Added = false;
			m_MismatchedTables.Clear();
			m_IdenticalTables.Clear();
			m_EmptyTables.Clear();
		}
		private void GetChecksums()
		{			
			Util.Print("Comparing databases [" + m_Server1 + "].dbo.[" + m_DBName1 + "] and [" + 
				m_Server2 + "].dbo.[" + m_DBName2 + "]",m_SW);
			Util.Print("",m_SW);
			// Get list of tables
			ArrayList tables_DB1 = GetSortedTableList(m_Server1, m_DBName1);
			ArrayList tables_DB2 = GetSortedTableList(m_Server2, m_DBName2);
			ArrayList common_Tables = GetCommonTables(tables_DB1,tables_DB2);

			// Connection to m_Server1
			SqlConnection conn = new SqlConnection();
			conn.ConnectionString = "Data Source=" + m_Server1 + ";Initial Catalog=" 
				+ m_DBName1 + ";Trusted_Connection=True";			
			conn.Open();
			SqlCommand cmd = new SqlCommand();
			cmd.Connection = conn;			
			cmd.CommandTimeout = 0;
			cmd.CommandType = CommandType.Text;						

			// Create temp tables in DB1 to hold the checksum values
			// PS. Had to use tempdb.dbo.tablename instead of dbo.#tablename
			// because for some reason the latter wouldn't create the table in 
			// tempDB
			string cmd1 = "CREATE TABLE tempdb.dbo.DB1Checksum(tablename varchar(100),checkNum int)";
			// temp tables are created on first server
			cmd.CommandText = cmd1;
			cmd.ExecuteNonQuery();
			string cmd2 = "CREATE TABLE tempdb.dbo.DB2Checksum(tablename varchar(100),checkNum int)";
			cmd.CommandText = cmd2;
			cmd.ExecuteNonQuery();

			// Populate temp tables with checksum values
			// for both DBs												
			for (int i=0;i<common_Tables.Count;i++)
			{
				string strTableName = Convert.ToString(common_Tables[i]);
				cmd.CommandText =	"INSERT tempdb.dbo.DB1Checksum " +
					"SELECT	'" + strTableName + "', " +
					"CHECKSUM_AGG(BINARY_CHECKSUM(*)) FROM " +
					"[" + m_DBName1 + "].dbo.[" + strTableName + "]";
				cmd.ExecuteNonQuery();
				cmd.CommandText =	"INSERT tempdb.dbo.DB2Checksum " +
					"SELECT	'" + strTableName + "', " +
					"CHECKSUM_AGG(BINARY_CHECKSUM(*)) FROM " + 
					"[" + m_Server2 + "].[" + m_DBName2 + "].dbo.[" + strTableName + "]";
				cmd.ExecuteNonQuery();
			}			
			conn.Close();
		}

		private void CompareChecksums()
		{
			SqlConnection conn = new SqlConnection();
			conn.ConnectionString = "Data Source=" + m_Server1 + ";Initial Catalog=" 
				+ m_DBName1 + ";Trusted_Connection=True";
			conn.Open();

			SqlCommand cmd = new SqlCommand();
			cmd.Connection = conn;
			cmd.CommandType = CommandType.Text;

			// Check mismatched tables			
			cmd = null;
			cmd = new SqlCommand();
			cmd.Connection = conn;
			cmd.CommandType = CommandType.Text;
			cmd.CommandText = 
				"select A.tablename,A.checkNum,B.checkNum " +
				"from tempdb.dbo.DB1CheckSum A " +
				"inner join tempdb.dbo.DB2Checksum B " +
				"on	A.tablename = B.tablename " +
				"where (A.checkNum <> B.checkNum) " +
				"OR ((A.checkNum is null) AND (B.checkNum is not null)) " +
				"OR ((A.checkNum is not null) AND (B.checkNum is null))";
			SqlDataReader reader = cmd.ExecuteReader();														
			while (reader.Read())
			{
				string tbl = Convert.ToString(reader.GetValue(0));
				string chk1 = Convert.ToString(reader.GetValue(1));
				string chk2 = Convert.ToString(reader.GetValue(2));

				string s = System.String.Format("{0,-30}{1,-20}{2,-20}",
					tbl, 
					chk1, 
					chk2);				
				++m_NumTablesMismatched;
				m_MismatchedTablesOutput.Add(s);
				m_MismatchedTables.Add(new MismatchedTable(tbl,chk1,chk2));
			}
						
			reader.Close();

			// check identical tables
			cmd.CommandText = "";
			cmd.CommandText = 
				"select A.tablename " +
				"from tempdb.dbo.DB1Checksum A " +
				"inner join tempdb.dbo.DB2Checksum B " +
				"on	A.tablename = B.tablename " +
				"where A.checkNum = B.checkNum";
			reader = null;
			reader = cmd.ExecuteReader();			
			while (reader.Read())
			{
				string s = System.String.Format("{0,-30}",
					Convert.ToString(reader.GetValue(0))); 											
				++m_NumTablesIdentical;
				m_IdenticalTables.Add(s);
			}
			reader.Close();			
			cmd.CommandText = "";
			cmd.CommandText = 
				"select A.tablename " +
				"from tempdb.dbo.DB1Checksum A " +
				"inner join tempdb.dbo.DB2Checksum B " +
				"on	A.tablename = B.tablename " +
				"where (A.checkNum is null) AND (B.checkNum is null)";
			reader = cmd.ExecuteReader();				
			while (reader.Read())
			{
				string s = System.String.Format("{0,-30}",
					Convert.ToString(reader.GetValue(0))); 											
				m_EmptyTables.Add(s);
				++m_NumTablesEmpty;
			}			
			reader.Close();
			conn.Close();
		}


		/// <summary>
		/// Compare DBs using the checksum method.
		/// For mismatched tables, returns a list of objects of type MismatchedTable.
		/// For other lists, the data type is string.
		/// </summary>
		public override void Compare()
		{
			// Initialize member variables
			Init();
			
			// Check that there are no temp tables left over
			// from an incomplete run.
			CleanUpTempDB();
			
			// 
			// Compare by using the checksum method
			//				
			// Get and compare check sums				
			GetChecksums();
			CompareChecksums();								

			// 
			// Clean up
			//
			// clean up tables in tempDB				
			CleanUpTempDB();
		}					
		
		public ArrayList EmptyTables
		{
			get {return m_EmptyTables;}
		}
		private ArrayList m_EmptyTables;
	
		public int NumTablesEmpty
		{
			get {return m_NumTablesEmpty;}
		}
		private int m_NumTablesEmpty;		

		public ArrayList MismatchedTablesOutput
		{
			get {return m_MismatchedTablesOutput;}
		}		
		protected ArrayList m_MismatchedTablesOutput;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\dbdiff\DBDiff\DBDiffJoin.cs ===
using System;
using System.Text;
using System.Data;
using System.Data.SqlClient;
using System.Collections;
using System.IO;

namespace DBDiff_NS
{
	/// <summary>
	/// Summary description for DBDiffExact.
	/// </summary>
	public class DBDiffJoin : DBDiff
	{
		public DBDiffJoin(string server1, string DBName1, string server2, string DBName2) 		
		{
			m_Server1 = server1;
			m_Server2 = server2;
			m_DBName1 = DBName1;
			m_DBName2 = DBName2;
			m_MaxRows=100; //default value	
			m_IdenticalTables = new ArrayList();
			m_MismatchedTables = new ArrayList();			
			
			// Create log file stream
			string path = "DBDiff_" + 
				DateTime.Now.ToString("MM_dd_yyyy_HH_mm") + ".log";
			m_SW = File.CreateText(path);
			m_SW.AutoFlush = true;

			// Add linked server if necessary
			if (m_Server1 != m_Server2) 
				if (!Util.IsAlreadyLinkedServer(m_Server1,m_DBName1,m_Server2))
				{
					Util.AddLinkedServer(m_Server1,m_DBName1,m_Server2);
					Util.Print("Linked server " + m_Server1 + " and " + m_Server2 + ".",m_SW);			
					m_Server2Added = true;
				}
		}

		~DBDiffJoin()
		{
			// Close log file stream
			m_SW.Close();
			// Remove linked server if it was added
			if (IsServer2Added()) 
			{
				Util.RemoveLinkedServer(m_Server1,m_DBName1,m_Server2);
				Util.Print("Dropped Linked server " + m_Server2 + ".",m_SW);
			}
		}

		private void DMODisconnect()
		{
			m_SqlServer.DisConnect();
		}

		private void DMOConnectToSQL()
		{
			m_SqlServer = new SQLDMO.SQLServerClass();			
			m_SqlServer.LoginTimeout = 30;
			m_SqlServer.LoginSecure = true;						
			m_SqlServer.Connect(m_Server1, "", "");
		}

		private void DMOGetListOfCommonTables(out SQLDMO.Table[] tableList)
		{
			int id=0;
			bool bFoundDB = false;
			// Find DB ID
			foreach (SQLDMO.Database db in m_SqlServer.Databases)
			{
				string sname = db.Name.ToLower();
				if (sname == m_DBName1.ToLower())
				{					
					id = db.ID;
					bFoundDB = true;
					break;
				}				
			}
			
			if (!bFoundDB)
				throw new Exception("Did not find database " + m_DBName1 + ".");

			// Get DB object from ID
			m_Database = m_SqlServer.Databases.ItemByID(id);
			
			// Get list of tables
			ArrayList tables_DB1 = GetSortedTableList(m_Server1, m_DBName1);
			ArrayList tables_DB2 = GetSortedTableList(m_Server2, m_DBName2);
			ArrayList commonTablesSorted = GetCommonTables(tables_DB1,tables_DB2);
			
			tableList = new SQLDMO.Table[m_Database.Tables.Count];
			int i=0;
			// Get list of user tables
			foreach (SQLDMO.Table tbl in m_Database.Tables)
			{				
				// if it is not a system table and it is a common table between both DBs,
				// then add it to the list of DMO tables
				string s = tbl.Name;
				if ((!tbl.SystemObject) && (commonTablesSorted.BinarySearch(s) >= 0))
					tableList[i++] = tbl;
				// Debugging
				//Console.WriteLine("SystemObject={0}, {1}",tbl.SystemObject,tbl.Name);				
			}
			m_NumTablesTotal = i;
		}

		// Build the outer join SQL statement for this specific table
		/*private string BuildOuterJoinStatement(SQLDMO.Table table)
		{			
			StringBuilder sb = null;
			try
			{
				sb = new StringBuilder();
				sb.Append("SELECT * FROM [" + m_Server1 + "].[" + m_DBName1 + "].[dbo].[" + table.Name + "] A ");
				sb.Append("FULL OUTER JOIN [" + m_Server2 + "].[" + m_DBName2 + "].[dbo].[" + table.Name + "] B ON ");
			
				string sCol = "";			
				SQLDMO.Column ColForWhereClause = GetComparableColumn(table.Columns);			
				// if no comparable column is found, exit
				if (ColForWhereClause == null)
					throw new Exception("No comparable columns are found in table " + table.Name + ".");
				string sColForWhereClause = ColForWhereClause.Name;

				// Get columns			
				foreach (SQLDMO.Column col in table.Columns)
				{
					sCol = col.Name;
					// Exclude the non-comparable data types
					if (IsColComparable(col))				
						sb.Append("isnull(A." + sCol + ",0) = " + "isnull(B." + sCol + ",0) AND ");				
				}
				if (sCol == "")
					throw new Exception("No columns were found for table " + 
						table.Name + ".");
				// Remove the last 'AND'
				sb = sb.Remove(sb.Length - 5, 5);
				sb.Append(" WHERE (A." + sColForWhereClause + " is null AND  B." + 
					sColForWhereClause + " is not null) " +
					"OR (B." + sColForWhereClause + " is null AND A." + 
					sColForWhereClause + " is not null)");
			}
			catch (Exception e)
			{
				Util.Print(e.ToString(),m_SW);
			}
			return sb.ToString();
		}*/

		// Build join statement to get differing rows
		private string BuildOuterJoinStatement(SQLDMO.Table table, 
			ref uint uiKeyFlag, ref ArrayList KeyCols)
		{			
			// uiKeyFlag = 0 => No key or unique index found
			// uiKeyFlag = 1 => Primary key found
			// uiKeyFlag = 2 => Unique index found
			// uiKeyFlag = 3 => This will never happen (PK and UI)

			StringBuilder sb = null;
			KeyCols = null;			
			uiKeyFlag=0;
			try
			{								
				// First get primary key
				KeyCols = GetKey(table);
				// If not found, then try to get unique index
				if (KeyCols == null)
				{
					KeyCols = GetUniqueIndex(table);
					if (KeyCols != null) uiKeyFlag |= 2;
				}
				else
					uiKeyFlag |= 1;				

				sb = new StringBuilder();
				sb.Append("SELECT * FROM [" + m_Server1 + "].[" + m_DBName1 + "].[dbo].[" + table.Name + "] A ");
				sb.Append("FULL OUTER JOIN [" + m_Server2 + "].[" + m_DBName2 + "].[dbo].[" + table.Name + "] B ON ");
			
				string sCol = "";			
				ArrayList ColList = GetAllComparableColumns(table.Columns);	
				// if no comparable column is found, exit
				if (ColList == null)
					throw new Exception("No comparable columns are found in table " + table.Name + ".");				

				// Use columns of unique key for the join
				if (uiKeyFlag != 0)
				{
					int i=0;
					
					for (i=0;i<KeyCols.Count;i++)
					{
						sCol = (string)KeyCols[i];
						sb.Append("isnull(A." + sCol + ",0) = " + "isnull(B." + sCol + ",0) AND ");				
					}
					// Remove the last 'AND'
					sb = sb.Remove(sb.Length - 5, 5);
					// Use the remaining columns in the
					// WHERE clause
					sb.Append(" WHERE ");
					string sColForWhereClause="";
					for(i=0;i<ColList.Count;i++)
					{
						sColForWhereClause = ((SQLDMO.Column)ColList[i]).Name;
						if ((IsColComparable((SQLDMO.Column)ColList[i])) && (!KeyCols.Contains(sColForWhereClause)))
						{						
							sb.Append("(isnull(A." + sColForWhereClause + ",0) != isnull(B." + 
								sColForWhereClause + ",0)) OR ");
						}
					}
					// Remove last OR
					sb.Remove(sb.Length-4,4);
				}
				else // if no key was found, then use all columns in join
				{					
					SQLDMO.Column ColForWhereClause = GetComparableColumn(table.Columns);			
					// if no comparable column is found, exit
					if (ColForWhereClause == null)
						throw new Exception("No comparable columns are found in table " + table.Name + ".");
					string sColForWhereClause = ColForWhereClause.Name;

					// Get columns			
					foreach (SQLDMO.Column col in table.Columns)
					{
						sCol = col.Name;
						// Exclude the non-comparable data types
						if (IsColComparable(col))				
							sb.Append("isnull(A." + sCol + ",0) = " + "isnull(B." + sCol + ",0) AND ");				
					}
					if (sCol == "")
						throw new Exception("No columns were found for table " + 
							table.Name + ".");
					// Remove the last 'AND'
					sb = sb.Remove(sb.Length - 5, 5);
					sb.Append(" WHERE (A." + sColForWhereClause + " is null AND  B." + 
						sColForWhereClause + " is not null) " +
						"OR (B." + sColForWhereClause + " is null AND A." + 
						sColForWhereClause + " is not null)");
				}
			}
			catch (Exception e)
			{
				Util.Print(e.ToString(),m_SW);
			}
			if (sb != null)
				return sb.ToString();
			else
				return null;
		}

		private bool IsColComparable(SQLDMO.Column col)
		{
			string sDataType = col.Datatype.ToLower();
			
			return ((sDataType != "text") &&
				(sDataType != "ntext") &&
				(sDataType != "image"));				
		}

		private SQLDMO.Column GetComparableColumn(SQLDMO.Columns cols)
		{
			foreach (SQLDMO.Column col in cols)
			{
				if (IsColComparable(col))
					return col;
			}
			return null;
		}

		private ArrayList GetAllComparableColumns(SQLDMO.Columns cols)
		{
			ArrayList sCols = new ArrayList();
			foreach (SQLDMO.Column col in cols)
			{
				if (IsColComparable(col))
					sCols.Add(col);
			}
			if (sCols.Count ==0)
				return null;
			else
				return sCols;
		}

		private void ExecuteSQLQuery(string query, SQLDMO.Table table, 
			uint uiKeyFlag, ArrayList KeyCols)
		{
			SqlConnection conn = new SqlConnection("Data Source=" + m_Server1 +
				";Initial Catalog=" + m_DBName1 + ";Trusted_Connection=Yes");
			conn.Open();
			SqlCommand cmd = new SqlCommand();
			cmd.CommandTimeout = 0;
			cmd.Connection = conn;
			cmd.CommandType = CommandType.Text;			
			// Get the count of mistmatched rows				
			// replace SELECT * by SELECT COUNT(*)
			string queryCount = query.Replace("*", "COUNT(*)");
			cmd.CommandText = queryCount;
			SqlDataReader reader = cmd.ExecuteReader();
			int rowcount = 0;
			if (reader.Read()) rowcount = (int)reader.GetValue(0);
			if (rowcount > 0)
			{
				++m_NumTablesMismatched;
				m_MismatchedTables.Add(table.Name);
				Util.Print("\r\nTABLE MISMATCH:",m_SW);
				Util.Print("Table: " + table.Name,m_SW);
				Util.Print("Query:",m_SW);
				Util.Print(query,m_SW);												

				// If we have mismatches, then print number of mismatches				
				Util.Print("Number of mismatched rows in both tables: " + rowcount,m_SW);
				reader.Close();
				// then get rows
				cmd.CommandText = query;				
				reader = cmd.ExecuteReader();							
												
				string row1="",row2="";
				// Print rows if user wants rows to be printed
				if  (m_MaxRows>0)
				{
					if (uiKeyFlag != 0)
					{										
						// Print mismatched rows from both tables
						Util.Print("\r\nDIFFERING ROWS IN TABLE: " + table.Name,m_SW);						
						// Print key information
						string sKeyInfo="";
						if ((uiKeyFlag & 1) != 0)
							sKeyInfo="Primary Key Columns: ";
						else if ((uiKeyFlag & 2) != 0)
							sKeyInfo="Unique Index Columns: ";
						foreach(string sCol in KeyCols)
						{
							sKeyInfo+=sCol + ", ";
						}
						// Remove last comma
						sKeyInfo = sKeyInfo.Remove(sKeyInfo.Length-2,2);
						Util.Print(sKeyInfo,m_SW);

						// Print legend
						Util.Print("[" + m_Server1 + "].["+m_DBName1+"] = 1.>>",m_SW);
						Util.Print("[" + m_Server2 + "].["+m_DBName2+"] = 2.<<",m_SW);								
						Util.Print("\r\n",m_SW);

						rowcount=0;
						// Iterate through all the rows up to MAXROWS
						while ((reader.Read()) && (rowcount < m_MaxRows))
						{				
							++rowcount;
							object[] values = new object[reader.FieldCount];
							reader.GetValues(values);				
							row1="1.>> ";
							int nullCount=0;
							// Iterate through table A's values
							int i=0;
							for(i=0;i<values.Length/2;i++)
							{
								object o = values[i];
								if (o.GetType() == typeof(System.DBNull)) 
									++nullCount;
								else if (o.GetType() == typeof(System.Byte[]))
								{
									row1 += "<binary> ";
								}
								else
								{
									row1 += o.ToString() + " ";
								}
							}	
							if (nullCount == values.Length/2)
								row1 = "1.>> (No Matching Row Found)";						
							Util.Print(row1,m_SW);
							nullCount=0;
							row2="2.<< ";
							// Iterate through table B's values
							for(i=values.Length/2;i<values.Length;i++)
							{
								object o = values[i];
								if (o.GetType() == typeof(System.DBNull)) 
									++nullCount;
								else if (o.GetType() == typeof(System.Byte[]))
								{
									row2 += "<binary> ";
								}
								else
									row2 += o.ToString() + " ";
							}			
							if (nullCount == values.Length/2)
								row2 = "2.<< (No Matching Row Found)";							
							Util.Print(row2,m_SW);
							Util.Print("",m_SW);
						}					
					}
					else
					{
						Util.Print("No key was found for this table. Unable to show row differences. " +
							"First row returned by query result:", m_SW);
						reader.Read();
						object[] values = new object[reader.FieldCount];
						reader.GetValues(values);
						int i;
						string sRow="";
						for(i=0;i<values.Length;i++)
						{
							object o = values[i];
							if (o.GetType() == typeof(System.DBNull)) 
								sRow += "NULL ";
							else if (o.GetType() == typeof(System.Byte[]))
							{
								sRow += "<binary> ";
							}
							else
								sRow += o.ToString() + " ";							
						}	
						Util.Print(sRow,m_SW);
					}
				}
			}
			else
			{
				m_IdenticalTables.Add(table.Name);
				++m_NumTablesIdentical;
			}
			reader.Close();
			conn.Close();
		}	

		private void CompareJoin()
		{
			Util.Print("Comparing databases [" + m_Server1 + "].[" + m_DBName1 + "] and [" + 
				m_Server2 + "].[" + m_DBName2 + "].",m_SW);
			Util.Print("",m_SW);

			SQLDMO.Table[] tableList;			
			DMOGetListOfCommonTables(out tableList);
			ArrayList KeyCols = null;
			for(int i=0;i<m_NumTablesTotal;i++)
			{
				uint uiKeyFlag=0;
				string query = BuildOuterJoinStatement(tableList[i],ref uiKeyFlag, ref KeyCols);
				ExecuteSQLQuery(query, tableList[i], uiKeyFlag, KeyCols);
			}			
		}

		public override void Compare()
		{
			// Initialize member variables
			Init();

			// Connect to SQL server through SQLDMO
			DMOConnectToSQL();
			// Perform the comparison with outer joins
			CompareJoin();			
			// Release SQLDMO connection
			DMODisconnect();	
		}

		public override void PrintSummary()
		{
			Util.Print("",m_SW);
			Util.Print("S U M M A R Y:",m_SW);
			Util.Print("______________",m_SW);
			Util.Print("",m_SW);
			int i=0;
			Util.Print("MISMATCHED TABLES:",m_SW);	
			Util.Print("__________________",m_SW);
			if (m_MismatchedTables.Count == 0) 
				Util.Print("No mismatched tables were found.",m_SW);
			for(i=0;i<m_MismatchedTables.Count;i++)
			{
				Util.Print(m_MismatchedTables[i].ToString(),m_SW);
			}
			Util.Print("",m_SW);
			Util.Print("IDENTICAL TABLES:",m_SW);
			Util.Print("_________________",m_SW);
			if (m_IdenticalTables.Count == 0) 
				Util.Print("No identical tables were found.",m_SW);
			for(i=0;i<m_IdenticalTables.Count;i++)
			{
				Util.Print(m_IdenticalTables[i].ToString(),m_SW);
			}
			Util.Print("",m_SW);			
			Util.Print("Number of Mismatched Tables: " + m_NumTablesMismatched,m_SW);
			Util.Print("Number of Identical Tables: " + (m_NumTablesTotal - m_NumTablesMismatched).ToString(),m_SW);
			Util.Print("Total Number of Tables in Common: " + m_NumTablesTotal,m_SW);
		}

		private void Init()
		{
			m_NumTablesTotal = 0;
			m_NumTablesMismatched = 0;
			m_Server2Added = false;
			m_MismatchedTables.Clear();
			m_IdenticalTables.Clear();			
		}				

		private ArrayList GetKey(SQLDMO.Table tbl)
		{			
			ArrayList KeyCols = new ArrayList();
			string s = tbl.Name;					
			// Get columns of primary key
			SQLDMO.Key pkey = tbl.PrimaryKey;
			if (pkey != null)
			{										
				for(int i=0;i<pkey.KeyColumns.Count;i++)
				{
					foreach(string sCol in pkey.KeyColumns)
					{								
						KeyCols.Add(sCol);
					}
				}						
			}	
			if (KeyCols.Count > 0)
				return KeyCols;
			else
				return null;
		}

		private ArrayList GetUniqueIndex(SQLDMO.Table tbl)
		{		
			ArrayList IndexCols = new ArrayList();
			string s = tbl.Name;								
			foreach (SQLDMO.Index index in tbl.Indexes)
			{						
				string name = index.Name;						
				if (index.Type==SQLDMO.SQLDMO_INDEX_TYPE.SQLDMOIndex_Unique)
				{																					
					SQLDMO.SQLObjectList list = index.ListIndexedColumns();							
					if (list != null)
					{																						
						foreach (SQLDMO.Column col in list)
						{
							IndexCols.Add(col.Name);
						}								
					}
				}	
			}
									
			if (IndexCols.Count > 0)
				return IndexCols;
			else
				return null;
		}

		/*public static void Main(string[] args)
		{
			DBDiffJoin d = new DBDiffJoin("katiah1","Test1","katiah1","Test2");
			d.Compare();
			d.PrintSummary();
			//d.GetRowsDiff(new string[]{"Table1"});
			//DBDiffJoin d = new DBDiffJoin("katiah1","xreport3","katiah1","xreport3");
			//d.GetRowsDiff(new string[]{"UODB_Users"});
			
		}*/
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\DBLookup\ConnectionData.cs ===
using System;
using System.Data;
using System.Data.SqlClient;    
using System.Threading;

namespace DBLookup
{

    class ConnectionData : IDisposable
    {
        public static string g_dbusername = "sa";
        public static string g_dbpassword = "Suck!H3ad";
        public static string g_connectiontimeout = "5";

        public string serverName = null;
        public string connectionstring = null;
        public SqlConnection connection = null;
        public ManualResetEvent OnCompletionEvent;
        public int recordCount = 0;

        // These are used to pass information into the worker threads
        public DataSet dataSet = null;
        public string queryStr = null;

        public ConnectionData(string _serverName, ref ManualResetEvent _event)
        {
            this.serverName = _serverName;
            this.connectionstring = BuildConnectionString();
            this.connection = null;
            OnCompletionEvent = _event;
        }

        public ConnectionData(string _serverName, string _connectionstring, SqlConnection _connection)
        {
            this.serverName = _serverName;
            this.connectionstring = _connectionstring;
            this.connection = _connection;
        }

        public string GetServerName()
        {
            return "[" + serverName + "]";
        }

        public bool IsConnected()
        {
            if (connection == null)
                return false;
            return (connection.State == ConnectionState.Open);
        }

        private string BuildConnectionString()
        {
            string connectionstring = "data source=" + serverName + ";Trusted_Connection=true";
            if (g_dbusername != null && g_dbpassword != null)
            {
                connectionstring += ";user id=" + g_dbusername + ";pwd=" + g_dbpassword;
            }
            if (g_connectiontimeout != null)
            {
                connectionstring += ";Connection Timeout=" + g_connectiontimeout;
            }
            return connectionstring;
        }

        public void Close()
        {
            if (connection != null) 
            {
                connection.Close();
                connection = null;
            }
        }

        public void Open()
        {
            if (IsConnected())
            {
                return;
            }
            else if (connection == null)
            {
                try
                {
                    connection = new SqlConnection(this.connectionstring);
                    Console.WriteLine("{0} Connecting...", serverName);
                    connection.Open();
                    Console.WriteLine("{0} Connected: {1}", serverName, connectionstring);
                }
                catch (Exception e)
                {
                    Console.WriteLine("{0} Connection failed: {1}", serverName, e.Message);
                    throw;
                }
            }
        }

        public SqlDataReader Execute(string query)
        {
            // Open connection if necessary, otherwise this does nothing
            Open();
            SqlCommand command = new SqlCommand(query, connection);
            SqlDataReader reader = command.ExecuteReader(CommandBehavior.KeyInfo | CommandBehavior.SequentialAccess);
            return reader;
        }

        public void ExecuteDataAdapter(string selectQuery, int maxRecordsToRetrieve)
        {
            if (dataSet == null)
            {
                throw new Exception("No DataSet specified for query");
            }
            SqlDataAdapter myDataAdapter;
            try
            {
                Open();
                myDataAdapter = new SqlDataAdapter(selectQuery, connection);
                myDataAdapter.Fill(this.dataSet, 0, maxRecordsToRetrieve, GetServerName());
                recordCount = this.dataSet.Tables[GetServerName()].Rows.Count;
            }
            catch (Exception e)
            {
                Close();
                throw e;
            }
            finally
            {
                OnCompletionEvent.Set();
            }           
        }

        #region IDisposable Members

        public void Dispose()
        {
            Close();
        }

        #endregion
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\DBLookup\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\dbdiff\DBDiff\Util.cs ===
using System;
using System.IO;
using System.Data;
using System.Data.SqlClient;

namespace DBDiff_NS
{
	/// <summary>
	/// Class holding utility methods shared by other classes.
	/// </summary>
	class Util
	{		

		public static bool AddLinkedServer(string server1, string DB1, string server2)
		{
			SqlConnection conn = new SqlConnection();
			conn.ConnectionString = "Data Source=" + server1 + ";Initial Catalog=" 
				+ DB1 + ";Trusted_Connection=True";
			conn.Open();
			SqlCommand cmd = new SqlCommand();
			cmd.Connection = conn;
			cmd.CommandType = CommandType.Text;
			cmd.CommandText = "sp_addlinkedserver '" + server2 + "'";
			SqlDataReader reader  = cmd.ExecuteReader();						

			reader.Close();
			conn.Close();
			return true;
		}

		// We can't link the server twice, so check if the server 
		// is already linked
		public static bool IsAlreadyLinkedServer(string server1, string DB1, string server2)
		{
			SqlConnection conn = new SqlConnection();
			conn.ConnectionString = "Data Source=" + server1 + ";Initial Catalog=" 
				+ DB1 + ";Trusted_Connection=True";
			conn.Open();
			SqlCommand cmd = new SqlCommand();
			cmd.Connection = conn;
			cmd.CommandType = CommandType.Text;
			cmd.CommandText = "sp_helpserver";
			SqlDataReader reader  = cmd.ExecuteReader();
			bool bLinked = false;
			while (reader.Read())
			{
				string serverName = (string)reader.GetSqlString(0);
				if (serverName.ToUpper() == server2.ToUpper())
				{
					bLinked = true;
					break;
				}
			}
			reader.Close();
			conn.Close();
			return bLinked;
		}		

		// Removes server2 from the linked servers list of server1
		public static bool RemoveLinkedServer(string server1, string DB1, string server2)
		{
			SqlConnection conn = new SqlConnection();
			conn.ConnectionString = "Data Source=" + server1 + ";Initial Catalog=" 
				+ DB1 + ";Trusted_Connection=True";
			conn.Open();
			SqlCommand cmd = new SqlCommand();
			cmd.Connection = conn;
			cmd.CommandType = CommandType.Text;
			cmd.CommandText = "sp_dropserver '" + server2 + "'";
			SqlDataReader reader  = cmd.ExecuteReader();						

			reader.Close();
			conn.Close();
			return true;
		}

		// Prints to the console and to the log file
		public static void Print(string msg, StreamWriter sw)
		{
			// print to the log file			
			sw.WriteLine(msg);	
			
			// display message on console
			Console.WriteLine(msg);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\DBLookup\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\DBLookup\DBLookup.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Data;
using System.Data.SqlClient;    
using System.IO;
using System.Threading;
using System.Text;

namespace DBLookup
{
    
    /// <summary>
	/// Summary description for DBLookupForm
	/// </summary>
    public class DBLookupForm : System.Windows.Forms.Form
    {
        public enum OutputType
        {
            MSG = 0x1,
            DATA = 0x2,
            ALL = (MSG | DATA)
        };

        private static System.IO.StreamWriter g_writer = null;
        private static string g_ServersFilename = "servers.ini";
        private static string g_HistoryFilename = "history.ini";
        private static int g_MaxRecordsToRetrieve = 500;

        private ConnectionData[] connectionData;
        private ManualResetEvent[] queryCompletionEvents;
        public static bool bGotData = false;
        
        private System.Windows.Forms.TextBox QueryText;
        private System.Windows.Forms.Button ClearBtn;
        private System.Windows.Forms.Button GoBtn;
        private System.Windows.Forms.Label QueryLabel;
        private System.Windows.Forms.Label ServerLabel;
        private System.Windows.Forms.Panel QueryPanel;
        private System.Windows.Forms.ListBox ServerList;
        private System.Windows.Forms.TextBox ResultsText;
        private System.Windows.Forms.ComboBox QueryHistory;
        private System.Windows.Forms.Button UseHistoryBtn;
        private System.Windows.Forms.Button AllBtn;
        private System.Windows.Forms.Button NoneBtn;
        private System.Windows.Forms.DataGrid myDataGrid;
        private System.Windows.Forms.Button SwitchViewBtn;
        private System.Windows.Forms.StatusBar myStatusBar;
        private System.Windows.Forms.StatusBarPanel panel1;
        private System.Windows.Forms.Button CopyClipboardBtn;
        private System.Windows.Forms.Button AddServerBtn;
        private System.Windows.Forms.Button RemoveServerBtn;

        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.Container components = null;

        public DBLookupForm() : this(g_ServersFilename) {}
        public DBLookupForm(string serversFilename)
        {
            //
            // Required for Windows Form Designer support
            //
            InitializeComponent();

            //
            // TODO: Add any constructor code after InitializeComponent call
            //
            OutputReset();
            PopulateServers(LoadServers(serversFilename), ServerList);
            LoadHistory();
        }

        #region Windows Form Designer generated code
        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        protected override void Dispose( bool disposing )
        {
            if( disposing )
            {
                if (components != null) 
                {
                    components.Dispose();
                }
            }
            base.Dispose( disposing );
        }

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.QueryLabel = new System.Windows.Forms.Label();
            this.QueryText = new System.Windows.Forms.TextBox();
            this.ServerLabel = new System.Windows.Forms.Label();
            this.ClearBtn = new System.Windows.Forms.Button();
            this.GoBtn = new System.Windows.Forms.Button();
            this.QueryPanel = new System.Windows.Forms.Panel();
            this.NoneBtn = new System.Windows.Forms.Button();
            this.AllBtn = new System.Windows.Forms.Button();
            this.UseHistoryBtn = new System.Windows.Forms.Button();
            this.QueryHistory = new System.Windows.Forms.ComboBox();
            this.ServerList = new System.Windows.Forms.ListBox();
            this.ResultsText = new System.Windows.Forms.TextBox();
            this.myDataGrid = new System.Windows.Forms.DataGrid();
            this.SwitchViewBtn = new System.Windows.Forms.Button();
            this.myStatusBar = new System.Windows.Forms.StatusBar();
            this.panel1 = new System.Windows.Forms.StatusBarPanel();
            this.CopyClipboardBtn = new System.Windows.Forms.Button();
            this.AddServerBtn = new System.Windows.Forms.Button();
            this.RemoveServerBtn = new System.Windows.Forms.Button();
            this.QueryPanel.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.myDataGrid)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.panel1)).BeginInit();
            this.SuspendLayout();
            // 
            // QueryLabel
            // 
            this.QueryLabel.Location = new System.Drawing.Point(0, 0);
            this.QueryLabel.Name = "QueryLabel";
            this.QueryLabel.Size = new System.Drawing.Size(100, 16);
            this.QueryLabel.TabIndex = 0;
            this.QueryLabel.Text = "Query:";
            // 
            // QueryText
            // 
            this.QueryText.AcceptsReturn = true;
            this.QueryText.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
                | System.Windows.Forms.AnchorStyles.Left) 
                | System.Windows.Forms.AnchorStyles.Right)));
            this.QueryText.Font = new System.Drawing.Font("Courier New", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
            this.QueryText.Location = new System.Drawing.Point(0, 16);
            this.QueryText.MaxLength = 65534;
            this.QueryText.Multiline = true;
            this.QueryText.Name = "QueryText";
            this.QueryText.ScrollBars = System.Windows.Forms.ScrollBars.Vertical;
            this.QueryText.Size = new System.Drawing.Size(760, 88);
            this.QueryText.TabIndex = 1;
            this.QueryText.Text = "use uodb select * from t_title_trust_constants";
            this.QueryText.KeyPress += new System.Windows.Forms.KeyPressEventHandler(this.QueryText_KeyPress);
            this.QueryText.TextChanged += new System.EventHandler(this.QueryText_TextChanged);
            // 
            // ServerLabel
            // 
            this.ServerLabel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
            this.ServerLabel.Location = new System.Drawing.Point(768, 0);
            this.ServerLabel.Name = "ServerLabel";
            this.ServerLabel.Size = new System.Drawing.Size(100, 16);
            this.ServerLabel.TabIndex = 3;
            this.ServerLabel.Text = "Servers:";
            // 
            // ClearBtn
            // 
            this.ClearBtn.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
            this.ClearBtn.Location = new System.Drawing.Point(88, 128);
            this.ClearBtn.Name = "ClearBtn";
            this.ClearBtn.Size = new System.Drawing.Size(75, 20);
            this.ClearBtn.TabIndex = 4;
            this.ClearBtn.Text = "Clear";
            this.ClearBtn.Click += new System.EventHandler(this.ClearBtn_Click);
            // 
            // GoBtn
            // 
            this.GoBtn.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
            this.GoBtn.Location = new System.Drawing.Point(0, 128);
            this.GoBtn.Name = "GoBtn";
            this.GoBtn.Size = new System.Drawing.Size(75, 20);
            this.GoBtn.TabIndex = 5;
            this.GoBtn.Text = "Go";
            this.GoBtn.Click += new System.EventHandler(this.GoBtn_Click);
            // 
            // QueryPanel
            // 
            this.QueryPanel.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
                | System.Windows.Forms.AnchorStyles.Right)));
            this.QueryPanel.Controls.Add(this.RemoveServerBtn);
            this.QueryPanel.Controls.Add(this.AddServerBtn);
            this.QueryPanel.Controls.Add(this.NoneBtn);
            this.QueryPanel.Controls.Add(this.AllBtn);
            this.QueryPanel.Controls.Add(this.UseHistoryBtn);
            this.QueryPanel.Controls.Add(this.QueryHistory);
            this.QueryPanel.Controls.Add(this.ServerLabel);
            this.QueryPanel.Controls.Add(this.QueryLabel);
            this.QueryPanel.Controls.Add(this.QueryText);
            this.QueryPanel.Controls.Add(this.ServerList);
            this.QueryPanel.Controls.Add(this.GoBtn);
            this.QueryPanel.Controls.Add(this.ClearBtn);
            this.QueryPanel.Location = new System.Drawing.Point(8, 8);
            this.QueryPanel.Name = "QueryPanel";
            this.QueryPanel.Size = new System.Drawing.Size(864, 152);
            this.QueryPanel.TabIndex = 6;
            // 
            // NoneBtn
            // 
            this.NoneBtn.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
            this.NoneBtn.Location = new System.Drawing.Point(824, 128);
            this.NoneBtn.Name = "NoneBtn";
            this.NoneBtn.Size = new System.Drawing.Size(40, 20);
            this.NoneBtn.TabIndex = 9;
            this.NoneBtn.Text = "None";
            this.NoneBtn.Click += new System.EventHandler(this.NoneBtn_Click);
            // 
            // AllBtn
            // 
            this.AllBtn.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
            this.AllBtn.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
            this.AllBtn.Location = new System.Drawing.Point(768, 128);
            this.AllBtn.Name = "AllBtn";
            this.AllBtn.Size = new System.Drawing.Size(48, 20);
            this.AllBtn.TabIndex = 8;
            this.AllBtn.Text = "All";
            this.AllBtn.Click += new System.EventHandler(this.AllBtn_Click);
            // 
            // UseHistoryBtn
            // 
            this.UseHistoryBtn.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
            this.UseHistoryBtn.Location = new System.Drawing.Point(680, 128);
            this.UseHistoryBtn.Name = "UseHistoryBtn";
            this.UseHistoryBtn.Size = new System.Drawing.Size(75, 20);
            this.UseHistoryBtn.TabIndex = 7;
            this.UseHistoryBtn.Text = "Use";
            this.UseHistoryBtn.Click += new System.EventHandler(this.UseHistoryBtn_Click);
            // 
            // QueryHistory
            // 
            this.QueryHistory.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left) 
                | System.Windows.Forms.AnchorStyles.Right)));
            this.QueryHistory.Location = new System.Drawing.Point(0, 104);
            this.QueryHistory.Name = "QueryHistory";
            this.QueryHistory.Size = new System.Drawing.Size(760, 21);
            this.QueryHistory.TabIndex = 6;
            this.QueryHistory.SelectionChangeCommitted += new System.EventHandler(this.QueryHistory_SelectionChangeCommitted);
            // 
            // ServerList
            // 
            this.ServerList.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
            this.ServerList.Location = new System.Drawing.Point(768, 16);
            this.ServerList.Name = "ServerList";
            this.ServerList.SelectionMode = System.Windows.Forms.SelectionMode.MultiSimple;
            this.ServerList.Size = new System.Drawing.Size(96, 108);
            this.ServerList.TabIndex = 2;
            // 
            // ResultsText
            // 
            this.ResultsText.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left) 
                | System.Windows.Forms.AnchorStyles.Right)));
            this.ResultsText.Location = new System.Drawing.Point(336, 616);
            this.ResultsText.MaxLength = 500000;
            this.ResultsText.Multiline = true;
            this.ResultsText.Name = "ResultsText";
            this.ResultsText.ScrollBars = System.Windows.Forms.ScrollBars.Both;
            this.ResultsText.Size = new System.Drawing.Size(536, 32);
            this.ResultsText.TabIndex = 7;
            this.ResultsText.Text = "ResultsText";
            this.ResultsText.WordWrap = false;
            // 
            // myDataGrid
            // 
            this.myDataGrid.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
                | System.Windows.Forms.AnchorStyles.Left) 
                | System.Windows.Forms.AnchorStyles.Right)));
            this.myDataGrid.DataMember = "";
            this.myDataGrid.HeaderForeColor = System.Drawing.SystemColors.ControlText;
            this.myDataGrid.Location = new System.Drawing.Point(8, 160);
            this.myDataGrid.Name = "myDataGrid";
            this.myDataGrid.ParentRowsVisible = false;
            this.myDataGrid.PreferredColumnWidth = 60;
            this.myDataGrid.ReadOnly = true;
            this.myDataGrid.RowHeaderWidth = 45;
            this.myDataGrid.Size = new System.Drawing.Size(864, 464);
            this.myDataGrid.TabIndex = 10;
            this.myDataGrid.MouseDown += new MouseEventHandler(this.myDataGrid_MouseDown);

            // 
            // SwitchViewBtn
            // 
            this.SwitchViewBtn.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
            this.SwitchViewBtn.Location = new System.Drawing.Point(8, 624);
            this.SwitchViewBtn.Name = "SwitchViewBtn";
            this.SwitchViewBtn.Size = new System.Drawing.Size(128, 20);
            this.SwitchViewBtn.TabIndex = 11;
            this.SwitchViewBtn.Text = "Switch to Text";
            this.SwitchViewBtn.Click += new System.EventHandler(this.SwitchViewBtn_Click);
            // 
            // myStatusBar
            // 
            this.myStatusBar.Location = new System.Drawing.Point(0, 648);
            this.myStatusBar.Name = "myStatusBar";
            this.myStatusBar.Panels.AddRange(new System.Windows.Forms.StatusBarPanel[] {
                                                                                           this.panel1});
            this.myStatusBar.ShowPanels = true;
            this.myStatusBar.Size = new System.Drawing.Size(880, 22);
            this.myStatusBar.TabIndex = 12;
            this.myStatusBar.Text = "statusBar1";
            // 
            // panel1
            // 
            this.panel1.AutoSize = System.Windows.Forms.StatusBarPanelAutoSize.Spring;
            this.panel1.Text = "OK";
            this.panel1.Width = 864;
            // 
            // CopyClipboardBtn
            // 
            this.CopyClipboardBtn.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
            this.CopyClipboardBtn.Location = new System.Drawing.Point(152, 624);
            this.CopyClipboardBtn.Name = "CopyClipboardBtn";
            this.CopyClipboardBtn.Size = new System.Drawing.Size(128, 20);
            this.CopyClipboardBtn.TabIndex = 13;
            this.CopyClipboardBtn.Text = "Copy to Clipboard";
            this.CopyClipboardBtn.Visible = false;
            this.CopyClipboardBtn.Click += new System.EventHandler(this.CopyClipboardBtn_Click);
            // 
            // AddServerBtn
            // 
            this.AddServerBtn.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
            this.AddServerBtn.Location = new System.Drawing.Point(816, 0);
            this.AddServerBtn.Name = "AddServerBtn";
            this.AddServerBtn.Size = new System.Drawing.Size(19, 15);
            this.AddServerBtn.TabIndex = 10;
            this.AddServerBtn.Text = "+";
            this.AddServerBtn.Visible = false;
            this.AddServerBtn.Click += new System.EventHandler(this.AddServerBtn_Click);
            // 
            // RemoveServerBtn
            // 
            this.RemoveServerBtn.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
            this.RemoveServerBtn.Location = new System.Drawing.Point(840, 0);
            this.RemoveServerBtn.Name = "RemoveServerBtn";
            this.RemoveServerBtn.Size = new System.Drawing.Size(19, 15);
            this.RemoveServerBtn.TabIndex = 11;
            this.RemoveServerBtn.Text = "-";
            this.RemoveServerBtn.Visible = false;
            // 
            // DBLookupForm
            // 
            this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
            this.ClientSize = new System.Drawing.Size(880, 670);
            this.Controls.Add(this.CopyClipboardBtn);
            this.Controls.Add(this.myStatusBar);
            this.Controls.Add(this.SwitchViewBtn);
            this.Controls.Add(this.ResultsText);
            this.Controls.Add(this.QueryPanel);
            this.Controls.Add(this.myDataGrid);
            this.MinimumSize = new System.Drawing.Size(400, 300);
            this.Name = "DBLookupForm";
            this.Text = "DBLookupForm";
            this.Disposed += new System.EventHandler(this.DBLookupForm_Disposed);
            this.Resize += new System.EventHandler(this.DBLookupForm_Resize);
            this.Load += new System.EventHandler(this.DBLookupForm_Load);
            this.QueryPanel.ResumeLayout(false);
            ((System.ComponentModel.ISupportInitialize)(this.myDataGrid)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.panel1)).EndInit();
            this.ResumeLayout(false);

        }
        #endregion


        private void DBLookupForm_Load(object sender, System.EventArgs e)
        {
            // Show grid, hide text output
            myDataGrid.Visible = true;
            ResultsText.Visible = false;
            ResultsText.Anchor = myDataGrid.Anchor;
            ResultsText.Location = myDataGrid.Location;
            ResultsText.Size = myDataGrid.Size;

            // Select All servers
            for (int i = 0; i < ServerList.Items.Count; i++)
            {
                ServerList.SetSelected(i, true);
            }

            // Spawn worker threads to connect to the databases
            CreateConnections(ServerList.SelectedItems);
        }

        private void DBLookupForm_Resize(object sender, System.EventArgs e)
        {
        }

        private void DBLookupForm_Disposed(object sender, System.EventArgs e)
        {
            if (connectionData == null)
                return;
            Output("Closing connections...");
            for (int i = 0; i < connectionData.Length; i++)
            {
                if (connectionData[i] != null)
                    connectionData[i].Close();
            }
            SaveServers(g_ServersFilename);
            DBLookupForm.g_writer.Close();
        }

        private void ClearBtn_Click(object sender, System.EventArgs e)
        {
            QueryText.Clear();
        }

        private void QueryText_TextChanged(object sender, System.EventArgs e)
        {
        
        }
        private void QueryText_KeyPress(object sender, KeyPressEventArgs e)
        {
            // Execute query if ENTER pressed
            if (e.KeyChar == (char)13)
            {
                ExecuteQuery(QueryText.Text);
                e.Handled = true;
            }
            // Select all if CTRL-A pressed
            // (I'm not entirely sure this is the correct keycode, but it does work)
            if (e.KeyChar == 0x1)
            {
                QueryText.SelectAll();
                e.Handled = true;
            }
        }

        public void SaveServers(string filename)
        {
            StreamWriter sw;
            try 
            {
                sw = new StreamWriter(filename, false);
                for (int i = 0; i < ServerList.Items.Count; i++)
                {
                    sw.WriteLine(ServerList.Items[i].ToString());
                }
                sw.Close();
            }
            catch (Exception e)
            {
                Output(OutputType.MSG, "Error saving servers: " + e.Message);
            }

        }

        public String[] LoadServers(string filename)
        {
            try 
            {
                StreamReader sr = new StreamReader(filename);
                String s;
                ArrayList servers = new ArrayList(7);

                while ((s = sr.ReadLine()) != null)
                {
                    if (s == "")
                        continue;
                    servers.Add(s);
                }
                sr.Close();
                return (String[])servers.ToArray(typeof(String));
            }
            catch (System.IO.FileNotFoundException)
            {
                String[] list = new String[7] { "XeUserSQLW01", "XeUserSQLW02", "XeUserSQLW03", "XeUserSQLW04", "XeUserSQLW05", "XeUserSQLW06", "XeUserSQLW07" };
                return list;
            }
        }

        private void PopulateServers(string[] servers, ListBox control)
        {
            foreach (String s in servers)
            {
                control.Items.Add(s);
            }
        }


        private void LoadHistory()
        {
            try
            {
                StreamReader sr = new StreamReader(g_HistoryFilename);
                string s;
                while ((s = sr.ReadLine()) != null)
                {
                    QueryHistory.Items.Add(s);
                }
                QueryHistory.SelectedIndex = 0;
                sr.Close();
            }
            catch (System.IO.FileNotFoundException)
            {
                return;
            }
        }

        private void SaveHistory(string query)
        {
            // Does this item already exist in list?
            int idx;
            if ((idx = QueryHistory.FindStringExact(query)) > -1)
            {
                // Bump to top
                object item = QueryHistory.Items[idx];
                QueryHistory.Items.RemoveAt(idx);
                QueryHistory.Items.Insert(0, item);
                QueryHistory.SelectedIndex = 0;
                return;
            }

            // Add to top
            QueryHistory.Items.Add(query);
            QueryHistory.SelectedIndex = QueryHistory.Items.Count - 1;
            
            // Write to file
            try 
            {
                StreamWriter sw = new StreamWriter(g_HistoryFilename, true);
                sw.WriteLine(query);
                sw.Close();
            }
            catch (Exception e)
            {
                Output(OutputType.MSG, "Error writing history: " + e.Message);
            }
        }


        private void CreateConnections(ListBox.SelectedObjectCollection servers)
        {
            connectionData = new ConnectionData[servers.Count];
            queryCompletionEvents = new ManualResetEvent[servers.Count];
            for (int i = 0; i < servers.Count; i++)
            {
                queryCompletionEvents[i] = new ManualResetEvent(false);
                connectionData[i] = new ConnectionData(servers[i].ToString(), ref queryCompletionEvents[i]);
            }
        }

#if false
        static void OpenConnectionWorker(object TargetDetails)
        {
            ConnectionData cd = (ConnectionData)TargetDetails;
            cd.Open();
            cd.OnCompletionEvent.Set();
        }    


        private void WaitForConnections()
        {
            // Let's try waiting here... not ideal
            Output("Waiting for connection worker threads...");
            this.Cursor = Cursors.WaitCursor;
            WaitHandle.WaitAll(openCompletionEvents);
            this.Cursor = Cursors.Default;
        }
#endif

        static void ExecuteQueryWorker(object TargetDetails)
        {
            try
            {
                ConnectionData cd = (ConnectionData)TargetDetails;
                cd.ExecuteDataAdapter(cd.queryStr, g_MaxRecordsToRetrieve);
                DBLookupForm.bGotData = true;
            }
            catch (Exception e)
            {
                Console.WriteLine("ExecuteQueryWorker: " + e.Message);
                return;
            }
        }

        private void ExecuteQuery(string query)
        {
            // Strip query of extraneous linefeeds, etc
            string trimChars = " \n\r";
            query = query.Trim(trimChars.ToCharArray());

            // Let's make sure this is a SELECT query
            // Do it naively for now
            if (query.ToLower().IndexOf("select ") == -1)
            {
                DialogResult res = MessageBox.Show(this, "Your query should be a SELECT statement unless you really, really know what you're doing. Do you want to continue?", "Warning, dangerous query", MessageBoxButtons.YesNo, MessageBoxIcon.Warning, MessageBoxDefaultButton.Button2);
                if (res == DialogResult.No)
                    return;
            }

            Output("Executing: " + query);
            if (connectionData == null)
            {
                Output("No connections available");
                return;
            }
            OutputReset();
            bGotData = false;

            // For the datagrid
            DataSet myDataSet = new DataSet();

            // Reset the wait events
            for (int i = 0; i < queryCompletionEvents.Length; i++)
            {
                queryCompletionEvents[i].Reset();
            }

            // We could query every connected database, but instead I think we should only do
            // the ones that are selected.  Assume they match up with the array here.
            this.Cursor = Cursors.WaitCursor;
            for (int selectedIdx = 0; selectedIdx < ServerList.SelectedIndices.Count; selectedIdx++)
            {
                int serverNum = ServerList.SelectedIndices[selectedIdx];
                if (connectionData[serverNum] == null)
                    continue;

                // Create threads to open connection and execute query
                //
                connectionData[serverNum].dataSet = myDataSet;
                connectionData[serverNum].queryStr = query;

                // This is how you create a thread:
                ThreadPool.QueueUserWorkItem(new WaitCallback(ExecuteQueryWorker), connectionData[serverNum]);
                Thread.Sleep(0);
            }

            // Wait for all threads to finish
            WaitHandle.WaitAll(queryCompletionEvents);

            this.Cursor = Cursors.Default;
            
            // Execute succeeded, so let's save it in the history
            SaveHistory(query);

            if (bGotData)
            {
                // Dump it
                myDataGrid.CaptionText = query;
                DumpDataSet(myDataSet);
            }
            
        }
        public void DumpDataSet(DataSet myDataSet)
        {
            // Dump contents of dataset
            //
            int totalRecordCount = 0;
            string statusMsg;
            for (int selectedIdx = 0; selectedIdx < ServerList.SelectedIndices.Count; selectedIdx++)
            {
                int serverNum = ServerList.SelectedIndices[selectedIdx];
                if (connectionData[serverNum] == null)
                    continue;
                string serverNameStr = connectionData[serverNum].GetServerName();
                try 
                {
                    DataTable table = myDataSet.Tables[serverNameStr];
                    table.TableName = String.Format("{0} {1} records", serverNameStr, connectionData[serverNum].recordCount);

                    // If first iteration, dump table header, otherwise just dump data
                    if (selectedIdx == 0)
                    {
                        DumpTableHeader(table, "SERVERNAME");
                    }
                    DumpTableData(table, serverNameStr);
                    connectionData[serverNum].Close();
                }
                catch (Exception e)
                {
                    Output(OutputType.MSG, "DumpDataSet() error: {0}", e.Message);
                    continue;
                }

                statusMsg = String.Format("Retrieved {0} records from {1}", connectionData[serverNum].recordCount, serverNameStr);
                Output(OutputType.MSG, statusMsg);
                totalRecordCount += connectionData[serverNum].recordCount;
                OutputFlush();
            }

            statusMsg = String.Format("Retrieved {0} total records", totalRecordCount);
            Output(OutputType.MSG, statusMsg);
            myStatusBar.Panels[0].Text = statusMsg;

            myDataGrid.DataSource = myDataSet;
            myDataGrid.Expand(-1);
        }

        private void DumpTableHeader(DataTable table, string prefix)
        {
            StringBuilder sbColumnNames = new StringBuilder(500);
            if (prefix != null && prefix != "")
                sbColumnNames.Append(prefix + "\t");
            for (int i = 0; i < table.Columns.Count; i++)
            {
                sbColumnNames.Append(table.Columns[i].ColumnName + "\t");
            }
            Output(OutputType.DATA, sbColumnNames.ToString());
        }

        private int DumpTableData(DataTable table, string prefix)
        {
            // Spit out all the data
            int recordcount2 = 0;
            for (int row = 0; row < table.Rows.Count; row++)
            {
                StringBuilder sb = new StringBuilder(prefix, 500);
                foreach (object field in table.Rows[row].ItemArray)
                {
                    if (field.GetType() == System.Type.GetType("System.Byte[]"))
                    {
                        byte[] data = (byte[])field;
                        sb.Append(tohex(data, false) + "\t");
                    }
                    else 
                    {
                        string s = field.ToString();
                        sb.Append(s + "\t");
                    }
                }
                Output(OutputType.DATA, sb.ToString());
                recordcount2++;
            }
            return recordcount2;
        }

        public static string tohex(byte[] bytes, bool reverse )
        {
            StringBuilder s = new StringBuilder(bytes.Length * 2);
            if( reverse )
            {
                for (int i = bytes.Length - 1; i >= 0; i--)
                    s.AppendFormat("{0:X2}", bytes[i]);
            }
            else
            {
                for (int i = 0; i < bytes.Length; i++)
                    s.AppendFormat("{0:X2}", bytes[i]);
            }
            return s.ToString();
        }

        public void Output(string format, params object[] arg) { Output(OutputType.MSG, format, arg); }
        public void Output(OutputType where, string format, params object[] arg)
        {
            if ((where & OutputType.MSG) != 0)
                Console.WriteLine(format, arg);
            if ((where & OutputType.DATA) != 0) 
            {
                DBLookupForm.g_writer.WriteLine(format, arg);
                ResultsText.AppendText(String.Format(format, arg) + "\r\n");    
            }
        }

        public void OutputFlush()
        {
            g_writer.Flush();
        }

        public void OutputReset()
        {
            if (g_writer != null)
                g_writer.Close();
            g_writer = new System.IO.StreamWriter("out.txt", false);
            g_writer.AutoFlush = true;
            ResultsText.Clear();
        }

        private void GoBtn_Click(object sender, System.EventArgs e)
        {
            ExecuteQuery(QueryText.Text);
            
        }

        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        /// 
        [MTAThread]
        static void Main()
        {
            DBLookupForm dbform = new DBLookupForm();
            Application.Run(dbform);
        }

        private void QueryHistory_SelectionChangeCommitted(object sender, System.EventArgs e)
        {
            QueryText.Text = QueryHistory.SelectedItem.ToString();
        }

        private void UseHistoryBtn_Click(object sender, System.EventArgs e)
        {
            QueryText.Text = QueryHistory.Text;
        }

        private void AllBtn_Click(object sender, System.EventArgs e)
        {
            for (int i = 0; i < ServerList.Items.Count; i++)
            {
                ServerList.SetSelected(i, true);
            }
        }

        private void NoneBtn_Click(object sender, System.EventArgs e)
        {
            for (int i = 0; i < ServerList.Items.Count; i++)
            {
                ServerList.SetSelected(i, false);
            }
        }

        private void SwitchViewBtn_Click(object sender, System.EventArgs e)
        {
            if (myDataGrid.Visible)
            {
                SwitchViewBtn.Text = "Switch to grid";
                myDataGrid.Visible = false;
                ResultsText.Visible = true;
            }
            else
            {
                SwitchViewBtn.Text = "Switch to text";
                ResultsText.Visible = false;
                myDataGrid.Visible = true;
            }
        }

        private void CopyClipboardBtn_Click(object sender, System.EventArgs e)
        {
            // This doesn't seem to work in multi-threaded app, it throws an exception and
            // says to specify STAThread attribute.  So we'll just disable the button for now.
            Clipboard.SetDataObject(ResultsText.Text);
        }

        private void AddServerBtn_Click(object sender, System.EventArgs e)
        {
        
        }


        private void myDataGrid_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            // I would like to pop up a hex version of byte arrays at this point, if the user
            // right-clicks on a byte[] cell. I can't figure out how to do this in C# at the moment
            // however.
            if (e.Button == MouseButtons.Right)
            {
                DataGridCell cell = myDataGrid.CurrentCell;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\dbInstrument\sqlccConfig\Program.cs ===
using System;
using System.Collections.Generic;
using System.Collections;
using System.IO;
using System.Xml;
using System.Xml.Serialization;
using System.Text;

using Microsoft.Webstore.MetaData;
using Microsoft.Webstore.WstClient;

namespace SqlccConfig
{

    public class Program
    {

        static string[] instrumentDbList = new string[] {
            "titledb",
            "storedb",
            "uodb"        
        };

        static string dbInstrumentConfigFile;

        
        static public void WriteWebStoreConfgiureFile(string [] configServers)
        {

            // Create a writer to write XML to the console.
            XmlWriterSettings settings = new XmlWriterSettings();
            settings.Indent = true;
            settings.Encoding = Encoding.UTF8;
            XmlWriter writer = XmlWriter.Create("WstRuntime.config", settings);

            // Write the root element.
            writer.WriteStartElement("configuration");
            // Write an element with attributes.
            writer.WriteStartElement("WEBSTORE");
            writer.WriteStartElement("WEBSTOREMETADATA");
            writer.WriteStartElement("DATACENTER");
            writer.WriteAttributeString("NAME", "DEFAULTDATACENTER");
            writer.WriteEndElement();
            writer.WriteStartElement("SITES");
            writer.WriteStartElement("SITE");
            writer.WriteAttributeString("NAME", "DEFAULTCONFIG");
            writer.WriteStartElement("CONFIGS");

            foreach (string server in configServers) {
                writer.WriteStartElement("CONFIG");
                writer.WriteAttributeString("SERVERNAME", server);
                writer.WriteAttributeString("DATACENTERNAME", "DEFAULTDATACENTER");
                writer.WriteEndElement();
            }

            for(int i =0; i<6;i++)
                writer.WriteEndElement();

            // Write the XML to file and close the writer
            writer.Close();
        }

        public class CCDataBase
        {
            public string ServerName;
            public string DatabaseName;
            public string UserName;
            public string UserPassword;
            public string TraceShare;

            public void SetDataBase(CCDataBase o, string srvName, string dbName)
            {
                ServerName = srvName;
                DatabaseName = dbName;
                UserName = o.UserName;
                UserPassword = o.UserPassword;
                TraceShare = o.TraceShare;
            }            
        }

        [XmlRootAttribute("SqlccComponent", Namespace = "http://schemas.microsoft.com/test/sql/sqlcc/v3.0", IsNullable = false)]
        public class SqlccComponent { 
            public class ReportingDatabase{
                public string ServerName;
                public string DatabaseName;
                public string UserName;
                public string UserPassword;
                public string Type;
            }

            public string ComponentName;
            public string CustomVersion;
            public string ComponentShare;

            [XmlElement("ReportingDatabase")]
            public ReportingDatabase ReportingDb;            

            [XmlElement("Database")]
            public List<CCDataBase> dbList = new List<CCDataBase>();
        }


        static SqlccComponent Read(string filename)
        {
            XmlSerializer serializer = new XmlSerializer(typeof(SqlccComponent));
            FileStream fileStream = new FileStream(filename, FileMode.Open, FileAccess.Read);
            return (SqlccComponent)serializer.Deserialize(fileStream);
        }

        static void Write(string filename, SqlccComponent sqlCCComponent)
        {
            XmlSerializer serializer = new XmlSerializer(typeof(SqlccComponent));
            TextWriter textWriter = new StreamWriter(filename);
            serializer.Serialize(textWriter, sqlCCComponent);   
            textWriter.Close();
        }

        static void Main(string[] args)   
        {
            //should get from the optopus

            string[] configServers;
            string buildNo;
            string npdbServer;
  

            if (args.Length < 3)
            {
                Console.WriteLine("Missing parameters, expected more than 2!");
                return;
            }

            npdbServer = args[1];
            //Get build number
            buildNo = args[0];

            dbInstrumentConfigFile = npdbServer + '_' + buildNo + ".config";

            //Get the Configure Servers
            ArrayList list = new ArrayList();
            for (int j = 2; j < args.Length; j++) { 
                list.Add(args[j]);
            }

            configServers = (string [])list.ToArray(typeof(string));

            GenerateInstrumentConfigFile(configServers, buildNo);

            Console.WriteLine("Temporary Sql cc instrument configure file \"temp.config\" is generated!");
            
        }

        static void GenerateInstrumentConfigFile(string[] configServers, string buildNo)
        {


            SqlccComponent ccComp = Read("sqlcc.config");

            ccComp.CustomVersion = buildNo;

            CCDataBase ccDb = (CCDataBase)ccComp.dbList[0];

            ccComp.dbList.Clear();


            WriteWebStoreConfgiureFile(configServers);

            WebstoreConfig cfg = WebstoreMetaData.Instance.DefaultConfig;

            foreach (WebstoreDeployment dep in cfg.Deployments)
            {
                foreach (WebstoreSQLFss fss in dep.SQLFailSafeSets)
                {
                    foreach (WebstoreDatabase db in fss.Databases)
                    {
                          foreach(string targetDb in instrumentDbList) {
                              if(db.Name.ToLower().Equals(targetDb)) {
                                  CCDataBase addedDb = new CCDataBase();
                                    addedDb.SetDataBase(ccDb, db.ServerName, db.Name);
                                    ccComp.dbList.Add(addedDb);
                                    break;
                              }
                          }
//                        Console.WriteLine("{0}:{1}", db.ServerName, db.Name);
//                        Console.WriteLine("     IsPrimary = {0}", db.IsPrimary.ToString());
//                        Console.WriteLine("     Status = {0}", db.Status.ToString());
                    }

                }
            }

            //temporary instrument configure file, this file would be used by the instrument tool and trace collection tool.
            Write(dbInstrumentConfigFile, ccComp);

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\DBLookup\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_dblookup_none_12.4.56.0_none_ed504139aa5dc161
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_dblookup_no-public-key_12.4.56.0_x-ww_d28ca93b
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=dblookup
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_dblookup_no-public-key_12.4.56.0_x-ww_d28ca93b
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_dblookup_no-public-key_12.4.56.0_x-ww_d28ca93b.manifest
XP_MANIFEST_PATH=manifests\msil_dblookup_no-public-key_12.4.56.0_x-ww_d28ca93b.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_dblookup_no-public-key_12.4.56.0_x-ww_d28ca93b.cat
XP_CATALOG_PATH=manifests\msil_dblookup_no-public-key_12.4.56.0_x-ww_d28ca93b.cat
XP_PAYLOAD_PATH=msil_dblookup_no-public-key_12.4.56.0_x-ww_d28ca93b
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=dblookup,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\DBLookup\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_dblookup_none_12.4.56.0_none_ed504139aa5dc161
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_dblookup_no-public-key_12.4.56.0_x-ww_d28ca93b
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=dblookup
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_dblookup_no-public-key_12.4.56.0_x-ww_d28ca93b
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_dblookup_no-public-key_12.4.56.0_x-ww_d28ca93b.manifest
XP_MANIFEST_PATH=manifests\msil_dblookup_no-public-key_12.4.56.0_x-ww_d28ca93b.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_dblookup_no-public-key_12.4.56.0_x-ww_d28ca93b.cat
XP_CATALOG_PATH=manifests\msil_dblookup_no-public-key_12.4.56.0_x-ww_d28ca93b.cat
XP_PAYLOAD_PATH=msil_dblookup_no-public-key_12.4.56.0_x-ww_d28ca93b
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=dblookup,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\dbposter\DBPoster\dbposter.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Collections;
using System.Diagnostics;
using System.Xml;
using System.Text.RegularExpressions;
using ServerTestFramework.Utilities.DBPoster;
using ServerTestFramework.Utilities;
using ServerTestFramework;

namespace DBPosterTool
{
    public class DBPosterToolRunner
    {
        static bool IsParam(string s, string param)
        {
            if (s.Length > 0 && (s[0] == '-' || s[0] == '/') && s.Substring(1) == param)
            {
                return true;
            }
            return false;
        }

        public class InvalidParamException : System.Exception
        {
            public InvalidParamException() : base() {}
            public InvalidParamException(string s) : base(s) {}
            public InvalidParamException(string s, System.Exception e) : base(s, e) {}
        }

        static void Main(string[] args)
        {
            // Setup stf
            ServerTestFramework.Report.GetRoot().AddReportDestination(new DebugOutputReportDestination());
            ServerTestFramework.Report.GetRoot().AddReportDestination(new ConsoleReportDestination());

            CoreGlobal.Initialize(new XmlDataDocument());

            //
            bool paramInfo=false;
            string paramKEK=null;
            DBPMode paramMode=DBPMode.DBP_NONE;

            Environment.ExitCode = 1;

            try
            {
                int argshift = 0;

                if (args.Length == 0 || (args.Length == 1 && (args[0] == "/?" || args[0] == "-?" || args[0] == "-h")))
                {
                    throw new InvalidParamException("");
                }

                while (args.Length - argshift > 0)
                {
                    if (args.Length - argshift > 0 && IsParam(args[argshift], "info"))
                    {
                        paramInfo = true;
                        argshift++;
                    }
                    else if (args.Length - argshift > 1 && IsParam(args[argshift], "kek"))
                    {
                        if (!File.Exists(args[argshift + 1]))
                        {
                            throw new InvalidParamException("Invalid KEK file specified");
                        }
                        StreamReader sr = new StreamReader(args[argshift + 1]);
                        paramKEK = sr.ReadLine().Trim();
                        sr.Close();
                        argshift += 2;
                    }
                    else
                    {
                        break;
                    }
                }

                if (args.Length - argshift > 0 && (IsParam(args[argshift], "add") || IsParam(args[argshift], "insert")))
                {
                    paramMode = DBPMode.DBP_ADD;
                    argshift++;
                }
                else if (args.Length - argshift > 0 && IsParam(args[argshift], "update"))
                {
                    paramMode = DBPMode.DBP_UPDATE;
                    argshift++;
                }

                if (paramMode == DBPMode.DBP_NONE)
                {
                    throw new InvalidParamException("Mode not specified.");
                }

                try
                {
                    if (args.Length - argshift == 2 && File.Exists(args[argshift]) && File.Exists(args[1 + argshift]))
                    {
                        DBPoster.Post(paramMode, args[argshift], args[1 + argshift], paramKEK, paramInfo);
                    }
                    else if (!File.Exists(args[argshift]))
                    {
                        throw new ImportFileException("File " + args[argshift] + " does not exist.");
                    }
                    else if (!File.Exists(args[1 + argshift]))
                    {
                        throw new ImportFileException("File " + args[1 + argshift] + " does not exist.");
                    }
                    else
                    {
                        throw new InvalidParamException();
                    }

                    Environment.ExitCode = 0;
                }
                catch(ImportFileException e)
                {
                    Console.WriteLine(e.Message);
                }
            }
            catch(InvalidParamException e)
            {
                Console.WriteLine(e.Message);
                Usage();
            }
        }

        static void Usage()
        {
            Console.WriteLine("usage:");
            Console.WriteLine("  DBPoster [-info] [-kek kekfile] -{add|compare|remove|update} <table description file> <file to post>");
            Console.WriteLine("       -add: Inserts new record, fails if it already exists");
            Console.WriteLine("    -update: Performs an update if the record exists, otherwises inserts new record");
            Console.WriteLine("   -compare: Checks for the existence of the record");
            Console.WriteLine("    -remove: Removes rows from database. Warning: many tables have primary keys that we don't");
            Console.WriteLine("             know about (such as generated PUIDs). Remove will fail for these. You probably");
            Console.WriteLine("             shouldn't be using this feature unless you know what you're doing.");
            Console.WriteLine("      -info: (In conjunction with one of the above) Will print the command instead of executing it");
            Console.WriteLine("       -kek: Read the en-encrypted key encryption key from kekfile, which should contain a single");
            Console.WriteLine("             hex string (with or without \"0x\") of 32 bytes (64 actual hex characters).");
            Console.WriteLine("");
            Console.WriteLine("  The <table description file> specifies which columns are primary keys, which are needed for");
            Console.WriteLine("  -update, -compare, and -remove.  The first column in the .ini file, before the DB column name,");
            Console.WriteLine("  is a number. If this number is greater than 0, it is treated as a primary key. Multiple keys");
            Console.WriteLine("  are allowed.");
        }

    } //class DBPoster
} //namespace DBPosterTool
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\dbposter\DBPoster\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\dbposter\DBPoster\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\dbposter\DecryptKey\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\dbposter\DecryptKey\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\dbposter\DBPoster\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_dbposter_none_12.4.56.0_none_f4ed35199ef46dfc
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_dbposter_no-public-key_12.4.56.0_x-ww_33635f4e
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=dbposter
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_dbposter_no-public-key_12.4.56.0_x-ww_33635f4e
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_dbposter_no-public-key_12.4.56.0_x-ww_33635f4e.manifest
XP_MANIFEST_PATH=manifests\msil_dbposter_no-public-key_12.4.56.0_x-ww_33635f4e.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_dbposter_no-public-key_12.4.56.0_x-ww_33635f4e.cat
XP_CATALOG_PATH=manifests\msil_dbposter_no-public-key_12.4.56.0_x-ww_33635f4e.cat
XP_PAYLOAD_PATH=msil_dbposter_no-public-key_12.4.56.0_x-ww_33635f4e
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=dbposter,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\dbposter\DecryptKey\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\dbposter\DBPoster\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_dbposter_none_12.4.56.0_none_f4ed35199ef46dfc
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_dbposter_no-public-key_12.4.56.0_x-ww_33635f4e
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=dbposter
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_dbposter_no-public-key_12.4.56.0_x-ww_33635f4e
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_dbposter_no-public-key_12.4.56.0_x-ww_33635f4e.manifest
XP_MANIFEST_PATH=manifests\msil_dbposter_no-public-key_12.4.56.0_x-ww_33635f4e.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_dbposter_no-public-key_12.4.56.0_x-ww_33635f4e.cat
XP_CATALOG_PATH=manifests\msil_dbposter_no-public-key_12.4.56.0_x-ww_33635f4e.cat
XP_PAYLOAD_PATH=msil_dbposter_no-public-key_12.4.56.0_x-ww_33635f4e
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=dbposter,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\dbposter\DecryptKey\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_decryptkey_none_12.4.56.0_none_ec39ab9f9ef8c9c9
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_decryptkey_no-public-key_12.4.56.0_x-ww_1e448095
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=decryptkey
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_decryptkey_no-public-key_12.4.56.0_x-ww_1e448095
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_decryptkey_no-public-key_12.4.56.0_x-ww_1e448095.manifest
XP_MANIFEST_PATH=manifests\msil_decryptkey_no-public-key_12.4.56.0_x-ww_1e448095.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_decryptkey_no-public-key_12.4.56.0_x-ww_1e448095.cat
XP_CATALOG_PATH=manifests\msil_decryptkey_no-public-key_12.4.56.0_x-ww_1e448095.cat
XP_PAYLOAD_PATH=msil_decryptkey_no-public-key_12.4.56.0_x-ww_1e448095
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=decryptkey,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\dbposter\DecryptKey\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_decryptkey_none_12.4.56.0_none_ec39ab9f9ef8c9c9
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_decryptkey_no-public-key_12.4.56.0_x-ww_1e448095
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=decryptkey
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_decryptkey_no-public-key_12.4.56.0_x-ww_1e448095
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_decryptkey_no-public-key_12.4.56.0_x-ww_1e448095.manifest
XP_MANIFEST_PATH=manifests\msil_decryptkey_no-public-key_12.4.56.0_x-ww_1e448095.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_decryptkey_no-public-key_12.4.56.0_x-ww_1e448095.cat
XP_CATALOG_PATH=manifests\msil_decryptkey_no-public-key_12.4.56.0_x-ww_1e448095.cat
XP_PAYLOAD_PATH=msil_decryptkey_no-public-key_12.4.56.0_x-ww_1e448095
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=decryptkey,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\DisableSub\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\DisableSub\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\dbposter\DecryptKey\DecryptKey.cs ===
using System;
using System.Security.Cryptography;
using System.Text;
using System.Collections;

using xonline.common.crypto;

namespace xonline.supersecret
{
    /// <summary>
    /// Given an encrypted service key, decrypt it using the master key.
    /// 
    /// The master keyset must exist on your computer, use something like:
    ///       Add: xkeymgr.exe storemk MasterKeyV1.prv
    ///    Remove: xkeymgr.exe removemk [version number]
    ///  Larry suggests always removing before adding. These files currently live in:
    ///        $corext\drop\debug\tools\xkeymgr\xkeymgr.exe
    ///        $corext\private\ops\sitecfg\XeTestNet\MasterKeyV1.prv
    ///        etc...
    ///  
    ///  Do not distribute this program, this is sensitive material.
    ///  
    ///  kgoodier 09/2004
    ///  
    /// </summary>
    public class CryptoReaderTool
    {

        public static void ShowHelp()
        {
            Console.WriteLine("Usage: DecryptKey.exe -key <hex encoded key> [-version masterKeyVersion] [-ascii]");
            Console.WriteLine("      -key: <hex encoded key> may optionally begin with 0x");
            Console.WriteLine("  -version: master key version to use. Default is 1.");
            Console.WriteLine("    -ascii: output key in both hex and ascii format. Default is hex only.");
            System.Environment.Exit(1);
        }

        static void Main(string[] args) 
        {
            uint masterKeyVersion = 1;
            bool bShowAscii = false;
            byte[] keyEncrypted = null;
            byte[] keyDecrypted = null;

            if (args.Length < 2)
                ShowHelp();

            for (int i = 0; i < args.Length; i++)
            {
                if (args[i].ToLower() == "-key")
                {
                    if (i+1 >= args.Length)
                        ShowHelp();
                    keyEncrypted = StringToHex((string)args[i+1]);
                    i++;
                }
                else if (args[i].ToLower() == "-version")
                {
                    if (i+1 >= args.Length)
                        ShowHelp();
                    masterKeyVersion = uint.Parse(args[i+1]);
                    i++;
                }
                else if (args[i].ToLower() == "-ascii")
                {
                    bShowAscii = true;
                }
            }
            Console.WriteLine("Decrypting with given key and MasterKeyVersion={0}", masterKeyVersion);

            try 
            {
                keyDecrypted = DecryptWithMasterKeyWrp((uint)masterKeyVersion, (uint)keyEncrypted.Length, keyEncrypted);
            }
            catch (Exception e)
            {
                Console.WriteLine("Error: " + e.Message);
                return;
            }

            Console.WriteLine("Decrypted key: " + HexToString(keyDecrypted));
            if (bShowAscii)
            {
                Console.WriteLine("Decrypted key (ascii): " + HexToAscii(keyDecrypted));
            }
        }

        static internal XoCryptoWrapperClass m_cryptoWrp = null;

        public static byte [] DecryptWithMasterKeyWrp (uint masterkeyver, uint encPasswordLength, byte[] encPassword)
        {
            if (m_cryptoWrp == null)
            {
                try
                {
                    m_cryptoWrp = new XoCryptoWrapperClass();
                }
                catch
                {
                    Console.WriteLine("Error creating crypto wrapper class. Did you run \"regs