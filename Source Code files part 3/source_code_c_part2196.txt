CINTERFACE)
    
    MIDL_INTERFACE("000214EA-0000-0000-C000-000000000046")
    IPersistFolder : public IPersist
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ __RPC__in PCIDLIST_ABSOLUTE pidl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPersistFolderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPersistFolder * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPersistFolder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPersistFolder * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassID )( 
            IPersistFolder * This,
            /* [out] */ __RPC__out CLSID *pClassID);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IPersistFolder * This,
            /* [in] */ __RPC__in PCIDLIST_ABSOLUTE pidl);
        
        END_INTERFACE
    } IPersistFolderVtbl;

    interface IPersistFolder
    {
        CONST_VTBL struct IPersistFolderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPersistFolder_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPersistFolder_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPersistFolder_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPersistFolder_GetClassID(This,pClassID)	\
    ( (This)->lpVtbl -> GetClassID(This,pClassID) ) 


#define IPersistFolder_Initialize(This,pidl)	\
    ( (This)->lpVtbl -> Initialize(This,pidl) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPersistFolder_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0004 */
/* [local] */ 

typedef IPersistFolder *LPPERSISTFOLDER;

#if (_WIN32_IE >= 0x0400)
#define IRTIR_TASK_NOT_RUNNING   0
#define IRTIR_TASK_RUNNING       1
#define IRTIR_TASK_SUSPENDED     2
#define IRTIR_TASK_PENDING       3
#define IRTIR_TASK_FINISHED      4


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0004_v0_0_s_ifspec;

#ifndef __IRunnableTask_INTERFACE_DEFINED__
#define __IRunnableTask_INTERFACE_DEFINED__

/* interface IRunnableTask */
/* [local][object][uuid] */ 


EXTERN_C const IID IID_IRunnableTask;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85788d00-6807-11d0-b810-00c04fd706ec")
    IRunnableTask : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Run( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Kill( 
            /* [in] */ 
            __in  BOOL bWait) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Suspend( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual ULONG STDMETHODCALLTYPE IsRunning( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRunnableTaskVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRunnableTask * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRunnableTask * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRunnableTask * This);
        
        HRESULT ( STDMETHODCALLTYPE *Run )( 
            IRunnableTask * This);
        
        HRESULT ( STDMETHODCALLTYPE *Kill )( 
            IRunnableTask * This,
            /* [in] */ 
            __in  BOOL bWait);
        
        HRESULT ( STDMETHODCALLTYPE *Suspend )( 
            IRunnableTask * This);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IRunnableTask * This);
        
        ULONG ( STDMETHODCALLTYPE *IsRunning )( 
            IRunnableTask * This);
        
        END_INTERFACE
    } IRunnableTaskVtbl;

    interface IRunnableTask
    {
        CONST_VTBL struct IRunnableTaskVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRunnableTask_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRunnableTask_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRunnableTask_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRunnableTask_Run(This)	\
    ( (This)->lpVtbl -> Run(This) ) 

#define IRunnableTask_Kill(This,bWait)	\
    ( (This)->lpVtbl -> Kill(This,bWait) ) 

#define IRunnableTask_Suspend(This)	\
    ( (This)->lpVtbl -> Suspend(This) ) 

#define IRunnableTask_Resume(This)	\
    ( (This)->lpVtbl -> Resume(This) ) 

#define IRunnableTask_IsRunning(This)	\
    ( (This)->lpVtbl -> IsRunning(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRunnableTask_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0005 */
/* [local] */ 

#define TOID_NULL                    GUID_NULL
#define ITSAT_DEFAULT_LPARAM         ((DWORD_PTR)-1)
#define ITSAT_DEFAULT_PRIORITY       0x10000000
#define ITSAT_MAX_PRIORITY           0x7fffffff
#define ITSAT_MIN_PRIORITY           0x00000000
#define ITSSFLAG_COMPLETE_ON_DESTROY 0x0000 // wait for the current task to complete before deleting the scheduler
#define ITSSFLAG_KILL_ON_DESTROY     0x0001 // kill the current task (if there is one) when the task scheduler is deleted
#define ITSSFLAG_FLAGS_MASK          0x0003
#define ITSS_THREAD_DESTROY_DEFAULT_TIMEOUT  (10*1000)       // default milliseconds until a sleeping worker thread is released
#define ITSS_THREAD_TERMINATE_TIMEOUT        (INFINITE)      // set sleeping worker threads to never be released
#define ITSS_THREAD_TIMEOUT_NO_CHANGE        (INFINITE - 1)  // no change to the thread timeout


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0005_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0005_v0_0_s_ifspec;

#ifndef __IShellTaskScheduler_INTERFACE_DEFINED__
#define __IShellTaskScheduler_INTERFACE_DEFINED__

/* interface IShellTaskScheduler */
/* [local][object][uuid] */ 


EXTERN_C const IID IID_IShellTaskScheduler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6CCB7BE0-6807-11d0-B810-00C04FD706EC")
    IShellTaskScheduler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddTask( 
            /* [in] */ 
            __in  IRunnableTask *prt,
            /* [in] */ 
            __in  REFTASKOWNERID rtoid,
            /* [in] */ 
            __in  DWORD_PTR lParam,
            /* [in] */ 
            __in  DWORD dwPriority) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveTasks( 
            /* [in] */ 
            __in  REFTASKOWNERID rtoid,
            /* [in] */ 
            __in  DWORD_PTR lParam,
            /* [in] */ 
            __in  BOOL bWaitIfRunning) = 0;
        
        virtual UINT STDMETHODCALLTYPE CountTasks( 
            /* [in] */ 
            __in  REFTASKOWNERID rtoid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Status( 
            /* [in] */ 
            __in  DWORD dwReleaseStatus,
            /* [in] */ 
            __in  DWORD dwThreadTimeout) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellTaskSchedulerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellTaskScheduler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellTaskScheduler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellTaskScheduler * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddTask )( 
            IShellTaskScheduler * This,
            /* [in] */ 
            __in  IRunnableTask *prt,
            /* [in] */ 
            __in  REFTASKOWNERID rtoid,
            /* [in] */ 
            __in  DWORD_PTR lParam,
            /* [in] */ 
            __in  DWORD dwPriority);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveTasks )( 
            IShellTaskScheduler * This,
            /* [in] */ 
            __in  REFTASKOWNERID rtoid,
            /* [in] */ 
            __in  DWORD_PTR lParam,
            /* [in] */ 
            __in  BOOL bWaitIfRunning);
        
        UINT ( STDMETHODCALLTYPE *CountTasks )( 
            IShellTaskScheduler * This,
            /* [in] */ 
            __in  REFTASKOWNERID rtoid);
        
        HRESULT ( STDMETHODCALLTYPE *Status )( 
            IShellTaskScheduler * This,
            /* [in] */ 
            __in  DWORD dwReleaseStatus,
            /* [in] */ 
            __in  DWORD dwThreadTimeout);
        
        END_INTERFACE
    } IShellTaskSchedulerVtbl;

    interface IShellTaskScheduler
    {
        CONST_VTBL struct IShellTaskSchedulerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellTaskScheduler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellTaskScheduler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellTaskScheduler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellTaskScheduler_AddTask(This,prt,rtoid,lParam,dwPriority)	\
    ( (This)->lpVtbl -> AddTask(This,prt,rtoid,lParam,dwPriority) ) 

#define IShellTaskScheduler_RemoveTasks(This,rtoid,lParam,bWaitIfRunning)	\
    ( (This)->lpVtbl -> RemoveTasks(This,rtoid,lParam,bWaitIfRunning) ) 

#define IShellTaskScheduler_CountTasks(This,rtoid)	\
    ( (This)->lpVtbl -> CountTasks(This,rtoid) ) 

#define IShellTaskScheduler_Status(This,dwReleaseStatus,dwThreadTimeout)	\
    ( (This)->lpVtbl -> Status(This,dwReleaseStatus,dwThreadTimeout) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellTaskScheduler_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0006 */
/* [local] */ 

#define SID_ShellTaskScheduler IID_IShellTaskScheduler


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0006_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0006_v0_0_s_ifspec;

#ifndef __IPersistFolder2_INTERFACE_DEFINED__
#define __IPersistFolder2_INTERFACE_DEFINED__

/* interface IPersistFolder2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IPersistFolder2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1AC3D9F0-175C-11d1-95BE-00609797EA4F")
    IPersistFolder2 : public IPersistFolder
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCurFolder( 
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPersistFolder2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPersistFolder2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPersistFolder2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPersistFolder2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassID )( 
            IPersistFolder2 * This,
            /* [out] */ __RPC__out CLSID *pClassID);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IPersistFolder2 * This,
            /* [in] */ __RPC__in PCIDLIST_ABSOLUTE pidl);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurFolder )( 
            IPersistFolder2 * This,
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidl);
        
        END_INTERFACE
    } IPersistFolder2Vtbl;

    interface IPersistFolder2
    {
        CONST_VTBL struct IPersistFolder2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPersistFolder2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPersistFolder2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPersistFolder2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPersistFolder2_GetClassID(This,pClassID)	\
    ( (This)->lpVtbl -> GetClassID(This,pClassID) ) 


#define IPersistFolder2_Initialize(This,pidl)	\
    ( (This)->lpVtbl -> Initialize(This,pidl) ) 


#define IPersistFolder2_GetCurFolder(This,ppidl)	\
    ( (This)->lpVtbl -> GetCurFolder(This,ppidl) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPersistFolder2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0007 */
/* [local] */ 

#endif
#if (_WIN32_IE >= 0x0500)
#define CSIDL_FLAG_PFTI_TRACKTARGET CSIDL_FLAG_DONT_VERIFY
#include <pshpack8.h>
typedef struct _PERSIST_FOLDER_TARGET_INFO
    {
    PIDLIST_ABSOLUTE pidlTargetFolder;
    WCHAR szTargetParsingName[ 260 ];
    WCHAR szNetworkProvider[ 260 ];
    DWORD dwAttributes;
    int csidl;
    } 	PERSIST_FOLDER_TARGET_INFO;

#include <poppack.h>


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0007_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0007_v0_0_s_ifspec;

#ifndef __IPersistFolder3_INTERFACE_DEFINED__
#define __IPersistFolder3_INTERFACE_DEFINED__

/* interface IPersistFolder3 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IPersistFolder3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CEF04FDF-FE72-11d2-87A5-00C04F6837CF")
    IPersistFolder3 : public IPersistFolder2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitializeEx( 
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbc,
            /* [in] */ __RPC__in PCIDLIST_ABSOLUTE pidlRoot,
            /* [unique][in] */ __RPC__in_opt const PERSIST_FOLDER_TARGET_INFO *ppfti) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFolderTargetInfo( 
            /* [out] */ __RPC__out PERSIST_FOLDER_TARGET_INFO *ppfti) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPersistFolder3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPersistFolder3 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPersistFolder3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPersistFolder3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassID )( 
            IPersistFolder3 * This,
            /* [out] */ __RPC__out CLSID *pClassID);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IPersistFolder3 * This,
            /* [in] */ __RPC__in PCIDLIST_ABSOLUTE pidl);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurFolder )( 
            IPersistFolder3 * This,
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidl);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeEx )( 
            IPersistFolder3 * This,
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbc,
            /* [in] */ __RPC__in PCIDLIST_ABSOLUTE pidlRoot,
            /* [unique][in] */ __RPC__in_opt const PERSIST_FOLDER_TARGET_INFO *ppfti);
        
        HRESULT ( STDMETHODCALLTYPE *GetFolderTargetInfo )( 
            IPersistFolder3 * This,
            /* [out] */ __RPC__out PERSIST_FOLDER_TARGET_INFO *ppfti);
        
        END_INTERFACE
    } IPersistFolder3Vtbl;

    interface IPersistFolder3
    {
        CONST_VTBL struct IPersistFolder3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPersistFolder3_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPersistFolder3_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPersistFolder3_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPersistFolder3_GetClassID(This,pClassID)	\
    ( (This)->lpVtbl -> GetClassID(This,pClassID) ) 


#define IPersistFolder3_Initialize(This,pidl)	\
    ( (This)->lpVtbl -> Initialize(This,pidl) ) 


#define IPersistFolder3_GetCurFolder(This,ppidl)	\
    ( (This)->lpVtbl -> GetCurFolder(This,ppidl) ) 


#define IPersistFolder3_InitializeEx(This,pbc,pidlRoot,ppfti)	\
    ( (This)->lpVtbl -> InitializeEx(This,pbc,pidlRoot,ppfti) ) 

#define IPersistFolder3_GetFolderTargetInfo(This,ppfti)	\
    ( (This)->lpVtbl -> GetFolderTargetInfo(This,ppfti) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPersistFolder3_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0008 */
/* [local] */ 

#endif
#if (NTDDI_VERSION >= NTDDI_WINXP) || (_WIN32_IE >= _WIN32_IE_IE70)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0008_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0008_v0_0_s_ifspec;

#ifndef __IPersistIDList_INTERFACE_DEFINED__
#define __IPersistIDList_INTERFACE_DEFINED__

/* interface IPersistIDList */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IPersistIDList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1079acfc-29bd-11d3-8e0d-00c04f6837d5")
    IPersistIDList : public IPersist
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetIDList( 
            /* [in] */ __RPC__in PCIDLIST_ABSOLUTE pidl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIDList( 
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPersistIDListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPersistIDList * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPersistIDList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPersistIDList * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassID )( 
            IPersistIDList * This,
            /* [out] */ __RPC__out CLSID *pClassID);
        
        HRESULT ( STDMETHODCALLTYPE *SetIDList )( 
            IPersistIDList * This,
            /* [in] */ __RPC__in PCIDLIST_ABSOLUTE pidl);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDList )( 
            IPersistIDList * This,
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidl);
        
        END_INTERFACE
    } IPersistIDListVtbl;

    interface IPersistIDList
    {
        CONST_VTBL struct IPersistIDListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPersistIDList_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPersistIDList_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPersistIDList_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPersistIDList_GetClassID(This,pClassID)	\
    ( (This)->lpVtbl -> GetClassID(This,pClassID) ) 


#define IPersistIDList_SetIDList(This,pidl)	\
    ( (This)->lpVtbl -> SetIDList(This,pidl) ) 

#define IPersistIDList_GetIDList(This,ppidl)	\
    ( (This)->lpVtbl -> GetIDList(This,ppidl) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPersistIDList_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0009 */
/* [local] */ 

#endif  // NTDDI_WINXP|| (_WIN32_IE >= _WIN32_IE_IE70)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0009_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0009_v0_0_s_ifspec;

#ifndef __IEnumIDList_INTERFACE_DEFINED__
#define __IEnumIDList_INTERFACE_DEFINED__

/* interface IEnumIDList */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IEnumIDList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000214F2-0000-0000-C000-000000000046")
    IEnumIDList : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ 
            __in  ULONG celt,
            /* [length_is][size_is][out] */ 
            __out_ecount_part(celt, *pceltFetched)  PITEMID_CHILD *rgelt,
            /* [out] */ 
            __out_opt  ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumIDList **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumIDListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumIDList * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumIDList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumIDList * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumIDList * This,
            /* [in] */ 
            __in  ULONG celt,
            /* [length_is][size_is][out] */ 
            __out_ecount_part(celt, *pceltFetched)  PITEMID_CHILD *rgelt,
            /* [out] */ 
            __out_opt  ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumIDList * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumIDList * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumIDList * This,
            /* [out] */ __RPC__deref_out_opt IEnumIDList **ppenum);
        
        END_INTERFACE
    } IEnumIDListVtbl;

    interface IEnumIDList
    {
        CONST_VTBL struct IEnumIDListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumIDList_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumIDList_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumIDList_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumIDList_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumIDList_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumIDList_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumIDList_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumIDList_RemoteNext_Proxy( 
    IEnumIDList * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) PITEMID_CHILD *rgelt,
    /* [out] */ __RPC__out ULONG *pceltFetched);


void __RPC_STUB IEnumIDList_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumIDList_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0010 */
/* [local] */ 

typedef IEnumIDList *LPENUMIDLIST;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0010_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0010_v0_0_s_ifspec;

#ifndef __IEnumFullIDList_INTERFACE_DEFINED__
#define __IEnumFullIDList_INTERFACE_DEFINED__

/* interface IEnumFullIDList */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IEnumFullIDList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d0191542-7954-4908-bc06-b2360bbe45ba")
    IEnumFullIDList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) PIDLIST_ABSOLUTE *rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumFullIDList **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumFullIDListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumFullIDList * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumFullIDList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumFullIDList * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumFullIDList * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) PIDLIST_ABSOLUTE *rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumFullIDList * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumFullIDList * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumFullIDList * This,
            /* [out] */ __RPC__deref_out_opt IEnumFullIDList **ppenum);
        
        END_INTERFACE
    } IEnumFullIDListVtbl;

    interface IEnumFullIDList
    {
        CONST_VTBL struct IEnumFullIDListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumFullIDList_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumFullIDList_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumFullIDList_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumFullIDList_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumFullIDList_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumFullIDList_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumFullIDList_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumFullIDList_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0011 */
/* [local] */ 

typedef 
enum tagSHGDN
    {	SHGDN_NORMAL	= 0,
	SHGDN_INFOLDER	= 0x1,
	SHGDN_FOREDITING	= 0x1000,
	SHGDN_FORADDRESSBAR	= 0x4000,
	SHGDN_FORPARSING	= 0x8000
    } 	SHGNO;

typedef DWORD SHGDNF;

typedef 
enum tagSHCONTF
    {	SHCONTF_FOLDERS	= 0x20,
	SHCONTF_NONFOLDERS	= 0x40,
	SHCONTF_INCLUDEHIDDEN	= 0x80,
	SHCONTF_INIT_ON_FIRST_NEXT	= 0x100,
	SHCONTF_NETPRINTERSRCH	= 0x200,
	SHCONTF_SHAREABLE	= 0x400,
	SHCONTF_STORAGE	= 0x800,
	SHCONTF_FASTITEMS	= 0x2000,
	SHCONTF_FLATLIST	= 0x4000,
	SHCONTF_ENABLE_ASYNC	= 0x8000
    } 	SHCONT;

typedef DWORD SHCONTF;

#define SHCIDS_ALLFIELDS        0x80000000L
#define SHCIDS_CANONICALONLY    0x10000000L
#define SHCIDS_BITMASK          0xFFFF0000L
#define SHCIDS_COLUMNMASK       0x0000FFFFL
#define SFGAO_CANCOPY           DROPEFFECT_COPY // Objects can be copied    (0x1)
#define SFGAO_CANMOVE           DROPEFFECT_MOVE // Objects can be moved     (0x2)
#define SFGAO_CANLINK           DROPEFFECT_LINK // Objects can be linked    (0x4)
#define SFGAO_STORAGE           0x00000008L     // supports BindToObject(IID_IStorage)
#define SFGAO_CANRENAME         0x00000010L     // Objects can be renamed
#define SFGAO_CANDELETE         0x00000020L     // Objects can be deleted
#define SFGAO_HASPROPSHEET      0x00000040L     // Objects have property sheets
#define SFGAO_DROPTARGET        0x00000100L     // Objects are drop target
#define SFGAO_CAPABILITYMASK    0x00000177L
#define SFGAO_ENCRYPTED         0x00002000L     // Object is encrypted (use alt color)
#define SFGAO_ISSLOW            0x00004000L     // 'Slow' object
#define SFGAO_GHOSTED           0x00008000L     // Ghosted icon
#define SFGAO_LINK              0x00010000L     // Shortcut (link)
#define SFGAO_SHARE             0x00020000L     // Shared
#define SFGAO_READONLY          0x00040000L     // Read-only
#define SFGAO_HIDDEN            0x00080000L     // Hidden object
#define SFGAO_DISPLAYATTRMASK   0x000FC000L
#define SFGAO_FILESYSANCESTOR   0x10000000L     // May contain children with SFGAO_FILESYSTEM
#define SFGAO_FOLDER            0x20000000L     // Support BindToObject(IID_IShellFolder)
#define SFGAO_FILESYSTEM        0x40000000L     // Is a win32 file system object (file/folder/root)
#define SFGAO_HASSUBFOLDER      0x80000000L     // May contain children with SFGAO_FOLDER (may be slow)
#define SFGAO_CONTENTSMASK      0x80000000L
#define SFGAO_VALIDATE          0x01000000L     // Invalidate cached information (may be slow)
#define SFGAO_REMOVABLE         0x02000000L     // Is this removeable media?
#define SFGAO_COMPRESSED        0x04000000L     // Object is compressed (use alt color)
#define SFGAO_BROWSABLE         0x08000000L     // Supports IShellFolder, but only implements CreateViewObject() (non-folder view)
#define SFGAO_NONENUMERATED     0x00100000L     // Is a non-enumerated object (should be hidden)
#define SFGAO_NEWCONTENT        0x00200000L     // Should show bold in explorer tree
#define SFGAO_CANMONIKER        0x00400000L     // Obsolete
#define SFGAO_HASSTORAGE        0x00400000L     // Obsolete
#define SFGAO_STREAM            0x00400000L     // Supports BindToObject(IID_IStream)
#define SFGAO_STORAGEANCESTOR   0x00800000L     // May contain children with SFGAO_STORAGE or SFGAO_STREAM
#define SFGAO_STORAGECAPMASK    0x70C50008L     // For determining storage capabilities, ie for open/save semantics
#define SFGAO_PKEYSFGAOMASK     0x81044010L     // Attributes that are masked out for PKEY_SFGAOFlags because they are considered to cause slow calculations or lack context (SFGAO_VALIDATE | SFGAO_ISSLOW | SFGAO_HASSUBFOLDER and others)
typedef ULONG SFGAOF;

#define STR_BIND_FORCE_FOLDER_SHORTCUT_RESOLVE   L"Force Folder Shortcut Resolve"
#define STR_AVOID_DRIVE_RESTRICTION_POLICY   L"Avoid Drive Restriction Policy"
#define STR_AVOID_DRIVE_RESTRICTION_POLICY   L"Avoid Drive Restriction Policy"
#define STR_SKIP_BINDING_CLSID      L"Skip Binding CLSID"
#define STR_PARSE_PREFER_FOLDER_BROWSING     L"Parse Prefer Folder Browsing"
#define STR_DONT_PARSE_RELATIVE              L"Don't Parse Relative"
#define STR_PARSE_TRANSLATE_ALIASES          L"Parse Translate Aliases"
#define STR_PARSE_SKIP_NET_CACHE             L"Skip Net Resource Cache"
#define STR_PARSE_SHELL_PROTOCOL_TO_FILE_OBJECTS     L"Parse Shell Protocol To File Objects"
#if (_WIN32_IE >= 0x0700)
#define STR_TRACK_CLSID                      L"Track the CLSID"
#define STR_INTERNAL_NAVIGATE                L"Internal Navigation"
#define STR_PARSE_PROPERTYSTORE             L"DelegateNamedProperties"
#define STR_NO_VALIDATE_FILENAME_CHARS      L"NoValidateFilenameChars"
#define STR_IFILTER_LOAD_DEFINED_FILTER   L"Only bind registered persistent handlers"
#define STR_IFILTER_FORCE_TEXT_FILTER_FALLBACK   L"Always bind persistent handlers"
#define STR_BIND_DELEGATE_CREATE_OBJECT L"Delegate Object Creation"
#define STR_PARSE_ALLOW_INTERNET_SHELL_FOLDERS   L"Allow binding to Internet shell folder handlers and negate STR_PARSE_PREFER_WEB_BROWSING"
#define STR_PARSE_PREFER_WEB_BROWSING   L"Do not bind to Internet shell folder handlers"
#define STR_PARSE_SHOW_NET_DIAGNOSTICS_UI  L"Show network diagnostics UI"
#define STR_PARSE_DONT_REQUIRE_VALIDATED_URLS  L"Do not require validated URLs"
#endif // _WIN32_IE >= 0x0700



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0011_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0011_v0_0_s_ifspec;

#ifndef __IShellFolder_INTERFACE_DEFINED__
#define __IShellFolder_INTERFACE_DEFINED__

/* interface IShellFolder */
/* [unique][object][uuid] */ 






EXTERN_C const IID IID_IShellFolder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000214E6-0000-0000-C000-000000000046")
    IShellFolder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ParseDisplayName( 
            /* [unique][in] */ __RPC__in_opt HWND hwnd,
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbc,
            /* [string][in] */ __RPC__in LPWSTR pszDisplayName,
            /* [unique][out][in] */ 
            __reserved  ULONG *pchEaten,
            /* [out] */ __RPC__deref_out_opt PIDLIST_RELATIVE *ppidl,
            /* [unique][out][in] */ __RPC__inout_opt ULONG *pdwAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumObjects( 
            /* [unique][in] */ __RPC__in_opt HWND hwnd,
            /* [in] */ SHCONTF grfFlags,
            /* [out] */ __RPC__deref_out_opt IEnumIDList **ppenumIDList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BindToObject( 
            /* [in] */ __RPC__in PCUIDLIST_RELATIVE pidl,
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbc,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BindToStorage( 
            /* [in] */ __RPC__in PCUIDLIST_RELATIVE pidl,
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbc,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompareIDs( 
            /* [in] */ LPARAM lParam,
            /* [in] */ __RPC__in PCUIDLIST_RELATIVE pidl1,
            /* [in] */ __RPC__in PCUIDLIST_RELATIVE pidl2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateViewObject( 
            /* [unique][in] */ __RPC__in_opt HWND hwndOwner,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributesOf( 
            /* [in] */ UINT cidl,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(cidl) PCUITEMID_CHILD_ARRAY apidl,
            /* [out][in] */ __RPC__inout SFGAOF *rgfInOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUIObjectOf( 
            /* [unique][in] */ __RPC__in_opt HWND hwndOwner,
            /* [in] */ UINT cidl,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(cidl) PCUITEMID_CHILD_ARRAY apidl,
            /* [in] */ __RPC__in REFIID riid,
            /* [unique][out][in] */ 
            __reserved  UINT *rgfReserved,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayNameOf( 
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl,
            /* [in] */ SHGDNF uFlags,
            /* [out] */ __RPC__out STRRET *pName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNameOf( 
            /* [unique][in] */ __RPC__in_opt HWND hwnd,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl,
            /* [string][in] */ __RPC__in LPCWSTR pszName,
            /* [in] */ SHGDNF uFlags,
            /* [out] */ __RPC__deref_out_opt PITEMID_CHILD *ppidlOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellFolderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellFolder * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellFolder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellFolder * This);
        
        HRESULT ( STDMETHODCALLTYPE *ParseDisplayName )( 
            IShellFolder * This,
            /* [unique][in] */ __RPC__in_opt HWND hwnd,
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbc,
            /* [string][in] */ __RPC__in LPWSTR pszDisplayName,
            /* [unique][out][in] */ 
            __reserved  ULONG *pchEaten,
            /* [out] */ __RPC__deref_out_opt PIDLIST_RELATIVE *ppidl,
            /* [unique][out][in] */ __RPC__inout_opt ULONG *pdwAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *EnumObjects )( 
            IShellFolder * This,
            /* [unique][in] */ __RPC__in_opt HWND hwnd,
            /* [in] */ SHCONTF grfFlags,
            /* [out] */ __RPC__deref_out_opt IEnumIDList **ppenumIDList);
        
        HRESULT ( STDMETHODCALLTYPE *BindToObject )( 
            IShellFolder * This,
            /* [in] */ __RPC__in PCUIDLIST_RELATIVE pidl,
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbc,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *BindToStorage )( 
            IShellFolder * This,
            /* [in] */ __RPC__in PCUIDLIST_RELATIVE pidl,
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbc,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *CompareIDs )( 
            IShellFolder * This,
            /* [in] */ LPARAM lParam,
            /* [in] */ __RPC__in PCUIDLIST_RELATIVE pidl1,
            /* [in] */ __RPC__in PCUIDLIST_RELATIVE pidl2);
        
        HRESULT ( STDMETHODCALLTYPE *CreateViewObject )( 
            IShellFolder * This,
            /* [unique][in] */ __RPC__in_opt HWND hwndOwner,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributesOf )( 
            IShellFolder * This,
            /* [in] */ UINT cidl,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(cidl) PCUITEMID_CHILD_ARRAY apidl,
            /* [out][in] */ __RPC__inout SFGAOF *rgfInOut);
        
        HRESULT ( STDMETHODCALLTYPE *GetUIObjectOf )( 
            IShellFolder * This,
            /* [unique][in] */ __RPC__in_opt HWND hwndOwner,
            /* [in] */ UINT cidl,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(cidl) PCUITEMID_CHILD_ARRAY apidl,
            /* [in] */ __RPC__in REFIID riid,
            /* [unique][out][in] */ 
            __reserved  UINT *rgfReserved,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayNameOf )( 
            IShellFolder * This,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl,
            /* [in] */ SHGDNF uFlags,
            /* [out] */ __RPC__out STRRET *pName);
        
        HRESULT ( STDMETHODCALLTYPE *SetNameOf )( 
            IShellFolder * This,
            /* [unique][in] */ __RPC__in_opt HWND hwnd,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl,
            /* [string][in] */ __RPC__in LPCWSTR pszName,
            /* [in] */ SHGDNF uFlags,
            /* [out] */ __RPC__deref_out_opt PITEMID_CHILD *ppidlOut);
        
        END_INTERFACE
    } IShellFolderVtbl;

    interface IShellFolder
    {
        CONST_VTBL struct IShellFolderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellFolder_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellFolder_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellFolder_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellFolder_ParseDisplayName(This,hwnd,pbc,pszDisplayName,pchEaten,ppidl,pdwAttributes)	\
    ( (This)->lpVtbl -> ParseDisplayName(This,hwnd,pbc,pszDisplayName,pchEaten,ppidl,pdwAttributes) ) 

#define IShellFolder_EnumObjects(This,hwnd,grfFlags,ppenumIDList)	\
    ( (This)->lpVtbl -> EnumObjects(This,hwnd,grfFlags,ppenumIDList) ) 

#define IShellFolder_BindToObject(This,pidl,pbc,riid,ppv)	\
    ( (This)->lpVtbl -> BindToObject(This,pidl,pbc,riid,ppv) ) 

#define IShellFolder_BindToStorage(This,pidl,pbc,riid,ppv)	\
    ( (This)->lpVtbl -> BindToStorage(This,pidl,pbc,riid,ppv) ) 

#define IShellFolder_CompareIDs(This,lParam,pidl1,pidl2)	\
    ( (This)->lpVtbl -> CompareIDs(This,lParam,pidl1,pidl2) ) 

#define IShellFolder_CreateViewObject(This,hwndOwner,riid,ppv)	\
    ( (This)->lpVtbl -> CreateViewObject(This,hwndOwner,riid,ppv) ) 

#define IShellFolder_GetAttributesOf(This,cidl,apidl,rgfInOut)	\
    ( (This)->lpVtbl -> GetAttributesOf(This,cidl,apidl,rgfInOut) ) 

#define IShellFolder_GetUIObjectOf(This,hwndOwner,cidl,apidl,riid,rgfReserved,ppv)	\
    ( (This)->lpVtbl -> GetUIObjectOf(This,hwndOwner,cidl,apidl,riid,rgfReserved,ppv) ) 

#define IShellFolder_GetDisplayNameOf(This,pidl,uFlags,pName)	\
    ( (This)->lpVtbl -> GetDisplayNameOf(This,pidl,uFlags,pName) ) 

#define IShellFolder_SetNameOf(This,hwnd,pidl,pszName,uFlags,ppidlOut)	\
    ( (This)->lpVtbl -> SetNameOf(This,hwnd,pidl,pszName,uFlags,ppidlOut) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellFolder_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0012 */
/* [local] */ 

typedef IShellFolder *LPSHELLFOLDER;

typedef struct tagEXTRASEARCH
    {
    GUID guidSearch;
    WCHAR wszFriendlyName[ 80 ];
    WCHAR wszUrl[ 2084 ];
    } 	EXTRASEARCH;

typedef struct tagEXTRASEARCH *LPEXTRASEARCH;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0012_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0012_v0_0_s_ifspec;

#ifndef __IEnumExtraSearch_INTERFACE_DEFINED__
#define __IEnumExtraSearch_INTERFACE_DEFINED__

/* interface IEnumExtraSearch */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IEnumExtraSearch;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0E700BE1-9DB6-11d1-A1CE-00C04FD75D13")
    IEnumExtraSearch : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) EXTRASEARCH *rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumExtraSearch **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumExtraSearchVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumExtraSearch * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumExtraSearch * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumExtraSearch * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumExtraSearch * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) EXTRASEARCH *rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumExtraSearch * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumExtraSearch * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumExtraSearch * This,
            /* [out] */ __RPC__deref_out_opt IEnumExtraSearch **ppenum);
        
        END_INTERFACE
    } IEnumExtraSearchVtbl;

    interface IEnumExtraSearch
    {
        CONST_VTBL struct IEnumExtraSearchVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumExtraSearch_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumExtraSearch_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumExtraSearch_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumExtraSearch_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumExtraSearch_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumExtraSearch_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumExtraSearch_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumExtraSearch_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0013 */
/* [local] */ 

typedef IEnumExtraSearch *LPENUMEXTRASEARCH;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0013_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0013_v0_0_s_ifspec;

#ifndef __IShellFolder2_INTERFACE_DEFINED__
#define __IShellFolder2_INTERFACE_DEFINED__

/* interface IShellFolder2 */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IShellFolder2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("93F2F68C-1D1B-11d3-A30E-00C04F79ABD1")
    IShellFolder2 : public IShellFolder
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDefaultSearchGUID( 
            /* [out] */ __RPC__out GUID *pguid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumSearches( 
            /* [out] */ __RPC__deref_out_opt IEnumExtraSearch **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultColumn( 
            /* [in] */ DWORD dwRes,
            /* [out] */ __RPC__out ULONG *pSort,
            /* [out] */ __RPC__out ULONG *pDisplay) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultColumnState( 
            /* [in] */ UINT iColumn,
            /* [out] */ __RPC__out SHCOLSTATEF *pcsFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDetailsEx( 
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl,
            /* [in] */ __RPC__in const SHCOLUMNID *pscid,
            /* [out] */ __RPC__out VARIANT *pv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDetailsOf( 
            /* [unique][in] */ __RPC__in_opt PCUITEMID_CHILD pidl,
            /* [in] */ UINT iColumn,
            /* [out] */ __RPC__out SHELLDETAILS *psd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapColumnToSCID( 
            /* [in] */ UINT iColumn,
            /* [out] */ __RPC__out SHCOLUMNID *pscid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellFolder2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellFolder2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellFolder2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellFolder2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ParseDisplayName )( 
            IShellFolder2 * This,
            /* [unique][in] */ __RPC__in_opt HWND hwnd,
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbc,
            /* [string][in] */ __RPC__in LPWSTR pszDisplayName,
            /* [unique][out][in] */ 
            __reserved  ULONG *pchEaten,
            /* [out] */ __RPC__deref_out_opt PIDLIST_RELATIVE *ppidl,
            /* [unique][out][in] */ __RPC__inout_opt ULONG *pdwAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *EnumObjects )( 
            IShellFolder2 * This,
            /* [unique][in] */ __RPC__in_opt HWND hwnd,
            /* [in] */ SHCONTF grfFlags,
            /* [out] */ __RPC__deref_out_opt IEnumIDList **ppenumIDList);
        
        HRESULT ( STDMETHODCALLTYPE *BindToObject )( 
            IShellFolder2 * This,
            /* [in] */ __RPC__in PCUIDLIST_RELATIVE pidl,
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbc,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *BindToStorage )( 
            IShellFolder2 * This,
            /* [in] */ __RPC__in PCUIDLIST_RELATIVE pidl,
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbc,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *CompareIDs )( 
            IShellFolder2 * This,
            /* [in] */ LPARAM lParam,
            /* [in] */ __RPC__in PCUIDLIST_RELATIVE pidl1,
            /* [in] */ __RPC__in PCUIDLIST_RELATIVE pidl2);
        
        HRESULT ( STDMETHODCALLTYPE *CreateViewObject )( 
            IShellFolder2 * This,
            /* [unique][in] */ __RPC__in_opt HWND hwndOwner,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributesOf )( 
            IShellFolder2 * This,
            /* [in] */ UINT cidl,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(cidl) PCUITEMID_CHILD_ARRAY apidl,
            /* [out][in] */ __RPC__inout SFGAOF *rgfInOut);
        
        HRESULT ( STDMETHODCALLTYPE *GetUIObjectOf )( 
            IShellFolder2 * This,
            /* [unique][in] */ __RPC__in_opt HWND hwndOwner,
            /* [in] */ UINT cidl,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(cidl) PCUITEMID_CHILD_ARRAY apidl,
            /* [in] */ __RPC__in REFIID riid,
            /* [unique][out][in] */ 
            __reserved  UINT *rgfReserved,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayNameOf )( 
            IShellFolder2 * This,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl,
            /* [in] */ SHGDNF uFlags,
            /* [out] */ __RPC__out STRRET *pName);
        
        HRESULT ( STDMETHODCALLTYPE *SetNameOf )( 
            IShellFolder2 * This,
            /* [unique][in] */ __RPC__in_opt HWND hwnd,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl,
            /* [string][in] */ __RPC__in LPCWSTR pszName,
            /* [in] */ SHGDNF uFlags,
            /* [out] */ __RPC__deref_out_opt PITEMID_CHILD *ppidlOut);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultSearchGUID )( 
            IShellFolder2 * This,
            /* [out] */ __RPC__out GUID *pguid);
        
        HRESULT ( STDMETHODCALLTYPE *EnumSearches )( 
            IShellFolder2 * This,
            /* [out] */ __RPC__deref_out_opt IEnumExtraSearch **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultColumn )( 
            IShellFolder2 * This,
            /* [in] */ DWORD dwRes,
            /* [out] */ __RPC__out ULONG *pSort,
            /* [out] */ __RPC__out ULONG *pDisplay);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultColumnState )( 
            IShellFolder2 * This,
            /* [in] */ UINT iColumn,
            /* [out] */ __RPC__out SHCOLSTATEF *pcsFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetDetailsEx )( 
            IShellFolder2 * This,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl,
            /* [in] */ __RPC__in const SHCOLUMNID *pscid,
            /* [out] */ __RPC__out VARIANT *pv);
        
        HRESULT ( STDMETHODCALLTYPE *GetDetailsOf )( 
            IShellFolder2 * This,
            /* [unique][in] */ __RPC__in_opt PCUITEMID_CHILD pidl,
            /* [in] */ UINT iColumn,
            /* [out] */ __RPC__out SHELLDETAILS *psd);
        
        HRESULT ( STDMETHODCALLTYPE *MapColumnToSCID )( 
            IShellFolder2 * This,
            /* [in] */ UINT iColumn,
            /* [out] */ __RPC__out SHCOLUMNID *pscid);
        
        END_INTERFACE
    } IShellFolder2Vtbl;

    interface IShellFolder2
    {
        CONST_VTBL struct IShellFolder2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellFolder2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellFolder2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellFolder2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellFolder2_ParseDisplayName(This,hwnd,pbc,pszDisplayName,pchEaten,ppidl,pdwAttributes)	\
    ( (This)->lpVtbl -> ParseDisplayName(This,hwnd,pbc,pszDisplayName,pchEaten,ppidl,pdwAttributes) ) 

#define IShellFolder2_EnumObjects(This,hwnd,grfFlags,ppenumIDList)	\
    ( (This)->lpVtbl -> EnumObjects(This,hwnd,grfFlags,ppenumIDList) ) 

#define IShellFolder2_BindToObject(This,pidl,pbc,riid,ppv)	\
    ( (This)->lpVtbl -> BindToObject(This,pidl,pbc,riid,ppv) ) 

#define IShellFolder2_BindToStorage(This,pidl,pbc,riid,ppv)	\
    ( (This)->lpVtbl -> BindToStorage(This,pidl,pbc,riid,ppv) ) 

#define IShellFolder2_CompareIDs(This,lParam,pidl1,pidl2)	\
    ( (This)->lpVtbl -> CompareIDs(This,lParam,pidl1,pidl2) ) 

#define IShellFolder2_CreateViewObject(This,hwndOwner,riid,ppv)	\
    ( (This)->lpVtbl -> CreateViewObject(This,hwndOwner,riid,ppv) ) 

#define IShellFolder2_GetAttributesOf(This,cidl,apidl,rgfInOut)	\
    ( (This)->lpVtbl -> GetAttributesOf(This,cidl,apidl,rgfInOut) ) 

#define IShellFolder2_GetUIObjectOf(This,hwndOwner,cidl,apidl,riid,rgfReserved,ppv)	\
    ( (This)->lpVtbl -> GetUIObjectOf(This,hwndOwner,cidl,apidl,riid,rgfReserved,ppv) ) 

#define IShellFolder2_GetDisplayNameOf(This,pidl,uFlags,pName)	\
    ( (This)->lpVtbl -> GetDisplayNameOf(This,pidl,uFlags,pName) ) 

#define IShellFolder2_SetNameOf(This,hwnd,pidl,pszName,uFlags,ppidlOut)	\
    ( (This)->lpVtbl -> SetNameOf(This,hwnd,pidl,pszName,uFlags,ppidlOut) ) 


#define IShellFolder2_GetDefaultSearchGUID(This,pguid)	\
    ( (This)->lpVtbl -> GetDefaultSearchGUID(This,pguid) ) 

#define IShellFolder2_EnumSearches(This,ppenum)	\
    ( (This)->lpVtbl -> EnumSearches(This,ppenum) ) 

#define IShellFolder2_GetDefaultColumn(This,dwRes,pSort,pDisplay)	\
    ( (This)->lpVtbl -> GetDefaultColumn(This,dwRes,pSort,pDisplay) ) 

#define IShellFolder2_GetDefaultColumnState(This,iColumn,pcsFlags)	\
    ( (This)->lpVtbl -> GetDefaultColumnState(This,iColumn,pcsFlags) ) 

#define IShellFolder2_GetDetailsEx(This,pidl,pscid,pv)	\
    ( (This)->lpVtbl -> GetDetailsEx(This,pidl,pscid,pv) ) 

#define IShellFolder2_GetDetailsOf(This,pidl,iColumn,psd)	\
    ( (This)->lpVtbl -> GetDetailsOf(This,pidl,iColumn,psd) ) 

#define IShellFolder2_MapColumnToSCID(This,iColumn,pscid)	\
    ( (This)->lpVtbl -> MapColumnToSCID(This,iColumn,pscid) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellFolder2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0014 */
/* [local] */ 

typedef char *LPVIEWSETTINGS;

typedef /* [v1_enum] */ 
enum tagFOLDERFLAGS
    {	FWF_AUTOARRANGE	= 0x1,
	FWF_ABBREVIATEDNAMES	= 0x2,
	FWF_SNAPTOGRID	= 0x4,
	FWF_OWNERDATA	= 0x8,
	FWF_BESTFITWINDOW	= 0x10,
	FWF_DESKTOP	= 0x20,
	FWF_SINGLESEL	= 0x40,
	FWF_NOSUBFOLDERS	= 0x80,
	FWF_TRANSPARENT	= 0x100,
	FWF_NOCLIENTEDGE	= 0x200,
	FWF_NOSCROLL	= 0x400,
	FWF_ALIGNLEFT	= 0x800,
	FWF_NOICONS	= 0x1000,
	FWF_SHOWSELALWAYS	= 0x2000,
	FWF_NOVISIBLE	= 0x4000,
	FWF_SINGLECLICKACTIVATE	= 0x8000,
	FWF_NOWEBVIEW	= 0x10000,
	FWF_HIDEFILENAMES	= 0x20000,
	FWF_CHECKSELECT	= 0x40000,
	FWF_NOENUMREFRESH	= 0x80000,
	FWF_NOGROUPING	= 0x100000,
	FWF_FULLROWSELECT	= 0x200000,
	FWF_NOFILTERS	= 0x400000,
	FWF_NOCOLUMNHEADER	= 0x800000,
	FWF_NOHEADERINALLVIEWS	= 0x1000000,
	FWF_EXTENDEDTILES	= 0x2000000,
	FWF_TRICHECKSELECT	= 0x4000000,
	FWF_AUTOCHECKSELECT	= 0x8000000,
	FWF_NOBROWSERVIEWSTATE	= 0x10000000,
	FWF_SUBSETGROUPS	= 0x20000000,
	FWF_USESEARCHFOLDER	= 0x40000000,
	FWF_ALLOWRTLREADING	= ( int  )0x80000000
    } 	FOLDERFLAGS;

typedef /* [v1_enum] */ 
enum tagFOLDERVIEWMODE
    {	FVM_AUTO	= -1,
	FVM_FIRST	= 1,
	FVM_ICON	= 1,
	FVM_SMALLICON	= 2,
	FVM_LIST	= 3,
	FVM_DETAILS	= 4,
	FVM_THUMBNAIL	= 5,
	FVM_TILE	= 6,
	FVM_THUMBSTRIP	= 7,
	FVM_LAST	= 7
    } 	FOLDERVIEWMODE;

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef /* [v1_enum] */ 
enum tagFOLDERLOGICALVIEWMODE
    {	FLVM_UNSPECIFIED	= -1,
	FLVM_FIRST	= 1,
	FLVM_DETAILS	= 1,
	FLVM_TILES	= 2,
	FLVM_ICONS	= 3,
	FLVM_LAST	= 3
    } 	FOLDERLOGICALVIEWMODE;

#endif  // NTDDI_VISTA
typedef struct tagFOLDERSETTINGS
    {
    UINT ViewMode;
    UINT fFlags;
    } 	FOLDERSETTINGS;

typedef FOLDERSETTINGS *LPFOLDERSETTINGS;

typedef const FOLDERSETTINGS *LPCFOLDERSETTINGS;

typedef FOLDERSETTINGS *PFOLDERSETTINGS;

#define SVSI_DESELECT       0x00000000
#define SVSI_SELECT         0x00000001
#define SVSI_EDIT           0x00000003  // includes select
#define SVSI_DESELECTOTHERS 0x00000004
#define SVSI_ENSUREVISIBLE  0x00000008
#define SVSI_FOCUSED        0x00000010
#define SVSI_TRANSLATEPT    0x00000020
#define SVSI_SELECTIONMARK  0x00000040
#define SVSI_POSITIONITEM   0x00000080
#define SVSI_CHECK          0x00000100
#define SVSI_CHECK2         0x00000200
#define SVSI_KEYBOARDSELECT 0x00000401  // includes select
#define SVSI_NOTAKEFOCUS    0x40000000
#define SVSI_NOSTATECHANGE  0x80000000
typedef UINT SVSIF;

/* [v1_enum] */ 
enum tagSVGIO
    {	SVGIO_BACKGROUND	= 0,
	SVGIO_SELECTION	= 0x1,
	SVGIO_ALLVIEW	= 0x2,
	SVGIO_CHECKED	= 0x3,
	SVGIO_TYPE_MASK	= 0xf,
	SVGIO_FLAG_VIEWORDER	= ( int  )0x80000000
    } ;
typedef int SVGIO;

typedef /* [v1_enum] */ 
enum tagSVUIA_STATUS
    {	SVUIA_DEACTIVATE	= 0,
	SVUIA_ACTIVATE_NOFOCUS	= 1,
	SVUIA_ACTIVATE_FOCUS	= 2,
	SVUIA_INPLACEACTIVATE	= 3
    } 	SVUIA_STATUS;

#ifdef _FIX_ENABLEMODELESS_CONFLICT
#define    EnableModeless EnableModelessSV
#endif
#ifdef _NEVER_
typedef LPARAM LPFNSVADDPROPSHEETPAGE;

#else //!_NEVER_
#include <prsht.h>
typedef LPFNADDPROPSHEETPAGE LPFNSVADDPROPSHEETPAGE;
#endif //_NEVER_



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0014_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0014_v0_0_s_ifspec;

#ifndef __IShellView_INTERFACE_DEFINED__
#define __IShellView_INTERFACE_DEFINED__

/* interface IShellView */
/* [unique][object][uuid] */ 

typedef IShellView *LPSHELLVIEW;


EXTERN_C const IID IID_IShellView;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000214E3-0000-0000-C000-000000000046")
    IShellView : public IOleWindow
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE TranslateAccelerator( 
            /* [in] */ __RPC__in MSG *pmsg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableModeless( 
            /* [in] */ BOOL fEnable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UIActivate( 
            /* [in] */ UINT uState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateViewWindow( 
            /* [unique][in] */ __RPC__in_opt IShellView *psvPrevious,
            /* [in] */ __RPC__in LPCFOLDERSETTINGS pfs,
            /* [in] */ __RPC__in_opt IShellBrowser *psb,
            /* [in] */ __RPC__in RECT *prcView,
            /* [out] */ __RPC__deref_out_opt HWND *phWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyViewWindow( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentInfo( 
            /* [out] */ __RPC__out LPFOLDERSETTINGS pfs) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE AddPropertySheetPages( 
            /* [in] */ 
            __in  DWORD dwReserved,
            /* [in] */ 
            __in  LPFNSVADDPROPSHEETPAGE pfn,
            /* [in] */ 
            __in  LPARAM lparam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveViewState( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectItem( 
            /* [unique][in] */ __RPC__in_opt PCUITEMID_CHILD pidlItem,
            /* [in] */ SVSIF uFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItemObject( 
            /* [in] */ UINT uItem,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellViewVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellView * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellView * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellView * This);
        
        /* [input_sync] */ HRESULT ( STDMETHODCALLTYPE *GetWindow )( 
            IShellView * This,
            /* [out] */ __RPC__deref_out_opt HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *ContextSensitiveHelp )( 
            IShellView * This,
            /* [in] */ BOOL fEnterMode);
        
        HRESULT ( STDMETHODCALLTYPE *TranslateAccelerator )( 
            IShellView * This,
            /* [in] */ __RPC__in MSG *pmsg);
        
        HRESULT ( STDMETHODCALLTYPE *EnableModeless )( 
            IShellView * This,
            /* [in] */ BOOL fEnable);
        
        HRESULT ( STDMETHODCALLTYPE *UIActivate )( 
            IShellView * This,
            /* [in] */ UINT uState);
        
        HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IShellView * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateViewWindow )( 
            IShellView * This,
            /* [unique][in] */ __RPC__in_opt IShellView *psvPrevious,
            /* [in] */ __RPC__in LPCFOLDERSETTINGS pfs,
            /* [in] */ __RPC__in_opt IShellBrowser *psb,
            /* [in] */ __RPC__in RECT *prcView,
            /* [out] */ __RPC__deref_out_opt HWND *phWnd);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyViewWindow )( 
            IShellView * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentInfo )( 
            IShellView * This,
            /* [out] */ __RPC__out LPFOLDERSETTINGS pfs);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *AddPropertySheetPages )( 
            IShellView * This,
            /* [in] */ 
            __in  DWORD dwReserved,
            /* [in] */ 
            __in  LPFNSVADDPROPSHEETPAGE pfn,
            /* [in] */ 
            __in  LPARAM lparam);
        
        HRESULT ( STDMETHODCALLTYPE *SaveViewState )( 
            IShellView * This);
        
        HRESULT ( STDMETHODCALLTYPE *SelectItem )( 
            IShellView * This,
            /* [unique][in] */ __RPC__in_opt PCUITEMID_CHILD pidlItem,
            /* [in] */ SVSIF uFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemObject )( 
            IShellView * This,
            /* [in] */ UINT uItem,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        END_INTERFACE
    } IShellViewVtbl;

    interface IShellView
    {
        CONST_VTBL struct IShellViewVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellView_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellView_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellView_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellView_GetWindow(This,phwnd)	\
    ( (This)->lpVtbl -> GetWindow(This,phwnd) ) 

#define IShellView_ContextSensitiveHelp(This,fEnterMode)	\
    ( (This)->lpVtbl -> ContextSensitiveHelp(This,fEnterMode) ) 


#define IShellView_TranslateAccelerator(This,pmsg)	\
    ( (This)->lpVtbl -> TranslateAccelerator(This,pmsg) ) 

#define IShellView_EnableModeless(This,fEnable)	\
    ( (This)->lpVtbl -> EnableModeless(This,fEnable) ) 

#define IShellView_UIActivate(This,uState)	\
    ( (This)->lpVtbl -> UIActivate(This,uState) ) 

#define IShellView_Refresh(This)	\
    ( (This)->lpVtbl -> Refresh(This) ) 

#define IShellView_CreateViewWindow(This,psvPrevious,pfs,psb,prcView,phWnd)	\
    ( (This)->lpVtbl -> CreateViewWindow(This,psvPrevious,pfs,psb,prcView,phWnd) ) 

#define IShellView_DestroyViewWindow(This)	\
    ( (This)->lpVtbl -> DestroyViewWindow(This) ) 

#define IShellView_GetCurrentInfo(This,pfs)	\
    ( (This)->lpVtbl -> GetCurrentInfo(This,pfs) ) 

#define IShellView_AddPropertySheetPages(This,dwReserved,pfn,lparam)	\
    ( (This)->lpVtbl -> AddPropertySheetPages(This,dwReserved,pfn,lparam) ) 

#define IShellView_SaveViewState(This)	\
    ( (This)->lpVtbl -> SaveViewState(This) ) 

#define IShellView_SelectItem(This,pidlItem,uFlags)	\
    ( (This)->lpVtbl -> SelectItem(This,pidlItem,uFlags) ) 

#define IShellView_GetItemObject(This,uItem,riid,ppv)	\
    ( (This)->lpVtbl -> GetItemObject(This,uItem,riid,ppv) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellView_INTERFACE_DEFINED__ */


#ifndef __IShellView2_INTERFACE_DEFINED__
#define __IShellView2_INTERFACE_DEFINED__

/* interface IShellView2 */
/* [unique][object][uuid] */ 

typedef GUID SHELLVIEWID;

#define SV2GV_CURRENTVIEW ((UINT)-1)
#define SV2GV_DEFAULTVIEW ((UINT)-2)
#include <pshpack8.h>
typedef struct _SV2CVW2_PARAMS
    {
    DWORD cbSize;
    IShellView *psvPrev;
    LPCFOLDERSETTINGS pfs;
    IShellBrowser *psbOwner;
    RECT *prcView;
    const SHELLVIEWID *pvid;
    HWND hwndView;
    } 	SV2CVW2_PARAMS;

typedef struct _SV2CVW2_PARAMS *LPSV2CVW2_PARAMS;

#include <poppack.h>

EXTERN_C const IID IID_IShellView2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("88E39E80-3578-11CF-AE69-08002B2E1262")
    IShellView2 : public IShellView
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetView( 
            /* [out][in] */ __RPC__inout SHELLVIEWID *pvid,
            /* [in] */ ULONG uView) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateViewWindow2( 
            /* [in] */ __RPC__in LPSV2CVW2_PARAMS lpParams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HandleRename( 
            /* [unique][in] */ __RPC__in_opt PCUITEMID_CHILD pidlNew) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectAndPositionItem( 
            /* [in] */ __RPC__in PCUITEMID_CHILD pidlItem,
            /* [in] */ UINT uFlags,
            /* [unique][in] */ __RPC__in_opt POINT *ppt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellView2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellView2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellView2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellView2 * This);
        
        /* [input_sync] */ HRESULT ( STDMETHODCALLTYPE *GetWindow )( 
            IShellView2 * This,
            /* [out] */ __RPC__deref_out_opt HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *ContextSensitiveHelp )( 
            IShellView2 * This,
            /* [in] */ BOOL fEnterMode);
        
        HRESULT ( STDMETHODCALLTYPE *TranslateAccelerator )( 
            IShellView2 * This,
            /* [in] */ __RPC__in MSG *pmsg);
        
        HRESULT ( STDMETHODCALLTYPE *EnableModeless )( 
            IShellView2 * This,
            /* [in] */ BOOL fEnable);
        
        HRESULT ( STDMETHODCALLTYPE *UIActivate )( 
            IShellView2 * This,
            /* [in] */ UINT uState);
        
        HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IShellView2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateViewWindow )( 
            IShellView2 * This,
            /* [unique][in] */ __RPC__in_opt IShellView *psvPrevious,
            /* [in] */ __RPC__in LPCFOLDERSETTINGS pfs,
            /* [in] */ __RPC__in_opt IShellBrowser *psb,
            /* [in] */ __RPC__in RECT *prcView,
            /* [out] */ __RPC__deref_out_opt HWND *phWnd);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyViewWindow )( 
            IShellView2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentInfo )( 
            IShellView2 * This,
            /* [out] */ __RPC__out LPFOLDERSETTINGS pfs);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *AddPropertySheetPages )( 
            IShellView2 * This,
            /* [in] */ 
            __in  DWORD dwReserved,
            /* [in] */ 
            __in  LPFNSVADDPROPSHEETPAGE pfn,
            /* [in] */ 
            __in  LPARAM lparam);
        
        HRESULT ( STDMETHODCALLTYPE *SaveViewState )( 
            IShellView2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SelectItem )( 
            IShellView2 * This,
            /* [unique][in] */ __RPC__in_opt PCUITEMID_CHILD pidlItem,
            /* [in] */ SVSIF uFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemObject )( 
            IShellView2 * This,
            /* [in] */ UINT uItem,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetView )( 
            IShellView2 * This,
            /* [out][in] */ __RPC__inout SHELLVIEWID *pvid,
            /* [in] */ ULONG uView);
        
        HRESULT ( STDMETHODCALLTYPE *CreateViewWindow2 )( 
            IShellView2 * This,
            /* [in] */ __RPC__in LPSV2CVW2_PARAMS lpParams);
        
        HRESULT ( STDMETHODCALLTYPE *HandleRename )( 
            IShellView2 * This,
            /* [unique][in] */ __RPC__in_opt PCUITEMID_CHILD pidlNew);
        
        HRESULT ( STDMETHODCALLTYPE *SelectAndPositionItem )( 
            IShellView2 * This,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidlItem,
            /* [in] */ UINT uFlags,
            /* [unique][in] */ __RPC__in_opt POINT *ppt);
        
        END_INTERFACE
    } IShellView2Vtbl;

    interface IShellView2
    {
        CONST_VTBL struct IShellView2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellView2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellView2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellView2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellView2_GetWindow(This,phwnd)	\
    ( (This)->lpVtbl -> GetWindow(This,phwnd) ) 

#define IShellView2_ContextSensitiveHelp(This,fEnterMode)	\
    ( (This)->lpVtbl -> ContextSensitiveHelp(This,fEnterMode) ) 


#define IShellView2_TranslateAccelerator(This,pmsg)	\
    ( (This)->lpVtbl -> TranslateAccelerator(This,pmsg) ) 

#define IShellView2_EnableModeless(This,fEnable)	\
    ( (This)->lpVtbl -> EnableModeless(This,fEnable) ) 

#define IShellView2_UIActivate(This,uState)	\
    ( (This)->lpVtbl -> UIActivate(This,uState) ) 

#define IShellView2_Refresh(This)	\
    ( (This)->lpVtbl -> Refresh(This) ) 

#define IShellView2_CreateViewWindow(This,psvPrevious,pfs,psb,prcView,phWnd)	\
    ( (This)->lpVtbl -> CreateViewWindow(This,psvPrevious,pfs,psb,prcView,phWnd) ) 

#define IShellView2_DestroyViewWindow(This)	\
    ( (This)->lpVtbl -> DestroyViewWindow(This) ) 

#define IShellView2_GetCurrentInfo(This,pfs)	\
    ( (This)->lpVtbl -> GetCurrentInfo(This,pfs) ) 

#define IShellView2_AddPropertySheetPages(This,dwReserved,pfn,lparam)	\
    ( (This)->lpVtbl -> AddPropertySheetPages(This,dwReserved,pfn,lparam) ) 

#define IShellView2_SaveViewState(This)	\
    ( (This)->lpVtbl -> SaveViewState(This) ) 

#define IShellView2_SelectItem(This,pidlItem,uFlags)	\
    ( (This)->lpVtbl -> SelectItem(This,pidlItem,uFlags) ) 

#define IShellView2_GetItemObject(This,uItem,riid,ppv)	\
    ( (This)->lpVtbl -> GetItemObject(This,uItem,riid,ppv) ) 


#define IShellView2_GetView(This,pvid,uView)	\
    ( (This)->lpVtbl -> GetView(This,pvid,uView) ) 

#define IShellView2_CreateViewWindow2(This,lpParams)	\
    ( (This)->lpVtbl -> CreateViewWindow2(This,lpParams) ) 

#define IShellView2_HandleRename(This,pidlNew)	\
    ( (This)->lpVtbl -> HandleRename(This,pidlNew) ) 

#define IShellView2_SelectAndPositionItem(This,pidlItem,uFlags,ppt)	\
    ( (This)->lpVtbl -> SelectAndPositionItem(This,pidlItem,uFlags,ppt) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellView2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0016 */
/* [local] */ 

#if (NTDDI_VERSION >= NTDDI_VISTA)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0016_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0016_v0_0_s_ifspec;

#ifndef __IShellView3_INTERFACE_DEFINED__
#define __IShellView3_INTERFACE_DEFINED__

/* interface IShellView3 */
/* [unique][object][uuid] */ 

/* [v1_enum] */ 
enum tagSV3CVW3
    {	SV3CVW3_DEFAULT	= 0,
	SV3CVW3_NONINTERACTIVE	= 0x1,
	SV3CVW3_FORCEVIEWMODE	= 0x2,
	SV3CVW3_FORCEFOLDERFLAGS	= 0x4
    } ;
typedef DWORD SV3CVW3_FLAGS;


EXTERN_C const IID IID_IShellView3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ec39fa88-f8af-41c5-8421-38bed28f4673")
    IShellView3 : public IShellView2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateViewWindow3( 
            /* [in] */ __RPC__in_opt IShellBrowser *psbOwner,
            /* [unique][in] */ __RPC__in_opt IShellView *psvPrev,
            /* [in] */ SV3CVW3_FLAGS dwViewFlags,
            /* [in] */ FOLDERFLAGS dwMask,
            /* [in] */ FOLDERFLAGS dwFlags,
            /* [in] */ FOLDERVIEWMODE fvMode,
            /* [unique][in] */ __RPC__in_opt const SHELLVIEWID *pvid,
            /* [in] */ __RPC__in const RECT *prcView,
            /* [out] */ __RPC__deref_out_opt HWND *phwndView) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellView3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellView3 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellView3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellView3 * This);
        
        /* [input_sync] */ HRESULT ( STDMETHODCALLTYPE *GetWindow )( 
            IShellView3 * This,
            /* [out] */ __RPC__deref_out_opt HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *ContextSensitiveHelp )( 
            IShellView3 * This,
            /* [in] */ BOOL fEnterMode);
        
        HRESULT ( STDMETHODCALLTYPE *TranslateAccelerator )( 
            IShellView3 * This,
            /* [in] */ __RPC__in MSG *pmsg);
        
        HRESULT ( STDMETHODCALLTYPE *EnableModeless )( 
            IShellView3 * This,
            /* [in] */ BOOL fEnable);
        
        HRESULT ( STDMETHODCALLTYPE *UIActivate )( 
            IShellView3 * This,
            /* [in] */ UINT uState);
        
        HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IShellView3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateViewWindow )( 
            IShellView3 * This,
            /* [unique][in] */ __RPC__in_opt IShellView *psvPrevious,
            /* [in] */ __RPC__in LPCFOLDERSETTINGS pfs,
            /* [in] */ __RPC__in_opt IShellBrowser *psb,
            /* [in] */ __RPC__in RECT *prcView,
            /* [out] */ __RPC__deref_out_opt HWND *phWnd);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyViewWindow )( 
            IShellView3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentInfo )( 
            IShellView3 * This,
            /* [out] */ __RPC__out LPFOLDERSETTINGS pfs);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *AddPropertySheetPages )( 
            IShellView3 * This,
            /* [in] */ 
            __in  DWORD dwReserved,
            /* [in] */ 
            __in  LPFNSVADDPROPSHEETPAGE pfn,
            /* [in] */ 
            __in  LPARAM lparam);
        
        HRESULT ( STDMETHODCALLTYPE *SaveViewState )( 
            IShellView3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SelectItem )( 
            IShellView3 * This,
            /* [unique][in] */ __RPC__in_opt PCUITEMID_CHILD pidlItem,
            /* [in] */ SVSIF uFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemObject )( 
            IShellView3 * This,
            /* [in] */ UINT uItem,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetView )( 
            IShellView3 * This,
            /* [out][in] */ __RPC__inout SHELLVIEWID *pvid,
            /* [in] */ ULONG uView);
        
        HRESULT ( STDMETHODCALLTYPE *CreateViewWindow2 )( 
            IShellView3 * This,
            /* [in] */ __RPC__in LPSV2CVW2_PARAMS lpParams);
        
        HRESULT ( STDMETHODCALLTYPE *HandleRename )( 
            IShellView3 * This,
            /* [unique][in] */ __RPC__in_opt PCUITEMID_CHILD pidlNew);
        
        HRESULT ( STDMETHODCALLTYPE *SelectAndPositionItem )( 
            IShellView3 * This,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidlItem,
            /* [in] */ UINT uFlags,
            /* [unique][in] */ __RPC__in_opt POINT *ppt);
        
        HRESULT ( STDMETHODCALLTYPE *CreateViewWindow3 )( 
            IShellView3 * This,
            /* [in] */ __RPC__in_opt IShellBrowser *psbOwner,
            /* [unique][in] */ __RPC__in_opt IShellView *psvPrev,
            /* [in] */ SV3CVW3_FLAGS dwViewFlags,
            /* [in] */ FOLDERFLAGS dwMask,
            /* [in] */ FOLDERFLAGS dwFlags,
            /* [in] */ FOLDERVIEWMODE fvMode,
            /* [unique][in] */ __RPC__in_opt const SHELLVIEWID *pvid,
            /* [in] */ __RPC__in const RECT *prcView,
            /* [out] */ __RPC__deref_out_opt HWND *phwndView);
        
        END_INTERFACE
    } IShellView3Vtbl;

    interface IShellView3
    {
        CONST_VTBL struct IShellView3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellView3_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellView3_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellView3_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellView3_GetWindow(This,phwnd)	\
    ( (This)->lpVtbl -> GetWindow(This,phwnd) ) 

#define IShellView3_ContextSensitiveHelp(This,fEnterMode)	\
    ( (This)->lpVtbl -> ContextSensitiveHelp(This,fEnterMode) ) 


#define IShellView3_TranslateAccelerator(This,pmsg)	\
    ( (This)->lpVtbl -> TranslateAccelerator(This,pmsg) ) 

#define IShellView3_EnableModeless(This,fEnable)	\
    ( (This)->lpVtbl -> EnableModeless(This,fEnable) ) 

#define IShellView3_UIActivate(This,uState)	\
    ( (This)->lpVtbl -> UIActivate(This,uState) ) 

#define IShellView3_Refresh(This)	\
    ( (This)->lpVtbl -> Refresh(This) ) 

#define IShellView3_CreateViewWindow(This,psvPrevious,pfs,psb,prcView,phWnd)	\
    ( (This)->lpVtbl -> CreateViewWindow(This,psvPrevious,pfs,psb,prcView,phWnd) ) 

#define IShellView3_DestroyViewWindow(This)	\
    ( (This)->lpVtbl -> DestroyViewWindow(This) ) 

#define IShellView3_GetCurrentInfo(This,pfs)	\
    ( (This)->lpVtbl -> GetCurrentInfo(This,pfs) ) 

#define IShellView3_AddPropertySheetPages(This,dwReserved,pfn,lparam)	\
    ( (This)->lpVtbl -> AddPropertySheetPages(This,dwReserved,pfn,lparam) ) 

#define IShellView3_SaveViewState(This)	\
    ( (This)->lpVtbl -> SaveViewState(This) ) 

#define IShellView3_SelectItem(This,pidlItem,uFlags)	\
    ( (This)->lpVtbl -> SelectItem(This,pidlItem,uFlags) ) 

#define IShellView3_GetItemObject(This,uItem,riid,ppv)	\
    ( (This)->lpVtbl -> GetItemObject(This,uItem,riid,ppv) ) 


#define IShellView3_GetView(This,pvid,uView)	\
    ( (This)->lpVtbl -> GetView(This,pvid,uView) ) 

#define IShellView3_CreateViewWindow2(This,lpParams)	\
    ( (This)->lpVtbl -> CreateViewWindow2(This,lpParams) ) 

#define IShellView3_HandleRename(This,pidlNew)	\
    ( (This)->lpVtbl -> HandleRename(This,pidlNew) ) 

#define IShellView3_SelectAndPositionItem(This,pidlItem,uFlags,ppt)	\
    ( (This)->lpVtbl -> SelectAndPositionItem(This,pidlItem,uFlags,ppt) ) 


#define IShellView3_CreateViewWindow3(This,psbOwner,psvPrev,dwViewFlags,dwMask,dwFlags,fvMode,pvid,prcView,phwndView)	\
    ( (This)->lpVtbl -> CreateViewWindow3(This,psbOwner,psvPrev,dwViewFlags,dwMask,dwFlags,fvMode,pvid,prcView,phwndView) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellView3_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0017 */
/* [local] */ 

#endif  // NTDDI_VISTA
#ifdef _FIX_ENABLEMODELESS_CONFLICT
#undef    EnableModeless 
#endif


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0017_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0017_v0_0_s_ifspec;

#ifndef __IFolderView_INTERFACE_DEFINED__
#define __IFolderView_INTERFACE_DEFINED__

/* interface IFolderView */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IFolderView;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("cde725b0-ccc9-4519-917e-325d72fab4ce")
    IFolderView : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCurrentViewMode( 
            /* [out][in] */ __RPC__inout UINT *pViewMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCurrentViewMode( 
            /* [in] */ UINT ViewMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFolder( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ int iItemIndex,
            /* [out] */ __RPC__deref_out_opt PITEMID_CHILD *ppidl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ItemCount( 
            /* [in] */ UINT uFlags,
            /* [out] */ __RPC__out int *pcItems) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Items( 
            /* [in] */ UINT uFlags,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSelectionMarkedItem( 
            /* [out] */ __RPC__out int *piItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFocusedItem( 
            /* [out] */ __RPC__out int *piItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItemPosition( 
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl,
            /* [out] */ __RPC__out POINT *ppt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSpacing( 
            /* [unique][out][in] */ __RPC__inout_opt POINT *ppt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultSpacing( 
            /* [out] */ __RPC__out POINT *ppt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAutoArrange( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectItem( 
            /* [in] */ int iItem,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectAndPositionItems( 
            /* [in] */ UINT cidl,
            /* [size_is][in] */ __RPC__in_ecount_full(cidl) PCUITEMID_CHILD_ARRAY apidl,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(cidl) POINT *apt,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFolderViewVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFolderView * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFolderView * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFolderView * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentViewMode )( 
            IFolderView * This,
            /* [out][in] */ __RPC__inout UINT *pViewMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetCurrentViewMode )( 
            IFolderView * This,
            /* [in] */ UINT ViewMode);
        
        HRESULT ( STDMETHODCALLTYPE *GetFolder )( 
            IFolderView * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *Item )( 
            IFolderView * This,
            /* [in] */ int iItemIndex,
            /* [out] */ __RPC__deref_out_opt PITEMID_CHILD *ppidl);
        
        HRESULT ( STDMETHODCALLTYPE *ItemCount )( 
            IFolderView * This,
            /* [in] */ UINT uFlags,
            /* [out] */ __RPC__out int *pcItems);
        
        HRESULT ( STDMETHODCALLTYPE *Items )( 
            IFolderView * This,
            /* [in] */ UINT uFlags,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelectionMarkedItem )( 
            IFolderView * This,
            /* [out] */ __RPC__out int *piItem);
        
        HRESULT ( STDMETHODCALLTYPE *GetFocusedItem )( 
            IFolderView * This,
            /* [out] */ __RPC__out int *piItem);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemPosition )( 
            IFolderView * This,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl,
            /* [out] */ __RPC__out POINT *ppt);
        
        HRESULT ( STDMETHODCALLTYPE *GetSpacing )( 
            IFolderView * This,
            /* [unique][out][in] */ __RPC__inout_opt POINT *ppt);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultSpacing )( 
            IFolderView * This,
            /* [out] */ __RPC__out POINT *ppt);
        
        HRESULT ( STDMETHODCALLTYPE *GetAutoArrange )( 
            IFolderView * This);
        
        HRESULT ( STDMETHODCALLTYPE *SelectItem )( 
            IFolderView * This,
            /* [in] */ int iItem,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SelectAndPositionItems )( 
            IFolderView * This,
            /* [in] */ UINT cidl,
            /* [size_is][in] */ __RPC__in_ecount_full(cidl) PCUITEMID_CHILD_ARRAY apidl,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(cidl) POINT *apt,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IFolderViewVtbl;

    interface IFolderView
    {
        CONST_VTBL struct IFolderViewVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFolderView_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFolderView_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFolderView_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFolderView_GetCurrentViewMode(This,pViewMode)	\
    ( (This)->lpVtbl -> GetCurrentViewMode(This,pViewMode) ) 

#define IFolderView_SetCurrentViewMode(This,ViewMode)	\
    ( (This)->lpVtbl -> SetCurrentViewMode(This,ViewMode) ) 

#define IFolderView_GetFolder(This,riid,ppv)	\
    ( (This)->lpVtbl -> GetFolder(This,riid,ppv) ) 

#define IFolderView_Item(This,iItemIndex,ppidl)	\
    ( (This)->lpVtbl -> Item(This,iItemIndex,ppidl) ) 

#define IFolderView_ItemCount(This,uFlags,pcItems)	\
    ( (This)->lpVtbl -> ItemCount(This,uFlags,pcItems) ) 

#define IFolderView_Items(This,uFlags,riid,ppv)	\
    ( (This)->lpVtbl -> Items(This,uFlags,riid,ppv) ) 

#define IFolderView_GetSelectionMarkedItem(This,piItem)	\
    ( (This)->lpVtbl -> GetSelectionMarkedItem(This,piItem) ) 

#define IFolderView_GetFocusedItem(This,piItem)	\
    ( (This)->lpVtbl -> GetFocusedItem(This,piItem) ) 

#define IFolderView_GetItemPosition(This,pidl,ppt)	\
    ( (This)->lpVtbl -> GetItemPosition(This,pidl,ppt) ) 

#define IFolderView_GetSpacing(This,ppt)	\
    ( (This)->lpVtbl -> GetSpacing(This,ppt) ) 

#define IFolderView_GetDefaultSpacing(This,ppt)	\
    ( (This)->lpVtbl -> GetDefaultSpacing(This,ppt) ) 

#define IFolderView_GetAutoArrange(This)	\
    ( (This)->lpVtbl -> GetAutoArrange(This) ) 

#define IFolderView_SelectItem(This,iItem,dwFlags)	\
    ( (This)->lpVtbl -> SelectItem(This,iItem,dwFlags) ) 

#define IFolderView_SelectAndPositionItems(This,cidl,apidl,apt,dwFlags)	\
    ( (This)->lpVtbl -> SelectAndPositionItems(This,cidl,apidl,apt,dwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFolderView_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0018 */
/* [local] */ 

#define SID_SFolderView IID_IFolderView    // folder view, usually IFolderView
#if (NTDDI_VERSION >= NTDDI_VISTA) || (_WIN32_IE >= _WIN32_IE_IE70)
#ifndef NO_SHOBJIDL_SORTDIRECTION
/* [v1_enum] */ 
enum tagSORTDIRECTION
    {	SORT_DESCENDING	= -1,
	SORT_ASCENDING	= 1
    } ;
#endif  // NO_SHOBJIDL_SORTDIRECTION
typedef int SORTDIRECTION;

typedef struct tagSORTCOLUMN
    {
    PROPERTYKEY propkey;
    SORTDIRECTION direction;
    } 	SORTCOLUMN;

typedef /* [v1_enum] */ 
enum tagFVTEXTTYPE
    {	FVST_EMPTYTEXT	= 0
    } 	FVTEXTTYPE;




extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0018_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0018_v0_0_s_ifspec;

#ifndef __IFolderView2_INTERFACE_DEFINED__
#define __IFolderView2_INTERFACE_DEFINED__

/* interface IFolderView2 */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IFolderView2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1af3a467-214f-4298-908e-06b03e0b39f9")
    IFolderView2 : public IFolderView
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetGroupBy( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ BOOL fAscending) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGroupBy( 
            /* [out] */ __RPC__out PROPERTYKEY *pkey,
            /* [out] */ __RPC__out BOOL *pfAscending) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetViewProperty( 
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl,
            /* [in] */ __RPC__in REFPROPERTYKEY propkey,
            /* [in] */ __RPC__in REFPROPVARIANT propvar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetViewProperty( 
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl,
            /* [in] */ __RPC__in REFPROPERTYKEY propkey,
            /* [out] */ __RPC__out PROPVARIANT *ppropvar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTileViewProperties( 
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl,
            /* [string][in] */ __RPC__in LPCWSTR pszPropList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetExtendedTileViewProperties( 
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl,
            /* [string][in] */ __RPC__in LPCWSTR pszPropList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetText( 
            /* [in] */ FVTEXTTYPE iType,
            /* [in] */ __RPC__in LPCWSTR pwszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCurrentFolderFlags( 
            /* [in] */ DWORD dwMask,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentFolderFlags( 
            /* [out] */ __RPC__out DWORD *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSortColumnCount( 
            /* [out] */ __RPC__out int *pcColumns) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSortColumns( 
            /* [size_is][in] */ __RPC__in_ecount_full(cColumns) const SORTCOLUMN *rgSortColumns,
            /* [in] */ int cColumns) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSortColumns( 
            /* [size_is][out] */ __RPC__out_ecount_full(cColumns) SORTCOLUMN *rgSortColumns,
            /* [in] */ int cColumns) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItem( 
            /* [in] */ int iItem,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVisibleItem( 
            /* [in] */ int iStart,
            /* [in] */ BOOL fPrevious,
            /* [out] */ __RPC__out int *piItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSelectedItem( 
            /* [in] */ int iStart,
            /* [out] */ __RPC__out int *piItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSelection( 
            /* [in] */ BOOL fNoneImpliesFolder,
            /* [out] */ __RPC__deref_out_opt IShellItemArray **ppsia) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSelectionState( 
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl,
            /* [out] */ __RPC__out DWORD *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InvokeVerbOnSelection( 
            /* [string][unique][in] */ __RPC__in_opt LPCSTR pszVerb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetViewModeAndIconSize( 
            /* [in] */ FOLDERVIEWMODE uViewMode,
            /* [in] */ int iImageSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetViewModeAndIconSize( 
            /* [out] */ __RPC__out FOLDERVIEWMODE *puViewMode,
            /* [out] */ __RPC__out int *piImageSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetGroupSubsetCount( 
            /* [in] */ UINT cVisibleRows) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGroupSubsetCount( 
            /* [out] */ __RPC__out UINT *pcVisibleRows) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRedraw( 
            /* [in] */ BOOL fRedrawOn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsMoveInSameFolder( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoRename( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFolderView2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFolderView2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFolderView2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFolderView2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentViewMode )( 
            IFolderView2 * This,
            /* [out][in] */ __RPC__inout UINT *pViewMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetCurrentViewMode )( 
            IFolderView2 * This,
            /* [in] */ UINT ViewMode);
        
        HRESULT ( STDMETHODCALLTYPE *GetFolder )( 
            IFolderView2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *Item )( 
            IFolderView2 * This,
            /* [in] */ int iItemIndex,
            /* [out] */ __RPC__deref_out_opt PITEMID_CHILD *ppidl);
        
        HRESULT ( STDMETHODCALLTYPE *ItemCount )( 
            IFolderView2 * This,
            /* [in] */ UINT uFlags,
            /* [out] */ __RPC__out int *pcItems);
        
        HRESULT ( STDMETHODCALLTYPE *Items )( 
            IFolderView2 * This,
            /* [in] */ UINT uFlags,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelectionMarkedItem )( 
            IFolderView2 * This,
            /* [out] */ __RPC__out int *piItem);
        
        HRESULT ( STDMETHODCALLTYPE *GetFocusedItem )( 
            IFolderView2 * This,
            /* [out] */ __RPC__out int *piItem);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemPosition )( 
            IFolderView2 * This,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl,
            /* [out] */ __RPC__out POINT *ppt);
        
        HRESULT ( STDMETHODCALLTYPE *GetSpacing )( 
            IFolderView2 * This,
            /* [unique][out][in] */ __RPC__inout_opt POINT *ppt);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultSpacing )( 
            IFolderView2 * This,
            /* [out] */ __RPC__out POINT *ppt);
        
        HRESULT ( STDMETHODCALLTYPE *GetAutoArrange )( 
            IFolderView2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SelectItem )( 
            IFolderView2 * This,
            /* [in] */ int iItem,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SelectAndPositionItems )( 
            IFolderView2 * This,
            /* [in] */ UINT cidl,
            /* [size_is][in] */ __RPC__in_ecount_full(cidl) PCUITEMID_CHILD_ARRAY apidl,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(cidl) POINT *apt,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetGroupBy )( 
            IFolderView2 * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ BOOL fAscending);
        
        HRESULT ( STDMETHODCALLTYPE *GetGroupBy )( 
            IFolderView2 * This,
            /* [out] */ __RPC__out PROPERTYKEY *pkey,
            /* [out] */ __RPC__out BOOL *pfAscending);
        
        HRESULT ( STDMETHODCALLTYPE *SetViewProperty )( 
            IFolderView2 * This,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl,
            /* [in] */ __RPC__in REFPROPERTYKEY propkey,
            /* [in] */ __RPC__in REFPROPVARIANT propvar);
        
        HRESULT ( STDMETHODCALLTYPE *GetViewProperty )( 
            IFolderView2 * This,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl,
            /* [in] */ __RPC__in REFPROPERTYKEY propkey,
            /* [out] */ __RPC__out PROPVARIANT *ppropvar);
        
        HRESULT ( STDMETHODCALLTYPE *SetTileViewProperties )( 
            IFolderView2 * This,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl,
            /* [string][in] */ __RPC__in LPCWSTR pszPropList);
        
        HRESULT ( STDMETHODCALLTYPE *SetExtendedTileViewProperties )( 
            IFolderView2 * This,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl,
            /* [string][in] */ __RPC__in LPCWSTR pszPropList);
        
        HRESULT ( STDMETHODCALLTYPE *SetText )( 
            IFolderView2 * This,
            /* [in] */ FVTEXTTYPE iType,
            /* [in] */ __RPC__in LPCWSTR pwszText);
        
        HRESULT ( STDMETHODCALLTYPE *SetCurrentFolderFlags )( 
            IFolderView2 * This,
            /* [in] */ DWORD dwMask,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentFolderFlags )( 
            IFolderView2 * This,
            /* [out] */ __RPC__out DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetSortColumnCount )( 
            IFolderView2 * This,
            /* [out] */ __RPC__out int *pcColumns);
        
        HRESULT ( STDMETHODCALLTYPE *SetSortColumns )( 
            IFolderView2 * This,
            /* [size_is][in] */ __RPC__in_ecount_full(cColumns) const SORTCOLUMN *rgSortColumns,
            /* [in] */ int cColumns);
        
        HRESULT ( STDMETHODCALLTYPE *GetSortColumns )( 
            IFolderView2 * This,
            /* [size_is][out] */ __RPC__out_ecount_full(cColumns) SORTCOLUMN *rgSortColumns,
            /* [in] */ int cColumns);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            IFolderView2 * This,
            /* [in] */ int iItem,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetVisibleItem )( 
            IFolderView2 * This,
            /* [in] */ int iStart,
            /* [in] */ BOOL fPrevious,
            /* [out] */ __RPC__out int *piItem);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelectedItem )( 
            IFolderView2 * This,
            /* [in] */ int iStart,
            /* [out] */ __RPC__out int *piItem);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelection )( 
            IFolderView2 * This,
            /* [in] */ BOOL fNoneImpliesFolder,
            /* [out] */ __RPC__deref_out_opt IShellItemArray **ppsia);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelectionState )( 
            IFolderView2 * This,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl,
            /* [out] */ __RPC__out DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *InvokeVerbOnSelection )( 
            IFolderView2 * This,
            /* [string][unique][in] */ __RPC__in_opt LPCSTR pszVerb);
        
        HRESULT ( STDMETHODCALLTYPE *SetViewModeAndIconSize )( 
            IFolderView2 * This,
            /* [in] */ FOLDERVIEWMODE uViewMode,
            /* [in] */ int iImageSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetViewModeAndIconSize )( 
            IFolderView2 * This,
            /* [out] */ __RPC__out FOLDERVIEWMODE *puViewMode,
            /* [out] */ __RPC__out int *piImageSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetGroupSubsetCount )( 
            IFolderView2 * This,
            /* [in] */ UINT cVisibleRows);
        
        HRESULT ( STDMETHODCALLTYPE *GetGroupSubsetCount )( 
            IFolderView2 * This,
            /* [out] */ __RPC__out UINT *pcVisibleRows);
        
        HRESULT ( STDMETHODCALLTYPE *SetRedraw )( 
            IFolderView2 * This,
            /* [in] */ BOOL fRedrawOn);
        
        HRESULT ( STDMETHODCALLTYPE *IsMoveInSameFolder )( 
            IFolderView2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *DoRename )( 
            IFolderView2 * This);
        
        END_INTERFACE
    } IFolderView2Vtbl;

    interface IFolderView2
    {
        CONST_VTBL struct IFolderView2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFolderView2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFolderView2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFolderView2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFolderView2_GetCurrentViewMode(This,pViewMode)	\
    ( (This)->lpVtbl -> GetCurrentViewMode(This,pViewMode) ) 

#define IFolderView2_SetCurrentViewMode(This,ViewMode)	\
    ( (This)->lpVtbl -> SetCurrentViewMode(This,ViewMode) ) 

#define IFolderView2_GetFolder(This,riid,ppv)	\
    ( (This)->lpVtbl -> GetFolder(This,riid,ppv) ) 

#define IFolderView2_Item(This,iItemIndex,ppidl)	\
    ( (This)->lpVtbl -> Item(This,iItemIndex,ppidl) ) 

#define IFolderView2_ItemCount(This,uFlags,pcItems)	\
    ( (This)->lpVtbl -> ItemCount(This,uFlags,pcItems) ) 

#define IFolderView2_Items(This,uFlags,riid,ppv)	\
    ( (This)->lpVtbl -> Items(This,uFlags,riid,ppv) ) 

#define IFolderView2_GetSelectionMarkedItem(This,piItem)	\
    ( (This)->lpVtbl -> GetSelectionMarkedItem(This,piItem) ) 

#define IFolderView2_GetFocusedItem(This,piItem)	\
    ( (This)->lpVtbl -> GetFocusedItem(This,piItem) ) 

#define IFolderView2_GetItemPosition(This,pidl,ppt)	\
    ( (This)->lpVtbl -> GetItemPosition(This,pidl,ppt) ) 

#define IFolderView2_GetSpacing(This,ppt)	\
    ( (This)->lpVtbl -> GetSpacing(This,ppt) ) 

#define IFolderView2_GetDefaultSpacing(This,ppt)	\
    ( (This)->lpVtbl -> GetDefaultSpacing(This,ppt) ) 

#define IFolderView2_GetAutoArrange(This)	\
    ( (This)->lpVtbl -> GetAutoArrange(This) ) 

#define IFolderView2_SelectItem(This,iItem,dwFlags)	\
    ( (This)->lpVtbl -> SelectItem(This,iItem,dwFlags) ) 

#define IFolderView2_SelectAndPositionItems(This,cidl,apidl,apt,dwFlags)	\
    ( (This)->lpVtbl -> SelectAndPositionItems(This,cidl,apidl,apt,dwFlags) ) 


#define IFolderView2_SetGroupBy(This,key,fAscending)	\
    ( (This)->lpVtbl -> SetGroupBy(This,key,fAscending) ) 

#define IFolderView2_GetGroupBy(This,pkey,pfAscending)	\
    ( (This)->lpVtbl -> GetGroupBy(This,pkey,pfAscending) ) 

#define IFolderView2_SetViewProperty(This,pidl,propkey,propvar)	\
    ( (This)->lpVtbl -> SetViewProperty(This,pidl,propkey,propvar) ) 

#define IFolderView2_GetViewProperty(This,pidl,propkey,ppropvar)	\
    ( (This)->lpVtbl -> GetViewProperty(This,pidl,propkey,ppropvar) ) 

#define IFolderView2_SetTileViewProperties(This,pidl,pszPropList)	\
    ( (This)->lpVtbl -> SetTileViewProperties(This,pidl,pszPropList) ) 

#define IFolderView2_SetExtendedTileViewProperties(This,pidl,pszPropList)	\
    ( (This)->lpVtbl -> SetExtendedTileViewProperties(This,pidl,pszPropList) ) 

#define IFolderView2_SetText(This,iType,pwszText)	\
    ( (This)->lpVtbl -> SetText(This,iType,pwszText) ) 

#define IFolderView2_SetCurrentFolderFlags(This,dwMask,dwFlags)	\
    ( (This)->lpVtbl -> SetCurrentFolderFlags(This,dwMask,dwFlags) ) 

#define IFolderView2_GetCurrentFolderFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> GetCurrentFolderFlags(This,pdwFlags) ) 

#define IFolderView2_GetSortColumnCount(This,pcColumns)	\
    ( (This)->lpVtbl -> GetSortColumnCount(This,pcColumns) ) 

#define IFolderView2_SetSortColumns(This,rgSortColumns,cColumns)	\
    ( (This)->lpVtbl -> SetSortColumns(This,rgSortColumns,cColumns) ) 

#define IFolderView2_GetSortColumns(This,rgSortColumns,cColumns)	\
    ( (This)->lpVtbl -> GetSortColumns(This,rgSortColumns,cColumns) ) 

#define IFolderView2_GetItem(This,iItem,riid,ppv)	\
    ( (This)->lpVtbl -> GetItem(This,iItem,riid,ppv) ) 

#define IFolderView2_GetVisibleItem(This,iStart,fPrevious,piItem)	\
    ( (This)->lpVtbl -> GetVisibleItem(This,iStart,fPrevious,piItem) ) 

#define IFolderView2_GetSelectedItem(This,iStart,piItem)	\
    ( (This)->lpVtbl -> GetSelectedItem(This,iStart,piItem) ) 

#define IFolderView2_GetSelection(This,fNoneImpliesFolder,ppsia)	\
    ( (This)->lpVtbl -> GetSelection(This,fNoneImpliesFolder,ppsia) ) 

#define IFolderView2_GetSelectionState(This,pidl,pdwFlags)	\
    ( (This)->lpVtbl -> GetSelectionState(This,pidl,pdwFlags) ) 

#define IFolderView2_InvokeVerbOnSelection(This,pszVerb)	\
    ( (This)->lpVtbl -> InvokeVerbOnSelection(This,pszVerb) ) 

#define IFolderView2_SetViewModeAndIconSize(This,uViewMode,iImageSize)	\
    ( (This)->lpVtbl -> SetViewModeAndIconSize(This,uViewMode,iImageSize) ) 

#define IFolderView2_GetViewModeAndIconSize(This,puViewMode,piImageSize)	\
    ( (This)->lpVtbl -> GetViewModeAndIconSize(This,puViewMode,piImageSize) ) 

#define IFolderView2_SetGroupSubsetCount(This,cVisibleRows)	\
    ( (This)->lpVtbl -> SetGroupSubsetCount(This,cVisibleRows) ) 

#define IFolderView2_GetGroupSubsetCount(This,pcVisibleRows)	\
    ( (This)->lpVtbl -> GetGroupSubsetCount(This,pcVisibleRows) ) 

#define IFolderView2_SetRedraw(This,fRedrawOn)	\
    ( (This)->lpVtbl -> SetRedraw(This,fRedrawOn) ) 

#define IFolderView2_IsMoveInSameFolder(This)	\
    ( (This)->lpVtbl -> IsMoveInSameFolder(This) ) 

#define IFolderView2_DoRename(This)	\
    ( (This)->lpVtbl -> DoRename(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFolderView2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0019 */
/* [local] */ 

#if (NTDDI_VERSION >= NTDDI_VISTA)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0019_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0019_v0_0_s_ifspec;

#ifndef __IFolderViewSettings_INTERFACE_DEFINED__
#define __IFolderViewSettings_INTERFACE_DEFINED__

/* interface IFolderViewSettings */
/* [object][uuid] */ 


EXTERN_C const IID IID_IFolderViewSettings;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ae8c987d-8797-4ed3-be72-2a47dd938db0")
    IFolderViewSettings : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetColumnPropertyList( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGroupByProperty( 
            /* [out] */ __RPC__out PROPERTYKEY *pkey,
            /* [out] */ __RPC__out BOOL *pfGroupAscending) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetViewMode( 
            /* [out] */ __RPC__out FOLDERLOGICALVIEWMODE *plvm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIconSize( 
            /* [out] */ __RPC__out UINT *puIconSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFolderFlags( 
            /* [out] */ __RPC__out FOLDERFLAGS *pfolderMask,
            /* [out] */ __RPC__out FOLDERFLAGS *pfolderFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSortColumns( 
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(cColumnsIn, *pcColumnsOut) SORTCOLUMN *rgSortColumns,
            /* [in] */ UINT cColumnsIn,
            /* [out] */ __RPC__out UINT *pcColumnsOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGroupSubsetCount( 
            /* [out] */ __RPC__out UINT *pcVisibleRows) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFolderViewSettingsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFolderViewSettings * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFolderViewSettings * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFolderViewSettings * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetColumnPropertyList )( 
            IFolderViewSettings * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetGroupByProperty )( 
            IFolderViewSettings * This,
            /* [out] */ __RPC__out PROPERTYKEY *pkey,
            /* [out] */ __RPC__out BOOL *pfGroupAscending);
        
        HRESULT ( STDMETHODCALLTYPE *GetViewMode )( 
            IFolderViewSettings * This,
            /* [out] */ __RPC__out FOLDERLOGICALVIEWMODE *plvm);
        
        HRESULT ( STDMETHODCALLTYPE *GetIconSize )( 
            IFolderViewSettings * This,
            /* [out] */ __RPC__out UINT *puIconSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetFolderFlags )( 
            IFolderViewSettings * This,
            /* [out] */ __RPC__out FOLDERFLAGS *pfolderMask,
            /* [out] */ __RPC__out FOLDERFLAGS *pfolderFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetSortColumns )( 
            IFolderViewSettings * This,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(cColumnsIn, *pcColumnsOut) SORTCOLUMN *rgSortColumns,
            /* [in] */ UINT cColumnsIn,
            /* [out] */ __RPC__out UINT *pcColumnsOut);
        
        HRESULT ( STDMETHODCALLTYPE *GetGroupSubsetCount )( 
            IFolderViewSettings * This,
            /* [out] */ __RPC__out UINT *pcVisibleRows);
        
        END_INTERFACE
    } IFolderViewSettingsVtbl;

    interface IFolderViewSettings
    {
        CONST_VTBL struct IFolderViewSettingsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFolderViewSettings_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFolderViewSettings_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFolderViewSettings_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFolderViewSettings_GetColumnPropertyList(This,riid,ppv)	\
    ( (This)->lpVtbl -> GetColumnPropertyList(This,riid,ppv) ) 

#define IFolderViewSettings_GetGroupByProperty(This,pkey,pfGroupAscending)	\
    ( (This)->lpVtbl -> GetGroupByProperty(This,pkey,pfGroupAscending) ) 

#define IFolderViewSettings_GetViewMode(This,plvm)	\
    ( (This)->lpVtbl -> GetViewMode(This,plvm) ) 

#define IFolderViewSettings_GetIconSize(This,puIconSize)	\
    ( (This)->lpVtbl -> GetIconSize(This,puIconSize) ) 

#define IFolderViewSettings_GetFolderFlags(This,pfolderMask,pfolderFlags)	\
    ( (This)->lpVtbl -> GetFolderFlags(This,pfolderMask,pfolderFlags) ) 

#define IFolderViewSettings_GetSortColumns(This,rgSortColumns,cColumnsIn,pcColumnsOut)	\
    ( (This)->lpVtbl -> GetSortColumns(This,rgSortColumns,cColumnsIn,pcColumnsOut) ) 

#define IFolderViewSettings_GetGroupSubsetCount(This,pcVisibleRows)	\
    ( (This)->lpVtbl -> GetGroupSubsetCount(This,pcVisibleRows) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFolderViewSettings_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0020 */
/* [local] */ 

#endif  // NTDDI_VISTA
#endif  // (_WIN32_IE >= _WIN32_IE_IE70)
#if (_WIN32_IE >= _WIN32_IE_IE70)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0020_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0020_v0_0_s_ifspec;

#ifndef __IPreviewHandlerVisuals_INTERFACE_DEFINED__
#define __IPreviewHandlerVisuals_INTERFACE_DEFINED__

/* interface IPreviewHandlerVisuals */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IPreviewHandlerVisuals;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("196bf9a5-b346-4ef0-aa1e-5dcdb76768b1")
    IPreviewHandlerVisuals : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetBackgroundColor( 
            /* [in] */ COLORREF color) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFont( 
            /* [in] */ __RPC__in const LOGFONTW *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTextColor( 
            /* [in] */ COLORREF color) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPreviewHandlerVisualsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPreviewHandlerVisuals * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPreviewHandlerVisuals * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPreviewHandlerVisuals * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetBackgroundColor )( 
            IPreviewHandlerVisuals * This,
            /* [in] */ COLORREF color);
        
        HRESULT ( STDMETHODCALLTYPE *SetFont )( 
            IPreviewHandlerVisuals * This,
            /* [in] */ __RPC__in const LOGFONTW *plf);
        
        HRESULT ( STDMETHODCALLTYPE *SetTextColor )( 
            IPreviewHandlerVisuals * This,
            /* [in] */ COLORREF color);
        
        END_INTERFACE
    } IPreviewHandlerVisualsVtbl;

    interface IPreviewHandlerVisuals
    {
        CONST_VTBL struct IPreviewHandlerVisualsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPreviewHandlerVisuals_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPreviewHandlerVisuals_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPreviewHandlerVisuals_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPreviewHandlerVisuals_SetBackgroundColor(This,color)	\
    ( (This)->lpVtbl -> SetBackgroundColor(This,color) ) 

#define IPreviewHandlerVisuals_SetFont(This,plf)	\
    ( (This)->lpVtbl -> SetFont(This,plf) ) 

#define IPreviewHandlerVisuals_SetTextColor(This,color)	\
    ( (This)->lpVtbl -> SetTextColor(This,color) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPreviewHandlerVisuals_INTERFACE_DEFINED__ */


#ifndef __IVisualProperties_INTERFACE_DEFINED__
#define __IVisualProperties_INTERFACE_DEFINED__

/* interface IVisualProperties */
/* [unique][object][uuid] */ 

typedef /* [v1_enum] */ 
enum tagVPWATERMARKFLAGS
    {	VPWF_DEFAULT	= 0,
	VPWF_ALPHABLEND	= 0x1
    } 	VPWATERMARKFLAGS;

typedef /* [v1_enum] */ 
enum tagVPCOLORFLAGS
    {	VPCF_TEXT	= 0x1,
	VPCF_BACKGROUND	= 0x2,
	VPCF_SORTCOLUMN	= 0x3,
	VPCF_SUBTEXT	= 0x4
    } 	VPCOLORFLAGS;


EXTERN_C const IID IID_IVisualProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e693cf68-d967-4112-8763-99172aee5e5a")
    IVisualProperties : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetWatermark( 
            /* [unique][in] */ __RPC__in_opt HBITMAP hbmp,
            /* [in] */ VPWATERMARKFLAGS vpwf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetColor( 
            /* [in] */ VPCOLORFLAGS vpcf,
            /* [in] */ COLORREF cr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColor( 
            /* [in] */ VPCOLORFLAGS vpcf,
            /* [out] */ __RPC__out COLORREF *pcr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetItemHeight( 
            /* [in] */ int cyItemInPixels) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItemHeight( 
            /* [out] */ __RPC__out int *cyItemInPixels) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFont( 
            /* [in] */ __RPC__in const LOGFONTW *plf,
            /* [in] */ BOOL bRedraw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFont( 
            /* [out] */ __RPC__out LOGFONTW *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTheme( 
            /* [string][in] */ __RPC__in LPCWSTR pszSubAppName,
            /* [string][in] */ __RPC__in LPCWSTR pszSubIdList) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVisualPropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVisualProperties * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVisualProperties * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVisualProperties * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetWatermark )( 
            IVisualProperties * This,
            /* [unique][in] */ __RPC__in_opt HBITMAP hbmp,
            /* [in] */ VPWATERMARKFLAGS vpwf);
        
        HRESULT ( STDMETHODCALLTYPE *SetColor )( 
            IVisualProperties * This,
            /* [in] */ VPCOLORFLAGS vpcf,
            /* [in] */ COLORREF cr);
        
        HRESULT ( STDMETHODCALLTYPE *GetColor )( 
            IVisualProperties * This,
            /* [in] */ VPCOLORFLAGS vpcf,
            /* [out] */ __RPC__out COLORREF *pcr);
        
        HRESULT ( STDMETHODCALLTYPE *SetItemHeight )( 
            IVisualProperties * This,
            /* [in] */ int cyItemInPixels);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemHeight )( 
            IVisualProperties * This,
            /* [out] */ __RPC__out int *cyItemInPixels);
        
        HRESULT ( STDMETHODCALLTYPE *SetFont )( 
            IVisualProperties * This,
            /* [in] */ __RPC__in const LOGFONTW *plf,
            /* [in] */ BOOL bRedraw);
        
        HRESULT ( STDMETHODCALLTYPE *GetFont )( 
            IVisualProperties * This,
            /* [out] */ __RPC__out LOGFONTW *plf);
        
        HRESULT ( STDMETHODCALLTYPE *SetTheme )( 
            IVisualProperties * This,
            /* [string][in] */ __RPC__in LPCWSTR pszSubAppName,
            /* [string][in] */ __RPC__in LPCWSTR pszSubIdList);
        
        END_INTERFACE
    } IVisualPropertiesVtbl;

    interface IVisualProperties
    {
        CONST_VTBL struct IVisualPropertiesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVisualProperties_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVisualProperties_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVisualProperties_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVisualProperties_SetWatermark(This,hbmp,vpwf)	\
    ( (This)->lpVtbl -> SetWatermark(This,hbmp,vpwf) ) 

#define IVisualProperties_SetColor(This,vpcf,cr)	\
    ( (This)->lpVtbl -> SetColor(This,vpcf,cr) ) 

#define IVisualProperties_GetColor(This,vpcf,pcr)	\
    ( (This)->lpVtbl -> GetColor(This,vpcf,pcr) ) 

#define IVisualProperties_SetItemHeight(This,cyItemInPixels)	\
    ( (This)->lpVtbl -> SetItemHeight(This,cyItemInPixels) ) 

#define IVisualProperties_GetItemHeight(This,cyItemInPixels)	\
    ( (This)->lpVtbl -> GetItemHeight(This,cyItemInPixels) ) 

#define IVisualProperties_SetFont(This,plf,bRedraw)	\
    ( (This)->lpVtbl -> SetFont(This,plf,bRedraw) ) 

#define IVisualProperties_GetFont(This,plf)	\
    ( (This)->lpVtbl -> GetFont(This,plf) ) 

#define IVisualProperties_SetTheme(This,pszSubAppName,pszSubIdList)	\
    ( (This)->lpVtbl -> SetTheme(This,pszSubAppName,pszSubIdList) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVisualProperties_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0022 */
/* [local] */ 

#endif  // _WIN32_IE_IE70
#define CDBOSC_SETFOCUS     0x00000000
#define CDBOSC_KILLFOCUS    0x00000001
#define CDBOSC_SELCHANGE    0x00000002
#define CDBOSC_RENAME       0x00000003
#define CDBOSC_STATECHANGE  0x00000004


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0022_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0022_v0_0_s_ifspec;

#ifndef __ICommDlgBrowser_INTERFACE_DEFINED__
#define __ICommDlgBrowser_INTERFACE_DEFINED__

/* interface ICommDlgBrowser */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_ICommDlgBrowser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000214F1-0000-0000-C000-000000000046")
    ICommDlgBrowser : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnDefaultCommand( 
            /* [in] */ __RPC__in_opt IShellView *ppshv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnStateChange( 
            /* [in] */ __RPC__in_opt IShellView *ppshv,
            /* [in] */ ULONG uChange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IncludeObject( 
            /* [unique][in] */ __RPC__in_opt IShellView *ppshv,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICommDlgBrowserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICommDlgBrowser * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICommDlgBrowser * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICommDlgBrowser * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnDefaultCommand )( 
            ICommDlgBrowser * This,
            /* [in] */ __RPC__in_opt IShellView *ppshv);
        
        HRESULT ( STDMETHODCALLTYPE *OnStateChange )( 
            ICommDlgBrowser * This,
            /* [in] */ __RPC__in_opt IShellView *ppshv,
            /* [in] */ ULONG uChange);
        
        HRESULT ( STDMETHODCALLTYPE *IncludeObject )( 
            ICommDlgBrowser * This,
            /* [unique][in] */ __RPC__in_opt IShellView *ppshv,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl);
        
        END_INTERFACE
    } ICommDlgBrowserVtbl;

    interface ICommDlgBrowser
    {
        CONST_VTBL struct ICommDlgBrowserVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICommDlgBrowser_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICommDlgBrowser_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICommDlgBrowser_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICommDlgBrowser_OnDefaultCommand(This,ppshv)	\
    ( (This)->lpVtbl -> OnDefaultCommand(This,ppshv) ) 

#define ICommDlgBrowser_OnStateChange(This,ppshv,uChange)	\
    ( (This)->lpVtbl -> OnStateChange(This,ppshv,uChange) ) 

#define ICommDlgBrowser_IncludeObject(This,ppshv,pidl)	\
    ( (This)->lpVtbl -> IncludeObject(This,ppshv,pidl) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICommDlgBrowser_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0023 */
/* [local] */ 

typedef ICommDlgBrowser *LPCOMMDLGBROWSER;

#define SID_SExplorerBrowserFrame IID_ICommDlgBrowser
#if (NTDDI_VERSION >= NTDDI_WIN2K)
#define CDB2N_CONTEXTMENU_DONE  0x00000001
#define CDB2N_CONTEXTMENU_START 0x00000002
#define CDB2GVF_SHOWALLFILES        0x00000001
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define CDB2GVF_ISFILESAVE          0x00000002 // is file save, else file open
#define CDB2GVF_ALLOWPREVIEWPANE    0x00000004
#define CDB2GVF_NOSELECTVERB        0x00000008
#define CDB2GVF_NOINCLUDEITEM       0x00000010
#define CDB2GVF_ISFOLDERPICKER      0x00000020
#endif  // NTDDI_VISTA


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0023_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0023_v0_0_s_ifspec;

#ifndef __ICommDlgBrowser2_INTERFACE_DEFINED__
#define __ICommDlgBrowser2_INTERFACE_DEFINED__

/* interface ICommDlgBrowser2 */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_ICommDlgBrowser2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("10339516-2894-11d2-9039-00C04F8EEB3E")
    ICommDlgBrowser2 : public ICommDlgBrowser
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ __RPC__in_opt IShellView *ppshv,
            /* [in] */ DWORD dwNotifyType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultMenuText( 
            /* [in] */ __RPC__in_opt IShellView *ppshv,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cchMax) LPWSTR pszText,
            /* [in] */ int cchMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetViewFlags( 
            /* [out] */ __RPC__out DWORD *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICommDlgBrowser2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICommDlgBrowser2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICommDlgBrowser2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICommDlgBrowser2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnDefaultCommand )( 
            ICommDlgBrowser2 * This,
            /* [in] */ __RPC__in_opt IShellView *ppshv);
        
        HRESULT ( STDMETHODCALLTYPE *OnStateChange )( 
            ICommDlgBrowser2 * This,
            /* [in] */ __RPC__in_opt IShellView *ppshv,
            /* [in] */ ULONG uChange);
        
        HRESULT ( STDMETHODCALLTYPE *IncludeObject )( 
            ICommDlgBrowser2 * This,
            /* [unique][in] */ __RPC__in_opt IShellView *ppshv,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl);
        
        HRESULT ( STDMETHODCALLTYPE *Notify )( 
            ICommDlgBrowser2 * This,
            /* [in] */ __RPC__in_opt IShellView *ppshv,
            /* [in] */ DWORD dwNotifyType);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultMenuText )( 
            ICommDlgBrowser2 * This,
            /* [in] */ __RPC__in_opt IShellView *ppshv,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cchMax) LPWSTR pszText,
            /* [in] */ int cchMax);
        
        HRESULT ( STDMETHODCALLTYPE *GetViewFlags )( 
            ICommDlgBrowser2 * This,
            /* [out] */ __RPC__out DWORD *pdwFlags);
        
        END_INTERFACE
    } ICommDlgBrowser2Vtbl;

    interface ICommDlgBrowser2
    {
        CONST_VTBL struct ICommDlgBrowser2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICommDlgBrowser2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICommDlgBrowser2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICommDlgBrowser2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICommDlgBrowser2_OnDefaultCommand(This,ppshv)	\
    ( (This)->lpVtbl -> OnDefaultCommand(This,ppshv) ) 

#define ICommDlgBrowser2_OnStateChange(This,ppshv,uChange)	\
    ( (This)->lpVtbl -> OnStateChange(This,ppshv,uChange) ) 

#define ICommDlgBrowser2_IncludeObject(This,ppshv,pidl)	\
    ( (This)->lpVtbl -> IncludeObject(This,ppshv,pidl) ) 


#define ICommDlgBrowser2_Notify(This,ppshv,dwNotifyType)	\
    ( (This)->lpVtbl -> Notify(This,ppshv,dwNotifyType) ) 

#define ICommDlgBrowser2_GetDefaultMenuText(This,ppshv,pszText,cchMax)	\
    ( (This)->lpVtbl -> GetDefaultMenuText(This,ppshv,pszText,cchMax) ) 

#define ICommDlgBrowser2_GetViewFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> GetViewFlags(This,pdwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICommDlgBrowser2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0024 */
/* [local] */ 

typedef ICommDlgBrowser2 *LPCOMMDLGBROWSER2;

#endif  // NTDDI_WIN2K
#if (_WIN32_IE >= _WIN32_IE_IE70)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0024_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0024_v0_0_s_ifspec;

#ifndef __ICommDlgBrowser3_INTERFACE_DEFINED__
#define __ICommDlgBrowser3_INTERFACE_DEFINED__

/* interface ICommDlgBrowser3 */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_ICommDlgBrowser3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c8ad25a1-3294-41ee-8165-71174bd01c57")
    ICommDlgBrowser3 : public ICommDlgBrowser2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnColumnClicked( 
            /* [in] */ __RPC__in_opt IShellView *ppshv,
            /* [in] */ int iColumn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentFilter( 
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cchFileSpec) LPWSTR pszFileSpec,
            /* [in] */ int cchFileSpec) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnPreViewCreated( 
            /* [in] */ __RPC__in_opt IShellView *ppshv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICommDlgBrowser3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICommDlgBrowser3 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICommDlgBrowser3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICommDlgBrowser3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnDefaultCommand )( 
            ICommDlgBrowser3 * This,
            /* [in] */ __RPC__in_opt IShellView *ppshv);
        
        HRESULT ( STDMETHODCALLTYPE *OnStateChange )( 
            ICommDlgBrowser3 * This,
            /* [in] */ __RPC__in_opt IShellView *ppshv,
            /* [in] */ ULONG uChange);
        
        HRESULT ( STDMETHODCALLTYPE *IncludeObject )( 
            ICommDlgBrowser3 * This,
            /* [unique][in] */ __RPC__in_opt IShellView *ppshv,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl);
        
        HRESULT ( STDMETHODCALLTYPE *Notify )( 
            ICommDlgBrowser3 * This,
            /* [in] */ __RPC__in_opt IShellView *ppshv,
            /* [in] */ DWORD dwNotifyType);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultMenuText )( 
            ICommDlgBrowser3 * This,
            /* [in] */ __RPC__in_opt IShellView *ppshv,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cchMax) LPWSTR pszText,
            /* [in] */ int cchMax);
        
        HRESULT ( STDMETHODCALLTYPE *GetViewFlags )( 
            ICommDlgBrowser3 * This,
            /* [out] */ __RPC__out DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *OnColumnClicked )( 
            ICommDlgBrowser3 * This,
            /* [in] */ __RPC__in_opt IShellView *ppshv,
            /* [in] */ int iColumn);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentFilter )( 
            ICommDlgBrowser3 * This,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cchFileSpec) LPWSTR pszFileSpec,
            /* [in] */ int cchFileSpec);
        
        HRESULT ( STDMETHODCALLTYPE *OnPreViewCreated )( 
            ICommDlgBrowser3 * This,
            /* [in] */ __RPC__in_opt IShellView *ppshv);
        
        END_INTERFACE
    } ICommDlgBrowser3Vtbl;

    interface ICommDlgBrowser3
    {
        CONST_VTBL struct ICommDlgBrowser3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICommDlgBrowser3_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICommDlgBrowser3_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICommDlgBrowser3_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICommDlgBrowser3_OnDefaultCommand(This,ppshv)	\
    ( (This)->lpVtbl -> OnDefaultCommand(This,ppshv) ) 

#define ICommDlgBrowser3_OnStateChange(This,ppshv,uChange)	\
    ( (This)->lpVtbl -> OnStateChange(This,ppshv,uChange) ) 

#define ICommDlgBrowser3_IncludeObject(This,ppshv,pidl)	\
    ( (This)->lpVtbl -> IncludeObject(This,ppshv,pidl) ) 


#define ICommDlgBrowser3_Notify(This,ppshv,dwNotifyType)	\
    ( (This)->lpVtbl -> Notify(This,ppshv,dwNotifyType) ) 

#define ICommDlgBrowser3_GetDefaultMenuText(This,ppshv,pszText,cchMax)	\
    ( (This)->lpVtbl -> GetDefaultMenuText(This,ppshv,pszText,cchMax) ) 

#define ICommDlgBrowser3_GetViewFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> GetViewFlags(This,pdwFlags) ) 


#define ICommDlgBrowser3_OnColumnClicked(This,ppshv,iColumn)	\
    ( (This)->lpVtbl -> OnColumnClicked(This,ppshv,iColumn) ) 

#define ICommDlgBrowser3_GetCurrentFilter(This,pszFileSpec,cchFileSpec)	\
    ( (This)->lpVtbl -> GetCurrentFilter(This,pszFileSpec,cchFileSpec) ) 

#define ICommDlgBrowser3_OnPreViewCreated(This,ppshv)	\
    ( (This)->lpVtbl -> OnPreViewCreated(This,ppshv) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICommDlgBrowser3_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0025 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum tagCM_MASK
    {	CM_MASK_WIDTH	= 0x1,
	CM_MASK_DEFAULTWIDTH	= 0x2,
	CM_MASK_IDEALWIDTH	= 0x4,
	CM_MASK_NAME	= 0x8,
	CM_MASK_STATE	= 0x10
    } 	CM_MASK;

typedef /* [v1_enum] */ 
enum tagCM_STATE
    {	CM_STATE_NONE	= 0,
	CM_STATE_VISIBLE	= 0x1,
	CM_STATE_FIXEDWIDTH	= 0x2,
	CM_STATE_NOSORTBYFOLDERNESS	= 0x4,
	CM_STATE_ALWAYSVISIBLE	= 0x8
    } 	CM_STATE;

typedef /* [v1_enum] */ 
enum tagCM_ENUM_FLAGS
    {	CM_ENUM_ALL	= 0x1,
	CM_ENUM_VISIBLE	= 0x2
    } 	CM_ENUM_FLAGS;

typedef /* [v1_enum] */ 
enum tagCM_SET_WIDTH_VALUE
    {	CM_WIDTH_USEDEFAULT	= -1,
	CM_WIDTH_AUTOSIZE	= -2
    } 	CM_SET_WIDTH_VALUE;

typedef struct tagCM_COLUMNINFO
    {
    DWORD cbSize;
    DWORD dwMask;
    DWORD dwState;
    UINT uWidth;
    UINT uDefaultWidth;
    UINT uIdealWidth;
    WCHAR wszName[ 80 ];
    } 	CM_COLUMNINFO;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0025_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0025_v0_0_s_ifspec;

#ifndef __IColumnManager_INTERFACE_DEFINED__
#define __IColumnManager_INTERFACE_DEFINED__

/* interface IColumnManager */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IColumnManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d8ec27bb-3f3b-4042-b10a-4acfd924d453")
    IColumnManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetColumnInfo( 
            /* [in] */ __RPC__in REFPROPERTYKEY propkey,
            /* [in] */ __RPC__in const CM_COLUMNINFO *pcmci) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColumnInfo( 
            /* [in] */ __RPC__in REFPROPERTYKEY propkey,
            /* [out] */ __RPC__out CM_COLUMNINFO *pcmci) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColumnCount( 
            /* [in] */ CM_ENUM_FLAGS dwFlags,
            /* [out] */ __RPC__out UINT *puCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColumns( 
            /* [in] */ CM_ENUM_FLAGS dwFlags,
            /* [size_is][out] */ __RPC__out_ecount_full(cColumns) PROPERTYKEY *rgkeyOrder,
            /* [in] */ UINT cColumns) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetColumns( 
            /* [size_is][in] */ __RPC__in_ecount_full(cVisible) const PROPERTYKEY *rgkeyOrder,
            /* [in] */ UINT cVisible) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IColumnManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IColumnManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IColumnManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IColumnManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetColumnInfo )( 
            IColumnManager * This,
            /* [in] */ __RPC__in REFPROPERTYKEY propkey,
            /* [in] */ __RPC__in const CM_COLUMNINFO *pcmci);
        
        HRESULT ( STDMETHODCALLTYPE *GetColumnInfo )( 
            IColumnManager * This,
            /* [in] */ __RPC__in REFPROPERTYKEY propkey,
            /* [out] */ __RPC__out CM_COLUMNINFO *pcmci);
        
        HRESULT ( STDMETHODCALLTYPE *GetColumnCount )( 
            IColumnManager * This,
            /* [in] */ CM_ENUM_FLAGS dwFlags,
            /* [out] */ __RPC__out UINT *puCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetColumns )( 
            IColumnManager * This,
            /* [in] */ CM_ENUM_FLAGS dwFlags,
            /* [size_is][out] */ __RPC__out_ecount_full(cColumns) PROPERTYKEY *rgkeyOrder,
            /* [in] */ UINT cColumns);
        
        HRESULT ( STDMETHODCALLTYPE *SetColumns )( 
            IColumnManager * This,
            /* [size_is][in] */ __RPC__in_ecount_full(cVisible) const PROPERTYKEY *rgkeyOrder,
            /* [in] */ UINT cVisible);
        
        END_INTERFACE
    } IColumnManagerVtbl;

    interface IColumnManager
    {
        CONST_VTBL struct IColumnManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IColumnManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IColumnManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IColumnManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IColumnManager_SetColumnInfo(This,propkey,pcmci)	\
    ( (This)->lpVtbl -> SetColumnInfo(This,propkey,pcmci) ) 

#define IColumnManager_GetColumnInfo(This,propkey,pcmci)	\
    ( (This)->lpVtbl -> GetColumnInfo(This,propkey,pcmci) ) 

#define IColumnManager_GetColumnCount(This,dwFlags,puCount)	\
    ( (This)->lpVtbl -> GetColumnCount(This,dwFlags,puCount) ) 

#define IColumnManager_GetColumns(This,dwFlags,rgkeyOrder,cColumns)	\
    ( (This)->lpVtbl -> GetColumns(This,dwFlags,rgkeyOrder,cColumns) ) 

#define IColumnManager_SetColumns(This,rgkeyOrder,cVisible)	\
    ( (This)->lpVtbl -> SetColumns(This,rgkeyOrder,cVisible) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IColumnManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0026 */
/* [local] */ 

#endif  // (_WIN32_IE >= _WIN32_IE_IE70)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0026_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0026_v0_0_s_ifspec;

#ifndef __IFolderFilterSite_INTERFACE_DEFINED__
#define __IFolderFilterSite_INTERFACE_DEFINED__

/* interface IFolderFilterSite */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IFolderFilterSite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C0A651F5-B48B-11d2-B5ED-006097C686F6")
    IFolderFilterSite : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFilter( 
            /* [in] */ __RPC__in_opt IUnknown *punk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFolderFilterSiteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFolderFilterSite * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFolderFilterSite * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFolderFilterSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFilter )( 
            IFolderFilterSite * This,
            /* [in] */ __RPC__in_opt IUnknown *punk);
        
        END_INTERFACE
    } IFolderFilterSiteVtbl;

    interface IFolderFilterSite
    {
        CONST_VTBL struct IFolderFilterSiteVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFolderFilterSite_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFolderFilterSite_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFolderFilterSite_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFolderFilterSite_SetFilter(This,punk)	\
    ( (This)->lpVtbl -> SetFilter(This,punk) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFolderFilterSite_INTERFACE_DEFINED__ */


#ifndef __IFolderFilter_INTERFACE_DEFINED__
#define __IFolderFilter_INTERFACE_DEFINED__

/* interface IFolderFilter */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IFolderFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9CC22886-DC8E-11d2-B1D0-00C04F8EEB3E")
    IFolderFilter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ShouldShow( 
            /* [in] */ __RPC__in_opt IShellFolder *psf,
            /* [unique][in] */ __RPC__in_opt PCIDLIST_ABSOLUTE pidlFolder,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidlItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnumFlags( 
            /* [in] */ __RPC__in_opt IShellFolder *psf,
            /* [in] */ __RPC__in PCIDLIST_ABSOLUTE pidlFolder,
            /* [out] */ __RPC__deref_out_opt HWND *phwnd,
            /* [out][in] */ __RPC__inout DWORD *pgrfFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFolderFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFolderFilter * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFolderFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFolderFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *ShouldShow )( 
            IFolderFilter * This,
            /* [in] */ __RPC__in_opt IShellFolder *psf,
            /* [unique][in] */ __RPC__in_opt PCIDLIST_ABSOLUTE pidlFolder,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidlItem);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnumFlags )( 
            IFolderFilter * This,
            /* [in] */ __RPC__in_opt IShellFolder *psf,
            /* [in] */ __RPC__in PCIDLIST_ABSOLUTE pidlFolder,
            /* [out] */ __RPC__deref_out_opt HWND *phwnd,
            /* [out][in] */ __RPC__inout DWORD *pgrfFlags);
        
        END_INTERFACE
    } IFolderFilterVtbl;

    interface IFolderFilter
    {
        CONST_VTBL struct IFolderFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFolderFilter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFolderFilter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFolderFilter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFolderFilter_ShouldShow(This,psf,pidlFolder,pidlItem)	\
    ( (This)->lpVtbl -> ShouldShow(This,psf,pidlFolder,pidlItem) ) 

#define IFolderFilter_GetEnumFlags(This,psf,pidlFolder,phwnd,pgrfFlags)	\
    ( (This)->lpVtbl -> GetEnumFlags(This,psf,pidlFolder,phwnd,pgrfFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFolderFilter_INTERFACE_DEFINED__ */


#ifndef __IInputObjectSite_INTERFACE_DEFINED__
#define __IInputObjectSite_INTERFACE_DEFINED__

/* interface IInputObjectSite */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IInputObjectSite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F1DB8392-7331-11D0-8C99-00A0C92DBFE8")
    IInputObjectSite : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnFocusChangeIS( 
            /* [unique][in] */ __RPC__in_opt IUnknown *punkObj,
            /* [in] */ BOOL fSetFocus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInputObjectSiteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInputObjectSite * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInputObjectSite * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInputObjectSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnFocusChangeIS )( 
            IInputObjectSite * This,
            /* [unique][in] */ __RPC__in_opt IUnknown *punkObj,
            /* [in] */ BOOL fSetFocus);
        
        END_INTERFACE
    } IInputObjectSiteVtbl;

    interface IInputObjectSite
    {
        CONST_VTBL struct IInputObjectSiteVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInputObjectSite_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInputObjectSite_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInputObjectSite_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInputObjectSite_OnFocusChangeIS(This,punkObj,fSetFocus)	\
    ( (This)->lpVtbl -> OnFocusChangeIS(This,punkObj,fSetFocus) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInputObjectSite_INTERFACE_DEFINED__ */


#ifndef __IInputObject_INTERFACE_DEFINED__
#define __IInputObject_INTERFACE_DEFINED__

/* interface IInputObject */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IInputObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("68284fAA-6A48-11D0-8c78-00C04fd918b4")
    IInputObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE UIActivateIO( 
            /* [in] */ BOOL fActivate,
            /* [unique][in] */ __RPC__in_opt MSG *pMsg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HasFocusIO( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TranslateAcceleratorIO( 
            /* [in] */ __RPC__in MSG *pMsg) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInputObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInputObject * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInputObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInputObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *UIActivateIO )( 
            IInputObject * This,
            /* [in] */ BOOL fActivate,
            /* [unique][in] */ __RPC__in_opt MSG *pMsg);
        
        HRESULT ( STDMETHODCALLTYPE *HasFocusIO )( 
            IInputObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *TranslateAcceleratorIO )( 
            IInputObject * This,
            /* [in] */ __RPC__in MSG *pMsg);
        
        END_INTERFACE
    } IInputObjectVtbl;

    interface IInputObject
    {
        CONST_VTBL struct IInputObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInputObject_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInputObject_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInputObject_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInputObject_UIActivateIO(This,fActivate,pMsg)	\
    ( (This)->lpVtbl -> UIActivateIO(This,fActivate,pMsg) ) 

#define IInputObject_HasFocusIO(This)	\
    ( (This)->lpVtbl -> HasFocusIO(This) ) 

#define IInputObject_TranslateAcceleratorIO(This,pMsg)	\
    ( (This)->lpVtbl -> TranslateAcceleratorIO(This,pMsg) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInputObject_INTERFACE_DEFINED__ */


#ifndef __IInputObject2_INTERFACE_DEFINED__
#define __IInputObject2_INTERFACE_DEFINED__

/* interface IInputObject2 */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IInputObject2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6915C085-510B-44cd-94AF-28DFA56CF92B")
    IInputObject2 : public IInputObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE TranslateAcceleratorGlobal( 
            /* [in] */ 
            __in  MSG *pMsg) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInputObject2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInputObject2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInputObject2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInputObject2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *UIActivateIO )( 
            IInputObject2 * This,
            /* [in] */ BOOL fActivate,
            /* [unique][in] */ MSG *pMsg);
        
        HRESULT ( STDMETHODCALLTYPE *HasFocusIO )( 
            IInputObject2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *TranslateAcceleratorIO )( 
            IInputObject2 * This,
            /* [in] */ MSG *pMsg);
        
        HRESULT ( STDMETHODCALLTYPE *TranslateAcceleratorGlobal )( 
            IInputObject2 * This,
            /* [in] */ 
            __in  MSG *pMsg);
        
        END_INTERFACE
    } IInputObject2Vtbl;

    interface IInputObject2
    {
        CONST_VTBL struct IInputObject2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInputObject2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInputObject2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInputObject2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInputObject2_UIActivateIO(This,fActivate,pMsg)	\
    ( (This)->lpVtbl -> UIActivateIO(This,fActivate,pMsg) ) 

#define IInputObject2_HasFocusIO(This)	\
    ( (This)->lpVtbl -> HasFocusIO(This) ) 

#define IInputObject2_TranslateAcceleratorIO(This,pMsg)	\
    ( (This)->lpVtbl -> TranslateAcceleratorIO(This,pMsg) ) 


#define IInputObject2_TranslateAcceleratorGlobal(This,pMsg)	\
    ( (This)->lpVtbl -> TranslateAcceleratorGlobal(This,pMsg) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInputObject2_INTERFACE_DEFINED__ */


#ifndef __IShellIcon_INTERFACE_DEFINED__
#define __IShellIcon_INTERFACE_DEFINED__

/* interface IShellIcon */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IShellIcon;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000214E5-0000-0000-C000-000000000046")
    IShellIcon : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetIconOf( 
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl,
            /* [in] */ UINT flags,
            /* [out] */ __RPC__out int *pIconIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellIconVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellIcon * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellIcon * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellIcon * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetIconOf )( 
            IShellIcon * This,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl,
            /* [in] */ UINT flags,
            /* [out] */ __RPC__out int *pIconIndex);
        
        END_INTERFACE
    } IShellIconVtbl;

    interface IShellIcon
    {
        CONST_VTBL struct IShellIconVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellIcon_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellIcon_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellIcon_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellIcon_GetIconOf(This,pidl,flags,pIconIndex)	\
    ( (This)->lpVtbl -> GetIconOf(This,pidl,flags,pIconIndex) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellIcon_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0032 */
/* [local] */ 

#define SBSP_DEFBROWSER         0x0000
#define SBSP_SAMEBROWSER        0x0001
#define SBSP_NEWBROWSER         0x0002
#define SBSP_DEFMODE            0x0000
#define SBSP_OPENMODE           0x0010
#define SBSP_EXPLOREMODE        0x0020
#define SBSP_HELPMODE           0x0040
#define SBSP_NOTRANSFERHIST     0x0080
#define SBSP_ABSOLUTE           0x0000
#define SBSP_RELATIVE           0x1000
#define SBSP_PARENT             0x2000
#define SBSP_NAVIGATEBACK       0x4000
#define SBSP_NAVIGATEFORWARD    0x8000
#define SBSP_ALLOW_AUTONAVIGATE   0x00010000
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define SBSP_KEEPSAMETEMPLATE     0x00020000
#define SBSP_KEEPWORDWHEELTEXT    0x00040000
#define SBSP_ACTIVATE_NOFOCUS     0x00080000
#endif  // (NTDDI_VERSION >= NTDDI_VISTA)
#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
#define SBSP_CALLERUNTRUSTED      0x00800000
#define SBSP_TRUSTFIRSTDOWNLOAD   0x01000000
#define SBSP_UNTRUSTEDFORDOWNLOAD 0x02000000
#endif  // _WIN32_IE_IE60SP2
#define SBSP_NOAUTOSELECT         0x04000000
#define SBSP_WRITENOHISTORY       0x08000000
#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
#define SBSP_TRUSTEDFORACTIVEX    0x10000000
#endif  // _WIN32_IE_IE60SP2
#if (_WIN32_IE >= _WIN32_IE_IE70)
#define SBSP_FEEDNAVIGATION       0x20000000
#endif  // _WIN32_IE_IE70
#define SBSP_REDIRECT                     0x40000000
#define SBSP_INITIATEDBYHLINKFRAME        0x80000000
#define FCW_STATUS         0x0001
#define FCW_TOOLBAR        0x0002
#define FCW_TREE           0x0003
#define FCW_INTERNETBAR    0x0006
#define FCW_PROGRESS       0x0008
#if (_WIN32_IE >= 0x0700)
#endif
#define FCT_MERGE       0x0001
#define FCT_CONFIGABLE  0x0002
#define FCT_ADDTOEND    0x0004
#ifdef _NEVER_
typedef LPARAM LPTBBUTTONSB;

#else //!_NEVER_
#include <commctrl.h>
typedef LPTBBUTTON LPTBBUTTONSB;
#endif //_NEVER_


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0032_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0032_v0_0_s_ifspec;

#ifndef __IShellBrowser_INTERFACE_DEFINED__
#define __IShellBrowser_INTERFACE_DEFINED__

/* interface IShellBrowser */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IShellBrowser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000214E2-0000-0000-C000-000000000046")
    IShellBrowser : public IOleWindow
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InsertMenusSB( 
            /* [in] */ __RPC__in HMENU hmenuShared,
            /* [out][in] */ __RPC__inout LPOLEMENUGROUPWIDTHS lpMenuWidths) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMenuSB( 
            /* [unique][in] */ __RPC__in_opt HMENU hmenuShared,
            /* [unique][in] */ __RPC__in_opt HOLEMENU holemenuRes,
            /* [unique][in] */ __RPC__in_opt HWND hwndActiveObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveMenusSB( 
            /* [in] */ __RPC__in HMENU hmenuShared) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStatusTextSB( 
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszStatusText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableModelessSB( 
            /* [in] */ BOOL fEnable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TranslateAcceleratorSB( 
            /* [in] */ __RPC__in MSG *pmsg,
            /* [in] */ WORD wID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BrowseObject( 
            /* [unique][in] */ __RPC__in_opt PCUIDLIST_RELATIVE pidl,
            /* [in] */ UINT wFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetViewStateStream( 
            /* [in] */ DWORD grfMode,
            /* [out] */ __RPC__deref_out_opt IStream **ppStrm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetControlWindow( 
            /* [in] */ UINT id,
            /* [out] */ __RPC__deref_out_opt HWND *phwnd) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SendControlMsg( 
            /* [in] */ 
            __in  UINT id,
            /* [in] */ 
            __in  UINT uMsg,
            /* [in] */ 
            __in  WPARAM wParam,
            /* [in] */ 
            __in  LPARAM lParam,
            /* [out] */ 
            __out_opt  LRESULT *pret) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryActiveShellView( 
            /* [out] */ __RPC__deref_out_opt IShellView **ppshv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnViewWindowActive( 
            /* [in] */ __RPC__in_opt IShellView *pshv) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetToolbarItems( 
            /* [in] */ 
            __in_ecount_opt(nButtons)  LPTBBUTTONSB lpButtons,
            /* [in] */ 
            __in  UINT nButtons,
            /* [in] */ 
            __in  UINT uFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellBrowserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellBrowser * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellBrowser * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellBrowser * This);
        
        /* [input_sync] */ HRESULT ( STDMETHODCALLTYPE *GetWindow )( 
            IShellBrowser * This,
            /* [out] */ __RPC__deref_out_opt HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *ContextSensitiveHelp )( 
            IShellBrowser * This,
            /* [in] */ BOOL fEnterMode);
        
        HRESULT ( STDMETHODCALLTYPE *InsertMenusSB )( 
            IShellBrowser * This,
            /* [in] */ __RPC__in HMENU hmenuShared,
            /* [out][in] */ __RPC__inout LPOLEMENUGROUPWIDTHS lpMenuWidths);
        
        HRESULT ( STDMETHODCALLTYPE *SetMenuSB )( 
            IShellBrowser * This,
            /* [unique][in] */ __RPC__in_opt HMENU hmenuShared,
            /* [unique][in] */ __RPC__in_opt HOLEMENU holemenuRes,
            /* [unique][in] */ __RPC__in_opt HWND hwndActiveObject);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveMenusSB )( 
            IShellBrowser * This,
            /* [in] */ __RPC__in HMENU hmenuShared);
        
        HRESULT ( STDMETHODCALLTYPE *SetStatusTextSB )( 
            IShellBrowser * This,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszStatusText);
        
        HRESULT ( STDMETHODCALLTYPE *EnableModelessSB )( 
            IShellBrowser * This,
            /* [in] */ BOOL fEnable);
        
        HRESULT ( STDMETHODCALLTYPE *TranslateAcceleratorSB )( 
            IShellBrowser * This,
            /* [in] */ __RPC__in MSG *pmsg,
            /* [in] */ WORD wID);
        
        HRESULT ( STDMETHODCALLTYPE *BrowseObject )( 
            IShellBrowser * This,
            /* [unique][in] */ __RPC__in_opt PCUIDLIST_RELATIVE pidl,
            /* [in] */ UINT wFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetViewStateStream )( 
            IShellBrowser * This,
            /* [in] */ DWORD grfMode,
            /* [out] */ __RPC__deref_out_opt IStream **ppStrm);
        
        HRESULT ( STDMETHODCALLTYPE *GetControlWindow )( 
            IShellBrowser * This,
            /* [in] */ UINT id,
            /* [out] */ __RPC__deref_out_opt HWND *phwnd);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SendControlMsg )( 
            IShellBrowser * This,
            /* [in] */ 
            __in  UINT id,
            /* [in] */ 
            __in  UINT uMsg,
            /* [in] */ 
            __in  WPARAM wParam,
            /* [in] */ 
            __in  LPARAM lParam,
            /* [out] */ 
            __out_opt  LRESULT *pret);
        
        HRESULT ( STDMETHODCALLTYPE *QueryActiveShellView )( 
            IShellBrowser * This,
            /* [out] */ __RPC__deref_out_opt IShellView **ppshv);
        
        HRESULT ( STDMETHODCALLTYPE *OnViewWindowActive )( 
            IShellBrowser * This,
            /* [in] */ __RPC__in_opt IShellView *pshv);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SetToolbarItems )( 
            IShellBrowser * This,
            /* [in] */ 
            __in_ecount_opt(nButtons)  LPTBBUTTONSB lpButtons,
            /* [in] */ 
            __in  UINT nButtons,
            /* [in] */ 
            __in  UINT uFlags);
        
        END_INTERFACE
    } IShellBrowserVtbl;

    interface IShellBrowser
    {
        CONST_VTBL struct IShellBrowserVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellBrowser_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellBrowser_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellBrowser_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellBrowser_GetWindow(This,phwnd)	\
    ( (This)->lpVtbl -> GetWindow(This,phwnd) ) 

#define IShellBrowser_ContextSensitiveHelp(This,fEnterMode)	\
    ( (This)->lpVtbl -> ContextSensitiveHelp(This,fEnterMode) ) 


#define IShellBrowser_InsertMenusSB(This,hmenuShared,lpMenuWidths)	\
    ( (This)->lpVtbl -> InsertMenusSB(This,hmenuShared,lpMenuWidths) ) 

#define IShellBrowser_SetMenuSB(This,hmenuShared,holemenuRes,hwndActiveObject)	\
    ( (This)->lpVtbl -> SetMenuSB(This,hmenuShared,holemenuRes,hwndActiveObject) ) 

#define IShellBrowser_RemoveMenusSB(This,hmenuShared)	\
    ( (This)->lpVtbl -> RemoveMenusSB(This,hmenuShared) ) 

#define IShellBrowser_SetStatusTextSB(This,pszStatusText)	\
    ( (This)->lpVtbl -> SetStatusTextSB(This,pszStatusText) ) 

#define IShellBrowser_EnableModelessSB(This,fEnable)	\
    ( (This)->lpVtbl -> EnableModelessSB(This,fEnable) ) 

#define IShellBrowser_TranslateAcceleratorSB(This,pmsg,wID)	\
    ( (This)->lpVtbl -> TranslateAcceleratorSB(This,pmsg,wID) ) 

#define IShellBrowser_BrowseObject(This,pidl,wFlags)	\
    ( (This)->lpVtbl -> BrowseObject(This,pidl,wFlags) ) 

#define IShellBrowser_GetViewStateStream(This,grfMode,ppStrm)	\
    ( (This)->lpVtbl -> GetViewStateStream(This,grfMode,ppStrm) ) 

#define IShellBrowser_GetControlWindow(This,id,phwnd)	\
    ( (This)->lpVtbl -> GetControlWindow(This,id,phwnd) ) 

#define IShellBrowser_SendControlMsg(This,id,uMsg,wParam,lParam,pret)	\
    ( (This)->lpVtbl -> SendControlMsg(This,id,uMsg,wParam,lParam,pret) ) 

#define IShellBrowser_QueryActiveShellView(This,ppshv)	\
    ( (This)->lpVtbl -> QueryActiveShellView(This,ppshv) ) 

#define IShellBrowser_OnViewWindowActive(This,pshv)	\
    ( (This)->lpVtbl -> OnViewWindowActive(This,pshv) ) 

#define IShellBrowser_SetToolbarItems(This,lpButtons,nButtons,uFlags)	\
    ( (This)->lpVtbl -> SetToolbarItems(This,lpButtons,nButtons,uFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellBrowser_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0033 */
/* [local] */ 

typedef IShellBrowser *LPSHELLBROWSER;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0033_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0033_v0_0_s_ifspec;

#ifndef __IProfferService_INTERFACE_DEFINED__
#define __IProfferService_INTERFACE_DEFINED__

/* interface IProfferService */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IProfferService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("cb728b20-f786-11ce-92ad-00aa00a74cd0")
    IProfferService : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ProfferService( 
            /* [in] */ __RPC__in REFGUID guidService,
            /* [in] */ __RPC__in_opt IServiceProvider *psp,
            /* [out] */ __RPC__out DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RevokeService( 
            /* [in] */ DWORD dwCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProfferServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IProfferService * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IProfferService * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IProfferService * This);
        
        HRESULT ( STDMETHODCALLTYPE *ProfferService )( 
            IProfferService * This,
            /* [in] */ __RPC__in REFGUID guidService,
            /* [in] */ __RPC__in_opt IServiceProvider *psp,
            /* [out] */ __RPC__out DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *RevokeService )( 
            IProfferService * This,
            /* [in] */ DWORD dwCookie);
        
        END_INTERFACE
    } IProfferServiceVtbl;

    interface IProfferService
    {
        CONST_VTBL struct IProfferServiceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProfferService_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IProfferService_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IProfferService_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IProfferService_ProfferService(This,guidService,psp,pdwCookie)	\
    ( (This)->lpVtbl -> ProfferService(This,guidService,psp,pdwCookie) ) 

#define IProfferService_RevokeService(This,dwCookie)	\
    ( (This)->lpVtbl -> RevokeService(This,dwCookie) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IProfferService_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0034 */
/* [local] */ 

#define SID_SProfferService IID_IProfferService    // nearest service that you can proffer to
#define STR_DONT_RESOLVE_LINK      L"Don't Resolve Link"
#define STR_PLAYLIST_EDITOR_UI  L"Static List In Dialog"


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0034_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0034_v0_0_s_ifspec;

#ifndef __IShellItem_INTERFACE_DEFINED__
#define __IShellItem_INTERFACE_DEFINED__

/* interface IShellItem */
/* [unique][object][uuid][helpstring] */ 

typedef /* [v1_enum] */ 
enum tagSIGDN
    {	SIGDN_NORMALDISPLAY	= 0,
	SIGDN_PARENTRELATIVEPARSING	= ( int  )0x80018001,
	SIGDN_DESKTOPABSOLUTEPARSING	= ( int  )0x80028000,
	SIGDN_PARENTRELATIVEEDITING	= ( int  )0x80031001,
	SIGDN_DESKTOPABSOLUTEEDITING	= ( int  )0x8004c000,
	SIGDN_FILESYSPATH	= ( int  )0x80058000,
	SIGDN_URL	= ( int  )0x80068000,
	SIGDN_PARENTRELATIVEFORADDRESSBAR	= ( int  )0x8007c001,
	SIGDN_PARENTRELATIVE	= ( int  )0x80080001
    } 	SIGDN;

/* [v1_enum] */ 
enum tagSHELLITEMCOMPAREHINTF
    {	SICHINT_DISPLAY	= 0,
	SICHINT_ALLFIELDS	= ( int  )0x80000000,
	SICHINT_CANONICAL	= 0x10000000
    } ;
typedef DWORD SICHINTF;


EXTERN_C const IID IID_IShellItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43826d1e-e718-42ee-bc55-a1e261c37bfe")
    IShellItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BindToHandler( 
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbc,
            /* [in] */ __RPC__in REFGUID bhid,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParent( 
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayName( 
            /* [in] */ SIGDN sigdnName,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributes( 
            /* [in] */ SFGAOF sfgaoMask,
            /* [out] */ __RPC__out SFGAOF *psfgaoAttribs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Compare( 
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [in] */ SICHINTF hint,
            /* [out] */ __RPC__out int *piOrder) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *BindToHandler )( 
            IShellItem * This,
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbc,
            /* [in] */ __RPC__in REFGUID bhid,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
            IShellItem * This,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            IShellItem * This,
            /* [in] */ SIGDN sigdnName,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributes )( 
            IShellItem * This,
            /* [in] */ SFGAOF sfgaoMask,
            /* [out] */ __RPC__out SFGAOF *psfgaoAttribs);
        
        HRESULT ( STDMETHODCALLTYPE *Compare )( 
            IShellItem * This,
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [in] */ SICHINTF hint,
            /* [out] */ __RPC__out int *piOrder);
        
        END_INTERFACE
    } IShellItemVtbl;

    interface IShellItem
    {
        CONST_VTBL struct IShellItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellItem_BindToHandler(This,pbc,bhid,riid,ppv)	\
    ( (This)->lpVtbl -> BindToHandler(This,pbc,bhid,riid,ppv) ) 

#define IShellItem_GetParent(This,ppsi)	\
    ( (This)->lpVtbl -> GetParent(This,ppsi) ) 

#define IShellItem_GetDisplayName(This,sigdnName,ppszName)	\
    ( (This)->lpVtbl -> GetDisplayName(This,sigdnName,ppszName) ) 

#define IShellItem_GetAttributes(This,sfgaoMask,psfgaoAttribs)	\
    ( (This)->lpVtbl -> GetAttributes(This,sfgaoMask,psfgaoAttribs) ) 

#define IShellItem_Compare(This,psi,hint,piOrder)	\
    ( (This)->lpVtbl -> Compare(This,psi,hint,piOrder) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellItem_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0035 */
/* [local] */ 

#if (_WIN32_IE >= _WIN32_IE_IE70)
// CLSID_ShellItem create and init helper APIs. produce IShellItem derived interfaces from these different expressions of an item
SHSTDAPI SHCreateItemFromIDList(__in PCIDLIST_ABSOLUTE pidl, __in REFIID riid, __deref_out void **ppv);
SHSTDAPI SHCreateItemFromParsingName(__in PCWSTR pszPath, __in_opt IBindCtx *pbc, __in REFIID riid, __deref_out void **ppv);
SHSTDAPI SHCreateItemWithParent(__in_opt PCIDLIST_ABSOLUTE pidlParent, __in_opt IShellFolder *psfParent, __in PCUITEMID_CHILD pidl, __in REFIID riid, __deref_out void **ppvItem);
SHSTDAPI SHCreateItemFromRelativeName(__in IShellItem *psiParent, __in PCWSTR pszName, __in_opt IBindCtx* pbc, __in REFIID riid, __deref_out void **ppv);
#endif  // (_WIN32_IE >= _WIN32_IE_IE70)
#if (NTDDI_VERSION >= NTDDI_VISTA)
SHSTDAPI SHCreateItemInKnownFolder(REFKNOWNFOLDERID kfid, DWORD dwKFFlags, __in_opt PCWSTR pszItem, REFIID riid, __deref_out void **ppv);
// get the IDList expression from an object, works with objects that support IPersistIDlist or IPersistIDlist like CLSID_ShellItem and most shell folders
SHSTDAPI SHGetIDListFromObject(__in_opt IUnknown *punk, __out PIDLIST_ABSOLUTE *ppidl);
// these APIs return object that support IPropertyStore or related interfaces
SHSTDAPI SHGetPropertyStoreFromIDList(__in PCIDLIST_ABSOLUTE pidl, GETPROPERTYSTOREFLAGS flags, REFIID riid, __out void **ppv);
SHSTDAPI SHGetPropertyStoreFromParsingName(__in PCWSTR pszPath, __in_opt IBindCtx *pbc, GETPROPERTYSTOREFLAGS flags, REFIID riid, __out void **ppv);
SHSTDAPI SHGetNameFromIDList(__in PCIDLIST_ABSOLUTE pidl, SIGDN sigdnName, __out PWSTR *ppszName);
#endif // (NTDDI_VERSION >= NTDDI_VISTA)
#define STR_GPS_HANDLERPROPERTIESONLY      L"GPS_HANDLERPROPERTIESONLY"
#define STR_GPS_FASTPROPERTIESONLY         L"GPS_FASTPROPERTIESONLY"
#define STR_GPS_OPENSLOWITEM               L"GPS_OPENSLOWITEM"
#define STR_GPS_DELAYCREATION              L"GPS_DELAYCREATION"
#define STR_GPS_BESTEFFORT                 L"GPS_BESTEFFORT"


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0035_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0035_v0_0_s_ifspec;

#ifndef __IShellItem2_INTERFACE_DEFINED__
#define __IShellItem2_INTERFACE_DEFINED__

/* interface IShellItem2 */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IShellItem2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7e9fb0d3-919f-4307-ab2e-9b1860310c93")
    IShellItem2 : public IShellItem
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPropertyStore( 
            /* [in] */ GETPROPERTYSTOREFLAGS flags,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyStoreWithCreateObject( 
            /* [in] */ GETPROPERTYSTOREFLAGS flags,
            /* [in] */ __RPC__in_opt IUnknown *punkCreateObject,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyStoreForKeys( 
            /* [size_is][in] */ __RPC__in_ecount_full(cKeys) const PROPERTYKEY *rgKeys,
            /* [in] */ UINT cKeys,
            /* [in] */ GETPROPERTYSTOREFLAGS flags,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyDescriptionList( 
            /* [in] */ __RPC__in REFPROPERTYKEY keyType,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Update( 
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out PROPVARIANT *ppropvar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCLSID( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out CLSID *pclsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFileTime( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out FILETIME *pft) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInt32( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out int *pi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetString( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppsz) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUInt32( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out ULONG *pui) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUInt64( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out ULONGLONG *pull) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBool( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out BOOL *pf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellItem2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellItem2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellItem2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellItem2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *BindToHandler )( 
            IShellItem2 * This,
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbc,
            /* [in] */ __RPC__in REFGUID bhid,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
            IShellItem2 * This,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            IShellItem2 * This,
            /* [in] */ SIGDN sigdnName,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributes )( 
            IShellItem2 * This,
            /* [in] */ SFGAOF sfgaoMask,
            /* [out] */ __RPC__out SFGAOF *psfgaoAttribs);
        
        HRESULT ( STDMETHODCALLTYPE *Compare )( 
            IShellItem2 * This,
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [in] */ SICHINTF hint,
            /* [out] */ __RPC__out int *piOrder);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyStore )( 
            IShellItem2 * This,
            /* [in] */ GETPROPERTYSTOREFLAGS flags,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyStoreWithCreateObject )( 
            IShellItem2 * This,
            /* [in] */ GETPROPERTYSTOREFLAGS flags,
            /* [in] */ __RPC__in_opt IUnknown *punkCreateObject,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyStoreForKeys )( 
            IShellItem2 * This,
            /* [size_is][in] */ __RPC__in_ecount_full(cKeys) const PROPERTYKEY *rgKeys,
            /* [in] */ UINT cKeys,
            /* [in] */ GETPROPERTYSTOREFLAGS flags,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyDescriptionList )( 
            IShellItem2 * This,
            /* [in] */ __RPC__in REFPROPERTYKEY keyType,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Update )( 
            IShellItem2 * This,
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbc);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IShellItem2 * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out PROPVARIANT *ppropvar);
        
        HRESULT ( STDMETHODCALLTYPE *GetCLSID )( 
            IShellItem2 * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out CLSID *pclsid);
        
        HRESULT ( STDMETHODCALLTYPE *GetFileTime )( 
            IShellItem2 * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out FILETIME *pft);
        
        HRESULT ( STDMETHODCALLTYPE *GetInt32 )( 
            IShellItem2 * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out int *pi);
        
        HRESULT ( STDMETHODCALLTYPE *GetString )( 
            IShellItem2 * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppsz);
        
        HRESULT ( STDMETHODCALLTYPE *GetUInt32 )( 
            IShellItem2 * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out ULONG *pui);
        
        HRESULT ( STDMETHODCALLTYPE *GetUInt64 )( 
            IShellItem2 * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out ULONGLONG *pull);
        
        HRESULT ( STDMETHODCALLTYPE *GetBool )( 
            IShellItem2 * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out BOOL *pf);
        
        END_INTERFACE
    } IShellItem2Vtbl;

    interface IShellItem2
    {
        CONST_VTBL struct IShellItem2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellItem2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellItem2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellItem2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellItem2_BindToHandler(This,pbc,bhid,riid,ppv)	\
    ( (This)->lpVtbl -> BindToHandler(This,pbc,bhid,riid,ppv) ) 

#define IShellItem2_GetParent(This,ppsi)	\
    ( (This)->lpVtbl -> GetParent(This,ppsi) ) 

#define IShellItem2_GetDisplayName(This,sigdnName,ppszName)	\
    ( (This)->lpVtbl -> GetDisplayName(This,sigdnName,ppszName) ) 

#define IShellItem2_GetAttributes(This,sfgaoMask,psfgaoAttribs)	\
    ( (This)->lpVtbl -> GetAttributes(This,sfgaoMask,psfgaoAttribs) ) 

#define IShellItem2_Compare(This,psi,hint,piOrder)	\
    ( (This)->lpVtbl -> Compare(This,psi,hint,piOrder) ) 


#define IShellItem2_GetPropertyStore(This,flags,riid,ppv)	\
    ( (This)->lpVtbl -> GetPropertyStore(This,flags,riid,ppv) ) 

#define IShellItem2_GetPropertyStoreWithCreateObject(This,flags,punkCreateObject,riid,ppv)	\
    ( (This)->lpVtbl -> GetPropertyStoreWithCreateObject(This,flags,punkCreateObject,riid,ppv) ) 

#define IShellItem2_GetPropertyStoreForKeys(This,rgKeys,cKeys,flags,riid,ppv)	\
    ( (This)->lpVtbl -> GetPropertyStoreForKeys(This,rgKeys,cKeys,flags,riid,ppv) ) 

#define IShellItem2_GetPropertyDescriptionList(This,keyType,riid,ppv)	\
    ( (This)->lpVtbl -> GetPropertyDescriptionList(This,keyType,riid,ppv) ) 

#define IShellItem2_Update(This,pbc)	\
    ( (This)->lpVtbl -> Update(This,pbc) ) 

#define IShellItem2_GetProperty(This,key,ppropvar)	\
    ( (This)->lpVtbl -> GetProperty(This,key,ppropvar) ) 

#define IShellItem2_GetCLSID(This,key,pclsid)	\
    ( (This)->lpVtbl -> GetCLSID(This,key,pclsid) ) 

#define IShellItem2_GetFileTime(This,key,pft)	\
    ( (This)->lpVtbl -> GetFileTime(This,key,pft) ) 

#define IShellItem2_GetInt32(This,key,pi)	\
    ( (This)->lpVtbl -> GetInt32(This,key,pi) ) 

#define IShellItem2_GetString(This,key,ppsz)	\
    ( (This)->lpVtbl -> GetString(This,key,ppsz) ) 

#define IShellItem2_GetUInt32(This,key,pui)	\
    ( (This)->lpVtbl -> GetUInt32(This,key,pui) ) 

#define IShellItem2_GetUInt64(This,key,pull)	\
    ( (This)->lpVtbl -> GetUInt64(This,key,pull) ) 

#define IShellItem2_GetBool(This,key,pf)	\
    ( (This)->lpVtbl -> GetBool(This,key,pf) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellItem2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0036 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum tagSIIGB
    {	SIIGBF_RESIZETOFIT	= 0,
	SIIGBF_BIGGERSIZEOK	= 0x1,
	SIIGBF_MEMORYONLY	= 0x2,
	SIIGBF_ICONONLY	= 0x4,
	SIIGBF_THUMBNAILONLY	= 0x8,
	SIIGBF_INCACHEONLY	= 0x10
    } 	SIIGB;

typedef int SIIGBF;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0036_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0036_v0_0_s_ifspec;

#ifndef __IShellItemImageFactory_INTERFACE_DEFINED__
#define __IShellItemImageFactory_INTERFACE_DEFINED__

/* interface IShellItemImageFactory */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IShellItemImageFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("bcc18b79-ba16-442f-80c4-8a59c30c463b")
    IShellItemImageFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetImage( 
            /* [in] */ SIZE size,
            /* [in] */ SIIGBF flags,
            /* [out] */ __RPC__deref_out_opt HBITMAP *phbm) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellItemImageFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellItemImageFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellItemImageFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellItemImageFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetImage )( 
            IShellItemImageFactory * This,
            /* [in] */ SIZE size,
            /* [in] */ SIIGBF flags,
            /* [out] */ __RPC__deref_out_opt HBITMAP *phbm);
        
        END_INTERFACE
    } IShellItemImageFactoryVtbl;

    interface IShellItemImageFactory
    {
        CONST_VTBL struct IShellItemImageFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellItemImageFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellItemImageFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellItemImageFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellItemImageFactory_GetImage(This,size,flags,phbm)	\
    ( (This)->lpVtbl -> GetImage(This,size,flags,phbm) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellItemImageFactory_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0037 */
/* [local] */ 

#if (NTDDI_VERSION >= NTDDI_WINXP)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0037_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0037_v0_0_s_ifspec;

#ifndef __IEnumShellItems_INTERFACE_DEFINED__
#define __IEnumShellItems_INTERFACE_DEFINED__

/* interface IEnumShellItems */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IEnumShellItems;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("70629033-e363-4a28-a567-0db78006e6d7")
    IEnumShellItems : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) IShellItem **rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumShellItems **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumShellItemsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumShellItems * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumShellItems * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumShellItems * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumShellItems * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) IShellItem **rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumShellItems * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumShellItems * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumShellItems * This,
            /* [out] */ __RPC__deref_out_opt IEnumShellItems **ppenum);
        
        END_INTERFACE
    } IEnumShellItemsVtbl;

    interface IEnumShellItems
    {
        CONST_VTBL struct IEnumShellItemsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumShellItems_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumShellItems_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumShellItems_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumShellItems_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumShellItems_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumShellItems_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumShellItems_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumShellItems_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0038 */
/* [local] */ 

typedef GUID STGTRANSCONFIRMATION;

typedef GUID *LPSTGTRANSCONFIRMATION;

typedef /* [v1_enum] */ 
enum tagSTGOP
    {	STGOP_MOVE	= 1,
	STGOP_COPY	= 2,
	STGOP_SYNC	= 3,
	STGOP_REMOVE	= 5,
	STGOP_RENAME	= 6,
	STGOP_APPLYPROPERTIES	= 8,
	STGOP_NEW	= 10
    } 	STGOP;

#endif  // NTDDI_WINXP
#if (_WIN32_IE >= _WIN32_IE_IE70)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0038_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0038_v0_0_s_ifspec;

#ifndef __ITransferAdviseSink_INTERFACE_DEFINED__
#define __ITransferAdviseSink_INTERFACE_DEFINED__

/* interface ITransferAdviseSink */
/* [object][local][unique][uuid] */ 

/* [v1_enum] */ 
enum tagTRANSFER_ADVISE_STATE
    {	TS_PERFORMING	= 0x1,
	TS_PREPARING	= 0x2,
	TS_INDETERMINATE	= 0x4
    } ;
typedef DWORD TRANSFER_ADVISE_STATE;


EXTERN_C const IID IID_ITransferAdviseSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d594d0d8-8da7-457b-b3b4-ce5dbaac0b88")
    ITransferAdviseSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE UpdateProgress( 
            /* [in] */ 
            __in  ULONGLONG ullSizeCurrent,
            /* [in] */ 
            __in  ULONGLONG ullSizeTotal,
            /* [in] */ 
            __in  int nFilesCurrent,
            /* [in] */ 
            __in  int nFilesTotal,
            /* [in] */ 
            __in  int nFoldersCurrent,
            /* [in] */ 
            __in  int nFoldersTotal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateTransferState( 
            /* [in] */ 
            __in  TRANSFER_ADVISE_STATE ts) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfirmOverwrite( 
            /* [in] */ 
            __in  IShellItem *psiSource,
            /* [in] */ 
            __in  IShellItem *psiDestParent,
            /* [string][in] */ 
            __in  LPCWSTR pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfirmEncryptionLoss( 
            /* [in] */ 
            __in  IShellItem *psiSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FileFailure( 
            /* [in] */ 
            __in  IShellItem *psi,
            /* [string][unique][in] */ 
            __in_opt  LPCWSTR pszItem,
            /* [in] */ 
            __in  HRESULT hrError,
            /* [size_is][unique][out] */ 
            __out_ecount_opt(cchRename)  LPWSTR pszRename,
            /* [in] */ 
            __in  ULONG cchRename) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SubStreamFailure( 
            /* [in] */ 
            __in  IShellItem *psi,
            /* [string][in] */ 
            __in  LPCWSTR pszStreamName,
            /* [in] */ 
            __in  HRESULT hrError) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PropertyFailure( 
            /* [in] */ 
            __in  IShellItem *psi,
            /* [unique][in] */ 
            __in_opt  const PROPERTYKEY *pkey,
            /* [in] */ 
            __in  HRESULT hrError) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransferAdviseSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransferAdviseSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransferAdviseSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransferAdviseSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateProgress )( 
            ITransferAdviseSink * This,
            /* [in] */ 
            __in  ULONGLONG ullSizeCurrent,
            /* [in] */ 
            __in  ULONGLONG ullSizeTotal,
            /* [in] */ 
            __in  int nFilesCurrent,
            /* [in] */ 
            __in  int nFilesTotal,
            /* [in] */ 
            __in  int nFoldersCurrent,
            /* [in] */ 
            __in  int nFoldersTotal);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateTransferState )( 
            ITransferAdviseSink * This,
            /* [in] */ 
            __in  TRANSFER_ADVISE_STATE ts);
        
        HRESULT ( STDMETHODCALLTYPE *ConfirmOverwrite )( 
            ITransferAdviseSink * This,
            /* [in] */ 
            __in  IShellItem *psiSource,
            /* [in] */ 
            __in  IShellItem *psiDestParent,
            /* [string][in] */ 
            __in  LPCWSTR pszName);
        
        HRESULT ( STDMETHODCALLTYPE *ConfirmEncryptionLoss )( 
            ITransferAdviseSink * This,
            /* [in] */ 
            __in  IShellItem *psiSource);
        
        HRESULT ( STDMETHODCALLTYPE *FileFailure )( 
            ITransferAdviseSink * This,
            /* [in] */ 
            __in  IShellItem *psi,
            /* [string][unique][in] */ 
            __in_opt  LPCWSTR pszItem,
            /* [in] */ 
            __in  HRESULT hrError,
            /* [size_is][unique][out] */ 
            __out_ecount_opt(cchRename)  LPWSTR pszRename,
            /* [in] */ 
            __in  ULONG cchRename);
        
        HRESULT ( STDMETHODCALLTYPE *SubStreamFailure )( 
            ITransferAdviseSink * This,
            /* [in] */ 
            __in  IShellItem *psi,
            /* [string][in] */ 
            __in  LPCWSTR pszStreamName,
            /* [in] */ 
            __in  HRESULT hrError);
        
        HRESULT ( STDMETHODCALLTYPE *PropertyFailure )( 
            ITransferAdviseSink * This,
            /* [in] */ 
            __in  IShellItem *psi,
            /* [unique][in] */ 
            __in_opt  const PROPERTYKEY *pkey,
            /* [in] */ 
            __in  HRESULT hrError);
        
        END_INTERFACE
    } ITransferAdviseSinkVtbl;

    interface ITransferAdviseSink
    {
        CONST_VTBL struct ITransferAdviseSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransferAdviseSink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITransferAdviseSink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITransferAdviseSink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITransferAdviseSink_UpdateProgress(This,ullSizeCurrent,ullSizeTotal,nFilesCurrent,nFilesTotal,nFoldersCurrent,nFoldersTotal)	\
    ( (This)->lpVtbl -> UpdateProgress(This,ullSizeCurrent,ullSizeTotal,nFilesCurrent,nFilesTotal,nFoldersCurrent,nFoldersTotal) ) 

#define ITransferAdviseSink_UpdateTransferState(This,ts)	\
    ( (This)->lpVtbl -> UpdateTransferState(This,ts) ) 

#define ITransferAdviseSink_ConfirmOverwrite(This,psiSource,psiDestParent,pszName)	\
    ( (This)->lpVtbl -> ConfirmOverwrite(This,psiSource,psiDestParent,pszName) ) 

#define ITransferAdviseSink_ConfirmEncryptionLoss(This,psiSource)	\
    ( (This)->lpVtbl -> ConfirmEncryptionLoss(This,psiSource) ) 

#define ITransferAdviseSink_FileFailure(This,psi,pszItem,hrError,pszRename,cchRename)	\
    ( (This)->lpVtbl -> FileFailure(This,psi,pszItem,hrError,pszRename,cchRename) ) 

#define ITransferAdviseSink_SubStreamFailure(This,psi,pszStreamName,hrError)	\
    ( (This)->lpVtbl -> SubStreamFailure(This,psi,pszStreamName,hrError) ) 

#define ITransferAdviseSink_PropertyFailure(This,psi,pkey,hrError)	\
    ( (This)->lpVtbl -> PropertyFailure(This,psi,pkey,hrError) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITransferAdviseSink_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0039 */
/* [local] */ 

#define TSF_NORMAL                      0x0000
#define TSF_FAIL_EXIST                  0x0000      // Fail if destination already exists
#define TSF_RENAME_EXIST                0x0001      // Rename with auto-name generation if destination already exists
#define TSF_OVERWRITE_EXIST             0x0002      // Overwrite/Merge with destination
#define TSF_ALLOW_DECRYPTION            0x0004      // Allow creation of decrypted destination
#define TSF_NO_SECURITY                 0x0008      // Without DACL/SACL/Owner
#define TSF_COPY_CREATION_TIME          0x0010      // Copy the creation time as part of the copy (useful for move as copy/delete)
#define TSF_COPY_WRITE_TIME             0x0020      // Copy the last write time as part of the copy
#define TSF_USE_FULL_ACCESS             0x0040      // Open a file with write, read, or delete as share mode
#define TSF_DELETE_RECYCLE_IF_POSSIBLE  0x0080      // Recycle if possible
#define TSF_COPY_HARD_LINK              0x0100      // Hard link desired (not required)
#define TSF_COPY_LOCALIZED_NAME         0x0200      // Copy localized name
#define TSF_MOVE_AS_COPY_DELETE         0x0400      // We are doing a move operation, but we are doing it as a copy/delete
#define TSF_SUSPEND_SHELLEVENTS         0x0800      // suspend shell events
#endif  // (_WIN32_IE >= _WIN32_IE_IE70)
#if (NTDDI_VERSION >= NTDDI_VISTA)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0039_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0039_v0_0_s_ifspec;

#ifndef __ITransferSource_INTERFACE_DEFINED__
#define __ITransferSource_INTERFACE_DEFINED__

/* interface ITransferSource */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_ITransferSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00adb003-bde9-45c6-8e29-d09f9353e108")
    ITransferSource : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Advise( 
            /* [in] */ 
            __in  ITransferAdviseSink *psink,
            /* [out] */ 
            __out  DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unadvise( 
            /* [in] */ 
            __in  DWORD dwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProperties( 
            /* [in] */ 
            __in  IPropertyChangeArray *pproparray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenItem( 
            /* [in] */ 
            __in  IShellItem *psi,
            /* [in] */ 
            __in  DWORD dwFlags,
            /* [in] */ 
            __in  REFIID riid,
            /* [iid_is][out] */ 
            __deref_out  void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MoveItem( 
            /* [in] */ 
            __in  IShellItem *psi,
            /* [in] */ 
            __in  IShellItem *psiParentDst,
            /* [string][in] */ 
            __in  LPCWSTR pszNameDst,
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __deref_out  IShellItem **ppsiNew) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RecycleItem( 
            /* [in] */ 
            __in  IShellItem *psiSource,
            /* [in] */ 
            __in  IShellItem *psiParentDest,
            /* [in] */ 
            __in  DWORD dwFlags,
            /* [out] */ 
            __deref_out  IShellItem **ppsiNewDest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveItem( 
            /* [in] */ 
            __in  IShellItem *psiSource,
            /* [in] */ 
            __in  DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RenameItem( 
            /* [in] */ 
            __in  IShellItem *psiSource,
            /* [string][in] */ 
            __in  LPCWSTR pszNewName,
            /* [in] */ 
            __in  DWORD dwFlags,
            /* [out] */ 
            __deref_out  IShellItem **ppsiNewDest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LinkItem( 
            /* [in] */ 
            __in  IShellItem *psiSource,
            /* [in] */ 
            __in  IShellItem *psiParentDest,
            /* [string][unique][in] */ 
            __in_opt  LPCWSTR pszNewName,
            /* [in] */ 
            __in  DWORD dwLinkFlags,
            /* [out] */ 
            __deref_out  IShellItem **ppsiNewDest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ApplyPropertiesToItem( 
            /* [in] */ 
            __in  IShellItem *psiSource,
            /* [out] */ 
            __deref_out  IShellItem **ppsiNew) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultDestinationName( 
            /* [in] */ 
            __in  IShellItem *psiSource,
            /* [in] */ 
            __in  IShellItem *psiParentDest,
            /* [string][out] */ 
            __deref_out  LPWSTR *ppszDestinationName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnterFolder( 
            /* [in] */ 
            __in  IShellItem *psiChildFolderDest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LeaveFolder( 
            /* [in] */ 
            __in  IShellItem *psiChildFolderDest) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransferSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransferSource * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransferSource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransferSource * This);
        
        HRESULT ( STDMETHODCALLTYPE *Advise )( 
            ITransferSource * This,
            /* [in] */ 
            __in  ITransferAdviseSink *psink,
            /* [out] */ 
            __out  DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *Unadvise )( 
            ITransferSource * This,
            /* [in] */ 
            __in  DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperties )( 
            ITransferSource * This,
            /* [in] */ 
            __in  IPropertyChangeArray *pproparray);
        
        HRESULT ( STDMETHODCALLTYPE *OpenItem )( 
            ITransferSource * This,
            /* [in] */ 
            __in  IShellItem *psi,
            /* [in] */ 
            __in  DWORD dwFlags,
            /* [in] */ 
            __in  REFIID riid,
            /* [iid_is][out] */ 
            __deref_out  void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *MoveItem )( 
            ITransferSource * This,
            /* [in] */ 
            __in  IShellItem *psi,
            /* [in] */ 
            __in  IShellItem *psiParentDst,
            /* [string][in] */ 
            __in  LPCWSTR pszNameDst,
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __deref_out  IShellItem **ppsiNew);
        
        HRESULT ( STDMETHODCALLTYPE *RecycleItem )( 
            ITransferSource * This,
            /* [in] */ 
            __in  IShellItem *psiSource,
            /* [in] */ 
            __in  IShellItem *psiParentDest,
            /* [in] */ 
            __in  DWORD dwFlags,
            /* [out] */ 
            __deref_out  IShellItem **ppsiNewDest);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveItem )( 
            ITransferSource * This,
            /* [in] */ 
            __in  IShellItem *psiSource,
            /* [in] */ 
            __in  DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *RenameItem )( 
            ITransferSource * This,
            /* [in] */ 
            __in  IShellItem *psiSource,
            /* [string][in] */ 
            __in  LPCWSTR pszNewName,
            /* [in] */ 
            __in  DWORD dwFlags,
            /* [out] */ 
            __deref_out  IShellItem **ppsiNewDest);
        
        HRESULT ( STDMETHODCALLTYPE *LinkItem )( 
            ITransferSource * This,
            /* [in] */ 
            __in  IShellItem *psiSource,
            /* [in] */ 
            __in  IShellItem *psiParentDest,
            /* [string][unique][in] */ 
            __in_opt  LPCWSTR pszNewName,
            /* [in] */ 
            __in  DWORD dwLinkFlags,
            /* [out] */ 
            __deref_out  IShellItem **ppsiNewDest);
        
        HRESULT ( STDMETHODCALLTYPE *ApplyPropertiesToItem )( 
            ITransferSource * This,
            /* [in] */ 
            __in  IShellItem *psiSource,
            /* [out] */ 
            __deref_out  IShellItem **ppsiNew);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultDestinationName )( 
            ITransferSource * This,
            /* [in] */ 
            __in  IShellItem *psiSource,
            /* [in] */ 
            __in  IShellItem *psiParentDest,
            /* [string][out] */ 
            __deref_out  LPWSTR *ppszDestinationName);
        
        HRESULT ( STDMETHODCALLTYPE *EnterFolder )( 
            ITransferSource * This,
            /* [in] */ 
            __in  IShellItem *psiChildFolderDest);
        
        HRESULT ( STDMETHODCALLTYPE *LeaveFolder )( 
            ITransferSource * This,
            /* [in] */ 
            __in  IShellItem *psiChildFolderDest);
        
        END_INTERFACE
    } ITransferSourceVtbl;

    interface ITransferSource
    {
        CONST_VTBL struct ITransferSourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransferSource_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITransferSource_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITransferSource_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITransferSource_Advise(This,psink,pdwCookie)	\
    ( (This)->lpVtbl -> Advise(This,psink,pdwCookie) ) 

#define ITransferSource_Unadvise(This,dwCookie)	\
    ( (This)->lpVtbl -> Unadvise(This,dwCookie) ) 

#define ITransferSource_SetProperties(This,pproparray)	\
    ( (This)->lpVtbl -> SetProperties(This,pproparray) ) 

#define ITransferSource_OpenItem(This,psi,dwFlags,riid,ppv)	\
    ( (This)->lpVtbl -> OpenItem(This,psi,dwFlags,riid,ppv) ) 

#define ITransferSource_MoveItem(This,psi,psiParentDst,pszNameDst,dwFlags,ppsiNew)	\
    ( (This)->lpVtbl -> MoveItem(This,psi,psiParentDst,pszNameDst,dwFlags,ppsiNew) ) 

#define ITransferSource_RecycleItem(This,psiSource,psiParentDest,dwFlags,ppsiNewDest)	\
    ( (This)->lpVtbl -> RecycleItem(This,psiSource,psiParentDest,dwFlags,ppsiNewDest) ) 

#define ITransferSource_RemoveItem(This,psiSource,dwFlags)	\
    ( (This)->lpVtbl -> RemoveItem(This,psiSource,dwFlags) ) 

#define ITransferSource_RenameItem(This,psiSource,pszNewName,dwFlags,ppsiNewDest)	\
    ( (This)->lpVtbl -> RenameItem(This,psiSource,pszNewName,dwFlags,ppsiNewDest) ) 

#define ITransferSource_LinkItem(This,psiSource,psiParentDest,pszNewName,dwLinkFlags,ppsiNewDest)	\
    ( (This)->lpVtbl -> LinkItem(This,psiSource,psiParentDest,pszNewName,dwLinkFlags,ppsiNewDest) ) 

#define ITransferSource_ApplyPropertiesToItem(This,psiSource,ppsiNew)	\
    ( (This)->lpVtbl -> ApplyPropertiesToItem(This,psiSource,ppsiNew) ) 

#define ITransferSource_GetDefaultDestinationName(This,psiSource,psiParentDest,ppszDestinationName)	\
    ( (This)->lpVtbl -> GetDefaultDestinationName(This,psiSource,psiParentDest,ppszDestinationName) ) 

#define ITransferSource_EnterFolder(This,psiChildFolderDest)	\
    ( (This)->lpVtbl -> EnterFolder(This,psiChildFolderDest) ) 

#define ITransferSource_LeaveFolder(This,psiChildFolderDest)	\
    ( (This)->lpVtbl -> LeaveFolder(This,psiChildFolderDest) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITransferSource_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0040 */
/* [local] */ 

#endif  // NTDDI_VISTA
typedef struct _shell_item_resource_
    {
    GUID guidType;
    WCHAR szName[ 260 ];
    } 	SHELL_ITEM_RESOURCE;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0040_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0040_v0_0_s_ifspec;

#ifndef __IEnumResources_INTERFACE_DEFINED__
#define __IEnumResources_INTERFACE_DEFINED__

/* interface IEnumResources */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumResources;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2dd81fe3-a83c-4da9-a330-47249d345ba1")
    IEnumResources : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [size_is][out] */ __RPC__out_ecount_full(celt) SHELL_ITEM_RESOURCE *psir,
            /* [out] */ __RPC__out ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumResources **ppenumr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumResourcesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumResources * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumResources * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumResources * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumResources * This,
            /* [in] */ ULONG celt,
            /* [size_is][out] */ __RPC__out_ecount_full(celt) SHELL_ITEM_RESOURCE *psir,
            /* [out] */ __RPC__out ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumResources * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumResources * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumResources * This,
            /* [out] */ __RPC__deref_out_opt IEnumResources **ppenumr);
        
        END_INTERFACE
    } IEnumResourcesVtbl;

    interface IEnumResources
    {
        CONST_VTBL struct IEnumResourcesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumResources_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumResources_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumResources_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumResources_Next(This,celt,psir,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,psir,pceltFetched) ) 

#define IEnumResources_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumResources_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumResources_Clone(This,ppenumr)	\
    ( (This)->lpVtbl -> Clone(This,ppenumr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumResources_INTERFACE_DEFINED__ */


#ifndef __IShellItemResources_INTERFACE_DEFINED__
#define __IShellItemResources_INTERFACE_DEFINED__

/* interface IShellItemResources */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IShellItemResources;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ff5693be-2ce0-4d48-b5c5-40817d1acdb9")
    IShellItemResources : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAttributes( 
            /* [out] */ __RPC__out DWORD *pdwAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSize( 
            /* [out] */ __RPC__out ULONGLONG *pullSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTimes( 
            /* [out] */ __RPC__out FILETIME *pftCreation,
            /* [out] */ __RPC__out FILETIME *pftWrite,
            /* [out] */ __RPC__out FILETIME *pftAccess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTimes( 
            /* [in] */ __RPC__in const FILETIME *pftCreation,
            /* [in] */ __RPC__in const FILETIME *pftWrite,
            /* [in] */ __RPC__in const FILETIME *pftAccess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResourceDescription( 
            /* [in] */ __RPC__in const SHELL_ITEM_RESOURCE *pcsir,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumResources( 
            /* [out] */ __RPC__deref_out_opt IEnumResources **ppenumr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SupportsResource( 
            /* [in] */ __RPC__in const SHELL_ITEM_RESOURCE *pcsir) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenResource( 
            /* [in] */ __RPC__in const SHELL_ITEM_RESOURCE *pcsir,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateResource( 
            /* [in] */ __RPC__in const SHELL_ITEM_RESOURCE *pcsir,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MarkForDelete( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellItemResourcesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellItemResources * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellItemResources * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellItemResources * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributes )( 
            IShellItemResources * This,
            /* [out] */ __RPC__out DWORD *pdwAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            IShellItemResources * This,
            /* [out] */ __RPC__out ULONGLONG *pullSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetTimes )( 
            IShellItemResources * This,
            /* [out] */ __RPC__out FILETIME *pftCreation,
            /* [out] */ __RPC__out FILETIME *pftWrite,
            /* [out] */ __RPC__out FILETIME *pftAccess);
        
        HRESULT ( STDMETHODCALLTYPE *SetTimes )( 
            IShellItemResources * This,
            /* [in] */ __RPC__in const FILETIME *pftCreation,
            /* [in] */ __RPC__in const FILETIME *pftWrite,
            /* [in] */ __RPC__in const FILETIME *pftAccess);
        
        HRESULT ( STDMETHODCALLTYPE *GetResourceDescription )( 
            IShellItemResources * This,
            /* [in] */ __RPC__in const SHELL_ITEM_RESOURCE *pcsir,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDescription);
        
        HRESULT ( STDMETHODCALLTYPE *EnumResources )( 
            IShellItemResources * This,
            /* [out] */ __RPC__deref_out_opt IEnumResources **ppenumr);
        
        HRESULT ( STDMETHODCALLTYPE *SupportsResource )( 
            IShellItemResources * This,
            /* [in] */ __RPC__in const SHELL_ITEM_RESOURCE *pcsir);
        
        HRESULT ( STDMETHODCALLTYPE *OpenResource )( 
            IShellItemResources * This,
            /* [in] */ __RPC__in const SHELL_ITEM_RESOURCE *pcsir,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *CreateResource )( 
            IShellItemResources * This,
            /* [in] */ __RPC__in const SHELL_ITEM_RESOURCE *pcsir,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *MarkForDelete )( 
            IShellItemResources * This);
        
        END_INTERFACE
    } IShellItemResourcesVtbl;

    interface IShellItemResources
    {
        CONST_VTBL struct IShellItemResourcesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellItemResources_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellItemResources_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellItemResources_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellItemResources_GetAttributes(This,pdwAttributes)	\
    ( (This)->lpVtbl -> GetAttributes(This,pdwAttributes) ) 

#define IShellItemResources_GetSize(This,pullSize)	\
    ( (This)->lpVtbl -> GetSize(This,pullSize) ) 

#define IShellItemResources_GetTimes(This,pftCreation,pftWrite,pftAccess)	\
    ( (This)->lpVtbl -> GetTimes(This,pftCreation,pftWrite,pftAccess) ) 

#define IShellItemResources_SetTimes(This,pftCreation,pftWrite,pftAccess)	\
    ( (This)->lpVtbl -> SetTimes(This,pftCreation,pftWrite,pftAccess) ) 

#define IShellItemResources_GetResourceDescription(This,pcsir,ppszDescription)	\
    ( (This)->lpVtbl -> GetResourceDescription(This,pcsir,ppszDescription) ) 

#define IShellItemResources_EnumResources(This,ppenumr)	\
    ( (This)->lpVtbl -> EnumResources(This,ppenumr) ) 

#define IShellItemResources_SupportsResource(This,pcsir)	\
    ( (This)->lpVtbl -> SupportsResource(This,pcsir) ) 

#define IShellItemResources_OpenResource(This,pcsir,riid,ppv)	\
    ( (This)->lpVtbl -> OpenResource(This,pcsir,riid,ppv) ) 

#define IShellItemResources_CreateResource(This,pcsir,riid,ppv)	\
    ( (This)->lpVtbl -> CreateResource(This,pcsir,riid,ppv) ) 

#define IShellItemResources_MarkForDelete(This)	\
    ( (This)->lpVtbl -> MarkForDelete(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellItemResources_INTERFACE_DEFINED__ */


#ifndef __ITransferDestination_INTERFACE_DEFINED__
#define __ITransferDestination_INTERFACE_DEFINED__

/* interface ITransferDestination */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_ITransferDestination;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("48addd32-3ca5-4124-abe3-b5a72531b207")
    ITransferDestination : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Advise( 
            /* [in] */ 
            __in  ITransferAdviseSink *psink,
            /* [out] */ 
            __out  DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unadvise( 
            /* [in] */ DWORD dwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateItem( 
            /* [string][in] */ 
            __in  LPCWSTR pszName,
            /* [in] */ 
            __in  DWORD dwAttributes,
            /* [in] */ 
            __in  ULONGLONG ullSize,
            /* [in] */ 
            __in  DWORD dwFlags,
            /* [in] */ 
            __in  REFIID riidItem,
            /* [iid_is][out] */ 
            __deref_out  void **ppvItem,
            /* [in] */ 
            __in  REFIID riidResources,
            /* [iid_is][out] */ 
            __deref_out  void **ppvResources) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransferDestinationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransferDestination * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransferDestination * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransferDestination * This);
        
        HRESULT ( STDMETHODCALLTYPE *Advise )( 
            ITransferDestination * This,
            /* [in] */ 
            __in  ITransferAdviseSink *psink,
            /* [out] */ 
            __out  DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *Unadvise )( 
            ITransferDestination * This,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *CreateItem )( 
            ITransferDestination * This,
            /* [string][in] */ 
            __in  LPCWSTR pszName,
            /* [in] */ 
            __in  DWORD dwAttributes,
            /* [in] */ 
            __in  ULONGLONG ullSize,
            /* [in] */ 
            __in  DWORD dwFlags,
            /* [in] */ 
            __in  REFIID riidItem,
            /* [iid_is][out] */ 
            __deref_out  void **ppvItem,
            /* [in] */ 
            __in  REFIID riidResources,
            /* [iid_is][out] */ 
            __deref_out  void **ppvResources);
        
        END_INTERFACE
    } ITransferDestinationVtbl;

    interface ITransferDestination
    {
        CONST_VTBL struct ITransferDestinationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransferDestination_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITransferDestination_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITransferDestination_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITransferDestination_Advise(This,psink,pdwCookie)	\
    ( (This)->lpVtbl -> Advise(This,psink,pdwCookie) ) 

#define ITransferDestination_Unadvise(This,dwCookie)	\
    ( (This)->lpVtbl -> Unadvise(This,dwCookie) ) 

#define ITransferDestination_CreateItem(This,pszName,dwAttributes,ullSize,dwFlags,riidItem,ppvItem,riidResources,ppvResources)	\
    ( (This)->lpVtbl -> CreateItem(This,pszName,dwAttributes,ullSize,dwFlags,riidItem,ppvItem,riidResources,ppvResources) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITransferDestination_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0043 */
/* [local] */ 

#ifdef MIDL_PASS
typedef struct _OVERLAPPED
    {
    ULONG_PTR Internal;
    ULONG_PTR InternalHigh;
    union 
        {
        struct 
            {
            DWORD Offset;
            DWORD OffsetHigh;
            } 	;
        PVOID Pointer;
        } 	;
    HANDLE hEvent;
    } 	OVERLAPPED;

typedef struct _OVERLAPPED *LPOVERLAPPED;

#endif // MIDL_PASS


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0043_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0043_v0_0_s_ifspec;

#ifndef __IStreamAsync_INTERFACE_DEFINED__
#define __IStreamAsync_INTERFACE_DEFINED__

/* interface IStreamAsync */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IStreamAsync;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fe0b6665-e0ca-49b9-a178-2b5cb48d92a5")
    IStreamAsync : public IStream
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ReadAsync( 
            /* [length_is][size_is][out] */ 
            __in_bcount(cb)  void *pv,
            /* [in] */ DWORD cb,
            /* [out] */ 
            __out  LPDWORD pcbRead,
            /* [in] */ 
            __in  LPOVERLAPPED lpOverlapped) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteAsync( 
            /* [length_is][size_is][in] */ 
            __in_bcount(cb)  const void *lpBuffer,
            /* [in] */ DWORD cb,
            /* [out] */ 
            __out  LPDWORD pcbWritten,
            /* [in] */ 
            __in  LPOVERLAPPED lpOverlapped) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OverlappedResult( 
            /* [in] */ 
            __in  LPOVERLAPPED lpOverlapped,
            /* [out] */ 
            __out  LPDWORD lpNumberOfBytesTransferred,
            /* [in] */ 
            __in  BOOL bWait) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelIo( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStreamAsyncVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IStreamAsync * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IStreamAsync * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IStreamAsync * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Read )( 
            IStreamAsync * This,
            /* [length_is][size_is][out] */ void *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG *pcbRead);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Write )( 
            IStreamAsync * This,
            /* [size_is][in] */ const void *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG *pcbWritten);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Seek )( 
            IStreamAsync * This,
            /* [in] */ LARGE_INTEGER dlibMove,
            /* [in] */ DWORD dwOrigin,
            /* [out] */ ULARGE_INTEGER *plibNewPosition);
        
        HRESULT ( STDMETHODCALLTYPE *SetSize )( 
            IStreamAsync * This,
            /* [in] */ ULARGE_INTEGER libNewSize);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CopyTo )( 
            IStreamAsync * This,
            /* [unique][in] */ IStream *pstm,
            /* [in] */ ULARGE_INTEGER cb,
            /* [out] */ ULARGE_INTEGER *pcbRead,
            /* [out] */ ULARGE_INTEGER *pcbWritten);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IStreamAsync * This,
            /* [in] */ DWORD grfCommitFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Revert )( 
            IStreamAsync * This);
        
        HRESULT ( STDMETHODCALLTYPE *LockRegion )( 
            IStreamAsync * This,
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockRegion )( 
            IStreamAsync * This,
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
        
        HRESULT ( STDMETHODCALLTYPE *Stat )( 
            IStreamAsync * This,
            /* [out] */ STATSTG *pstatstg,
            /* [in] */ DWORD grfStatFlag);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IStreamAsync * This,
            /* [out] */ IStream **ppstm);
        
        HRESULT ( STDMETHODCALLTYPE *ReadAsync )( 
            IStreamAsync * This,
            /* [length_is][size_is][out] */ 
            __in_bcount(cb)  void *pv,
            /* [in] */ DWORD cb,
            /* [out] */ 
            __out  LPDWORD pcbRead,
            /* [in] */ 
            __in  LPOVERLAPPED lpOverlapped);
        
        HRESULT ( STDMETHODCALLTYPE *WriteAsync )( 
            IStreamAsync * This,
            /* [length_is][size_is][in] */ 
            __in_bcount(cb)  const void *lpBuffer,
            /* [in] */ DWORD cb,
            /* [out] */ 
            __out  LPDWORD pcbWritten,
            /* [in] */ 
            __in  LPOVERLAPPED lpOverlapped);
        
        HRESULT ( STDMETHODCALLTYPE *OverlappedResult )( 
            IStreamAsync * This,
            /* [in] */ 
            __in  LPOVERLAPPED lpOverlapped,
            /* [out] */ 
            __out  LPDWORD lpNumberOfBytesTransferred,
            /* [in] */ 
            __in  BOOL bWait);
        
        HRESULT ( STDMETHODCALLTYPE *CancelIo )( 
            IStreamAsync * This);
        
        END_INTERFACE
    } IStreamAsyncVtbl;

    interface IStreamAsync
    {
        CONST_VTBL struct IStreamAsyncVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStreamAsync_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IStreamAsync_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IStreamAsync_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IStreamAsync_Read(This,pv,cb,pcbRead)	\
    ( (This)->lpVtbl -> Read(This,pv,cb,pcbRead) ) 

#define IStreamAsync_Write(This,pv,cb,pcbWritten)	\
    ( (This)->lpVtbl -> Write(This,pv,cb,pcbWritten) ) 


#define IStreamAsync_Seek(This,dlibMove,dwOrigin,plibNewPosition)	\
    ( (This)->lpVtbl -> Seek(This,dlibMove,dwOrigin,plibNewPosition) ) 

#define IStreamAsync_SetSize(This,libNewSize)	\
    ( (This)->lpVtbl -> SetSize(This,libNewSize) ) 

#define IStreamAsync_CopyTo(This,pstm,cb,pcbRead,pcbWritten)	\
    ( (This)->lpVtbl -> CopyTo(This,pstm,cb,pcbRead,pcbWritten) ) 

#define IStreamAsync_Commit(This,grfCommitFlags)	\
    ( (This)->lpVtbl -> Commit(This,grfCommitFlags) ) 

#define IStreamAsync_Revert(This)	\
    ( (This)->lpVtbl -> Revert(This) ) 

#define IStreamAsync_LockRegion(This,libOffset,cb,dwLockType)	\
    ( (This)->lpVtbl -> LockRegion(This,libOffset,cb,dwLockType) ) 

#define IStreamAsync_UnlockRegion(This,libOffset,cb,dwLockType)	\
    ( (This)->lpVtbl -> UnlockRegion(This,libOffset,cb,dwLockType) ) 

#define IStreamAsync_Stat(This,pstatstg,grfStatFlag)	\
    ( (This)->lpVtbl -> Stat(This,pstatstg,grfStatFlag) ) 

#define IStreamAsync_Clone(This,ppstm)	\
    ( (This)->lpVtbl -> Clone(This,ppstm) ) 


#define IStreamAsync_ReadAsync(This,pv,cb,pcbRead,lpOverlapped)	\
    ( (This)->lpVtbl -> ReadAsync(This,pv,cb,pcbRead,lpOverlapped) ) 

#define IStreamAsync_WriteAsync(This,lpBuffer,cb,pcbWritten,lpOverlapped)	\
    ( (This)->lpVtbl -> WriteAsync(This,lpBuffer,cb,pcbWritten,lpOverlapped) ) 

#define IStreamAsync_OverlappedResult(This,lpOverlapped,lpNumberOfBytesTransferred,bWait)	\
    ( (This)->lpVtbl -> OverlappedResult(This,lpOverlapped,lpNumberOfBytesTransferred,bWait) ) 

#define IStreamAsync_CancelIo(This)	\
    ( (This)->lpVtbl -> CancelIo(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IStreamAsync_INTERFACE_DEFINED__ */


#ifndef __IStreamUnbufferedInfo_INTERFACE_DEFINED__
#define __IStreamUnbufferedInfo_INTERFACE_DEFINED__

/* interface IStreamUnbufferedInfo */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IStreamUnbufferedInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8a68fdda-1fdc-4c20-8ceb-416643b5a625")
    IStreamUnbufferedInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSectorSize( 
            /* [out] */ 
            __out  ULONG *pcbSectorSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStreamUnbufferedInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IStreamUnbufferedInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IStreamUnbufferedInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IStreamUnbufferedInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSectorSize )( 
            IStreamUnbufferedInfo * This,
            /* [out] */ 
            __out  ULONG *pcbSectorSize);
        
        END_INTERFACE
    } IStreamUnbufferedInfoVtbl;

    interface IStreamUnbufferedInfo
    {
        CONST_VTBL struct IStreamUnbufferedInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStreamUnbufferedInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IStreamUnbufferedInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IStreamUnbufferedInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IStreamUnbufferedInfo_GetSectorSize(This,pcbSectorSize)	\
    ( (This)->lpVtbl -> GetSectorSize(This,pcbSectorSize) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IStreamUnbufferedInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0045 */
/* [local] */ 

#if (_WIN32_IE >= _WIN32_IE_IE70)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0045_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0045_v0_0_s_ifspec;

#ifndef __IFileOperationProgressSink_INTERFACE_DEFINED__
#define __IFileOperationProgressSink_INTERFACE_DEFINED__

/* interface IFileOperationProgressSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IFileOperationProgressSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("04b0f1a7-9490-44bc-96e1-4296a31252e2")
    IFileOperationProgressSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StartOperations( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FinishOperations( 
            /* [in] */ HRESULT hrResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PreRenameItem( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IShellItem *psiItem,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszNewName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PostRenameItem( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IShellItem *psiItem,
            /* [string][in] */ __RPC__in LPCWSTR pszNewName,
            /* [in] */ HRESULT hrRename,
            /* [in] */ __RPC__in_opt IShellItem *psiNewlyCreated) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PreMoveItem( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IShellItem *psiItem,
            /* [in] */ __RPC__in_opt IShellItem *psiDestinationFolder,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszNewName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PostMoveItem( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IShellItem *psiItem,
            /* [in] */ __RPC__in_opt IShellItem *psiDestinationFolder,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszNewName,
            /* [in] */ HRESULT hrMove,
            /* [in] */ __RPC__in_opt IShellItem *psiNewlyCreated) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PreCopyItem( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IShellItem *psiItem,
            /* [in] */ __RPC__in_opt IShellItem *psiDestinationFolder,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszNewName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PostCopyItem( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IShellItem *psiItem,
            /* [in] */ __RPC__in_opt IShellItem *psiDestinationFolder,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszNewName,
            /* [in] */ HRESULT hrCopy,
            /* [in] */ __RPC__in_opt IShellItem *psiNewlyCreated) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PreDeleteItem( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IShellItem *psiItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PostDeleteItem( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IShellItem *psiItem,
            /* [in] */ HRESULT hrDelete,
            /* [in] */ __RPC__in_opt IShellItem *psiNewlyCreated) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PreNewItem( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IShellItem *psiDestinationFolder,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszNewName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PostNewItem( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IShellItem *psiDestinationFolder,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszNewName,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszTemplateName,
            /* [in] */ DWORD dwFileAttributes,
            /* [in] */ HRESULT hrNew,
            /* [in] */ __RPC__in_opt IShellItem *psiNewItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateProgress( 
            /* [in] */ UINT iWorkTotal,
            /* [in] */ UINT iWorkSoFar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetTimer( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PauseTimer( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResumeTimer( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFileOperationProgressSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFileOperationProgressSink * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFileOperationProgressSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFileOperationProgressSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartOperations )( 
            IFileOperationProgressSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *FinishOperations )( 
            IFileOperationProgressSink * This,
            /* [in] */ HRESULT hrResult);
        
        HRESULT ( STDMETHODCALLTYPE *PreRenameItem )( 
            IFileOperationProgressSink * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IShellItem *psiItem,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszNewName);
        
        HRESULT ( STDMETHODCALLTYPE *PostRenameItem )( 
            IFileOperationProgressSink * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IShellItem *psiItem,
            /* [string][in] */ __RPC__in LPCWSTR pszNewName,
            /* [in] */ HRESULT hrRename,
            /* [in] */ __RPC__in_opt IShellItem *psiNewlyCreated);
        
        HRESULT ( STDMETHODCALLTYPE *PreMoveItem )( 
            IFileOperationProgressSink * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IShellItem *psiItem,
            /* [in] */ __RPC__in_opt IShellItem *psiDestinationFolder,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszNewName);
        
        HRESULT ( STDMETHODCALLTYPE *PostMoveItem )( 
            IFileOperationProgressSink * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IShellItem *psiItem,
            /* [in] */ __RPC__in_opt IShellItem *psiDestinationFolder,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszNewName,
            /* [in] */ HRESULT hrMove,
            /* [in] */ __RPC__in_opt IShellItem *psiNewlyCreated);
        
        HRESULT ( STDMETHODCALLTYPE *PreCopyItem )( 
            IFileOperationProgressSink * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IShellItem *psiItem,
            /* [in] */ __RPC__in_opt IShellItem *psiDestinationFolder,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszNewName);
        
        HRESULT ( STDMETHODCALLTYPE *PostCopyItem )( 
            IFileOperationProgressSink * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IShellItem *psiItem,
            /* [in] */ __RPC__in_opt IShellItem *psiDestinationFolder,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszNewName,
            /* [in] */ HRESULT hrCopy,
            /* [in] */ __RPC__in_opt IShellItem *psiNewlyCreated);
        
        HRESULT ( STDMETHODCALLTYPE *PreDeleteItem )( 
            IFileOperationProgressSink * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IShellItem *psiItem);
        
        HRESULT ( STDMETHODCALLTYPE *PostDeleteItem )( 
            IFileOperationProgressSink * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IShellItem *psiItem,
            /* [in] */ HRESULT hrDelete,
            /* [in] */ __RPC__in_opt IShellItem *psiNewlyCreated);
        
        HRESULT ( STDMETHODCALLTYPE *PreNewItem )( 
            IFileOperationProgressSink * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IShellItem *psiDestinationFolder,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszNewName);
        
        HRESULT ( STDMETHODCALLTYPE *PostNewItem )( 
            IFileOperationProgressSink * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IShellItem *psiDestinationFolder,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszNewName,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszTemplateName,
            /* [in] */ DWORD dwFileAttributes,
            /* [in] */ HRESULT hrNew,
            /* [in] */ __RPC__in_opt IShellItem *psiNewItem);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateProgress )( 
            IFileOperationProgressSink * This,
            /* [in] */ UINT iWorkTotal,
            /* [in] */ UINT iWorkSoFar);
        
        HRESULT ( STDMETHODCALLTYPE *ResetTimer )( 
            IFileOperationProgressSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *PauseTimer )( 
            IFileOperationProgressSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *ResumeTimer )( 
            IFileOperationProgressSink * This);
        
        END_INTERFACE
    } IFileOperationProgressSinkVtbl;

    interface IFileOperationProgressSink
    {
        CONST_VTBL struct IFileOperationProgressSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFileOperationProgressSink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFileOperationProgressSink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFileOperationProgressSink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFileOperationProgressSink_StartOperations(This)	\
    ( (This)->lpVtbl -> StartOperations(This) ) 

#define IFileOperationProgressSink_FinishOperations(This,hrResult)	\
    ( (This)->lpVtbl -> FinishOperations(This,hrResult) ) 

#define IFileOperationProgressSink_PreRenameItem(This,dwFlags,psiItem,pszNewName)	\
    ( (This)->lpVtbl -> PreRenameItem(This,dwFlags,psiItem,pszNewName) ) 

#define IFileOperationProgressSink_PostRenameItem(This,dwFlags,psiItem,pszNewName,hrRename,psiNewlyCreated)	\
    ( (This)->lpVtbl -> PostRenameItem(This,dwFlags,psiItem,pszNewName,hrRename,psiNewlyCreated) ) 

#define IFileOperationProgressSink_PreMoveItem(This,dwFlags,psiItem,psiDestinationFolder,pszNewName)	\
    ( (This)->lpVtbl -> PreMoveItem(This,dwFlags,psiItem,psiDestinationFolder,pszNewName) ) 

#define IFileOperationProgressSink_PostMoveItem(This,dwFlags,psiItem,psiDestinationFolder,pszNewName,hrMove,psiNewlyCreated)	\
    ( (This)->lpVtbl -> PostMoveItem(This,dwFlags,psiItem,psiDestinationFolder,pszNewName,hrMove,psiNewlyCreated) ) 

#define IFileOperationProgressSink_PreCopyItem(This,dwFlags,psiItem,psiDestinationFolder,pszNewName)	\
    ( (This)->lpVtbl -> PreCopyItem(This,dwFlags,psiItem,psiDestinationFolder,pszNewName) ) 

#define IFileOperationProgressSink_PostCopyItem(This,dwFlags,psiItem,psiDestinationFolder,pszNewName,hrCopy,psiNewlyCreated)	\
    ( (This)->lpVtbl -> PostCopyItem(This,dwFlags,psiItem,psiDestinationFolder,pszNewName,hrCopy,psiNewlyCreated) ) 

#define IFileOperationProgressSink_PreDeleteItem(This,dwFlags,psiItem)	\
    ( (This)->lpVtbl -> PreDeleteItem(This,dwFlags,psiItem) ) 

#define IFileOperationProgressSink_PostDeleteItem(This,dwFlags,psiItem,hrDelete,psiNewlyCreated)	\
    ( (This)->lpVtbl -> PostDeleteItem(This,dwFlags,psiItem,hrDelete,psiNewlyCreated) ) 

#define IFileOperationProgressSink_PreNewItem(This,dwFlags,psiDestinationFolder,pszNewName)	\
    ( (This)->lpVtbl -> PreNewItem(This,dwFlags,psiDestinationFolder,pszNewName) ) 

#define IFileOperationProgressSink_PostNewItem(This,dwFlags,psiDestinationFolder,pszNewName,pszTemplateName,dwFileAttributes,hrNew,psiNewItem)	\
    ( (This)->lpVtbl -> PostNewItem(This,dwFlags,psiDestinationFolder,pszNewName,pszTemplateName,dwFileAttributes,hrNew,psiNewItem) ) 

#define IFileOperationProgressSink_UpdateProgress(This,iWorkTotal,iWorkSoFar)	\
    ( (This)->lpVtbl -> UpdateProgress(This,iWorkTotal,iWorkSoFar) ) 

#define IFileOperationProgressSink_ResetTimer(This)	\
    ( (This)->lpVtbl -> ResetTimer(This) ) 

#define IFileOperationProgressSink_PauseTimer(This)	\
    ( (This)->lpVtbl -> PauseTimer(This) ) 

#define IFileOperationProgressSink_ResumeTimer(This)	\
    ( (This)->lpVtbl -> ResumeTimer(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFileOperationProgressSink_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0046 */
/* [local] */ 

#endif  // (_WIN32_IE >= _WIN32_IE_IE70)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0046_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0046_v0_0_s_ifspec;

#ifndef __IShellItemArray_INTERFACE_DEFINED__
#define __IShellItemArray_INTERFACE_DEFINED__

/* interface IShellItemArray */
/* [unique][object][uuid][helpstring] */ 

typedef /* [v1_enum] */ 
enum tagSIATTRIBFLAGS
    {	SIATTRIBFLAGS_AND	= 0x1,
	SIATTRIBFLAGS_OR	= 0x2,
	SIATTRIBFLAGS_APPCOMPAT	= 0x3,
	SIATTRIBFLAGS_MASK	= 0x3
    } 	SIATTRIBFLAGS;


EXTERN_C const IID IID_IShellItemArray;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b63ea76d-1f85-456f-a19c-48159efa858b")
    IShellItemArray : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BindToHandler( 
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbc,
            /* [in] */ __RPC__in REFGUID rbhid,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppvOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyStore( 
            /* [in] */ GETPROPERTYSTOREFLAGS flags,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyDescriptionList( 
            /* [in] */ __RPC__in REFPROPERTYKEY keyType,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributes( 
            /* [in] */ SIATTRIBFLAGS dwAttribFlags,
            /* [in] */ SFGAOF sfgaoMask,
            /* [out] */ __RPC__out SFGAOF *psfgaoAttribs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out DWORD *pdwNumItems) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItemAt( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumItems( 
            /* [out] */ __RPC__deref_out_opt IEnumShellItems **ppenumShellItems) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellItemArrayVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellItemArray * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellItemArray * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellItemArray * This);
        
        HRESULT ( STDMETHODCALLTYPE *BindToHandler )( 
            IShellItemArray * This,
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbc,
            /* [in] */ __RPC__in REFGUID rbhid,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppvOut);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyStore )( 
            IShellItemArray * This,
            /* [in] */ GETPROPERTYSTOREFLAGS flags,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyDescriptionList )( 
            IShellItemArray * This,
            /* [in] */ __RPC__in REFPROPERTYKEY keyType,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributes )( 
            IShellItemArray * This,
            /* [in] */ SIATTRIBFLAGS dwAttribFlags,
            /* [in] */ SFGAOF sfgaoMask,
            /* [out] */ __RPC__out SFGAOF *psfgaoAttribs);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IShellItemArray * This,
            /* [out] */ __RPC__out DWORD *pdwNumItems);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemAt )( 
            IShellItemArray * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi);
        
        HRESULT ( STDMETHODCALLTYPE *EnumItems )( 
            IShellItemArray * This,
            /* [out] */ __RPC__deref_out_opt IEnumShellItems **ppenumShellItems);
        
        END_INTERFACE
    } IShellItemArrayVtbl;

    interface IShellItemArray
    {
        CONST_VTBL struct IShellItemArrayVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellItemArray_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellItemArray_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellItemArray_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellItemArray_BindToHandler(This,pbc,rbhid,riid,ppvOut)	\
    ( (This)->lpVtbl -> BindToHandler(This,pbc,rbhid,riid,ppvOut) ) 

#define IShellItemArray_GetPropertyStore(This,flags,riid,ppv)	\
    ( (This)->lpVtbl -> GetPropertyStore(This,flags,riid,ppv) ) 

#define IShellItemArray_GetPropertyDescriptionList(This,keyType,riid,ppv)	\
    ( (This)->lpVtbl -> GetPropertyDescriptionList(This,keyType,riid,ppv) ) 

#define IShellItemArray_GetAttributes(This,dwAttribFlags,sfgaoMask,psfgaoAttribs)	\
    ( (This)->lpVtbl -> GetAttributes(This,dwAttribFlags,sfgaoMask,psfgaoAttribs) ) 

#define IShellItemArray_GetCount(This,pdwNumItems)	\
    ( (This)->lpVtbl -> GetCount(This,pdwNumItems) ) 

#define IShellItemArray_GetItemAt(This,dwIndex,ppsi)	\
    ( (This)->lpVtbl -> GetItemAt(This,dwIndex,ppsi) ) 

#define IShellItemArray_EnumItems(This,ppenumShellItems)	\
    ( (This)->lpVtbl -> EnumItems(This,ppenumShellItems) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellItemArray_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0047 */
/* [local] */ 

#if (_WIN32_IE >= _WIN32_IE_IE70)
SHSTDAPI SHCreateShellItemArray(__in_opt PCIDLIST_ABSOLUTE pidlParent, __in_opt IShellFolder *psf, UINT cidl, __in_ecount(cidl) PCUITEMID_CHILD_ARRAY ppidl, __deref_out IShellItemArray **ppsiItemArray);
SHSTDAPI SHCreateShellItemArrayFromDataObject(IDataObject *pdo, REFIID riid, __deref_out void **ppv);
SHSTDAPI SHCreateShellItemArrayFromIDLists(UINT cidl, PCIDLIST_ABSOLUTE_ARRAY rgpidl, __deref_out IShellItemArray **ppsiItemArray);
SHSTDAPI SHCreateShellItemArrayFromShellItem(__in IShellItem *psi, REFIID riid, __deref_out void **ppv);
#endif  // (_WIN32_IE >= _WIN32_IE_IE70)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0047_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0047_v0_0_s_ifspec;

#ifndef __IInitializeWithItem_INTERFACE_DEFINED__
#define __IInitializeWithItem_INTERFACE_DEFINED__

/* interface IInitializeWithItem */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IInitializeWithItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7f73be3f-fb79-493c-a6c7-7ee14e245841")
    IInitializeWithItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [in] */ DWORD grfMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInitializeWithItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInitializeWithItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInitializeWithItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInitializeWithItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IInitializeWithItem * This,
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [in] */ DWORD grfMode);
        
        END_INTERFACE
    } IInitializeWithItemVtbl;

    interface IInitializeWithItem
    {
        CONST_VTBL struct IInitializeWithItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInitializeWithItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInitializeWithItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInitializeWithItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInitializeWithItem_Initialize(This,psi,grfMode)	\
    ( (This)->lpVtbl -> Initialize(This,psi,grfMode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInitializeWithItem_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0048 */
/* [local] */ 

/* [v1_enum] */ 
enum tagPROPERTYUI_NAME_FLAGS
    {	PUIFNF_DEFAULT	= 0,
	PUIFNF_MNEMONIC	= 0x1
    } ;
typedef DWORD PROPERTYUI_NAME_FLAGS;

/* [v1_enum] */ 
enum tagPROPERTYUI_FLAGS
    {	PUIF_DEFAULT	= 0,
	PUIF_RIGHTALIGN	= 0x1,
	PUIF_NOLABELININFOTIP	= 0x2
    } ;
typedef DWORD PROPERTYUI_FLAGS;

/* [v1_enum] */ 
enum tagPROPERTYUI_FORMAT_FLAGS
    {	PUIFFDF_DEFAULT	= 0,
	PUIFFDF_RIGHTTOLEFT	= 0x1,
	PUIFFDF_SHORTFORMAT	= 0x2,
	PUIFFDF_NOTIME	= 0x4,
	PUIFFDF_FRIENDLYDATE	= 0x8
    } ;
typedef DWORD PROPERTYUI_FORMAT_FLAGS;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0048_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0048_v0_0_s_ifspec;

#ifndef __IPropertyUI_INTERFACE_DEFINED__
#define __IPropertyUI_INTERFACE_DEFINED__

/* interface IPropertyUI */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IPropertyUI;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("757a7d9f-919a-4118-99d7-dbb208c8cc66")
    IPropertyUI : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ParsePropertyName( 
            /* [string][in] */ __RPC__in LPCWSTR pszName,
            /* [out] */ __RPC__out FMTID *pfmtid,
            /* [out] */ __RPC__out PROPID *ppid,
            /* [out][in] */ __RPC__inout ULONG *pchEaten) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCannonicalName( 
            /* [in] */ __RPC__in REFFMTID fmtid,
            /* [in] */ PROPID pid,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cchText) LPWSTR pwszText,
            /* [in] */ DWORD cchText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayName( 
            /* [in] */ __RPC__in REFFMTID fmtid,
            /* [in] */ PROPID pid,
            /* [in] */ PROPERTYUI_NAME_FLAGS flags,
            /* [size_is][out] */ __RPC__out_ecount_full(cchText) LPWSTR pwszText,
            /* [in] */ DWORD cchText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyDescription( 
            /* [in] */ __RPC__in REFFMTID fmtid,
            /* [in] */ PROPID pid,
            /* [size_is][out] */ __RPC__out_ecount_full(cchText) LPWSTR pwszText,
            /* [in] */ DWORD cchText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultWidth( 
            /* [in] */ __RPC__in REFFMTID fmtid,
            /* [in] */ PROPID pid,
            /* [out] */ __RPC__out ULONG *pcxChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFlags( 
            /* [in] */ __RPC__in REFFMTID fmtid,
            /* [in] */ PROPID pid,
            /* [out] */ __RPC__out PROPERTYUI_FLAGS *pflags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FormatForDisplay( 
            /* [in] */ __RPC__in REFFMTID fmtid,
            /* [in] */ PROPID pid,
            /* [in] */ __RPC__in const PROPVARIANT *ppropvar,
            /* [in] */ PROPERTYUI_FORMAT_FLAGS puiff,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cchText) LPWSTR pwszText,
            /* [in] */ DWORD cchText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHelpInfo( 
            /* [in] */ __RPC__in REFFMTID fmtid,
            /* [in] */ PROPID pid,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPWSTR pwszHelpFile,
            /* [in] */ DWORD cch,
            /* [out] */ __RPC__out UINT *puHelpID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyUIVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPropertyUI * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPropertyUI * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPropertyUI * This);
        
        HRESULT ( STDMETHODCALLTYPE *ParsePropertyName )( 
            IPropertyUI * This,
            /* [string][in] */ __RPC__in LPCWSTR pszName,
            /* [out] */ __RPC__out FMTID *pfmtid,
            /* [out] */ __RPC__out PROPID *ppid,
            /* [out][in] */ __RPC__inout ULONG *pchEaten);
        
        HRESULT ( STDMETHODCALLTYPE *GetCannonicalName )( 
            IPropertyUI * This,
            /* [in] */ __RPC__in REFFMTID fmtid,
            /* [in] */ PROPID pid,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cchText) LPWSTR pwszText,
            /* [in] */ DWORD cchText);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            IPropertyUI * This,
            /* [in] */ __RPC__in REFFMTID fmtid,
            /* [in] */ PROPID pid,
            /* [in] */ PROPERTYUI_NAME_FLAGS flags,
            /* [size_is][out] */ __RPC__out_ecount_full(cchText) LPWSTR pwszText,
            /* [in] */ DWORD cchText);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyDescription )( 
            IPropertyUI * This,
            /* [in] */ __RPC__in REFFMTID fmtid,
            /* [in] */ PROPID pid,
            /* [size_is][out] */ __RPC__out_ecount_full(cchText) LPWSTR pwszText,
            /* [in] */ DWORD cchText);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultWidth )( 
            IPropertyUI * This,
            /* [in] */ __RPC__in REFFMTID fmtid,
            /* [in] */ PROPID pid,
            /* [out] */ __RPC__out ULONG *pcxChars);
        
        HRESULT ( STDMETHODCALLTYPE *GetFlags )( 
            IPropertyUI * This,
            /* [in] */ __RPC__in REFFMTID fmtid,
            /* [in] */ PROPID pid,
            /* [out] */ __RPC__out PROPERTYUI_FLAGS *pflags);
        
        HRESULT ( STDMETHODCALLTYPE *FormatForDisplay )( 
            IPropertyUI * This,
            /* [in] */ __RPC__in REFFMTID fmtid,
            /* [in] */ PROPID pid,
            /* [in] */ __RPC__in const PROPVARIANT *ppropvar,
            /* [in] */ PROPERTYUI_FORMAT_FLAGS puiff,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cchText) LPWSTR pwszText,
            /* [in] */ DWORD cchText);
        
        HRESULT ( STDMETHODCALLTYPE *GetHelpInfo )( 
            IPropertyUI * This,
            /* [in] */ __RPC__in REFFMTID fmtid,
            /* [in] */ PROPID pid,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPWSTR pwszHelpFile,
            /* [in] */ DWORD cch,
            /* [out] */ __RPC__out UINT *puHelpID);
        
        END_INTERFACE
    } IPropertyUIVtbl;

    interface IPropertyUI
    {
        CONST_VTBL struct IPropertyUIVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyUI_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyUI_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyUI_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyUI_ParsePropertyName(This,pszName,pfmtid,ppid,pchEaten)	\
    ( (This)->lpVtbl -> ParsePropertyName(This,pszName,pfmtid,ppid,pchEaten) ) 

#define IPropertyUI_GetCannonicalName(This,fmtid,pid,pwszText,cchText)	\
    ( (This)->lpVtbl -> GetCannonicalName(This,fmtid,pid,pwszText,cchText) ) 

#define IPropertyUI_GetDisplayName(This,fmtid,pid,flags,pwszText,cchText)	\
    ( (This)->lpVtbl -> GetDisplayName(This,fmtid,pid,flags,pwszText,cchText) ) 

#define IPropertyUI_GetPropertyDescription(This,fmtid,pid,pwszText,cchText)	\
    ( (This)->lpVtbl -> GetPropertyDescription(This,fmtid,pid,pwszText,cchText) ) 

#define IPropertyUI_GetDefaultWidth(This,fmtid,pid,pcxChars)	\
    ( (This)->lpVtbl -> GetDefaultWidth(This,fmtid,pid,pcxChars) ) 

#define IPropertyUI_GetFlags(This,fmtid,pid,pflags)	\
    ( (This)->lpVtbl -> GetFlags(This,fmtid,pid,pflags) ) 

#define IPropertyUI_FormatForDisplay(This,fmtid,pid,ppropvar,puiff,pwszText,cchText)	\
    ( (This)->lpVtbl -> FormatForDisplay(This,fmtid,pid,ppropvar,puiff,pwszText,cchText) ) 

#define IPropertyUI_GetHelpInfo(This,fmtid,pid,pwszHelpFile,cch,puHelpID)	\
    ( (This)->lpVtbl -> GetHelpInfo(This,fmtid,pid,pwszHelpFile,cch,puHelpID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertyUI_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0049 */
/* [local] */ 

#if (_WIN32_IE >= _WIN32_IE_IE70)
SHSTDAPI SHRemovePersonalPropertyValues(__in IShellItemArray *psia);
SHSTDAPI SHAddDefaultPropertiesByExt(PCWSTR pszExt, IPropertyStore *pPropStore);
SHSTDAPI SHCreateDefaultPropertiesOp(IShellItem *psi, __out IFileOperation **ppFileOp);
SHSTDAPI SHSetDefaultProperties(__in_opt HWND hwndParent, IShellItem *psi, DWORD dwFileOpFlags, __in_opt IFileOperationProgressSink *pfops);
#endif  // (_WIN32_IE >= _WIN32_IE_IE70)
#if (_WIN32_IE >= 0x0500)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0049_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0049_v0_0_s_ifspec;

#ifndef __ICategoryProvider_INTERFACE_DEFINED__
#define __ICategoryProvider_INTERFACE_DEFINED__

/* interface ICategoryProvider */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_ICategoryProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9af64809-5864-4c26-a720-c1f78c086ee3")
    ICategoryProvider : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CanCategorizeOnSCID( 
            /* [in] */ __RPC__in const SHCOLUMNID *pscid) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDefaultCategory( 
            /* [out] */ __RPC__out GUID *pguid,
            /* [out] */ __RPC__out SHCOLUMNID *pscid) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCategoryForSCID( 
            /* [in] */ __RPC__in const SHCOLUMNID *pscid,
            /* [out] */ __RPC__out GUID *pguid) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumCategories( 
            /* [out] */ __RPC__deref_out_opt IEnumGUID **penum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCategoryName( 
            /* [in] */ __RPC__in const GUID *pguid,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPWSTR pszName,
            /* [in] */ UINT cch) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateCategory( 
            /* [in] */ __RPC__in const GUID *pguid,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICategoryProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICategoryProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICategoryProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICategoryProvider * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CanCategorizeOnSCID )( 
            ICategoryProvider * This,
            /* [in] */ __RPC__in const SHCOLUMNID *pscid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDefaultCategory )( 
            ICategoryProvider * This,
            /* [out] */ __RPC__out GUID *pguid,
            /* [out] */ __RPC__out SHCOLUMNID *pscid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCategoryForSCID )( 
            ICategoryProvider * This,
            /* [in] */ __RPC__in const SHCOLUMNID *pscid,
            /* [out] */ __RPC__out GUID *pguid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumCategories )( 
            ICategoryProvider * This,
            /* [out] */ __RPC__deref_out_opt IEnumGUID **penum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCategoryName )( 
            ICategoryProvider * This,
            /* [in] */ __RPC__in const GUID *pguid,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPWSTR pszName,
            /* [in] */ UINT cch);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateCategory )( 
            ICategoryProvider * This,
            /* [in] */ __RPC__in const GUID *pguid,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        END_INTERFACE
    } ICategoryProviderVtbl;

    interface ICategoryProvider
    {
        CONST_VTBL struct ICategoryProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICategoryProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICategoryProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICategoryProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICategoryProvider_CanCategorizeOnSCID(This,pscid)	\
    ( (This)->lpVtbl -> CanCategorizeOnSCID(This,pscid) ) 

#define ICategoryProvider_GetDefaultCategory(This,pguid,pscid)	\
    ( (This)->lpVtbl -> GetDefaultCategory(This,pguid,pscid) ) 

#define ICategoryProvider_GetCategoryForSCID(This,pscid,pguid)	\
    ( (This)->lpVtbl -> GetCategoryForSCID(This,pscid,pguid) ) 

#define ICategoryProvider_EnumCategories(This,penum)	\
    ( (This)->lpVtbl -> EnumCategories(This,penum) ) 

#define ICategoryProvider_GetCategoryName(This,pguid,pszName,cch)	\
    ( (This)->lpVtbl -> GetCategoryName(This,pguid,pszName,cch) ) 

#define ICategoryProvider_CreateCategory(This,pguid,riid,ppv)	\
    ( (This)->lpVtbl -> CreateCategory(This,pguid,riid,ppv) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICategoryProvider_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0050 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum tagCATEGORYINFO_FLAGS
    {	CATINFO_NORMAL	= 0,
	CATINFO_COLLAPSED	= 0x1,
	CATINFO_HIDDEN	= 0x2,
	CATINFO_EXPANDED	= 0x4,
	CATINFO_NOHEADER	= 0x8,
	CATINFO_NOTCOLLAPSIBLE	= 0x10,
	CATINFO_NOHEADERCOUNT	= 0x20
    } 	CATEGORYINFO_FLAGS;

typedef /* [v1_enum] */ 
enum tagCATSORT_FLAGS
    {	CATSORT_DEFAULT	= 0,
	CATSORT_NAME	= 0x1
    } 	CATSORT_FLAGS;

typedef struct tagCATEGORY_INFO
    {
    CATEGORYINFO_FLAGS cif;
    WCHAR wszName[ 260 ];
    } 	CATEGORY_INFO;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0050_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0050_v0_0_s_ifspec;

#ifndef __ICategorizer_INTERFACE_DEFINED__
#define __ICategorizer_INTERFACE_DEFINED__

/* interface ICategorizer */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_ICategorizer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a3b14589-9174-49a8-89a3-06a1ae2b9ba7")
    ICategorizer : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDescription( 
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPWSTR pszDesc,
            /* [in] */ UINT cch) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCategory( 
            /* [in] */ UINT cidl,
            /* [size_is][in] */ __RPC__in_ecount_full(cidl) PCUITEMID_CHILD_ARRAY apidl,
            /* [size_is][out] */ __RPC__out_ecount_full(cidl) DWORD *rgCategoryIds) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCategoryInfo( 
            /* [in] */ DWORD dwCategoryId,
            /* [out] */ __RPC__out CATEGORY_INFO *pci) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareCategory( 
            /* [in] */ CATSORT_FLAGS csfFlags,
            /* [in] */ DWORD dwCategoryId1,
            /* [in] */ DWORD dwCategoryId2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICategorizerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICategorizer * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICategorizer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICategorizer * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDescription )( 
            ICategorizer * This,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPWSTR pszDesc,
            /* [in] */ UINT cch);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCategory )( 
            ICategorizer * This,
            /* [in] */ UINT cidl,
            /* [size_is][in] */ __RPC__in_ecount_full(cidl) PCUITEMID_CHILD_ARRAY apidl,
            /* [size_is][out] */ __RPC__out_ecount_full(cidl) DWORD *rgCategoryIds);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCategoryInfo )( 
            ICategorizer * This,
            /* [in] */ DWORD dwCategoryId,
            /* [out] */ __RPC__out CATEGORY_INFO *pci);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CompareCategory )( 
            ICategorizer * This,
            /* [in] */ CATSORT_FLAGS csfFlags,
            /* [in] */ DWORD dwCategoryId1,
            /* [in] */ DWORD dwCategoryId2);
        
        END_INTERFACE
    } ICategorizerVtbl;

    interface ICategorizer
    {
        CONST_VTBL struct ICategorizerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICategorizer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICategorizer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICategorizer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICategorizer_GetDescription(This,pszDesc,cch)	\
    ( (This)->lpVtbl -> GetDescription(This,pszDesc,cch) ) 

#define ICategorizer_GetCategory(This,cidl,apidl,rgCategoryIds)	\
    ( (This)->lpVtbl -> GetCategory(This,cidl,apidl,rgCategoryIds) ) 

#define ICategorizer_GetCategoryInfo(This,dwCategoryId,pci)	\
    ( (This)->lpVtbl -> GetCategoryInfo(This,dwCategoryId,pci) ) 

#define ICategorizer_CompareCategory(This,csfFlags,dwCategoryId1,dwCategoryId2)	\
    ( (This)->lpVtbl -> CompareCategory(This,csfFlags,dwCategoryId1,dwCategoryId2) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICategorizer_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0051 */
/* [local] */ 

#endif // (_WIN32_IE >= 0x0500)
#if (NTDDI_VERSION >= NTDDI_WIN2K)
#include <pshpack8.h>
typedef struct tagSHDRAGIMAGE
    {
    SIZE sizeDragImage;
    POINT ptOffset;
    HBITMAP hbmpDragImage;
    COLORREF crColorKey;
    } 	SHDRAGIMAGE;

typedef struct tagSHDRAGIMAGE *LPSHDRAGIMAGE;

#include <poppack.h> // Return to byte packing
#define DI_GETDRAGIMAGE     TEXT("ShellGetDragImage")


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0051_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0051_v0_0_s_ifspec;

#ifndef __IDropTargetHelper_INTERFACE_DEFINED__
#define __IDropTargetHelper_INTERFACE_DEFINED__

/* interface IDropTargetHelper */
/* [object][unique][local][uuid] */ 


EXTERN_C const IID IID_IDropTargetHelper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4657278B-411B-11D2-839A-00C04FD918D0")
    IDropTargetHelper : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DragEnter( 
            /* [in] */ 
            __in  HWND hwndTarget,
            /* [in] */ 
            __in  IDataObject *pDataObject,
            /* [in] */ 
            __in  POINT *ppt,
            /* [in] */ 
            __in  DWORD dwEffect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DragLeave( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DragOver( 
            /* [in] */ 
            __in  POINT *ppt,
            /* [in] */ 
            __in  DWORD dwEffect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Drop( 
            /* [in] */ 
            __in  IDataObject *pDataObject,
            /* [in] */ 
            __in  POINT *ppt,
            /* [in] */ 
            __in  DWORD dwEffect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Show( 
            /* [in] */ 
            __in  BOOL fShow) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDropTargetHelperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDropTargetHelper * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDropTargetHelper * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDropTargetHelper * This);
        
        HRESULT ( STDMETHODCALLTYPE *DragEnter )( 
            IDropTargetHelper * This,
            /* [in] */ 
            __in  HWND hwndTarget,
            /* [in] */ 
            __in  IDataObject *pDataObject,
            /* [in] */ 
            __in  POINT *ppt,
            /* [in] */ 
            __in  DWORD dwEffect);
        
        HRESULT ( STDMETHODCALLTYPE *DragLeave )( 
            IDropTargetHelper * This);
        
        HRESULT ( STDMETHODCALLTYPE *DragOver )( 
            IDropTargetHelper * This,
            /* [in] */ 
            __in  POINT *ppt,
            /* [in] */ 
            __in  DWORD dwEffect);
        
        HRESULT ( STDMETHODCALLTYPE *Drop )( 
            IDropTargetHelper * This,
            /* [in] */ 
            __in  IDataObject *pDataObject,
            /* [in] */ 
            __in  POINT *ppt,
            /* [in] */ 
            __in  DWORD dwEffect);
        
        HRESULT ( STDMETHODCALLTYPE *Show )( 
            IDropTargetHelper * This,
            /* [in] */ 
            __in  BOOL fShow);
        
        END_INTERFACE
    } IDropTargetHelperVtbl;

    interface IDropTargetHelper
    {
        CONST_VTBL struct IDropTargetHelperVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDropTargetHelper_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDropTargetHelper_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDropTargetHelper_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDropTargetHelper_DragEnter(This,hwndTarget,pDataObject,ppt,dwEffect)	\
    ( (This)->lpVtbl -> DragEnter(This,hwndTarget,pDataObject,ppt,dwEffect) ) 

#define IDropTargetHelper_DragLeave(This)	\
    ( (This)->lpVtbl -> DragLeave(This) ) 

#define IDropTargetHelper_DragOver(This,ppt,dwEffect)	\
    ( (This)->lpVtbl -> DragOver(This,ppt,dwEffect) ) 

#define IDropTargetHelper_Drop(This,pDataObject,ppt,dwEffect)	\
    ( (This)->lpVtbl -> Drop(This,pDataObject,ppt,dwEffect) ) 

#define IDropTargetHelper_Show(This,fShow)	\
    ( (This)->lpVtbl -> Show(This,fShow) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDropTargetHelper_INTERFACE_DEFINED__ */


#ifndef __IDragSourceHelper_INTERFACE_DEFINED__
#define __IDragSourceHelper_INTERFACE_DEFINED__

/* interface IDragSourceHelper */
/* [object][unique][local][uuid] */ 


EXTERN_C const IID IID_IDragSourceHelper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DE5BF786-477A-11D2-839D-00C04FD918D0")
    IDragSourceHelper : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitializeFromBitmap( 
            /* [in] */ 
            __in  LPSHDRAGIMAGE pshdi,
            /* [in] */ 
            __in  IDataObject *pDataObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeFromWindow( 
            /* [in] */ 
            __in  HWND hwnd,
            /* [in] */ 
            __in  POINT *ppt,
            /* [in] */ 
            __in  IDataObject *pDataObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDragSourceHelperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDragSourceHelper * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDragSourceHelper * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDragSourceHelper * This);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromBitmap )( 
            IDragSourceHelper * This,
            /* [in] */ 
            __in  LPSHDRAGIMAGE pshdi,
            /* [in] */ 
            __in  IDataObject *pDataObject);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromWindow )( 
            IDragSourceHelper * This,
            /* [in] */ 
            __in  HWND hwnd,
            /* [in] */ 
            __in  POINT *ppt,
            /* [in] */ 
            __in  IDataObject *pDataObject);
        
        END_INTERFACE
    } IDragSourceHelperVtbl;

    interface IDragSourceHelper
    {
        CONST_VTBL struct IDragSourceHelperVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDragSourceHelper_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDragSourceHelper_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDragSourceHelper_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDragSourceHelper_InitializeFromBitmap(This,pshdi,pDataObject)	\
    ( (This)->lpVtbl -> InitializeFromBitmap(This,pshdi,pDataObject) ) 

#define IDragSourceHelper_InitializeFromWindow(This,hwnd,ppt,pDataObject)	\
    ( (This)->lpVtbl -> InitializeFromWindow(This,hwnd,ppt,pDataObject) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDragSourceHelper_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0053 */
/* [local] */ 

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef 
enum tagDSH_FLAGS
    {	DSH_ALLOWDROPDESCRIPTIONTEXT	= 0x1
    } 	DSH_FLAGS;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0053_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0053_v0_0_s_ifspec;

#ifndef __IDragSourceHelper2_INTERFACE_DEFINED__
#define __IDragSourceHelper2_INTERFACE_DEFINED__

/* interface IDragSourceHelper2 */
/* [object][unique][local][uuid] */ 


EXTERN_C const IID IID_IDragSourceHelper2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("83E07D0D-0C5F-4163-BF1A-60B274051E40")
    IDragSourceHelper2 : public IDragSourceHelper
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFlags( 
            /* [in] */ 
            __in  DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDragSourceHelper2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDragSourceHelper2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDragSourceHelper2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDragSourceHelper2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromBitmap )( 
            IDragSourceHelper2 * This,
            /* [in] */ 
            __in  LPSHDRAGIMAGE pshdi,
            /* [in] */ 
            __in  IDataObject *pDataObject);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromWindow )( 
            IDragSourceHelper2 * This,
            /* [in] */ 
            __in  HWND hwnd,
            /* [in] */ 
            __in  POINT *ppt,
            /* [in] */ 
            __in  IDataObject *pDataObject);
        
        HRESULT ( STDMETHODCALLTYPE *SetFlags )( 
            IDragSourceHelper2 * This,
            /* [in] */ 
            __in  DWORD dwFlags);
        
        END_INTERFACE
    } IDragSourceHelper2Vtbl;

    interface IDragSourceHelper2
    {
        CONST_VTBL struct IDragSourceHelper2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDragSourceHelper2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDragSourceHelper2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDragSourceHelper2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDragSourceHelper2_InitializeFromBitmap(This,pshdi,pDataObject)	\
    ( (This)->lpVtbl -> InitializeFromBitmap(This,pshdi,pDataObject) ) 

#define IDragSourceHelper2_InitializeFromWindow(This,hwnd,ppt,pDataObject)	\
    ( (This)->lpVtbl -> InitializeFromWindow(This,hwnd,ppt,pDataObject) ) 


#define IDragSourceHelper2_SetFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> SetFlags(This,dwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDragSourceHelper2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0054 */
/* [local] */ 

#endif  // NTDDI_VISTA
#endif  // NTDDI_WIN2K
#ifdef UNICODE
#define IShellLink      IShellLinkW
#else
#define IShellLink      IShellLinkA
#endif
typedef 
enum tagSLR_FLAGS
    {	SLR_NO_UI	= 0x1,
	SLR_ANY_MATCH	= 0x2,
	SLR_UPDATE	= 0x4,
	SLR_NOUPDATE	= 0x8,
	SLR_NOSEARCH	= 0x10,
	SLR_NOTRACK	= 0x20,
	SLR_NOLINKINFO	= 0x40,
	SLR_INVOKE_MSI	= 0x80,
	SLR_NO_UI_WITH_MSG_PUMP	= 0x101
    } 	SLR_FLAGS;

typedef 
enum tagSLGP_FLAGS
    {	SLGP_SHORTPATH	= 0x1,
	SLGP_UNCPRIORITY	= 0x2,
	SLGP_RAWPATH	= 0x4,
	SLGP_RELATIVEPRIORITY	= 0x8
    } 	SLGP_FLAGS;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0054_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0054_v0_0_s_ifspec;

#ifndef __IShellLinkA_INTERFACE_DEFINED__
#define __IShellLinkA_INTERFACE_DEFINED__

/* interface IShellLinkA */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IShellLinkA;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000214EE-0000-0000-C000-000000000046")
    IShellLinkA : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPath( 
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPSTR pszFile,
            /* [in] */ int cch,
            /* [unique][out][in] */ __RPC__inout_opt WIN32_FIND_DATAA *pfd,
            /* [in] */ DWORD fFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIDList( 
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIDList( 
            /* [in] */ __RPC__in PCIDLIST_ABSOLUTE pidl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescription( 
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPSTR pszName,
            /* [in] */ int cch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDescription( 
            /* [string][in] */ __RPC__in LPCSTR pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWorkingDirectory( 
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPSTR pszDir,
            /* [in] */ int cch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetWorkingDirectory( 
            /* [string][in] */ __RPC__in LPCSTR pszDir) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetArguments( 
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPSTR pszArgs,
            /* [in] */ int cch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetArguments( 
            /* [string][in] */ __RPC__in LPCSTR pszArgs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHotkey( 
            /* [out] */ __RPC__out WORD *pwHotkey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHotkey( 
            /* [in] */ WORD wHotkey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetShowCmd( 
            /* [out] */ __RPC__out int *piShowCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetShowCmd( 
            /* [in] */ int iShowCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIconLocation( 
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPSTR pszIconPath,
            /* [in] */ int cch,
            /* [out] */ __RPC__out int *piIcon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIconLocation( 
            /* [string][in] */ __RPC__in LPCSTR pszIconPath,
            /* [in] */ int iIcon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRelativePath( 
            /* [string][in] */ __RPC__in LPCSTR pszPathRel,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resolve( 
            /* [unique][in] */ __RPC__in_opt HWND hwnd,
            /* [in] */ DWORD fFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPath( 
            /* [string][in] */ __RPC__in LPCSTR pszFile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellLinkAVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellLinkA * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellLinkA * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellLinkA * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPath )( 
            IShellLinkA * This,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPSTR pszFile,
            /* [in] */ int cch,
            /* [unique][out][in] */ __RPC__inout_opt WIN32_FIND_DATAA *pfd,
            /* [in] */ DWORD fFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDList )( 
            IShellLinkA * This,
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidl);
        
        HRESULT ( STDMETHODCALLTYPE *SetIDList )( 
            IShellLinkA * This,
            /* [in] */ __RPC__in PCIDLIST_ABSOLUTE pidl);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescription )( 
            IShellLinkA * This,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPSTR pszName,
            /* [in] */ int cch);
        
        HRESULT ( STDMETHODCALLTYPE *SetDescription )( 
            IShellLinkA * This,
            /* [string][in] */ __RPC__in LPCSTR pszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetWorkingDirectory )( 
            IShellLinkA * This,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPSTR pszDir,
            /* [in] */ int cch);
        
        HRESULT ( STDMETHODCALLTYPE *SetWorkingDirectory )( 
            IShellLinkA * This,
            /* [string][in] */ __RPC__in LPCSTR pszDir);
        
        HRESULT ( STDMETHODCALLTYPE *GetArguments )( 
            IShellLinkA * This,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPSTR pszArgs,
            /* [in] */ int cch);
        
        HRESULT ( STDMETHODCALLTYPE *SetArguments )( 
            IShellLinkA * This,
            /* [string][in] */ __RPC__in LPCSTR pszArgs);
        
        HRESULT ( STDMETHODCALLTYPE *GetHotkey )( 
            IShellLinkA * This,
            /* [out] */ __RPC__out WORD *pwHotkey);
        
        HRESULT ( STDMETHODCALLTYPE *SetHotkey )( 
            IShellLinkA * This,
            /* [in] */ WORD wHotkey);
        
        HRESULT ( STDMETHODCALLTYPE *GetShowCmd )( 
            IShellLinkA * This,
            /* [out] */ __RPC__out int *piShowCmd);
        
        HRESULT ( STDMETHODCALLTYPE *SetShowCmd )( 
            IShellLinkA * This,
            /* [in] */ int iShowCmd);
        
        HRESULT ( STDMETHODCALLTYPE *GetIconLocation )( 
            IShellLinkA * This,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPSTR pszIconPath,
            /* [in] */ int cch,
            /* [out] */ __RPC__out int *piIcon);
        
        HRESULT ( STDMETHODCALLTYPE *SetIconLocation )( 
            IShellLinkA * This,
            /* [string][in] */ __RPC__in LPCSTR pszIconPath,
            /* [in] */ int iIcon);
        
        HRESULT ( STDMETHODCALLTYPE *SetRelativePath )( 
            IShellLinkA * This,
            /* [string][in] */ __RPC__in LPCSTR pszPathRel,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *Resolve )( 
            IShellLinkA * This,
            /* [unique][in] */ __RPC__in_opt HWND hwnd,
            /* [in] */ DWORD fFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetPath )( 
            IShellLinkA * This,
            /* [string][in] */ __RPC__in LPCSTR pszFile);
        
        END_INTERFACE
    } IShellLinkAVtbl;

    interface IShellLinkA
    {
        CONST_VTBL struct IShellLinkAVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellLinkA_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellLinkA_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellLinkA_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellLinkA_GetPath(This,pszFile,cch,pfd,fFlags)	\
    ( (This)->lpVtbl -> GetPath(This,pszFile,cch,pfd,fFlags) ) 

#define IShellLinkA_GetIDList(This,ppidl)	\
    ( (This)->lpVtbl -> GetIDList(This,ppidl) ) 

#define IShellLinkA_SetIDList(This,pidl)	\
    ( (This)->lpVtbl -> SetIDList(This,pidl) ) 

#define IShellLinkA_GetDescription(This,pszName,cch)	\
    ( (This)->lpVtbl -> GetDescription(This,pszName,cch) ) 

#define IShellLinkA_SetDescription(This,pszName)	\
    ( (This)->lpVtbl -> SetDescription(This,pszName) ) 

#define IShellLinkA_GetWorkingDirectory(This,pszDir,cch)	\
    ( (This)->lpVtbl -> GetWorkingDirectory(This,pszDir,cch) ) 

#define IShellLinkA_SetWorkingDirectory(This,pszDir)	\
    ( (This)->lpVtbl -> SetWorkingDirectory(This,pszDir) ) 

#define IShellLinkA_GetArguments(This,pszArgs,cch)	\
    ( (This)->lpVtbl -> GetArguments(This,pszArgs,cch) ) 

#define IShellLinkA_SetArguments(This,pszArgs)	\
    ( (This)->lpVtbl -> SetArguments(This,pszArgs) ) 

#define IShellLinkA_GetHotkey(This,pwHotkey)	\
    ( (This)->lpVtbl -> GetHotkey(This,pwHotkey) ) 

#define IShellLinkA_SetHotkey(This,wHotkey)	\
    ( (This)->lpVtbl -> SetHotkey(This,wHotkey) ) 

#define IShellLinkA_GetShowCmd(This,piShowCmd)	\
    ( (This)->lpVtbl -> GetShowCmd(This,piShowCmd) ) 

#define IShellLinkA_SetShowCmd(This,iShowCmd)	\
    ( (This)->lpVtbl -> SetShowCmd(This,iShowCmd) ) 

#define IShellLinkA_GetIconLocation(This,pszIconPath,cch,piIcon)	\
    ( (This)->lpVtbl -> GetIconLocation(This,pszIconPath,cch,piIcon) ) 

#define IShellLinkA_SetIconLocation(This,pszIconPath,iIcon)	\
    ( (This)->lpVtbl -> SetIconLocation(This,pszIconPath,iIcon) ) 

#define IShellLinkA_SetRelativePath(This,pszPathRel,dwReserved)	\
    ( (This)->lpVtbl -> SetRelativePath(This,pszPathRel,dwReserved) ) 

#define IShellLinkA_Resolve(This,hwnd,fFlags)	\
    ( (This)->lpVtbl -> Resolve(This,hwnd,fFlags) ) 

#define IShellLinkA_SetPath(This,pszFile)	\
    ( (This)->lpVtbl -> SetPath(This,pszFile) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellLinkA_INTERFACE_DEFINED__ */


#ifndef __IShellLinkW_INTERFACE_DEFINED__
#define __IShellLinkW_INTERFACE_DEFINED__

/* interface IShellLinkW */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IShellLinkW;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000214F9-0000-0000-C000-000000000046")
    IShellLinkW : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPath( 
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPWSTR pszFile,
            /* [in] */ int cch,
            /* [unique][out][in] */ __RPC__inout_opt WIN32_FIND_DATAW *pfd,
            /* [in] */ DWORD fFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIDList( 
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIDList( 
            /* [unique][in] */ __RPC__in_opt PCIDLIST_ABSOLUTE pidl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescription( 
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPWSTR pszName,
            int cch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDescription( 
            /* [string][in] */ __RPC__in LPCWSTR pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWorkingDirectory( 
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPWSTR pszDir,
            int cch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetWorkingDirectory( 
            /* [string][in] */ __RPC__in LPCWSTR pszDir) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetArguments( 
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPWSTR pszArgs,
            /* [in] */ int cch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetArguments( 
            /* [string][in] */ __RPC__in LPCWSTR pszArgs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHotkey( 
            /* [out] */ __RPC__out WORD *pwHotkey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHotkey( 
            /* [in] */ WORD wHotkey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetShowCmd( 
            /* [out] */ __RPC__out int *piShowCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetShowCmd( 
            /* [in] */ int iShowCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIconLocation( 
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPWSTR pszIconPath,
            /* [in] */ int cch,
            /* [out] */ __RPC__out int *piIcon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIconLocation( 
            /* [string][in] */ __RPC__in LPCWSTR pszIconPath,
            /* [in] */ int iIcon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRelativePath( 
            /* [string][in] */ __RPC__in LPCWSTR pszPathRel,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resolve( 
            /* [unique][in] */ __RPC__in_opt HWND hwnd,
            /* [in] */ DWORD fFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPath( 
            /* [string][in] */ __RPC__in LPCWSTR pszFile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellLinkWVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellLinkW * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellLinkW * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellLinkW * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPath )( 
            IShellLinkW * This,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPWSTR pszFile,
            /* [in] */ int cch,
            /* [unique][out][in] */ __RPC__inout_opt WIN32_FIND_DATAW *pfd,
            /* [in] */ DWORD fFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDList )( 
            IShellLinkW * This,
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidl);
        
        HRESULT ( STDMETHODCALLTYPE *SetIDList )( 
            IShellLinkW * This,
            /* [unique][in] */ __RPC__in_opt PCIDLIST_ABSOLUTE pidl);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescription )( 
            IShellLinkW * This,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPWSTR pszName,
            int cch);
        
        HRESULT ( STDMETHODCALLTYPE *SetDescription )( 
            IShellLinkW * This,
            /* [string][in] */ __RPC__in LPCWSTR pszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetWorkingDirectory )( 
            IShellLinkW * This,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPWSTR pszDir,
            int cch);
        
        HRESULT ( STDMETHODCALLTYPE *SetWorkingDirectory )( 
            IShellLinkW * This,
            /* [string][in] */ __RPC__in LPCWSTR pszDir);
        
        HRESULT ( STDMETHODCALLTYPE *GetArguments )( 
            IShellLinkW * This,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPWSTR pszArgs,
            /* [in] */ int cch);
        
        HRESULT ( STDMETHODCALLTYPE *SetArguments )( 
            IShellLinkW * This,
            /* [string][in] */ __RPC__in LPCWSTR pszArgs);
        
        HRESULT ( STDMETHODCALLTYPE *GetHotkey )( 
            IShellLinkW * This,
            /* [out] */ __RPC__out WORD *pwHotkey);
        
        HRESULT ( STDMETHODCALLTYPE *SetHotkey )( 
            IShellLinkW * This,
            /* [in] */ WORD wHotkey);
        
        HRESULT ( STDMETHODCALLTYPE *GetShowCmd )( 
            IShellLinkW * This,
            /* [out] */ __RPC__out int *piShowCmd);
        
        HRESULT ( STDMETHODCALLTYPE *SetShowCmd )( 
            IShellLinkW * This,
            /* [in] */ int iShowCmd);
        
        HRESULT ( STDMETHODCALLTYPE *GetIconLocation )( 
            IShellLinkW * This,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPWSTR pszIconPath,
            /* [in] */ int cch,
            /* [out] */ __RPC__out int *piIcon);
        
        HRESULT ( STDMETHODCALLTYPE *SetIconLocation )( 
            IShellLinkW * This,
            /* [string][in] */ __RPC__in LPCWSTR pszIconPath,
            /* [in] */ int iIcon);
        
        HRESULT ( STDMETHODCALLTYPE *SetRelativePath )( 
            IShellLinkW * This,
            /* [string][in] */ __RPC__in LPCWSTR pszPathRel,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *Resolve )( 
            IShellLinkW * This,
            /* [unique][in] */ __RPC__in_opt HWND hwnd,
            /* [in] */ DWORD fFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetPath )( 
            IShellLinkW * This,
            /* [string][in] */ __RPC__in LPCWSTR pszFile);
        
        END_INTERFACE
    } IShellLinkWVtbl;

    interface IShellLinkW
    {
        CONST_VTBL struct IShellLinkWVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellLinkW_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellLinkW_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellLinkW_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellLinkW_GetPath(This,pszFile,cch,pfd,fFlags)	\
    ( (This)->lpVtbl -> GetPath(This,pszFile,cch,pfd,fFlags) ) 

#define IShellLinkW_GetIDList(This,ppidl)	\
    ( (This)->lpVtbl -> GetIDList(This,ppidl) ) 

#define IShellLinkW_SetIDList(This,pidl)	\
    ( (This)->lpVtbl -> SetIDList(This,pidl) ) 

#define IShellLinkW_GetDescription(This,pszName,cch)	\
    ( (This)->lpVtbl -> GetDescription(This,pszName,cch) ) 

#define IShellLinkW_SetDescription(This,pszName)	\
    ( (This)->lpVtbl -> SetDescription(This,pszName) ) 

#define IShellLinkW_GetWorkingDirectory(This,pszDir,cch)	\
    ( (This)->lpVtbl -> GetWorkingDirectory(This,pszDir,cch) ) 

#define IShellLinkW_SetWorkingDirectory(This,pszDir)	\
    ( (This)->lpVtbl -> SetWorkingDirectory(This,pszDir) ) 

#define IShellLinkW_GetArguments(This,pszArgs,cch)	\
    ( (This)->lpVtbl -> GetArguments(This,pszArgs,cch) ) 

#define IShellLinkW_SetArguments(This,pszArgs)	\
    ( (This)->lpVtbl -> SetArguments(This,pszArgs) ) 

#define IShellLinkW_GetHotkey(This,pwHotkey)	\
    ( (This)->lpVtbl -> GetHotkey(This,pwHotkey) ) 

#define IShellLinkW_SetHotkey(This,wHotkey)	\
    ( (This)->lpVtbl -> SetHotkey(This,wHotkey) ) 

#define IShellLinkW_GetShowCmd(This,piShowCmd)	\
    ( (This)->lpVtbl -> GetShowCmd(This,piShowCmd) ) 

#define IShellLinkW_SetShowCmd(This,iShowCmd)	\
    ( (This)->lpVtbl -> SetShowCmd(This,iShowCmd) ) 

#define IShellLinkW_GetIconLocation(This,pszIconPath,cch,piIcon)	\
    ( (This)->lpVtbl -> GetIconLocation(This,pszIconPath,cch,piIcon) ) 

#define IShellLinkW_SetIconLocation(This,pszIconPath,iIcon)	\
    ( (This)->lpVtbl -> SetIconLocation(This,pszIconPath,iIcon) ) 

#define IShellLinkW_SetRelativePath(This,pszPathRel,dwReserved)	\
    ( (This)->lpVtbl -> SetRelativePath(This,pszPathRel,dwReserved) ) 

#define IShellLinkW_Resolve(This,hwnd,fFlags)	\
    ( (This)->lpVtbl -> Resolve(This,hwnd,fFlags) ) 

#define IShellLinkW_SetPath(This,pszFile)	\
    ( (This)->lpVtbl -> SetPath(This,pszFile) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellLinkW_INTERFACE_DEFINED__ */


#ifndef __IShellLinkDataList_INTERFACE_DEFINED__
#define __IShellLinkDataList_INTERFACE_DEFINED__

/* interface IShellLinkDataList */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IShellLinkDataList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("45e2b4ae-b1c3-11d0-b92f-00a0c90312e1")
    IShellLinkDataList : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE AddDataBlock( 
            /* [in] */ 
            __in  void *pDataBlock) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CopyDataBlock( 
            /* [in] */ 
            __in  DWORD dwSig,
            /* [out] */ 
            __deref_out  void **ppDataBlock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveDataBlock( 
            /* [in] */ DWORD dwSig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFlags( 
            /* [out] */ __RPC__out DWORD *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFlags( 
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellLinkDataListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellLinkDataList * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellLinkDataList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellLinkDataList * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *AddDataBlock )( 
            IShellLinkDataList * This,
            /* [in] */ 
            __in  void *pDataBlock);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CopyDataBlock )( 
            IShellLinkDataList * This,
            /* [in] */ 
            __in  DWORD dwSig,
            /* [out] */ 
            __deref_out  void **ppDataBlock);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveDataBlock )( 
            IShellLinkDataList * This,
            /* [in] */ DWORD dwSig);
        
        HRESULT ( STDMETHODCALLTYPE *GetFlags )( 
            IShellLinkDataList * This,
            /* [out] */ __RPC__out DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetFlags )( 
            IShellLinkDataList * This,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IShellLinkDataListVtbl;

    interface IShellLinkDataList
    {
        CONST_VTBL struct IShellLinkDataListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellLinkDataList_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellLinkDataList_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellLinkDataList_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellLinkDataList_AddDataBlock(This,pDataBlock)	\
    ( (This)->lpVtbl -> AddDataBlock(This,pDataBlock) ) 

#define IShellLinkDataList_CopyDataBlock(This,dwSig,ppDataBlock)	\
    ( (This)->lpVtbl -> CopyDataBlock(This,dwSig,ppDataBlock) ) 

#define IShellLinkDataList_RemoveDataBlock(This,dwSig)	\
    ( (This)->lpVtbl -> RemoveDataBlock(This,dwSig) ) 

#define IShellLinkDataList_GetFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> GetFlags(This,pdwFlags) ) 

#define IShellLinkDataList_SetFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> SetFlags(This,dwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellLinkDataList_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0057 */
/* [local] */ 

#if (NTDDI_VERSION >= NTDDI_WIN2K)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0057_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0057_v0_0_s_ifspec;

#ifndef __IResolveShellLink_INTERFACE_DEFINED__
#define __IResolveShellLink_INTERFACE_DEFINED__

/* interface IResolveShellLink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IResolveShellLink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5cd52983-9449-11d2-963a-00c04f79adf0")
    IResolveShellLink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ResolveShellLink( 
            /* [in] */ __RPC__in_opt IUnknown *punkLink,
            /* [in] */ __RPC__in HWND hwnd,
            /* [in] */ DWORD fFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IResolveShellLinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IResolveShellLink * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IResolveShellLink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IResolveShellLink * This);
        
        HRESULT ( STDMETHODCALLTYPE *ResolveShellLink )( 
            IResolveShellLink * This,
            /* [in] */ __RPC__in_opt IUnknown *punkLink,
            /* [in] */ __RPC__in HWND hwnd,
            /* [in] */ DWORD fFlags);
        
        END_INTERFACE
    } IResolveShellLinkVtbl;

    interface IResolveShellLink
    {
        CONST_VTBL struct IResolveShellLinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResolveShellLink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IResolveShellLink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IResolveShellLink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IResolveShellLink_ResolveShellLink(This,punkLink,hwnd,fFlags)	\
    ( (This)->lpVtbl -> ResolveShellLink(This,punkLink,hwnd,fFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IResolveShellLink_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0058 */
/* [local] */ 

#endif  // NTDDI_WIN2K


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0058_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0058_v0_0_s_ifspec;

#ifndef __IActionProgressDialog_INTERFACE_DEFINED__
#define __IActionProgressDialog_INTERFACE_DEFINED__

/* interface IActionProgressDialog */
/* [unique][uuid][object] */ 

/* [v1_enum] */ 
enum tagSPINITF
    {	SPINITF_NORMAL	= 0,
	SPINITF_MODAL	= 0x1,
	SPINITF_NOMINIMIZE	= 0x8
    } ;
typedef DWORD SPINITF;


EXTERN_C const IID IID_IActionProgressDialog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("49ff1172-eadc-446d-9285-156453a6431c")
    IActionProgressDialog : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ SPINITF flags,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszTitle,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszCancel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActionProgressDialogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActionProgressDialog * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActionProgressDialog * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActionProgressDialog * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IActionProgressDialog * This,
            /* [in] */ SPINITF flags,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszTitle,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszCancel);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IActionProgressDialog * This);
        
        END_INTERFACE
    } IActionProgressDialogVtbl;

    interface IActionProgressDialog
    {
        CONST_VTBL struct IActionProgressDialogVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActionProgressDialog_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActionProgressDialog_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActionProgressDialog_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActionProgressDialog_Initialize(This,flags,pszTitle,pszCancel)	\
    ( (This)->lpVtbl -> Initialize(This,flags,pszTitle,pszCancel) ) 

#define IActionProgressDialog_Stop(This)	\
    ( (This)->lpVtbl -> Stop(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActionProgressDialog_INTERFACE_DEFINED__ */


#ifndef __IHWEventHandler_INTERFACE_DEFINED__
#define __IHWEventHandler_INTERFACE_DEFINED__

/* interface IHWEventHandler */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IHWEventHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C1FB73D0-EC3A-4ba2-B512-8CDB9187B6D1")
    IHWEventHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [string][in] */ __RPC__in LPCWSTR pszParams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HandleEvent( 
            /* [string][in] */ __RPC__in LPCWSTR pszDeviceID,
            /* [string][in] */ __RPC__in LPCWSTR pszAltDeviceID,
            /* [string][in] */ __RPC__in LPCWSTR pszEventType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HandleEventWithContent( 
            /* [string][in] */ __RPC__in LPCWSTR pszDeviceID,
            /* [string][in] */ __RPC__in LPCWSTR pszAltDeviceID,
            /* [string][in] */ __RPC__in LPCWSTR pszEventType,
            /* [string][in] */ __RPC__in LPCWSTR pszContentTypeHandler,
            /* [in] */ __RPC__in_opt IDataObject *pdataobject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHWEventHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHWEventHandler * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHWEventHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHWEventHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IHWEventHandler * This,
            /* [string][in] */ __RPC__in LPCWSTR pszParams);
        
        HRESULT ( STDMETHODCALLTYPE *HandleEvent )( 
            IHWEventHandler * This,
            /* [string][in] */ __RPC__in LPCWSTR pszDeviceID,
            /* [string][in] */ __RPC__in LPCWSTR pszAltDeviceID,
            /* [string][in] */ __RPC__in LPCWSTR pszEventType);
        
        HRESULT ( STDMETHODCALLTYPE *HandleEventWithContent )( 
            IHWEventHandler * This,
            /* [string][in] */ __RPC__in LPCWSTR pszDeviceID,
            /* [string][in] */ __RPC__in LPCWSTR pszAltDeviceID,
            /* [string][in] */ __RPC__in LPCWSTR pszEventType,
            /* [string][in] */ __RPC__in LPCWSTR pszContentTypeHandler,
            /* [in] */ __RPC__in_opt IDataObject *pdataobject);
        
        END_INTERFACE
    } IHWEventHandlerVtbl;

    interface IHWEventHandler
    {
        CONST_VTBL struct IHWEventHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHWEventHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IHWEventHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IHWEventHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IHWEventHandler_Initialize(This,pszParams)	\
    ( (This)->lpVtbl -> Initialize(This,pszParams) ) 

#define IHWEventHandler_HandleEvent(This,pszDeviceID,pszAltDeviceID,pszEventType)	\
    ( (This)->lpVtbl -> HandleEvent(This,pszDeviceID,pszAltDeviceID,pszEventType) ) 

#define IHWEventHandler_HandleEventWithContent(This,pszDeviceID,pszAltDeviceID,pszEventType,pszContentTypeHandler,pdataobject)	\
    ( (This)->lpVtbl -> HandleEventWithContent(This,pszDeviceID,pszAltDeviceID,pszEventType,pszContentTypeHandler,pdataobject) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IHWEventHandler_INTERFACE_DEFINED__ */


#ifndef __IHWEventHandler2_INTERFACE_DEFINED__
#define __IHWEventHandler2_INTERFACE_DEFINED__

/* interface IHWEventHandler2 */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IHWEventHandler2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CFCC809F-295D-42e8-9FFC-424B33C487E6")
    IHWEventHandler2 : public IHWEventHandler
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE HandleEventWithHWND( 
            /* [string][in] */ __RPC__in LPCWSTR pszDeviceID,
            /* [string][in] */ __RPC__in LPCWSTR pszAltDeviceID,
            /* [string][in] */ __RPC__in LPCWSTR pszEventType,
            /* [in] */ __RPC__in HWND hwndOwner) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHWEventHandler2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHWEventHandler2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHWEventHandler2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHWEventHandler2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IHWEventHandler2 * This,
            /* [string][in] */ __RPC__in LPCWSTR pszParams);
        
        HRESULT ( STDMETHODCALLTYPE *HandleEvent )( 
            IHWEventHandler2 * This,
            /* [string][in] */ __RPC__in LPCWSTR pszDeviceID,
            /* [string][in] */ __RPC__in LPCWSTR pszAltDeviceID,
            /* [string][in] */ __RPC__in LPCWSTR pszEventType);
        
        HRESULT ( STDMETHODCALLTYPE *HandleEventWithContent )( 
            IHWEventHandler2 * This,
            /* [string][in] */ __RPC__in LPCWSTR pszDeviceID,
            /* [string][in] */ __RPC__in LPCWSTR pszAltDeviceID,
            /* [string][in] */ __RPC__in LPCWSTR pszEventType,
            /* [string][in] */ __RPC__in LPCWSTR pszContentTypeHandler,
            /* [in] */ __RPC__in_opt IDataObject *pdataobject);
        
        HRESULT ( STDMETHODCALLTYPE *HandleEventWithHWND )( 
            IHWEventHandler2 * This,
            /* [string][in] */ __RPC__in LPCWSTR pszDeviceID,
            /* [string][in] */ __RPC__in LPCWSTR pszAltDeviceID,
            /* [string][in] */ __RPC__in LPCWSTR pszEventType,
            /* [in] */ __RPC__in HWND hwndOwner);
        
        END_INTERFACE
    } IHWEventHandler2Vtbl;

    interface IHWEventHandler2
    {
        CONST_VTBL struct IHWEventHandler2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHWEventHandler2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IHWEventHandler2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IHWEventHandler2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IHWEventHandler2_Initialize(This,pszParams)	\
    ( (This)->lpVtbl -> Initialize(This,pszParams) ) 

#define IHWEventHandler2_HandleEvent(This,pszDeviceID,pszAltDeviceID,pszEventType)	\
    ( (This)->lpVtbl -> HandleEvent(This,pszDeviceID,pszAltDeviceID,pszEventType) ) 

#define IHWEventHandler2_HandleEventWithContent(This,pszDeviceID,pszAltDeviceID,pszEventType,pszContentTypeHandler,pdataobject)	\
    ( (This)->lpVtbl -> HandleEventWithContent(This,pszDeviceID,pszAltDeviceID,pszEventType,pszContentTypeHandler,pdataobject) ) 


#define IHWEventHandler2_HandleEventWithHWND(This,pszDeviceID,pszAltDeviceID,pszEventType,hwndOwner)	\
    ( (This)->lpVtbl -> HandleEventWithHWND(This,pszDeviceID,pszAltDeviceID,pszEventType,hwndOwner) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IHWEventHandler2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0061 */
/* [local] */ 

#define ARCONTENT_AUTORUNINF             0x00000002   // That's the one we have today, and always had
#define ARCONTENT_AUDIOCD                0x00000004   // Audio CD (not MP3 and the like, the stuff you buy at the store)
#define ARCONTENT_DVDMOVIE               0x00000008   // DVD Movie (not MPEGs, the stuff you buy at the store)
#define ARCONTENT_BLANKCD                0x00000010   // Blank CD-R/CD-RW)
#define ARCONTENT_BLANKDVD               0x00000020   // Blank DVD-R/DVD-RW
#define ARCONTENT_UNKNOWNCONTENT         0x00000040   // Whatever files.  Mean that it's formatted.
#define ARCONTENT_AUTOPLAYPIX            0x00000080   // Any files classified by shell as image. (jpg, bmp, etc.)
#define ARCONTENT_AUTOPLAYMUSIC          0x00000100   // Any files classified by shell as music. (wma, mp3, etc.)
#define ARCONTENT_AUTOPLAYVIDEO          0x00000200   // Any files classified by shell as video. (mpg, avi, etc.)
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define ARCONTENT_VCD                    0x00000400   // VCD format
#define ARCONTENT_SVCD                   0x00000800   // Super-VCD format
#define ARCONTENT_DVDAUDIO               0x00001000   // DVD-Audio
#define ARCONTENT_HDDVD                  0x00002000   // HD DVD
#define ARCONTENT_BLURAY                 0x00004000   // Blu-ray Disc
#define ARCONTENT_NONE                   0x00000000   // Empty (but formatted)
#define ARCONTENT_MASK                   0x00007FFE   // Bits that denote valid content types
#define ARCONTENT_PHASE_UNKNOWN          0x00000000   // We can be in any phase.  This is XP behavior.
#define ARCONTENT_PHASE_PRESNIFF         0x10000000   // These are contents we know w/o scanning the media for complete data (e.g. Audio track, DVD Movie).
#define ARCONTENT_PHASE_SNIFFING         0x20000000   // We are in the middle of searching the media.  There could be more contents to be found than currently reported.
#define ARCONTENT_PHASE_FINAL            0x40000000   // We have finished searching; contents we report are final.
#define ARCONTENT_PHASE_MASK             0x70000000   // Bits that denote what phase we are in the Autoplay process.
#endif  // NTDDI_VISTA


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0061_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0061_v0_0_s_ifspec;

#ifndef __IQueryCancelAutoPlay_INTERFACE_DEFINED__
#define __IQueryCancelAutoPlay_INTERFACE_DEFINED__

/* interface IQueryCancelAutoPlay */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IQueryCancelAutoPlay;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DDEFE873-6997-4e68-BE26-39B633ADBE12")
    IQueryCancelAutoPlay : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AllowAutoPlay( 
            /* [string][in] */ __RPC__in LPCWSTR pszPath,
            /* [in] */ DWORD dwContentType,
            /* [string][in] */ __RPC__in LPCWSTR pszLabel,
            /* [in] */ DWORD dwSerialNumber) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IQueryCancelAutoPlayVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IQueryCancelAutoPlay * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IQueryCancelAutoPlay * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IQueryCancelAutoPlay * This);
        
        HRESULT ( STDMETHODCALLTYPE *AllowAutoPlay )( 
            IQueryCancelAutoPlay * This,
            /* [string][in] */ __RPC__in LPCWSTR pszPath,
            /* [in] */ DWORD dwContentType,
            /* [string][in] */ __RPC__in LPCWSTR pszLabel,
            /* [in] */ DWORD dwSerialNumber);
        
        END_INTERFACE
    } IQueryCancelAutoPlayVtbl;

    interface IQueryCancelAutoPlay
    {
        CONST_VTBL struct IQueryCancelAutoPlayVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IQueryCancelAutoPlay_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IQueryCancelAutoPlay_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IQueryCancelAutoPlay_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IQueryCancelAutoPlay_AllowAutoPlay(This,pszPath,dwContentType,pszLabel,dwSerialNumber)	\
    ( (This)->lpVtbl -> AllowAutoPlay(This,pszPath,dwContentType,pszLabel,dwSerialNumber) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IQueryCancelAutoPlay_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0062 */
/* [local] */ 

#if (NTDDI_VERSION >= NTDDI_VISTA)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0062_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0062_v0_0_s_ifspec;

#ifndef __IDynamicHWHandler_INTERFACE_DEFINED__
#define __IDynamicHWHandler_INTERFACE_DEFINED__

/* interface IDynamicHWHandler */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDynamicHWHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DC2601D7-059E-42fc-A09D-2AFD21B6D5F7")
    IDynamicHWHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDynamicInfo( 
            /* [string][in] */ __RPC__in LPCWSTR pszDeviceID,
            /* [in] */ DWORD dwContentType,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszAction) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDynamicHWHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDynamicHWHandler * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDynamicHWHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDynamicHWHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDynamicInfo )( 
            IDynamicHWHandler * This,
            /* [string][in] */ __RPC__in LPCWSTR pszDeviceID,
            /* [in] */ DWORD dwContentType,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszAction);
        
        END_INTERFACE
    } IDynamicHWHandlerVtbl;

    interface IDynamicHWHandler
    {
        CONST_VTBL struct IDynamicHWHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDynamicHWHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDynamicHWHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDynamicHWHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDynamicHWHandler_GetDynamicInfo(This,pszDeviceID,dwContentType,ppszAction)	\
    ( (This)->lpVtbl -> GetDynamicInfo(This,pszDeviceID,dwContentType,ppszAction) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDynamicHWHandler_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0063 */
/* [local] */ 

#endif  // NTDDI_VISTA


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0063_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0063_v0_0_s_ifspec;

#ifndef __IActionProgress_INTERFACE_DEFINED__
#define __IActionProgress_INTERFACE_DEFINED__

/* interface IActionProgress */
/* [unique][uuid][object] */ 

/* [v1_enum] */ 
enum tagSPBEGINF
    {	SPBEGINF_NORMAL	= 0,
	SPBEGINF_AUTOTIME	= 0x2,
	SPBEGINF_NOPROGRESSBAR	= 0x10,
	SPBEGINF_MARQUEEPROGRESS	= 0x20,
	SPBEGINF_NOCANCELBUTTON	= 0x40
    } ;
typedef DWORD SPBEGINF;

typedef /* [v1_enum] */ 
enum _SPACTION
    {	SPACTION_NONE	= 0,
	SPACTION_MOVING	= ( SPACTION_NONE + 1 ) ,
	SPACTION_COPYING	= ( SPACTION_MOVING + 1 ) ,
	SPACTION_RECYCLING	= ( SPACTION_COPYING + 1 ) ,
	SPACTION_APPLYINGATTRIBS	= ( SPACTION_RECYCLING + 1 ) ,
	SPACTION_DOWNLOADING	= ( SPACTION_APPLYINGATTRIBS + 1 ) ,
	SPACTION_SEARCHING_INTERNET	= ( SPACTION_DOWNLOADING + 1 ) ,
	SPACTION_CALCULATING	= ( SPACTION_SEARCHING_INTERNET + 1 ) ,
	SPACTION_UPLOADING	= ( SPACTION_CALCULATING + 1 ) ,
	SPACTION_SEARCHING_FILES	= ( SPACTION_UPLOADING + 1 ) ,
	SPACTION_DELETING	= ( SPACTION_SEARCHING_FILES + 1 ) ,
	SPACTION_RENAMING	= ( SPACTION_DELETING + 1 ) ,
	SPACTION_FORMATTING	= ( SPACTION_RENAMING + 1 ) 
    } 	SPACTION;

typedef /* [v1_enum] */ 
enum _SPTEXT
    {	SPTEXT_ACTIONDESCRIPTION	= 1,
	SPTEXT_ACTIONDETAIL	= ( SPTEXT_ACTIONDESCRIPTION + 1 ) 
    } 	SPTEXT;


EXTERN_C const IID IID_IActionProgress;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("49ff1173-eadc-446d-9285-156453a6431c")
    IActionProgress : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Begin( 
            /* [in] */ SPACTION action,
            /* [in] */ SPBEGINF flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateProgress( 
            /* [in] */ ULONGLONG ulCompleted,
            /* [in] */ ULONGLONG ulTotal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateText( 
            /* [in] */ SPTEXT sptext,
            /* [string][in] */ __RPC__in LPCWSTR pszText,
            /* [in] */ BOOL fMayCompact) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryCancel( 
            /* [out] */ __RPC__out BOOL *pfCancelled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetCancel( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE End( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActionProgressVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActionProgress * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActionProgress * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActionProgress * This);
        
        HRESULT ( STDMETHODCALLTYPE *Begin )( 
            IActionProgress * This,
            /* [in] */ SPACTION action,
            /* [in] */ SPBEGINF flags);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateProgress )( 
            IActionProgress * This,
            /* [in] */ ULONGLONG ulCompleted,
            /* [in] */ ULONGLONG ulTotal);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateText )( 
            IActionProgress * This,
            /* [in] */ SPTEXT sptext,
            /* [string][in] */ __RPC__in LPCWSTR pszText,
            /* [in] */ BOOL fMayCompact);
        
        HRESULT ( STDMETHODCALLTYPE *QueryCancel )( 
            IActionProgress * This,
            /* [out] */ __RPC__out BOOL *pfCancelled);
        
        HRESULT ( STDMETHODCALLTYPE *ResetCancel )( 
            IActionProgress * This);
        
        HRESULT ( STDMETHODCALLTYPE *End )( 
            IActionProgress * This);
        
        END_INTERFACE
    } IActionProgressVtbl;

    interface IActionProgress
    {
        CONST_VTBL struct IActionProgressVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActionProgress_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActionProgress_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActionProgress_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActionProgress_Begin(This,action,flags)	\
    ( (This)->lpVtbl -> Begin(This,action,flags) ) 

#define IActionProgress_UpdateProgress(This,ulCompleted,ulTotal)	\
    ( (This)->lpVtbl -> UpdateProgress(This,ulCompleted,ulTotal) ) 

#define IActionProgress_UpdateText(This,sptext,pszText,fMayCompact)	\
    ( (This)->lpVtbl -> UpdateText(This,sptext,pszText,fMayCompact) ) 

#define IActionProgress_QueryCancel(This,pfCancelled)	\
    ( (This)->lpVtbl -> QueryCancel(This,pfCancelled) ) 

#define IActionProgress_ResetCancel(This)	\
    ( (This)->lpVtbl -> ResetCancel(This) ) 

#define IActionProgress_End(This)	\
    ( (This)->lpVtbl -> End(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActionProgress_INTERFACE_DEFINED__ */


#ifndef __IShellExtInit_INTERFACE_DEFINED__
#define __IShellExtInit_INTERFACE_DEFINED__

/* interface IShellExtInit */
/* [unique][local][object][uuid] */ 


EXTERN_C const IID IID_IShellExtInit;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000214E8-0000-0000-C000-000000000046")
    IShellExtInit : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [unique][in] */ 
            __in_opt  PCIDLIST_ABSOLUTE pidlFolder,
            /* [unique][in] */ 
            __in_opt  IDataObject *pdtobj,
            /* [unique][in] */ 
            __in_opt  HKEY hkeyProgID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellExtInitVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellExtInit * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellExtInit * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellExtInit * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IShellExtInit * This,
            /* [unique][in] */ 
            __in_opt  PCIDLIST_ABSOLUTE pidlFolder,
            /* [unique][in] */ 
            __in_opt  IDataObject *pdtobj,
            /* [unique][in] */ 
            __in_opt  HKEY hkeyProgID);
        
        END_INTERFACE
    } IShellExtInitVtbl;

    interface IShellExtInit
    {
        CONST_VTBL struct IShellExtInitVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellExtInit_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellExtInit_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellExtInit_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellExtInit_Initialize(This,pidlFolder,pdtobj,hkeyProgID)	\
    ( (This)->lpVtbl -> Initialize(This,pidlFolder,pdtobj,hkeyProgID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellExtInit_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0065 */
/* [local] */ 

typedef IShellExtInit *LPSHELLEXTINIT;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0065_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0065_v0_0_s_ifspec;

#ifndef __IShellPropSheetExt_INTERFACE_DEFINED__
#define __IShellPropSheetExt_INTERFACE_DEFINED__

/* interface IShellPropSheetExt */
/* [unique][local][object][uuid] */ 


enum tagSHELLPROPSHEETEXTPAGEID
    {	EXPPS_FILETYPES	= 0x1
    } ;
typedef UINT EXPPS;


EXTERN_C const IID IID_IShellPropSheetExt;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000214E9-0000-0000-C000-000000000046")
    IShellPropSheetExt : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddPages( 
            /* [in] */ 
            __in  LPFNSVADDPROPSHEETPAGE pfnAddPage,
            /* [in] */ 
            __in  LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReplacePage( 
            /* [in] */ 
            __in  EXPPS uPageID,
            /* [in] */ 
            __in  LPFNSVADDPROPSHEETPAGE pfnReplaceWith,
            /* [in] */ 
            __in  LPARAM lParam) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellPropSheetExtVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellPropSheetExt * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellPropSheetExt * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellPropSheetExt * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddPages )( 
            IShellPropSheetExt * This,
            /* [in] */ 
            __in  LPFNSVADDPROPSHEETPAGE pfnAddPage,
            /* [in] */ 
            __in  LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *ReplacePage )( 
            IShellPropSheetExt * This,
            /* [in] */ 
            __in  EXPPS uPageID,
            /* [in] */ 
            __in  LPFNSVADDPROPSHEETPAGE pfnReplaceWith,
            /* [in] */ 
            __in  LPARAM lParam);
        
        END_INTERFACE
    } IShellPropSheetExtVtbl;

    interface IShellPropSheetExt
    {
        CONST_VTBL struct IShellPropSheetExtVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellPropSheetExt_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellPropSheetExt_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellPropSheetExt_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellPropSheetExt_AddPages(This,pfnAddPage,lParam)	\
    ( (This)->lpVtbl -> AddPages(This,pfnAddPage,lParam) ) 

#define IShellPropSheetExt_ReplacePage(This,uPageID,pfnReplaceWith,lParam)	\
    ( (This)->lpVtbl -> ReplacePage(This,uPageID,pfnReplaceWith,lParam) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellPropSheetExt_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0066 */
/* [local] */ 

typedef IShellPropSheetExt *LPSHELLPROPSHEETEXT;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0066_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0066_v0_0_s_ifspec;

#ifndef __IRemoteComputer_INTERFACE_DEFINED__
#define __IRemoteComputer_INTERFACE_DEFINED__

/* interface IRemoteComputer */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IRemoteComputer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000214FE-0000-0000-C000-000000000046")
    IRemoteComputer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [string][in] */ __RPC__in LPCWSTR pszMachine,
            /* [in] */ BOOL bEnumerating) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteComputerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRemoteComputer * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRemoteComputer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRemoteComputer * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IRemoteComputer * This,
            /* [string][in] */ __RPC__in LPCWSTR pszMachine,
            /* [in] */ BOOL bEnumerating);
        
        END_INTERFACE
    } IRemoteComputerVtbl;

    interface IRemoteComputer
    {
        CONST_VTBL struct IRemoteComputerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteComputer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRemoteComputer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRemoteComputer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRemoteComputer_Initialize(This,pszMachine,bEnumerating)	\
    ( (This)->lpVtbl -> Initialize(This,pszMachine,bEnumerating) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRemoteComputer_INTERFACE_DEFINED__ */


#ifndef __IQueryContinue_INTERFACE_DEFINED__
#define __IQueryContinue_INTERFACE_DEFINED__

/* interface IQueryContinue */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IQueryContinue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7307055c-b24a-486b-9f25-163e597a28a9")
    IQueryContinue : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryContinue( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IQueryContinueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IQueryContinue * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IQueryContinue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IQueryContinue * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryContinue )( 
            IQueryContinue * This);
        
        END_INTERFACE
    } IQueryContinueVtbl;

    interface IQueryContinue
    {
        CONST_VTBL struct IQueryContinueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IQueryContinue_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IQueryContinue_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IQueryContinue_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IQueryContinue_QueryContinue(This)	\
    ( (This)->lpVtbl -> QueryContinue(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IQueryContinue_INTERFACE_DEFINED__ */


#ifndef __IUserNotification_INTERFACE_DEFINED__
#define __IUserNotification_INTERFACE_DEFINED__

/* interface IUserNotification */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IUserNotification;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ba9711ba-5893-4787-a7e1-41277151550b")
    IUserNotification : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetBalloonInfo( 
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszTitle,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszText,
            /* [in] */ DWORD dwInfoFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBalloonRetry( 
            /* [in] */ DWORD dwShowTime,
            /* [in] */ DWORD dwInterval,
            /* [in] */ UINT cRetryCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIconInfo( 
            /* [unique][in] */ __RPC__in_opt HICON hIcon,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszToolTip) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Show( 
            /* [unique][in] */ __RPC__in_opt IQueryContinue *pqc,
            /* [in] */ DWORD dwContinuePollInterval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlaySound( 
            /* [string][in] */ __RPC__in LPCWSTR pszSoundName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUserNotificationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUserNotification * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUserNotification * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUserNotification * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetBalloonInfo )( 
            IUserNotification * This,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszTitle,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszText,
            /* [in] */ DWORD dwInfoFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetBalloonRetry )( 
            IUserNotification * This,
            /* [in] */ DWORD dwShowTime,
            /* [in] */ DWORD dwInterval,
            /* [in] */ UINT cRetryCount);
        
        HRESULT ( STDMETHODCALLTYPE *SetIconInfo )( 
            IUserNotification * This,
            /* [unique][in] */ __RPC__in_opt HICON hIcon,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszToolTip);
        
        HRESULT ( STDMETHODCALLTYPE *Show )( 
            IUserNotification * This,
            /* [unique][in] */ __RPC__in_opt IQueryContinue *pqc,
            /* [in] */ DWORD dwContinuePollInterval);
        
        HRESULT ( STDMETHODCALLTYPE *PlaySound )( 
            IUserNotification * This,
            /* [string][in] */ __RPC__in LPCWSTR pszSoundName);
        
        END_INTERFACE
    } IUserNotificationVtbl;

    interface IUserNotification
    {
        CONST_VTBL struct IUserNotificationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUserNotification_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUserNotification_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUserNotification_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUserNotification_SetBalloonInfo(This,pszTitle,pszText,dwInfoFlags)	\
    ( (This)->lpVtbl -> SetBalloonInfo(This,pszTitle,pszText,dwInfoFlags) ) 

#define IUserNotification_SetBalloonRetry(This,dwShowTime,dwInterval,cRetryCount)	\
    ( (This)->lpVtbl -> SetBalloonRetry(This,dwShowTime,dwInterval,cRetryCount) ) 

#define IUserNotification_SetIconInfo(This,hIcon,pszToolTip)	\
    ( (This)->lpVtbl -> SetIconInfo(This,hIcon,pszToolTip) ) 

#define IUserNotification_Show(This,pqc,dwContinuePollInterval)	\
    ( (This)->lpVtbl -> Show(This,pqc,dwContinuePollInterval) ) 

#define IUserNotification_PlaySound(This,pszSoundName)	\
    ( (This)->lpVtbl -> PlaySound(This,pszSoundName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUserNotification_INTERFACE_DEFINED__ */


#ifndef __IUserNotificationCallback_INTERFACE_DEFINED__
#define __IUserNotificationCallback_INTERFACE_DEFINED__

/* interface IUserNotificationCallback */
/* [object][uuid] */ 


EXTERN_C const IID IID_IUserNotificationCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("19108294-0441-4AFF-8013-FA0A730B0BEA")
    IUserNotificationCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnBalloonUserClick( 
            /* [in] */ __RPC__in POINT *pt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnLeftClick( 
            /* [in] */ __RPC__in POINT *pt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnContextMenu( 
            /* [in] */ __RPC__in POINT *pt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUserNotificationCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUserNotificationCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUserNotificationCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUserNotificationCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnBalloonUserClick )( 
            IUserNotificationCallback * This,
            /* [in] */ __RPC__in POINT *pt);
        
        HRESULT ( STDMETHODCALLTYPE *OnLeftClick )( 
            IUserNotificationCallback * This,
            /* [in] */ __RPC__in POINT *pt);
        
        HRESULT ( STDMETHODCALLTYPE *OnContextMenu )( 
            IUserNotificationCallback * This,
            /* [in] */ __RPC__in POINT *pt);
        
        END_INTERFACE
    } IUserNotificationCallbackVtbl;

    interface IUserNotificationCallback
    {
        CONST_VTBL struct IUserNotificationCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUserNotificationCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUserNotificationCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUserNotificationCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUserNotificationCallback_OnBalloonUserClick(This,pt)	\
    ( (This)->lpVtbl -> OnBalloonUserClick(This,pt) ) 

#define IUserNotificationCallback_OnLeftClick(This,pt)	\
    ( (This)->lpVtbl -> OnLeftClick(This,pt) ) 

#define IUserNotificationCallback_OnContextMenu(This,pt)	\
    ( (This)->lpVtbl -> OnContextMenu(This,pt) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUserNotificationCallback_INTERFACE_DEFINED__ */


#ifndef __IUserNotification2_INTERFACE_DEFINED__
#define __IUserNotification2_INTERFACE_DEFINED__

/* interface IUserNotification2 */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IUserNotification2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("215913CC-57EB-4FAB-AB5A-E5FA7BEA2A6C")
    IUserNotification2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetBalloonInfo( 
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszTitle,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszText,
            /* [in] */ DWORD dwInfoFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBalloonRetry( 
            /* [in] */ DWORD dwShowTime,
            /* [in] */ DWORD dwInterval,
            /* [in] */ UINT cRetryCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIconInfo( 
            /* [unique][in] */ __RPC__in_opt HICON hIcon,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszToolTip) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Show( 
            /* [unique][in] */ __RPC__in_opt IQueryContinue *pqc,
            /* [in] */ DWORD dwContinuePollInterval,
            /* [unique][in] */ __RPC__in_opt IUserNotificationCallback *pSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlaySound( 
            /* [string][in] */ __RPC__in LPCWSTR pszSoundName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUserNotification2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUserNotification2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUserNotification2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUserNotification2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetBalloonInfo )( 
            IUserNotification2 * This,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszTitle,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszText,
            /* [in] */ DWORD dwInfoFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetBalloonRetry )( 
            IUserNotification2 * This,
            /* [in] */ DWORD dwShowTime,
            /* [in] */ DWORD dwInterval,
            /* [in] */ UINT cRetryCount);
        
        HRESULT ( STDMETHODCALLTYPE *SetIconInfo )( 
            IUserNotification2 * This,
            /* [unique][in] */ __RPC__in_opt HICON hIcon,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszToolTip);
        
        HRESULT ( STDMETHODCALLTYPE *Show )( 
            IUserNotification2 * This,
            /* [unique][in] */ __RPC__in_opt IQueryContinue *pqc,
            /* [in] */ DWORD dwContinuePollInterval,
            /* [unique][in] */ __RPC__in_opt IUserNotificationCallback *pSink);
        
        HRESULT ( STDMETHODCALLTYPE *PlaySound )( 
            IUserNotification2 * This,
            /* [string][in] */ __RPC__in LPCWSTR pszSoundName);
        
        END_INTERFACE
    } IUserNotification2Vtbl;

    interface IUserNotification2
    {
        CONST_VTBL struct IUserNotification2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUserNotification2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUserNotification2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUserNotification2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUserNotification2_SetBalloonInfo(This,pszTitle,pszText,dwInfoFlags)	\
    ( (This)->lpVtbl -> SetBalloonInfo(This,pszTitle,pszText,dwInfoFlags) ) 

#define IUserNotification2_SetBalloonRetry(This,dwShowTime,dwInterval,cRetryCount)	\
    ( (This)->lpVtbl -> SetBalloonRetry(This,dwShowTime,dwInterval,cRetryCount) ) 

#define IUserNotification2_SetIconInfo(This,hIcon,pszToolTip)	\
    ( (This)->lpVtbl -> SetIconInfo(This,hIcon,pszToolTip) ) 

#define IUserNotification2_Show(This,pqc,dwContinuePollInterval,pSink)	\
    ( (This)->lpVtbl -> Show(This,pqc,dwContinuePollInterval,pSink) ) 

#define IUserNotification2_PlaySound(This,pszSoundName)	\
    ( (This)->lpVtbl -> PlaySound(This,pszSoundName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUserNotification2_INTERFACE_DEFINED__ */


#ifndef __IItemNameLimits_INTERFACE_DEFINED__
#define __IItemNameLimits_INTERFACE_DEFINED__

/* interface IItemNameLimits */
/* [object][uuid] */ 


EXTERN_C const IID IID_IItemNameLimits;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1df0d7f1-b267-4d28-8b10-12e23202a5c4")
    IItemNameLimits : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetValidCharacters( 
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszValidChars,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszInvalidChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxLength( 
            /* [string][in] */ __RPC__in LPCWSTR pszName,
            /* [out] */ __RPC__out int *piMaxNameLen) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IItemNameLimitsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IItemNameLimits * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IItemNameLimits * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IItemNameLimits * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetValidCharacters )( 
            IItemNameLimits * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszValidChars,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszInvalidChars);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxLength )( 
            IItemNameLimits * This,
            /* [string][in] */ __RPC__in LPCWSTR pszName,
            /* [out] */ __RPC__out int *piMaxNameLen);
        
        END_INTERFACE
    } IItemNameLimitsVtbl;

    interface IItemNameLimits
    {
        CONST_VTBL struct IItemNameLimitsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IItemNameLimits_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IItemNameLimits_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IItemNameLimits_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IItemNameLimits_GetValidCharacters(This,ppwszValidChars,ppwszInvalidChars)	\
    ( (This)->lpVtbl -> GetValidCharacters(This,ppwszValidChars,ppwszInvalidChars) ) 

#define IItemNameLimits_GetMaxLength(This,pszName,piMaxNameLen)	\
    ( (This)->lpVtbl -> GetMaxLength(This,pszName,piMaxNameLen) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IItemNameLimits_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0072 */
/* [local] */ 

#if (NTDDI_VERSION >= NTDDI_VISTA)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0072_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0072_v0_0_s_ifspec;

#ifndef __ISearchFolderItemFactory_INTERFACE_DEFINED__
#define __ISearchFolderItemFactory_INTERFACE_DEFINED__

/* interface ISearchFolderItemFactory */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISearchFolderItemFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a0ffbc28-5482-4366-be27-3e81e78e06c2")
    ISearchFolderItemFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetDisplayName( 
            /* [string][in] */ __RPC__in LPCWSTR pszDisplayName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFolderTypeID( 
            /* [in] */ FOLDERTYPEID ftid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFolderLogicalViewMode( 
            /* [in] */ FOLDERLOGICALVIEWMODE flvm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIconSize( 
            /* [in] */ int iIconSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetVisibleColumns( 
            /* [in] */ UINT cVisibleColumns,
            /* [size_is][in] */ __RPC__in_ecount_full(cVisibleColumns) PROPERTYKEY *rgKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSortColumns( 
            /* [in] */ UINT cSortColumns,
            /* [size_is][in] */ __RPC__in_ecount_full(cSortColumns) SORTCOLUMN *rgSortColumns) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetGroupColumn( 
            /* [in] */ __RPC__in REFPROPERTYKEY keyGroup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStacks( 
            /* [in] */ UINT cStackKeys,
            /* [size_is][in] */ __RPC__in_ecount_full(cStackKeys) PROPERTYKEY *rgStackKeys) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetScope( 
            /* [in] */ __RPC__in_opt IShellItemArray *psiaScope) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCondition( 
            /* [in] */ __RPC__in_opt ICondition *pCondition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetShellItem( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIDList( 
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISearchFolderItemFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISearchFolderItemFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISearchFolderItemFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISearchFolderItemFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDisplayName )( 
            ISearchFolderItemFactory * This,
            /* [string][in] */ __RPC__in LPCWSTR pszDisplayName);
        
        HRESULT ( STDMETHODCALLTYPE *SetFolderTypeID )( 
            ISearchFolderItemFactory * This,
            /* [in] */ FOLDERTYPEID ftid);
        
        HRESULT ( STDMETHODCALLTYPE *SetFolderLogicalViewMode )( 
            ISearchFolderItemFactory * This,
            /* [in] */ FOLDERLOGICALVIEWMODE flvm);
        
        HRESULT ( STDMETHODCALLTYPE *SetIconSize )( 
            ISearchFolderItemFactory * This,
            /* [in] */ int iIconSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetVisibleColumns )( 
            ISearchFolderItemFactory * This,
            /* [in] */ UINT cVisibleColumns,
            /* [size_is][in] */ __RPC__in_ecount_full(cVisibleColumns) PROPERTYKEY *rgKey);
        
        HRESULT ( STDMETHODCALLTYPE *SetSortColumns )( 
            ISearchFolderItemFactory * This,
            /* [in] */ UINT cSortColumns,
            /* [size_is][in] */ __RPC__in_ecount_full(cSortColumns) SORTCOLUMN *rgSortColumns);
        
        HRESULT ( STDMETHODCALLTYPE *SetGroupColumn )( 
            ISearchFolderItemFactory * This,
            /* [in] */ __RPC__in REFPROPERTYKEY keyGroup);
        
        HRESULT ( STDMETHODCALLTYPE *SetStacks )( 
            ISearchFolderItemFactory * This,
            /* [in] */ UINT cStackKeys,
            /* [size_is][in] */ __RPC__in_ecount_full(cStackKeys) PROPERTYKEY *rgStackKeys);
        
        HRESULT ( STDMETHODCALLTYPE *SetScope )( 
            ISearchFolderItemFactory * This,
            /* [in] */ __RPC__in_opt IShellItemArray *psiaScope);
        
        HRESULT ( STDMETHODCALLTYPE *SetCondition )( 
            ISearchFolderItemFactory * This,
            /* [in] */ __RPC__in_opt ICondition *pCondition);
        
        HRESULT ( STDMETHODCALLTYPE *GetShellItem )( 
            ISearchFolderItemFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDList )( 
            ISearchFolderItemFactory * This,
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidl);
        
        END_INTERFACE
    } ISearchFolderItemFactoryVtbl;

    interface ISearchFolderItemFactory
    {
        CONST_VTBL struct ISearchFolderItemFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISearchFolderItemFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISearchFolderItemFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISearchFolderItemFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISearchFolderItemFactory_SetDisplayName(This,pszDisplayName)	\
    ( (This)->lpVtbl -> SetDisplayName(This,pszDisplayName) ) 

#define ISearchFolderItemFactory_SetFolderTypeID(This,ftid)	\
    ( (This)->lpVtbl -> SetFolderTypeID(This,ftid) ) 

#define ISearchFolderItemFactory_SetFolderLogicalViewMode(This,flvm)	\
    ( (This)->lpVtbl -> SetFolderLogicalViewMode(This,flvm) ) 

#define ISearchFolderItemFactory_SetIconSize(This,iIconSize)	\
    ( (This)->lpVtbl -> SetIconSize(This,iIconSize) ) 

#define ISearchFolderItemFactory_SetVisibleColumns(This,cVisibleColumns,rgKey)	\
    ( (This)->lpVtbl -> SetVisibleColumns(This,cVisibleColumns,rgKey) ) 

#define ISearchFolderItemFactory_SetSortColumns(This,cSortColumns,rgSortColumns)	\
    ( (This)->lpVtbl -> SetSortColumns(This,cSortColumns,rgSortColumns) ) 

#define ISearchFolderItemFactory_SetGroupColumn(This,keyGroup)	\
    ( (This)->lpVtbl -> SetGroupColumn(This,keyGroup) ) 

#define ISearchFolderItemFactory_SetStacks(This,cStackKeys,rgStackKeys)	\
    ( (This)->lpVtbl -> SetStacks(This,cStackKeys,rgStackKeys) ) 

#define ISearchFolderItemFactory_SetScope(This,psiaScope)	\
    ( (This)->lpVtbl -> SetScope(This,psiaScope) ) 

#define ISearchFolderItemFactory_SetCondition(This,pCondition)	\
    ( (This)->lpVtbl -> SetCondition(This,pCondition) ) 

#define ISearchFolderItemFactory_GetShellItem(This,riid,ppv)	\
    ( (This)->lpVtbl -> GetShellItem(This,riid,ppv) ) 

#define ISearchFolderItemFactory_GetIDList(This,ppidl)	\
    ( (This)->lpVtbl -> GetIDList(This,ppidl) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISearchFolderItemFactory_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0073 */
/* [local] */ 

#endif  // NTDDI_VISTA
#if (_WIN32_IE >= 0x0400)
#define IEI_PRIORITY_MAX        ITSAT_MAX_PRIORITY
#define IEI_PRIORITY_MIN        ITSAT_MIN_PRIORITY
#define IEIT_PRIORITY_NORMAL     ITSAT_DEFAULT_PRIORITY
#define IEIFLAG_ASYNC       0x0001      // (deprecated) ask the extractor if it supports ASYNC extract (free threaded)
#define IEIFLAG_CACHE       0x0002      // returned from the extractor if it does NOT cache the thumbnail
#define IEIFLAG_ASPECT      0x0004      // passed to the extractor to beg it to render to the aspect ratio of the supplied rect
#define IEIFLAG_OFFLINE     0x0008      // if the extractor shouldn't hit the net to get any content neede for the rendering
#define IEIFLAG_GLEAM       0x0010      // does the image have a gleam ? this will be returned if it does
#define IEIFLAG_SCREEN      0x0020      // render as if for the screen  (this is exlusive with IEIFLAG_ASPECT )
#define IEIFLAG_ORIGSIZE    0x0040      // render to the approx size passed, but crop if neccessary
#define IEIFLAG_NOSTAMP     0x0080      // returned from the extractor if it does NOT want an icon stamp on the thumbnail
#define IEIFLAG_NOBORDER    0x0100      // returned from the extractor if it does NOT want an a border around the thumbnail
#define IEIFLAG_QUALITY     0x0200      // passed to the Extract method to indicate that a slower, higher quality image is desired, re-compute the thumbnail
#define IEIFLAG_REFRESH     0x0400      // returned from the extractor if it would like to have Refresh Thumbnail available


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0073_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0073_v0_0_s_ifspec;

#ifndef __IExtractImage_INTERFACE_DEFINED__
#define __IExtractImage_INTERFACE_DEFINED__

/* interface IExtractImage */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IExtractImage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BB2E617C-0920-11d1-9A0B-00C04FC2D6C1")
    IExtractImage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetLocation( 
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPWSTR pszPathBuffer,
            /* [in] */ DWORD cch,
            /* [unique][out][in] */ __RPC__inout_opt DWORD *pdwPriority,
            /* [in] */ __RPC__in const SIZE *prgSize,
            /* [in] */ DWORD dwRecClrDepth,
            /* [out][in] */ __RPC__inout DWORD *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Extract( 
            /* [out] */ __RPC__deref_out_opt HBITMAP *phBmpThumbnail) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExtractImageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IExtractImage * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IExtractImage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IExtractImage * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocation )( 
            IExtractImage * This,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPWSTR pszPathBuffer,
            /* [in] */ DWORD cch,
            /* [unique][out][in] */ __RPC__inout_opt DWORD *pdwPriority,
            /* [in] */ __RPC__in const SIZE *prgSize,
            /* [in] */ DWORD dwRecClrDepth,
            /* [out][in] */ __RPC__inout DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Extract )( 
            IExtractImage * This,
            /* [out] */ __RPC__deref_out_opt HBITMAP *phBmpThumbnail);
        
        END_INTERFACE
    } IExtractImageVtbl;

    interface IExtractImage
    {
        CONST_VTBL struct IExtractImageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExtractImage_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IExtractImage_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IExtractImage_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IExtractImage_GetLocation(This,pszPathBuffer,cch,pdwPriority,prgSize,dwRecClrDepth,pdwFlags)	\
    ( (This)->lpVtbl -> GetLocation(This,pszPathBuffer,cch,pdwPriority,prgSize,dwRecClrDepth,pdwFlags) ) 

#define IExtractImage_Extract(This,phBmpThumbnail)	\
    ( (This)->lpVtbl -> Extract(This,phBmpThumbnail) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IExtractImage_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0074 */
/* [local] */ 

typedef IExtractImage *LPEXTRACTIMAGE;

#endif
#if (_WIN32_IE >= 0x0500)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0074_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0074_v0_0_s_ifspec;

#ifndef __IExtractImage2_INTERFACE_DEFINED__
#define __IExtractImage2_INTERFACE_DEFINED__

/* interface IExtractImage2 */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IExtractImage2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("953BB1EE-93B4-11d1-98A3-00C04FB687DA")
    IExtractImage2 : public IExtractImage
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDateStamp( 
            /* [out] */ __RPC__out FILETIME *pDateStamp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExtractImage2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IExtractImage2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IExtractImage2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IExtractImage2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocation )( 
            IExtractImage2 * This,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPWSTR pszPathBuffer,
            /* [in] */ DWORD cch,
            /* [unique][out][in] */ __RPC__inout_opt DWORD *pdwPriority,
            /* [in] */ __RPC__in const SIZE *prgSize,
            /* [in] */ DWORD dwRecClrDepth,
            /* [out][in] */ __RPC__inout DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Extract )( 
            IExtractImage2 * This,
            /* [out] */ __RPC__deref_out_opt HBITMAP *phBmpThumbnail);
        
        HRESULT ( STDMETHODCALLTYPE *GetDateStamp )( 
            IExtractImage2 * This,
            /* [out] */ __RPC__out FILETIME *pDateStamp);
        
        END_INTERFACE
    } IExtractImage2Vtbl;

    interface IExtractImage2
    {
        CONST_VTBL struct IExtractImage2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExtractImage2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IExtractImage2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IExtractImage2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IExtractImage2_GetLocation(This,pszPathBuffer,cch,pdwPriority,prgSize,dwRecClrDepth,pdwFlags)	\
    ( (This)->lpVtbl -> GetLocation(This,pszPathBuffer,cch,pdwPriority,prgSize,dwRecClrDepth,pdwFlags) ) 

#define IExtractImage2_Extract(This,phBmpThumbnail)	\
    ( (This)->lpVtbl -> Extract(This,phBmpThumbnail) ) 


#define IExtractImage2_GetDateStamp(This,pDateStamp)	\
    ( (This)->lpVtbl -> GetDateStamp(This,pDateStamp) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IExtractImage2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0075 */
/* [local] */ 

typedef IExtractImage2 *LPEXTRACTIMAGE2;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0075_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0075_v0_0_s_ifspec;

#ifndef __IThumbnailHandlerFactory_INTERFACE_DEFINED__
#define __IThumbnailHandlerFactory_INTERFACE_DEFINED__

/* interface IThumbnailHandlerFactory */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IThumbnailHandlerFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e35b4b2e-00da-4bc1-9f13-38bc11f5d417")
    IThumbnailHandlerFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetThumbnailHandler( 
            /* [in] */ __RPC__in PCUITEMID_CHILD pidlChild,
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbc,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IThumbnailHandlerFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IThumbnailHandlerFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IThumbnailHandlerFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IThumbnailHandlerFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetThumbnailHandler )( 
            IThumbnailHandlerFactory * This,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidlChild,
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbc,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        END_INTERFACE
    } IThumbnailHandlerFactoryVtbl;

    interface IThumbnailHandlerFactory
    {
        CONST_VTBL struct IThumbnailHandlerFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IThumbnailHandlerFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IThumbnailHandlerFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IThumbnailHandlerFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IThumbnailHandlerFactory_GetThumbnailHandler(This,pidlChild,pbc,riid,ppv)	\
    ( (This)->lpVtbl -> GetThumbnailHandler(This,pidlChild,pbc,riid,ppv) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IThumbnailHandlerFactory_INTERFACE_DEFINED__ */


#ifndef __IParentAndItem_INTERFACE_DEFINED__
#define __IParentAndItem_INTERFACE_DEFINED__

/* interface IParentAndItem */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IParentAndItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b3a4b685-b685-4805-99d9-5dead2873236")
    IParentAndItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetParentAndItem( 
            /* [unique][in] */ __RPC__in_opt PCIDLIST_ABSOLUTE pidlParent,
            /* [unique][in] */ __RPC__in_opt IShellFolder *psf,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidlChild) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParentAndItem( 
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidlParent,
            /* [out] */ __RPC__deref_out_opt IShellFolder **ppsf,
            /* [out] */ __RPC__deref_out_opt PITEMID_CHILD *ppidlChild) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IParentAndItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IParentAndItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IParentAndItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IParentAndItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetParentAndItem )( 
            IParentAndItem * This,
            /* [unique][in] */ __RPC__in_opt PCIDLIST_ABSOLUTE pidlParent,
            /* [unique][in] */ __RPC__in_opt IShellFolder *psf,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidlChild);
        
        HRESULT ( STDMETHODCALLTYPE *GetParentAndItem )( 
            IParentAndItem * This,
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidlParent,
            /* [out] */ __RPC__deref_out_opt IShellFolder **ppsf,
            /* [out] */ __RPC__deref_out_opt PITEMID_CHILD *ppidlChild);
        
        END_INTERFACE
    } IParentAndItemVtbl;

    interface IParentAndItem
    {
        CONST_VTBL struct IParentAndItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IParentAndItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IParentAndItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IParentAndItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IParentAndItem_SetParentAndItem(This,pidlParent,psf,pidlChild)	\
    ( (This)->lpVtbl -> SetParentAndItem(This,pidlParent,psf,pidlChild) ) 

#define IParentAndItem_GetParentAndItem(This,ppidlParent,ppsf,ppidlChild)	\
    ( (This)->lpVtbl -> GetParentAndItem(This,ppidlParent,ppsf,ppidlChild) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IParentAndItem_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0077 */
/* [local] */ 

#endif


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0077_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0077_v0_0_s_ifspec;

#ifndef __IDockingWindow_INTERFACE_DEFINED__
#define __IDockingWindow_INTERFACE_DEFINED__

/* interface IDockingWindow */
/* [object][uuid] */ 


EXTERN_C const IID IID_IDockingWindow;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("012dd920-7b26-11d0-8ca9-00a0c92dbfe8")
    IDockingWindow : public IOleWindow
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ShowDW( 
            /* [in] */ BOOL fShow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CloseDW( 
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResizeBorderDW( 
            /* [in] */ __RPC__in LPCRECT prcBorder,
            /* [in] */ __RPC__in_opt IUnknown *punkToolbarSite,
            /* [in] */ BOOL fReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDockingWindowVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDockingWindow * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDockingWindow * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDockingWindow * This);
        
        /* [input_sync] */ HRESULT ( STDMETHODCALLTYPE *GetWindow )( 
            IDockingWindow * This,
            /* [out] */ __RPC__deref_out_opt HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *ContextSensitiveHelp )( 
            IDockingWindow * This,
            /* [in] */ BOOL fEnterMode);
        
        HRESULT ( STDMETHODCALLTYPE *ShowDW )( 
            IDockingWindow * This,
            /* [in] */ BOOL fShow);
        
        HRESULT ( STDMETHODCALLTYPE *CloseDW )( 
            IDockingWindow * This,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *ResizeBorderDW )( 
            IDockingWindow * This,
            /* [in] */ __RPC__in LPCRECT prcBorder,
            /* [in] */ __RPC__in_opt IUnknown *punkToolbarSite,
            /* [in] */ BOOL fReserved);
        
        END_INTERFACE
    } IDockingWindowVtbl;

    interface IDockingWindow
    {
        CONST_VTBL struct IDockingWindowVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDockingWindow_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDockingWindow_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDockingWindow_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDockingWindow_GetWindow(This,phwnd)	\
    ( (This)->lpVtbl -> GetWindow(This,phwnd) ) 

#define IDockingWindow_ContextSensitiveHelp(This,fEnterMode)	\
    ( (This)->lpVtbl -> ContextSensitiveHelp(This,fEnterMode) ) 


#define IDockingWindow_ShowDW(This,fShow)	\
    ( (This)->lpVtbl -> ShowDW(This,fShow) ) 

#define IDockingWindow_CloseDW(This,dwReserved)	\
    ( (This)->lpVtbl -> CloseDW(This,dwReserved) ) 

#define IDockingWindow_ResizeBorderDW(This,prcBorder,punkToolbarSite,fReserved)	\
    ( (This)->lpVtbl -> ResizeBorderDW(This,prcBorder,punkToolbarSite,fReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDockingWindow_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0078 */
/* [local] */ 

#define DBIM_MINSIZE    0x0001
#define DBIM_MAXSIZE    0x0002
#define DBIM_INTEGRAL   0x0004
#define DBIM_ACTUAL     0x0008
#define DBIM_TITLE      0x0010
#define DBIM_MODEFLAGS  0x0020
#define DBIM_BKCOLOR    0x0040
#include <pshpack8.h>
typedef struct tagDESKBANDINFO
    {
    DWORD dwMask;
    POINTL ptMinSize;
    POINTL ptMaxSize;
    POINTL ptIntegral;
    POINTL ptActual;
    WCHAR wszTitle[ 256 ];
    DWORD dwModeFlags;
    COLORREF crBkgnd;
    } 	DESKBANDINFO;

#include <poppack.h>
#define DBIMF_NORMAL            0x0000
#define DBIMF_FIXED             0x0001
#define DBIMF_FIXEDBMP          0x0004   // a fixed background bitmap (if supported)
#define DBIMF_VARIABLEHEIGHT    0x0008
#define DBIMF_UNDELETEABLE      0x0010
#define DBIMF_DEBOSSED          0x0020
#define DBIMF_BKCOLOR           0x0040
#define DBIMF_USECHEVRON        0x0080
#define DBIMF_BREAK             0x0100
#define DBIMF_ADDTOFRONT        0x0200
#define DBIMF_TOPALIGN          0x0400
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define DBIMF_NOGRIPPER         0x0800
#define DBIMF_ALWAYSGRIPPER     0x1000
#define DBIMF_NOMARGINS         0x2000
#endif  // NTDDI_VISTA
#define DBIF_VIEWMODE_NORMAL         0x0000
#define DBIF_VIEWMODE_VERTICAL       0x0001
#define DBIF_VIEWMODE_FLOATING       0x0002
#define DBIF_VIEWMODE_TRANSPARENT    0x0004

enum tagDESKBANDCID
    {	DBID_BANDINFOCHANGED	= 0,
	DBID_SHOWONLY	= 1,
	DBID_MAXIMIZEBAND	= 2,
	DBID_PUSHCHEVRON	= 3,
	DBID_DELAYINIT	= 4,
	DBID_FINISHINIT	= 5,
	DBID_SETWINDOWTHEME	= 6,
	DBID_PERMITAUTOHIDE	= 7
    } ;
#define DBPC_SELECTFIRST    (DWORD)-1
#define DBPC_SELECTLAST     (DWORD)-2
#define CGID_DeskBand IID_IDeskBand


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0078_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0078_v0_0_s_ifspec;

#ifndef __IDeskBand_INTERFACE_DEFINED__
#define __IDeskBand_INTERFACE_DEFINED__

/* interface IDeskBand */
/* [object][uuid] */ 


EXTERN_C const IID IID_IDeskBand;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EB0FE172-1A3A-11D0-89B3-00A0C90A90AC")
    IDeskBand : public IDockingWindow
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetBandInfo( 
            /* [in] */ DWORD dwBandID,
            /* [in] */ DWORD dwViewMode,
            /* [out][in] */ __RPC__inout DESKBANDINFO *pdbi) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDeskBandVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDeskBand * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDeskBand * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDeskBand * This);
        
        /* [input_sync] */ HRESULT ( STDMETHODCALLTYPE *GetWindow )( 
            IDeskBand * This,
            /* [out] */ __RPC__deref_out_opt HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *ContextSensitiveHelp )( 
            IDeskBand * This,
            /* [in] */ BOOL fEnterMode);
        
        HRESULT ( STDMETHODCALLTYPE *ShowDW )( 
            IDeskBand * This,
            /* [in] */ BOOL fShow);
        
        HRESULT ( STDMETHODCALLTYPE *CloseDW )( 
            IDeskBand * This,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *ResizeBorderDW )( 
            IDeskBand * This,
            /* [in] */ __RPC__in LPCRECT prcBorder,
            /* [in] */ __RPC__in_opt IUnknown *punkToolbarSite,
            /* [in] */ BOOL fReserved);
        
        HRESULT ( STDMETHODCALLTYPE *GetBandInfo )( 
            IDeskBand * This,
            /* [in] */ DWORD dwBandID,
            /* [in] */ DWORD dwViewMode,
            /* [out][in] */ __RPC__inout DESKBANDINFO *pdbi);
        
        END_INTERFACE
    } IDeskBandVtbl;

    interface IDeskBand
    {
        CONST_VTBL struct IDeskBandVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDeskBand_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDeskBand_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDeskBand_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDeskBand_GetWindow(This,phwnd)	\
    ( (This)->lpVtbl -> GetWindow(This,phwnd) ) 

#define IDeskBand_ContextSensitiveHelp(This,fEnterMode)	\
    ( (This)->lpVtbl -> ContextSensitiveHelp(This,fEnterMode) ) 


#define IDeskBand_ShowDW(This,fShow)	\
    ( (This)->lpVtbl -> ShowDW(This,fShow) ) 

#define IDeskBand_CloseDW(This,dwReserved)	\
    ( (This)->lpVtbl -> CloseDW(This,dwReserved) ) 

#define IDeskBand_ResizeBorderDW(This,prcBorder,punkToolbarSite,fReserved)	\
    ( (This)->lpVtbl -> ResizeBorderDW(This,prcBorder,punkToolbarSite,fReserved) ) 


#define IDeskBand_GetBandInfo(This,dwBandID,dwViewMode,pdbi)	\
    ( (This)->lpVtbl -> GetBandInfo(This,dwBandID,dwViewMode,pdbi) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDeskBand_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0079 */
/* [local] */ 

#if (NTDDI_VERSION >= NTDDI_VISTA)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0079_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0079_v0_0_s_ifspec;

#ifndef __IDeskBandInfo_INTERFACE_DEFINED__
#define __IDeskBandInfo_INTERFACE_DEFINED__

/* interface IDeskBandInfo */
/* [object][uuid] */ 


EXTERN_C const IID IID_IDeskBandInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("77E425FC-CBF9-4307-BA6A-BB5727745661")
    IDeskBandInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDefaultBandWidth( 
            /* [in] */ DWORD dwBandID,
            /* [in] */ DWORD dwViewMode,
            /* [out] */ __RPC__out int *pnWidth) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDeskBandInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDeskBandInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDeskBandInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDeskBandInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultBandWidth )( 
            IDeskBandInfo * This,
            /* [in] */ DWORD dwBandID,
            /* [in] */ DWORD dwViewMode,
            /* [out] */ __RPC__out int *pnWidth);
        
        END_INTERFACE
    } IDeskBandInfoVtbl;

    interface IDeskBandInfo
    {
        CONST_VTBL struct IDeskBandInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDeskBandInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDeskBandInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDeskBandInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDeskBandInfo_GetDefaultBandWidth(This,dwBandID,dwViewMode,pnWidth)	\
    ( (This)->lpVtbl -> GetDefaultBandWidth(This,dwBandID,dwViewMode,pnWidth) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDeskBandInfo_INTERFACE_DEFINED__ */


#ifndef __IDeskBand2_INTERFACE_DEFINED__
#define __IDeskBand2_INTERFACE_DEFINED__

/* interface IDeskBand2 */
/* [object][uuid] */ 


EXTERN_C const IID IID_IDeskBand2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79D16DE4-ABEE-4021-8D9D-9169B261D657")
    IDeskBand2 : public IDeskBand
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CanRenderComposited( 
            /* [out] */ __RPC__out BOOL *pfCanRenderComposited) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionState( 
            /* [in] */ BOOL fCompositionEnabled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionState( 
            /* [out] */ __RPC__out BOOL *pfCompositionEnabled) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDeskBand2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDeskBand2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDeskBand2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDeskBand2 * This);
        
        /* [input_sync] */ HRESULT ( STDMETHODCALLTYPE *GetWindow )( 
            IDeskBand2 * This,
            /* [out] */ __RPC__deref_out_opt HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *ContextSensitiveHelp )( 
            IDeskBand2 * This,
            /* [in] */ BOOL fEnterMode);
        
        HRESULT ( STDMETHODCALLTYPE *ShowDW )( 
            IDeskBand2 * This,
            /* [in] */ BOOL fShow);
        
        HRESULT ( STDMETHODCALLTYPE *CloseDW )( 
            IDeskBand2 * This,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *ResizeBorderDW )( 
            IDeskBand2 * This,
            /* [in] */ __RPC__in LPCRECT prcBorder,
            /* [in] */ __RPC__in_opt IUnknown *punkToolbarSite,
            /* [in] */ BOOL fReserved);
        
        HRESULT ( STDMETHODCALLTYPE *GetBandInfo )( 
            IDeskBand2 * This,
            /* [in] */ DWORD dwBandID,
            /* [in] */ DWORD dwViewMode,
            /* [out][in] */ __RPC__inout DESKBANDINFO *pdbi);
        
        HRESULT ( STDMETHODCALLTYPE *CanRenderComposited )( 
            IDeskBand2 * This,
            /* [out] */ __RPC__out BOOL *pfCanRenderComposited);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionState )( 
            IDeskBand2 * This,
            /* [in] */ BOOL fCompositionEnabled);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionState )( 
            IDeskBand2 * This,
            /* [out] */ __RPC__out BOOL *pfCompositionEnabled);
        
        END_INTERFACE
    } IDeskBand2Vtbl;

    interface IDeskBand2
    {
        CONST_VTBL struct IDeskBand2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDeskBand2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDeskBand2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDeskBand2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDeskBand2_GetWindow(This,phwnd)	\
    ( (This)->lpVtbl -> GetWindow(This,phwnd) ) 

#define IDeskBand2_ContextSensitiveHelp(This,fEnterMode)	\
    ( (This)->lpVtbl -> ContextSensitiveHelp(This,fEnterMode) ) 


#define IDeskBand2_ShowDW(This,fShow)	\
    ( (This)->lpVtbl -> ShowDW(This,fShow) ) 

#define IDeskBand2_CloseDW(This,dwReserved)	\
    ( (This)->lpVtbl -> CloseDW(This,dwReserved) ) 

#define IDeskBand2_ResizeBorderDW(This,prcBorder,punkToolbarSite,fReserved)	\
    ( (This)->lpVtbl -> ResizeBorderDW(This,prcBorder,punkToolbarSite,fReserved) ) 


#define IDeskBand2_GetBandInfo(This,dwBandID,dwViewMode,pdbi)	\
    ( (This)->lpVtbl -> GetBandInfo(This,dwBandID,dwViewMode,pdbi) ) 


#define IDeskBand2_CanRenderComposited(This,pfCanRenderComposited)	\
    ( (This)->lpVtbl -> CanRenderComposited(This,pfCanRenderComposited) ) 

#define IDeskBand2_SetCompositionState(This,fCompositionEnabled)	\
    ( (This)->lpVtbl -> SetCompositionState(This,fCompositionEnabled) ) 

#define IDeskBand2_GetCompositionState(This,pfCompositionEnabled)	\
    ( (This)->lpVtbl -> GetCompositionState(This,pfCompositionEnabled) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDeskBand2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0081 */
/* [local] */ 

#endif  // NTDDI_VISTA


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0081_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0081_v0_0_s_ifspec;

#ifndef __ITaskbarList_INTERFACE_DEFINED__
#define __ITaskbarList_INTERFACE_DEFINED__

/* interface ITaskbarList */
/* [object][uuid] */ 


EXTERN_C const IID IID_ITaskbarList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56FDF342-FD6D-11d0-958A-006097C9A090")
    ITaskbarList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE HrInit( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddTab( 
            /* [in] */ __RPC__in HWND hwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteTab( 
            /* [in] */ __RPC__in HWND hwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ActivateTab( 
            /* [in] */ __RPC__in HWND hwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetActiveAlt( 
            /* [in] */ __RPC__in HWND hwnd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITaskbarListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITaskbarList * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITaskbarList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITaskbarList * This);
        
        HRESULT ( STDMETHODCALLTYPE *HrInit )( 
            ITaskbarList * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddTab )( 
            ITaskbarList * This,
            /* [in] */ __RPC__in HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteTab )( 
            ITaskbarList * This,
            /* [in] */ __RPC__in HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE *ActivateTab )( 
            ITaskbarList * This,
            /* [in] */ __RPC__in HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE *SetActiveAlt )( 
            ITaskbarList * This,
            /* [in] */ __RPC__in HWND hwnd);
        
        END_INTERFACE
    } ITaskbarListVtbl;

    interface ITaskbarList
    {
        CONST_VTBL struct ITaskbarListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITaskbarList_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITaskbarList_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITaskbarList_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITaskbarList_HrInit(This)	\
    ( (This)->lpVtbl -> HrInit(This) ) 

#define ITaskbarList_AddTab(This,hwnd)	\
    ( (This)->lpVtbl -> AddTab(This,hwnd) ) 

#define ITaskbarList_DeleteTab(This,hwnd)	\
    ( (This)->lpVtbl -> DeleteTab(This,hwnd) ) 

#define ITaskbarList_ActivateTab(This,hwnd)	\
    ( (This)->lpVtbl -> ActivateTab(This,hwnd) ) 

#define ITaskbarList_SetActiveAlt(This,hwnd)	\
    ( (This)->lpVtbl -> SetActiveAlt(This,hwnd) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITaskbarList_INTERFACE_DEFINED__ */


#ifndef __ITaskbarList2_INTERFACE_DEFINED__
#define __ITaskbarList2_INTERFACE_DEFINED__

/* interface ITaskbarList2 */
/* [object][uuid] */ 


EXTERN_C const IID IID_ITaskbarList2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("602D4995-B13A-429b-A66E-1935E44F4317")
    ITaskbarList2 : public ITaskbarList
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE MarkFullscreenWindow( 
            /* [in] */ __RPC__in HWND hwnd,
            /* [in] */ BOOL fFullscreen) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITaskbarList2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITaskbarList2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITaskbarList2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITaskbarList2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *HrInit )( 
            ITaskbarList2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddTab )( 
            ITaskbarList2 * This,
            /* [in] */ __RPC__in HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteTab )( 
            ITaskbarList2 * This,
            /* [in] */ __RPC__in HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE *ActivateTab )( 
            ITaskbarList2 * This,
            /* [in] */ __RPC__in HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE *SetActiveAlt )( 
            ITaskbarList2 * This,
            /* [in] */ __RPC__in HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE *MarkFullscreenWindow )( 
            ITaskbarList2 * This,
            /* [in] */ __RPC__in HWND hwnd,
            /* [in] */ BOOL fFullscreen);
        
        END_INTERFACE
    } ITaskbarList2Vtbl;

    interface ITaskbarList2
    {
        CONST_VTBL struct ITaskbarList2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITaskbarList2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITaskbarList2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITaskbarList2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITaskbarList2_HrInit(This)	\
    ( (This)->lpVtbl -> HrInit(This) ) 

#define ITaskbarList2_AddTab(This,hwnd)	\
    ( (This)->lpVtbl -> AddTab(This,hwnd) ) 

#define ITaskbarList2_DeleteTab(This,hwnd)	\
    ( (This)->lpVtbl -> DeleteTab(This,hwnd) ) 

#define ITaskbarList2_ActivateTab(This,hwnd)	\
    ( (This)->lpVtbl -> ActivateTab(This,hwnd) ) 

#define ITaskbarList2_SetActiveAlt(This,hwnd)	\
    ( (This)->lpVtbl -> SetActiveAlt(This,hwnd) ) 


#define ITaskbarList2_MarkFullscreenWindow(This,hwnd,fFullscreen)	\
    ( (This)->lpVtbl -> MarkFullscreenWindow(This,hwnd,fFullscreen) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITaskbarList2_INTERFACE_DEFINED__ */


#ifndef __IStartMenuPinnedList_INTERFACE_DEFINED__
#define __IStartMenuPinnedList_INTERFACE_DEFINED__

/* interface IStartMenuPinnedList */
/* [object][uuid] */ 


EXTERN_C const IID IID_IStartMenuPinnedList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4CD19ADA-25A5-4A32-B3B7-347BEE5BE36B")
    IStartMenuPinnedList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RemoveFromList( 
            /* [in] */ __RPC__in_opt IShellItem *pitem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStartMenuPinnedListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IStartMenuPinnedList * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IStartMenuPinnedList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IStartMenuPinnedList * This);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveFromList )( 
            IStartMenuPinnedList * This,
            /* [in] */ __RPC__in_opt IShellItem *pitem);
        
        END_INTERFACE
    } IStartMenuPinnedListVtbl;

    interface IStartMenuPinnedList
    {
        CONST_VTBL struct IStartMenuPinnedListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStartMenuPinnedList_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IStartMenuPinnedList_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IStartMenuPinnedList_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IStartMenuPinnedList_RemoveFromList(This,pitem)	\
    ( (This)->lpVtbl -> RemoveFromList(This,pitem) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IStartMenuPinnedList_INTERFACE_DEFINED__ */


#ifndef __ICDBurn_INTERFACE_DEFINED__
#define __ICDBurn_INTERFACE_DEFINED__

/* interface ICDBurn */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICDBurn;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3d73a659-e5d0-4d42-afc0-5121ba425c8d")
    ICDBurn : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRecorderDriveLetter( 
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPWSTR pszDrive,
            /* [in] */ UINT cch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Burn( 
            /* [in] */ __RPC__in HWND hwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HasRecordableDrive( 
            /* [out] */ __RPC__out BOOL *pfHasRecorder) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICDBurnVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICDBurn * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICDBurn * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICDBurn * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecorderDriveLetter )( 
            ICDBurn * This,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPWSTR pszDrive,
            /* [in] */ UINT cch);
        
        HRESULT ( STDMETHODCALLTYPE *Burn )( 
            ICDBurn * This,
            /* [in] */ __RPC__in HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE *HasRecordableDrive )( 
            ICDBurn * This,
            /* [out] */ __RPC__out BOOL *pfHasRecorder);
        
        END_INTERFACE
    } ICDBurnVtbl;

    interface ICDBurn
    {
        CONST_VTBL struct ICDBurnVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICDBurn_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICDBurn_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICDBurn_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICDBurn_GetRecorderDriveLetter(This,pszDrive,cch)	\
    ( (This)->lpVtbl -> GetRecorderDriveLetter(This,pszDrive,cch) ) 

#define ICDBurn_Burn(This,hwnd)	\
    ( (This)->lpVtbl -> Burn(This,hwnd) ) 

#define ICDBurn_HasRecordableDrive(This,pfHasRecorder)	\
    ( (This)->lpVtbl -> HasRecordableDrive(This,pfHasRecorder) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICDBurn_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0085 */
/* [local] */ 

#define IDD_WIZEXTN_FIRST    0x5000
#define IDD_WIZEXTN_LAST     0x5100


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0085_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0085_v0_0_s_ifspec;

#ifndef __IWizardSite_INTERFACE_DEFINED__
#define __IWizardSite_INTERFACE_DEFINED__

/* interface IWizardSite */
/* [object][local][helpstring][uuid] */ 


EXTERN_C const IID IID_IWizardSite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("88960f5b-422f-4e7b-8013-73415381c3c3")
    IWizardSite : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPreviousPage( 
            /* [out] */ 
            __out  HPROPSHEETPAGE *phpage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextPage( 
            /* [out] */ 
            __out  HPROPSHEETPAGE *phpage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCancelledPage( 
            /* [out] */ 
            __out  HPROPSHEETPAGE *phpage) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWizardSiteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWizardSite * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWizardSite * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWizardSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPreviousPage )( 
            IWizardSite * This,
            /* [out] */ 
            __out  HPROPSHEETPAGE *phpage);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextPage )( 
            IWizardSite * This,
            /* [out] */ 
            __out  HPROPSHEETPAGE *phpage);
        
        HRESULT ( STDMETHODCALLTYPE *GetCancelledPage )( 
            IWizardSite * This,
            /* [out] */ 
            __out  HPROPSHEETPAGE *phpage);
        
        END_INTERFACE
    } IWizardSiteVtbl;

    interface IWizardSite
    {
        CONST_VTBL struct IWizardSiteVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWizardSite_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWizardSite_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWizardSite_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWizardSite_GetPreviousPage(This,phpage)	\
    ( (This)->lpVtbl -> GetPreviousPage(This,phpage) ) 

#define IWizardSite_GetNextPage(This,phpage)	\
    ( (This)->lpVtbl -> GetNextPage(This,phpage) ) 

#define IWizardSite_GetCancelledPage(This,phpage)	\
    ( (This)->lpVtbl -> GetCancelledPage(This,phpage) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWizardSite_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0086 */
/* [local] */ 

#define SID_WizardSite IID_IWizardSite


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0086_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0086_v0_0_s_ifspec;

#ifndef __IWizardExtension_INTERFACE_DEFINED__
#define __IWizardExtension_INTERFACE_DEFINED__

/* interface IWizardExtension */
/* [object][local][helpstring][uuid] */ 


EXTERN_C const IID IID_IWizardExtension;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c02ea696-86cc-491e-9b23-74394a0444a8")
    IWizardExtension : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddPages( 
            /* [size_is][out][in] */ 
            __out_ecount_part(cPages, *pnPagesAdded)  HPROPSHEETPAGE *aPages,
            /* [in] */ 
            __in  UINT cPages,
            /* [out] */ 
            __out  UINT *pnPagesAdded) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFirstPage( 
            /* [out] */ 
            __out  HPROPSHEETPAGE *phpage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLastPage( 
            /* [out] */ 
            __out  HPROPSHEETPAGE *phpage) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWizardExtensionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWizardExtension * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWizardExtension * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWizardExtension * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddPages )( 
            IWizardExtension * This,
            /* [size_is][out][in] */ 
            __out_ecount_part(cPages, *pnPagesAdded)  HPROPSHEETPAGE *aPages,
            /* [in] */ 
            __in  UINT cPages,
            /* [out] */ 
            __out  UINT *pnPagesAdded);
        
        HRESULT ( STDMETHODCALLTYPE *GetFirstPage )( 
            IWizardExtension * This,
            /* [out] */ 
            __out  HPROPSHEETPAGE *phpage);
        
        HRESULT ( STDMETHODCALLTYPE *GetLastPage )( 
            IWizardExtension * This,
            /* [out] */ 
            __out  HPROPSHEETPAGE *phpage);
        
        END_INTERFACE
    } IWizardExtensionVtbl;

    interface IWizardExtension
    {
        CONST_VTBL struct IWizardExtensionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWizardExtension_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWizardExtension_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWizardExtension_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWizardExtension_AddPages(This,aPages,cPages,pnPagesAdded)	\
    ( (This)->lpVtbl -> AddPages(This,aPages,cPages,pnPagesAdded) ) 

#define IWizardExtension_GetFirstPage(This,phpage)	\
    ( (This)->lpVtbl -> GetFirstPage(This,phpage) ) 

#define IWizardExtension_GetLastPage(This,phpage)	\
    ( (This)->lpVtbl -> GetLastPage(This,phpage) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWizardExtension_INTERFACE_DEFINED__ */


#ifndef __IWebWizardExtension_INTERFACE_DEFINED__
#define __IWebWizardExtension_INTERFACE_DEFINED__

/* interface IWebWizardExtension */
/* [object][unique][local][uuid][helpstring] */ 


EXTERN_C const IID IID_IWebWizardExtension;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0e6b3f66-98d1-48c0-a222-fbde74e2fbc5")
    IWebWizardExtension : public IWizardExtension
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetInitialURL( 
            /* [string][in] */ 
            __in  LPCWSTR pszURL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetErrorURL( 
            /* [string][in] */ 
            __in  LPCWSTR pszErrorURL) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWebWizardExtensionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWebWizardExtension * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWebWizardExtension * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWebWizardExtension * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddPages )( 
            IWebWizardExtension * This,
            /* [size_is][out][in] */ 
            __out_ecount_part(cPages, *pnPagesAdded)  HPROPSHEETPAGE *aPages,
            /* [in] */ 
            __in  UINT cPages,
            /* [out] */ 
            __out  UINT *pnPagesAdded);
        
        HRESULT ( STDMETHODCALLTYPE *GetFirstPage )( 
            IWebWizardExtension * This,
            /* [out] */ 
            __out  HPROPSHEETPAGE *phpage);
        
        HRESULT ( STDMETHODCALLTYPE *GetLastPage )( 
            IWebWizardExtension * This,
            /* [out] */ 
            __out  HPROPSHEETPAGE *phpage);
        
        HRESULT ( STDMETHODCALLTYPE *SetInitialURL )( 
            IWebWizardExtension * This,
            /* [string][in] */ 
            __in  LPCWSTR pszURL);
        
        HRESULT ( STDMETHODCALLTYPE *SetErrorURL )( 
            IWebWizardExtension * This,
            /* [string][in] */ 
            __in  LPCWSTR pszErrorURL);
        
        END_INTERFACE
    } IWebWizardExtensionVtbl;

    interface IWebWizardExtension
    {
        CONST_VTBL struct IWebWizardExtensionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWebWizardExtension_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWebWizardExtension_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWebWizardExtension_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWebWizardExtension_AddPages(This,aPages,cPages,pnPagesAdded)	\
    ( (This)->lpVtbl -> AddPages(This,aPages,cPages,pnPagesAdded) ) 

#define IWebWizardExtension_GetFirstPage(This,phpage)	\
    ( (This)->lpVtbl -> GetFirstPage(This,phpage) ) 

#define IWebWizardExtension_GetLastPage(This,phpage)	\
    ( (This)->lpVtbl -> GetLastPage(This,phpage) ) 


#define IWebWizardExtension_SetInitialURL(This,pszURL)	\
    ( (This)->lpVtbl -> SetInitialURL(This,pszURL) ) 

#define IWebWizardExtension_SetErrorURL(This,pszErrorURL)	\
    ( (This)->lpVtbl -> SetErrorURL(This,pszErrorURL) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWebWizardExtension_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0088 */
/* [local] */ 

#define SID_WebWizardHost IID_IWebWizardExtension
#define SHPWHF_NORECOMPRESS             0x00000001  // don't allow/prompt for recompress of streams
#define SHPWHF_NONETPLACECREATE         0x00000002  // don't create a network place when transfer is complete
#define SHPWHF_NOFILESELECTOR           0x00000004  // don't show the file selector
#define SHPWHF_USEMRU                   0x00000008  // For OPW.  Use the Most-Recently-Used Print Provider
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define SHPWHF_ANYLOCATION              0x00000100  // allow publishing to any location
#endif  // NTDDI_VISTA
#define SHPWHF_VALIDATEVIAWEBFOLDERS    0x00010000  // enable web folders to validate network places (ANP support)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0088_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0088_v0_0_s_ifspec;

#ifndef __IPublishingWizard_INTERFACE_DEFINED__
#define __IPublishingWizard_INTERFACE_DEFINED__

/* interface IPublishingWizard */
/* [object][unique][local][uuid][helpstring] */ 


EXTERN_C const IID IID_IPublishingWizard;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa9198bb-ccec-472d-beed-19a4f6733f7a")
    IPublishingWizard : public IWizardExtension
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [unique][in] */ 
            __in_opt  IDataObject *pdo,
            /* [in] */ 
            __in  DWORD dwOptions,
            /* [string][in] */ 
            __in  LPCWSTR pszServiceScope) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransferManifest( 
            /* [out] */ 
            __out  HRESULT *phrFromTransfer,
            /* [out] */ 
            __deref_out  IXMLDOMDocument **pdocManifest) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPublishingWizardVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPublishingWizard * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPublishingWizard * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPublishingWizard * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddPages )( 
            IPublishingWizard * This,
            /* [size_is][out][in] */ 
            __out_ecount_part(cPages, *pnPagesAdded)  HPROPSHEETPAGE *aPages,
            /* [in] */ 
            __in  UINT cPages,
            /* [out] */ 
            __out  UINT *pnPagesAdded);
        
        HRESULT ( STDMETHODCALLTYPE *GetFirstPage )( 
            IPublishingWizard * This,
            /* [out] */ 
            __out  HPROPSHEETPAGE *phpage);
        
        HRESULT ( STDMETHODCALLTYPE *GetLastPage )( 
            IPublishingWizard * This,
            /* [out] */ 
            __out  HPROPSHEETPAGE *phpage);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IPublishingWizard * This,
            /* [unique][in] */ 
            __in_opt  IDataObject *pdo,
            /* [in] */ 
            __in  DWORD dwOptions,
            /* [string][in] */ 
            __in  LPCWSTR pszServiceScope);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransferManifest )( 
            IPublishingWizard * This,
            /* [out] */ 
            __out  HRESULT *phrFromTransfer,
            /* [out] */ 
            __deref_out  IXMLDOMDocument **pdocManifest);
        
        END_INTERFACE
    } IPublishingWizardVtbl;

    interface IPublishingWizard
    {
        CONST_VTBL struct IPublishingWizardVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPublishingWizard_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPublishingWizard_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPublishingWizard_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPublishingWizard_AddPages(This,aPages,cPages,pnPagesAdded)	\
    ( (This)->lpVtbl -> AddPages(This,aPages,cPages,pnPagesAdded) ) 

#define IPublishingWizard_GetFirstPage(This,phpage)	\
    ( (This)->lpVtbl -> GetFirstPage(This,phpage) ) 

#define IPublishingWizard_GetLastPage(This,phpage)	\
    ( (This)->lpVtbl -> GetLastPage(This,phpage) ) 


#define IPublishingWizard_Initialize(This,pdo,dwOptions,pszServiceScope)	\
    ( (This)->lpVtbl -> Initialize(This,pdo,dwOptions,pszServiceScope) ) 

#define IPublishingWizard_GetTransferManifest(This,phrFromTransfer,pdocManifest)	\
    ( (This)->lpVtbl -> GetTransferManifest(This,phrFromTransfer,pdocManifest) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPublishingWizard_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0089 */
/* [local] */ 

#if (NTDDI_VERSION >= NTDDI_WINXP) || (_WIN32_IE >= _WIN32_IE_IE70)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0089_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0089_v0_0_s_ifspec;

#ifndef __IFolderViewHost_INTERFACE_DEFINED__
#define __IFolderViewHost_INTERFACE_DEFINED__

/* interface IFolderViewHost */
/* [object][local][helpstring][uuid] */ 


EXTERN_C const IID IID_IFolderViewHost;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1ea58f02-d55a-411d-b09e-9e65ac21605b")
    IFolderViewHost : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ 
            __in  HWND hwndParent,
            /* [in] */ 
            __in  IDataObject *pdo,
            /* [in] */ 
            __in  RECT *prc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFolderViewHostVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFolderViewHost * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFolderViewHost * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFolderViewHost * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IFolderViewHost * This,
            /* [in] */ 
            __in  HWND hwndParent,
            /* [in] */ 
            __in  IDataObject *pdo,
            /* [in] */ 
            __in  RECT *prc);
        
        END_INTERFACE
    } IFolderViewHostVtbl;

    interface IFolderViewHost
    {
        CONST_VTBL struct IFolderViewHostVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFolderViewHost_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFolderViewHost_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFolderViewHost_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFolderViewHost_Initialize(This,hwndParent,pdo,prc)	\
    ( (This)->lpVtbl -> Initialize(This,hwndParent,pdo,prc) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFolderViewHost_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0090 */
/* [local] */ 

#if (_WIN32_IE >= _WIN32_IE_IE70)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0090_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0090_v0_0_s_ifspec;

#ifndef __IExplorerBrowserEvents_INTERFACE_DEFINED__
#define __IExplorerBrowserEvents_INTERFACE_DEFINED__

/* interface IExplorerBrowserEvents */
/* [local][object][uuid] */ 


EXTERN_C const IID IID_IExplorerBrowserEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("361bbdc7-e6ee-4e13-be58-58e2240c810f")
    IExplorerBrowserEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnNavigationPending( 
            /* [in] */ 
            __in  PCIDLIST_ABSOLUTE pidlFolder) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnViewCreated( 
            /* [in] */ 
            __in  IShellView *psv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnNavigationComplete( 
            /* [in] */ 
            __in  PCIDLIST_ABSOLUTE pidlFolder) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnNavigationFailed( 
            /* [in] */ 
            __in  PCIDLIST_ABSOLUTE pidlFolder) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExplorerBrowserEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IExplorerBrowserEvents * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IExplorerBrowserEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IExplorerBrowserEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnNavigationPending )( 
            IExplorerBrowserEvents * This,
            /* [in] */ 
            __in  PCIDLIST_ABSOLUTE pidlFolder);
        
        HRESULT ( STDMETHODCALLTYPE *OnViewCreated )( 
            IExplorerBrowserEvents * This,
            /* [in] */ 
            __in  IShellView *psv);
        
        HRESULT ( STDMETHODCALLTYPE *OnNavigationComplete )( 
            IExplorerBrowserEvents * This,
            /* [in] */ 
            __in  PCIDLIST_ABSOLUTE pidlFolder);
        
        HRESULT ( STDMETHODCALLTYPE *OnNavigationFailed )( 
            IExplorerBrowserEvents * This,
            /* [in] */ 
            __in  PCIDLIST_ABSOLUTE pidlFolder);
        
        END_INTERFACE
    } IExplorerBrowserEventsVtbl;

    interface IExplorerBrowserEvents
    {
        CONST_VTBL struct IExplorerBrowserEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExplorerBrowserEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IExplorerBrowserEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IExplorerBrowserEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IExplorerBrowserEvents_OnNavigationPending(This,pidlFolder)	\
    ( (This)->lpVtbl -> OnNavigationPending(This,pidlFolder) ) 

#define IExplorerBrowserEvents_OnViewCreated(This,psv)	\
    ( (This)->lpVtbl -> OnViewCreated(This,psv) ) 

#define IExplorerBrowserEvents_OnNavigationComplete(This,pidlFolder)	\
    ( (This)->lpVtbl -> OnNavigationComplete(This,pidlFolder) ) 

#define IExplorerBrowserEvents_OnNavigationFailed(This,pidlFolder)	\
    ( (This)->lpVtbl -> OnNavigationFailed(This,pidlFolder) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IExplorerBrowserEvents_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0091 */
/* [local] */ 

/* [v1_enum] */ 
enum _EXPLORER_BROWSER_OPTIONS
    {	EBO_NONE	= 0,
	EBO_NAVIGATEONCE	= 0x1,
	EBO_SHOWFRAMES	= 0x2,
	EBO_ALWAYSNAVIGATE	= 0x4,
	EBO_NOTRAVELLOG	= 0x8,
	EBO_NOWRAPPERWINDOW	= 0x10,
	EBO_HTMLSHAREPOINTVIEW	= 0x20
    } ;
typedef DWORD EXPLORER_BROWSER_OPTIONS;

/* [v1_enum] */ 
enum _EXPLORER_BROWSER_FILL_FLAGS
    {	EBF_NONE	= 0,
	EBF_SELECTFROMDATAOBJECT	= 0x100,
	EBF_NODROPTARGET	= 0x200
    } ;
typedef DWORD EXPLORER_BROWSER_FILL_FLAGS;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0091_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0091_v0_0_s_ifspec;

#ifndef __IExplorerBrowser_INTERFACE_DEFINED__
#define __IExplorerBrowser_INTERFACE_DEFINED__

/* interface IExplorerBrowser */
/* [object][uuid] */ 


EXTERN_C const IID IID_IExplorerBrowser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("dfd3b6b5-c10c-4be9-85f6-a66969f402f6")
    IExplorerBrowser : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ 
            __in  HWND hwndParent,
            /* [in] */ 
            __in  const RECT *prc,
            /* [unique][in] */ 
            __in_opt  const FOLDERSETTINGS *pfs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Destroy( void) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetRect( 
            /* [unique][out][in] */ 
            __inout_opt  HDWP *phdwp,
            /* [in] */ 
            __in  RECT rcBrowser) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPropertyBag( 
            /* [string][in] */ __RPC__in LPCWSTR pszPropertyBag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEmptyText( 
            /* [string][in] */ __RPC__in LPCWSTR pszEmptyText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFolderSettings( 
            /* [in] */ __RPC__in const FOLDERSETTINGS *pfs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Advise( 
            /* [in] */ __RPC__in_opt IExplorerBrowserEvents *psbe,
            /* [out] */ __RPC__out DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unadvise( 
            /* [in] */ DWORD dwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOptions( 
            /* [in] */ EXPLORER_BROWSER_OPTIONS dwFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOptions( 
            /* [out] */ __RPC__out EXPLORER_BROWSER_OPTIONS *pdwFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BrowseToIDList( 
            /* [in] */ __RPC__in PCUIDLIST_RELATIVE pidl,
            /* [in] */ UINT uFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BrowseToObject( 
            /* [in] */ __RPC__in_opt IUnknown *punk,
            /* [in] */ UINT uFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FillFromObject( 
            /* [unique][in] */ __RPC__in_opt IUnknown *punk,
            /* [in] */ EXPLORER_BROWSER_FILL_FLAGS dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAll( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentView( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExplorerBrowserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IExplorerBrowser * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IExplorerBrowser * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IExplorerBrowser * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IExplorerBrowser * This,
            /* [in] */ 
            __in  HWND hwndParent,
            /* [in] */ 
            __in  const RECT *prc,
            /* [unique][in] */ 
            __in_opt  const FOLDERSETTINGS *pfs);
        
        HRESULT ( STDMETHODCALLTYPE *Destroy )( 
            IExplorerBrowser * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SetRect )( 
            IExplorerBrowser * This,
            /* [unique][out][in] */ 
            __inout_opt  HDWP *phdwp,
            /* [in] */ 
            __in  RECT rcBrowser);
        
        HRESULT ( STDMETHODCALLTYPE *SetPropertyBag )( 
            IExplorerBrowser * This,
            /* [string][in] */ __RPC__in LPCWSTR pszPropertyBag);
        
        HRESULT ( STDMETHODCALLTYPE *SetEmptyText )( 
            IExplorerBrowser * This,
            /* [string][in] */ __RPC__in LPCWSTR pszEmptyText);
        
        HRESULT ( STDMETHODCALLTYPE *SetFolderSettings )( 
            IExplorerBrowser * This,
            /* [in] */ __RPC__in const FOLDERSETTINGS *pfs);
        
        HRESULT ( STDMETHODCALLTYPE *Advise )( 
            IExplorerBrowser * This,
            /* [in] */ __RPC__in_opt IExplorerBrowserEvents *psbe,
            /* [out] */ __RPC__out DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *Unadvise )( 
            IExplorerBrowser * This,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *SetOptions )( 
            IExplorerBrowser * This,
            /* [in] */ EXPLORER_BROWSER_OPTIONS dwFlag);
        
        HRESULT ( STDMETHODCALLTYPE *GetOptions )( 
            IExplorerBrowser * This,
            /* [out] */ __RPC__out EXPLORER_BROWSER_OPTIONS *pdwFlag);
        
        HRESULT ( STDMETHODCALLTYPE *BrowseToIDList )( 
            IExplorerBrowser * This,
            /* [in] */ __RPC__in PCUIDLIST_RELATIVE pidl,
            /* [in] */ UINT uFlags);
        
        HRESULT ( STDMETHODCALLTYPE *BrowseToObject )( 
            IExplorerBrowser * This,
            /* [in] */ __RPC__in_opt IUnknown *punk,
            /* [in] */ UINT uFlags);
        
        HRESULT ( STDMETHODCALLTYPE *FillFromObject )( 
            IExplorerBrowser * This,
            /* [unique][in] */ __RPC__in_opt IUnknown *punk,
            /* [in] */ EXPLORER_BROWSER_FILL_FLAGS dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAll )( 
            IExplorerBrowser * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentView )( 
            IExplorerBrowser * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        END_INTERFACE
    } IExplorerBrowserVtbl;

    interface IExplorerBrowser
    {
        CONST_VTBL struct IExplorerBrowserVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExplorerBrowser_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IExplorerBrowser_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IExplorerBrowser_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IExplorerBrowser_Initialize(This,hwndParent,prc,pfs)	\
    ( (This)->lpVtbl -> Initialize(This,hwndParent,prc,pfs) ) 

#define IExplorerBrowser_Destroy(This)	\
    ( (This)->lpVtbl -> Destroy(This) ) 

#define IExplorerBrowser_SetRect(This,phdwp,rcBrowser)	\
    ( (This)->lpVtbl -> SetRect(This,phdwp,rcBrowser) ) 

#define IExplorerBrowser_SetPropertyBag(This,pszPropertyBag)	\
    ( (This)->lpVtbl -> SetPropertyBag(This,pszPropertyBag) ) 

#define IExplorerBrowser_SetEmptyText(This,pszEmptyText)	\
    ( (This)->lpVtbl -> SetEmptyText(This,pszEmptyText) ) 

#define IExplorerBrowser_SetFolderSettings(This,pfs)	\
    ( (This)->lpVtbl -> SetFolderSettings(This,pfs) ) 

#define IExplorerBrowser_Advise(This,psbe,pdwCookie)	\
    ( (This)->lpVtbl -> Advise(This,psbe,pdwCookie) ) 

#define IExplorerBrowser_Unadvise(This,dwCookie)	\
    ( (This)->lpVtbl -> Unadvise(This,dwCookie) ) 

#define IExplorerBrowser_SetOptions(This,dwFlag)	\
    ( (This)->lpVtbl -> SetOptions(This,dwFlag) ) 

#define IExplorerBrowser_GetOptions(This,pdwFlag)	\
    ( (This)->lpVtbl -> GetOptions(This,pdwFlag) ) 

#define IExplorerBrowser_BrowseToIDList(This,pidl,uFlags)	\
    ( (This)->lpVtbl -> BrowseToIDList(This,pidl,uFlags) ) 

#define IExplorerBrowser_BrowseToObject(This,punk,uFlags)	\
    ( (This)->lpVtbl -> BrowseToObject(This,punk,uFlags) ) 

#define IExplorerBrowser_FillFromObject(This,punk,dwFlags)	\
    ( (This)->lpVtbl -> FillFromObject(This,punk,dwFlags) ) 

#define IExplorerBrowser_RemoveAll(This)	\
    ( (This)->lpVtbl -> RemoveAll(This) ) 

#define IExplorerBrowser_GetCurrentView(This,riid,ppv)	\
    ( (This)->lpVtbl -> GetCurrentView(This,riid,ppv) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IExplorerBrowser_INTERFACE_DEFINED__ */


#ifndef __IAccessibleObject_INTERFACE_DEFINED__
#define __IAccessibleObject_INTERFACE_DEFINED__

/* interface IAccessibleObject */
/* [object][uuid] */ 


EXTERN_C const IID IID_IAccessibleObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("95A391C5-9ED4-4c28-8401-AB9E06719E11")
    IAccessibleObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetAccessibleName( 
            /* [string][in] */ __RPC__in LPCWSTR pszName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAccessibleObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAccessibleObject * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAccessibleObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAccessibleObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetAccessibleName )( 
            IAccessibleObject * This,
            /* [string][in] */ __RPC__in LPCWSTR pszName);
        
        END_INTERFACE
    } IAccessibleObjectVtbl;

    interface IAccessibleObject
    {
        CONST_VTBL struct IAccessibleObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAccessibleObject_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAccessibleObject_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAccessibleObject_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAccessibleObject_SetAccessibleName(This,pszName)	\
    ( (This)->lpVtbl -> SetAccessibleName(This,pszName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAccessibleObject_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0093 */
/* [local] */ 

#endif  // (_WIN32_IE >= _WIN32_IE_IE70)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0093_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0093_v0_0_s_ifspec;

#ifndef __IResultsFolder_INTERFACE_DEFINED__
#define __IResultsFolder_INTERFACE_DEFINED__

/* interface IResultsFolder */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IResultsFolder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96E5AE6D-6AE1-4b1c-900C-C6480EAA8828")
    IResultsFolder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddItem( 
            /* [in] */ __RPC__in_opt IShellItem *psi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddIDList( 
            /* [in] */ __RPC__in PCIDLIST_ABSOLUTE pidl,
            /* [out] */ __RPC__deref_out_opt PITEMID_CHILD *ppidlAdded) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveItem( 
            /* [in] */ __RPC__in_opt IShellItem *psi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveIDList( 
            /* [in] */ __RPC__in PCIDLIST_ABSOLUTE pidl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAll( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IResultsFolderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IResultsFolder * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IResultsFolder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IResultsFolder * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddItem )( 
            IResultsFolder * This,
            /* [in] */ __RPC__in_opt IShellItem *psi);
        
        HRESULT ( STDMETHODCALLTYPE *AddIDList )( 
            IResultsFolder * This,
            /* [in] */ __RPC__in PCIDLIST_ABSOLUTE pidl,
            /* [out] */ __RPC__deref_out_opt PITEMID_CHILD *ppidlAdded);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveItem )( 
            IResultsFolder * This,
            /* [in] */ __RPC__in_opt IShellItem *psi);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveIDList )( 
            IResultsFolder * This,
            /* [in] */ __RPC__in PCIDLIST_ABSOLUTE pidl);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAll )( 
            IResultsFolder * This);
        
        END_INTERFACE
    } IResultsFolderVtbl;

    interface IResultsFolder
    {
        CONST_VTBL struct IResultsFolderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResultsFolder_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IResultsFolder_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IResultsFolder_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IResultsFolder_AddItem(This,psi)	\
    ( (This)->lpVtbl -> AddItem(This,psi) ) 

#define IResultsFolder_AddIDList(This,pidl,ppidlAdded)	\
    ( (This)->lpVtbl -> AddIDList(This,pidl,ppidlAdded) ) 

#define IResultsFolder_RemoveItem(This,psi)	\
    ( (This)->lpVtbl -> RemoveItem(This,psi) ) 

#define IResultsFolder_RemoveIDList(This,pidl)	\
    ( (This)->lpVtbl -> RemoveIDList(This,pidl) ) 

#define IResultsFolder_RemoveAll(This)	\
    ( (This)->lpVtbl -> RemoveAll(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IResultsFolder_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0094 */
/* [local] */ 

#if (_WIN32_IE >= _WIN32_IE_IE70)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0094_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0094_v0_0_s_ifspec;

#ifndef __IEnumObjects_INTERFACE_DEFINED__
#define __IEnumObjects_INTERFACE_DEFINED__

/* interface IEnumObjects */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IEnumObjects;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2c1c7e2e-2d0e-4059-831e-1e6f82335c2e")
    IEnumObjects : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ 
            __in  ULONG celt,
            /* [in] */ 
            __in  REFIID riid,
            /* [iid_is][length_is][size_is][out] */ 
            __out_ecount_part(celt, *pceltFetched)  void **rgelt,
            /* [out] */ 
            __out_opt  ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumObjects **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumObjectsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumObjects * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumObjects * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumObjects * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumObjects * This,
            /* [in] */ 
            __in  ULONG celt,
            /* [in] */ 
            __in  REFIID riid,
            /* [iid_is][length_is][size_is][out] */ 
            __out_ecount_part(celt, *pceltFetched)  void **rgelt,
            /* [out] */ 
            __out_opt  ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumObjects * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumObjects * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumObjects * This,
            /* [out] */ __RPC__deref_out_opt IEnumObjects **ppenum);
        
        END_INTERFACE
    } IEnumObjectsVtbl;

    interface IEnumObjects
    {
        CONST_VTBL struct IEnumObjectsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumObjects_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumObjects_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumObjects_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumObjects_Next(This,celt,riid,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,riid,rgelt,pceltFetched) ) 

#define IEnumObjects_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumObjects_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumObjects_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumObjects_RemoteNext_Proxy( 
    IEnumObjects * This,
    /* [in] */ ULONG celt,
    /* [in] */ __RPC__in REFIID riid,
    /* [iid_is][size_is][out] */ __RPC__out_ecount_full(celt) void **rgelt,
    /* [out] */ __RPC__out ULONG *pceltFetched);


void __RPC_STUB IEnumObjects_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumObjects_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0095 */
/* [local] */ 

#define OPPROGDLG_ENABLEPAUSE     0x00000080      // Add a pause button (operation can be paused)
#define OPPROGDLG_ALLOWUNDO       0x00000100      // The operation can be undone in the dialog.  (The Stop button becomes Undo)
#define OPPROGDLG_DONTDISPLAYSOURCEPATH   0x00000200  // Don't display the path of source file in progress dialog
#define OPPROGDLG_DONTDISPLAYDESTPATH     0x00000400  // Don't display the path of destination file in progress dialog


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0095_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0095_v0_0_s_ifspec;

#ifndef __IOperationsProgressDialog_INTERFACE_DEFINED__
#define __IOperationsProgressDialog_INTERFACE_DEFINED__

/* interface IOperationsProgressDialog */
/* [unique][object][uuid][helpstring] */ 

/* [v1_enum] */ 
enum tagPDMODE
    {	PDM_RUN	= 0x1,
	PDM_PREFLIGHT	= 0x2,
	PDM_UNDOING	= 0x4,
	PDM_ERRORSBLOCKING	= 0x8,
	PDM_INDETERMINATE	= 0x10
    } ;
typedef DWORD PDMODE;

typedef /* [v1_enum] */ 
enum tagPDOPSTATUS
    {	PDOPS_RUNNING	= 0x1,
	PDOPS_PAUSED	= 0x2,
	PDOPS_CANCELLED	= 0x3,
	PDOPS_STOPPED	= 0x4,
	PDOPS_ERRORS	= 0x5
    } 	PDOPSTATUS;


EXTERN_C const IID IID_IOperationsProgressDialog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0C9FB851-E5C9-43EB-A370-F0677B13874C")
    IOperationsProgressDialog : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StartProgressDialog( 
            /* [unique][in] */ __RPC__in_opt HWND hwndParent,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopProgressDialog( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOperation( 
            /* [in] */ SPACTION action) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMode( 
            /* [in] */ PDMODE mode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateProgress( 
            /* [in] */ ULONGLONG ullPointsCurrent,
            /* [in] */ ULONGLONG ullPointsTotal,
            /* [in] */ ULONGLONG ullSizeCurrent,
            /* [in] */ ULONGLONG ullSizeTotal,
            /* [in] */ ULONGLONG ullItemsCurrent,
            /* [in] */ ULONGLONG ullItemsTotal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateLocations( 
            /* [unique][in] */ __RPC__in_opt IShellItem *psiSource,
            /* [unique][in] */ __RPC__in_opt IShellItem *psiTarget,
            /* [unique][in] */ __RPC__in_opt IShellItem *psiItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetTimer( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PauseTimer( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResumeTimer( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMilliseconds( 
            /* [out] */ __RPC__out ULONGLONG *pullElapsed,
            /* [out] */ __RPC__out ULONGLONG *pullRemaining) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOperationStatus( 
            /* [out] */ __RPC__out PDOPSTATUS *popstatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOperationsProgressDialogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IOperationsProgressDialog * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IOperationsProgressDialog * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IOperationsProgressDialog * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartProgressDialog )( 
            IOperationsProgressDialog * This,
            /* [unique][in] */ __RPC__in_opt HWND hwndParent,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *StopProgressDialog )( 
            IOperationsProgressDialog * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetOperation )( 
            IOperationsProgressDialog * This,
            /* [in] */ SPACTION action);
        
        HRESULT ( STDMETHODCALLTYPE *SetMode )( 
            IOperationsProgressDialog * This,
            /* [in] */ PDMODE mode);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateProgress )( 
            IOperationsProgressDialog * This,
            /* [in] */ ULONGLONG ullPointsCurrent,
            /* [in] */ ULONGLONG ullPointsTotal,
            /* [in] */ ULONGLONG ullSizeCurrent,
            /* [in] */ ULONGLONG ullSizeTotal,
            /* [in] */ ULONGLONG ullItemsCurrent,
            /* [in] */ ULONGLONG ullItemsTotal);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateLocations )( 
            IOperationsProgressDialog * This,
            /* [unique][in] */ __RPC__in_opt IShellItem *psiSource,
            /* [unique][in] */ __RPC__in_opt IShellItem *psiTarget,
            /* [unique][in] */ __RPC__in_opt IShellItem *psiItem);
        
        HRESULT ( STDMETHODCALLTYPE *ResetTimer )( 
            IOperationsProgressDialog * This);
        
        HRESULT ( STDMETHODCALLTYPE *PauseTimer )( 
            IOperationsProgressDialog * This);
        
        HRESULT ( STDMETHODCALLTYPE *ResumeTimer )( 
            IOperationsProgressDialog * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMilliseconds )( 
            IOperationsProgressDialog * This,
            /* [out] */ __RPC__out ULONGLONG *pullElapsed,
            /* [out] */ __RPC__out ULONGLONG *pullRemaining);
        
        HRESULT ( STDMETHODCALLTYPE *GetOperationStatus )( 
            IOperationsProgressDialog * This,
            /* [out] */ __RPC__out PDOPSTATUS *popstatus);
        
        END_INTERFACE
    } IOperationsProgressDialogVtbl;

    interface IOperationsProgressDialog
    {
        CONST_VTBL struct IOperationsProgressDialogVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOperationsProgressDialog_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IOperationsProgressDialog_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IOperationsProgressDialog_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IOperationsProgressDialog_StartProgressDialog(This,hwndParent,dwFlags)	\
    ( (This)->lpVtbl -> StartProgressDialog(This,hwndParent,dwFlags) ) 

#define IOperationsProgressDialog_StopProgressDialog(This)	\
    ( (This)->lpVtbl -> StopProgressDialog(This) ) 

#define IOperationsProgressDialog_SetOperation(This,action)	\
    ( (This)->lpVtbl -> SetOperation(This,action) ) 

#define IOperationsProgressDialog_SetMode(This,mode)	\
    ( (This)->lpVtbl -> SetMode(This,mode) ) 

#define IOperationsProgressDialog_UpdateProgress(This,ullPointsCurrent,ullPointsTotal,ullSizeCurrent,ullSizeTotal,ullItemsCurrent,ullItemsTotal)	\
    ( (This)->lpVtbl -> UpdateProgress(This,ullPointsCurrent,ullPointsTotal,ullSizeCurrent,ullSizeTotal,ullItemsCurrent,ullItemsTotal) ) 

#define IOperationsProgressDialog_UpdateLocations(This,psiSource,psiTarget,psiItem)	\
    ( (This)->lpVtbl -> UpdateLocations(This,psiSource,psiTarget,psiItem) ) 

#define IOperationsProgressDialog_ResetTimer(This)	\
    ( (This)->lpVtbl -> ResetTimer(This) ) 

#define IOperationsProgressDialog_PauseTimer(This)	\
    ( (This)->lpVtbl -> PauseTimer(This) ) 

#define IOperationsProgressDialog_ResumeTimer(This)	\
    ( (This)->lpVtbl -> ResumeTimer(This) ) 

#define IOperationsProgressDialog_GetMilliseconds(This,pullElapsed,pullRemaining)	\
    ( (This)->lpVtbl -> GetMilliseconds(This,pullElapsed,pullRemaining) ) 

#define IOperationsProgressDialog_GetOperationStatus(This,popstatus)	\
    ( (This)->lpVtbl -> GetOperationStatus(This,popstatus) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IOperationsProgressDialog_INTERFACE_DEFINED__ */


#ifndef __IOperationsUpdateProgress_INTERFACE_DEFINED__
#define __IOperationsUpdateProgress_INTERFACE_DEFINED__

/* interface IOperationsUpdateProgress */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IOperationsUpdateProgress;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B5256C5C-F918-49E6-BBB7-A3C254C09FDF")
    IOperationsUpdateProgress : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddTreeDone( 
            /* [in] */ int iFiles,
            /* [in] */ int iFolders,
            /* [in] */ LONGLONG llSize,
            /* [in] */ int iPoints) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddTreeTotal( 
            /* [in] */ int iFiles,
            /* [in] */ int iFolders,
            /* [in] */ LONGLONG llSize,
            /* [in] */ int iPoints) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOperationsUpdateProgressVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IOperationsUpdateProgress * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IOperationsUpdateProgress * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IOperationsUpdateProgress * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddTreeDone )( 
            IOperationsUpdateProgress * This,
            /* [in] */ int iFiles,
            /* [in] */ int iFolders,
            /* [in] */ LONGLONG llSize,
            /* [in] */ int iPoints);
        
        HRESULT ( STDMETHODCALLTYPE *AddTreeTotal )( 
            IOperationsUpdateProgress * This,
            /* [in] */ int iFiles,
            /* [in] */ int iFolders,
            /* [in] */ LONGLONG llSize,
            /* [in] */ int iPoints);
        
        END_INTERFACE
    } IOperationsUpdateProgressVtbl;

    interface IOperationsUpdateProgress
    {
        CONST_VTBL struct IOperationsUpdateProgressVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOperationsUpdateProgress_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IOperationsUpdateProgress_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IOperationsUpdateProgress_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IOperationsUpdateProgress_AddTreeDone(This,iFiles,iFolders,llSize,iPoints)	\
    ( (This)->lpVtbl -> AddTreeDone(This,iFiles,iFolders,llSize,iPoints) ) 

#define IOperationsUpdateProgress_AddTreeTotal(This,iFiles,iFolders,llSize,iPoints)	\
    ( (This)->lpVtbl -> AddTreeTotal(This,iFiles,iFolders,llSize,iPoints) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IOperationsUpdateProgress_INTERFACE_DEFINED__ */


#ifndef __IIOCancelInformation_INTERFACE_DEFINED__
#define __IIOCancelInformation_INTERFACE_DEFINED__

/* interface IIOCancelInformation */
/* [local][unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IIOCancelInformation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f5b0bf81-8cb5-4b1b-9449-1a159e0c733c")
    IIOCancelInformation : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetCancelInformation( 
            /* [in] */ DWORD dwThreadID,
            /* [in] */ UINT uMsgCancel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCancelInformation( 
            /* [out] */ 
            __out_opt  DWORD *pdwThreadID,
            /* [out] */ 
            __out_opt  UINT *puMsgCancel) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIOCancelInformationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IIOCancelInformation * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IIOCancelInformation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IIOCancelInformation * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetCancelInformation )( 
            IIOCancelInformation * This,
            /* [in] */ DWORD dwThreadID,
            /* [in] */ UINT uMsgCancel);
        
        HRESULT ( STDMETHODCALLTYPE *GetCancelInformation )( 
            IIOCancelInformation * This,
            /* [out] */ 
            __out_opt  DWORD *pdwThreadID,
            /* [out] */ 
            __out_opt  UINT *puMsgCancel);
        
        END_INTERFACE
    } IIOCancelInformationVtbl;

    interface IIOCancelInformation
    {
        CONST_VTBL struct IIOCancelInformationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIOCancelInformation_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IIOCancelInformation_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IIOCancelInformation_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IIOCancelInformation_SetCancelInformation(This,dwThreadID,uMsgCancel)	\
    ( (This)->lpVtbl -> SetCancelInformation(This,dwThreadID,uMsgCancel) ) 

#define IIOCancelInformation_GetCancelInformation(This,pdwThreadID,puMsgCancel)	\
    ( (This)->lpVtbl -> GetCancelInformation(This,pdwThreadID,puMsgCancel) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IIOCancelInformation_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0098 */
/* [local] */ 

#define FOFX_NOSKIPJUNCTIONS         0x00010000  // Don't avoid binding to junctions (like Task folder, Recycle-Bin)
#define FOFX_PREFERHARDLINK          0x00020000  // Create hard link if possible
#define FOFX_SHOWELEVATIONPROMPT     0x00040000  // Show elevation prompts when error UI is disabled (use with FOF_NOERRORUI)
#define FOFX_EARLYFAILURE            0x00100000  // Fail operation as soon as a single error occurs rather than trying to process other items (applies only when using FOF_NOERRORUI)
#define FOFX_PRESERVEFILEEXTENSIONS  0x00200000  // Rename collisions preserve file extns (use with FOF_RENAMEONCOLLISION)
#define FOFX_KEEPNEWERFILE           0x00400000  // Keep newer file on naming conflicts
#define FOFX_NOCOPYHOOKS             0x00800000  // Don't use copy hooks
#define FOFX_NOMINIMIZEBOX           0x01000000  // Don't allow minimizing the progress dialog
#define FOFX_MOVEACLSACROSSVOLUMES   0x02000000  // Copy security information when performing a cross-volume move operation
#define FOFX_DONTDISPLAYSOURCEPATH   0x04000000  // Don't display the path of source file in progress dialog
#define FOFX_DONTDISPLAYDESTPATH     0x08000000  // Don't display the path of destination file in progress dialog
#define FOFX_REQUIREELEVATION        0x10000000  // User expects the elevation; don't show a dialog to confirm


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0098_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0098_v0_0_s_ifspec;

#ifndef __IFileOperation_INTERFACE_DEFINED__
#define __IFileOperation_INTERFACE_DEFINED__

/* interface IFileOperation */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IFileOperation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("947aab5f-0a5c-4c13-b4d6-4bf7836fc9f8")
    IFileOperation : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Advise( 
            /* [in] */ __RPC__in_opt IFileOperationProgressSink *pfops,
            /* [out] */ __RPC__out DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unadvise( 
            /* [in] */ DWORD dwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOperationFlags( 
            /* [in] */ DWORD dwOperationFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProgressMessage( 
            /* [string][in] */ __RPC__in LPCWSTR pszMessage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProgressDialog( 
            /* [in] */ __RPC__in_opt IOperationsProgressDialog *popd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProperties( 
            /* [in] */ __RPC__in_opt IPropertyChangeArray *pproparray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOwnerWindow( 
            /* [in] */ __RPC__in HWND hwndParent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ApplyPropertiesToItem( 
            /* [in] */ __RPC__in_opt IShellItem *psiItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ApplyPropertiesToItems( 
            /* [in] */ __RPC__in_opt IUnknown *punkItems) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RenameItem( 
            /* [in] */ __RPC__in_opt IShellItem *psiItem,
            /* [string][in] */ __RPC__in LPCWSTR pszNewName,
            /* [unique][in] */ __RPC__in_opt IFileOperationProgressSink *pfopsItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RenameItems( 
            /* [in] */ __RPC__in_opt IUnknown *pUnkItems,
            /* [string][in] */ __RPC__in LPCWSTR pszNewName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MoveItem( 
            /* [in] */ __RPC__in_opt IShellItem *psiItem,
            /* [in] */ __RPC__in_opt IShellItem *psiDestinationFolder,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszNewName,
            /* [unique][in] */ __RPC__in_opt IFileOperationProgressSink *pfopsItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MoveItems( 
            /* [in] */ __RPC__in_opt IUnknown *punkItems,
            /* [in] */ __RPC__in_opt IShellItem *psiDestinationFolder) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CopyItem( 
            /* [in] */ __RPC__in_opt IShellItem *psiItem,
            /* [in] */ __RPC__in_opt IShellItem *psiDestinationFolder,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszCopyName,
            /* [unique][in] */ __RPC__in_opt IFileOperationProgressSink *pfopsItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CopyItems( 
            /* [in] */ __RPC__in_opt IUnknown *punkItems,
            /* [in] */ __RPC__in_opt IShellItem *psiDestinationFolder) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteItem( 
            /* [in] */ __RPC__in_opt IShellItem *psiItem,
            /* [unique][in] */ __RPC__in_opt IFileOperationProgressSink *pfopsItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteItems( 
            /* [in] */ __RPC__in_opt IUnknown *punkItems) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NewItem( 
            /* [in] */ __RPC__in_opt IShellItem *psiDestinationFolder,
            /* [in] */ DWORD dwFileAttributes,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszName,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszTemplateName,
            /* [unique][in] */ __RPC__in_opt IFileOperationProgressSink *pfopsItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PerformOperations( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAnyOperationsAborted( 
            /* [out] */ __RPC__out BOOL *pfAnyOperationsAborted) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFileOperationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFileOperation * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFileOperation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFileOperation * This);
        
        HRESULT ( STDMETHODCALLTYPE *Advise )( 
            IFileOperation * This,
            /* [in] */ __RPC__in_opt IFileOperationProgressSink *pfops,
            /* [out] */ __RPC__out DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *Unadvise )( 
            IFileOperation * This,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *SetOperationFlags )( 
            IFileOperation * This,
            /* [in] */ DWORD dwOperationFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetProgressMessage )( 
            IFileOperation * This,
            /* [string][in] */ __RPC__in LPCWSTR pszMessage);
        
        HRESULT ( STDMETHODCALLTYPE *SetProgressDialog )( 
            IFileOperation * This,
            /* [in] */ __RPC__in_opt IOperationsProgressDialog *popd);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperties )( 
            IFileOperation * This,
            /* [in] */ __RPC__in_opt IPropertyChangeArray *pproparray);
        
        HRESULT ( STDMETHODCALLTYPE *SetOwnerWindow )( 
            IFileOperation * This,
            /* [in] */ __RPC__in HWND hwndParent);
        
        HRESULT ( STDMETHODCALLTYPE *ApplyPropertiesToItem )( 
            IFileOperation * This,
            /* [in] */ __RPC__in_opt IShellItem *psiItem);
        
        HRESULT ( STDMETHODCALLTYPE *ApplyPropertiesToItems )( 
            IFileOperation * This,
            /* [in] */ __RPC__in_opt IUnknown *punkItems);
        
        HRESULT ( STDMETHODCALLTYPE *RenameItem )( 
            IFileOperation * This,
            /* [in] */ __RPC__in_opt IShellItem *psiItem,
            /* [string][in] */ __RPC__in LPCWSTR pszNewName,
            /* [unique][in] */ __RPC__in_opt IFileOperationProgressSink *pfopsItem);
        
        HRESULT ( STDMETHODCALLTYPE *RenameItems )( 
            IFileOperation * This,
            /* [in] */ __RPC__in_opt IUnknown *pUnkItems,
            /* [string][in] */ __RPC__in LPCWSTR pszNewName);
        
        HRESULT ( STDMETHODCALLTYPE *MoveItem )( 
            IFileOperation * This,
            /* [in] */ __RPC__in_opt IShellItem *psiItem,
            /* [in] */ __RPC__in_opt IShellItem *psiDestinationFolder,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszNewName,
            /* [unique][in] */ __RPC__in_opt IFileOperationProgressSink *pfopsItem);
        
        HRESULT ( STDMETHODCALLTYPE *MoveItems )( 
            IFileOperation * This,
            /* [in] */ __RPC__in_opt IUnknown *punkItems,
            /* [in] */ __RPC__in_opt IShellItem *psiDestinationFolder);
        
        HRESULT ( STDMETHODCALLTYPE *CopyItem )( 
            IFileOperation * This,
            /* [in] */ __RPC__in_opt IShellItem *psiItem,
            /* [in] */ __RPC__in_opt IShellItem *psiDestinationFolder,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszCopyName,
            /* [unique][in] */ __RPC__in_opt IFileOperationProgressSink *pfopsItem);
        
        HRESULT ( STDMETHODCALLTYPE *CopyItems )( 
            IFileOperation * This,
            /* [in] */ __RPC__in_opt IUnknown *punkItems,
            /* [in] */ __RPC__in_opt IShellItem *psiDestinationFolder);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteItem )( 
            IFileOperation * This,
            /* [in] */ __RPC__in_opt IShellItem *psiItem,
            /* [unique][in] */ __RPC__in_opt IFileOperationProgressSink *pfopsItem);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteItems )( 
            IFileOperation * This,
            /* [in] */ __RPC__in_opt IUnknown *punkItems);
        
        HRESULT ( STDMETHODCALLTYPE *NewItem )( 
            IFileOperation * This,
            /* [in] */ __RPC__in_opt IShellItem *psiDestinationFolder,
            /* [in] */ DWORD dwFileAttributes,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszName,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszTemplateName,
            /* [unique][in] */ __RPC__in_opt IFileOperationProgressSink *pfopsItem);
        
        HRESULT ( STDMETHODCALLTYPE *PerformOperations )( 
            IFileOperation * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAnyOperationsAborted )( 
            IFileOperation * This,
            /* [out] */ __RPC__out BOOL *pfAnyOperationsAborted);
        
        END_INTERFACE
    } IFileOperationVtbl;

    interface IFileOperation
    {
        CONST_VTBL struct IFileOperationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFileOperation_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFileOperation_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFileOperation_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFileOperation_Advise(This,pfops,pdwCookie)	\
    ( (This)->lpVtbl -> Advise(This,pfops,pdwCookie) ) 

#define IFileOperation_Unadvise(This,dwCookie)	\
    ( (This)->lpVtbl -> Unadvise(This,dwCookie) ) 

#define IFileOperation_SetOperationFlags(This,dwOperationFlags)	\
    ( (This)->lpVtbl -> SetOperationFlags(This,dwOperationFlags) ) 

#define IFileOperation_SetProgressMessage(This,pszMessage)	\
    ( (This)->lpVtbl -> SetProgressMessage(This,pszMessage) ) 

#define IFileOperation_SetProgressDialog(This,popd)	\
    ( (This)->lpVtbl -> SetProgressDialog(This,popd) ) 

#define IFileOperation_SetProperties(This,pproparray)	\
    ( (This)->lpVtbl -> SetProperties(This,pproparray) ) 

#define IFileOperation_SetOwnerWindow(This,hwndParent)	\
    ( (This)->lpVtbl -> SetOwnerWindow(This,hwndParent) ) 

#define IFileOperation_ApplyPropertiesToItem(This,psiItem)	\
    ( (This)->lpVtbl -> ApplyPropertiesToItem(This,psiItem) ) 

#define IFileOperation_ApplyPropertiesToItems(This,punkItems)	\
    ( (This)->lpVtbl -> ApplyPropertiesToItems(This,punkItems) ) 

#define IFileOperation_RenameItem(This,psiItem,pszNewName,pfopsItem)	\
    ( (This)->lpVtbl -> RenameItem(This,psiItem,pszNewName,pfopsItem) ) 

#define IFileOperation_RenameItems(This,pUnkItems,pszNewName)	\
    ( (This)->lpVtbl -> RenameItems(This,pUnkItems,pszNewName) ) 

#define IFileOperation_MoveItem(This,psiItem,psiDestinationFolder,pszNewName,pfopsItem)	\
    ( (This)->lpVtbl -> MoveItem(This,psiItem,psiDestinationFolder,pszNewName,pfopsItem) ) 

#define IFileOperation_MoveItems(This,punkItems,psiDestinationFolder)	\
    ( (This)->lpVtbl -> MoveItems(This,punkItems,psiDestinationFolder) ) 

#define IFileOperation_CopyItem(This,psiItem,psiDestinationFolder,pszCopyName,pfopsItem)	\
    ( (This)->lpVtbl -> CopyItem(This,psiItem,psiDestinationFolder,pszCopyName,pfopsItem) ) 

#define IFileOperation_CopyItems(This,punkItems,psiDestinationFolder)	\
    ( (This)->lpVtbl -> CopyItems(This,punkItems,psiDestinationFolder) ) 

#define IFileOperation_DeleteItem(This,psiItem,pfopsItem)	\
    ( (This)->lpVtbl -> DeleteItem(This,psiItem,pfopsItem) ) 

#define IFileOperation_DeleteItems(This,punkItems)	\
    ( (This)->lpVtbl -> DeleteItems(This,punkItems) ) 

#define IFileOperation_NewItem(This,psiDestinationFolder,dwFileAttributes,pszName,pszTemplateName,pfopsItem)	\
    ( (This)->lpVtbl -> NewItem(This,psiDestinationFolder,dwFileAttributes,pszName,pszTemplateName,pfopsItem) ) 

#define IFileOperation_PerformOperations(This)	\
    ( (This)->lpVtbl -> PerformOperations(This) ) 

#define IFileOperation_GetAnyOperationsAborted(This,pfAnyOperationsAborted)	\
    ( (This)->lpVtbl -> GetAnyOperationsAborted(This,pfAnyOperationsAborted) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFileOperation_INTERFACE_DEFINED__ */


#ifndef __IObjectProvider_INTERFACE_DEFINED__
#define __IObjectProvider_INTERFACE_DEFINED__

/* interface IObjectProvider */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IObjectProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a6087428-3be3-4d73-b308-7c04a540bf1a")
    IObjectProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryObject( 
            /* [in] */ __RPC__in REFGUID guidObject,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppvOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IObjectProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IObjectProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IObjectProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryObject )( 
            IObjectProvider * This,
            /* [in] */ __RPC__in REFGUID guidObject,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppvOut);
        
        END_INTERFACE
    } IObjectProviderVtbl;

    interface IObjectProvider
    {
        CONST_VTBL struct IObjectProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IObjectProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IObjectProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IObjectProvider_QueryObject(This,guidObject,riid,ppvOut)	\
    ( (This)->lpVtbl -> QueryObject(This,guidObject,riid,ppvOut) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IObjectProvider_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0100 */
/* [local] */ 

#endif  // (_WIN32_IE >= _WIN32_IE_IE70)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0100_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0100_v0_0_s_ifspec;

#ifndef __INamespaceWalkCB_INTERFACE_DEFINED__
#define __INamespaceWalkCB_INTERFACE_DEFINED__

/* interface INamespaceWalkCB */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_INamespaceWalkCB;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d92995f8-cf5e-4a76-bf59-ead39ea2b97e")
    INamespaceWalkCB : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FoundItem( 
            /* [in] */ __RPC__in_opt IShellFolder *psf,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnterFolder( 
            /* [in] */ __RPC__in_opt IShellFolder *psf,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LeaveFolder( 
            /* [in] */ __RPC__in_opt IShellFolder *psf,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeProgressDialog( 
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszTitle,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszCancel) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INamespaceWalkCBVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INamespaceWalkCB * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INamespaceWalkCB * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INamespaceWalkCB * This);
        
        HRESULT ( STDMETHODCALLTYPE *FoundItem )( 
            INamespaceWalkCB * This,
            /* [in] */ __RPC__in_opt IShellFolder *psf,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl);
        
        HRESULT ( STDMETHODCALLTYPE *EnterFolder )( 
            INamespaceWalkCB * This,
            /* [in] */ __RPC__in_opt IShellFolder *psf,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl);
        
        HRESULT ( STDMETHODCALLTYPE *LeaveFolder )( 
            INamespaceWalkCB * This,
            /* [in] */ __RPC__in_opt IShellFolder *psf,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeProgressDialog )( 
            INamespaceWalkCB * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszTitle,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszCancel);
        
        END_INTERFACE
    } INamespaceWalkCBVtbl;

    interface INamespaceWalkCB
    {
        CONST_VTBL struct INamespaceWalkCBVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INamespaceWalkCB_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INamespaceWalkCB_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INamespaceWalkCB_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INamespaceWalkCB_FoundItem(This,psf,pidl)	\
    ( (This)->lpVtbl -> FoundItem(This,psf,pidl) ) 

#define INamespaceWalkCB_EnterFolder(This,psf,pidl)	\
    ( (This)->lpVtbl -> EnterFolder(This,psf,pidl) ) 

#define INamespaceWalkCB_LeaveFolder(This,psf,pidl)	\
    ( (This)->lpVtbl -> LeaveFolder(This,psf,pidl) ) 

#define INamespaceWalkCB_InitializeProgressDialog(This,ppszTitle,ppszCancel)	\
    ( (This)->lpVtbl -> InitializeProgressDialog(This,ppszTitle,ppszCancel) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INamespaceWalkCB_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0101 */
/* [local] */ 

#if (_WIN32_IE >= _WIN32_IE_IE70)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0101_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0101_v0_0_s_ifspec;

#ifndef __INamespaceWalkCB2_INTERFACE_DEFINED__
#define __INamespaceWalkCB2_INTERFACE_DEFINED__

/* interface INamespaceWalkCB2 */
/* [object][uuid] */ 


EXTERN_C const IID IID_INamespaceWalkCB2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7ac7492b-c38e-438a-87db-68737844ff70")
    INamespaceWalkCB2 : public INamespaceWalkCB
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE WalkComplete( 
            /* [in] */ HRESULT hr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INamespaceWalkCB2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INamespaceWalkCB2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INamespaceWalkCB2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INamespaceWalkCB2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *FoundItem )( 
            INamespaceWalkCB2 * This,
            /* [in] */ __RPC__in_opt IShellFolder *psf,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl);
        
        HRESULT ( STDMETHODCALLTYPE *EnterFolder )( 
            INamespaceWalkCB2 * This,
            /* [in] */ __RPC__in_opt IShellFolder *psf,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl);
        
        HRESULT ( STDMETHODCALLTYPE *LeaveFolder )( 
            INamespaceWalkCB2 * This,
            /* [in] */ __RPC__in_opt IShellFolder *psf,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeProgressDialog )( 
            INamespaceWalkCB2 * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszTitle,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszCancel);
        
        HRESULT ( STDMETHODCALLTYPE *WalkComplete )( 
            INamespaceWalkCB2 * This,
            /* [in] */ HRESULT hr);
        
        END_INTERFACE
    } INamespaceWalkCB2Vtbl;

    interface INamespaceWalkCB2
    {
        CONST_VTBL struct INamespaceWalkCB2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INamespaceWalkCB2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INamespaceWalkCB2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INamespaceWalkCB2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INamespaceWalkCB2_FoundItem(This,psf,pidl)	\
    ( (This)->lpVtbl -> FoundItem(This,psf,pidl) ) 

#define INamespaceWalkCB2_EnterFolder(This,psf,pidl)	\
    ( (This)->lpVtbl -> EnterFolder(This,psf,pidl) ) 

#define INamespaceWalkCB2_LeaveFolder(This,psf,pidl)	\
    ( (This)->lpVtbl -> LeaveFolder(This,psf,pidl) ) 

#define INamespaceWalkCB2_InitializeProgressDialog(This,ppszTitle,ppszCancel)	\
    ( (This)->lpVtbl -> InitializeProgressDialog(This,ppszTitle,ppszCancel) ) 


#define INamespaceWalkCB2_WalkComplete(This,hr)	\
    ( (This)->lpVtbl -> WalkComplete(This,hr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INamespaceWalkCB2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0102 */
/* [local] */ 

#endif  // (_WIN32_IE >= _WIN32_IE_IE70)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0102_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0102_v0_0_s_ifspec;

#ifndef __INamespaceWalk_INTERFACE_DEFINED__
#define __INamespaceWalk_INTERFACE_DEFINED__

/* interface INamespaceWalk */
/* [object][helpstring][uuid] */ 


enum tagNAMESPACEWALKFLAG
    {	NSWF_NONE_IMPLIES_ALL	= 0x1,
	NSWF_ONE_IMPLIES_ALL	= 0x2,
	NSWF_DONT_TRAVERSE_LINKS	= 0x4,
	NSWF_DONT_ACCUMULATE_RESULT	= 0x8,
	NSWF_TRAVERSE_STREAM_JUNCTIONS	= 0x10,
	NSWF_FILESYSTEM_ONLY	= 0x20,
	NSWF_SHOW_PROGRESS	= 0x40,
	NSWF_FLAG_VIEWORDER	= 0x80,
	NSWF_IGNORE_AUTOPLAY_HIDA	= 0x100,
	NSWF_ASYNC	= 0x200,
	NSWF_DONT_RESOLVE_LINKS	= 0x400,
	NSWF_ACCUMULATE_FOLDERS	= 0x800,
	NSWF_DONT_SORT	= 0x1000,
	NSWF_USE_TRANSFER_MEDIUM	= 0x2000
    } ;

EXTERN_C const IID IID_INamespaceWalk;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("57ced8a7-3f4a-432c-9350-30f24483f74f")
    INamespaceWalk : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Walk( 
            /* [in] */ __RPC__in_opt IUnknown *punkToWalk,
            /* [in] */ DWORD dwFlags,
            /* [in] */ int cDepth,
            /* [unique][in] */ __RPC__in_opt INamespaceWalkCB *pnswcb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIDArrayResult( 
            /* [out] */ __RPC__out UINT *pcItems,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcItems) PIDLIST_ABSOLUTE **prgpidl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INamespaceWalkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INamespaceWalk * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INamespaceWalk * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INamespaceWalk * This);
        
        HRESULT ( STDMETHODCALLTYPE *Walk )( 
            INamespaceWalk * This,
            /* [in] */ __RPC__in_opt IUnknown *punkToWalk,
            /* [in] */ DWORD dwFlags,
            /* [in] */ int cDepth,
            /* [unique][in] */ __RPC__in_opt INamespaceWalkCB *pnswcb);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDArrayResult )( 
            INamespaceWalk * This,
            /* [out] */ __RPC__out UINT *pcItems,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcItems) PIDLIST_ABSOLUTE **prgpidl);
        
        END_INTERFACE
    } INamespaceWalkVtbl;

    interface INamespaceWalk
    {
        CONST_VTBL struct INamespaceWalkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INamespaceWalk_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INamespaceWalk_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INamespaceWalk_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INamespaceWalk_Walk(This,punkToWalk,dwFlags,cDepth,pnswcb)	\
    ( (This)->lpVtbl -> Walk(This,punkToWalk,dwFlags,cDepth,pnswcb) ) 

#define INamespaceWalk_GetIDArrayResult(This,pcItems,prgpidl)	\
    ( (This)->lpVtbl -> GetIDArrayResult(This,pcItems,prgpidl) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INamespaceWalk_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0103 */
/* [local] */ 

#endif  // NTDDI_WINXP || (_WIN32_IE >= _WIN32_IE_IE70)
__inline void FreeIDListArray(PIDLIST_RELATIVE *ppidls, UINT cItems)
{                                        
     UINT i;                             
     for (i = 0; i < cItems; i++)        
     {                                   
         CoTaskMemFree(ppidls[i]);       
     }                                   
     CoTaskMemFree(ppidls);              
}                                        
#if defined(STRICT_TYPED_ITEMIDS) && defined(__cplusplus)
__inline void FreeIDListArrayFull(PIDLIST_ABSOLUTE *ppidls, UINT cItems)
{                                        
     for (UINT i = 0; i < cItems; i++)   
     {                                   
         CoTaskMemFree(ppidls[i]);       
     }                                   
     CoTaskMemFree(ppidls);              
}                                        
__inline void FreeIDListArrayChild(PITEMID_CHILD *ppidls, UINT cItems)
{                                        
     for (UINT i = 0; i < cItems; i++)   
     {                                   
         CoTaskMemFree(ppidls[i]);       
     }                                   
     CoTaskMemFree(ppidls);              
}                                        
#else //  defined(STRICT_TYPED_ITEMIDS) && defined(__cplusplus)
#define FreeIDListArrayFull FreeIDListArray
#define FreeIDListArrayChild FreeIDListArray
#endif //  defined(STRICT_TYPED_ITEMIDS) && defined(__cplusplus)
#define ACDD_VISIBLE        0x0001


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0103_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0103_v0_0_s_ifspec;

#ifndef __IAutoCompleteDropDown_INTERFACE_DEFINED__
#define __IAutoCompleteDropDown_INTERFACE_DEFINED__

/* interface IAutoCompleteDropDown */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IAutoCompleteDropDown;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3CD141F4-3C6A-11d2-BCAA-00C04FD929DB")
    IAutoCompleteDropDown : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDropDownStatus( 
            /* [out] */ __RPC__out DWORD *pdwFlags,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetEnumerator( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAutoCompleteDropDownVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAutoCompleteDropDown * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAutoCompleteDropDown * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAutoCompleteDropDown * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDropDownStatus )( 
            IAutoCompleteDropDown * This,
            /* [out] */ __RPC__out DWORD *pdwFlags,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszString);
        
        HRESULT ( STDMETHODCALLTYPE *ResetEnumerator )( 
            IAutoCompleteDropDown * This);
        
        END_INTERFACE
    } IAutoCompleteDropDownVtbl;

    interface IAutoCompleteDropDown
    {
        CONST_VTBL struct IAutoCompleteDropDownVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAutoCompleteDropDown_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAutoCompleteDropDown_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAutoCompleteDropDown_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAutoCompleteDropDown_GetDropDownStatus(This,pdwFlags,ppwszString)	\
    ( (This)->lpVtbl -> GetDropDownStatus(This,pdwFlags,ppwszString) ) 

#define IAutoCompleteDropDown_ResetEnumerator(This)	\
    ( (This)->lpVtbl -> ResetEnumerator(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAutoCompleteDropDown_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0104 */
/* [local] */ 

#if (_WIN32_IE >= _WIN32_IE_IE40)
#include <pshpack8.h>
typedef struct tagBANDSITEINFO
    {
    DWORD dwMask;
    DWORD dwState;
    DWORD dwStyle;
    } 	BANDSITEINFO;

#include <poppack.h>

enum tagBANDSITECID
    {	BSID_BANDADDED	= 0,
	BSID_BANDREMOVED	= ( BSID_BANDADDED + 1 ) 
    } ;
#define BSIM_STATE          0x00000001
#define BSIM_STYLE          0x00000002
#define BSSF_VISIBLE        0x00000001
#define BSSF_NOTITLE        0x00000002
#define BSSF_UNDELETEABLE   0x00001000
#define BSIS_AUTOGRIPPER               0x00000000
#define BSIS_NOGRIPPER                 0x00000001
#define BSIS_ALWAYSGRIPPER             0x00000002
#define BSIS_LEFTALIGN                 0x00000004
#define BSIS_SINGLECLICK               0x00000008
#define BSIS_NOCONTEXTMENU             0x00000010
#define BSIS_NODROPTARGET              0x00000020
#define BSIS_NOCAPTION                 0x00000040
#define BSIS_PREFERNOLINEBREAK         0x00000080
#define BSIS_LOCKED                    0x00000100
#if (_WIN32_IE >= _WIN32_IE_IE70)
#define BSIS_PRESERVEORDERDURINGLAYOUT 0x00000200
#endif  // _WIN32_IE_IE70
#define SID_SBandSite IID_IBandSite
#define CGID_BandSite IID_IBandSite


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0104_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0104_v0_0_s_ifspec;

#ifndef __IBandSite_INTERFACE_DEFINED__
#define __IBandSite_INTERFACE_DEFINED__

/* interface IBandSite */
/* [uuid][object] */ 


EXTERN_C const IID IID_IBandSite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4CF504B0-DE96-11D0-8B3F-00A0C911E8E5")
    IBandSite : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddBand( 
            /* [in] */ __RPC__in_opt IUnknown *punk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumBands( 
            /* [in] */ UINT uBand,
            /* [out] */ __RPC__out DWORD *pdwBandID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryBand( 
            /* [in] */ DWORD dwBandID,
            /* [out] */ __RPC__deref_out_opt IDeskBand **ppstb,
            /* [out] */ __RPC__out DWORD *pdwState,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cchName) LPWSTR pszName,
            /* [in] */ int cchName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBandState( 
            /* [in] */ DWORD dwBandID,
            /* [in] */ DWORD dwMask,
            /* [in] */ DWORD dwState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveBand( 
            /* [in] */ DWORD dwBandID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBandObject( 
            /* [in] */ DWORD dwBandID,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBandSiteInfo( 
            /* [in] */ __RPC__in const BANDSITEINFO *pbsinfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBandSiteInfo( 
            /* [out][in] */ __RPC__inout BANDSITEINFO *pbsinfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBandSiteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBandSite * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBandSite * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBandSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddBand )( 
            IBandSite * This,
            /* [in] */ __RPC__in_opt IUnknown *punk);
        
        HRESULT ( STDMETHODCALLTYPE *EnumBands )( 
            IBandSite * This,
            /* [in] */ UINT uBand,
            /* [out] */ __RPC__out DWORD *pdwBandID);
        
        HRESULT ( STDMETHODCALLTYPE *QueryBand )( 
            IBandSite * This,
            /* [in] */ DWORD dwBandID,
            /* [out] */ __RPC__deref_out_opt IDeskBand **ppstb,
            /* [out] */ __RPC__out DWORD *pdwState,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cchName) LPWSTR pszName,
            /* [in] */ int cchName);
        
        HRESULT ( STDMETHODCALLTYPE *SetBandState )( 
            IBandSite * This,
            /* [in] */ DWORD dwBandID,
            /* [in] */ DWORD dwMask,
            /* [in] */ DWORD dwState);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveBand )( 
            IBandSite * This,
            /* [in] */ DWORD dwBandID);
        
        HRESULT ( STDMETHODCALLTYPE *GetBandObject )( 
            IBandSite * This,
            /* [in] */ DWORD dwBandID,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *SetBandSiteInfo )( 
            IBandSite * This,
            /* [in] */ __RPC__in const BANDSITEINFO *pbsinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetBandSiteInfo )( 
            IBandSite * This,
            /* [out][in] */ __RPC__inout BANDSITEINFO *pbsinfo);
        
        END_INTERFACE
    } IBandSiteVtbl;

    interface IBandSite
    {
        CONST_VTBL struct IBandSiteVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBandSite_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBandSite_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBandSite_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBandSite_AddBand(This,punk)	\
    ( (This)->lpVtbl -> AddBand(This,punk) ) 

#define IBandSite_EnumBands(This,uBand,pdwBandID)	\
    ( (This)->lpVtbl -> EnumBands(This,uBand,pdwBandID) ) 

#define IBandSite_QueryBand(This,dwBandID,ppstb,pdwState,pszName,cchName)	\
    ( (This)->lpVtbl -> QueryBand(This,dwBandID,ppstb,pdwState,pszName,cchName) ) 

#define IBandSite_SetBandState(This,dwBandID,dwMask,dwState)	\
    ( (This)->lpVtbl -> SetBandState(This,dwBandID,dwMask,dwState) ) 

#define IBandSite_RemoveBand(This,dwBandID)	\
    ( (This)->lpVtbl -> RemoveBand(This,dwBandID) ) 

#define IBandSite_GetBandObject(This,dwBandID,riid,ppv)	\
    ( (This)->lpVtbl -> GetBandObject(This,dwBandID,riid,ppv) ) 

#define IBandSite_SetBandSiteInfo(This,pbsinfo)	\
    ( (This)->lpVtbl -> SetBandSiteInfo(This,pbsinfo) ) 

#define IBandSite_GetBandSiteInfo(This,pbsinfo)	\
    ( (This)->lpVtbl -> GetBandSiteInfo(This,pbsinfo) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IBandSite_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0105 */
/* [local] */ 

#endif // _WIN32_IE_IE40
#if (NTDDI_VERSION >= NTDDI_WINXP)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0105_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0105_v0_0_s_ifspec;

#ifndef __IModalWindow_INTERFACE_DEFINED__
#define __IModalWindow_INTERFACE_DEFINED__

/* interface IModalWindow */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IModalWindow;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b4db1657-70d7-485e-8e3e-6fcb5a5c1802")
    IModalWindow : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Show( 
            /* [in] */ 
            __in  HWND hwndParent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IModalWindowVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IModalWindow * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IModalWindow * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IModalWindow * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Show )( 
            IModalWindow * This,
            /* [in] */ 
            __in  HWND hwndParent);
        
        END_INTERFACE
    } IModalWindowVtbl;

    interface IModalWindow
    {
        CONST_VTBL struct IModalWindowVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IModalWindow_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IModalWindow_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IModalWindow_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IModalWindow_Show(This,hwndParent)	\
    ( (This)->lpVtbl -> Show(This,hwndParent) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IModalWindow_RemoteShow_Proxy( 
    IModalWindow * This,
    /* [in] */ __RPC__in HWND hwndParent);


void __RPC_STUB IModalWindow_RemoteShow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IModalWindow_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0106 */
/* [local] */ 

#define PROPSTR_EXTENSIONCOMPLETIONSTATE L"ExtensionCompletionState"

enum tagCDBURNINGEXTENSIONRET
    {	CDBE_RET_DEFAULT	= 0,
	CDBE_RET_DONTRUNOTHEREXTS	= 0x1,
	CDBE_RET_STOPWIZARD	= 0x2
    } ;
#define SID_CDWizardHost IID_ICDBurnExt

enum tagCDBURNINGEXTENSIONACTION
    {	CDBE_TYPE_MUSIC	= 0x1,
	CDBE_TYPE_DATA	= 0x2,
	CDBE_TYPE_ALL	= ( int  )0xffffffff
    } ;
typedef DWORD CDBE_ACTIONS;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0106_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0106_v0_0_s_ifspec;

#ifndef __ICDBurnExt_INTERFACE_DEFINED__
#define __ICDBurnExt_INTERFACE_DEFINED__

/* interface ICDBurnExt */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_ICDBurnExt;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2271dcca-74fc-4414-8fb7-c56b05ace2d7")
    ICDBurnExt : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSupportedActionTypes( 
            /* [out] */ __RPC__out CDBE_ACTIONS *pdwActions) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICDBurnExtVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICDBurnExt * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICDBurnExt * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICDBurnExt * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedActionTypes )( 
            ICDBurnExt * This,
            /* [out] */ __RPC__out CDBE_ACTIONS *pdwActions);
        
        END_INTERFACE
    } ICDBurnExtVtbl;

    interface ICDBurnExt
    {
        CONST_VTBL struct ICDBurnExtVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICDBurnExt_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICDBurnExt_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICDBurnExt_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICDBurnExt_GetSupportedActionTypes(This,pdwActions)	\
    ( (This)->lpVtbl -> GetSupportedActionTypes(This,pdwActions) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICDBurnExt_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0107 */
/* [local] */ 

#endif  // NTDDI_WINXP


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0107_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0107_v0_0_s_ifspec;

#ifndef __IContextMenuSite_INTERFACE_DEFINED__
#define __IContextMenuSite_INTERFACE_DEFINED__

/* interface IContextMenuSite */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IContextMenuSite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0811AEBE-0B87-4C54-9E72-548CF649016B")
    IContextMenuSite : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DoContextMenuPopup( 
            /* [in] */ __RPC__in_opt IUnknown *punkContextMenu,
            /* [in] */ UINT fFlags,
            /* [in] */ POINT pt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IContextMenuSiteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IContextMenuSite * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IContextMenuSite * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IContextMenuSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *DoContextMenuPopup )( 
            IContextMenuSite * This,
            /* [in] */ __RPC__in_opt IUnknown *punkContextMenu,
            /* [in] */ UINT fFlags,
            /* [in] */ POINT pt);
        
        END_INTERFACE
    } IContextMenuSiteVtbl;

    interface IContextMenuSite
    {
        CONST_VTBL struct IContextMenuSiteVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContextMenuSite_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IContextMenuSite_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IContextMenuSite_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IContextMenuSite_DoContextMenuPopup(This,punkContextMenu,fFlags,pt)	\
    ( (This)->lpVtbl -> DoContextMenuPopup(This,punkContextMenu,fFlags,pt) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IContextMenuSite_INTERFACE_DEFINED__ */


#ifndef __IEnumReadyCallback_INTERFACE_DEFINED__
#define __IEnumReadyCallback_INTERFACE_DEFINED__

/* interface IEnumReadyCallback */
/* [local][unique][object][uuid] */ 


EXTERN_C const IID IID_IEnumReadyCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("61E00D45-8FFF-4e60-924E-6537B61612DD")
    IEnumReadyCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumReady( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumReadyCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumReadyCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumReadyCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumReadyCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumReady )( 
            IEnumReadyCallback * This);
        
        END_INTERFACE
    } IEnumReadyCallbackVtbl;

    interface IEnumReadyCallback
    {
        CONST_VTBL struct IEnumReadyCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumReadyCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumReadyCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumReadyCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumReadyCallback_EnumReady(This)	\
    ( (This)->lpVtbl -> EnumReady(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumReadyCallback_INTERFACE_DEFINED__ */


#ifndef __IEnumerableView_INTERFACE_DEFINED__
#define __IEnumerableView_INTERFACE_DEFINED__

/* interface IEnumerableView */
/* [object][local][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumerableView;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8C8BF236-1AEC-495f-9894-91D57C3C686F")
    IEnumerableView : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetEnumReadyCallback( 
            /* [in] */ 
            __in  IEnumReadyCallback *percb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateEnumIDListFromContents( 
            /* [in] */ 
            __in  PCIDLIST_ABSOLUTE pidlFolder,
            /* [in] */ 
            __in  DWORD dwEnumFlags,
            /* [out] */ 
            __deref_out  IEnumIDList **ppEnumIDList) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumerableViewVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumerableView * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumerableView * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumerableView * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetEnumReadyCallback )( 
            IEnumerableView * This,
            /* [in] */ 
            __in  IEnumReadyCallback *percb);
        
        HRESULT ( STDMETHODCALLTYPE *CreateEnumIDListFromContents )( 
            IEnumerableView * This,
            /* [in] */ 
            __in  PCIDLIST_ABSOLUTE pidlFolder,
            /* [in] */ 
            __in  DWORD dwEnumFlags,
            /* [out] */ 
            __deref_out  IEnumIDList **ppEnumIDList);
        
        END_INTERFACE
    } IEnumerableViewVtbl;

    interface IEnumerableView
    {
        CONST_VTBL struct IEnumerableViewVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumerableView_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumerableView_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumerableView_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumerableView_SetEnumReadyCallback(This,percb)	\
    ( (This)->lpVtbl -> SetEnumReadyCallback(This,percb) ) 

#define IEnumerableView_CreateEnumIDListFromContents(This,pidlFolder,dwEnumFlags,ppEnumIDList)	\
    ( (This)->lpVtbl -> CreateEnumIDListFromContents(This,pidlFolder,dwEnumFlags,ppEnumIDList) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumerableView_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0110 */
/* [local] */ 

#define SID_EnumerableView IID_IEnumerableView
#if (NTDDI_VERSION >= NTDDI_WINXP) || (_WIN32_IE >= _WIN32_IE_IE70)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0110_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0110_v0_0_s_ifspec;

#ifndef __IInsertItem_INTERFACE_DEFINED__
#define __IInsertItem_INTERFACE_DEFINED__

/* interface IInsertItem */
/* [local][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IInsertItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D2B57227-3D23-4b95-93C0-492BD454C356")
    IInsertItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InsertItem( 
            /* [in] */ 
            __in  PCUIDLIST_RELATIVE pidl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInsertItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInsertItem * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInsertItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInsertItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *InsertItem )( 
            IInsertItem * This,
            /* [in] */ 
            __in  PCUIDLIST_RELATIVE pidl);
        
        END_INTERFACE
    } IInsertItemVtbl;

    interface IInsertItem
    {
        CONST_VTBL struct IInsertItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInsertItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInsertItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInsertItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInsertItem_InsertItem(This,pidl)	\
    ( (This)->lpVtbl -> InsertItem(This,pidl) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInsertItem_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0111 */
/* [local] */ 

#if (NTDDI_VERSION >= NTDDI_WINXP)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0111_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0111_v0_0_s_ifspec;

#ifndef __IMenuBand_INTERFACE_DEFINED__
#define __IMenuBand_INTERFACE_DEFINED__

/* interface IMenuBand */
/* [local][unique][object][uuid] */ 


enum tagMENUBANDHANDLERCID
    {	MBHANDCID_PIDLSELECT	= 0
    } ;

EXTERN_C const IID IID_IMenuBand;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("568804CD-CBD7-11d0-9816-00C04FD91972")
    IMenuBand : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsMenuMessage( 
            /* [in] */ 
            __in  MSG *pmsg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TranslateMenuMessage( 
            /* [out][in] */ 
            __inout  MSG *pmsg,
            /* [out] */ 
            __out  LRESULT *plRet) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMenuBandVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMenuBand * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMenuBand * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMenuBand * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsMenuMessage )( 
            IMenuBand * This,
            /* [in] */ 
            __in  MSG *pmsg);
        
        HRESULT ( STDMETHODCALLTYPE *TranslateMenuMessage )( 
            IMenuBand * This,
            /* [out][in] */ 
            __inout  MSG *pmsg,
            /* [out] */ 
            __out  LRESULT *plRet);
        
        END_INTERFACE
    } IMenuBandVtbl;

    interface IMenuBand
    {
        CONST_VTBL struct IMenuBandVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMenuBand_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMenuBand_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMenuBand_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMenuBand_IsMenuMessage(This,pmsg)	\
    ( (This)->lpVtbl -> IsMenuMessage(This,pmsg) ) 

#define IMenuBand_TranslateMenuMessage(This,pmsg,plRet)	\
    ( (This)->lpVtbl -> TranslateMenuMessage(This,pmsg,plRet) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMenuBand_INTERFACE_DEFINED__ */


#ifndef __IFolderBandPriv_INTERFACE_DEFINED__
#define __IFolderBandPriv_INTERFACE_DEFINED__

/* interface IFolderBandPriv */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IFolderBandPriv;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("47c01f95-e185-412c-b5c5-4f27df965aea")
    IFolderBandPriv : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetCascade( 
            /* [in] */ BOOL fCascade) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAccelerators( 
            /* [in] */ BOOL fAccelerators) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNoIcons( 
            /* [in] */ BOOL fNoIcons) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNoText( 
            /* [in] */ BOOL fNoText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFolderBandPrivVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFolderBandPriv * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFolderBandPriv * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFolderBandPriv * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetCascade )( 
            IFolderBandPriv * This,
            /* [in] */ BOOL fCascade);
        
        HRESULT ( STDMETHODCALLTYPE *SetAccelerators )( 
            IFolderBandPriv * This,
            /* [in] */ BOOL fAccelerators);
        
        HRESULT ( STDMETHODCALLTYPE *SetNoIcons )( 
            IFolderBandPriv * This,
            /* [in] */ BOOL fNoIcons);
        
        HRESULT ( STDMETHODCALLTYPE *SetNoText )( 
            IFolderBandPriv * This,
            /* [in] */ BOOL fNoText);
        
        END_INTERFACE
    } IFolderBandPrivVtbl;

    interface IFolderBandPriv
    {
        CONST_VTBL struct IFolderBandPrivVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFolderBandPriv_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFolderBandPriv_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFolderBandPriv_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFolderBandPriv_SetCascade(This,fCascade)	\
    ( (This)->lpVtbl -> SetCascade(This,fCascade) ) 

#define IFolderBandPriv_SetAccelerators(This,fAccelerators)	\
    ( (This)->lpVtbl -> SetAccelerators(This,fAccelerators) ) 

#define IFolderBandPriv_SetNoIcons(This,fNoIcons)	\
    ( (This)->lpVtbl -> SetNoIcons(This,fNoIcons) ) 

#define IFolderBandPriv_SetNoText(This,fNoText)	\
    ( (This)->lpVtbl -> SetNoText(This,fNoText) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFolderBandPriv_INTERFACE_DEFINED__ */


#ifndef __IRegTreeItem_INTERFACE_DEFINED__
#define __IRegTreeItem_INTERFACE_DEFINED__

/* interface IRegTreeItem */
/* [object][local][helpstring][uuid] */ 


EXTERN_C const IID IID_IRegTreeItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A9521922-0812-4d44-9EC3-7FD38C726F3D")
    IRegTreeItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCheckState( 
            /* [out] */ 
            __out  BOOL *pbCheck) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCheckState( 
            /* [in] */ 
            __in  BOOL bCheck) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRegTreeItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRegTreeItem * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRegTreeItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRegTreeItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCheckState )( 
            IRegTreeItem * This,
            /* [out] */ 
            __out  BOOL *pbCheck);
        
        HRESULT ( STDMETHODCALLTYPE *SetCheckState )( 
            IRegTreeItem * This,
            /* [in] */ 
            __in  BOOL bCheck);
        
        END_INTERFACE
    } IRegTreeItemVtbl;

    interface IRegTreeItem
    {
        CONST_VTBL struct IRegTreeItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRegTreeItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRegTreeItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRegTreeItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRegTreeItem_GetCheckState(This,pbCheck)	\
    ( (This)->lpVtbl -> GetCheckState(This,pbCheck) ) 

#define IRegTreeItem_SetCheckState(This,bCheck)	\
    ( (This)->lpVtbl -> SetCheckState(This,bCheck) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRegTreeItem_INTERFACE_DEFINED__ */


#ifndef __IImageRecompress_INTERFACE_DEFINED__
#define __IImageRecompress_INTERFACE_DEFINED__

/* interface IImageRecompress */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IImageRecompress;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("505f1513-6b3e-4892-a272-59f8889a4d3e")
    IImageRecompress : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RecompressImage( 
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [in] */ int cx,
            /* [in] */ int cy,
            /* [in] */ int iQuality,
            /* [in] */ __RPC__in_opt IStorage *pstg,
            /* [out] */ __RPC__deref_out_opt IStream **ppstrmOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImageRecompressVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IImageRecompress * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IImageRecompress * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IImageRecompress * This);
        
        HRESULT ( STDMETHODCALLTYPE *RecompressImage )( 
            IImageRecompress * This,
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [in] */ int cx,
            /* [in] */ int cy,
            /* [in] */ int iQuality,
            /* [in] */ __RPC__in_opt IStorage *pstg,
            /* [out] */ __RPC__deref_out_opt IStream **ppstrmOut);
        
        END_INTERFACE
    } IImageRecompressVtbl;

    interface IImageRecompress
    {
        CONST_VTBL struct IImageRecompressVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImageRecompress_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IImageRecompress_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IImageRecompress_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IImageRecompress_RecompressImage(This,psi,cx,cy,iQuality,pstg,ppstrmOut)	\
    ( (This)->lpVtbl -> RecompressImage(This,psi,cx,cy,iQuality,pstg,ppstrmOut) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IImageRecompress_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0115 */
/* [local] */ 

#endif  // NTDDI_WINXP
#endif  // NTDDI_WINXP) || (_WIN32_IE >= _WIN32_IE_IE70)
#if (_WIN32_IE >= _WIN32_IE_IE60)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0115_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0115_v0_0_s_ifspec;

#ifndef __IDeskBar_INTERFACE_DEFINED__
#define __IDeskBar_INTERFACE_DEFINED__

/* interface IDeskBar */
/* [local][unique][object][uuid] */ 


EXTERN_C const IID IID_IDeskBar;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EB0FE173-1A3A-11D0-89B3-00A0C90A90AC")
    IDeskBar : public IOleWindow
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetClient( 
            /* [in] */ 
            __in  IUnknown *punkClient) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClient( 
            /* [out] */ 
            __deref_out  IUnknown **ppunkClient) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnPosRectChangeDB( 
            /* [in] */ 
            __in  RECT *prc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDeskBarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDeskBar * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDeskBar * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDeskBar * This);
        
        /* [input_sync] */ HRESULT ( STDMETHODCALLTYPE *GetWindow )( 
            IDeskBar * This,
            /* [out] */ HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *ContextSensitiveHelp )( 
            IDeskBar * This,
            /* [in] */ BOOL fEnterMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetClient )( 
            IDeskBar * This,
            /* [in] */ 
            __in  IUnknown *punkClient);
        
        HRESULT ( STDMETHODCALLTYPE *GetClient )( 
            IDeskBar * This,
            /* [out] */ 
            __deref_out  IUnknown **ppunkClient);
        
        HRESULT ( STDMETHODCALLTYPE *OnPosRectChangeDB )( 
            IDeskBar * This,
            /* [in] */ 
            __in  RECT *prc);
        
        END_INTERFACE
    } IDeskBarVtbl;

    interface IDeskBar
    {
        CONST_VTBL struct IDeskBarVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDeskBar_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDeskBar_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDeskBar_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDeskBar_GetWindow(This,phwnd)	\
    ( (This)->lpVtbl -> GetWindow(This,phwnd) ) 

#define IDeskBar_ContextSensitiveHelp(This,fEnterMode)	\
    ( (This)->lpVtbl -> ContextSensitiveHelp(This,fEnterMode) ) 


#define IDeskBar_SetClient(This,punkClient)	\
    ( (This)->lpVtbl -> SetClient(This,punkClient) ) 

#define IDeskBar_GetClient(This,ppunkClient)	\
    ( (This)->lpVtbl -> GetClient(This,ppunkClient) ) 

#define IDeskBar_OnPosRectChangeDB(This,prc)	\
    ( (This)->lpVtbl -> OnPosRectChangeDB(This,prc) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDeskBar_INTERFACE_DEFINED__ */


#ifndef __IMenuPopup_INTERFACE_DEFINED__
#define __IMenuPopup_INTERFACE_DEFINED__

/* interface IMenuPopup */
/* [local][unique][object][uuid] */ 


enum tagMENUPOPUPSELECT
    {	MPOS_EXECUTE	= 0,
	MPOS_FULLCANCEL	= ( MPOS_EXECUTE + 1 ) ,
	MPOS_CANCELLEVEL	= ( MPOS_FULLCANCEL + 1 ) ,
	MPOS_SELECTLEFT	= ( MPOS_CANCELLEVEL + 1 ) ,
	MPOS_SELECTRIGHT	= ( MPOS_SELECTLEFT + 1 ) ,
	MPOS_CHILDTRACKING	= ( MPOS_SELECTRIGHT + 1 ) 
    } ;

enum tagMENUPOPUPPOPUPFLAGS
    {	MPPF_SETFOCUS	= 0x1,
	MPPF_INITIALSELECT	= 0x2,
	MPPF_NOANIMATE	= 0x4,
	MPPF_KEYBOARD	= 0x10,
	MPPF_REPOSITION	= 0x20,
	MPPF_FORCEZORDER	= 0x40,
	MPPF_FINALSELECT	= 0x80,
	MPPF_TOP	= 0x20000000,
	MPPF_LEFT	= 0x40000000,
	MPPF_RIGHT	= 0x60000000,
	MPPF_BOTTOM	= ( int  )0x80000000,
	MPPF_POS_MASK	= ( int  )0xe0000000,
	MPPF_ALIGN_LEFT	= 0x2000000,
	MPPF_ALIGN_RIGHT	= 0x4000000
    } ;
typedef int MP_POPUPFLAGS;


EXTERN_C const IID IID_IMenuPopup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D1E7AFEB-6A2E-11d0-8C78-00C04FD918B4")
    IMenuPopup : public IDeskBar
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Popup( 
            /* [in] */ 
            __in  POINTL *ppt,
            /* [in] */ 
            __in  RECTL *prcExclude,
            /* [in] */ 
            __in  MP_POPUPFLAGS dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSelect( 
            /* [in] */ 
            __in  DWORD dwSelectType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSubMenu( 
            /* [in] */ 
            __in  IMenuPopup *pmp,
            /* [in] */ 
            __in  BOOL fSet) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMenuPopupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMenuPopup * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMenuPopup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMenuPopup * This);
        
        /* [input_sync] */ HRESULT ( STDMETHODCALLTYPE *GetWindow )( 
            IMenuPopup * This,
            /* [out] */ HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *ContextSensitiveHelp )( 
            IMenuPopup * This,
            /* [in] */ BOOL fEnterMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetClient )( 
            IMenuPopup * This,
            /* [in] */ 
            __in  IUnknown *punkClient);
        
        HRESULT ( STDMETHODCALLTYPE *GetClient )( 
            IMenuPopup * This,
            /* [out] */ 
            __deref_out  IUnknown **ppunkClient);
        
        HRESULT ( STDMETHODCALLTYPE *OnPosRectChangeDB )( 
            IMenuPopup * This,
            /* [in] */ 
            __in  RECT *prc);
        
        HRESULT ( STDMETHODCALLTYPE *Popup )( 
            IMenuPopup * This,
            /* [in] */ 
            __in  POINTL *ppt,
            /* [in] */ 
            __in  RECTL *prcExclude,
            /* [in] */ 
            __in  MP_POPUPFLAGS dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *OnSelect )( 
            IMenuPopup * This,
            /* [in] */ 
            __in  DWORD dwSelectType);
        
        HRESULT ( STDMETHODCALLTYPE *SetSubMenu )( 
            IMenuPopup * This,
            /* [in] */ 
            __in  IMenuPopup *pmp,
            /* [in] */ 
            __in  BOOL fSet);
        
        END_INTERFACE
    } IMenuPopupVtbl;

    interface IMenuPopup
    {
        CONST_VTBL struct IMenuPopupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMenuPopup_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMenuPopup_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMenuPopup_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMenuPopup_GetWindow(This,phwnd)	\
    ( (This)->lpVtbl -> GetWindow(This,phwnd) ) 

#define IMenuPopup_ContextSensitiveHelp(This,fEnterMode)	\
    ( (This)->lpVtbl -> ContextSensitiveHelp(This,fEnterMode) ) 


#define IMenuPopup_SetClient(This,punkClient)	\
    ( (This)->lpVtbl -> SetClient(This,punkClient) ) 

#define IMenuPopup_GetClient(This,ppunkClient)	\
    ( (This)->lpVtbl -> GetClient(This,ppunkClient) ) 

#define IMenuPopup_OnPosRectChangeDB(This,prc)	\
    ( (This)->lpVtbl -> OnPosRectChangeDB(This,prc) ) 


#define IMenuPopup_Popup(This,ppt,prcExclude,dwFlags)	\
    ( (This)->lpVtbl -> Popup(This,ppt,prcExclude,dwFlags) ) 

#define IMenuPopup_OnSelect(This,dwSelectType)	\
    ( (This)->lpVtbl -> OnSelect(This,dwSelectType) ) 

#define IMenuPopup_SetSubMenu(This,pmp,fSet)	\
    ( (This)->lpVtbl -> SetSubMenu(This,pmp,fSet) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMenuPopup_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0117 */
/* [local] */ 

#endif  // _WIN32_IE_IE60
#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef /* [helpstring] */ 
enum tagFILE_USAGE_TYPE
    {	FUT_PLAYING	= 0,
	FUT_EDITING	= ( FUT_PLAYING + 1 ) ,
	FUT_GENERIC	= ( FUT_EDITING + 1 ) 
    } 	FILE_USAGE_TYPE;

#define OF_CAP_CANSWITCHTO     0x0001
#define OF_CAP_CANCLOSE        0x0002


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0117_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0117_v0_0_s_ifspec;

#ifndef __IFileIsInUse_INTERFACE_DEFINED__
#define __IFileIsInUse_INTERFACE_DEFINED__

/* interface IFileIsInUse */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_IFileIsInUse;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("64a1cbf0-3a1a-4461-9158-376969693950")
    IFileIsInUse : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAppName( 
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUsage( 
            /* [out] */ __RPC__out FILE_USAGE_TYPE *pfut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCapabilities( 
            /* [out] */ __RPC__out DWORD *pdwCapFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSwitchToHWND( 
            /* [out] */ __RPC__deref_out_opt HWND *phwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CloseFile( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFileIsInUseVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFileIsInUse * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFileIsInUse * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFileIsInUse * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAppName )( 
            IFileIsInUse * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetUsage )( 
            IFileIsInUse * This,
            /* [out] */ __RPC__out FILE_USAGE_TYPE *pfut);
        
        HRESULT ( STDMETHODCALLTYPE *GetCapabilities )( 
            IFileIsInUse * This,
            /* [out] */ __RPC__out DWORD *pdwCapFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetSwitchToHWND )( 
            IFileIsInUse * This,
            /* [out] */ __RPC__deref_out_opt HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *CloseFile )( 
            IFileIsInUse * This);
        
        END_INTERFACE
    } IFileIsInUseVtbl;

    interface IFileIsInUse
    {
        CONST_VTBL struct IFileIsInUseVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFileIsInUse_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFileIsInUse_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFileIsInUse_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFileIsInUse_GetAppName(This,ppszName)	\
    ( (This)->lpVtbl -> GetAppName(This,ppszName) ) 

#define IFileIsInUse_GetUsage(This,pfut)	\
    ( (This)->lpVtbl -> GetUsage(This,pfut) ) 

#define IFileIsInUse_GetCapabilities(This,pdwCapFlags)	\
    ( (This)->lpVtbl -> GetCapabilities(This,pdwCapFlags) ) 

#define IFileIsInUse_GetSwitchToHWND(This,phwnd)	\
    ( (This)->lpVtbl -> GetSwitchToHWND(This,phwnd) ) 

#define IFileIsInUse_CloseFile(This)	\
    ( (This)->lpVtbl -> CloseFile(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFileIsInUse_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0118 */
/* [local] */ 


typedef /* [v1_enum] */ 
enum tagFDE_OVERWRITE_RESPONSE
    {	FDEOR_DEFAULT	= 0,
	FDEOR_ACCEPT	= 0x1,
	FDEOR_REFUSE	= 0x2
    } 	FDE_OVERWRITE_RESPONSE;

typedef /* [v1_enum] */ 
enum tagFDE_SHAREVIOLATION_RESPONSE
    {	FDESVR_DEFAULT	= 0,
	FDESVR_ACCEPT	= 0x1,
	FDESVR_REFUSE	= 0x2
    } 	FDE_SHAREVIOLATION_RESPONSE;

typedef /* [v1_enum] */ 
enum tagFDAP
    {	FDAP_BOTTOM	= 0,
	FDAP_TOP	= 0x1
    } 	FDAP;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0118_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0118_v0_0_s_ifspec;

#ifndef __IFileDialogEvents_INTERFACE_DEFINED__
#define __IFileDialogEvents_INTERFACE_DEFINED__

/* interface IFileDialogEvents */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IFileDialogEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("973510db-7d7f-452b-8975-74a85828d354")
    IFileDialogEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnFileOk( 
            /* [in] */ __RPC__in_opt IFileDialog *pfd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnFolderChanging( 
            /* [in] */ __RPC__in_opt IFileDialog *pfd,
            /* [in] */ __RPC__in_opt IShellItem *psiFolder) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnFolderChange( 
            /* [in] */ __RPC__in_opt IFileDialog *pfd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSelectionChange( 
            /* [in] */ __RPC__in_opt IFileDialog *pfd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnShareViolation( 
            /* [in] */ __RPC__in_opt IFileDialog *pfd,
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [out] */ __RPC__out FDE_SHAREVIOLATION_RESPONSE *pResponse) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnTypeChange( 
            /* [in] */ __RPC__in_opt IFileDialog *pfd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnOverwrite( 
            /* [in] */ __RPC__in_opt IFileDialog *pfd,
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [out] */ __RPC__out FDE_OVERWRITE_RESPONSE *pResponse) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFileDialogEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFileDialogEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFileDialogEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFileDialogEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnFileOk )( 
            IFileDialogEvents * This,
            /* [in] */ __RPC__in_opt IFileDialog *pfd);
        
        HRESULT ( STDMETHODCALLTYPE *OnFolderChanging )( 
            IFileDialogEvents * This,
            /* [in] */ __RPC__in_opt IFileDialog *pfd,
            /* [in] */ __RPC__in_opt IShellItem *psiFolder);
        
        HRESULT ( STDMETHODCALLTYPE *OnFolderChange )( 
            IFileDialogEvents * This,
            /* [in] */ __RPC__in_opt IFileDialog *pfd);
        
        HRESULT ( STDMETHODCALLTYPE *OnSelectionChange )( 
            IFileDialogEvents * This,
            /* [in] */ __RPC__in_opt IFileDialog *pfd);
        
        HRESULT ( STDMETHODCALLTYPE *OnShareViolation )( 
            IFileDialogEvents * This,
            /* [in] */ __RPC__in_opt IFileDialog *pfd,
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [out] */ __RPC__out FDE_SHAREVIOLATION_RESPONSE *pResponse);
        
        HRESULT ( STDMETHODCALLTYPE *OnTypeChange )( 
            IFileDialogEvents * This,
            /* [in] */ __RPC__in_opt IFileDialog *pfd);
        
        HRESULT ( STDMETHODCALLTYPE *OnOverwrite )( 
            IFileDialogEvents * This,
            /* [in] */ __RPC__in_opt IFileDialog *pfd,
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [out] */ __RPC__out FDE_OVERWRITE_RESPONSE *pResponse);
        
        END_INTERFACE
    } IFileDialogEventsVtbl;

    interface IFileDialogEvents
    {
        CONST_VTBL struct IFileDialogEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFileDialogEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFileDialogEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFileDialogEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFileDialogEvents_OnFileOk(This,pfd)	\
    ( (This)->lpVtbl -> OnFileOk(This,pfd) ) 

#define IFileDialogEvents_OnFolderChanging(This,pfd,psiFolder)	\
    ( (This)->lpVtbl -> OnFolderChanging(This,pfd,psiFolder) ) 

#define IFileDialogEvents_OnFolderChange(This,pfd)	\
    ( (This)->lpVtbl -> OnFolderChange(This,pfd) ) 

#define IFileDialogEvents_OnSelectionChange(This,pfd)	\
    ( (This)->lpVtbl -> OnSelectionChange(This,pfd) ) 

#define IFileDialogEvents_OnShareViolation(This,pfd,psi,pResponse)	\
    ( (This)->lpVtbl -> OnShareViolation(This,pfd,psi,pResponse) ) 

#define IFileDialogEvents_OnTypeChange(This,pfd)	\
    ( (This)->lpVtbl -> OnTypeChange(This,pfd) ) 

#define IFileDialogEvents_OnOverwrite(This,pfd,psi,pResponse)	\
    ( (This)->lpVtbl -> OnOverwrite(This,pfd,psi,pResponse) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFileDialogEvents_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0119 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0119_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0119_v0_0_s_ifspec;

#ifndef __IFileDialog_INTERFACE_DEFINED__
#define __IFileDialog_INTERFACE_DEFINED__

/* interface IFileDialog */
/* [unique][object][uuid] */ 


enum tagFILEOPENDIALOGOPTIONS
    {	FOS_OVERWRITEPROMPT	= 0x2,
	FOS_STRICTFILETYPES	= 0x4,
	FOS_NOCHANGEDIR	= 0x8,
	FOS_PICKFOLDERS	= 0x20,
	FOS_FORCEFILESYSTEM	= 0x40,
	FOS_ALLNONSTORAGEITEMS	= 0x80,
	FOS_NOVALIDATE	= 0x100,
	FOS_ALLOWMULTISELECT	= 0x200,
	FOS_PATHMUSTEXIST	= 0x800,
	FOS_FILEMUSTEXIST	= 0x1000,
	FOS_CREATEPROMPT	= 0x2000,
	FOS_SHAREAWARE	= 0x4000,
	FOS_NOREADONLYRETURN	= 0x8000,
	FOS_NOTESTFILECREATE	= 0x10000,
	FOS_HIDEMRUPLACES	= 0x20000,
	FOS_HIDEPINNEDPLACES	= 0x40000,
	FOS_NODEREFERENCELINKS	= 0x100000,
	FOS_DONTADDTORECENT	= 0x2000000,
	FOS_FORCESHOWHIDDEN	= 0x10000000,
	FOS_DEFAULTNOMINIMODE	= 0x20000000,
	FOS_FORCEPREVIEWPANEON	= 0x40000000
    } ;

EXTERN_C const IID IID_IFileDialog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("42f85136-db7e-439c-85f1-e4075d135fc8")
    IFileDialog : public IModalWindow
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFileTypes( 
            /* [in] */ UINT cFileTypes,
            /* [size_is][in] */ __RPC__in_ecount_full(cFileTypes) const COMDLG_FILTERSPEC *rgFilterSpec) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFileTypeIndex( 
            /* [in] */ UINT iFileType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFileTypeIndex( 
            /* [out] */ __RPC__out UINT *piFileType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Advise( 
            /* [in] */ __RPC__in_opt IFileDialogEvents *pfde,
            /* [out] */ __RPC__out DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unadvise( 
            /* [in] */ DWORD dwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOptions( 
            /* [in] */ DWORD fos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOptions( 
            /* [out] */ __RPC__out DWORD *pfos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultFolder( 
            /* [in] */ __RPC__in_opt IShellItem *psi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFolder( 
            /* [in] */ __RPC__in_opt IShellItem *psi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFolder( 
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentSelection( 
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFileName( 
            /* [string][in] */ __RPC__in LPCWSTR pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFileName( 
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTitle( 
            /* [string][in] */ __RPC__in LPCWSTR pszTitle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOkButtonLabel( 
            /* [string][in] */ __RPC__in LPCWSTR pszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFileNameLabel( 
            /* [string][in] */ __RPC__in LPCWSTR pszLabel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResult( 
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddPlace( 
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [in] */ FDAP fdap) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultExtension( 
            /* [string][in] */ __RPC__in LPCWSTR pszDefaultExtension) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( 
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClientGuid( 
            /* [in] */ __RPC__in REFGUID guid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearClientData( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFilter( 
            /* [in] */ __RPC__in_opt IShellItemFilter *pFilter) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFileDialogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFileDialog * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFileDialog * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFileDialog * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Show )( 
            IFileDialog * This,
            /* [in] */ 
            __in  HWND hwndParent);
        
        HRESULT ( STDMETHODCALLTYPE *SetFileTypes )( 
            IFileDialog * This,
            /* [in] */ UINT cFileTypes,
            /* [size_is][in] */ __RPC__in_ecount_full(cFileTypes) const COMDLG_FILTERSPEC *rgFilterSpec);
        
        HRESULT ( STDMETHODCALLTYPE *SetFileTypeIndex )( 
            IFileDialog * This,
            /* [in] */ UINT iFileType);
        
        HRESULT ( STDMETHODCALLTYPE *GetFileTypeIndex )( 
            IFileDialog * This,
            /* [out] */ __RPC__out UINT *piFileType);
        
        HRESULT ( STDMETHODCALLTYPE *Advise )( 
            IFileDialog * This,
            /* [in] */ __RPC__in_opt IFileDialogEvents *pfde,
            /* [out] */ __RPC__out DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *Unadvise )( 
            IFileDialog * This,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *SetOptions )( 
            IFileDialog * This,
            /* [in] */ DWORD fos);
        
        HRESULT ( STDMETHODCALLTYPE *GetOptions )( 
            IFileDialog * This,
            /* [out] */ __RPC__out DWORD *pfos);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultFolder )( 
            IFileDialog * This,
            /* [in] */ __RPC__in_opt IShellItem *psi);
        
        HRESULT ( STDMETHODCALLTYPE *SetFolder )( 
            IFileDialog * This,
            /* [in] */ __RPC__in_opt IShellItem *psi);
        
        HRESULT ( STDMETHODCALLTYPE *GetFolder )( 
            IFileDialog * This,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentSelection )( 
            IFileDialog * This,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi);
        
        HRESULT ( STDMETHODCALLTYPE *SetFileName )( 
            IFileDialog * This,
            /* [string][in] */ __RPC__in LPCWSTR pszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetFileName )( 
            IFileDialog * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *pszName);
        
        HRESULT ( STDMETHODCALLTYPE *SetTitle )( 
            IFileDialog * This,
            /* [string][in] */ __RPC__in LPCWSTR pszTitle);
        
        HRESULT ( STDMETHODCALLTYPE *SetOkButtonLabel )( 
            IFileDialog * This,
            /* [string][in] */ __RPC__in LPCWSTR pszText);
        
        HRESULT ( STDMETHODCALLTYPE *SetFileNameLabel )( 
            IFileDialog * This,
            /* [string][in] */ __RPC__in LPCWSTR pszLabel);
        
        HRESULT ( STDMETHODCALLTYPE *GetResult )( 
            IFileDialog * This,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi);
        
        HRESULT ( STDMETHODCALLTYPE *AddPlace )( 
            IFileDialog * This,
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [in] */ FDAP fdap);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultExtension )( 
            IFileDialog * This,
            /* [string][in] */ __RPC__in LPCWSTR pszDefaultExtension);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            IFileDialog * This,
            /* [in] */ HRESULT hr);
        
        HRESULT ( STDMETHODCALLTYPE *SetClientGuid )( 
            IFileDialog * This,
            /* [in] */ __RPC__in REFGUID guid);
        
        HRESULT ( STDMETHODCALLTYPE *ClearClientData )( 
            IFileDialog * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFilter )( 
            IFileDialog * This,
            /* [in] */ __RPC__in_opt IShellItemFilter *pFilter);
        
        END_INTERFACE
    } IFileDialogVtbl;

    interface IFileDialog
    {
        CONST_VTBL struct IFileDialogVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFileDialog_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFileDialog_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFileDialog_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFileDialog_Show(This,hwndParent)	\
    ( (This)->lpVtbl -> Show(This,hwndParent) ) 


#define IFileDialog_SetFileTypes(This,cFileTypes,rgFilterSpec)	\
    ( (This)->lpVtbl -> SetFileTypes(This,cFileTypes,rgFilterSpec) ) 

#define IFileDialog_SetFileTypeIndex(This,iFileType)	\
    ( (This)->lpVtbl -> SetFileTypeIndex(This,iFileType) ) 

#define IFileDialog_GetFileTypeIndex(This,piFileType)	\
    ( (This)->lpVtbl -> GetFileTypeIndex(This,piFileType) ) 

#define IFileDialog_Advise(This,pfde,pdwCookie)	\
    ( (This)->lpVtbl -> Advise(This,pfde,pdwCookie) ) 

#define IFileDialog_Unadvise(This,dwCookie)	\
    ( (This)->lpVtbl -> Unadvise(This,dwCookie) ) 

#define IFileDialog_SetOptions(This,fos)	\
    ( (This)->lpVtbl -> SetOptions(This,fos) ) 

#define IFileDialog_GetOptions(This,pfos)	\
    ( (This)->lpVtbl -> GetOptions(This,pfos) ) 

#define IFileDialog_SetDefaultFolder(This,psi)	\
    ( (This)->lpVtbl -> SetDefaultFolder(This,psi) ) 

#define IFileDialog_SetFolder(This,psi)	\
    ( (This)->lpVtbl -> SetFolder(This,psi) ) 

#define IFileDialog_GetFolder(This,ppsi)	\
    ( (This)->lpVtbl -> GetFolder(This,ppsi) ) 

#define IFileDialog_GetCurrentSelection(This,ppsi)	\
    ( (This)->lpVtbl -> GetCurrentSelection(This,ppsi) ) 

#define IFileDialog_SetFileName(This,pszName)	\
    ( (This)->lpVtbl -> SetFileName(This,pszName) ) 

#define IFileDialog_GetFileName(This,pszName)	\
    ( (This)->lpVtbl -> GetFileName(This,pszName) ) 

#define IFileDialog_SetTitle(This,pszTitle)	\
    ( (This)->lpVtbl -> SetTitle(This,pszTitle) ) 

#define IFileDialog_SetOkButtonLabel(This,pszText)	\
    ( (This)->lpVtbl -> SetOkButtonLabel(This,pszText) ) 

#define IFileDialog_SetFileNameLabel(This,pszLabel)	\
    ( (This)->lpVtbl -> SetFileNameLabel(This,pszLabel) ) 

#define IFileDialog_GetResult(This,ppsi)	\
    ( (This)->lpVtbl -> GetResult(This,ppsi) ) 

#define IFileDialog_AddPlace(This,psi,fdap)	\
    ( (This)->lpVtbl -> AddPlace(This,psi,fdap) ) 

#define IFileDialog_SetDefaultExtension(This,pszDefaultExtension)	\
    ( (This)->lpVtbl -> SetDefaultExtension(This,pszDefaultExtension) ) 

#define IFileDialog_Close(This,hr)	\
    ( (This)->lpVtbl -> Close(This,hr) ) 

#define IFileDialog_SetClientGuid(This,guid)	\
    ( (This)->lpVtbl -> SetClientGuid(This,guid) ) 

#define IFileDialog_ClearClientData(This)	\
    ( (This)->lpVtbl -> ClearClientData(This) ) 

#define IFileDialog_SetFilter(This,pFilter)	\
    ( (This)->lpVtbl -> SetFilter(This,pFilter) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFileDialog_INTERFACE_DEFINED__ */


#ifndef __IFileSaveDialog_INTERFACE_DEFINED__
#define __IFileSaveDialog_INTERFACE_DEFINED__

/* interface IFileSaveDialog */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IFileSaveDialog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("84bccd23-5fde-4cdb-aea4-af64b83d78ab")
    IFileSaveDialog : public IFileDialog
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetSaveAsItem( 
            /* [in] */ __RPC__in_opt IShellItem *psi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProperties( 
            /* [in] */ __RPC__in_opt IPropertyStore *pStore) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCollectedProperties( 
            /* [in] */ __RPC__in_opt IPropertyDescriptionList *pList,
            /* [in] */ BOOL fAppendDefault) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__deref_out_opt IPropertyStore **ppStore) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ApplyProperties( 
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [in] */ __RPC__in_opt IPropertyStore *pStore,
            /* [unique][in] */ __RPC__in_opt HWND hwnd,
            /* [unique][in] */ __RPC__in_opt IFileOperationProgressSink *pSink) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFileSaveDialogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFileSaveDialog * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFileSaveDialog * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFileSaveDialog * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Show )( 
            IFileSaveDialog * This,
            /* [in] */ 
            __in  HWND hwndParent);
        
        HRESULT ( STDMETHODCALLTYPE *SetFileTypes )( 
            IFileSaveDialog * This,
            /* [in] */ UINT cFileTypes,
            /* [size_is][in] */ __RPC__in_ecount_full(cFileTypes) const COMDLG_FILTERSPEC *rgFilterSpec);
        
        HRESULT ( STDMETHODCALLTYPE *SetFileTypeIndex )( 
            IFileSaveDialog * This,
            /* [in] */ UINT iFileType);
        
        HRESULT ( STDMETHODCALLTYPE *GetFileTypeIndex )( 
            IFileSaveDialog * This,
            /* [out] */ __RPC__out UINT *piFileType);
        
        HRESULT ( STDMETHODCALLTYPE *Advise )( 
            IFileSaveDialog * This,
            /* [in] */ __RPC__in_opt IFileDialogEvents *pfde,
            /* [out] */ __RPC__out DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *Unadvise )( 
            IFileSaveDialog * This,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *SetOptions )( 
            IFileSaveDialog * This,
            /* [in] */ DWORD fos);
        
        HRESULT ( STDMETHODCALLTYPE *GetOptions )( 
            IFileSaveDialog * This,
            /* [out] */ __RPC__out DWORD *pfos);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultFolder )( 
            IFileSaveDialog * This,
            /* [in] */ __RPC__in_opt IShellItem *psi);
        
        HRESULT ( STDMETHODCALLTYPE *SetFolder )( 
            IFileSaveDialog * This,
            /* [in] */ __RPC__in_opt IShellItem *psi);
        
        HRESULT ( STDMETHODCALLTYPE *GetFolder )( 
            IFileSaveDialog * This,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentSelection )( 
            IFileSaveDialog * This,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi);
        
        HRESULT ( STDMETHODCALLTYPE *SetFileName )( 
            IFileSaveDialog * This,
            /* [string][in] */ __RPC__in LPCWSTR pszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetFileName )( 
            IFileSaveDialog * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *pszName);
        
        HRESULT ( STDMETHODCALLTYPE *SetTitle )( 
            IFileSaveDialog * This,
            /* [string][in] */ __RPC__in LPCWSTR pszTitle);
        
        HRESULT ( STDMETHODCALLTYPE *SetOkButtonLabel )( 
            IFileSaveDialog * This,
            /* [string][in] */ __RPC__in LPCWSTR pszText);
        
        HRESULT ( STDMETHODCALLTYPE *SetFileNameLabel )( 
            IFileSaveDialog * This,
            /* [string][in] */ __RPC__in LPCWSTR pszLabel);
        
        HRESULT ( STDMETHODCALLTYPE *GetResult )( 
            IFileSaveDialog * This,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi);
        
        HRESULT ( STDMETHODCALLTYPE *AddPlace )( 
            IFileSaveDialog * This,
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [in] */ FDAP fdap);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultExtension )( 
            IFileSaveDialog * This,
            /* [string][in] */ __RPC__in LPCWSTR pszDefaultExtension);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            IFileSaveDialog * This,
            /* [in] */ HRESULT hr);
        
        HRESULT ( STDMETHODCALLTYPE *SetClientGuid )( 
            IFileSaveDialog * This,
            /* [in] */ __RPC__in REFGUID guid);
        
        HRESULT ( STDMETHODCALLTYPE *ClearClientData )( 
            IFileSaveDialog * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFilter )( 
            IFileSaveDialog * This,
            /* [in] */ __RPC__in_opt IShellItemFilter *pFilter);
        
        HRESULT ( STDMETHODCALLTYPE *SetSaveAsItem )( 
            IFileSaveDialog * This,
            /* [in] */ __RPC__in_opt IShellItem *psi);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperties )( 
            IFileSaveDialog * This,
            /* [in] */ __RPC__in_opt IPropertyStore *pStore);
        
        HRESULT ( STDMETHODCALLTYPE *SetCollectedProperties )( 
            IFileSaveDialog * This,
            /* [in] */ __RPC__in_opt IPropertyDescriptionList *pList,
            /* [in] */ BOOL fAppendDefault);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            IFileSaveDialog * This,
            /* [out] */ __RPC__deref_out_opt IPropertyStore **ppStore);
        
        HRESULT ( STDMETHODCALLTYPE *ApplyProperties )( 
            IFileSaveDialog * This,
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [in] */ __RPC__in_opt IPropertyStore *pStore,
            /* [unique][in] */ __RPC__in_opt HWND hwnd,
            /* [unique][in] */ __RPC__in_opt IFileOperationProgressSink *pSink);
        
        END_INTERFACE
    } IFileSaveDialogVtbl;

    interface IFileSaveDialog
    {
        CONST_VTBL struct IFileSaveDialogVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFileSaveDialog_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFileSaveDialog_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFileSaveDialog_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFileSaveDialog_Show(This,hwndParent)	\
    ( (This)->lpVtbl -> Show(This,hwndParent) ) 


#define IFileSaveDialog_SetFileTypes(This,cFileTypes,rgFilterSpec)	\
    ( (This)->lpVtbl -> SetFileTypes(This,cFileTypes,rgFilterSpec) ) 

#define IFileSaveDialog_SetFileTypeIndex(This,iFileType)	\
    ( (This)->lpVtbl -> SetFileTypeIndex(This,iFileType) ) 

#define IFileSaveDialog_GetFileTypeIndex(This,piFileType)	\
    ( (This)->lpVtbl -> GetFileTypeIndex(This,piFileType) ) 

#define IFileSaveDialog_Advise(This,pfde,pdwCookie)	\
    ( (This)->lpVtbl -> Advise(This,pfde,pdwCookie) ) 

#define IFileSaveDialog_Unadvise(This,dwCookie)	\
    ( (This)->lpVtbl -> Unadvise(This,dwCookie) ) 

#define IFileSaveDialog_SetOptions(This,fos)	\
    ( (This)->lpVtbl -> SetOptions(This,fos) ) 

#define IFileSaveDialog_GetOptions(This,pfos)	\
    ( (This)->lpVtbl -> GetOptions(This,pfos) ) 

#define IFileSaveDialog_SetDefaultFolder(This,psi)	\
    ( (This)->lpVtbl -> SetDefaultFolder(This,psi) ) 

#define IFileSaveDialog_SetFolder(This,psi)	\
    ( (This)->lpVtbl -> SetFolder(This,psi) ) 

#define IFileSaveDialog_GetFolder(This,ppsi)	\
    ( (This)->lpVtbl -> GetFolder(This,ppsi) ) 

#define IFileSaveDialog_GetCurrentSelection(This,ppsi)	\
    ( (This)->lpVtbl -> GetCurrentSelection(This,ppsi) ) 

#define IFileSaveDialog_SetFileName(This,pszName)	\
    ( (This)->lpVtbl -> SetFileName(This,pszName) ) 

#define IFileSaveDialog_GetFileName(This,pszName)	\
    ( (This)->lpVtbl -> GetFileName(This,pszName) ) 

#define IFileSaveDialog_SetTitle(This,pszTitle)	\
    ( (This)->lpVtbl -> SetTitle(This,pszTitle) ) 

#define IFileSaveDialog_SetOkButtonLabel(This,pszText)	\
    ( (This)->lpVtbl -> SetOkButtonLabel(This,pszText) ) 

#define IFileSaveDialog_SetFileNameLabel(This,pszLabel)	\
    ( (This)->lpVtbl -> SetFileNameLabel(This,pszLabel) ) 

#define IFileSaveDialog_GetResult(This,ppsi)	\
    ( (This)->lpVtbl -> GetResult(This,ppsi) ) 

#define IFileSaveDialog_AddPlace(This,psi,fdap)	\
    ( (This)->lpVtbl -> AddPlace(This,psi,fdap) ) 

#define IFileSaveDialog_SetDefaultExtension(This,pszDefaultExtension)	\
    ( (This)->lpVtbl -> SetDefaultExtension(This,pszDefaultExtension) ) 

#define IFileSaveDialog_Close(This,hr)	\
    ( (This)->lpVtbl -> Close(This,hr) ) 

#define IFileSaveDialog_SetClientGuid(This,guid)	\
    ( (This)->lpVtbl -> SetClientGuid(This,guid) ) 

#define IFileSaveDialog_ClearClientData(This)	\
    ( (This)->lpVtbl -> ClearClientData(This) ) 

#define IFileSaveDialog_SetFilter(This,pFilter)	\
    ( (This)->lpVtbl -> SetFilter(This,pFilter) ) 


#define IFileSaveDialog_SetSaveAsItem(This,psi)	\
    ( (This)->lpVtbl -> SetSaveAsItem(This,psi) ) 

#define IFileSaveDialog_SetProperties(This,pStore)	\
    ( (This)->lpVtbl -> SetProperties(This,pStore) ) 

#define IFileSaveDialog_SetCollectedProperties(This,pList,fAppendDefault)	\
    ( (This)->lpVtbl -> SetCollectedProperties(This,pList,fAppendDefault) ) 

#define IFileSaveDialog_GetProperties(This,ppStore)	\
    ( (This)->lpVtbl -> GetProperties(This,ppStore) ) 

#define IFileSaveDialog_ApplyProperties(This,psi,pStore,hwnd,pSink)	\
    ( (This)->lpVtbl -> ApplyProperties(This,psi,pStore,hwnd,pSink) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFileSaveDialog_INTERFACE_DEFINED__ */


#ifndef __IFileOpenDialog_INTERFACE_DEFINED__
#define __IFileOpenDialog_INTERFACE_DEFINED__

/* interface IFileOpenDialog */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IFileOpenDialog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d57c7288-d4ad-4768-be02-9d969532d960")
    IFileOpenDialog : public IFileDialog
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetResults( 
            /* [out] */ __RPC__deref_out_opt IShellItemArray **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSelectedItems( 
            /* [out] */ __RPC__deref_out_opt IShellItemArray **ppsai) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFileOpenDialogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFileOpenDialog * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFileOpenDialog * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFileOpenDialog * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Show )( 
            IFileOpenDialog * This,
            /* [in] */ 
            __in  HWND hwndParent);
        
        HRESULT ( STDMETHODCALLTYPE *SetFileTypes )( 
            IFileOpenDialog * This,
            /* [in] */ UINT cFileTypes,
            /* [size_is][in] */ __RPC__in_ecount_full(cFileTypes) const COMDLG_FILTERSPEC *rgFilterSpec);
        
        HRESULT ( STDMETHODCALLTYPE *SetFileTypeIndex )( 
            IFileOpenDialog * This,
            /* [in] */ UINT iFileType);
        
        HRESULT ( STDMETHODCALLTYPE *GetFileTypeIndex )( 
            IFileOpenDialog * This,
            /* [out] */ __RPC__out UINT *piFileType);
        
        HRESULT ( STDMETHODCALLTYPE *Advise )( 
            IFileOpenDialog * This,
            /* [in] */ __RPC__in_opt IFileDialogEvents *pfde,
            /* [out] */ __RPC__out DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *Unadvise )( 
            IFileOpenDialog * This,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *SetOptions )( 
            IFileOpenDialog * This,
            /* [in] */ DWORD fos);
        
        HRESULT ( STDMETHODCALLTYPE *GetOptions )( 
            IFileOpenDialog * This,
            /* [out] */ __RPC__out DWORD *pfos);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultFolder )( 
            IFileOpenDialog * This,
            /* [in] */ __RPC__in_opt IShellItem *psi);
        
        HRESULT ( STDMETHODCALLTYPE *SetFolder )( 
            IFileOpenDialog * This,
            /* [in] */ __RPC__in_opt IShellItem *psi);
        
        HRESULT ( STDMETHODCALLTYPE *GetFolder )( 
            IFileOpenDialog * This,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentSelection )( 
            IFileOpenDialog * This,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi);
        
        HRESULT ( STDMETHODCALLTYPE *SetFileName )( 
            IFileOpenDialog * This,
            /* [string][in] */ __RPC__in LPCWSTR pszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetFileName )( 
            IFileOpenDialog * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *pszName);
        
        HRESULT ( STDMETHODCALLTYPE *SetTitle )( 
            IFileOpenDialog * This,
            /* [string][in] */ __RPC__in LPCWSTR pszTitle);
        
        HRESULT ( STDMETHODCALLTYPE *SetOkButtonLabel )( 
            IFileOpenDialog * This,
            /* [string][in] */ __RPC__in LPCWSTR pszText);
        
        HRESULT ( STDMETHODCALLTYPE *SetFileNameLabel )( 
            IFileOpenDialog * This,
            /* [string][in] */ __RPC__in LPCWSTR pszLabel);
        
        HRESULT ( STDMETHODCALLTYPE *GetResult )( 
            IFileOpenDialog * This,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi);
        
        HRESULT ( STDMETHODCALLTYPE *AddPlace )( 
            IFileOpenDialog * This,
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [in] */ FDAP fdap);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultExtension )( 
            IFileOpenDialog * This,
            /* [string][in] */ __RPC__in LPCWSTR pszDefaultExtension);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            IFileOpenDialog * This,
            /* [in] */ HRESULT hr);
        
        HRESULT ( STDMETHODCALLTYPE *SetClientGuid )( 
            IFileOpenDialog * This,
            /* [in] */ __RPC__in REFGUID guid);
        
        HRESULT ( STDMETHODCALLTYPE *ClearClientData )( 
            IFileOpenDialog * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFilter )( 
            IFileOpenDialog * This,
            /* [in] */ __RPC__in_opt IShellItemFilter *pFilter);
        
        HRESULT ( STDMETHODCALLTYPE *GetResults )( 
            IFileOpenDialog * This,
            /* [out] */ __RPC__deref_out_opt IShellItemArray **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelectedItems )( 
            IFileOpenDialog * This,
            /* [out] */ __RPC__deref_out_opt IShellItemArray **ppsai);
        
        END_INTERFACE
    } IFileOpenDialogVtbl;

    interface IFileOpenDialog
    {
        CONST_VTBL struct IFileOpenDialogVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFileOpenDialog_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFileOpenDialog_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFileOpenDialog_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFileOpenDialog_Show(This,hwndParent)	\
    ( (This)->lpVtbl -> Show(This,hwndParent) ) 


#define IFileOpenDialog_SetFileTypes(This,cFileTypes,rgFilterSpec)	\
    ( (This)->lpVtbl -> SetFileTypes(This,cFileTypes,rgFilterSpec) ) 

#define IFileOpenDialog_SetFileTypeIndex(This,iFileType)	\
    ( (This)->lpVtbl -> SetFileTypeIndex(This,iFileType) ) 

#define IFileOpenDialog_GetFileTypeIndex(This,piFileType)	\
    ( (This)->lpVtbl -> GetFileTypeIndex(This,piFileType) ) 

#define IFileOpenDialog_Advise(This,pfde,pdwCookie)	\
    ( (This)->lpVtbl -> Advise(This,pfde,pdwCookie) ) 

#define IFileOpenDialog_Unadvise(This,dwCookie)	\
    ( (This)->lpVtbl -> Unadvise(This,dwCookie) ) 

#define IFileOpenDialog_SetOptions(This,fos)	\
    ( (This)->lpVtbl -> SetOptions(This,fos) ) 

#define IFileOpenDialog_GetOptions(This,pfos)	\
    ( (This)->lpVtbl -> GetOptions(This,pfos) ) 

#define IFileOpenDialog_SetDefaultFolder(This,psi)	\
    ( (This)->lpVtbl -> SetDefaultFolder(This,psi) ) 

#define IFileOpenDialog_SetFolder(This,psi)	\
    ( (This)->lpVtbl -> SetFolder(This,psi) ) 

#define IFileOpenDialog_GetFolder(This,ppsi)	\
    ( (This)->lpVtbl -> GetFolder(This,ppsi) ) 

#define IFileOpenDialog_GetCurrentSelection(This,ppsi)	\
    ( (This)->lpVtbl -> GetCurrentSelection(This,ppsi) ) 

#define IFileOpenDialog_SetFileName(This,pszName)	\
    ( (This)->lpVtbl -> SetFileName(This,pszName) ) 

#define IFileOpenDialog_GetFileName(This,pszName)	\
    ( (This)->lpVtbl -> GetFileName(This,pszName) ) 

#define IFileOpenDialog_SetTitle(This,pszTitle)	\
    ( (This)->lpVtbl -> SetTitle(This,pszTitle) ) 

#define IFileOpenDialog_SetOkButtonLabel(This,pszText)	\
    ( (This)->lpVtbl -> SetOkButtonLabel(This,pszText) ) 

#define IFileOpenDialog_SetFileNameLabel(This,pszLabel)	\
    ( (This)->lpVtbl -> SetFileNameLabel(This,pszLabel) ) 

#define IFileOpenDialog_GetResult(This,ppsi)	\
    ( (This)->lpVtbl -> GetResult(This,ppsi) ) 

#define IFileOpenDialog_AddPlace(This,psi,fdap)	\
    ( (This)->lpVtbl -> AddPlace(This,psi,fdap) ) 

#define IFileOpenDialog_SetDefaultExtension(This,pszDefaultExtension)	\
    ( (This)->lpVtbl -> SetDefaultExtension(This,pszDefaultExtension) ) 

#define IFileOpenDialog_Close(This,hr)	\
    ( (This)->lpVtbl -> Close(This,hr) ) 

#define IFileOpenDialog_SetClientGuid(This,guid)	\
    ( (This)->lpVtbl -> SetClientGuid(This,guid) ) 

#define IFileOpenDialog_ClearClientData(This)	\
    ( (This)->lpVtbl -> ClearClientData(This) ) 

#define IFileOpenDialog_SetFilter(This,pFilter)	\
    ( (This)->lpVtbl -> SetFilter(This,pFilter) ) 


#define IFileOpenDialog_GetResults(This,ppenum)	\
    ( (This)->lpVtbl -> GetResults(This,ppenum) ) 

#define IFileOpenDialog_GetSelectedItems(This,ppsai)	\
    ( (This)->lpVtbl -> GetSelectedItems(This,ppsai) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFileOpenDialog_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0122 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum tagCDCONTROLSTATE
    {	CDCS_INACTIVE	= 0,
	CDCS_ENABLED	= 0x1,
	CDCS_VISIBLE	= 0x2
    } 	CDCONTROLSTATE;

typedef DWORD CDCONTROLSTATEF;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0122_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0122_v0_0_s_ifspec;

#ifndef __IFileDialogCustomize_INTERFACE_DEFINED__
#define __IFileDialogCustomize_INTERFACE_DEFINED__

/* interface IFileDialogCustomize */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IFileDialogCustomize;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e6fdd21a-163f-4975-9c8c-a69f1ba37034")
    IFileDialogCustomize : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnableOpenDropDown( 
            /* [in] */ DWORD dwIDCtl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddMenu( 
            /* [in] */ DWORD dwIDCtl,
            /* [string][in] */ __RPC__in LPCWSTR pszLabel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddPushButton( 
            /* [in] */ DWORD dwIDCtl,
            /* [string][in] */ __RPC__in LPCWSTR pszLabel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddComboBox( 
            /* [in] */ DWORD dwIDCtl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddRadioButtonList( 
            /* [in] */ DWORD dwIDCtl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddCheckButton( 
            /* [in] */ DWORD dwIDCtl,
            /* [string][in] */ __RPC__in LPCWSTR pszLabel,
            /* [in] */ BOOL bChecked) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddEditBox( 
            /* [in] */ DWORD dwIDCtl,
            /* [string][in] */ __RPC__in LPCWSTR pszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddSeparator( 
            /* [in] */ DWORD dwIDCtl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddText( 
            /* [in] */ DWORD dwIDCtl,
            /* [string][in] */ __RPC__in LPCWSTR pszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetControlLabel( 
            /* [in] */ DWORD dwIDCtl,
            /* [string][in] */ __RPC__in LPCWSTR pszLabel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetControlState( 
            /* [in] */ DWORD dwIDCtl,
            /* [out] */ __RPC__out CDCONTROLSTATEF *pdwState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetControlState( 
            /* [in] */ DWORD dwIDCtl,
            /* [in] */ CDCONTROLSTATEF dwState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEditBoxText( 
            /* [in] */ DWORD dwIDCtl,
            /* [string][out] */ __RPC__deref_out_opt_string WCHAR **ppszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEditBoxText( 
            /* [in] */ DWORD dwIDCtl,
            /* [string][in] */ __RPC__in LPCWSTR pszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCheckButtonState( 
            /* [in] */ DWORD dwIDCtl,
            /* [out] */ __RPC__out BOOL *pbChecked) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCheckButtonState( 
            /* [in] */ DWORD dwIDCtl,
            /* [in] */ BOOL bChecked) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddControlItem( 
            /* [in] */ DWORD dwIDCtl,
            /* [in] */ DWORD dwIDItem,
            /* [in] */ __RPC__in LPCWSTR pszLabel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveControlItem( 
            /* [in] */ DWORD dwIDCtl,
            /* [in] */ DWORD dwIDItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAllControlItems( 
            /* [in] */ DWORD dwIDCtl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetControlItemState( 
            /* [in] */ DWORD dwIDCtl,
            /* [in] */ DWORD dwIDItem,
            /* [out] */ __RPC__out CDCONTROLSTATEF *pdwState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetControlItemState( 
            /* [in] */ DWORD dwIDCtl,
            /* [in] */ DWORD dwIDItem,
            /* [in] */ CDCONTROLSTATEF dwState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSelectedControlItem( 
            /* [in] */ DWORD dwIDCtl,
            /* [out] */ __RPC__out DWORD *pdwIDItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSelectedControlItem( 
            /* [in] */ DWORD dwIDCtl,
            /* [in] */ DWORD dwIDItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartVisualGroup( 
            /* [in] */ DWORD dwIDCtl,
            /* [string][in] */ __RPC__in LPCWSTR pszLabel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndVisualGroup( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MakeProminent( 
            /* [in] */ DWORD dwIDCtl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetControlItemText( 
            /* [in] */ DWORD dwIDCtl,
            /* [in] */ DWORD dwIDItem,
            /* [string][in] */ __RPC__in LPCWSTR pszLabel) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFileDialogCustomizeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFileDialogCustomize * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFileDialogCustomize * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFileDialogCustomize * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnableOpenDropDown )( 
            IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl);
        
        HRESULT ( STDMETHODCALLTYPE *AddMenu )( 
            IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl,
            /* [string][in] */ __RPC__in LPCWSTR pszLabel);
        
        HRESULT ( STDMETHODCALLTYPE *AddPushButton )( 
            IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl,
            /* [string][in] */ __RPC__in LPCWSTR pszLabel);
        
        HRESULT ( STDMETHODCALLTYPE *AddComboBox )( 
            IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl);
        
        HRESULT ( STDMETHODCALLTYPE *AddRadioButtonList )( 
            IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl);
        
        HRESULT ( STDMETHODCALLTYPE *AddCheckButton )( 
            IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl,
            /* [string][in] */ __RPC__in LPCWSTR pszLabel,
            /* [in] */ BOOL bChecked);
        
        HRESULT ( STDMETHODCALLTYPE *AddEditBox )( 
            IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl,
            /* [string][in] */ __RPC__in LPCWSTR pszText);
        
        HRESULT ( STDMETHODCALLTYPE *AddSeparator )( 
            IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl);
        
        HRESULT ( STDMETHODCALLTYPE *AddText )( 
            IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl,
            /* [string][in] */ __RPC__in LPCWSTR pszText);
        
        HRESULT ( STDMETHODCALLTYPE *SetControlLabel )( 
            IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl,
            /* [string][in] */ __RPC__in LPCWSTR pszLabel);
        
        HRESULT ( STDMETHODCALLTYPE *GetControlState )( 
            IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl,
            /* [out] */ __RPC__out CDCONTROLSTATEF *pdwState);
        
        HRESULT ( STDMETHODCALLTYPE *SetControlState )( 
            IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl,
            /* [in] */ CDCONTROLSTATEF dwState);
        
        HRESULT ( STDMETHODCALLTYPE *GetEditBoxText )( 
            IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl,
            /* [string][out] */ __RPC__deref_out_opt_string WCHAR **ppszText);
        
        HRESULT ( STDMETHODCALLTYPE *SetEditBoxText )( 
            IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl,
            /* [string][in] */ __RPC__in LPCWSTR pszText);
        
        HRESULT ( STDMETHODCALLTYPE *GetCheckButtonState )( 
            IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl,
            /* [out] */ __RPC__out BOOL *pbChecked);
        
        HRESULT ( STDMETHODCALLTYPE *SetCheckButtonState )( 
            IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl,
            /* [in] */ BOOL bChecked);
        
        HRESULT ( STDMETHODCALLTYPE *AddControlItem )( 
            IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl,
            /* [in] */ DWORD dwIDItem,
            /* [in] */ __RPC__in LPCWSTR pszLabel);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveControlItem )( 
            IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl,
            /* [in] */ DWORD dwIDItem);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAllControlItems )( 
            IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl);
        
        HRESULT ( STDMETHODCALLTYPE *GetControlItemState )( 
            IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl,
            /* [in] */ DWORD dwIDItem,
            /* [out] */ __RPC__out CDCONTROLSTATEF *pdwState);
        
        HRESULT ( STDMETHODCALLTYPE *SetControlItemState )( 
            IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl,
            /* [in] */ DWORD dwIDItem,
            /* [in] */ CDCONTROLSTATEF dwState);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelectedControlItem )( 
            IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl,
            /* [out] */ __RPC__out DWORD *pdwIDItem);
        
        HRESULT ( STDMETHODCALLTYPE *SetSelectedControlItem )( 
            IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl,
            /* [in] */ DWORD dwIDItem);
        
        HRESULT ( STDMETHODCALLTYPE *StartVisualGroup )( 
            IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl,
            /* [string][in] */ __RPC__in LPCWSTR pszLabel);
        
        HRESULT ( STDMETHODCALLTYPE *EndVisualGroup )( 
            IFileDialogCustomize * This);
        
        HRESULT ( STDMETHODCALLTYPE *MakeProminent )( 
            IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl);
        
        HRESULT ( STDMETHODCALLTYPE *SetControlItemText )( 
            IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl,
            /* [in] */ DWORD dwIDItem,
            /* [string][in] */ __RPC__in LPCWSTR pszLabel);
        
        END_INTERFACE
    } IFileDialogCustomizeVtbl;

    interface IFileDialogCustomize
    {
        CONST_VTBL struct IFileDialogCustomizeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFileDialogCustomize_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFileDialogCustomize_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFileDialogCustomize_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFileDialogCustomize_EnableOpenDropDown(This,dwIDCtl)	\
    ( (This)->lpVtbl -> EnableOpenDropDown(This,dwIDCtl) ) 

#define IFileDialogCustomize_AddMenu(This,dwIDCtl,pszLabel)	\
    ( (This)->lpVtbl -> AddMenu(This,dwIDCtl,pszLabel) ) 

#define IFileDialogCustomize_AddPushButton(This,dwIDCtl,pszLabel)	\
    ( (This)->lpVtbl -> AddPushButton(This,dwIDCtl,pszLabel) ) 

#define IFileDialogCustomize_AddComboBox(This,dwIDCtl)	\
    ( (This)->lpVtbl -> AddComboBox(This,dwIDCtl) ) 

#define IFileDialogCustomize_AddRadioButtonList(This,dwIDCtl)	\
    ( (This)->lpVtbl -> AddRadioButtonList(This,dwIDCtl) ) 

#define IFileDialogCustomize_AddCheckButton(This,dwIDCtl,pszLabel,bChecked)	\
    ( (This)->lpVtbl -> AddCheckButton(This,dwIDCtl,pszLabel,bChecked) ) 

#define IFileDialogCustomize_AddEditBox(This,dwIDCtl,pszText)	\
    ( (This)->lpVtbl -> AddEditBox(This,dwIDCtl,pszText) ) 

#define IFileDialogCustomize_AddSeparator(This,dwIDCtl)	\
    ( (This)->lpVtbl -> AddSeparator(This,dwIDCtl) ) 

#define IFileDialogCustomize_AddText(This,dwIDCtl,pszText)	\
    ( (This)->lpVtbl -> AddText(This,dwIDCtl,pszText) ) 

#define IFileDialogCustomize_SetControlLabel(This,dwIDCtl,pszLabel)	\
    ( (This)->lpVtbl -> SetControlLabel(This,dwIDCtl,pszLabel) ) 

#define IFileDialogCustomize_GetControlState(This,dwIDCtl,pdwState)	\
    ( (This)->lpVtbl -> GetControlState(This,dwIDCtl,pdwState) ) 

#define IFileDialogCustomize_SetControlState(This,dwIDCtl,dwState)	\
    ( (This)->lpVtbl -> SetControlState(This,dwIDCtl,dwState) ) 

#define IFileDialogCustomize_GetEditBoxText(This,dwIDCtl,ppszText)	\
    ( (This)->lpVtbl -> GetEditBoxText(This,dwIDCtl,ppszText) ) 

#define IFileDialogCustomize_SetEditBoxText(This,dwIDCtl,pszText)	\
    ( (This)->lpVtbl -> SetEditBoxText(This,dwIDCtl,pszText) ) 

#define IFileDialogCustomize_GetCheckButtonState(This,dwIDCtl,pbChecked)	\
    ( (This)->lpVtbl -> GetCheckButtonState(This,dwIDCtl,pbChecked) ) 

#define IFileDialogCustomize_SetCheckButtonState(This,dwIDCtl,bChecked)	\
    ( (This)->lpVtbl -> SetCheckButtonState(This,dwIDCtl,bChecked) ) 

#define IFileDialogCustomize_AddControlItem(This,dwIDCtl,dwIDItem,pszLabel)	\
    ( (This)->lpVtbl -> AddControlItem(This,dwIDCtl,dwIDItem,pszLabel) ) 

#define IFileDialogCustomize_RemoveControlItem(This,dwIDCtl,dwIDItem)	\
    ( (This)->lpVtbl -> RemoveControlItem(This,dwIDCtl,dwIDItem) ) 

#define IFileDialogCustomize_RemoveAllControlItems(This,dwIDCtl)	\
    ( (This)->lpVtbl -> RemoveAllControlItems(This,dwIDCtl) ) 

#define IFileDialogCustomize_GetControlItemState(This,dwIDCtl,dwIDItem,pdwState)	\
    ( (This)->lpVtbl -> GetControlItemState(This,dwIDCtl,dwIDItem,pdwState) ) 

#define IFileDialogCustomize_SetControlItemState(This,dwIDCtl,dwIDItem,dwState)	\
    ( (This)->lpVtbl -> SetControlItemState(This,dwIDCtl,dwIDItem,dwState) ) 

#define IFileDialogCustomize_GetSelectedControlItem(This,dwIDCtl,pdwIDItem)	\
    ( (This)->lpVtbl -> GetSelectedControlItem(This,dwIDCtl,pdwIDItem) ) 

#define IFileDialogCustomize_SetSelectedControlItem(This,dwIDCtl,dwIDItem)	\
    ( (This)->lpVtbl -> SetSelectedControlItem(This,dwIDCtl,dwIDItem) ) 

#define IFileDialogCustomize_StartVisualGroup(This,dwIDCtl,pszLabel)	\
    ( (This)->lpVtbl -> StartVisualGroup(This,dwIDCtl,pszLabel) ) 

#define IFileDialogCustomize_EndVisualGroup(This)	\
    ( (This)->lpVtbl -> EndVisualGroup(This) ) 

#define IFileDialogCustomize_MakeProminent(This,dwIDCtl)	\
    ( (This)->lpVtbl -> MakeProminent(This,dwIDCtl) ) 

#define IFileDialogCustomize_SetControlItemText(This,dwIDCtl,dwIDItem,pszLabel)	\
    ( (This)->lpVtbl -> SetControlItemText(This,dwIDCtl,dwIDItem,pszLabel) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFileDialogCustomize_INTERFACE_DEFINED__ */


#ifndef __IFileDialogControlEvents_INTERFACE_DEFINED__
#define __IFileDialogControlEvents_INTERFACE_DEFINED__

/* interface IFileDialogControlEvents */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IFileDialogControlEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("36116642-D713-4b97-9B83-7484A9D00433")
    IFileDialogControlEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnItemSelected( 
            /* [in] */ __RPC__in_opt IFileDialogCustomize *pfdc,
            /* [in] */ DWORD dwIDCtl,
            /* [in] */ DWORD dwIDItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnButtonClicked( 
            /* [in] */ __RPC__in_opt IFileDialogCustomize *pfdc,
            /* [in] */ DWORD dwIDCtl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnCheckButtonToggled( 
            /* [in] */ __RPC__in_opt IFileDialogCustomize *pfdc,
            /* [in] */ DWORD dwIDCtl,
            /* [in] */ BOOL bChecked) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnControlActivating( 
            /* [in] */ __RPC__in_opt IFileDialogCustomize *pfdc,
            /* [in] */ DWORD dwIDCtl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFileDialogControlEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFileDialogControlEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFileDialogControlEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFileDialogControlEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnItemSelected )( 
            IFileDialogControlEvents * This,
            /* [in] */ __RPC__in_opt IFileDialogCustomize *pfdc,
            /* [in] */ DWORD dwIDCtl,
            /* [in] */ DWORD dwIDItem);
        
        HRESULT ( STDMETHODCALLTYPE *OnButtonClicked )( 
            IFileDialogControlEvents * This,
            /* [in] */ __RPC__in_opt IFileDialogCustomize *pfdc,
            /* [in] */ DWORD dwIDCtl);
        
        HRESULT ( STDMETHODCALLTYPE *OnCheckButtonToggled )( 
            IFileDialogControlEvents * This,
            /* [in] */ __RPC__in_opt IFileDialogCustomize *pfdc,
            /* [in] */ DWORD dwIDCtl,
            /* [in] */ BOOL bChecked);
        
        HRESULT ( STDMETHODCALLTYPE *OnControlActivating )( 
            IFileDialogControlEvents * This,
            /* [in] */ __RPC__in_opt IFileDialogCustomize *pfdc,
            /* [in] */ DWORD dwIDCtl);
        
        END_INTERFACE
    } IFileDialogControlEventsVtbl;

    interface IFileDialogControlEvents
    {
        CONST_VTBL struct IFileDialogControlEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFileDialogControlEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFileDialogControlEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFileDialogControlEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFileDialogControlEvents_OnItemSelected(This,pfdc,dwIDCtl,dwIDItem)	\
    ( (This)->lpVtbl -> OnItemSelected(This,pfdc,dwIDCtl,dwIDItem) ) 

#define IFileDialogControlEvents_OnButtonClicked(This,pfdc,dwIDCtl)	\
    ( (This)->lpVtbl -> OnButtonClicked(This,pfdc,dwIDCtl) ) 

#define IFileDialogControlEvents_OnCheckButtonToggled(This,pfdc,dwIDCtl,bChecked)	\
    ( (This)->lpVtbl -> OnCheckButtonToggled(This,pfdc,dwIDCtl,bChecked) ) 

#define IFileDialogControlEvents_OnControlActivating(This,pfdc,dwIDCtl)	\
    ( (This)->lpVtbl -> OnControlActivating(This,pfdc,dwIDCtl) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFileDialogControlEvents_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0124 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum tagASSOCIATIONLEVEL
    {	AL_MACHINE	= 0,
	AL_EFFECTIVE	= ( AL_MACHINE + 1 ) ,
	AL_USER	= ( AL_EFFECTIVE + 1 ) 
    } 	ASSOCIATIONLEVEL;

typedef /* [v1_enum] */ 
enum tagASSOCIATIONTYPE
    {	AT_FILEEXTENSION	= 0,
	AT_URLPROTOCOL	= ( AT_FILEEXTENSION + 1 ) ,
	AT_STARTMENUCLIENT	= ( AT_URLPROTOCOL + 1 ) ,
	AT_MIMETYPE	= ( AT_STARTMENUCLIENT + 1 ) 
    } 	ASSOCIATIONTYPE;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0124_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0124_v0_0_s_ifspec;

#ifndef __IApplicationAssociationRegistration_INTERFACE_DEFINED__
#define __IApplicationAssociationRegistration_INTERFACE_DEFINED__

/* interface IApplicationAssociationRegistration */
/* [helpstring][unique][uuid][object] */ 


EXTERN_C const IID IID_IApplicationAssociationRegistration;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4e530b0a-e611-4c77-a3ac-9031d022281b")
    IApplicationAssociationRegistration : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryCurrentDefault( 
            /* [string][in] */ __RPC__in LPCWSTR pszQuery,
            /* [in] */ ASSOCIATIONTYPE atQueryType,
            /* [in] */ ASSOCIATIONLEVEL alQueryLevel,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszAssociation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryAppIsDefault( 
            /* [string][in] */ __RPC__in LPCWSTR pszQuery,
            /* [in] */ ASSOCIATIONTYPE atQueryType,
            /* [in] */ ASSOCIATIONLEVEL alQueryLevel,
            /* [string][in] */ __RPC__in LPCWSTR pszAppRegistryName,
            /* [out] */ __RPC__out BOOL *pfDefault) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryAppIsDefaultAll( 
            /* [in] */ ASSOCIATIONLEVEL alQueryLevel,
            /* [string][in] */ __RPC__in LPCWSTR pszAppRegistryName,
            /* [out] */ __RPC__out BOOL *pfDefault) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAppAsDefault( 
            /* [string][in] */ __RPC__in LPCWSTR pszAppRegistryName,
            /* [string][in] */ __RPC__in LPCWSTR pszSet,
            /* [in] */ ASSOCIATIONTYPE atSetType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAppAsDefaultAll( 
            /* [string][in] */ __RPC__in LPCWSTR pszAppRegistryName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearUserAssociations( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IApplicationAssociationRegistrationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IApplicationAssociationRegistration * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IApplicationAssociationRegistration * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IApplicationAssociationRegistration * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryCurrentDefault )( 
            IApplicationAssociationRegistration * This,
            /* [string][in] */ __RPC__in LPCWSTR pszQuery,
            /* [in] */ ASSOCIATIONTYPE atQueryType,
            /* [in] */ ASSOCIATIONLEVEL alQueryLevel,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszAssociation);
        
        HRESULT ( STDMETHODCALLTYPE *QueryAppIsDefault )( 
            IApplicationAssociationRegistration * This,
            /* [string][in] */ __RPC__in LPCWSTR pszQuery,
            /* [in] */ ASSOCIATIONTYPE atQueryType,
            /* [in] */ ASSOCIATIONLEVEL alQueryLevel,
            /* [string][in] */ __RPC__in LPCWSTR pszAppRegistryName,
            /* [out] */ __RPC__out BOOL *pfDefault);
        
        HRESULT ( STDMETHODCALLTYPE *QueryAppIsDefaultAll )( 
            IApplicationAssociationRegistration * This,
            /* [in] */ ASSOCIATIONLEVEL alQueryLevel,
            /* [string][in] */ __RPC__in LPCWSTR pszAppRegistryName,
            /* [out] */ __RPC__out BOOL *pfDefault);
        
        HRESULT ( STDMETHODCALLTYPE *SetAppAsDefault )( 
            IApplicationAssociationRegistration * This,
            /* [string][in] */ __RPC__in LPCWSTR pszAppRegistryName,
            /* [string][in] */ __RPC__in LPCWSTR pszSet,
            /* [in] */ ASSOCIATIONTYPE atSetType);
        
        HRESULT ( STDMETHODCALLTYPE *SetAppAsDefaultAll )( 
            IApplicationAssociationRegistration * This,
            /* [string][in] */ __RPC__in LPCWSTR pszAppRegistryName);
        
        HRESULT ( STDMETHODCALLTYPE *ClearUserAssociations )( 
            IApplicationAssociationRegistration * This);
        
        END_INTERFACE
    } IApplicationAssociationRegistrationVtbl;

    interface IApplicationAssociationRegistration
    {
        CONST_VTBL struct IApplicationAssociationRegistrationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IApplicationAssociationRegistration_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IApplicationAssociationRegistration_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IApplicationAssociationRegistration_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IApplicationAssociationRegistration_QueryCurrentDefault(This,pszQuery,atQueryType,alQueryLevel,ppszAssociation)	\
    ( (This)->lpVtbl -> QueryCurrentDefault(This,pszQuery,atQueryType,alQueryLevel,ppszAssociation) ) 

#define IApplicationAssociationRegistration_QueryAppIsDefault(This,pszQuery,atQueryType,alQueryLevel,pszAppRegistryName,pfDefault)	\
    ( (This)->lpVtbl -> QueryAppIsDefault(This,pszQuery,atQueryType,alQueryLevel,pszAppRegistryName,pfDefault) ) 

#define IApplicationAssociationRegistration_QueryAppIsDefaultAll(This,alQueryLevel,pszAppRegistryName,pfDefault)	\
    ( (This)->lpVtbl -> QueryAppIsDefaultAll(This,alQueryLevel,pszAppRegistryName,pfDefault) ) 

#define IApplicationAssociationRegistration_SetAppAsDefault(This,pszAppRegistryName,pszSet,atSetType)	\
    ( (This)->lpVtbl -> SetAppAsDefault(This,pszAppRegistryName,pszSet,atSetType) ) 

#define IApplicationAssociationRegistration_SetAppAsDefaultAll(This,pszAppRegistryName)	\
    ( (This)->lpVtbl -> SetAppAsDefaultAll(This,pszAppRegistryName) ) 

#define IApplicationAssociationRegistration_ClearUserAssociations(This)	\
    ( (This)->lpVtbl -> ClearUserAssociations(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IApplicationAssociationRegistration_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0125 */
/* [local] */ 

SHSTDAPI SHCreateAssociationRegistration(__in REFIID riid, __deref_out void **ppv);


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0125_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0125_v0_0_s_ifspec;

#ifndef __IApplicationAssociationRegistrationUI_INTERFACE_DEFINED__
#define __IApplicationAssociationRegistrationUI_INTERFACE_DEFINED__

/* interface IApplicationAssociationRegistrationUI */
/* [helpstring][unique][uuid][object] */ 


EXTERN_C const IID IID_IApplicationAssociationRegistrationUI;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1f76a169-f994-40ac-8fc8-0959e8874710")
    IApplicationAssociationRegistrationUI : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE LaunchAdvancedAssociationUI( 
            /* [string][in] */ __RPC__in LPCWSTR pszAppRegistryName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IApplicationAssociationRegistrationUIVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IApplicationAssociationRegistrationUI * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IApplicationAssociationRegistrationUI * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IApplicationAssociationRegistrationUI * This);
        
        HRESULT ( STDMETHODCALLTYPE *LaunchAdvancedAssociationUI )( 
            IApplicationAssociationRegistrationUI * This,
            /* [string][in] */ __RPC__in LPCWSTR pszAppRegistryName);
        
        END_INTERFACE
    } IApplicationAssociationRegistrationUIVtbl;

    interface IApplicationAssociationRegistrationUI
    {
        CONST_VTBL struct IApplicationAssociationRegistrationUIVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IApplicationAssociationRegistrationUI_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IApplicationAssociationRegistrationUI_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IApplicationAssociationRegistrationUI_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IApplicationAssociationRegistrationUI_LaunchAdvancedAssociationUI(This,pszAppRegistryName)	\
    ( (This)->lpVtbl -> LaunchAdvancedAssociationUI(This,pszAppRegistryName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IApplicationAssociationRegistrationUI_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0126 */
/* [local] */ 

#endif  // NTDDI_VISTA
#include <pshpack1.h>
typedef struct tagDELEGATEITEMID
    {
    WORD cbSize;
    WORD wOuter;
    WORD cbInner;
    BYTE rgb[ 1 ];
    } 	DELEGATEITEMID;

#include <poppack.h>
typedef const UNALIGNED DELEGATEITEMID *PCDELEGATEITEMID;
typedef UNALIGNED DELEGATEITEMID *PDELEGATEITEMID;


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0126_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0126_v0_0_s_ifspec;

#ifndef __IDelegateFolder_INTERFACE_DEFINED__
#define __IDelegateFolder_INTERFACE_DEFINED__

/* interface IDelegateFolder */
/* [unique][local][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IDelegateFolder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ADD8BA80-002B-11D0-8F0F-00C04FD7D062")
    IDelegateFolder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetItemAlloc( 
            /* [in] */ 
            __in  IMalloc *pmalloc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDelegateFolderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDelegateFolder * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDelegateFolder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDelegateFolder * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetItemAlloc )( 
            IDelegateFolder * This,
            /* [in] */ 
            __in  IMalloc *pmalloc);
        
        END_INTERFACE
    } IDelegateFolderVtbl;

    interface IDelegateFolder
    {
        CONST_VTBL struct IDelegateFolderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDelegateFolder_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDelegateFolder_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDelegateFolder_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDelegateFolder_SetItemAlloc(This,pmalloc)	\
    ( (This)->lpVtbl -> SetItemAlloc(This,pmalloc) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDelegateFolder_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0127 */
/* [local] */ 

#if (_WIN32_IE >= _WIN32_IE_IE60)
// INTERFACE: IBrowserFrameOptions
//
// This interface was implemented so a browser or host can ask a ShellView/ShelNameSpace what
// kind of 'Behavior' is appropriate for that view.
//
//    IBrowserFrameOptions::GetBrowserOptions()
//       dwMask is the logical OR of bits to look for.  pdwOptions is not optional and
//       it's return value will always equal or will be a subset of dwMask.
//       If the function succeeds, the return value must be S_OK and pdwOptions needs to be filled in.
//       If the function fails, pdwOptions needs to be filled in with BFO_NONE.
//


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0127_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0127_v0_0_s_ifspec;

#ifndef __IBrowserFrameOptions_INTERFACE_DEFINED__
#define __IBrowserFrameOptions_INTERFACE_DEFINED__

/* interface IBrowserFrameOptions */
/* [local][object][uuid] */ 

typedef /* [unique] */ IBrowserFrameOptions *LPBROWSERFRAMEOPTIONS;


enum tagBROWSERFRAMEOPTIONS
    {	BFO_NONE	= 0,
	BFO_BROWSER_PERSIST_SETTINGS	= 0x1,
	BFO_RENAME_FOLDER_OPTIONS_TOINTERNET	= 0x2,
	BFO_BOTH_OPTIONS	= 0x4,
	BIF_PREFER_INTERNET_SHORTCUT	= 0x8,
	BFO_BROWSE_NO_IN_NEW_PROCESS	= 0x10,
	BFO_ENABLE_HYPERLINK_TRACKING	= 0x20,
	BFO_USE_IE_OFFLINE_SUPPORT	= 0x40,
	BFO_SUBSTITUE_INTERNET_START_PAGE	= 0x80,
	BFO_USE_IE_LOGOBANDING	= 0x100,
	BFO_ADD_IE_TOCAPTIONBAR	= 0x200,
	BFO_USE_DIALUP_REF	= 0x400,
	BFO_USE_IE_TOOLBAR	= 0x800,
	BFO_NO_PARENT_FOLDER_SUPPORT	= 0x1000,
	BFO_NO_REOPEN_NEXT_RESTART	= 0x2000,
	BFO_GO_HOME_PAGE	= 0x4000,
	BFO_PREFER_IEPROCESS	= 0x8000,
	BFO_SHOW_NAVIGATION_CANCELLED	= 0x10000,
	BFO_USE_IE_STATUSBAR	= 0x20000,
	BFO_QUERY_ALL	= ( int  )0xffffffff
    } ;
typedef DWORD BROWSERFRAMEOPTIONS;


EXTERN_C const IID IID_IBrowserFrameOptions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("10DF43C8-1DBE-11d3-8B34-006097DF5BD4")
    IBrowserFrameOptions : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFrameOptions( 
            /* [in] */ 
            __in  BROWSERFRAMEOPTIONS dwMask,
            /* [out] */ 
            __out  BROWSERFRAMEOPTIONS *pdwOptions) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBrowserFrameOptionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBrowserFrameOptions * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBrowserFrameOptions * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBrowserFrameOptions * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetFrameOptions )( 
            IBrowserFrameOptions * This,
            /* [in] */ 
            __in  BROWSERFRAMEOPTIONS dwMask,
            /* [out] */ 
            __out  BROWSERFRAMEOPTIONS *pdwOptions);
        
        END_INTERFACE
    } IBrowserFrameOptionsVtbl;

    interface IBrowserFrameOptions
    {
        CONST_VTBL struct IBrowserFrameOptionsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBrowserFrameOptions_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBrowserFrameOptions_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBrowserFrameOptions_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBrowserFrameOptions_GetFrameOptions(This,dwMask,pdwOptions)	\
    ( (This)->lpVtbl -> GetFrameOptions(This,dwMask,pdwOptions) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IBrowserFrameOptions_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0128 */
/* [local] */ 

#endif  // _WIN32_IE_IE60
#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
typedef 
enum tagNWMF
    {	NWMF_UNLOADING	= 0x1,
	NWMF_USERINITED	= 0x2,
	NWMF_FIRST	= 0x4,
	NWMF_OVERRIDEKEY	= 0x8,
	NWMF_SHOWHELP	= 0x10,
	NWMF_HTMLDIALOG	= 0x20,
	NWMF_FROMDIALOGCHILD	= 0x40,
	NWMF_USERREQUESTED	= 0x80,
	NWMF_USERALLOWED	= 0x100,
	NWMF_FORCEWINDOW	= 0x10000,
	NWMF_FORCETAB	= 0x20000,
	NWMF_SUGGESTWINDOW	= 0x40000,
	NWMF_SUGGESTTAB	= 0x80000,
	NWMF_INACTIVETAB	= 0x100000
    } 	NWMF;

#define SID_SNewWindowManager IID_INewWindowManager


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0128_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0128_v0_0_s_ifspec;

#ifndef __INewWindowManager_INTERFACE_DEFINED__
#define __INewWindowManager_INTERFACE_DEFINED__

/* interface INewWindowManager */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_INewWindowManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D2BC4C84-3F72-4a52-A604-7BCBF3982CBB")
    INewWindowManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EvaluateNewWindow( 
            /* [string][in] */ __RPC__in LPCWSTR pszUrl,
            /* [string][in] */ __RPC__in LPCWSTR pszName,
            /* [string][in] */ __RPC__in LPCWSTR pszUrlContext,
            /* [string][in] */ __RPC__in LPCWSTR pszFeatures,
            /* [in] */ BOOL fReplace,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwUserActionTime) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INewWindowManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INewWindowManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INewWindowManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INewWindowManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *EvaluateNewWindow )( 
            INewWindowManager * This,
            /* [string][in] */ __RPC__in LPCWSTR pszUrl,
            /* [string][in] */ __RPC__in LPCWSTR pszName,
            /* [string][in] */ __RPC__in LPCWSTR pszUrlContext,
            /* [string][in] */ __RPC__in LPCWSTR pszFeatures,
            /* [in] */ BOOL fReplace,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwUserActionTime);
        
        END_INTERFACE
    } INewWindowManagerVtbl;

    interface INewWindowManager
    {
        CONST_VTBL struct INewWindowManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INewWindowManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INewWindowManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INewWindowManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INewWindowManager_EvaluateNewWindow(This,pszUrl,pszName,pszUrlContext,pszFeatures,fReplace,dwFlags,dwUserActionTime)	\
    ( (This)->lpVtbl -> EvaluateNewWindow(This,pszUrl,pszName,pszUrlContext,pszFeatures,fReplace,dwFlags,dwUserActionTime) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INewWindowManager_INTERFACE_DEFINED__ */


#ifndef __IAttachmentExecute_INTERFACE_DEFINED__
#define __IAttachmentExecute_INTERFACE_DEFINED__

/* interface IAttachmentExecute */
/* [unique][local][uuid][object] */ 

typedef 
enum tagATTACHMENT_PROMPT
    {	ATTACHMENT_PROMPT_NONE	= 0,
	ATTACHMENT_PROMPT_SAVE	= 0x1,
	ATTACHMENT_PROMPT_EXEC	= 0x2,
	ATTACHMENT_PROMPT_EXEC_OR_SAVE	= 0x3
    } 	ATTACHMENT_PROMPT;

typedef 
enum tagATTACHMENT_ACTION
    {	ATTACHMENT_ACTION_CANCEL	= 0,
	ATTACHMENT_ACTION_SAVE	= 0x1,
	ATTACHMENT_ACTION_EXEC	= 0x2
    } 	ATTACHMENT_ACTION;


EXTERN_C const IID IID_IAttachmentExecute;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("73db1241-1e85-4581-8e4f-a81e1d0f8c57")
    IAttachmentExecute : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetClientTitle( 
            /* [string][in] */ 
            __in  LPCWSTR pszTitle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClientGuid( 
            /* [in] */ 
            __in  REFGUID guid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLocalPath( 
            /* [string][in] */ 
            __in  LPCWSTR pszLocalPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFileName( 
            /* [string][in] */ 
            __in  LPCWSTR pszFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSource( 
            /* [string][in] */ 
            __in  LPCWSTR pszSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetReferrer( 
            /* [string][in] */ 
            __in  LPCWSTR pszReferrer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CheckPolicy( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Prompt( 
            /* [in] */ 
            __in  HWND hwnd,
            /* [in] */ 
            __in  ATTACHMENT_PROMPT prompt,
            /* [out] */ 
            __out  ATTACHMENT_ACTION *paction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Save( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Execute( 
            /* [in] */ 
            __in  HWND hwnd,
            /* [string][in] */ 
            __in  LPCWSTR pszVerb,
            /* [out] */ 
            __out_opt  HANDLE *phProcess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveWithUI( 
            /* [in] */ 
            __in  HWND hwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearClientState( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAttachmentExecuteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAttachmentExecute * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAttachmentExecute * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAttachmentExecute * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetClientTitle )( 
            IAttachmentExecute * This,
            /* [string][in] */ 
            __in  LPCWSTR pszTitle);
        
        HRESULT ( STDMETHODCALLTYPE *SetClientGuid )( 
            IAttachmentExecute * This,
            /* [in] */ 
            __in  REFGUID guid);
        
        HRESULT ( STDMETHODCALLTYPE *SetLocalPath )( 
            IAttachmentExecute * This,
            /* [string][in] */ 
            __in  LPCWSTR pszLocalPath);
        
        HRESULT ( STDMETHODCALLTYPE *SetFileName )( 
            IAttachmentExecute * This,
            /* [string][in] */ 
            __in  LPCWSTR pszFileName);
        
        HRESULT ( STDMETHODCALLTYPE *SetSource )( 
            IAttachmentExecute * This,
            /* [string][in] */ 
            __in  LPCWSTR pszSource);
        
        HRESULT ( STDMETHODCALLTYPE *SetReferrer )( 
            IAttachmentExecute * This,
            /* [string][in] */ 
            __in  LPCWSTR pszReferrer);
        
        HRESULT ( STDMETHODCALLTYPE *CheckPolicy )( 
            IAttachmentExecute * This);
        
        HRESULT ( STDMETHODCALLTYPE *Prompt )( 
            IAttachmentExecute * This,
            /* [in] */ 
            __in  HWND hwnd,
            /* [in] */ 
            __in  ATTACHMENT_PROMPT prompt,
            /* [out] */ 
            __out  ATTACHMENT_ACTION *paction);
        
        HRESULT ( STDMETHODCALLTYPE *Save )( 
            IAttachmentExecute * This);
        
        HRESULT ( STDMETHODCALLTYPE *Execute )( 
            IAttachmentExecute * This,
            /* [in] */ 
            __in  HWND hwnd,
            /* [string][in] */ 
            __in  LPCWSTR pszVerb,
            /* [out] */ 
            __out_opt  HANDLE *phProcess);
        
        HRESULT ( STDMETHODCALLTYPE *SaveWithUI )( 
            IAttachmentExecute * This,
            /* [in] */ 
            __in  HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE *ClearClientState )( 
            IAttachmentExecute * This);
        
        END_INTERFACE
    } IAttachmentExecuteVtbl;

    interface IAttachmentExecute
    {
        CONST_VTBL struct IAttachmentExecuteVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAttachmentExecute_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAttachmentExecute_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAttachmentExecute_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAttachmentExecute_SetClientTitle(This,pszTitle)	\
    ( (This)->lpVtbl -> SetClientTitle(This,pszTitle) ) 

#define IAttachmentExecute_SetClientGuid(This,guid)	\
    ( (This)->lpVtbl -> SetClientGuid(This,guid) ) 

#define IAttachmentExecute_SetLocalPath(This,pszLocalPath)	\
    ( (This)->lpVtbl -> SetLocalPath(This,pszLocalPath) ) 

#define IAttachmentExecute_SetFileName(This,pszFileName)	\
    ( (This)->lpVtbl -> SetFileName(This,pszFileName) ) 

#define IAttachmentExecute_SetSource(This,pszSource)	\
    ( (This)->lpVtbl -> SetSource(This,pszSource) ) 

#define IAttachmentExecute_SetReferrer(This,pszReferrer)	\
    ( (This)->lpVtbl -> SetReferrer(This,pszReferrer) ) 

#define IAttachmentExecute_CheckPolicy(This)	\
    ( (This)->lpVtbl -> CheckPolicy(This) ) 

#define IAttachmentExecute_Prompt(This,hwnd,prompt,paction)	\
    ( (This)->lpVtbl -> Prompt(This,hwnd,prompt,paction) ) 

#define IAttachmentExecute_Save(This)	\
    ( (This)->lpVtbl -> Save(This) ) 

#define IAttachmentExecute_Execute(This,hwnd,pszVerb,phProcess)	\
    ( (This)->lpVtbl -> Execute(This,hwnd,pszVerb,phProcess) ) 

#define IAttachmentExecute_SaveWithUI(This,hwnd)	\
    ( (This)->lpVtbl -> SaveWithUI(This,hwnd) ) 

#define IAttachmentExecute_ClearClientState(This)	\
    ( (This)->lpVtbl -> ClearClientState(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAttachmentExecute_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0130 */
/* [local] */ 

#endif  // _WIN32_IE_IE60SP2
#if (_WIN32_IE >= _WIN32_IE_IE60)
#include <pshpack8.h>
typedef struct tagSMDATA
    {
    DWORD dwMask;
    DWORD dwFlags;
    HMENU hmenu;
    HWND hwnd;
    UINT uId;
    UINT uIdParent;
    UINT uIdAncestor;
    IUnknown *punk;
    PIDLIST_ABSOLUTE pidlFolder;
    PUITEMID_CHILD pidlItem;
    IShellFolder *psf;
    void *pvUserData;
    } 	SMDATA;

typedef struct tagSMDATA *LPSMDATA;

// Mask
#define SMDM_SHELLFOLDER               0x00000001  // This is for an item in the band
#define SMDM_HMENU                     0x00000002  // This is for the Band itself
#define SMDM_TOOLBAR                   0x00000004  // Plain toolbar, not associated with a shell folder or hmenu
// Flags (bitmask)
typedef struct tagSMINFO
    {
    DWORD dwMask;
    DWORD dwType;
    DWORD dwFlags;
    int iIcon;
    } 	SMINFO;

typedef struct tagSMINFO *PSMINFO;

typedef struct tagSHCSCHANGENOTIFYSTRUCT
    {
    LONG lEvent;
    PCIDLIST_ABSOLUTE pidl1;
    PCIDLIST_ABSOLUTE pidl2;
    } 	SMCSHCHANGENOTIFYSTRUCT;

typedef struct tagSHCSCHANGENOTIFYSTRUCT *PSMCSHCHANGENOTIFYSTRUCT;

#include <poppack.h>

enum tagSMINFOMASK
    {	SMIM_TYPE	= 0x1,
	SMIM_FLAGS	= 0x2,
	SMIM_ICON	= 0x4
    } ;

enum tagSMINFOTYPE
    {	SMIT_SEPARATOR	= 0x1,
	SMIT_STRING	= 0x2
    } ;

enum tagSMINFOFLAGS
    {	SMIF_ICON	= 0x1,
	SMIF_ACCELERATOR	= 0x2,
	SMIF_DROPTARGET	= 0x4,
	SMIF_SUBMENU	= 0x8,
	SMIF_CHECKED	= 0x20,
	SMIF_DROPCASCADE	= 0x40,
	SMIF_HIDDEN	= 0x80,
	SMIF_DISABLED	= 0x100,
	SMIF_TRACKPOPUP	= 0x200,
	SMIF_DEMOTED	= 0x400,
	SMIF_ALTSTATE	= 0x800,
	SMIF_DRAGNDROP	= 0x1000,
	SMIF_NEW	= 0x2000
    } ;
#define SMC_INITMENU            0x00000001  // The callback is called to init a menuband
#define SMC_CREATE              0x00000002
#define SMC_EXITMENU            0x00000003  // The callback is called when menu is collapsing
#define SMC_GETINFO             0x00000005  // The callback is called to return DWORD values
#define SMC_GETSFINFO           0x00000006  // The callback is called to return DWORD values
#define SMC_GETOBJECT           0x00000007  // The callback is called to get some object
#define SMC_GETSFOBJECT         0x00000008  // The callback is called to get some object
#define SMC_SFEXEC              0x00000009  // The callback is called to execute an shell folder item
#define SMC_SFSELECTITEM        0x0000000A  // The callback is called when an item is selected
#define SMC_REFRESH             0x00000010  // Menus have completely refreshed. Reset your state.
#define SMC_DEMOTE              0x00000011  // Demote an item
#define SMC_PROMOTE             0x00000012  // Promote an item, wParam = SMINV_* flag
#define SMC_DEFAULTICON         0x00000016  // Returns Default icon location in wParam, index in lParam
#define SMC_NEWITEM             0x00000017  // Notifies item is not in the order stream.
#define SMC_CHEVRONEXPAND       0x00000019  // Notifies of a expansion via the chevron
#define SMC_DISPLAYCHEVRONTIP   0x0000002A  // S_OK display, S_FALSE not.
#define SMC_SETSFOBJECT         0x0000002D  // Called to save the passed object
#define SMC_SHCHANGENOTIFY      0x0000002E  // Called when a Change notify is received. lParam points to SMCSHCHANGENOTIFYSTRUCT
#define SMC_CHEVRONGETTIP       0x0000002F  // Called to get the chevron tip text. wParam = Tip title, Lparam = TipText Both MAX_PATH
#define SMC_SFDDRESTRICTED      0x00000030  // Called requesting if it's ok to drop. wParam = IDropTarget.
#if (_WIN32_IE >= _WIN32_IE_IE70)
#define SMC_SFEXEC_MIDDLE       0x00000031  // Same as SFEXEC, but the middle mouse button caused the exec.
#define SMC_GETAUTOEXPANDSTATE  0x00000041  // callback returns the default autoexpand state lParam = LPDWORD to recieve flags
#define SMC_AUTOEXPANDCHANGE    0x00000042  // Notify that the menu is expanding/contracting
#define SMC_GETCONTEXTMENUMODIFIER 0x00000043  // Used to add items to a context menu
#define SMC_GETBKCONTEXTMENU    0x00000044  // used to get a context menu to display when user right clicks on the background
#define SMC_OPEN                0x00000045  // allows client to overwrite open/explore verb action on an item
// Flags for return value from SMC_GETAUTOEXPANDSTATE and SMC_AUTOEXPANDCHANGE:
#define SMAE_EXPANDED           0x00000001  // The menu is or should start expanded
#define SMAE_CONTRACTED         0x00000002  // The menu is or should start contracted
                                            // SMAE_EXPANDED and SMAE_CONTRACTED are mutually exclusive
#define SMAE_USER               0x00000004  // Indicates that the menu expansion/contraction is a reflection
                                            // of user choice
#define SMAE_VALID              0x00000007
#endif  // _WIN32_IE_IE70


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0130_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0130_v0_0_s_ifspec;

#ifndef __IShellMenuCallback_INTERFACE_DEFINED__
#define __IShellMenuCallback_INTERFACE_DEFINED__

/* interface IShellMenuCallback */
/* [local][unique][object][uuid] */ 


EXTERN_C const IID IID_IShellMenuCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4CA300A1-9B8D-11d1-8B22-00C04FD918D0")
    IShellMenuCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CallbackSM( 
            /* [out][in] */ 
            __inout  LPSMDATA psmd,
            /* [in] */ 
            __in  UINT uMsg,
            /* [in] */ 
            __in  WPARAM wParam,
            /* [in] */ 
            __in  LPARAM lParam) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellMenuCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellMenuCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellMenuCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellMenuCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *CallbackSM )( 
            IShellMenuCallback * This,
            /* [out][in] */ 
            __inout  LPSMDATA psmd,
            /* [in] */ 
            __in  UINT uMsg,
            /* [in] */ 
            __in  WPARAM wParam,
            /* [in] */ 
            __in  LPARAM lParam);
        
        END_INTERFACE
    } IShellMenuCallbackVtbl;

    interface IShellMenuCallback
    {
        CONST_VTBL struct IShellMenuCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellMenuCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellMenuCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellMenuCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellMenuCallback_CallbackSM(This,psmd,uMsg,wParam,lParam)	\
    ( (This)->lpVtbl -> CallbackSM(This,psmd,uMsg,wParam,lParam) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellMenuCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0131 */
/* [local] */ 

#define SMINIT_DEFAULT              0x00000000  // No Options
#define SMINIT_RESTRICT_DRAGDROP    0x00000002  // Don't allow Drag and Drop
#define SMINIT_TOPLEVEL             0x00000004  // This is the top band.
#define SMINIT_CACHED               0x00000010
#if (_WIN32_IE >= _WIN32_IE_IE70)
#define SMINIT_AUTOEXPAND           0x00000100  // automatically expand/contract menu band
#define SMINIT_AUTOTOOLTIP          0x00000200  // regular tooltip support
#define SMINIT_DROPONCONTAINER      0x00000400  // allow drop on a container
#endif  // _WIN32_IE_IE70
#define SMINIT_VERTICAL             0x10000000  // This is a vertical menu
#define SMINIT_HORIZONTAL           0x20000000  // This is a horizontal menu    (does not inherit)
#define ANCESTORDEFAULT      (UINT)-1
#define SMSET_TOP                   0x10000000    // Bias this namespace to the top of the menu
#define SMSET_BOTTOM                0x20000000    // Bias this namespace to the bottom of the menu
#define SMSET_DONTOWN               0x00000001    // The Menuband doesn't own the non-ref counted object
#define SMINV_REFRESH        0x00000001
#define SMINV_ID             0x00000008


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0131_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0131_v0_0_s_ifspec;

#ifndef __IShellMenu_INTERFACE_DEFINED__
#define __IShellMenu_INTERFACE_DEFINED__

/* interface IShellMenu */
/* [local][unique][object][uuid] */ 


EXTERN_C const IID IID_IShellMenu;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EE1F7637-E138-11d1-8379-00C04FD918D0")
    IShellMenu : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ 
            __in  IShellMenuCallback *psmc,
            /* [in] */ 
            __in  UINT uId,
            /* [in] */ 
            __in  UINT uIdAncestor,
            /* [in] */ 
            __in  DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMenuInfo( 
            /* [out] */ 
            __deref_out  IShellMenuCallback **ppsmc,
            /* [out] */ 
            __out  UINT *puId,
            /* [out] */ 
            __out  UINT *puIdAncestor,
            /* [out] */ 
            __out  DWORD *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetShellFolder( 
            /* [in] */ 
            __in  IShellFolder *psf,
            /* [in] */ 
            __in  PCIDLIST_ABSOLUTE pidlFolder,
            /* [in] */ 
            __in  HKEY hKey,
            /* [in] */ 
            __in  DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetShellFolder( 
            /* [out] */ 
            __out  DWORD *pdwFlags,
            /* [out] */ 
            __deref_out  PIDLIST_ABSOLUTE *ppidl,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __deref_out  void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMenu( 
            /* [in] */ 
            __in  HMENU hmenu,
            /* [in] */ 
            __in  HWND hwnd,
            /* [in] */ 
            __in  DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMenu( 
            /* [out] */ 
            __out_opt  HMENU *phmenu,
            /* [out] */ 
            __out_opt  HWND *phwnd,
            /* [out] */ 
            __out_opt  DWORD *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InvalidateItem( 
            /* [in] */ 
            __in_opt  LPSMDATA psmd,
            /* [in] */ 
            __in  DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetState( 
            /* [out] */ 
            __out  LPSMDATA psmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMenuToolbar( 
            /* [in] */ 
            __in  IUnknown *punk,
            /* [in] */ 
            __in  DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellMenuVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellMenu * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellMenu * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellMenu * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IShellMenu * This,
            /* [in] */ 
            __in  IShellMenuCallback *psmc,
            /* [in] */ 
            __in  UINT uId,
            /* [in] */ 
            __in  UINT uIdAncestor,
            /* [in] */ 
            __in  DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetMenuInfo )( 
            IShellMenu * This,
            /* [out] */ 
            __deref_out  IShellMenuCallback **ppsmc,
            /* [out] */ 
            __out  UINT *puId,
            /* [out] */ 
            __out  UINT *puIdAncestor,
            /* [out] */ 
            __out  DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetShellFolder )( 
            IShellMenu * This,
            /* [in] */ 
            __in  IShellFolder *psf,
            /* [in] */ 
            __in  PCIDLIST_ABSOLUTE pidlFolder,
            /* [in] */ 
            __in  HKEY hKey,
            /* [in] */ 
            __in  DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetShellFolder )( 
            IShellMenu * This,
            /* [out] */ 
            __out  DWORD *pdwFlags,
            /* [out] */ 
            __deref_out  PIDLIST_ABSOLUTE *ppidl,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __deref_out  void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *SetMenu )( 
            IShellMenu * This,
            /* [in] */ 
            __in  HMENU hmenu,
            /* [in] */ 
            __in  HWND hwnd,
            /* [in] */ 
            __in  DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetMenu )( 
            IShellMenu * This,
            /* [out] */ 
            __out_opt  HMENU *phmenu,
            /* [out] */ 
            __out_opt  HWND *phwnd,
            /* [out] */ 
            __out_opt  DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *InvalidateItem )( 
            IShellMenu * This,
            /* [in] */ 
            __in_opt  LPSMDATA psmd,
            /* [in] */ 
            __in  DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            IShellMenu * This,
            /* [out] */ 
            __out  LPSMDATA psmd);
        
        HRESULT ( STDMETHODCALLTYPE *SetMenuToolbar )( 
            IShellMenu * This,
            /* [in] */ 
            __in  IUnknown *punk,
            /* [in] */ 
            __in  DWORD dwFlags);
        
        END_INTERFACE
    } IShellMenuVtbl;

    interface IShellMenu
    {
        CONST_VTBL struct IShellMenuVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellMenu_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellMenu_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellMenu_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellMenu_Initialize(This,psmc,uId,uIdAncestor,dwFlags)	\
    ( (This)->lpVtbl -> Initialize(This,psmc,uId,uIdAncestor,dwFlags) ) 

#define IShellMenu_GetMenuInfo(This,ppsmc,puId,puIdAncestor,pdwFlags)	\
    ( (This)->lpVtbl -> GetMenuInfo(This,ppsmc,puId,puIdAncestor,pdwFlags) ) 

#define IShellMenu_SetShellFolder(This,psf,pidlFolder,hKey,dwFlags)	\
    ( (This)->lpVtbl -> SetShellFolder(This,psf,pidlFolder,hKey,dwFlags) ) 

#define IShellMenu_GetShellFolder(This,pdwFlags,ppidl,riid,ppv)	\
    ( (This)->lpVtbl -> GetShellFolder(This,pdwFlags,ppidl,riid,ppv) ) 

#define IShellMenu_SetMenu(This,hmenu,hwnd,dwFlags)	\
    ( (This)->lpVtbl -> SetMenu(This,hmenu,hwnd,dwFlags) ) 

#define IShellMenu_GetMenu(This,phmenu,phwnd,pdwFlags)	\
    ( (This)->lpVtbl -> GetMenu(This,phmenu,phwnd,pdwFlags) ) 

#define IShellMenu_InvalidateItem(This,psmd,dwFlags)	\
    ( (This)->lpVtbl -> InvalidateItem(This,psmd,dwFlags) ) 

#define IShellMenu_GetState(This,psmd)	\
    ( (This)->lpVtbl -> GetState(This,psmd) ) 

#define IShellMenu_SetMenuToolbar(This,punk,dwFlags)	\
    ( (This)->lpVtbl -> SetMenuToolbar(This,punk,dwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellMenu_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0132 */
/* [local] */ 

#endif  // _WIN32_IE_IE60


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0132_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0132_v0_0_s_ifspec;

#ifndef __IShellRunDll_INTERFACE_DEFINED__
#define __IShellRunDll_INTERFACE_DEFINED__

/* interface IShellRunDll */
/* [local][ref][object][uuid] */ 


EXTERN_C const IID IID_IShellRunDll;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fce4bde0-4b68-4b80-8e9c-7426315a7388")
    IShellRunDll : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Run( 
            /* [string][in] */ 
            __in  LPCWSTR pszArgs) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellRunDllVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellRunDll * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellRunDll * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellRunDll * This);
        
        HRESULT ( STDMETHODCALLTYPE *Run )( 
            IShellRunDll * This,
            /* [string][in] */ 
            __in  LPCWSTR pszArgs);
        
        END_INTERFACE
    } IShellRunDllVtbl;

    interface IShellRunDll
    {
        CONST_VTBL struct IShellRunDllVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellRunDll_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellRunDll_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellRunDll_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellRunDll_Run(This,pszArgs)	\
    ( (This)->lpVtbl -> Run(This,pszArgs) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellRunDll_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0133 */
/* [local] */ 

#if (NTDDI_VERSION >= NTDDI_VISTA)
/* [v1_enum] */ 
enum tagKF_CATEGORY
    {	KF_CATEGORY_VIRTUAL	= 0x1,
	KF_CATEGORY_FIXED	= 0x2,
	KF_CATEGORY_COMMON	= 0x3,
	KF_CATEGORY_PERUSER	= 0x4
    } ;
typedef enum tagKF_CATEGORY KF_CATEGORY;

/* [v1_enum] */ 
enum tagKF_DEFINITION_FLAGS
    {	KFDF_LOCAL_REDIRECT_ONLY	= 0x2,
	KFDF_ROAMABLE	= 0x4,
	KFDF_PRECREATE	= 0x8
    } ;
typedef DWORD KF_DEFINITION_FLAGS;

/* [v1_enum] */ 
enum tagKF_REDIRECT_FLAGS
    {	KF_REDIRECT_USER_EXCLUSIVE	= 0x1,
	KF_REDIRECT_COPY_SOURCE_DACL	= 0x2,
	KF_REDIRECT_OWNER_USER	= 0x4,
	KF_REDIRECT_SET_OWNER_EXPLICIT	= 0x8,
	KF_REDIRECT_CHECK_ONLY	= 0x10,
	KF_REDIRECT_WITH_UI	= 0x20,
	KF_REDIRECT_UNPIN	= 0x40,
	KF_REDIRECT_PIN	= 0x80,
	KF_REDIRECT_COPY_CONTENTS	= 0x200,
	KF_REDIRECT_DEL_SOURCE_CONTENTS	= 0x400,
	KF_REDIRECT_EXCLUDE_ALL_KNOWN_SUBFOLDERS	= 0x800
    } ;
typedef DWORD KF_REDIRECT_FLAGS;

/* [v1_enum] */ 
enum tagKF_REDIRECTION_CAPABILITIES
    {	KF_REDIRECTION_CAPABILITIES_ALLOW_ALL	= 0xff,
	KF_REDIRECTION_CAPABILITIES_REDIRECTABLE	= 0x1,
	KF_REDIRECTION_CAPABILITIES_DENY_ALL	= 0xfff00,
	KF_REDIRECTION_CAPABILITIES_DENY_POLICY_REDIRECTED	= 0x100,
	KF_REDIRECTION_CAPABILITIES_DENY_POLICY	= 0x200,
	KF_REDIRECTION_CAPABILITIES_DENY_PERMISSIONS	= 0x400
    } ;
typedef DWORD KF_REDIRECTION_CAPABILITIES;

typedef struct tagKNOWNFOLDER_DEFINITION
    {
    KF_CATEGORY category;
    LPWSTR pszName;
    LPWSTR pszDescription;
    KNOWNFOLDERID fidParent;
    LPWSTR pszRelativePath;
    LPWSTR pszParsingName;
    LPWSTR pszTooltip;
    LPWSTR pszLocalizedName;
    LPWSTR pszIcon;
    LPWSTR pszSecurity;
    DWORD dwAttributes;
    KF_DEFINITION_FLAGS kfdFlags;
    FOLDERTYPEID ftidType;
    } 	KNOWNFOLDER_DEFINITION;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0133_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0133_v0_0_s_ifspec;

#ifndef __IKnownFolder_INTERFACE_DEFINED__
#define __IKnownFolder_INTERFACE_DEFINED__

/* interface IKnownFolder */
/* [ref][version][object][helpstring][uuid] */ 


EXTERN_C const IID IID_IKnownFolder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3AA7AF7E-9B36-420c-A8E3-F77D4674A488")
    IKnownFolder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetId( 
            /* [out] */ __RPC__out KNOWNFOLDERID *pkfid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCategory( 
            /* [out] */ __RPC__out KF_CATEGORY *pCategory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetShellItem( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPath( 
            /* [in] */ DWORD dwFlags,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPath( 
            /* [in] */ DWORD dwFlags,
            /* [string][in] */ __RPC__in LPCWSTR pszPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIDList( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFolderType( 
            /* [out] */ __RPC__out FOLDERTYPEID *pftid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRedirectionCapabilities( 
            /* [out] */ __RPC__out KF_REDIRECTION_CAPABILITIES *pCapabilities) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFolderDefinition( 
            /* [out] */ __RPC__out KNOWNFOLDER_DEFINITION *pKFD) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IKnownFolderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IKnownFolder * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IKnownFolder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IKnownFolder * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetId )( 
            IKnownFolder * This,
            /* [out] */ __RPC__out KNOWNFOLDERID *pkfid);
        
        HRESULT ( STDMETHODCALLTYPE *GetCategory )( 
            IKnownFolder * This,
            /* [out] */ __RPC__out KF_CATEGORY *pCategory);
        
        HRESULT ( STDMETHODCALLTYPE *GetShellItem )( 
            IKnownFolder * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetPath )( 
            IKnownFolder * This,
            /* [in] */ DWORD dwFlags,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszPath);
        
        HRESULT ( STDMETHODCALLTYPE *SetPath )( 
            IKnownFolder * This,
            /* [in] */ DWORD dwFlags,
            /* [string][in] */ __RPC__in LPCWSTR pszPath);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDList )( 
            IKnownFolder * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidl);
        
        HRESULT ( STDMETHODCALLTYPE *GetFolderType )( 
            IKnownFolder * This,
            /* [out] */ __RPC__out FOLDERTYPEID *pftid);
        
        HRESULT ( STDMETHODCALLTYPE *GetRedirectionCapabilities )( 
            IKnownFolder * This,
            /* [out] */ __RPC__out KF_REDIRECTION_CAPABILITIES *pCapabilities);
        
        HRESULT ( STDMETHODCALLTYPE *GetFolderDefinition )( 
            IKnownFolder * This,
            /* [out] */ __RPC__out KNOWNFOLDER_DEFINITION *pKFD);
        
        END_INTERFACE
    } IKnownFolderVtbl;

    interface IKnownFolder
    {
        CONST_VTBL struct IKnownFolderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IKnownFolder_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IKnownFolder_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IKnownFolder_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IKnownFolder_GetId(This,pkfid)	\
    ( (This)->lpVtbl -> GetId(This,pkfid) ) 

#define IKnownFolder_GetCategory(This,pCategory)	\
    ( (This)->lpVtbl -> GetCategory(This,pCategory) ) 

#define IKnownFolder_GetShellItem(This,dwFlags,riid,ppv)	\
    ( (This)->lpVtbl -> GetShellItem(This,dwFlags,riid,ppv) ) 

#define IKnownFolder_GetPath(This,dwFlags,ppszPath)	\
    ( (This)->lpVtbl -> GetPath(This,dwFlags,ppszPath) ) 

#define IKnownFolder_SetPath(This,dwFlags,pszPath)	\
    ( (This)->lpVtbl -> SetPath(This,dwFlags,pszPath) ) 

#define IKnownFolder_GetIDList(This,dwFlags,ppidl)	\
    ( (This)->lpVtbl -> GetIDList(This,dwFlags,ppidl) ) 

#define IKnownFolder_GetFolderType(This,pftid)	\
    ( (This)->lpVtbl -> GetFolderType(This,pftid) ) 

#define IKnownFolder_GetRedirectionCapabilities(This,pCapabilities)	\
    ( (This)->lpVtbl -> GetRedirectionCapabilities(This,pCapabilities) ) 

#define IKnownFolder_GetFolderDefinition(This,pKFD)	\
    ( (This)->lpVtbl -> GetFolderDefinition(This,pKFD) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IKnownFolder_INTERFACE_DEFINED__ */


#ifndef __IKnownFolderManager_INTERFACE_DEFINED__
#define __IKnownFolderManager_INTERFACE_DEFINED__

/* interface IKnownFolderManager */
/* [ref][version][object][helpstring][uuid] */ 

typedef /* [v1_enum] */ 
enum tagFFFP_MODE
    {	FFFP_EXACTMATCH	= 0,
	FFFP_NEARESTPARENTMATCH	= ( FFFP_EXACTMATCH + 1 ) 
    } 	FFFP_MODE;


EXTERN_C const IID IID_IKnownFolderManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8BE2D872-86AA-4d47-B776-32CCA40C7018")
    IKnownFolderManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FolderIdFromCsidl( 
            /* [in] */ int nCsidl,
            /* [out] */ __RPC__out KNOWNFOLDERID *pfid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FolderIdToCsidl( 
            /* [in] */ __RPC__in REFKNOWNFOLDERID rfid,
            /* [out] */ __RPC__out int *pnCsidl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFolderIds( 
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pCount) KNOWNFOLDERID **ppKFId,
            /* [out][in] */ __RPC__inout UINT *pCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFolder( 
            /* [in] */ __RPC__in REFKNOWNFOLDERID rfid,
            /* [out] */ __RPC__deref_out_opt IKnownFolder **ppkf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFolderByName( 
            /* [string][in] */ __RPC__in LPCWSTR pszCanonicalName,
            /* [out] */ __RPC__deref_out_opt IKnownFolder **ppkf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterFolder( 
            /* [in] */ __RPC__in REFKNOWNFOLDERID rfid,
            /* [in] */ __RPC__in const KNOWNFOLDER_DEFINITION *pKFD) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterFolder( 
            /* [in] */ __RPC__in REFKNOWNFOLDERID rfid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindFolderFromPath( 
            /* [string][in] */ __RPC__in LPCWSTR pszPath,
            /* [in] */ FFFP_MODE mode,
            /* [out] */ __RPC__deref_out_opt IKnownFolder **ppkf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindFolderFromIDList( 
            /* [in] */ __RPC__in PCIDLIST_ABSOLUTE pidl,
            /* [out] */ __RPC__deref_out_opt IKnownFolder **ppkf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Redirect( 
            /* [in] */ __RPC__in REFKNOWNFOLDERID rfid,
            /* [unique][in] */ __RPC__in_opt HWND hwnd,
            /* [in] */ KF_REDIRECT_FLAGS flags,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszTargetPath,
            /* [in] */ UINT cFolders,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(cFolders) const KNOWNFOLDERID *pExclusion,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszError) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IKnownFolderManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IKnownFolderManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IKnownFolderManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IKnownFolderManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *FolderIdFromCsidl )( 
            IKnownFolderManager * This,
            /* [in] */ int nCsidl,
            /* [out] */ __RPC__out KNOWNFOLDERID *pfid);
        
        HRESULT ( STDMETHODCALLTYPE *FolderIdToCsidl )( 
            IKnownFolderManager * This,
            /* [in] */ __RPC__in REFKNOWNFOLDERID rfid,
            /* [out] */ __RPC__out int *pnCsidl);
        
        HRESULT ( STDMETHODCALLTYPE *GetFolderIds )( 
            IKnownFolderManager * This,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pCount) KNOWNFOLDERID **ppKFId,
            /* [out][in] */ __RPC__inout UINT *pCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetFolder )( 
            IKnownFolderManager * This,
            /* [in] */ __RPC__in REFKNOWNFOLDERID rfid,
            /* [out] */ __RPC__deref_out_opt IKnownFolder **ppkf);
        
        HRESULT ( STDMETHODCALLTYPE *GetFolderByName )( 
            IKnownFolderManager * This,
            /* [string][in] */ __RPC__in LPCWSTR pszCanonicalName,
            /* [out] */ __RPC__deref_out_opt IKnownFolder **ppkf);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterFolder )( 
            IKnownFolderManager * This,
            /* [in] */ __RPC__in REFKNOWNFOLDERID rfid,
            /* [in] */ __RPC__in const KNOWNFOLDER_DEFINITION *pKFD);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterFolder )( 
            IKnownFolderManager * This,
            /* [in] */ __RPC__in REFKNOWNFOLDERID rfid);
        
        HRESULT ( STDMETHODCALLTYPE *FindFolderFromPath )( 
            IKnownFolderManager * This,
            /* [string][in] */ __RPC__in LPCWSTR pszPath,
            /* [in] */ FFFP_MODE mode,
            /* [out] */ __RPC__deref_out_opt IKnownFolder **ppkf);
        
        HRESULT ( STDMETHODCALLTYPE *FindFolderFromIDList )( 
            IKnownFolderManager * This,
            /* [in] */ __RPC__in PCIDLIST_ABSOLUTE pidl,
            /* [out] */ __RPC__deref_out_opt IKnownFolder **ppkf);
        
        HRESULT ( STDMETHODCALLTYPE *Redirect )( 
            IKnownFolderManager * This,
            /* [in] */ __RPC__in REFKNOWNFOLDERID rfid,
            /* [unique][in] */ __RPC__in_opt HWND hwnd,
            /* [in] */ KF_REDIRECT_FLAGS flags,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszTargetPath,
            /* [in] */ UINT cFolders,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(cFolders) const KNOWNFOLDERID *pExclusion,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszError);
        
        END_INTERFACE
    } IKnownFolderManagerVtbl;

    interface IKnownFolderManager
    {
        CONST_VTBL struct IKnownFolderManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IKnownFolderManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IKnownFolderManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IKnownFolderManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IKnownFolderManager_FolderIdFromCsidl(This,nCsidl,pfid)	\
    ( (This)->lpVtbl -> FolderIdFromCsidl(This,nCsidl,pfid) ) 

#define IKnownFolderManager_FolderIdToCsidl(This,rfid,pnCsidl)	\
    ( (This)->lpVtbl -> FolderIdToCsidl(This,rfid,pnCsidl) ) 

#define IKnownFolderManager_GetFolderIds(This,ppKFId,pCount)	\
    ( (This)->lpVtbl -> GetFolderIds(This,ppKFId,pCount) ) 

#define IKnownFolderManager_GetFolder(This,rfid,ppkf)	\
    ( (This)->lpVtbl -> GetFolder(This,rfid,ppkf) ) 

#define IKnownFolderManager_GetFolderByName(This,pszCanonicalName,ppkf)	\
    ( (This)->lpVtbl -> GetFolderByName(This,pszCanonicalName,ppkf) ) 

#define IKnownFolderManager_RegisterFolder(This,rfid,pKFD)	\
    ( (This)->lpVtbl -> RegisterFolder(This,rfid,pKFD) ) 

#define IKnownFolderManager_UnregisterFolder(This,rfid)	\
    ( (This)->lpVtbl -> UnregisterFolder(This,rfid) ) 

#define IKnownFolderManager_FindFolderFromPath(This,pszPath,mode,ppkf)	\
    ( (This)->lpVtbl -> FindFolderFromPath(This,pszPath,mode,ppkf) ) 

#define IKnownFolderManager_FindFolderFromIDList(This,pidl,ppkf)	\
    ( (This)->lpVtbl -> FindFolderFromIDList(This,pidl,ppkf) ) 

#define IKnownFolderManager_Redirect(This,rfid,hwnd,flags,pszTargetPath,cFolders,pExclusion,ppszError)	\
    ( (This)->lpVtbl -> Redirect(This,rfid,hwnd,flags,pszTargetPath,cFolders,pExclusion,ppszError) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IKnownFolderManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0135 */
/* [local] */ 

__inline void FreeKnownFolderDefinitionFields(KNOWNFOLDER_DEFINITION *pKFD)
{
    CoTaskMemFree(pKFD->pszName);
    CoTaskMemFree(pKFD->pszDescription);
    CoTaskMemFree(pKFD->pszRelativePath);
    CoTaskMemFree(pKFD->pszParsingName);
    CoTaskMemFree(pKFD->pszTooltip);
    CoTaskMemFree(pKFD->pszLocalizedName);
    CoTaskMemFree(pKFD->pszIcon);
    CoTaskMemFree(pKFD->pszSecurity);
}
typedef /* [v1_enum] */ 
enum _tagSHARE_ROLE
    {	SHARE_ROLE_INVALID	= -1,
	SHARE_ROLE_READER	= 0,
	SHARE_ROLE_CONTRIBUTOR	= 1,
	SHARE_ROLE_CO_OWNER	= 2,
	SHARE_ROLE_OWNER	= 3,
	SHARE_ROLE_CUSTOM	= 4,
	SHARE_ROLE_MIXED	= 5
    } 	SHARE_ROLE;

typedef /* [v1_enum] */ 
enum _tagDEF_SHARE_ID
    {	DEFSHAREID_USERS	= 1,
	DEFSHAREID_PUBLIC	= 2
    } 	DEF_SHARE_ID;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0135_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0135_v0_0_s_ifspec;

#ifndef __ISharingConfigurationManager_INTERFACE_DEFINED__
#define __ISharingConfigurationManager_INTERFACE_DEFINED__

/* interface ISharingConfigurationManager */
/* [helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISharingConfigurationManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B4CD448A-9C86-4466-9201-2E62105B87AE")
    ISharingConfigurationManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateShare( 
            /* [in] */ DEF_SHARE_ID dsid,
            /* [in] */ SHARE_ROLE role) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteShare( 
            /* [in] */ DEF_SHARE_ID dsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShareExists( 
            /* [in] */ DEF_SHARE_ID dsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSharePermissions( 
            /* [in] */ DEF_SHARE_ID dsid,
            /* [out] */ __RPC__out SHARE_ROLE *pRole) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SharePrinters( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopSharingPrinters( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ArePrintersShared( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISharingConfigurationManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISharingConfigurationManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISharingConfigurationManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISharingConfigurationManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateShare )( 
            ISharingConfigurationManager * This,
            /* [in] */ DEF_SHARE_ID dsid,
            /* [in] */ SHARE_ROLE role);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteShare )( 
            ISharingConfigurationManager * This,
            /* [in] */ DEF_SHARE_ID dsid);
        
        HRESULT ( STDMETHODCALLTYPE *ShareExists )( 
            ISharingConfigurationManager * This,
            /* [in] */ DEF_SHARE_ID dsid);
        
        HRESULT ( STDMETHODCALLTYPE *GetSharePermissions )( 
            ISharingConfigurationManager * This,
            /* [in] */ DEF_SHARE_ID dsid,
            /* [out] */ __RPC__out SHARE_ROLE *pRole);
        
        HRESULT ( STDMETHODCALLTYPE *SharePrinters )( 
            ISharingConfigurationManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *StopSharingPrinters )( 
            ISharingConfigurationManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *ArePrintersShared )( 
            ISharingConfigurationManager * This);
        
        END_INTERFACE
    } ISharingConfigurationManagerVtbl;

    interface ISharingConfigurationManager
    {
        CONST_VTBL struct ISharingConfigurationManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISharingConfigurationManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISharingConfigurationManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISharingConfigurationManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISharingConfigurationManager_CreateShare(This,dsid,role)	\
    ( (This)->lpVtbl -> CreateShare(This,dsid,role) ) 

#define ISharingConfigurationManager_DeleteShare(This,dsid)	\
    ( (This)->lpVtbl -> DeleteShare(This,dsid) ) 

#define ISharingConfigurationManager_ShareExists(This,dsid)	\
    ( (This)->lpVtbl -> ShareExists(This,dsid) ) 

#define ISharingConfigurationManager_GetSharePermissions(This,dsid,pRole)	\
    ( (This)->lpVtbl -> GetSharePermissions(This,dsid,pRole) ) 

#define ISharingConfigurationManager_SharePrinters(This)	\
    ( (This)->lpVtbl -> SharePrinters(This) ) 

#define ISharingConfigurationManager_StopSharingPrinters(This)	\
    ( (This)->lpVtbl -> StopSharingPrinters(This) ) 

#define ISharingConfigurationManager_ArePrintersShared(This)	\
    ( (This)->lpVtbl -> ArePrintersShared(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISharingConfigurationManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0136 */
/* [local] */ 

#endif  // NTDDI_VISTA


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0136_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0136_v0_0_s_ifspec;

#ifndef __IPreviousVersionsInfo_INTERFACE_DEFINED__
#define __IPreviousVersionsInfo_INTERFACE_DEFINED__

/* interface IPreviousVersionsInfo */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IPreviousVersionsInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("76e54780-ad74-48e3-a695-3ba9a0aff10d")
    IPreviousVersionsInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AreSnapshotsAvailable( 
            /* [string][in] */ 
            __in  LPCWSTR pszPath,
            /* [in] */ 
            __in  BOOL fOkToBeSlow,
            /* [out] */ 
            __out  BOOL *pfAvailable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPreviousVersionsInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPreviousVersionsInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPreviousVersionsInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPreviousVersionsInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *AreSnapshotsAvailable )( 
            IPreviousVersionsInfo * This,
            /* [string][in] */ 
            __in  LPCWSTR pszPath,
            /* [in] */ 
            __in  BOOL fOkToBeSlow,
            /* [out] */ 
            __out  BOOL *pfAvailable);
        
        END_INTERFACE
    } IPreviousVersionsInfoVtbl;

    interface IPreviousVersionsInfo
    {
        CONST_VTBL struct IPreviousVersionsInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPreviousVersionsInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPreviousVersionsInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPreviousVersionsInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPreviousVersionsInfo_AreSnapshotsAvailable(This,pszPath,fOkToBeSlow,pfAvailable)	\
    ( (This)->lpVtbl -> AreSnapshotsAvailable(This,pszPath,fOkToBeSlow,pfAvailable) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPreviousVersionsInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0137 */
/* [local] */ 

#if (_WIN32_IE >= _WIN32_IE_IE70)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0137_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0137_v0_0_s_ifspec;

#ifndef __IRelatedItem_INTERFACE_DEFINED__
#define __IRelatedItem_INTERFACE_DEFINED__

/* interface IRelatedItem */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IRelatedItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a73ce67a-8ab1-44f1-8d43-d2fcbf6b1cd0")
    IRelatedItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetItemIDList( 
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItem( 
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRelatedItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRelatedItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRelatedItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRelatedItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemIDList )( 
            IRelatedItem * This,
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidl);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            IRelatedItem * This,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi);
        
        END_INTERFACE
    } IRelatedItemVtbl;

    interface IRelatedItem
    {
        CONST_VTBL struct IRelatedItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRelatedItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRelatedItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRelatedItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRelatedItem_GetItemIDList(This,ppidl)	\
    ( (This)->lpVtbl -> GetItemIDList(This,ppidl) ) 

#define IRelatedItem_GetItem(This,ppsi)	\
    ( (This)->lpVtbl -> GetItem(This,ppsi) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRelatedItem_INTERFACE_DEFINED__ */


#ifndef __IIdentityName_INTERFACE_DEFINED__
#define __IIdentityName_INTERFACE_DEFINED__

/* interface IIdentityName */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IIdentityName;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7d903fca-d6f9-4810-8332-946c0177e247")
    IIdentityName : public IRelatedItem
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IIdentityNameVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IIdentityName * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IIdentityName * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IIdentityName * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemIDList )( 
            IIdentityName * This,
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidl);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            IIdentityName * This,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi);
        
        END_INTERFACE
    } IIdentityNameVtbl;

    interface IIdentityName
    {
        CONST_VTBL struct IIdentityNameVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIdentityName_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IIdentityName_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IIdentityName_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IIdentityName_GetItemIDList(This,ppidl)	\
    ( (This)->lpVtbl -> GetItemIDList(This,ppidl) ) 

#define IIdentityName_GetItem(This,ppsi)	\
    ( (This)->lpVtbl -> GetItem(This,ppsi) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IIdentityName_INTERFACE_DEFINED__ */


#ifndef __ICurrentItem_INTERFACE_DEFINED__
#define __ICurrentItem_INTERFACE_DEFINED__

/* interface ICurrentItem */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICurrentItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("240a7174-d653-4a1d-a6d3-d4943cfbfe3d")
    ICurrentItem : public IRelatedItem
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct ICurrentItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICurrentItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICurrentItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICurrentItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemIDList )( 
            ICurrentItem * This,
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidl);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            ICurrentItem * This,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi);
        
        END_INTERFACE
    } ICurrentItemVtbl;

    interface ICurrentItem
    {
        CONST_VTBL struct ICurrentItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICurrentItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICurrentItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICurrentItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICurrentItem_GetItemIDList(This,ppidl)	\
    ( (This)->lpVtbl -> GetItemIDList(This,ppidl) ) 

#define ICurrentItem_GetItem(This,ppsi)	\
    ( (This)->lpVtbl -> GetItem(This,ppsi) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICurrentItem_INTERFACE_DEFINED__ */


#ifndef __ITransferMediumItem_INTERFACE_DEFINED__
#define __ITransferMediumItem_INTERFACE_DEFINED__

/* interface ITransferMediumItem */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITransferMediumItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("77f295d5-2d6f-4e19-b8ae-322f3e721ab5")
    ITransferMediumItem : public IRelatedItem
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct ITransferMediumItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransferMediumItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransferMediumItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransferMediumItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemIDList )( 
            ITransferMediumItem * This,
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidl);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            ITransferMediumItem * This,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi);
        
        END_INTERFACE
    } ITransferMediumItemVtbl;

    interface ITransferMediumItem
    {
        CONST_VTBL struct ITransferMediumItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransferMediumItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITransferMediumItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITransferMediumItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITransferMediumItem_GetItemIDList(This,ppidl)	\
    ( (This)->lpVtbl -> GetItemIDList(This,ppidl) ) 

#define ITransferMediumItem_GetItem(This,ppsi)	\
    ( (This)->lpVtbl -> GetItem(This,ppsi) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITransferMediumItem_INTERFACE_DEFINED__ */


#ifndef __IUseToBrowseItem_INTERFACE_DEFINED__
#define __IUseToBrowseItem_INTERFACE_DEFINED__

/* interface IUseToBrowseItem */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUseToBrowseItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("05edda5c-98a3-4717-8adb-c5e7da991eb1")
    IUseToBrowseItem : public IRelatedItem
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IUseToBrowseItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUseToBrowseItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUseToBrowseItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUseToBrowseItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemIDList )( 
            IUseToBrowseItem * This,
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidl);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            IUseToBrowseItem * This,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi);
        
        END_INTERFACE
    } IUseToBrowseItemVtbl;

    interface IUseToBrowseItem
    {
        CONST_VTBL struct IUseToBrowseItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUseToBrowseItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUseToBrowseItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUseToBrowseItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUseToBrowseItem_GetItemIDList(This,ppidl)	\
    ( (This)->lpVtbl -> GetItemIDList(This,ppidl) ) 

#define IUseToBrowseItem_GetItem(This,ppsi)	\
    ( (This)->lpVtbl -> GetItem(This,ppsi) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUseToBrowseItem_INTERFACE_DEFINED__ */


#ifndef __IDisplayItem_INTERFACE_DEFINED__
#define __IDisplayItem_INTERFACE_DEFINED__

/* interface IDisplayItem */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDisplayItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c6fd5997-9f6b-4888-8703-94e80e8cde3f")
    IDisplayItem : public IRelatedItem
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDisplayItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDisplayItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDisplayItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDisplayItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemIDList )( 
            IDisplayItem * This,
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidl);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            IDisplayItem * This,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi);
        
        END_INTERFACE
    } IDisplayItemVtbl;

    interface IDisplayItem
    {
        CONST_VTBL struct IDisplayItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDisplayItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDisplayItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDisplayItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDisplayItem_GetItemIDList(This,ppidl)	\
    ( (This)->lpVtbl -> GetItemIDList(This,ppidl) ) 

#define IDisplayItem_GetItem(This,ppsi)	\
    ( (This)->lpVtbl -> GetItem(This,ppsi) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDisplayItem_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0143 */
/* [local] */ 

#endif  // (_WIN32_IE >= _WIN32_IE_IE70)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0143_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0143_v0_0_s_ifspec;

#ifndef __IDestinationStreamFactory_INTERFACE_DEFINED__
#define __IDestinationStreamFactory_INTERFACE_DEFINED__

/* interface IDestinationStreamFactory */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IDestinationStreamFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8a87781b-39a7-4a1f-aab3-a39b9c34a7d9")
    IDestinationStreamFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDestinationStream( 
            /* [out] */ __RPC__deref_out_opt IStream **ppstm) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDestinationStreamFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDestinationStreamFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDestinationStreamFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDestinationStreamFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDestinationStream )( 
            IDestinationStreamFactory * This,
            /* [out] */ __RPC__deref_out_opt IStream **ppstm);
        
        END_INTERFACE
    } IDestinationStreamFactoryVtbl;

    interface IDestinationStreamFactory
    {
        CONST_VTBL struct IDestinationStreamFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDestinationStreamFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDestinationStreamFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDestinationStreamFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDestinationStreamFactory_GetDestinationStream(This,ppstm)	\
    ( (This)->lpVtbl -> GetDestinationStream(This,ppstm) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDestinationStreamFactory_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0144 */
/* [local] */ 

#if (_WIN32_IE >= _WIN32_IE_IE70)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0144_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0144_v0_0_s_ifspec;

#ifndef __IShellItemFilter_INTERFACE_DEFINED__
#define __IShellItemFilter_INTERFACE_DEFINED__

/* interface IShellItemFilter */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IShellItemFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2659B475-EEB8-48b7-8F07-B378810F48CF")
    IShellItemFilter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IncludeItem( 
            /* [in] */ __RPC__in_opt IShellItem *psi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnumFlagsForItem( 
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [out] */ __RPC__out SHCONTF *pgrfFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellItemFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellItemFilter * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellItemFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellItemFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *IncludeItem )( 
            IShellItemFilter * This,
            /* [in] */ __RPC__in_opt IShellItem *psi);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnumFlagsForItem )( 
            IShellItemFilter * This,
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [out] */ __RPC__out SHCONTF *pgrfFlags);
        
        END_INTERFACE
    } IShellItemFilterVtbl;

    interface IShellItemFilter
    {
        CONST_VTBL struct IShellItemFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellItemFilter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellItemFilter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellItemFilter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellItemFilter_IncludeItem(This,psi)	\
    ( (This)->lpVtbl -> IncludeItem(This,psi) ) 

#define IShellItemFilter_GetEnumFlagsForItem(This,psi,pgrfFlags)	\
    ( (This)->lpVtbl -> GetEnumFlagsForItem(This,psi,pgrfFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellItemFilter_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0145 */
/* [local] */ 

#endif  // (_WIN32_IE >= _WIN32_IE_IE70)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0145_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0145_v0_0_s_ifspec;

#ifndef __INameSpaceTreeControl_INTERFACE_DEFINED__
#define __INameSpaceTreeControl_INTERFACE_DEFINED__

/* interface INameSpaceTreeControl */
/* [local][uuid][object] */ 

typedef DWORD NSTCSTYLE;

/* [v1_enum] */ 
enum tagNSTCSTYLE
    {	NSTCS_HASEXPANDOS	= 0x1,
	NSTCS_HASLINES	= 0x2,
	NSTCS_SINGLECLICKEXPAND	= 0x4,
	NSTCS_FULLROWSELECT	= 0x8,
	NSTCS_SPRINGEXPAND	= 0x10,
	NSTCS_HORIZONTALSCROLL	= 0x20,
	NSTCS_ROOTHASEXPANDO	= 0x40,
	NSTCS_SHOWSELECTIONALWAYS	= 0x80,
	NSTCS_NOINFOTIP	= 0x200,
	NSTCS_EVENHEIGHT	= 0x400,
	NSTCS_NOREPLACEOPEN	= 0x800,
	NSTCS_DISABLEDRAGDROP	= 0x1000,
	NSTCS_NOORDERSTREAM	= 0x2000,
	NSTCS_RICHTOOLTIP	= 0x4000,
	NSTCS_BORDER	= 0x8000,
	NSTCS_NOEDITLABELS	= 0x10000,
	NSTCS_TABSTOP	= 0x20000,
	NSTCS_FAVORITESMODE	= 0x80000,
	NSTCS_AUTOHSCROLL	= 0x100000,
	NSTCS_FADEINOUTEXPANDOS	= 0x200000,
	NSTCS_EMPTYTEXT	= 0x400000,
	NSTCS_CHECKBOXES	= 0x800000,
	NSTCS_PARTIALCHECKBOXES	= 0x1000000,
	NSTCS_EXCLUSIONCHECKBOXES	= 0x2000000,
	NSTCS_DIMMEDCHECKBOXES	= 0x4000000,
	NSTCS_NOINDENTCHECKS	= 0x8000000,
	NSTCS_ALLOWJUNCTIONS	= 0x10000000,
	NSTCS_SHOWTABSBUTTON	= 0x20000000,
	NSTCS_SHOWDELETEBUTTON	= 0x40000000,
	NSTCS_SHOWREFRESHBUTTON	= ( int  )0x80000000
    } ;
typedef DWORD NSTCROOTSTYLE;

/* [v1_enum] */ 
enum tagNSTCROOTSTYLE
    {	NSTCRS_VISIBLE	= 0,
	NSTCRS_HIDDEN	= 0x1,
	NSTCRS_EXPANDED	= 0x2
    } ;
typedef DWORD NSTCITEMSTATE;

/* [v1_enum] */ 
enum tagNSTCITEMSTATE
    {	NSTCIS_NONE	= 0,
	NSTCIS_SELECTED	= 0x1,
	NSTCIS_EXPANDED	= 0x2,
	NSTCIS_BOLD	= 0x4,
	NSTCIS_DISABLED	= 0x8
    } ;
typedef DWORD NSTCGNI;

/* [v1_enum] */ 
enum tagNSTCGNI
    {	NSTCGNI_NEXT	= 0,
	NSTCGNI_NEXTVISIBLE	= 0x1,
	NSTCGNI_PREV	= 0x2,
	NSTCGNI_PREVVISIBLE	= 0x3,
	NSTCGNI_PARENT	= 0x4,
	NSTCGNI_CHILD	= 0x5,
	NSTCGNI_FIRSTVISIBLE	= 0x6,
	NSTCGNI_LASTVISIBLE	= 0x7
    } ;

EXTERN_C const IID IID_INameSpaceTreeControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("028212A3-B627-47e9-8856-C14265554E4F")
    INameSpaceTreeControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ 
            __in  HWND hwndParent,
            /* [unique][in] */ 
            __in_opt  RECT *prc,
            /* [in] */ 
            __in  NSTCSTYLE nsctsFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TreeAdvise( 
            /* [in] */ 
            __in  IUnknown *punk,
            /* [out] */ 
            __out  DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TreeUnadvise( 
            /* [in] */ 
            __in  DWORD dwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AppendRoot( 
            /* [in] */ 
            __in  IShellItem *psiRoot,
            /* [in] */ 
            __in  SHCONTF grfEnumFlags,
            /* [in] */ 
            __in  NSTCROOTSTYLE grfRootStyle,
            /* [unique][in] */ 
            __in_opt  IShellItemFilter *pif) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertRoot( 
            /* [in] */ 
            __in  int iIndex,
            /* [in] */ 
            __in  IShellItem *psiRoot,
            /* [in] */ 
            __in  SHCONTF grfEnumFlags,
            /* [in] */ 
            __in  NSTCROOTSTYLE grfRootStyle,
            /* [unique][in] */ 
            __in_opt  IShellItemFilter *pif) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveRoot( 
            /* [in] */ 
            __in  IShellItem *psiRoot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAllRoots( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRootItems( 
            /* [out] */ 
            __deref_out  IShellItemArray **ppsiaRootItems) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetItemState( 
            /* [in] */ 
            __in  IShellItem *psi,
            /* [in] */ 
            __in  NSTCITEMSTATE nstcisMask,
            /* [in] */ 
            __in  NSTCITEMSTATE nstcisFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItemState( 
            /* [in] */ 
            __in  IShellItem *psi,
            /* [in] */ 
            __in  NSTCITEMSTATE nstcisMask,
            /* [out] */ 
            __out  NSTCITEMSTATE *pnstcisFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSelectedItems( 
            /* [out] */ 
            __deref_out  IShellItemArray **psiaItems) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItemCustomState( 
            /* [in] */ 
            __in  IShellItem *psi,
            /* [out] */ 
            __out  int *piStateNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetItemCustomState( 
            /* [in] */ 
            __in  IShellItem *psi,
            /* [in] */ 
            __in  int iStateNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnsureItemVisible( 
            /* [in] */ 
            __in  IShellItem *psi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTheme( 
            /* [string][in] */ 
            __in  LPCWSTR pszTheme) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextItem( 
            /* [in] */ 
            __in  IShellItem *psi,
            /* [in] */ 
            __in  NSTCGNI nstcgi,
            /* [out] */ 
            __deref_out  IShellItem **ppsiNext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HitTest( 
            /* [in] */ 
            __in  POINT *ppt,
            /* [out] */ 
            __deref_out  IShellItem **ppsiOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItemRect( 
            /* [in] */ 
            __in  IShellItem *psi,
            /* [out] */ 
            __out  RECT *prect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CollapseAll( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INameSpaceTreeControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INameSpaceTreeControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INameSpaceTreeControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INameSpaceTreeControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            INameSpaceTreeControl * This,
            /* [in] */ 
            __in  HWND hwndParent,
            /* [unique][in] */ 
            __in_opt  RECT *prc,
            /* [in] */ 
            __in  NSTCSTYLE nsctsFlags);
        
        HRESULT ( STDMETHODCALLTYPE *TreeAdvise )( 
            INameSpaceTreeControl * This,
            /* [in] */ 
            __in  IUnknown *punk,
            /* [out] */ 
            __out  DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *TreeUnadvise )( 
            INameSpaceTreeControl * This,
            /* [in] */ 
            __in  DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *AppendRoot )( 
            INameSpaceTreeControl * This,
            /* [in] */ 
            __in  IShellItem *psiRoot,
            /* [in] */ 
            __in  SHCONTF grfEnumFlags,
            /* [in] */ 
            __in  NSTCROOTSTYLE grfRootStyle,
            /* [unique][in] */ 
            __in_opt  IShellItemFilter *pif);
        
        HRESULT ( STDMETHODCALLTYPE *InsertRoot )( 
            INameSpaceTreeControl * This,
            /* [in] */ 
            __in  int iIndex,
            /* [in] */ 
            __in  IShellItem *psiRoot,
            /* [in] */ 
            __in  SHCONTF grfEnumFlags,
            /* [in] */ 
            __in  NSTCROOTSTYLE grfRootStyle,
            /* [unique][in] */ 
            __in_opt  IShellItemFilter *pif);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveRoot )( 
            INameSpaceTreeControl * This,
            /* [in] */ 
            __in  IShellItem *psiRoot);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAllRoots )( 
            INameSpaceTreeControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRootItems )( 
            INameSpaceTreeControl * This,
            /* [out] */ 
            __deref_out  IShellItemArray **ppsiaRootItems);
        
        HRESULT ( STDMETHODCALLTYPE *SetItemState )( 
            INameSpaceTreeControl * This,
            /* [in] */ 
            __in  IShellItem *psi,
            /* [in] */ 
            __in  NSTCITEMSTATE nstcisMask,
            /* [in] */ 
            __in  NSTCITEMSTATE nstcisFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemState )( 
            INameSpaceTreeControl * This,
            /* [in] */ 
            __in  IShellItem *psi,
            /* [in] */ 
            __in  NSTCITEMSTATE nstcisMask,
            /* [out] */ 
            __out  NSTCITEMSTATE *pnstcisFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelectedItems )( 
            INameSpaceTreeControl * This,
            /* [out] */ 
            __deref_out  IShellItemArray **psiaItems);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemCustomState )( 
            INameSpaceTreeControl * This,
            /* [in] */ 
            __in  IShellItem *psi,
            /* [out] */ 
            __out  int *piStateNumber);
        
        HRESULT ( STDMETHODCALLTYPE *SetItemCustomState )( 
            INameSpaceTreeControl * This,
            /* [in] */ 
            __in  IShellItem *psi,
            /* [in] */ 
            __in  int iStateNumber);
        
        HRESULT ( STDMETHODCALLTYPE *EnsureItemVisible )( 
            INameSpaceTreeControl * This,
            /* [in] */ 
            __in  IShellItem *psi);
        
        HRESULT ( STDMETHODCALLTYPE *SetTheme )( 
            INameSpaceTreeControl * This,
            /* [string][in] */ 
            __in  LPCWSTR pszTheme);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextItem )( 
            INameSpaceTreeControl * This,
            /* [in] */ 
            __in  IShellItem *psi,
            /* [in] */ 
            __in  NSTCGNI nstcgi,
            /* [out] */ 
            __deref_out  IShellItem **ppsiNext);
        
        HRESULT ( STDMETHODCALLTYPE *HitTest )( 
            INameSpaceTreeControl * This,
            /* [in] */ 
            __in  POINT *ppt,
            /* [out] */ 
            __deref_out  IShellItem **ppsiOut);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemRect )( 
            INameSpaceTreeControl * This,
            /* [in] */ 
            __in  IShellItem *psi,
            /* [out] */ 
            __out  RECT *prect);
        
        HRESULT ( STDMETHODCALLTYPE *CollapseAll )( 
            INameSpaceTreeControl * This);
        
        END_INTERFACE
    } INameSpaceTreeControlVtbl;

    interface INameSpaceTreeControl
    {
        CONST_VTBL struct INameSpaceTreeControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INameSpaceTreeControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INameSpaceTreeControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INameSpaceTreeControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INameSpaceTreeControl_Initialize(This,hwndParent,prc,nsctsFlags)	\
    ( (This)->lpVtbl -> Initialize(This,hwndParent,prc,nsctsFlags) ) 

#define INameSpaceTreeControl_TreeAdvise(This,punk,pdwCookie)	\
    ( (This)->lpVtbl -> TreeAdvise(This,punk,pdwCookie) ) 

#define INameSpaceTreeControl_TreeUnadvise(This,dwCookie)	\
    ( (This)->lpVtbl -> TreeUnadvise(This,dwCookie) ) 

#define INameSpaceTreeControl_AppendRoot(This,psiRoot,grfEnumFlags,grfRootStyle,pif)	\
    ( (This)->lpVtbl -> AppendRoot(This,psiRoot,grfEnumFlags,grfRootStyle,pif) ) 

#define INameSpaceTreeControl_InsertRoot(This,iIndex,psiRoot,grfEnumFlags,grfRootStyle,pif)	\
    ( (This)->lpVtbl -> InsertRoot(This,iIndex,psiRoot,grfEnumFlags,grfRootStyle,pif) ) 

#define INameSpaceTreeControl_RemoveRoot(This,psiRoot)	\
    ( (This)->lpVtbl -> RemoveRoot(This,psiRoot) ) 

#define INameSpaceTreeControl_RemoveAllRoots(This)	\
    ( (This)->lpVtbl -> RemoveAllRoots(This) ) 

#define INameSpaceTreeControl_GetRootItems(This,ppsiaRootItems)	\
    ( (This)->lpVtbl -> GetRootItems(This,ppsiaRootItems) ) 

#define INameSpaceTreeControl_SetItemState(This,psi,nstcisMask,nstcisFlags)	\
    ( (This)->lpVtbl -> SetItemState(This,psi,nstcisMask,nstcisFlags) ) 

#define INameSpaceTreeControl_GetItemState(This,psi,nstcisMask,pnstcisFlags)	\
    ( (This)->lpVtbl -> GetItemState(This,psi,nstcisMask,pnstcisFlags) ) 

#define INameSpaceTreeControl_GetSelectedItems(This,psiaItems)	\
    ( (This)->lpVtbl -> GetSelectedItems(This,psiaItems) ) 

#define INameSpaceTreeControl_GetItemCustomState(This,psi,piStateNumber)	\
    ( (This)->lpVtbl -> GetItemCustomState(This,psi,piStateNumber) ) 

#define INameSpaceTreeControl_SetItemCustomState(This,psi,iStateNumber)	\
    ( (This)->lpVtbl -> SetItemCustomState(This,psi,iStateNumber) ) 

#define INameSpaceTreeControl_EnsureItemVisible(This,psi)	\
    ( (This)->lpVtbl -> EnsureItemVisible(This,psi) ) 

#define INameSpaceTreeControl_SetTheme(This,pszTheme)	\
    ( (This)->lpVtbl -> SetTheme(This,pszTheme) ) 

#define INameSpaceTreeControl_GetNextItem(This,psi,nstcgi,ppsiNext)	\
    ( (This)->lpVtbl -> GetNextItem(This,psi,nstcgi,ppsiNext) ) 

#define INameSpaceTreeControl_HitTest(This,ppt,ppsiOut)	\
    ( (This)->lpVtbl -> HitTest(This,ppt,ppsiOut) ) 

#define INameSpaceTreeControl_GetItemRect(This,psi,prect)	\
    ( (This)->lpVtbl -> GetItemRect(This,psi,prect) ) 

#define INameSpaceTreeControl_CollapseAll(This)	\
    ( (This)->lpVtbl -> CollapseAll(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INameSpaceTreeControl_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0146 */
/* [local] */ 

#define SID_SNavigationPane IID_INameSpaceTreeControl   // nearest service that you can proffer to
#define ISLBUTTON(x) (NSTCECT_LBUTTON == ((x) & NSTCECT_BUTTON))
#define ISMBUTTON(x) (NSTCECT_MBUTTON == ((x) & NSTCECT_BUTTON))
#define ISRBUTTON(x) (NSTCECT_RBUTTON == ((x) & NSTCECT_BUTTON))
#define ISDBLCLICK(x) (NSTCECT_DBLCLICK == ((x) & NSTCECT_DBLCLICK))


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0146_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0146_v0_0_s_ifspec;

#ifndef __INameSpaceTreeControlEvents_INTERFACE_DEFINED__
#define __INameSpaceTreeControlEvents_INTERFACE_DEFINED__

/* interface INameSpaceTreeControlEvents */
/* [local][uuid][object] */ 

typedef DWORD NSTCEHITTEST;

/* [v1_enum] */ 
enum tagNSTCEHITTEST
    {	NSTCEHT_NOWHERE	= 0x1,
	NSTCEHT_ONITEMICON	= 0x2,
	NSTCEHT_ONITEMLABEL	= 0x4,
	NSTCEHT_ONITEMINDENT	= 0x8,
	NSTCEHT_ONITEMBUTTON	= 0x10,
	NSTCEHT_ONITEMRIGHT	= 0x20,
	NSTCEHT_ONITEMSTATEICON	= 0x40,
	NSTCEHT_ONITEM	= 0x46,
	NSTCEHT_ONITEMTABBUTTON	= 0x1000
    } ;
typedef DWORD NSTCECLICKTYPE;

/* [v1_enum] */ 
enum tagNSTCECLICKTYPE
    {	NSTCECT_LBUTTON	= 0x1,
	NSTCECT_MBUTTON	= 0x2,
	NSTCECT_RBUTTON	= 0x3,
	NSTCECT_BUTTON	= 0x3,
	NSTCECT_DBLCLICK	= 0x4
    } ;

EXTERN_C const IID IID_INameSpaceTreeControlEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("93D77985-B3D8-4484-8318-672CDDA002CE")
    INameSpaceTreeControlEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnItemClick( 
            /* [in] */ 
            __in  IShellItem *psi,
            /* [in] */ 
            __in  NSTCEHITTEST nstceHitTest,
            /* [in] */ 
            __in  NSTCECLICKTYPE nstceClickType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnPropertyItemCommit( 
            /* [in] */ 
            __in  IShellItem *psi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnItemStateChanging( 
            /* [in] */ 
            __in  IShellItem *psi,
            /* [in] */ 
            __in  NSTCITEMSTATE nstcisMask,
            /* [in] */ 
            __in  NSTCITEMSTATE nstcisState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnItemStateChanged( 
            /* [in] */ 
            __in  IShellItem *psi,
            /* [in] */ 
            __in  NSTCITEMSTATE nstcisMask,
            /* [in] */ 
            __in  NSTCITEMSTATE nstcisState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSelectionChanged( 
            /* [in] */ 
            __in  IShellItemArray *psiaSelection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnKeyboardInput( 
            /* [in] */ 
            __in  UINT uMsg,
            /* [in] */ 
            __in  WPARAM wParam,
            /* [in] */ 
            __in  LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnBeforeExpand( 
            /* [in] */ 
            __in  IShellItem *psi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnAfterExpand( 
            /* [in] */ 
            __in  IShellItem *psi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnBeginLabelEdit( 
            /* [in] */ 
            __in  IShellItem *psi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnEndLabelEdit( 
            /* [in] */ 
            __in  IShellItem *psi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnGetToolTip( 
            /* [in] */ 
            __in  IShellItem *psi,
            /* [size_is][string][out] */ 
            __out_ecount(cchTip)  LPWSTR pszTip,
            /* [in] */ 
            __in  int cchTip) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnBeforeItemDelete( 
            /* [in] */ 
            __in  IShellItem *psi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnItemAdded( 
            /* [in] */ 
            __in  IShellItem *psi,
            /* [in] */ 
            __in  BOOL fIsRoot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnItemDeleted( 
            /* [in] */ 
            __in  IShellItem *psi,
            /* [in] */ 
            __in  BOOL fIsRoot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnBeforeContextMenu( 
            /* [in] */ 
            __in  IShellItem *psi,
            /* [in] */ 
            __in  REFIID riid,
            /* [iid_is][out] */ 
            __deref_out  void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnAfterContextMenu( 
            /* [in] */ 
            __in  IShellItem *psi,
            /* [in] */ 
            __in  IContextMenu *pcmIn,
            /* [in] */ 
            __in  REFIID riid,
            /* [iid_is][out] */ 
            __deref_out  void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnBeforeStateImageChange( 
            /* [in] */ 
            __in  IShellItem *psi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnGetDefaultIconIndex( 
            /* [in] */ 
            __in  IShellItem *psi,
            /* [out] */ 
            __out  int *piDefaultIcon,
            /* [out] */ 
            __out  int *piOpenIcon) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INameSpaceTreeControlEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INameSpaceTreeControlEvents * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INameSpaceTreeControlEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INameSpaceTreeControlEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnItemClick )( 
            INameSpaceTreeControlEvents * This,
            /* [in] */ 
            __in  IShellItem *psi,
            /* [in] */ 
            __in  NSTCEHITTEST nstceHitTest,
            /* [in] */ 
            __in  NSTCECLICKTYPE nstceClickType);
        
        HRESULT ( STDMETHODCALLTYPE *OnPropertyItemCommit )( 
            INameSpaceTreeControlEvents * This,
            /* [in] */ 
            __in  IShellItem *psi);
        
        HRESULT ( STDMETHODCALLTYPE *OnItemStateChanging )( 
            INameSpaceTreeControlEvents * This,
            /* [in] */ 
            __in  IShellItem *psi,
            /* [in] */ 
            __in  NSTCITEMSTATE nstcisMask,
            /* [in] */ 
            __in  NSTCITEMSTATE nstcisState);
        
        HRESULT ( STDMETHODCALLTYPE *OnItemStateChanged )( 
            INameSpaceTreeControlEvents * This,
            /* [in] */ 
            __in  IShellItem *psi,
            /* [in] */ 
            __in  NSTCITEMSTATE nstcisMask,
            /* [in] */ 
            __in  NSTCITEMSTATE nstcisState);
        
        HRESULT ( STDMETHODCALLTYPE *OnSelectionChanged )( 
            INameSpaceTreeControlEvents * This,
            /* [in] */ 
            __in  IShellItemArray *psiaSelection);
        
        HRESULT ( STDMETHODCALLTYPE *OnKeyboardInput )( 
            INameSpaceTreeControlEvents * This,
            /* [in] */ 
            __in  UINT uMsg,
            /* [in] */ 
            __in  WPARAM wParam,
            /* [in] */ 
            __in  LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *OnBeforeExpand )( 
            INameSpaceTreeControlEvents * This,
            /* [in] */ 
            __in  IShellItem *psi);
        
        HRESULT ( STDMETHODCALLTYPE *OnAfterExpand )( 
            INameSpaceTreeControlEvents * This,
            /* [in] */ 
            __in  IShellItem *psi);
        
        HRESULT ( STDMETHODCALLTYPE *OnBeginLabelEdit )( 
            INameSpaceTreeControlEvents * This,
            /* [in] */ 
            __in  IShellItem *psi);
        
        HRESULT ( STDMETHODCALLTYPE *OnEndLabelEdit )( 
            INameSpaceTreeControlEvents * This,
            /* [in] */ 
            __in  IShellItem *psi);
        
        HRESULT ( STDMETHODCALLTYPE *OnGetToolTip )( 
            INameSpaceTreeControlEvents * This,
            /* [in] */ 
            __in  IShellItem *psi,
            /* [size_is][string][out] */ 
            __out_ecount(cchTip)  LPWSTR pszTip,
            /* [in] */ 
            __in  int cchTip);
        
        HRESULT ( STDMETHODCALLTYPE *OnBeforeItemDelete )( 
            INameSpaceTreeControlEvents * This,
            /* [in] */ 
            __in  IShellItem *psi);
        
        HRESULT ( STDMETHODCALLTYPE *OnItemAdded )( 
            INameSpaceTreeControlEvents * This,
            /* [in] */ 
            __in  IShellItem *psi,
            /* [in] */ 
            __in  BOOL fIsRoot);
        
        HRESULT ( STDMETHODCALLTYPE *OnItemDeleted )( 
            INameSpaceTreeControlEvents * This,
            /* [in] */ 
            __in  IShellItem *psi,
            /* [in] */ 
            __in  BOOL fIsRoot);
        
        HRESULT ( STDMETHODCALLTYPE *OnBeforeContextMenu )( 
            INameSpaceTreeControlEvents * This,
            /* [in] */ 
            __in  IShellItem *psi,
            /* [in] */ 
            __in  REFIID riid,
            /* [iid_is][out] */ 
            __deref_out  void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *OnAfterContextMenu )( 
            INameSpaceTreeControlEvents * This,
            /* [in] */ 
            __in  IShellItem *psi,
            /* [in] */ 
            __in  IContextMenu *pcmIn,
            /* [in] */ 
            __in  REFIID riid,
            /* [iid_is][out] */ 
            __deref_out  void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *OnBeforeStateImageChange )( 
            INameSpaceTreeControlEvents * This,
            /* [in] */ 
            __in  IShellItem *psi);
        
        HRESULT ( STDMETHODCALLTYPE *OnGetDefaultIconIndex )( 
            INameSpaceTreeControlEvents * This,
            /* [in] */ 
            __in  IShellItem *psi,
            /* [out] */ 
            __out  int *piDefaultIcon,
            /* [out] */ 
            __out  int *piOpenIcon);
        
        END_INTERFACE
    } INameSpaceTreeControlEventsVtbl;

    interface INameSpaceTreeControlEvents
    {
        CONST_VTBL struct INameSpaceTreeControlEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INameSpaceTreeControlEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INameSpaceTreeControlEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INameSpaceTreeControlEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INameSpaceTreeControlEvents_OnItemClick(This,psi,nstceHitTest,nstceClickType)	\
    ( (This)->lpVtbl -> OnItemClick(This,psi,nstceHitTest,nstceClickType) ) 

#define INameSpaceTreeControlEvents_OnPropertyItemCommit(This,psi)	\
    ( (This)->lpVtbl -> OnPropertyItemCommit(This,psi) ) 

#define INameSpaceTreeControlEvents_OnItemStateChanging(This,psi,nstcisMask,nstcisState)	\
    ( (This)->lpVtbl -> OnItemStateChanging(This,psi,nstcisMask,nstcisState) ) 

#define INameSpaceTreeControlEvents_OnItemStateChanged(This,psi,nstcisMask,nstcisState)	\
    ( (This)->lpVtbl -> OnItemStateChanged(This,psi,nstcisMask,nstcisState) ) 

#define INameSpaceTreeControlEvents_OnSelectionChanged(This,psiaSelection)	\
    ( (This)->lpVtbl -> OnSelectionChanged(This,psiaSelection) ) 

#define INameSpaceTreeControlEvents_OnKeyboardInput(This,uMsg,wParam,lParam)	\
    ( (This)->lpVtbl -> OnKeyboardInput(This,uMsg,wParam,lParam) ) 

#define INameSpaceTreeControlEvents_OnBeforeExpand(This,psi)	\
    ( (This)->lpVtbl -> OnBeforeExpand(This,psi) ) 

#define INameSpaceTreeControlEvents_OnAfterExpand(This,psi)	\
    ( (This)->lpVtbl -> OnAfterExpand(This,psi) ) 

#define INameSpaceTreeControlEvents_OnBeginLabelEdit(This,psi)	\
    ( (This)->lpVtbl -> OnBeginLabelEdit(This,psi) ) 

#define INameSpaceTreeControlEvents_OnEndLabelEdit(This,psi)	\
    ( (This)->lpVtbl -> OnEndLabelEdit(This,psi) ) 

#define INameSpaceTreeControlEvents_OnGetToolTip(This,psi,pszTip,cchTip)	\
    ( (This)->lpVtbl -> OnGetToolTip(This,psi,pszTip,cchTip) ) 

#define INameSpaceTreeControlEvents_OnBeforeItemDelete(This,psi)	\
    ( (This)->lpVtbl -> OnBeforeItemDelete(This,psi) ) 

#define INameSpaceTreeControlEvents_OnItemAdded(This,psi,fIsRoot)	\
    ( (This)->lpVtbl -> OnItemAdded(This,psi,fIsRoot) ) 

#define INameSpaceTreeControlEvents_OnItemDeleted(This,psi,fIsRoot)	\
    ( (This)->lpVtbl -> OnItemDeleted(This,psi,fIsRoot) ) 

#define INameSpaceTreeControlEvents_OnBeforeContextMenu(This,psi,riid,ppv)	\
    ( (This)->lpVtbl -> OnBeforeContextMenu(This,psi,riid,ppv) ) 

#define INameSpaceTreeControlEvents_OnAfterContextMenu(This,psi,pcmIn,riid,ppv)	\
    ( (This)->lpVtbl -> OnAfterContextMenu(This,psi,pcmIn,riid,ppv) ) 

#define INameSpaceTreeControlEvents_OnBeforeStateImageChange(This,psi)	\
    ( (This)->lpVtbl -> OnBeforeStateImageChange(This,psi) ) 

#define INameSpaceTreeControlEvents_OnGetDefaultIconIndex(This,psi,piDefaultIcon,piOpenIcon)	\
    ( (This)->lpVtbl -> OnGetDefaultIconIndex(This,psi,piDefaultIcon,piOpenIcon) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INameSpaceTreeControlEvents_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0147 */
/* [local] */ 

#define NSTCDHPOS_ONTOP  -1


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0147_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0147_v0_0_s_ifspec;

#ifndef __INameSpaceTreeControlDropHandler_INTERFACE_DEFINED__
#define __INameSpaceTreeControlDropHandler_INTERFACE_DEFINED__

/* interface INameSpaceTreeControlDropHandler */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_INameSpaceTreeControlDropHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F9C665D6-C2F2-4c19-BF33-8322D7352F51")
    INameSpaceTreeControlDropHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnDragEnter( 
            /* [unique][in] */ 
            __in_opt  IShellItem *psiOver,
            /* [in] */ 
            __in  IShellItemArray *psiaData,
            /* [in] */ 
            __in  BOOL fOutsideSource,
            /* [in] */ 
            __in  DWORD grfKeyState,
            /* [out][in] */ 
            __inout  DWORD *pdwEffect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDragOver( 
            /* [unique][in] */ 
            __in_opt  IShellItem *psiOver,
            /* [in] */ 
            __in  IShellItemArray *psiaData,
            /* [in] */ 
            __in  DWORD grfKeyState,
            /* [out][in] */ 
            __inout  DWORD *pdwEffect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDragPosition( 
            /* [unique][in] */ 
            __in_opt  IShellItem *psiOver,
            /* [in] */ 
            __in  IShellItemArray *psiaData,
            /* [in] */ 
            __in  int iNewPosition,
            /* [in] */ 
            __in  int iOldPosition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDrop( 
            /* [unique][in] */ 
            __in_opt  IShellItem *psiOver,
            /* [in] */ 
            __in  IShellItemArray *psiaData,
            /* [in] */ 
            __in  int iPosition,
            /* [in] */ 
            __in  DWORD grfKeyState,
            /* [out][in] */ 
            __inout  DWORD *pdwEffect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDropPosition( 
            /* [unique][in] */ 
            __in_opt  IShellItem *psiOver,
            /* [in] */ 
            __in  IShellItemArray *psiaData,
            /* [in] */ 
            __in  int iNewPosition,
            /* [in] */ 
            __in  int iOldPosition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDragLeave( 
            /* [unique][in] */ 
            __in_opt  IShellItem *psiOver) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INameSpaceTreeControlDropHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INameSpaceTreeControlDropHandler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INameSpaceTreeControlDropHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INameSpaceTreeControlDropHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnDragEnter )( 
            INameSpaceTreeControlDropHandler * This,
            /* [unique][in] */ 
            __in_opt  IShellItem *psiOver,
            /* [in] */ 
            __in  IShellItemArray *psiaData,
            /* [in] */ 
            __in  BOOL fOutsideSource,
            /* [in] */ 
            __in  DWORD grfKeyState,
            /* [out][in] */ 
            __inout  DWORD *pdwEffect);
        
        HRESULT ( STDMETHODCALLTYPE *OnDragOver )( 
            INameSpaceTreeControlDropHandler * This,
            /* [unique][in] */ 
            __in_opt  IShellItem *psiOver,
            /* [in] */ 
            __in  IShellItemArray *psiaData,
            /* [in] */ 
            __in  DWORD grfKeyState,
            /* [out][in] */ 
            __inout  DWORD *pdwEffect);
        
        HRESULT ( STDMETHODCALLTYPE *OnDragPosition )( 
            INameSpaceTreeControlDropHandler * This,
            /* [unique][in] */ 
            __in_opt  IShellItem *psiOver,
            /* [in] */ 
            __in  IShellItemArray *psiaData,
            /* [in] */ 
            __in  int iNewPosition,
            /* [in] */ 
            __in  int iOldPosition);
        
        HRESULT ( STDMETHODCALLTYPE *OnDrop )( 
            INameSpaceTreeControlDropHandler * This,
            /* [unique][in] */ 
            __in_opt  IShellItem *psiOver,
            /* [in] */ 
            __in  IShellItemArray *psiaData,
            /* [in] */ 
            __in  int iPosition,
            /* [in] */ 
            __in  DWORD grfKeyState,
            /* [out][in] */ 
            __inout  DWORD *pdwEffect);
        
        HRESULT ( STDMETHODCALLTYPE *OnDropPosition )( 
            INameSpaceTreeControlDropHandler * This,
            /* [unique][in] */ 
            __in_opt  IShellItem *psiOver,
            /* [in] */ 
            __in  IShellItemArray *psiaData,
            /* [in] */ 
            __in  int iNewPosition,
            /* [in] */ 
            __in  int iOldPosition);
        
        HRESULT ( STDMETHODCALLTYPE *OnDragLeave )( 
            INameSpaceTreeControlDropHandler * This,
            /* [unique][in] */ 
            __in_opt  IShellItem *psiOver);
        
        END_INTERFACE
    } INameSpaceTreeControlDropHandlerVtbl;

    interface INameSpaceTreeControlDropHandler
    {
        CONST_VTBL struct INameSpaceTreeControlDropHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INameSpaceTreeControlDropHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INameSpaceTreeControlDropHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INameSpaceTreeControlDropHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INameSpaceTreeControlDropHandler_OnDragEnter(This,psiOver,psiaData,fOutsideSource,grfKeyState,pdwEffect)	\
    ( (This)->lpVtbl -> OnDragEnter(This,psiOver,psiaData,fOutsideSource,grfKeyState,pdwEffect) ) 

#define INameSpaceTreeControlDropHandler_OnDragOver(This,psiOver,psiaData,grfKeyState,pdwEffect)	\
    ( (This)->lpVtbl -> OnDragOver(This,psiOver,psiaData,grfKeyState,pdwEffect) ) 

#define INameSpaceTreeControlDropHandler_OnDragPosition(This,psiOver,psiaData,iNewPosition,iOldPosition)	\
    ( (This)->lpVtbl -> OnDragPosition(This,psiOver,psiaData,iNewPosition,iOldPosition) ) 

#define INameSpaceTreeControlDropHandler_OnDrop(This,psiOver,psiaData,iPosition,grfKeyState,pdwEffect)	\
    ( (This)->lpVtbl -> OnDrop(This,psiOver,psiaData,iPosition,grfKeyState,pdwEffect) ) 

#define INameSpaceTreeControlDropHandler_OnDropPosition(This,psiOver,psiaData,iNewPosition,iOldPosition)	\
    ( (This)->lpVtbl -> OnDropPosition(This,psiOver,psiaData,iNewPosition,iOldPosition) ) 

#define INameSpaceTreeControlDropHandler_OnDragLeave(This,psiOver)	\
    ( (This)->lpVtbl -> OnDragLeave(This,psiOver) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INameSpaceTreeControlDropHandler_INTERFACE_DEFINED__ */


#ifndef __INameSpaceTreeAccessible_INTERFACE_DEFINED__
#define __INameSpaceTreeAccessible_INTERFACE_DEFINED__

/* interface INameSpaceTreeAccessible */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_INameSpaceTreeAccessible;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("71f312de-43ed-4190-8477-e9536b82350b")
    INameSpaceTreeAccessible : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnGetDefaultAccessibilityAction( 
            /* [in] */ 
            __in  IShellItem *psi,
            /* [out] */ 
            __deref_out  BSTR *pbstrDefaultAction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDoDefaultAccessibilityAction( 
            /* [in] */ 
            __in  IShellItem *psi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnGetAccessibilityRole( 
            /* [in] */ 
            __in  IShellItem *psi,
            /* [out] */ 
            __out  VARIANT *pvarRole) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INameSpaceTreeAccessibleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INameSpaceTreeAccessible * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INameSpaceTreeAccessible * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INameSpaceTreeAccessible * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnGetDefaultAccessibilityAction )( 
            INameSpaceTreeAccessible * This,
            /* [in] */ 
            __in  IShellItem *psi,
            /* [out] */ 
            __deref_out  BSTR *pbstrDefaultAction);
        
        HRESULT ( STDMETHODCALLTYPE *OnDoDefaultAccessibilityAction )( 
            INameSpaceTreeAccessible * This,
            /* [in] */ 
            __in  IShellItem *psi);
        
        HRESULT ( STDMETHODCALLTYPE *OnGetAccessibilityRole )( 
            INameSpaceTreeAccessible * This,
            /* [in] */ 
            __in  IShellItem *psi,
            /* [out] */ 
            __out  VARIANT *pvarRole);
        
        END_INTERFACE
    } INameSpaceTreeAccessibleVtbl;

    interface INameSpaceTreeAccessible
    {
        CONST_VTBL struct INameSpaceTreeAccessibleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INameSpaceTreeAccessible_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INameSpaceTreeAccessible_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INameSpaceTreeAccessible_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INameSpaceTreeAccessible_OnGetDefaultAccessibilityAction(This,psi,pbstrDefaultAction)	\
    ( (This)->lpVtbl -> OnGetDefaultAccessibilityAction(This,psi,pbstrDefaultAction) ) 

#define INameSpaceTreeAccessible_OnDoDefaultAccessibilityAction(This,psi)	\
    ( (This)->lpVtbl -> OnDoDefaultAccessibilityAction(This,psi) ) 

#define INameSpaceTreeAccessible_OnGetAccessibilityRole(This,psi,pvarRole)	\
    ( (This)->lpVtbl -> OnGetAccessibilityRole(This,psi,pvarRole) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INameSpaceTreeAccessible_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0149 */
/* [local] */ 

#ifdef MIDL_PASS
typedef IUnknown *HIMAGELIST;

#endif


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0149_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0149_v0_0_s_ifspec;

#ifndef __INameSpaceTreeControlCustomDraw_INTERFACE_DEFINED__
#define __INameSpaceTreeControlCustomDraw_INTERFACE_DEFINED__

/* interface INameSpaceTreeControlCustomDraw */
/* [local][uuid][object] */ 

typedef struct tagNSTCCUSTOMDRAW
    {
    IShellItem *psi;
    UINT uItemState;
    NSTCITEMSTATE nstcis;
    LPCWSTR pszText;
    int iImage;
    HIMAGELIST himl;
    int iLevel;
    int iIndent;
    } 	NSTCCUSTOMDRAW;


EXTERN_C const IID IID_INameSpaceTreeControlCustomDraw;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2D3BA758-33EE-42d5-BB7B-5F3431D86C78")
    INameSpaceTreeControlCustomDraw : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PrePaint( 
            /* [in] */ 
            __in  HDC hdc,
            /* [in] */ 
            __in  RECT *prc,
            /* [out] */ 
            __out  LRESULT *plres) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PostPaint( 
            /* [in] */ 
            __in  HDC hdc,
            /* [in] */ 
            __in  RECT *prc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ItemPrePaint( 
            /* [in] */ 
            __in  HDC hdc,
            /* [in] */ 
            __in  RECT *prc,
            /* [in] */ 
            __in  NSTCCUSTOMDRAW *pnstccdItem,
            /* [out][in] */ 
            __inout  COLORREF *pclrText,
            /* [out][in] */ 
            __inout  COLORREF *pclrTextBk,
            /* [out] */ 
            __out  LRESULT *plres) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ItemPostPaint( 
            /* [in] */ 
            __in  HDC hdc,
            /* [in] */ 
            __in  RECT *prc,
            /* [in] */ 
            __in  NSTCCUSTOMDRAW *pnstccdItem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INameSpaceTreeControlCustomDrawVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INameSpaceTreeControlCustomDraw * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INameSpaceTreeControlCustomDraw * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INameSpaceTreeControlCustomDraw * This);
        
        HRESULT ( STDMETHODCALLTYPE *PrePaint )( 
            INameSpaceTreeControlCustomDraw * This,
            /* [in] */ 
            __in  HDC hdc,
            /* [in] */ 
            __in  RECT *prc,
            /* [out] */ 
            __out  LRESULT *plres);
        
        HRESULT ( STDMETHODCALLTYPE *PostPaint )( 
            INameSpaceTreeControlCustomDraw * This,
            /* [in] */ 
            __in  HDC hdc,
            /* [in] */ 
            __in  RECT *prc);
        
        HRESULT ( STDMETHODCALLTYPE *ItemPrePaint )( 
            INameSpaceTreeControlCustomDraw * This,
            /* [in] */ 
            __in  HDC hdc,
            /* [in] */ 
            __in  RECT *prc,
            /* [in] */ 
            __in  NSTCCUSTOMDRAW *pnstccdItem,
            /* [out][in] */ 
            __inout  COLORREF *pclrText,
            /* [out][in] */ 
            __inout  COLORREF *pclrTextBk,
            /* [out] */ 
            __out  LRESULT *plres);
        
        HRESULT ( STDMETHODCALLTYPE *ItemPostPaint )( 
            INameSpaceTreeControlCustomDraw * This,
            /* [in] */ 
            __in  HDC hdc,
            /* [in] */ 
            __in  RECT *prc,
            /* [in] */ 
            __in  NSTCCUSTOMDRAW *pnstccdItem);
        
        END_INTERFACE
    } INameSpaceTreeControlCustomDrawVtbl;

    interface INameSpaceTreeControlCustomDraw
    {
        CONST_VTBL struct INameSpaceTreeControlCustomDrawVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INameSpaceTreeControlCustomDraw_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INameSpaceTreeControlCustomDraw_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INameSpaceTreeControlCustomDraw_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INameSpaceTreeControlCustomDraw_PrePaint(This,hdc,prc,plres)	\
    ( (This)->lpVtbl -> PrePaint(This,hdc,prc,plres) ) 

#define INameSpaceTreeControlCustomDraw_PostPaint(This,hdc,prc)	\
    ( (This)->lpVtbl -> PostPaint(This,hdc,prc) ) 

#define INameSpaceTreeControlCustomDraw_ItemPrePaint(This,hdc,prc,pnstccdItem,pclrText,pclrTextBk,plres)	\
    ( (This)->lpVtbl -> ItemPrePaint(This,hdc,prc,pnstccdItem,pclrText,pclrTextBk,plres) ) 

#define INameSpaceTreeControlCustomDraw_ItemPostPaint(This,hdc,prc,pnstccdItem)	\
    ( (This)->lpVtbl -> ItemPostPaint(This,hdc,prc,pnstccdItem) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INameSpaceTreeControlCustomDraw_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0150 */
/* [local] */ 

#define E_PREVIEWHANDLER_DRM_FAIL _HRESULT_TYPEDEF_(0x86420001L)
#define E_PREVIEWHANDLER_NOAUTH   _HRESULT_TYPEDEF_(0x86420002L)
#define E_PREVIEWHANDLER_NOTFOUND _HRESULT_TYPEDEF_(0x86420003L)
#define E_PREVIEWHANDLER_CORRUPT  _HRESULT_TYPEDEF_(0x86420004L)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0150_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0150_v0_0_s_ifspec;

#ifndef __IPreviewHandler_INTERFACE_DEFINED__
#define __IPreviewHandler_INTERFACE_DEFINED__

/* interface IPreviewHandler */
/* [uuid][object] */ 


EXTERN_C const IID IID_IPreviewHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8895b1c6-b41f-4c1c-a562-0d564250836f")
    IPreviewHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetWindow( 
            /* [in] */ __RPC__in HWND hwnd,
            /* [in] */ __RPC__in const RECT *prc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRect( 
            /* [in] */ __RPC__in const RECT *prc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoPreview( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unload( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFocus( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryFocus( 
            /* [out] */ __RPC__deref_out_opt HWND *phwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TranslateAccelerator( 
            /* [in] */ __RPC__in MSG *pmsg) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPreviewHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPreviewHandler * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPreviewHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPreviewHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetWindow )( 
            IPreviewHandler * This,
            /* [in] */ __RPC__in HWND hwnd,
            /* [in] */ __RPC__in const RECT *prc);
        
        HRESULT ( STDMETHODCALLTYPE *SetRect )( 
            IPreviewHandler * This,
            /* [in] */ __RPC__in const RECT *prc);
        
        HRESULT ( STDMETHODCALLTYPE *DoPreview )( 
            IPreviewHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *Unload )( 
            IPreviewHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFocus )( 
            IPreviewHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryFocus )( 
            IPreviewHandler * This,
            /* [out] */ __RPC__deref_out_opt HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *TranslateAccelerator )( 
            IPreviewHandler * This,
            /* [in] */ __RPC__in MSG *pmsg);
        
        END_INTERFACE
    } IPreviewHandlerVtbl;

    interface IPreviewHandler
    {
        CONST_VTBL struct IPreviewHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPreviewHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPreviewHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPreviewHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPreviewHandler_SetWindow(This,hwnd,prc)	\
    ( (This)->lpVtbl -> SetWindow(This,hwnd,prc) ) 

#define IPreviewHandler_SetRect(This,prc)	\
    ( (This)->lpVtbl -> SetRect(This,prc) ) 

#define IPreviewHandler_DoPreview(This)	\
    ( (This)->lpVtbl -> DoPreview(This) ) 

#define IPreviewHandler_Unload(This)	\
    ( (This)->lpVtbl -> Unload(This) ) 

#define IPreviewHandler_SetFocus(This)	\
    ( (This)->lpVtbl -> SetFocus(This) ) 

#define IPreviewHandler_QueryFocus(This,phwnd)	\
    ( (This)->lpVtbl -> QueryFocus(This,phwnd) ) 

#define IPreviewHandler_TranslateAccelerator(This,pmsg)	\
    ( (This)->lpVtbl -> TranslateAccelerator(This,pmsg) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPreviewHandler_INTERFACE_DEFINED__ */


#ifndef __IPreviewHandlerFrame_INTERFACE_DEFINED__
#define __IPreviewHandlerFrame_INTERFACE_DEFINED__

/* interface IPreviewHandlerFrame */
/* [unique][uuid][object] */ 

typedef /* [public][public] */ struct __MIDL_IPreviewHandlerFrame_0001
    {
    HACCEL haccel;
    UINT cAccelEntries;
    } 	PREVIEWHANDLERFRAMEINFO;


EXTERN_C const IID IID_IPreviewHandlerFrame;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fec87aaf-35f9-447a-adb7-20234491401a")
    IPreviewHandlerFrame : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetWindowContext( 
            /* [out] */ __RPC__out PREVIEWHANDLERFRAMEINFO *pinfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TranslateAccelerator( 
            /* [in] */ __RPC__in MSG *pmsg) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPreviewHandlerFrameVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPreviewHandlerFrame * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPreviewHandlerFrame * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPreviewHandlerFrame * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetWindowContext )( 
            IPreviewHandlerFrame * This,
            /* [out] */ __RPC__out PREVIEWHANDLERFRAMEINFO *pinfo);
        
        HRESULT ( STDMETHODCALLTYPE *TranslateAccelerator )( 
            IPreviewHandlerFrame * This,
            /* [in] */ __RPC__in MSG *pmsg);
        
        END_INTERFACE
    } IPreviewHandlerFrameVtbl;

    interface IPreviewHandlerFrame
    {
        CONST_VTBL struct IPreviewHandlerFrameVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPreviewHandlerFrame_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPreviewHandlerFrame_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPreviewHandlerFrame_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPreviewHandlerFrame_GetWindowContext(This,pinfo)	\
    ( (This)->lpVtbl -> GetWindowContext(This,pinfo) ) 

#define IPreviewHandlerFrame_TranslateAccelerator(This,pmsg)	\
    ( (This)->lpVtbl -> TranslateAccelerator(This,pmsg) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPreviewHandlerFrame_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0152 */
/* [local] */ 

#if (NTDDI_VERSION >= NTDDI_VISTA)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0152_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0152_v0_0_s_ifspec;

#ifndef __ITrayDeskBand_INTERFACE_DEFINED__
#define __ITrayDeskBand_INTERFACE_DEFINED__

/* interface ITrayDeskBand */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITrayDeskBand;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6D67E846-5B9C-4db8-9CBC-DDE12F4254F1")
    ITrayDeskBand : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ShowDeskBand( 
            /* [in] */ __RPC__in REFCLSID clsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HideDeskBand( 
            /* [in] */ __RPC__in REFCLSID clsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsDeskBandShown( 
            /* [in] */ __RPC__in REFCLSID clsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeskBandRegistrationChanged( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITrayDeskBandVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITrayDeskBand * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITrayDeskBand * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITrayDeskBand * This);
        
        HRESULT ( STDMETHODCALLTYPE *ShowDeskBand )( 
            ITrayDeskBand * This,
            /* [in] */ __RPC__in REFCLSID clsid);
        
        HRESULT ( STDMETHODCALLTYPE *HideDeskBand )( 
            ITrayDeskBand * This,
            /* [in] */ __RPC__in REFCLSID clsid);
        
        HRESULT ( STDMETHODCALLTYPE *IsDeskBandShown )( 
            ITrayDeskBand * This,
            /* [in] */ __RPC__in REFCLSID clsid);
        
        HRESULT ( STDMETHODCALLTYPE *DeskBandRegistrationChanged )( 
            ITrayDeskBand * This);
        
        END_INTERFACE
    } ITrayDeskBandVtbl;

    interface ITrayDeskBand
    {
        CONST_VTBL struct ITrayDeskBandVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITrayDeskBand_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITrayDeskBand_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITrayDeskBand_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITrayDeskBand_ShowDeskBand(This,clsid)	\
    ( (This)->lpVtbl -> ShowDeskBand(This,clsid) ) 

#define ITrayDeskBand_HideDeskBand(This,clsid)	\
    ( (This)->lpVtbl -> HideDeskBand(This,clsid) ) 

#define ITrayDeskBand_IsDeskBandShown(This,clsid)	\
    ( (This)->lpVtbl -> IsDeskBandShown(This,clsid) ) 

#define ITrayDeskBand_DeskBandRegistrationChanged(This)	\
    ( (This)->lpVtbl -> DeskBandRegistrationChanged(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITrayDeskBand_INTERFACE_DEFINED__ */


#ifndef __IBandHost_INTERFACE_DEFINED__
#define __IBandHost_INTERFACE_DEFINED__

/* interface IBandHost */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IBandHost;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B9075C7C-D48E-403f-AB99-D6C77A1084AC")
    IBandHost : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateBand( 
            /* [in] */ __RPC__in REFCLSID rclsidBand,
            /* [in] */ BOOL fAvailable,
            /* [in] */ BOOL fVisible,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBandAvailability( 
            /* [in] */ __RPC__in REFCLSID rclsidBand,
            /* [in] */ BOOL fAvailable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyBand( 
            /* [in] */ __RPC__in REFCLSID rclsidBand) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBandHostVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBandHost * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBandHost * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBandHost * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBand )( 
            IBandHost * This,
            /* [in] */ __RPC__in REFCLSID rclsidBand,
            /* [in] */ BOOL fAvailable,
            /* [in] */ BOOL fVisible,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *SetBandAvailability )( 
            IBandHost * This,
            /* [in] */ __RPC__in REFCLSID rclsidBand,
            /* [in] */ BOOL fAvailable);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyBand )( 
            IBandHost * This,
            /* [in] */ __RPC__in REFCLSID rclsidBand);
        
        END_INTERFACE
    } IBandHostVtbl;

    interface IBandHost
    {
        CONST_VTBL struct IBandHostVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBandHost_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBandHost_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBandHost_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBandHost_CreateBand(This,rclsidBand,fAvailable,fVisible,riid,ppv)	\
    ( (This)->lpVtbl -> CreateBand(This,rclsidBand,fAvailable,fVisible,riid,ppv) ) 

#define IBandHost_SetBandAvailability(This,rclsidBand,fAvailable)	\
    ( (This)->lpVtbl -> SetBandAvailability(This,rclsidBand,fAvailable) ) 

#define IBandHost_DestroyBand(This,rclsidBand)	\
    ( (This)->lpVtbl -> DestroyBand(This,rclsidBand) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IBandHost_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0154 */
/* [local] */ 

#define SID_SBandHost IID_IBandHost
typedef GUID EXPLORERPANE;

#if 0
typedef EXPLORERPANE *REFEXPLORERPANE;

#endif // 0
#ifdef __cplusplus
#define REFEXPLORERPANE const EXPLORERPANE &
#else // !__cplusplus
#define REFEXPLORERPANE const EXPLORERPANE * __MIDL_CONST
#endif // __cplusplus


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0154_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0154_v0_0_s_ifspec;

#ifndef __IExplorerPaneVisibility_INTERFACE_DEFINED__
#define __IExplorerPaneVisibility_INTERFACE_DEFINED__

/* interface IExplorerPaneVisibility */
/* [unique][local][uuid][object] */ 


enum tagEXPLORERPANESTATE
    {	EPS_DONTCARE	= 0,
	EPS_DEFAULT_ON	= 0x1,
	EPS_DEFAULT_OFF	= 0x2,
	EPS_STATEMASK	= 0xffff,
	EPS_INITIALSTATE	= 0x10000,
	EPS_FORCE	= 0x20000
    } ;
typedef DWORD EXPLORERPANESTATE;


EXTERN_C const IID IID_IExplorerPaneVisibility;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e07010ec-bc17-44c0-97b0-46c7c95b9edc")
    IExplorerPaneVisibility : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPaneState( 
            /* [in] */ 
            __in  REFEXPLORERPANE ep,
            /* [out] */ 
            __out  EXPLORERPANESTATE *peps) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExplorerPaneVisibilityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IExplorerPaneVisibility * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IExplorerPaneVisibility * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IExplorerPaneVisibility * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPaneState )( 
            IExplorerPaneVisibility * This,
            /* [in] */ 
            __in  REFEXPLORERPANE ep,
            /* [out] */ 
            __out  EXPLORERPANESTATE *peps);
        
        END_INTERFACE
    } IExplorerPaneVisibilityVtbl;

    interface IExplorerPaneVisibility
    {
        CONST_VTBL struct IExplorerPaneVisibilityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExplorerPaneVisibility_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IExplorerPaneVisibility_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IExplorerPaneVisibility_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IExplorerPaneVisibility_GetPaneState(This,ep,peps)	\
    ( (This)->lpVtbl -> GetPaneState(This,ep,peps) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IExplorerPaneVisibility_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0155 */
/* [local] */ 

#define SID_ExplorerPaneVisibility IID_IExplorerPaneVisibility


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0155_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0155_v0_0_s_ifspec;

#ifndef __IContextMenuCB_INTERFACE_DEFINED__
#define __IContextMenuCB_INTERFACE_DEFINED__

/* interface IContextMenuCB */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IContextMenuCB;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3409E930-5A39-11d1-83FA-00A0C90DC849")
    IContextMenuCB : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CallBack( 
            /* [unique][in] */ 
            __in_opt  IShellFolder *psf,
            /* [in] */ 
            __in  HWND hwndOwner,
            /* [unique][in] */ 
            __in_opt  IDataObject *pdtobj,
            /* [in] */ 
            __in  UINT uMsg,
            /* [in] */ 
            __in  WPARAM wParam,
            /* [in] */ 
            __in  LPARAM lParam) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IContextMenuCBVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IContextMenuCB * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IContextMenuCB * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IContextMenuCB * This);
        
        HRESULT ( STDMETHODCALLTYPE *CallBack )( 
            IContextMenuCB * This,
            /* [unique][in] */ 
            __in_opt  IShellFolder *psf,
            /* [in] */ 
            __in  HWND hwndOwner,
            /* [unique][in] */ 
            __in_opt  IDataObject *pdtobj,
            /* [in] */ 
            __in  UINT uMsg,
            /* [in] */ 
            __in  WPARAM wParam,
            /* [in] */ 
            __in  LPARAM lParam);
        
        END_INTERFACE
    } IContextMenuCBVtbl;

    interface IContextMenuCB
    {
        CONST_VTBL struct IContextMenuCBVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContextMenuCB_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IContextMenuCB_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IContextMenuCB_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IContextMenuCB_CallBack(This,psf,hwndOwner,pdtobj,uMsg,wParam,lParam)	\
    ( (This)->lpVtbl -> CallBack(This,psf,hwndOwner,pdtobj,uMsg,wParam,lParam) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IContextMenuCB_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0156 */
/* [local] */ 

#endif  // NTDDI_VISTA


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0156_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0156_v0_0_s_ifspec;

#ifndef __IDefaultExtractIconInit_INTERFACE_DEFINED__
#define __IDefaultExtractIconInit_INTERFACE_DEFINED__

/* interface IDefaultExtractIconInit */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IDefaultExtractIconInit;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("41ded17d-d6b3-4261-997d-88c60e4b1d58")
    IDefaultExtractIconInit : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFlags( 
            /* [in] */ 
            __in  UINT uFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetKey( 
            /* [in] */ 
            __in  HKEY hkey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNormalIcon( 
            /* [string][in] */ 
            __in  LPCWSTR pszFile,
            /* [in] */ 
            __in  int iIcon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOpenIcon( 
            /* [string][in] */ 
            __in  LPCWSTR pszFile,
            /* [in] */ 
            __in  int iIcon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetShortcutIcon( 
            /* [string][in] */ 
            __in  LPCWSTR pszFile,
            /* [in] */ 
            __in  int iIcon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultIcon( 
            /* [string][in] */ 
            __in  LPCWSTR pszFile,
            /* [in] */ 
            __in  int iIcon) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDefaultExtractIconInitVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDefaultExtractIconInit * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDefaultExtractIconInit * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDefaultExtractIconInit * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFlags )( 
            IDefaultExtractIconInit * This,
            /* [in] */ 
            __in  UINT uFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetKey )( 
            IDefaultExtractIconInit * This,
            /* [in] */ 
            __in  HKEY hkey);
        
        HRESULT ( STDMETHODCALLTYPE *SetNormalIcon )( 
            IDefaultExtractIconInit * This,
            /* [string][in] */ 
            __in  LPCWSTR pszFile,
            /* [in] */ 
            __in  int iIcon);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpenIcon )( 
            IDefaultExtractIconInit * This,
            /* [string][in] */ 
            __in  LPCWSTR pszFile,
            /* [in] */ 
            __in  int iIcon);
        
        HRESULT ( STDMETHODCALLTYPE *SetShortcutIcon )( 
            IDefaultExtractIconInit * This,
            /* [string][in] */ 
            __in  LPCWSTR pszFile,
            /* [in] */ 
            __in  int iIcon);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultIcon )( 
            IDefaultExtractIconInit * This,
            /* [string][in] */ 
            __in  LPCWSTR pszFile,
            /* [in] */ 
            __in  int iIcon);
        
        END_INTERFACE
    } IDefaultExtractIconInitVtbl;

    interface IDefaultExtractIconInit
    {
        CONST_VTBL struct IDefaultExtractIconInitVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDefaultExtractIconInit_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDefaultExtractIconInit_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDefaultExtractIconInit_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDefaultExtractIconInit_SetFlags(This,uFlags)	\
    ( (This)->lpVtbl -> SetFlags(This,uFlags) ) 

#define IDefaultExtractIconInit_SetKey(This,hkey)	\
    ( (This)->lpVtbl -> SetKey(This,hkey) ) 

#define IDefaultExtractIconInit_SetNormalIcon(This,pszFile,iIcon)	\
    ( (This)->lpVtbl -> SetNormalIcon(This,pszFile,iIcon) ) 

#define IDefaultExtractIconInit_SetOpenIcon(This,pszFile,iIcon)	\
    ( (This)->lpVtbl -> SetOpenIcon(This,pszFile,iIcon) ) 

#define IDefaultExtractIconInit_SetShortcutIcon(This,pszFile,iIcon)	\
    ( (This)->lpVtbl -> SetShortcutIcon(This,pszFile,iIcon) ) 

#define IDefaultExtractIconInit_SetDefaultIcon(This,pszFile,iIcon)	\
    ( (This)->lpVtbl -> SetDefaultIcon(This,pszFile,iIcon) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDefaultExtractIconInit_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0157 */
/* [local] */ 

STDAPI SHCreateDefaultExtractIcon(__in REFIID riid, __deref_out void **ppv);



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0157_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0157_v0_0_s_ifspec;

#ifndef __IExplorerCommand_INTERFACE_DEFINED__
#define __IExplorerCommand_INTERFACE_DEFINED__

/* interface IExplorerCommand */
/* [object][unique][uuid] */ 


enum tagEXPCMDSTATE
    {	ECS_ENABLED	= 0,
	ECS_DISABLED	= 0x1,
	ECS_HIDDEN	= 0x2,
	ECS_CHECKBOX	= 0x4,
	ECS_CHECKED	= 0x8
    } ;
typedef DWORD EXPCMDSTATE;


enum tagEXPCMDFLAGS
    {	ECF_HASSUBCOMMANDS	= 0x1,
	ECF_HASSPLITBUTTON	= 0x2,
	ECF_HIDELABEL	= 0x4,
	ECF_ISSEPARATOR	= 0x8,
	ECF_HASLUASHIELD	= 0x10
    } ;
typedef DWORD EXPCMDFLAGS;


EXTERN_C const IID IID_IExplorerCommand;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a08ce4d0-fa25-44ab-b57c-c7b1c323e0b9")
    IExplorerCommand : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTitle( 
            /* [unique][in] */ __RPC__in_opt IShellItemArray *psiItemArray,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIcon( 
            /* [unique][in] */ __RPC__in_opt IShellItemArray *psiItemArray,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszIcon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetToolTip( 
            /* [unique][in] */ __RPC__in_opt IShellItemArray *psiItemArray,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszInfotip) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCanonicalName( 
            /* [out] */ __RPC__out GUID *pguidCommandName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetState( 
            /* [in] */ __RPC__in_opt IShellItemArray *psiItemArray,
            /* [in] */ BOOL fOkToBeSlow,
            /* [out] */ __RPC__out EXPCMDSTATE *pCmdState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Invoke( 
            /* [in] */ __RPC__in_opt IShellItemArray *psiItemArray,
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFlags( 
            /* [out] */ __RPC__out EXPCMDFLAGS *pFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumSubCommands( 
            /* [out] */ __RPC__deref_out_opt IEnumExplorerCommand **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExplorerCommandVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IExplorerCommand * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IExplorerCommand * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IExplorerCommand * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTitle )( 
            IExplorerCommand * This,
            /* [unique][in] */ __RPC__in_opt IShellItemArray *psiItemArray,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetIcon )( 
            IExplorerCommand * This,
            /* [unique][in] */ __RPC__in_opt IShellItemArray *psiItemArray,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszIcon);
        
        HRESULT ( STDMETHODCALLTYPE *GetToolTip )( 
            IExplorerCommand * This,
            /* [unique][in] */ __RPC__in_opt IShellItemArray *psiItemArray,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszInfotip);
        
        HRESULT ( STDMETHODCALLTYPE *GetCanonicalName )( 
            IExplorerCommand * This,
            /* [out] */ __RPC__out GUID *pguidCommandName);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            IExplorerCommand * This,
            /* [in] */ __RPC__in_opt IShellItemArray *psiItemArray,
            /* [in] */ BOOL fOkToBeSlow,
            /* [out] */ __RPC__out EXPCMDSTATE *pCmdState);
        
        HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IExplorerCommand * This,
            /* [in] */ __RPC__in_opt IShellItemArray *psiItemArray,
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbc);
        
        HRESULT ( STDMETHODCALLTYPE *GetFlags )( 
            IExplorerCommand * This,
            /* [out] */ __RPC__out EXPCMDFLAGS *pFlags);
        
        HRESULT ( STDMETHODCALLTYPE *EnumSubCommands )( 
            IExplorerCommand * This,
            /* [out] */ __RPC__deref_out_opt IEnumExplorerCommand **ppEnum);
        
        END_INTERFACE
    } IExplorerCommandVtbl;

    interface IExplorerCommand
    {
        CONST_VTBL struct IExplorerCommandVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExplorerCommand_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IExplorerCommand_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IExplorerCommand_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IExplorerCommand_GetTitle(This,psiItemArray,ppszName)	\
    ( (This)->lpVtbl -> GetTitle(This,psiItemArray,ppszName) ) 

#define IExplorerCommand_GetIcon(This,psiItemArray,ppszIcon)	\
    ( (This)->lpVtbl -> GetIcon(This,psiItemArray,ppszIcon) ) 

#define IExplorerCommand_GetToolTip(This,psiItemArray,ppszInfotip)	\
    ( (This)->lpVtbl -> GetToolTip(This,psiItemArray,ppszInfotip) ) 

#define IExplorerCommand_GetCanonicalName(This,pguidCommandName)	\
    ( (This)->lpVtbl -> GetCanonicalName(This,pguidCommandName) ) 

#define IExplorerCommand_GetState(This,psiItemArray,fOkToBeSlow,pCmdState)	\
    ( (This)->lpVtbl -> GetState(This,psiItemArray,fOkToBeSlow,pCmdState) ) 

#define IExplorerCommand_Invoke(This,psiItemArray,pbc)	\
    ( (This)->lpVtbl -> Invoke(This,psiItemArray,pbc) ) 

#define IExplorerCommand_GetFlags(This,pFlags)	\
    ( (This)->lpVtbl -> GetFlags(This,pFlags) ) 

#define IExplorerCommand_EnumSubCommands(This,ppEnum)	\
    ( (This)->lpVtbl -> EnumSubCommands(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IExplorerCommand_INTERFACE_DEFINED__ */


#ifndef __IEnumExplorerCommand_INTERFACE_DEFINED__
#define __IEnumExplorerCommand_INTERFACE_DEFINED__

/* interface IEnumExplorerCommand */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_IEnumExplorerCommand;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a88826f8-186f-4987-aade-ea0cef8fbfe8")
    IEnumExplorerCommand : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) IExplorerCommand **pUICommand,
            /* [out] */ __RPC__out ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumExplorerCommand **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumExplorerCommandVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumExplorerCommand * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumExplorerCommand * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumExplorerCommand * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumExplorerCommand * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) IExplorerCommand **pUICommand,
            /* [out] */ __RPC__out ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumExplorerCommand * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumExplorerCommand * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumExplorerCommand * This,
            /* [out] */ __RPC__deref_out_opt IEnumExplorerCommand **ppenum);
        
        END_INTERFACE
    } IEnumExplorerCommandVtbl;

    interface IEnumExplorerCommand
    {
        CONST_VTBL struct IEnumExplorerCommandVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumExplorerCommand_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumExplorerCommand_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumExplorerCommand_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumExplorerCommand_Next(This,celt,pUICommand,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,pUICommand,pceltFetched) ) 

#define IEnumExplorerCommand_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumExplorerCommand_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumExplorerCommand_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumExplorerCommand_INTERFACE_DEFINED__ */


#ifndef __IExplorerCommandProvider_INTERFACE_DEFINED__
#define __IExplorerCommandProvider_INTERFACE_DEFINED__

/* interface IExplorerCommandProvider */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_IExplorerCommandProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("64961751-0835-43c0-8ffe-d57686530e64")
    IExplorerCommandProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCommands( 
            /* [in] */ __RPC__in_opt IUnknown *punkSite,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCommand( 
            /* [in] */ __RPC__in REFGUID rguidCommandId,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExplorerCommandProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IExplorerCommandProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IExplorerCommandProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IExplorerCommandProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCommands )( 
            IExplorerCommandProvider * This,
            /* [in] */ __RPC__in_opt IUnknown *punkSite,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetCommand )( 
            IExplorerCommandProvider * This,
            /* [in] */ __RPC__in REFGUID rguidCommandId,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        END_INTERFACE
    } IExplorerCommandProviderVtbl;

    interface IExplorerCommandProvider
    {
        CONST_VTBL struct IExplorerCommandProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExplorerCommandProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IExplorerCommandProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IExplorerCommandProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IExplorerCommandProvider_GetCommands(This,punkSite,riid,ppv)	\
    ( (This)->lpVtbl -> GetCommands(This,punkSite,riid,ppv) ) 

#define IExplorerCommandProvider_GetCommand(This,rguidCommandId,riid,ppv)	\
    ( (This)->lpVtbl -> GetCommand(This,rguidCommandId,riid,ppv) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IExplorerCommandProvider_INTERFACE_DEFINED__ */


#ifndef __IMarkupCallback_INTERFACE_DEFINED__
#define __IMarkupCallback_INTERFACE_DEFINED__

/* interface IMarkupCallback */
/* [object][local][uuid] */ 


EXTERN_C const IID IID_IMarkupCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4440306e-d79a-48d0-88e6-a42692279bfb")
    IMarkupCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetState( 
            /* [in] */ 
            __in  DWORD dwId,
            /* [in] */ 
            __in  UINT uState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ 
            __in  DWORD dwId,
            /* [in] */ 
            __in  int nCode,
            /* [in] */ 
            __in  int iLink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InvalidateRect( 
            /* [in] */ 
            __in  DWORD dwId,
            /* [in] */ 
            __in  const RECT *prc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnCustomDraw( 
            /* [in] */ 
            __in  DWORD dwDrawStage,
            /* [in] */ 
            __in  HDC hdc,
            /* [in] */ 
            __in  const RECT *prc,
            /* [in] */ 
            __in  DWORD dwId,
            /* [in] */ 
            __in  int iLink,
            /* [in] */ 
            __in  UINT uItemState,
            /* [out] */ 
            __out  LRESULT *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CustomDrawText( 
            /* [in] */ 
            __in  HDC hDC,
            /* [string][in] */ 
            __in  LPCWSTR lpString,
            /* [in] */ 
            __in  int nCount,
            /* [in] */ 
            __in  RECT *pRect,
            /* [in] */ 
            __in  UINT uFormat,
            /* [in] */ 
            __in  BOOL fLink) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMarkupCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMarkupCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMarkupCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMarkupCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            IMarkupCallback * This,
            /* [in] */ 
            __in  DWORD dwId,
            /* [in] */ 
            __in  UINT uState);
        
        HRESULT ( STDMETHODCALLTYPE *Notify )( 
            IMarkupCallback * This,
            /* [in] */ 
            __in  DWORD dwId,
            /* [in] */ 
            __in  int nCode,
            /* [in] */ 
            __in  int iLink);
        
        HRESULT ( STDMETHODCALLTYPE *InvalidateRect )( 
            IMarkupCallback * This,
            /* [in] */ 
            __in  DWORD dwId,
            /* [in] */ 
            __in  const RECT *prc);
        
        HRESULT ( STDMETHODCALLTYPE *OnCustomDraw )( 
            IMarkupCallback * This,
            /* [in] */ 
            __in  DWORD dwDrawStage,
            /* [in] */ 
            __in  HDC hdc,
            /* [in] */ 
            __in  const RECT *prc,
            /* [in] */ 
            __in  DWORD dwId,
            /* [in] */ 
            __in  int iLink,
            /* [in] */ 
            __in  UINT uItemState,
            /* [out] */ 
            __out  LRESULT *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *CustomDrawText )( 
            IMarkupCallback * This,
            /* [in] */ 
            __in  HDC hDC,
            /* [string][in] */ 
            __in  LPCWSTR lpString,
            /* [in] */ 
            __in  int nCount,
            /* [in] */ 
            __in  RECT *pRect,
            /* [in] */ 
            __in  UINT uFormat,
            /* [in] */ 
            __in  BOOL fLink);
        
        END_INTERFACE
    } IMarkupCallbackVtbl;

    interface IMarkupCallback
    {
        CONST_VTBL struct IMarkupCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMarkupCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMarkupCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMarkupCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMarkupCallback_GetState(This,dwId,uState)	\
    ( (This)->lpVtbl -> GetState(This,dwId,uState) ) 

#define IMarkupCallback_Notify(This,dwId,nCode,iLink)	\
    ( (This)->lpVtbl -> Notify(This,dwId,nCode,iLink) ) 

#define IMarkupCallback_InvalidateRect(This,dwId,prc)	\
    ( (This)->lpVtbl -> InvalidateRect(This,dwId,prc) ) 

#define IMarkupCallback_OnCustomDraw(This,dwDrawStage,hdc,prc,dwId,iLink,uItemState,pdwResult)	\
    ( (This)->lpVtbl -> OnCustomDraw(This,dwDrawStage,hdc,prc,dwId,iLink,uItemState,pdwResult) ) 

#define IMarkupCallback_CustomDrawText(This,hDC,lpString,nCount,pRect,uFormat,fLink)	\
    ( (This)->lpVtbl -> CustomDrawText(This,hDC,lpString,nCount,pRect,uFormat,fLink) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMarkupCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0161 */
/* [local] */ 

typedef HANDLE HTHEME;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0161_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0161_v0_0_s_ifspec;

#ifndef __IControlMarkup_INTERFACE_DEFINED__
#define __IControlMarkup_INTERFACE_DEFINED__

/* interface IControlMarkup */
/* [object][local][uuid] */ 

/* [v1_enum] */ 
enum tagMARKUPSIZE
    {	MARKUPSIZE_CALCWIDTH	= 0,
	MARKUPSIZE_CALCHEIGHT	= ( MARKUPSIZE_CALCWIDTH + 1 ) 
    } ;
typedef enum tagMARKUPSIZE MARKUPSIZE;

/* [v1_enum] */ 
enum tagMARKUPLINKTEXT
    {	MARKUPLINKTEXT_URL	= 0,
	MARKUPLINKTEXT_ID	= ( MARKUPLINKTEXT_URL + 1 ) ,
	MARKUPLINKTEXT_TEXT	= ( MARKUPLINKTEXT_ID + 1 ) 
    } ;
typedef enum tagMARKUPLINKTEXT MARKUPLINKTEXT;

/* [v1_enum] */ 
enum tagMARKUPSTATE
    {	MARKUPSTATE_FOCUSED	= 0x1,
	MARKUPSTATE_ENABLED	= 0x2,
	MARKUPSTATE_VISITED	= 0x4,
	MARKUPSTATE_HOT	= 0x8,
	MARKUPSTATE_DEFAULTCOLORS	= 0x10,
	MARKUPSTATE_ALLOWMARKUP	= 0x40000000
    } ;
typedef DWORD MARKUPSTATE;

/* [v1_enum] */ 
enum tagMARKUPMESSAGE
    {	MARKUPMESSAGE_KEYEXECUTE	= 0,
	MARKUPMESSAGE_CLICKEXECUTE	= ( MARKUPMESSAGE_KEYEXECUTE + 1 ) ,
	MARKUPMESSAGE_WANTFOCUS	= ( MARKUPMESSAGE_CLICKEXECUTE + 1 ) 
    } ;
typedef enum tagMARKUPMESSAGE MARKUPMESSAGE;


EXTERN_C const IID IID_IControlMarkup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D6D2FBAE-F116-458c-8C34-03569877A2D2")
    IControlMarkup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetCallback( 
            /* [in] */ 
            __in  IUnknown *punk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCallback( 
            /* [in] */ 
            __in  REFIID riid,
            /* [iid_is][out] */ 
            __deref_out  void **ppvUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetId( 
            /* [in] */ 
            __in  DWORD dwId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetId( 
            /* [out] */ 
            __out  DWORD *pdwId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFonts( 
            /* [in] */ 
            __in  HFONT hFont,
            /* [in] */ 
            __in  HFONT hFontUnderline) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFonts( 
            /* [out] */ 
            __out  HFONT *phFont,
            /* [out] */ 
            __out  HFONT *phFontUnderline) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetText( 
            /* [string][in] */ 
            __in  LPCWSTR pwszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetText( 
            /* [in] */ 
            __in  BOOL bRaw,
            /* [size_is][string][out] */ 
            __out_ecount_part(*pdwCch, *pdwCch)  LPWSTR pwszText,
            /* [out][in] */ 
            __inout  DWORD *pdwCch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLinkText( 
            /* [in] */ 
            __in  int iLink,
            /* [in] */ 
            __in  UINT uMarkupLinkText,
            /* [string][in] */ 
            __in  LPCWSTR pwszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLinkText( 
            /* [in] */ 
            __in  int iLink,
            /* [in] */ 
            __in  UINT uMarkupLinkText,
            /* [size_is][string][out] */ 
            __out_ecount_part(*pdwCch, *pdwCch)  LPWSTR pwszText,
            /* [out][in] */ 
            __inout  DWORD *pdwCch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRenderFlags( 
            /* [in] */ 
            __in  UINT uDT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRenderFlags( 
            /* [out] */ 
            __out  UINT *puDT,
            /* [out] */ 
            __out  HTHEME *phTheme,
            /* [out] */ 
            __out  int *piPartId,
            /* [out] */ 
            __out  int *piStateIdNormal,
            /* [out] */ 
            __out  int *piStateIdLink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetThemeRenderFlags( 
            /* [in] */ 
            __in  UINT uDT,
            /* [in] */ 
            __in  HTHEME hTheme,
            /* [in] */ 
            __in  int iPartId,
            /* [in] */ 
            __in  int iStateIdNormal,
            /* [in] */ 
            __in  int iStateIdLink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetState( 
            /* [in] */ 
            __in  int iLink,
            /* [in] */ 
            __in  UINT uStateMask,
            /* [out] */ 
            __out  UINT *puState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetState( 
            /* [in] */ 
            __in  int iLink,
            /* [in] */ 
            __in  UINT uStateMask,
            /* [in] */ 
            __in  UINT uState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DrawText( 
            /* [in] */ 
            __in  HDC hdcClient,
            /* [in] */ 
            __in  LPCRECT prcClient) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLinkCursor( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CalcIdealSize( 
            /* [in] */ 
            __in  HDC hdc,
            /* [in] */ 
            __in  UINT uMarkUpCalc,
            /* [out][in] */ 
            __inout  RECT *prc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFocus( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE KillFocus( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsTabbable( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnButtonDown( 
            /* [in] */ 
            __in  POINT pt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnButtonUp( 
            /* [in] */ 
            __in  POINT pt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnKeyDown( 
            /* [in] */ 
            __in  UINT uVirtKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HitTest( 
            /* [in] */ 
            __in  POINT pt,
            /* [out] */ 
            __out  int *piLink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLinkRect( 
            /* [in] */ 
            __in  int iLink,
            /* [out] */ 
            __out  RECT *prc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetControlRect( 
            /* [out] */ 
            __out  RECT *prcControl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLinkCount( 
            /* [out] */ 
            __out  UINT *pcLinks) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IControlMarkupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IControlMarkup * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IControlMarkup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IControlMarkup * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetCallback )( 
            IControlMarkup * This,
            /* [in] */ 
            __in  IUnknown *punk);
        
        HRESULT ( STDMETHODCALLTYPE *GetCallback )( 
            IControlMarkup * This,
            /* [in] */ 
            __in  REFIID riid,
            /* [iid_is][out] */ 
            __deref_out  void **ppvUnk);
        
        HRESULT ( STDMETHODCALLTYPE *SetId )( 
            IControlMarkup * This,
            /* [in] */ 
            __in  DWORD dwId);
        
        HRESULT ( STDMETHODCALLTYPE *GetId )( 
            IControlMarkup * This,
            /* [out] */ 
            __out  DWORD *pdwId);
        
        HRESULT ( STDMETHODCALLTYPE *SetFonts )( 
            IControlMarkup * This,
            /* [in] */ 
            __in  HFONT hFont,
            /* [in] */ 
            __in  HFONT hFontUnderline);
        
        HRESULT ( STDMETHODCALLTYPE *GetFonts )( 
            IControlMarkup * This,
            /* [out] */ 
            __out  HFONT *phFont,
            /* [out] */ 
            __out  HFONT *phFontUnderline);
        
        HRESULT ( STDMETHODCALLTYPE *SetText )( 
            IControlMarkup * This,
            /* [string][in] */ 
            __in  LPCWSTR pwszText);
        
        HRESULT ( STDMETHODCALLTYPE *GetText )( 
            IControlMarkup * This,
            /* [in] */ 
            __in  BOOL bRaw,
            /* [size_is][string][out] */ 
            __out_ecount_part(*pdwCch, *pdwCch)  LPWSTR pwszText,
            /* [out][in] */ 
            __inout  DWORD *pdwCch);
        
        HRESULT ( STDMETHODCALLTYPE *SetLinkText )( 
            IControlMarkup * This,
            /* [in] */ 
            __in  int iLink,
            /* [in] */ 
            __in  UINT uMarkupLinkText,
            /* [string][in] */ 
            __in  LPCWSTR pwszText);
        
        HRESULT ( STDMETHODCALLTYPE *GetLinkText )( 
            IControlMarkup * This,
            /* [in] */ 
            __in  int iLink,
            /* [in] */ 
            __in  UINT uMarkupLinkText,
            /* [size_is][string][out] */ 
            __out_ecount_part(*pdwCch, *pdwCch)  LPWSTR pwszText,
            /* [out][in] */ 
            __inout  DWORD *pdwCch);
        
        HRESULT ( STDMETHODCALLTYPE *SetRenderFlags )( 
            IControlMarkup * This,
            /* [in] */ 
            __in  UINT uDT);
        
        HRESULT ( STDMETHODCALLTYPE *GetRenderFlags )( 
            IControlMarkup * This,
            /* [out] */ 
            __out  UINT *puDT,
            /* [out] */ 
            __out  HTHEME *phTheme,
            /* [out] */ 
            __out  int *piPartId,
            /* [out] */ 
            __out  int *piStateIdNormal,
            /* [out] */ 
            __out  int *piStateIdLink);
        
        HRESULT ( STDMETHODCALLTYPE *SetThemeRenderFlags )( 
            IControlMarkup * This,
            /* [in] */ 
            __in  UINT uDT,
            /* [in] */ 
            __in  HTHEME hTheme,
            /* [in] */ 
            __in  int iPartId,
            /* [in] */ 
            __in  int iStateIdNormal,
            /* [in] */ 
            __in  int iStateIdLink);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            IControlMarkup * This,
            /* [in] */ 
            __in  int iLink,
            /* [in] */ 
            __in  UINT uStateMask,
            /* [out] */ 
            __out  UINT *puState);
        
        HRESULT ( STDMETHODCALLTYPE *SetState )( 
            IControlMarkup * This,
            /* [in] */ 
            __in  int iLink,
            /* [in] */ 
            __in  UINT uStateMask,
            /* [in] */ 
            __in  UINT uState);
        
        HRESULT ( STDMETHODCALLTYPE *DrawText )( 
            IControlMarkup * This,
            /* [in] */ 
            __in  HDC hdcClient,
            /* [in] */ 
            __in  LPCRECT prcClient);
        
        HRESULT ( STDMETHODCALLTYPE *SetLinkCursor )( 
            IControlMarkup * This);
        
        HRESULT ( STDMETHODCALLTYPE *CalcIdealSize )( 
            IControlMarkup * This,
            /* [in] */ 
            __in  HDC hdc,
            /* [in] */ 
            __in  UINT uMarkUpCalc,
            /* [out][in] */ 
            __inout  RECT *prc);
        
        HRESULT ( STDMETHODCALLTYPE *SetFocus )( 
            IControlMarkup * This);
        
        HRESULT ( STDMETHODCALLTYPE *KillFocus )( 
            IControlMarkup * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsTabbable )( 
            IControlMarkup * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnButtonDown )( 
            IControlMarkup * This,
            /* [in] */ 
            __in  POINT pt);
        
        HRESULT ( STDMETHODCALLTYPE *OnButtonUp )( 
            IControlMarkup * This,
            /* [in] */ 
            __in  POINT pt);
        
        HRESULT ( STDMETHODCALLTYPE *OnKeyDown )( 
            IControlMarkup * This,
            /* [in] */ 
            __in  UINT uVirtKey);
        
        HRESULT ( STDMETHODCALLTYPE *HitTest )( 
            IControlMarkup * This,
            /* [in] */ 
            __in  POINT pt,
            /* [out] */ 
            __out  int *piLink);
        
        HRESULT ( STDMETHODCALLTYPE *GetLinkRect )( 
            IControlMarkup * This,
            /* [in] */ 
            __in  int iLink,
            /* [out] */ 
            __out  RECT *prc);
        
        HRESULT ( STDMETHODCALLTYPE *GetControlRect )( 
            IControlMarkup * This,
            /* [out] */ 
            __out  RECT *prcControl);
        
        HRESULT ( STDMETHODCALLTYPE *GetLinkCount )( 
            IControlMarkup * This,
            /* [out] */ 
            __out  UINT *pcLinks);
        
        END_INTERFACE
    } IControlMarkupVtbl;

    interface IControlMarkup
    {
        CONST_VTBL struct IControlMarkupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IControlMarkup_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IControlMarkup_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IControlMarkup_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IControlMarkup_SetCallback(This,punk)	\
    ( (This)->lpVtbl -> SetCallback(This,punk) ) 

#define IControlMarkup_GetCallback(This,riid,ppvUnk)	\
    ( (This)->lpVtbl -> GetCallback(This,riid,ppvUnk) ) 

#define IControlMarkup_SetId(This,dwId)	\
    ( (This)->lpVtbl -> SetId(This,dwId) ) 

#define IControlMarkup_GetId(This,pdwId)	\
    ( (This)->lpVtbl -> GetId(This,pdwId) ) 

#define IControlMarkup_SetFonts(This,hFont,hFontUnderline)	\
    ( (This)->lpVtbl -> SetFonts(This,hFont,hFontUnderline) ) 

#define IControlMarkup_GetFonts(This,phFont,phFontUnderline)	\
    ( (This)->lpVtbl -> GetFonts(This,phFont,phFontUnderline) ) 

#define IControlMarkup_SetText(This,pwszText)	\
    ( (This)->lpVtbl -> SetText(This,pwszText) ) 

#define IControlMarkup_GetText(This,bRaw,pwszText,pdwCch)	\
    ( (This)->lpVtbl -> GetText(This,bRaw,pwszText,pdwCch) ) 

#define IControlMarkup_SetLinkText(This,iLink,uMarkupLinkText,pwszText)	\
    ( (This)->lpVtbl -> SetLinkText(This,iLink,uMarkupLinkText,pwszText) ) 

#define IControlMarkup_GetLinkText(This,iLink,uMarkupLinkText,pwszText,pdwCch)	\
    ( (This)->lpVtbl -> GetLinkText(This,iLink,uMarkupLinkText,pwszText,pdwCch) ) 

#define IControlMarkup_SetRenderFlags(This,uDT)	\
    ( (This)->lpVtbl -> SetRenderFlags(This,uDT) ) 

#define IControlMarkup_GetRenderFlags(This,puDT,phTheme,piPartId,piStateIdNormal,piStateIdLink)	\
    ( (This)->lpVtbl -> GetRenderFlags(This,puDT,phTheme,piPartId,piStateIdNormal,piStateIdLink) ) 

#define IControlMarkup_SetThemeRenderFlags(This,uDT,hTheme,iPartId,iStateIdNormal,iStateIdLink)	\
    ( (This)->lpVtbl -> SetThemeRenderFlags(This,uDT,hTheme,iPartId,iStateIdNormal,iStateIdLink) ) 

#define IControlMarkup_GetState(This,iLink,uStateMask,puState)	\
    ( (This)->lpVtbl -> GetState(This,iLink,uStateMask,puState) ) 

#define IControlMarkup_SetState(This,iLink,uStateMask,uState)	\
    ( (This)->lpVtbl -> SetState(This,iLink,uStateMask,uState) ) 

#define IControlMarkup_DrawText(This,hdcClient,prcClient)	\
    ( (This)->lpVtbl -> DrawText(This,hdcClient,prcClient) ) 

#define IControlMarkup_SetLinkCursor(This)	\
    ( (This)->lpVtbl -> SetLinkCursor(This) ) 

#define IControlMarkup_CalcIdealSize(This,hdc,uMarkUpCalc,prc)	\
    ( (This)->lpVtbl -> CalcIdealSize(This,hdc,uMarkUpCalc,prc) ) 

#define IControlMarkup_SetFocus(This)	\
    ( (This)->lpVtbl -> SetFocus(This) ) 

#define IControlMarkup_KillFocus(This)	\
    ( (This)->lpVtbl -> KillFocus(This) ) 

#define IControlMarkup_IsTabbable(This)	\
    ( (This)->lpVtbl -> IsTabbable(This) ) 

#define IControlMarkup_OnButtonDown(This,pt)	\
    ( (This)->lpVtbl -> OnButtonDown(This,pt) ) 

#define IControlMarkup_OnButtonUp(This,pt)	\
    ( (This)->lpVtbl -> OnButtonUp(This,pt) ) 

#define IControlMarkup_OnKeyDown(This,uVirtKey)	\
    ( (This)->lpVtbl -> OnKeyDown(This,uVirtKey) ) 

#define IControlMarkup_HitTest(This,pt,piLink)	\
    ( (This)->lpVtbl -> HitTest(This,pt,piLink) ) 

#define IControlMarkup_GetLinkRect(This,iLink,prc)	\
    ( (This)->lpVtbl -> GetLinkRect(This,iLink,prc) ) 

#define IControlMarkup_GetControlRect(This,prcControl)	\
    ( (This)->lpVtbl -> GetControlRect(This,prcControl) ) 

#define IControlMarkup_GetLinkCount(This,pcLinks)	\
    ( (This)->lpVtbl -> GetLinkCount(This,pcLinks) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IControlMarkup_INTERFACE_DEFINED__ */


#ifndef __IInitializeNetworkFolder_INTERFACE_DEFINED__
#define __IInitializeNetworkFolder_INTERFACE_DEFINED__

/* interface IInitializeNetworkFolder */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IInitializeNetworkFolder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6e0f9881-42a8-4f2a-97f8-8af4e026d92d")
    IInitializeNetworkFolder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [unique][in] */ __RPC__in_opt PCIDLIST_ABSOLUTE pidl,
            /* [unique][in] */ __RPC__in_opt PCIDLIST_ABSOLUTE pidlTarget,
            /* [in] */ UINT uDisplayType,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszResName,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszProvider) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInitializeNetworkFolderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInitializeNetworkFolder * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInitializeNetworkFolder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInitializeNetworkFolder * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IInitializeNetworkFolder * This,
            /* [unique][in] */ __RPC__in_opt PCIDLIST_ABSOLUTE pidl,
            /* [unique][in] */ __RPC__in_opt PCIDLIST_ABSOLUTE pidlTarget,
            /* [in] */ UINT uDisplayType,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszResName,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszProvider);
        
        END_INTERFACE
    } IInitializeNetworkFolderVtbl;

    interface IInitializeNetworkFolder
    {
        CONST_VTBL struct IInitializeNetworkFolderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInitializeNetworkFolder_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInitializeNetworkFolder_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInitializeNetworkFolder_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInitializeNetworkFolder_Initialize(This,pidl,pidlTarget,uDisplayType,pszResName,pszProvider)	\
    ( (This)->lpVtbl -> Initialize(This,pidl,pidlTarget,uDisplayType,pszResName,pszProvider) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInitializeNetworkFolder_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0163 */
/* [local] */ 

typedef 
enum tagCPVIEW
    {	CPVIEW_CLASSIC	= 0,
	CPVIEW_CATEGORY	= 1
    } 	CPVIEW;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0163_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0163_v0_0_s_ifspec;

#ifndef __IOpenControlPanel_INTERFACE_DEFINED__
#define __IOpenControlPanel_INTERFACE_DEFINED__

/* interface IOpenControlPanel */
/* [uuid][object] */ 


EXTERN_C const IID IID_IOpenControlPanel;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D11AD862-66DE-4DF4-BF6C-1F5621996AF1")
    IOpenControlPanel : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszName,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszPage,
            /* [unique][in] */ __RPC__in_opt IUnknown *punkSite) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPath( 
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszName,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cchPath) LPWSTR pszPath,
            /* [in] */ UINT cchPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentView( 
            /* [out] */ __RPC__out CPVIEW *pView) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOpenControlPanelVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IOpenControlPanel * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IOpenControlPanel * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IOpenControlPanel * This);
        
        HRESULT ( STDMETHODCALLTYPE *Open )( 
            IOpenControlPanel * This,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszName,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszPage,
            /* [unique][in] */ __RPC__in_opt IUnknown *punkSite);
        
        HRESULT ( STDMETHODCALLTYPE *GetPath )( 
            IOpenControlPanel * This,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszName,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cchPath) LPWSTR pszPath,
            /* [in] */ UINT cchPath);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentView )( 
            IOpenControlPanel * This,
            /* [out] */ __RPC__out CPVIEW *pView);
        
        END_INTERFACE
    } IOpenControlPanelVtbl;

    interface IOpenControlPanel
    {
        CONST_VTBL struct IOpenControlPanelVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOpenControlPanel_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IOpenControlPanel_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IOpenControlPanel_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IOpenControlPanel_Open(This,pszName,pszPage,punkSite)	\
    ( (This)->lpVtbl -> Open(This,pszName,pszPage,punkSite) ) 

#define IOpenControlPanel_GetPath(This,pszName,pszPath,cchPath)	\
    ( (This)->lpVtbl -> GetPath(This,pszName,pszPath,cchPath) ) 

#define IOpenControlPanel_GetCurrentView(This,pView)	\
    ( (This)->lpVtbl -> GetCurrentView(This,pView) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IOpenControlPanel_INTERFACE_DEFINED__ */


#ifndef __ISystemCPLUpdate_INTERFACE_DEFINED__
#define __ISystemCPLUpdate_INTERFACE_DEFINED__

/* interface ISystemCPLUpdate */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISystemCPLUpdate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A8A71374-80C2-49e0-8805-8524EBC45B07")
    ISystemCPLUpdate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE UpdateSystemInfo( 
            /* [string][in] */ __RPC__in LPCWSTR pszDescription,
            /* [string][in] */ __RPC__in LPCWSTR pszSpeed,
            /* [string][in] */ __RPC__in LPCWSTR pszMemory,
            /* [in] */ DWORD dwNumProcessors) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateLicensingInfo( 
            /* [in] */ DWORD dwLicensingStatus,
            /* [in] */ DWORD dwGraceTimeRemainingMinutes,
            /* [in] */ DWORD dwTotalGraceTimeDays,
            /* [in] */ BOOL fIsGenuine) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateRatingsInfo( 
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszRatingsLink,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszRatingsText,
            /* [unique][in] */ __RPC__in_opt HBITMAP hRatingsImage,
            /* [in] */ USHORT uWinCRSLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateComputerInfo( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISystemCPLUpdateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISystemCPLUpdate * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISystemCPLUpdate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISystemCPLUpdate * This);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateSystemInfo )( 
            ISystemCPLUpdate * This,
            /* [string][in] */ __RPC__in LPCWSTR pszDescription,
            /* [string][in] */ __RPC__in LPCWSTR pszSpeed,
            /* [string][in] */ __RPC__in LPCWSTR pszMemory,
            /* [in] */ DWORD dwNumProcessors);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateLicensingInfo )( 
            ISystemCPLUpdate * This,
            /* [in] */ DWORD dwLicensingStatus,
            /* [in] */ DWORD dwGraceTimeRemainingMinutes,
            /* [in] */ DWORD dwTotalGraceTimeDays,
            /* [in] */ BOOL fIsGenuine);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateRatingsInfo )( 
            ISystemCPLUpdate * This,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszRatingsLink,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszRatingsText,
            /* [unique][in] */ __RPC__in_opt HBITMAP hRatingsImage,
            /* [in] */ USHORT uWinCRSLevel);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateComputerInfo )( 
            ISystemCPLUpdate * This);
        
        END_INTERFACE
    } ISystemCPLUpdateVtbl;

    interface ISystemCPLUpdate
    {
        CONST_VTBL struct ISystemCPLUpdateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISystemCPLUpdate_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISystemCPLUpdate_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISystemCPLUpdate_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISystemCPLUpdate_UpdateSystemInfo(This,pszDescription,pszSpeed,pszMemory,dwNumProcessors)	\
    ( (This)->lpVtbl -> UpdateSystemInfo(This,pszDescription,pszSpeed,pszMemory,dwNumProcessors) ) 

#define ISystemCPLUpdate_UpdateLicensingInfo(This,dwLicensingStatus,dwGraceTimeRemainingMinutes,dwTotalGraceTimeDays,fIsGenuine)	\
    ( (This)->lpVtbl -> UpdateLicensingInfo(This,dwLicensingStatus,dwGraceTimeRemainingMinutes,dwTotalGraceTimeDays,fIsGenuine) ) 

#define ISystemCPLUpdate_UpdateRatingsInfo(This,pszRatingsLink,pszRatingsText,hRatingsImage,uWinCRSLevel)	\
    ( (This)->lpVtbl -> UpdateRatingsInfo(This,pszRatingsLink,pszRatingsText,hRatingsImage,uWinCRSLevel) ) 

#define ISystemCPLUpdate_UpdateComputerInfo(This)	\
    ( (This)->lpVtbl -> UpdateComputerInfo(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISystemCPLUpdate_INTERFACE_DEFINED__ */


#ifndef __IComputerInfoAdvise_INTERFACE_DEFINED__
#define __IComputerInfoAdvise_INTERFACE_DEFINED__

/* interface IComputerInfoAdvise */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IComputerInfoAdvise;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4623BD61-5603-444f-824A-AAEBCEED93FA")
    IComputerInfoAdvise : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Advise( 
            /* [in] */ __RPC__in_opt ISystemCPLUpdate *pUpdate,
            /* [out] */ __RPC__out DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unadvise( 
            /* [in] */ DWORD dwCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComputerInfoAdviseVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComputerInfoAdvise * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComputerInfoAdvise * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComputerInfoAdvise * This);
        
        HRESULT ( STDMETHODCALLTYPE *Advise )( 
            IComputerInfoAdvise * This,
            /* [in] */ __RPC__in_opt ISystemCPLUpdate *pUpdate,
            /* [out] */ __RPC__out DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *Unadvise )( 
            IComputerInfoAdvise * This,
            /* [in] */ DWORD dwCookie);
        
        END_INTERFACE
    } IComputerInfoAdviseVtbl;

    interface IComputerInfoAdvise
    {
        CONST_VTBL struct IComputerInfoAdviseVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComputerInfoAdvise_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IComputerInfoAdvise_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IComputerInfoAdvise_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IComputerInfoAdvise_Advise(This,pUpdate,pdwCookie)	\
    ( (This)->lpVtbl -> Advise(This,pUpdate,pdwCookie) ) 

#define IComputerInfoAdvise_Unadvise(This,dwCookie)	\
    ( (This)->lpVtbl -> Unadvise(This,dwCookie) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IComputerInfoAdvise_INTERFACE_DEFINED__ */


#ifndef __IComputerInfoChangeNotify_INTERFACE_DEFINED__
#define __IComputerInfoChangeNotify_INTERFACE_DEFINED__

/* interface IComputerInfoChangeNotify */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IComputerInfoChangeNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0DF60D92-6818-46d6-B358-D66170DDE466")
    IComputerInfoChangeNotify : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ComputerInfoChanged( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComputerInfoChangeNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComputerInfoChangeNotify * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComputerInfoChangeNotify * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComputerInfoChangeNotify * This);
        
        HRESULT ( STDMETHODCALLTYPE *ComputerInfoChanged )( 
            IComputerInfoChangeNotify * This);
        
        END_INTERFACE
    } IComputerInfoChangeNotifyVtbl;

    interface IComputerInfoChangeNotify
    {
        CONST_VTBL struct IComputerInfoChangeNotifyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComputerInfoChangeNotify_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IComputerInfoChangeNotify_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IComputerInfoChangeNotify_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IComputerInfoChangeNotify_ComputerInfoChanged(This)	\
    ( (This)->lpVtbl -> ComputerInfoChanged(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IComputerInfoChangeNotify_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0167 */
/* [local] */ 

#define STR_FILE_SYS_BIND_DATA      L"File System Bind Data"


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0167_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0167_v0_0_s_ifspec;

#ifndef __IFileSystemBindData_INTERFACE_DEFINED__
#define __IFileSystemBindData_INTERFACE_DEFINED__

/* interface IFileSystemBindData */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IFileSystemBindData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("01E18D10-4D8B-11d2-855D-006008059367")
    IFileSystemBindData : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFindData( 
            /* [in] */ const WIN32_FIND_DATAW *pfd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFindData( 
            /* [out] */ WIN32_FIND_DATAW *pfd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFileSystemBindDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFileSystemBindData * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFileSystemBindData * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFileSystemBindData * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFindData )( 
            IFileSystemBindData * This,
            /* [in] */ const WIN32_FIND_DATAW *pfd);
        
        HRESULT ( STDMETHODCALLTYPE *GetFindData )( 
            IFileSystemBindData * This,
            /* [out] */ WIN32_FIND_DATAW *pfd);
        
        END_INTERFACE
    } IFileSystemBindDataVtbl;

    interface IFileSystemBindData
    {
        CONST_VTBL struct IFileSystemBindDataVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFileSystemBindData_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFileSystemBindData_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFileSystemBindData_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFileSystemBindData_SetFindData(This,pfd)	\
    ( (This)->lpVtbl -> SetFindData(This,pfd) ) 

#define IFileSystemBindData_GetFindData(This,pfd)	\
    ( (This)->lpVtbl -> GetFindData(This,pfd) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFileSystemBindData_INTERFACE_DEFINED__ */


#ifndef __IFileSystemBindData2_INTERFACE_DEFINED__
#define __IFileSystemBindData2_INTERFACE_DEFINED__

/* interface IFileSystemBindData2 */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IFileSystemBindData2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3acf075f-71db-4afa-81f0-3fc4fdf2a5b8")
    IFileSystemBindData2 : public IFileSystemBindData
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFileID( 
            /* [in] */ LARGE_INTEGER liFileID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFileID( 
            /* [out] */ LARGE_INTEGER *pliFileID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetJunctionCLSID( 
            /* [in] */ REFCLSID clsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetJunctionCLSID( 
            /* [out] */ CLSID *pclsid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFileSystemBindData2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFileSystemBindData2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFileSystemBindData2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFileSystemBindData2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFindData )( 
            IFileSystemBindData2 * This,
            /* [in] */ const WIN32_FIND_DATAW *pfd);
        
        HRESULT ( STDMETHODCALLTYPE *GetFindData )( 
            IFileSystemBindData2 * This,
            /* [out] */ WIN32_FIND_DATAW *pfd);
        
        HRESULT ( STDMETHODCALLTYPE *SetFileID )( 
            IFileSystemBindData2 * This,
            /* [in] */ LARGE_INTEGER liFileID);
        
        HRESULT ( STDMETHODCALLTYPE *GetFileID )( 
            IFileSystemBindData2 * This,
            /* [out] */ LARGE_INTEGER *pliFileID);
        
        HRESULT ( STDMETHODCALLTYPE *SetJunctionCLSID )( 
            IFileSystemBindData2 * This,
            /* [in] */ REFCLSID clsid);
        
        HRESULT ( STDMETHODCALLTYPE *GetJunctionCLSID )( 
            IFileSystemBindData2 * This,
            /* [out] */ CLSID *pclsid);
        
        END_INTERFACE
    } IFileSystemBindData2Vtbl;

    interface IFileSystemBindData2
    {
        CONST_VTBL struct IFileSystemBindData2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFileSystemBindData2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFileSystemBindData2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFileSystemBindData2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFileSystemBindData2_SetFindData(This,pfd)	\
    ( (This)->lpVtbl -> SetFindData(This,pfd) ) 

#define IFileSystemBindData2_GetFindData(This,pfd)	\
    ( (This)->lpVtbl -> GetFindData(This,pfd) ) 


#define IFileSystemBindData2_SetFileID(This,liFileID)	\
    ( (This)->lpVtbl -> SetFileID(This,liFileID) ) 

#define IFileSystemBindData2_GetFileID(This,pliFileID)	\
    ( (This)->lpVtbl -> GetFileID(This,pliFileID) ) 

#define IFileSystemBindData2_SetJunctionCLSID(This,clsid)	\
    ( (This)->lpVtbl -> SetJunctionCLSID(This,clsid) ) 

#define IFileSystemBindData2_GetJunctionCLSID(This,pclsid)	\
    ( (This)->lpVtbl -> GetJunctionCLSID(This,pclsid) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFileSystemBindData2_INTERFACE_DEFINED__ */



#ifndef __ShellObjects_LIBRARY_DEFINED__
#define __ShellObjects_LIBRARY_DEFINED__

/* library ShellObjects */
/* [version][lcid][helpstring][uuid] */ 

#define SID_PublishingWizard CLSID_PublishingWizard

EXTERN_C const IID LIBID_ShellObjects;

EXTERN_C const CLSID CLSID_ShellDesktop;

#ifdef __cplusplus

class DECLSPEC_UUID("00021400-0000-0000-C000-000000000046")
ShellDesktop;
#endif

EXTERN_C const CLSID CLSID_ShellFSFolder;

#ifdef __cplusplus

class DECLSPEC_UUID("F3364BA0-65B9-11CE-A9BA-00AA004AE837")
ShellFSFolder;
#endif

EXTERN_C const CLSID CLSID_NetworkPlaces;

#ifdef __cplusplus

class DECLSPEC_UUID("208D2C60-3AEA-1069-A2D7-08002B30309D")
NetworkPlaces;
#endif

EXTERN_C const CLSID CLSID_ShellLink;

#ifdef __cplusplus

class DECLSPEC_UUID("00021401-0000-0000-C000-000000000046")
ShellLink;
#endif

EXTERN_C const CLSID CLSID_QueryCancelAutoPlay;

#ifdef __cplusplus

class DECLSPEC_UUID("331F1768-05A9-4ddd-B86E-DAE34DDC998A")
QueryCancelAutoPlay;
#endif

EXTERN_C const CLSID CLSID_DriveSizeCategorizer;

#ifdef __cplusplus

class DECLSPEC_UUID("94357B53-CA29-4b78-83AE-E8FE7409134F")
DriveSizeCategorizer;
#endif

EXTERN_C const CLSID CLSID_DriveTypeCategorizer;

#ifdef __cplusplus

class DECLSPEC_UUID("B0A8F3CF-4333-4bab-8873-1CCB1CADA48B")
DriveTypeCategorizer;
#endif

EXTERN_C const CLSID CLSID_FreeSpaceCategorizer;

#ifdef __cplusplus

class DECLSPEC_UUID("B5607793-24AC-44c7-82E2-831726AA6CB7")
FreeSpaceCategorizer;
#endif

EXTERN_C const CLSID CLSID_TimeCategorizer;

#ifdef __cplusplus

class DECLSPEC_UUID("3bb4118f-ddfd-4d30-a348-9fb5d6bf1afe")
TimeCategorizer;
#endif

EXTERN_C const CLSID CLSID_SizeCategorizer;

#ifdef __cplusplus

class DECLSPEC_UUID("55d7b852-f6d1-42f2-aa75-8728a1b2d264")
SizeCategorizer;
#endif

EXTERN_C const CLSID CLSID_AlphabeticalCategorizer;

#ifdef __cplusplus

class DECLSPEC_UUID("3c2654c6-7372-4f6b-b310-55d6128f49d2")
AlphabeticalCategorizer;
#endif

EXTERN_C const CLSID CLSID_MergedCategorizer;

#ifdef __cplusplus

class DECLSPEC_UUID("8e827c11-33e7-4bc1-b242-8cd9a1c2b304")
MergedCategorizer;
#endif

EXTERN_C const CLSID CLSID_ImageProperties;

#ifdef __cplusplus

class DECLSPEC_UUID("7ab770c7-0e23-4d7a-8aa2-19bfad479829")
ImageProperties;
#endif

EXTERN_C const CLSID CLSID_PropertiesUI;

#ifdef __cplusplus

class DECLSPEC_UUID("d912f8cf-0396-4915-884e-fb425d32943b")
PropertiesUI;
#endif

EXTERN_C const CLSID CLSID_UserNotification;

#ifdef __cplusplus

class DECLSPEC_UUID("0010890e-8789-413c-adbc-48f5b511b3af")
UserNotification;
#endif

EXTERN_C const CLSID CLSID_CDBurn;

#ifdef __cplusplus

class DECLSPEC_UUID("fbeb8a05-beee-4442-804e-409d6c4515e9")
CDBurn;
#endif

EXTERN_C const CLSID CLSID_TaskbarList;

#ifdef __cplusplus

class DECLSPEC_UUID("56FDF344-FD6D-11d0-958A-006097C9A090")
TaskbarList;
#endif

EXTERN_C const CLSID CLSID_StartMenuPin;

#ifdef __cplusplus

class DECLSPEC_UUID("a2a9545d-a0c2-42b4-9708-a0b2badd77c8")
StartMenuPin;
#endif

EXTERN_C const CLSID CLSID_WebWizardHost;

#ifdef __cplusplus

class DECLSPEC_UUID("c827f149-55c1-4d28-935e-57e47caed973")
WebWizardHost;
#endif

EXTERN_C const CLSID CLSID_PublishDropTarget;

#ifdef __cplusplus

class DECLSPEC_UUID("CC6EEFFB-43F6-46c5-9619-51D571967F7D")
PublishDropTarget;
#endif

EXTERN_C const CLSID CLSID_PublishingWizard;

#ifdef __cplusplus

class DECLSPEC_UUID("6b33163c-76a5-4b6c-bf21-45de9cd503a1")
PublishingWizard;
#endif

EXTERN_C const CLSID CLSID_InternetPrintOrdering;

#ifdef __cplusplus

class DECLSPEC_UUID("add36aa8-751a-4579-a266-d66f5202ccbb")
InternetPrintOrdering;
#endif

EXTERN_C const CLSID CLSID_FolderViewHost;

#ifdef __cplusplus

class DECLSPEC_UUID("20b1cb23-6968-4eb9-b7d4-a66d00d07cee")
FolderViewHost;
#endif

EXTERN_C const CLSID CLSID_ExplorerBrowser;

#ifdef __cplusplus

class DECLSPEC_UUID("71f96385-ddd6-48d3-a0c1-ae06e8b055fb")
ExplorerBrowser;
#endif

EXTERN_C const CLSID CLSID_ImageRecompress;

#ifdef __cplusplus

class DECLSPEC_UUID("6e33091c-d2f8-4740-b55e-2e11d1477a2c")
ImageRecompress;
#endif

EXTERN_C const CLSID CLSID_TrayBandSiteService;

#ifdef __cplusplus

class DECLSPEC_UUID("F60AD0A0-E5E1-45cb-B51A-E15B9F8B2934")
TrayBandSiteService;
#endif

EXTERN_C const CLSID CLSID_TrayDeskBand;

#ifdef __cplusplus

class DECLSPEC_UUID("E6442437-6C68-4f52-94DD-2CFED267EFB9")
TrayDeskBand;
#endif

EXTERN_C const CLSID CLSID_AttachmentServices;

#ifdef __cplusplus

class DECLSPEC_UUID("4125dd96-e03a-4103-8f70-e0597d803b9c")
AttachmentServices;
#endif

EXTERN_C const CLSID CLSID_DocPropShellExtension;

#ifdef __cplusplus

class DECLSPEC_UUID("883373C3-BF89-11D1-BE35-080036B11A03")
DocPropShellExtension;
#endif

EXTERN_C const CLSID CLSID_ShellItem;

#ifdef __cplusplus

class DECLSPEC_UUID("9ac9fbe1-e0a2-4ad6-b4ee-e212013ea917")
ShellItem;
#endif

EXTERN_C const CLSID CLSID_NamespaceWalker;

#ifdef __cplusplus

class DECLSPEC_UUID("72eb61e0-8672-4303-9175-f2e4c68b2e7c")
NamespaceWalker;
#endif

EXTERN_C const CLSID CLSID_FileOperation;

#ifdef __cplusplus

class DECLSPEC_UUID("3ad05575-8857-4850-9277-11b85bdb8e09")
FileOperation;
#endif

EXTERN_C const CLSID CLSID_FileOpenDialog;

#ifdef __cplusplus

class DECLSPEC_UUID("DC1C5A9C-E88A-4dde-A5A1-60F82A20AEF7")
FileOpenDialog;
#endif

EXTERN_C const CLSID CLSID_FileSaveDialog;

#ifdef __cplusplus

class DECLSPEC_UUID("C0B4E2F3-BA21-4773-8DBA-335EC946EB8B")
FileSaveDialog;
#endif

EXTERN_C const CLSID CLSID_KnownFolderManager;

#ifdef __cplusplus

class DECLSPEC_UUID("4df0c730-df9d-4ae3-9153-aa6b82e9795a")
KnownFolderManager;
#endif

EXTERN_C const CLSID CLSID_FSCopyHandler;

#ifdef __cplusplus

class DECLSPEC_UUID("D197380A-0A79-4dc8-A033-ED882C2FA14B")
FSCopyHandler;
#endif

EXTERN_C const CLSID CLSID_SharingConfigurationManager;

#ifdef __cplusplus

class DECLSPEC_UUID("49F371E1-8C5C-4d9c-9A3B-54A6827F513C")
SharingConfigurationManager;
#endif

EXTERN_C const CLSID CLSID_PreviousVersions;

#ifdef __cplusplus

class DECLSPEC_UUID("596AB062-B4D2-4215-9F74-E9109B0A8153")
PreviousVersions;
#endif

EXTERN_C const CLSID CLSID_NetworkConnections;

#ifdef __cplusplus

class DECLSPEC_UUID("7007ACC7-3202-11D1-AAD2-00805FC1270E")
NetworkConnections;
#endif

EXTERN_C const CLSID CLSID_NamespaceTreeControl;

#ifdef __cplusplus

class DECLSPEC_UUID("AE054212-3535-4430-83ED-D501AA6680E6")
NamespaceTreeControl;
#endif

EXTERN_C const CLSID CLSID_IENamespaceTreeControl;

#ifdef __cplusplus

class DECLSPEC_UUID("ACE52D03-E5CD-4b20-82FF-E71B11BEAE1D")
IENamespaceTreeControl;
#endif

EXTERN_C const CLSID CLSID_ScheduledTasks;

#ifdef __cplusplus

class DECLSPEC_UUID("D6277990-4C6A-11CF-8D87-00AA0060F5BF")
ScheduledTasks;
#endif

EXTERN_C const CLSID CLSID_ApplicationAssociationRegistration;

#ifdef __cplusplus

class DECLSPEC_UUID("591209c7-767b-42b2-9fba-44ee4615f2c7")
ApplicationAssociationRegistration;
#endif

EXTERN_C const CLSID CLSID_ApplicationAssociationRegistrationUI;

#ifdef __cplusplus

class DECLSPEC_UUID("1968106d-f3b5-44cf-890e-116fcb9ecef1")
ApplicationAssociationRegistrationUI;
#endif

EXTERN_C const CLSID CLSID_SearchFolderItemFactory;

#ifdef __cplusplus

class DECLSPEC_UUID("14010e02-bbbd-41f0-88e3-eda371216584")
SearchFolderItemFactory;
#endif

EXTERN_C const CLSID CLSID_OpenControlPanel;

#ifdef __cplusplus

class DECLSPEC_UUID("06622D85-6856-4460-8DE1-A81921B41C4B")
OpenControlPanel;
#endif

EXTERN_C const CLSID CLSID_ComputerInfoAdvise;

#ifdef __cplusplus

class DECLSPEC_UUID("00A77FF7-A514-493e-B721-CDF8CB0F5B59")
ComputerInfoAdvise;
#endif

EXTERN_C const CLSID CLSID_NetworkExplorerFolder;

#ifdef __cplusplus

class DECLSPEC_UUID("F02C1A0D-BE21-4350-88B0-7367FC96EF3C")
NetworkExplorerFolder;
#endif
#endif /* __ShellObjects_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_shobjidl_0000_0169 */
/* [local] */ 

#if (NTDDI_VERSION >= NTDDI_VISTA)
SHSTDAPI SHGetTemporaryPropertyForItem(__in IShellItem *psi, __in REFPROPERTYKEY propkey, __out PROPVARIANT *ppropvar);
SHSTDAPI SHSetTemporaryPropertyForItem(__in IShellItem *psi, __in REFPROPERTYKEY propkey, __in REFPROPVARIANT propvar);
#endif  // NTDDI_VISTA
#if (NTDDI_VERSION >= NTDDI_VISTA)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0169_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0169_v0_0_s_ifspec;

#ifndef __IAssocHandlerInvoker_INTERFACE_DEFINED__
#define __IAssocHandlerInvoker_INTERFACE_DEFINED__

/* interface IAssocHandlerInvoker */
/* [local][unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IAssocHandlerInvoker;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("92218CAB-ECAA-4335-8133-807FD234C2EE")
    IAssocHandlerInvoker : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SupportsSelection( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Invoke( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssocHandlerInvokerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssocHandlerInvoker * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssocHandlerInvoker * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssocHandlerInvoker * This);
        
        HRESULT ( STDMETHODCALLTYPE *SupportsSelection )( 
            IAssocHandlerInvoker * This);
        
        HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAssocHandlerInvoker * This);
        
        END_INTERFACE
    } IAssocHandlerInvokerVtbl;

    interface IAssocHandlerInvoker
    {
        CONST_VTBL struct IAssocHandlerInvokerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssocHandlerInvoker_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAssocHandlerInvoker_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAssocHandlerInvoker_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAssocHandlerInvoker_SupportsSelection(This)	\
    ( (This)->lpVtbl -> SupportsSelection(This) ) 

#define IAssocHandlerInvoker_Invoke(This)	\
    ( (This)->lpVtbl -> Invoke(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAssocHandlerInvoker_INTERFACE_DEFINED__ */


#ifndef __IAssocHandler_INTERFACE_DEFINED__
#define __IAssocHandler_INTERFACE_DEFINED__

/* interface IAssocHandler */
/* [local][unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IAssocHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F04061AC-1659-4a3f-A954-775AA57FC083")
    IAssocHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out][string] */ 
            __deref_out  LPWSTR *ppsz) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUIName( 
            /* [out][string] */ 
            __deref_out  LPWSTR *ppsz) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIconLocation( 
            /* [out][string] */ 
            __deref_out  LPWSTR *ppszPath,
            /* [out] */ 
            __out  int *pIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsRecommended( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MakeDefault( 
            /* [string][in] */ 
            __in  LPCWSTR pszDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Invoke( 
            /* [in] */ 
            __in  IDataObject *pdo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateInvoker( 
            /* [in] */ 
            __in  IDataObject *pdo,
            /* [out] */ 
            __deref_out  IAssocHandlerInvoker **ppInvoker) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssocHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssocHandler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssocHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssocHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IAssocHandler * This,
            /* [out][string] */ 
            __deref_out  LPWSTR *ppsz);
        
        HRESULT ( STDMETHODCALLTYPE *GetUIName )( 
            IAssocHandler * This,
            /* [out][string] */ 
            __deref_out  LPWSTR *ppsz);
        
        HRESULT ( STDMETHODCALLTYPE *GetIconLocation )( 
            IAssocHandler * This,
            /* [out][string] */ 
            __deref_out  LPWSTR *ppszPath,
            /* [out] */ 
            __out  int *pIndex);
        
        HRESULT ( STDMETHODCALLTYPE *IsRecommended )( 
            IAssocHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *MakeDefault )( 
            IAssocHandler * This,
            /* [string][in] */ 
            __in  LPCWSTR pszDescription);
        
        HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAssocHandler * This,
            /* [in] */ 
            __in  IDataObject *pdo);
        
        HRESULT ( STDMETHODCALLTYPE *CreateInvoker )( 
            IAssocHandler * This,
            /* [in] */ 
            __in  IDataObject *pdo,
            /* [out] */ 
            __deref_out  IAssocHandlerInvoker **ppInvoker);
        
        END_INTERFACE
    } IAssocHandlerVtbl;

    interface IAssocHandler
    {
        CONST_VTBL struct IAssocHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssocHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAssocHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAssocHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAssocHandler_GetName(This,ppsz)	\
    ( (This)->lpVtbl -> GetName(This,ppsz) ) 

#define IAssocHandler_GetUIName(This,ppsz)	\
    ( (This)->lpVtbl -> GetUIName(This,ppsz) ) 

#define IAssocHandler_GetIconLocation(This,ppszPath,pIndex)	\
    ( (This)->lpVtbl -> GetIconLocation(This,ppszPath,pIndex) ) 

#define IAssocHandler_IsRecommended(This)	\
    ( (This)->lpVtbl -> IsRecommended(This) ) 

#define IAssocHandler_MakeDefault(This,pszDescription)	\
    ( (This)->lpVtbl -> MakeDefault(This,pszDescription) ) 

#define IAssocHandler_Invoke(This,pdo)	\
    ( (This)->lpVtbl -> Invoke(This,pdo) ) 

#define IAssocHandler_CreateInvoker(This,pdo,ppInvoker)	\
    ( (This)->lpVtbl -> CreateInvoker(This,pdo,ppInvoker) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAssocHandler_INTERFACE_DEFINED__ */


#ifndef __IEnumAssocHandlers_INTERFACE_DEFINED__
#define __IEnumAssocHandlers_INTERFACE_DEFINED__

/* interface IEnumAssocHandlers */
/* [local][unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IEnumAssocHandlers;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("973810ae-9599-4b88-9e4d-6ee98c9552da")
    IEnumAssocHandlers : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ 
            __in  ULONG celt,
            /* [length_is][size_is][out] */ 
            __out_ecount_part(celt, *pceltFetched)  IAssocHandler **rgelt,
            /* [out] */ 
            __out_opt  ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumAssocHandlersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumAssocHandlers * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumAssocHandlers * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumAssocHandlers * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumAssocHandlers * This,
            /* [in] */ 
            __in  ULONG celt,
            /* [length_is][size_is][out] */ 
            __out_ecount_part(celt, *pceltFetched)  IAssocHandler **rgelt,
            /* [out] */ 
            __out_opt  ULONG *pceltFetched);
        
        END_INTERFACE
    } IEnumAssocHandlersVtbl;

    interface IEnumAssocHandlers
    {
        CONST_VTBL struct IEnumAssocHandlersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumAssocHandlers_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumAssocHandlers_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumAssocHandlers_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumAssocHandlers_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumAssocHandlers_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0172 */
/* [local] */ 


enum tagASSOC_FILTER
    {	ASSOC_FILTER_NONE	= 0,
	ASSOC_FILTER_RECOMMENDED	= 0x1
    } ;
typedef int ASSOC_FILTER;

SHSTDAPI SHAssocEnumHandlers(LPCWSTR pszExtra, ASSOC_FILTER afFilter, __deref_out IEnumAssocHandlers **ppEnumHandler);
#endif  // NTDDI_VISTA

extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0172_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0172_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  HACCEL_UserSize(     unsigned long *, unsigned long            , HACCEL * ); 
unsigned char * __RPC_USER  HACCEL_UserMarshal(  unsigned long *, unsigned char *, HACCEL * ); 
unsigned char * __RPC_USER  HACCEL_UserUnmarshal(unsigned long *, unsigned char *, HACCEL * ); 
void                      __RPC_USER  HACCEL_UserFree(     unsigned long *, HACCEL * ); 

unsigned long             __RPC_USER  HBITMAP_UserSize(     unsigned long *, unsigned long            , HBITMAP * ); 
unsigned char * __RPC_USER  HBITMAP_UserMarshal(  unsigned long *, unsigned char *, HBITMAP * ); 
unsigned char * __RPC_USER  HBITMAP_UserUnmarshal(unsigned long *, unsigned char *, HBITMAP * ); 
void                      __RPC_USER  HBITMAP_UserFree(     unsigned long *, HBITMAP * ); 

unsigned long             __RPC_USER  HGLOBAL_UserSize(     unsigned long *, unsigned long            , HGLOBAL * ); 
unsigned char * __RPC_USER  HGLOBAL_UserMarshal(  unsigned long *, unsigned char *, HGLOBAL * ); 
unsigned char * __RPC_USER  HGLOBAL_UserUnmarshal(unsigned long *, unsigned char *, HGLOBAL * ); 
void                      __RPC_USER  HGLOBAL_UserFree(     unsigned long *, HGLOBAL * ); 

unsigned long             __RPC_USER  HICON_UserSize(     unsigned long *, unsigned long            , HICON * ); 
unsigned char * __RPC_USER  HICON_UserMarshal(  unsigned long *, unsigned char *, HICON * ); 
unsigned char * __RPC_USER  HICON_UserUnmarshal(unsigned long *, unsigned char *, HICON * ); 
void                      __RPC_USER  HICON_UserFree(     unsigned long *, HICON * ); 

unsigned long             __RPC_USER  HMENU_UserSize(     unsigned long *, unsigned long            , HMENU * ); 
unsigned char * __RPC_USER  HMENU_UserMarshal(  unsigned long *, unsigned char *, HMENU * ); 
unsigned char * __RPC_USER  HMENU_UserUnmarshal(unsigned long *, unsigned char *, HMENU * ); 
void                      __RPC_USER  HMENU_UserFree(     unsigned long *, HMENU * ); 

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 

unsigned long             __RPC_USER  PCIDLIST_ABSOLUTE_UserSize(     unsigned long *, unsigned long            , PCIDLIST_ABSOLUTE * ); 
unsigned char * __RPC_USER  PCIDLIST_ABSOLUTE_UserMarshal(  unsigned long *, unsigned char *, PCIDLIST_ABSOLUTE * ); 
unsigned char * __RPC_USER  PCIDLIST_ABSOLUTE_UserUnmarshal(unsigned long *, unsigned char *, PCIDLIST_ABSOLUTE * ); 
void                      __RPC_USER  PCIDLIST_ABSOLUTE_UserFree(     unsigned long *, PCIDLIST_ABSOLUTE * ); 

unsigned long             __RPC_USER  PCUIDLIST_RELATIVE_UserSize(     unsigned long *, unsigned long            , PCUIDLIST_RELATIVE * ); 
unsigned char * __RPC_USER  PCUIDLIST_RELATIVE_UserMarshal(  unsigned long *, unsigned char *, PCUIDLIST_RELATIVE * ); 
unsigned char * __RPC_USER  PCUIDLIST_RELATIVE_UserUnmarshal(unsigned long *, unsigned char *, PCUIDLIST_RELATIVE * ); 
void                      __RPC_USER  PCUIDLIST_RELATIVE_UserFree(     unsigned long *, PCUIDLIST_RELATIVE * ); 

unsigned long             __RPC_USER  PCUITEMID_CHILD_UserSize(     unsigned long *, unsigned long            , PCUITEMID_CHILD * ); 
unsigned char * __RPC_USER  PCUITEMID_CHILD_UserMarshal(  unsigned long *, unsigned char *, PCUITEMID_CHILD * ); 
unsigned char * __RPC_USER  PCUITEMID_CHILD_UserUnmarshal(unsigned long *, unsigned char *, PCUITEMID_CHILD * ); 
void                      __RPC_USER  PCUITEMID_CHILD_UserFree(     unsigned long *, PCUITEMID_CHILD * ); 

unsigned long             __RPC_USER  PIDLIST_ABSOLUTE_UserSize(     unsigned long *, unsigned long            , PIDLIST_ABSOLUTE * ); 
unsigned char * __RPC_USER  PIDLIST_ABSOLUTE_UserMarshal(  unsigned long *, unsigned char *, PIDLIST_ABSOLUTE * ); 
unsigned char * __RPC_USER  PIDLIST_ABSOLUTE_UserUnmarshal(unsigned long *, unsigned char *, PIDLIST_ABSOLUTE * ); 
void                      __RPC_USER  PIDLIST_ABSOLUTE_UserFree(     unsigned long *, PIDLIST_ABSOLUTE * ); 

unsigned long             __RPC_USER  PIDLIST_RELATIVE_UserSize(     unsigned long *, unsigned long            , PIDLIST_RELATIVE * ); 
unsigned char * __RPC_USER  PIDLIST_RELATIVE_UserMarshal(  unsigned long *, unsigned char *, PIDLIST_RELATIVE * ); 
unsigned char * __RPC_USER  PIDLIST_RELATIVE_UserUnmarshal(unsigned long *, unsigned char *, PIDLIST_RELATIVE * ); 
void                      __RPC_USER  PIDLIST_RELATIVE_UserFree(     unsigned long *, PIDLIST_RELATIVE * ); 

unsigned long             __RPC_USER  PITEMID_CHILD_UserSize(     unsigned long *, unsigned long            , PITEMID_CHILD * ); 
unsigned char * __RPC_USER  PITEMID_CHILD_UserMarshal(  unsigned long *, unsigned char *, PITEMID_CHILD * ); 
unsigned char * __RPC_USER  PITEMID_CHILD_UserUnmarshal(unsigned long *, unsigned char *, PITEMID_CHILD * ); 
void                      __RPC_USER  PITEMID_CHILD_UserFree(     unsigned long *, PITEMID_CHILD * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  HACCEL_UserSize64(     unsigned long *, unsigned long            , HACCEL * ); 
unsigned char * __RPC_USER  HACCEL_UserMarshal64(  unsigned long *, unsigned char *, HACCEL * ); 
unsigned char * __RPC_USER  HACCEL_UserUnmarshal64(unsigned long *, unsigned char *, HACCEL * ); 
void                      __RPC_USER  HACCEL_UserFree64(     unsigned long *, HACCEL * ); 

unsigned long             __RPC_USER  HBITMAP_UserSize64(     unsigned long *, unsigned long            , HBITMAP * ); 
unsigned char * __RPC_USER  HBITMAP_UserMarshal64(  unsigned long *, unsigned char *, HBITMAP * ); 
unsigned char * __RPC_USER  HBITMAP_UserUnmarshal64(unsigned long *, unsigned char *, HBITMAP * ); 
void                      __RPC_USER  HBITMAP_UserFree64(     unsigned long *, HBITMAP * ); 

unsigned long             __RPC_USER  HGLOBAL_UserSize64(     unsigned long *, unsigned long            , HGLOBAL * ); 
unsigned char * __RPC_USER  HGLOBAL_UserMarshal64(  unsigned long *, unsigned char *, HGLOBAL * ); 
unsigned char * __RPC_USER  HGLOBAL_UserUnmarshal64(unsigned long *, unsigned char *, HGLOBAL * ); 
void                      __RPC_USER  HGLOBAL_UserFree64(     unsigned long *, HGLOBAL * ); 

unsigned long             __RPC_USER  HICON_UserSize64(     unsigned long *, unsigned long            , HICON * ); 
unsigned char * __RPC_USER  HICON_UserMarshal64(  unsigned long *, unsigned char *, HICON * ); 
unsigned char * __RPC_USER  HICON_UserUnmarshal64(unsigned long *, unsigned char *, HICON * ); 
void                      __RPC_USER  HICON_UserFree64(     unsigned long *, HICON * ); 

unsigned long             __RPC_USER  HMENU_UserSize64(     unsigned long *, unsigned long            , HMENU * ); 
unsigned char * __RPC_USER  HMENU_UserMarshal64(  unsigned long *, unsigned char *, HMENU * ); 
unsigned char * __RPC_USER  HMENU_UserUnmarshal64(unsigned long *, unsigned char *, HMENU * ); 
void                      __RPC_USER  HMENU_UserFree64(     unsigned long *, HMENU * ); 

unsigned long             __RPC_USER  HWND_UserSize64(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal64(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal64(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree64(     unsigned long *, HWND * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize64(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal64(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal64(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree64(     unsigned long *, LPSAFEARRAY * ); 

unsigned long             __RPC_USER  PCIDLIST_ABSOLUTE_UserSize64(     unsigned long *, unsigned long            , PCIDLIST_ABSOLUTE * ); 
unsigned char * __RPC_USER  PCIDLIST_ABSOLUTE_UserMarshal64(  unsigned long *, unsigned char *, PCIDLIST_ABSOLUTE * ); 
unsigned char * __RPC_USER  PCIDLIST_ABSOLUTE_UserUnmarshal64(unsigned long *, unsigned char *, PCIDLIST_ABSOLUTE * ); 
void                      __RPC_USER  PCIDLIST_ABSOLUTE_UserFree64(     unsigned long *, PCIDLIST_ABSOLUTE * ); 

unsigned long             __RPC_USER  PCUIDLIST_RELATIVE_UserSize64(     unsigned long *, unsigned long            , PCUIDLIST_RELATIVE * ); 
unsigned char * __RPC_USER  PCUIDLIST_RELATIVE_UserMarshal64(  unsigned long *, unsigned char *, PCUIDLIST_RELATIVE * ); 
unsigned char * __RPC_USER  PCUIDLIST_RELATIVE_UserUnmarshal64(unsigned long *, unsigned char *, PCUIDLIST_RELATIVE * ); 
void                      __RPC_USER  PCUIDLIST_RELATIVE_UserFree64(     unsigned long *, PCUIDLIST_RELATIVE * ); 

unsigned long             __RPC_USER  PCUITEMID_CHILD_UserSize64(     unsigned long *, unsigned long            , PCUITEMID_CHILD * ); 
unsigned char * __RPC_USER  PCUITEMID_CHILD_UserMarshal64(  unsigned long *, unsigned char *, PCUITEMID_CHILD * ); 
unsigned char * __RPC_USER  PCUITEMID_CHILD_UserUnmarshal64(unsigned long *, unsigned char *, PCUITEMID_CHILD * ); 
void                      __RPC_USER  PCUITEMID_CHILD_UserFree64(     unsigned long *, PCUITEMID_CHILD * ); 

unsigned long             __RPC_USER  PIDLIST_ABSOLUTE_UserSize64(     unsigned long *, unsigned long            , PIDLIST_ABSOLUTE * ); 
unsigned char * __RPC_USER  PIDLIST_ABSOLUTE_UserMarshal64(  unsigned long *, unsigned char *, PIDLIST_ABSOLUTE * ); 
unsigned char * __RPC_USER  PIDLIST_ABSOLUTE_UserUnmarshal64(unsigned long *, unsigned char *, PIDLIST_ABSOLUTE * ); 
void                      __RPC_USER  PIDLIST_ABSOLUTE_UserFree64(     unsigned long *, PIDLIST_ABSOLUTE * ); 

unsigned long             __RPC_USER  PIDLIST_RELATIVE_UserSize64(     unsigned long *, unsigned long            , PIDLIST_RELATIVE * ); 
unsigned char * __RPC_USER  PIDLIST_RELATIVE_UserMarshal64(  unsigned long *, unsigned char *, PIDLIST_RELATIVE * ); 
unsigned char * __RPC_USER  PIDLIST_RELATIVE_UserUnmarshal64(unsigned long *, unsigned char *, PIDLIST_RELATIVE * ); 
void                      __RPC_USER  PIDLIST_RELATIVE_UserFree64(     unsigned long *, PIDLIST_RELATIVE * ); 

unsigned long             __RPC_USER  PITEMID_CHILD_UserSize64(     unsigned long *, unsigned long            , PITEMID_CHILD * ); 
unsigned char * __RPC_USER  PITEMID_CHILD_UserMarshal64(  unsigned long *, unsigned char *, PITEMID_CHILD * ); 
unsigned char * __RPC_USER  PITEMID_CHILD_UserUnmarshal64(unsigned long *, unsigned char *, PITEMID_CHILD * ); 
void                      __RPC_USER  PITEMID_CHILD_UserFree64(     unsigned long *, PITEMID_CHILD * ); 

unsigned long             __RPC_USER  VARIANT_UserSize64(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal64(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal64(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree64(     unsigned long *, VARIANT * ); 

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumIDList_Next_Proxy( 
    IEnumIDList * This,
    /* [in] */ 
    __in  ULONG celt,
    /* [length_is][size_is][out] */ 
    __out_ecount_part(celt, *pceltFetched)  PITEMID_CHILD *rgelt,
    /* [out] */ 
    __out_opt  ULONG *pceltFetched);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumIDList_Next_Stub( 
    IEnumIDList * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) PITEMID_CHILD *rgelt,
    /* [out] */ __RPC__out ULONG *pceltFetched);

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumObjects_Next_Proxy( 
    IEnumObjects * This,
    /* [in] */ 
    __in  ULONG celt,
    /* [in] */ 
    __in  REFIID riid,
    /* [iid_is][length_is][size_is][out] */ 
    __out_ecount_part(celt, *pceltFetched)  void **rgelt,
    /* [out] */ 
    __out_opt  ULONG *pceltFetched);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumObjects_Next_Stub( 
    IEnumObjects * This,
    /* [in] */ ULONG celt,
    /* [in] */ __RPC__in REFIID riid,
    /* [iid_is][size_is][out] */ __RPC__out_ecount_full(celt) void **rgelt,
    /* [out] */ __RPC__out ULONG *pceltFetched);

/* [local] */ HRESULT STDMETHODCALLTYPE IModalWindow_Show_Proxy( 
    IModalWindow * This,
    /* [in] */ 
    __in  HWND hwndParent);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IModalWindow_Show_Stub( 
    IModalWindow * This,
    /* [in] */ __RPC__in HWND hwndParent);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\ShlGuid.h ===
//===========================================================================
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//
//===========================================================================


#pragma once


DEFINE_GUID(CLSID_NetworkDomain,        0x46e06680, 0x4bf0, 0x11d1, 0x83,0xee,0x00,0xa0,0xc9,0x0d,0xc8,0x49);//46e06680-4bf0-11d1-83ee-00a0c90dc849
DEFINE_GUID(CLSID_NetworkServer,        0xc0542a90, 0x4bf0, 0x11d1, 0x83,0xee,0x00,0xa0,0xc9,0x0d,0xc8,0x49);//c0542a90-4bf0-11d1-83ee-00a0c90dc849
DEFINE_GUID(CLSID_NetworkShare,         0x54a754c0, 0x4bf0, 0x11d1, 0x83,0xee,0x00,0xa0,0xc9,0x0d,0xc8,0x49);//54a754c0-4bf1-11d1-83ee-00a0c90dc849
DEFINE_GUID(CLSID_MyComputer,           0x20D04FE0, 0x3AEA, 0x1069, 0xA2,0xD8,0x08,0x00,0x2B,0x30,0x30,0x9D);//20D04FE0-3AEA-1069-A2D8-08002B30309D
DEFINE_GUID(CLSID_Internet,             0x871C5380, 0x42A0, 0x1069, 0xA2,0xEA,0x08,0x00,0x2B,0x30,0x30,0x9D);//871C5380-42A0-1069-A2EA-08002B30309D
DEFINE_GUID(CLSID_RecycleBin,           0x645FF040, 0x5081, 0x101B, 0x9F,0x08,0x00,0xAA,0x00,0x2F,0x95,0x4E);//645FF040-5081-101B-9F08-00AA002F954E
DEFINE_GUID(CLSID_ControlPanel,         0x21EC2020, 0x3AEA, 0x1069, 0xA2,0xDD,0x08,0x00,0x2B,0x30,0x30,0x9D);//21EC2020-3AEA-1069-A2DD-08002B30309D
DEFINE_GUID(CLSID_Printers,             0x2227A280, 0x3AEA, 0x1069, 0xA2,0xDE,0x08,0x00,0x2B,0x30,0x30,0x9D);
DEFINE_GUID(CLSID_MyDocuments,          0x450d8fba, 0xad25, 0x11d0, 0x98,0xa8,0x08,0x00,0x36,0x1b,0x11,0x03);//450D8FBA-AD25-11D0-98A8-0800361B1103
DEFINE_GUID(CLSID_PictureVideoLibrary,  0x00044b4e, 0x11e6, 0x4bef, 0xae,0xc2,0xba,0x15,0x7d,0x80,0xf6,0x60);//00044b4e-11e6-4bef-aec2-ba157d80f660
DEFINE_GUID(CLSID_MusicLibrary,         0x00875566, 0xaddc, 0x4883, 0xa2,0xbf,0x62,0xbb,0xd2,0x30,0xdf,0x07);//00875566-addc-4883-a2bf-62bbd230df07
DEFINE_GUID(CLSID_DocumentLibrary,      0x00f4a6ac, 0xe2e7, 0x4652, 0xb7,0xa7,0xec,0xbd,0x23,0x2f,0x78,0x18);//00f4a6ac-e2e7-4652-b7a7-ecbd232f7818

// string version of above CLSIDs
// useful for doing psfDesktop->ParseDisplayName( L"::" L STR_MYDOCS_CLSID, ...);

#define STR_MYDOCS_CLSID   "{450D8FBA-AD25-11D0-98A8-0800361B1103}"

#if (_WIN32_IE >= 0x0400)
DEFINE_GUID(CATID_BrowsableShellExt, 0x00021490L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(CATID_BrowseInPlace,     0x00021491L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(CATID_DeskBand,          0x00021492L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(CATID_InfoBand,          0x00021493L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(CATID_CommBand,          0x00021494L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);

#endif

#define PSGUID_INTERNETSHORTCUT {0x000214A0, 0, 0, 0xC0,0,0,0,0,0,0,0x46}
DEFINE_GUID(FMTID_Intshcut,          0x000214A0L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);

#define PSGUID_INTERNETSITE {0x000214A1L, 0, 0, 0xC0,0,0,0,0,0,0,0x46}
DEFINE_GUID(FMTID_InternetSite,      0x000214A1L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);

DEFINE_GUID(CGID_Explorer,           0x000214D0L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(CGID_ShellDocView,       0x000214D1L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);

#if (_WIN32_IE >= 0x0400)
DEFINE_GUID(CGID_ShellServiceObject, 0x000214D2L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(CGID_ExplorerBarDoc,     0x000214D3L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
#endif


DEFINE_GUID(IID_INewShortcutHookA,   0x000214E1L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IShellBrowser,       0x000214E2L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IShellView,          0x000214E3L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IContextMenu,        0x000214E4L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IShellIcon,          0x000214E5L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IShellFolder,        0x000214E6L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IShellExtInit,       0x000214E8L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IShellPropSheetExt,  0x000214E9L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IPersistFolder,      0x000214EAL, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IExtractIconA,       0x000214EBL, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IShellDetails,       0x000214ECL, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IShellLinkA,         0x000214EEL, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_ICopyHookA,          0x000214EFL, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IFileViewerA,        0x000214F0L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_ICommDlgBrowser,     0x000214F1L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IEnumIDList,         0x000214F2L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IFileViewerSite,     0x000214F3L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IContextMenu2,       0x000214F4L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IShellExecuteHookA,  0x000214F5L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IPropSheetPage,      0x000214F6L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_INewShortcutHookW,   0x000214F7L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IFileViewerW,        0x000214F8L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IShellLinkW,         0x000214F9L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IExtractIconW,       0x000214FAL, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IShellExecuteHookW,  0x000214FBL, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_ICopyHookW,          0x000214FCL, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IRemoteComputer,     0x000214FEL, 0, 0, 0xC0,0,0,0,0,0,0,0x46);

#define IID_IShellCopyHookA                  IID_ICopyHookA
#define IID_IShellCopyHookW                  IID_ICopyHookW

#define SID_LinkSite    IID_IShellLinkW     // IServiceProvider::QueryService() access the link object that is defering to you

#if (_WIN32_IE >= 0x0400)
DEFINE_GUID(IID_IQueryInfo,          0x00021500L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
#endif

DEFINE_GUID(IID_IBriefcaseStg,          0x8BCE1FA1L, 0x0921, 0x101B, 0xB1, 0xFF, 0x00, 0xDD, 0x01, 0x0C, 0xCC, 0x48);
DEFINE_GUID(IID_IShellView2,            0x88E39E80L, 0x3578, 0x11CF, 0xAE, 0x69, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);

#if (_WIN32_IE >= 0x0400)
DEFINE_GUID(IID_IURLSearchHook,         0xAC60F6A0L, 0x0FD9, 0x11D0, 0x99, 0xCB, 0x00, 0xC0, 0x4F, 0xD6, 0x44, 0x97);
DEFINE_GUID(IID_ISearchContext,         0x09F656A2L, 0x41AF, 0x480C, 0x88, 0xF7, 0x16, 0xCC, 0x0D, 0x16, 0x46, 0x15);
DEFINE_GUID(IID_IURLSearchHook2,        0x5ee44da4L, 0x6d32, 0x46e3, 0x86, 0xbc, 0x07, 0x54, 0x0d, 0xed, 0xd0, 0xe0);
DEFINE_GUID(IID_IDefViewID,             0x985F64F0L, 0xD410, 0x4E02, 0xBE, 0x22, 0xDA, 0x07, 0xF2, 0xB5, 0xC5, 0xE1);
#define IDefViewID   IUnknown

#if (_WIN32_IE >= 0x0500)
// CLSID_FolderShortcut {0AFACED1-E828-11D1-9187-B532F1E9575D}
DEFINE_GUID(CLSID_FolderShortcut,       0x0AFACED1L, 0xE828, 0x11D1, 0x91, 0x87, 0xB5, 0x32, 0xF1, 0xE9, 0x57, 0x5D);
#endif

DEFINE_GUID(IID_IDockingWindowSite,     0x2a342fc2, 0x7b26, 0x11d0, 0x8c, 0xa9, 0x0, 0xa0, 0xc9, 0x2d, 0xbf, 0xe8);
DEFINE_GUID(IID_IDockingWindowFrame,    0x47d2657a, 0x7b27, 0x11d0, 0x8c, 0xa9, 0x0, 0xa0, 0xc9, 0x2d, 0xbf, 0xe8);

DEFINE_GUID(IID_IShellIconOverlay,      0x7D688A70L, 0xC613, 0x11D0, 0x99, 0x9B, 0x00, 0xC0, 0x4F, 0xD6, 0x55, 0xE1);
DEFINE_GUID(IID_IShellIconOverlayIdentifier,  0x0C6C4200L, 0xC589, 0x11D0, 0x99, 0x9A, 0x00, 0xC0, 0x4F, 0xD6, 0x55, 0xE1);

// {10339516-2894-11d2-9039-00C04F8EEB3E}
DEFINE_GUID(IID_ICommDlgBrowser2,       0x10339516, 0x2894, 0x11d2, 0x90, 0x39, 0x0, 0xc0, 0x4f, 0x8e, 0xeb, 0x3e);

// {2047E320-F2A9-11CE-AE65-08002B2E1262}
DEFINE_GUID(IID_IShellFolderViewCB, 0x2047E320L, 0xF2A9, 0x11CE, 0xAE, 0x65, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);
#define SID_ShellFolderViewCB IID_IShellFolderViewCB

// {63B51F81-C868-11D0-999C-00C04FD655E1}
DEFINE_GUID(CLSID_CFSIconOverlayManager, 0x63B51F81L, 0xC868, 0x11D0, 0x99, 0x9C, 0x00, 0xC0, 0x4F, 0xD6, 0x55, 0xE1);


// f10b5e34-dd3b-42a7-aa7d-2f4ec54bb09b
DEFINE_GUID(IID_IShellIconOverlayManager, 0xf10b5e34L, 0xdd3b, 0x42a7, 0xaa, 0x7d, 0x2f, 0x4e, 0xc5, 0x4b, 0xb0, 0x9b);

// {4ea39266-7211-409f-b622-f63dbd16c533}
DEFINE_GUID(IID_IThumbnailCapture,           0x4ea39266, 0x7211, 0x409f, 0xb6, 0x22, 0xf6, 0x3d, 0xbd, 0x16, 0xc5, 0x33);

#if (_WIN32_IE >= 0x0500)

// {48C8118C-B924-11d1-98D5-00C04FB687DA}
DEFINE_GUID(IID_IShellImageStore,            0x48c8118c, 0xb924, 0x11d1, 0x98, 0xd5, 0x0, 0xc0, 0x4f, 0xb6, 0x87, 0xda);

#if (NTDDI_VERSION < NTDDI_VISTA) // removed in Windows Vista
// {1EBDCF80-A200-11d0-A3A4-00C04FD706EC}
DEFINE_GUID(CLSID_ShellThumbnailDiskCache,   0x1ebdcf80, 0xa200, 0x11d0, 0xa3, 0xa4, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);
#endif

#endif


// {BCFCE0A0-EC17-11d0-8D10-00A0C90F2719}
DEFINE_GUID(IID_IContextMenu3,          0xbcfce0a0, 0xec17, 0x11d0, 0x8d, 0x10, 0x0, 0xa0, 0xc9, 0xf, 0x27, 0x19);


#endif // _WIN32_IE >= 0x0400

DEFINE_GUID(SID_DefView,                0x6D12FE80, 0x7911, 0x11CF, 0x95, 0x34, 0x00, 0x00, 0xC0, 0x5B, 0xAE, 0x0B);

DEFINE_GUID(CGID_DefView,               0x4af07f10, 0xd231, 0x11d0, 0xb9, 0x42, 0x0, 0xa0, 0xc9, 0x3, 0x12, 0xe1);

DEFINE_GUID(CLSID_MenuBand,             0x5b4dae26, 0xb807, 0x11d0, 0x98, 0x15, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// IShellFolderBand stuff
// {7FE80CC8-C247-11d0-B93A-00A0C90312E1}
DEFINE_GUID(IID_IShellFolderBand, 0x7fe80cc8, 0xc247, 0x11d0, 0xb9, 0x3a, 0x0, 0xa0, 0xc9, 0x3, 0x12, 0xe1);
// 710EB7A0-45ED-11D0-924A-0020AFC7AC4D
DEFINE_GUID(IID_IDefViewFrame, 0x710EB7A0L, 0x45ED, 0x11D0, 0x92, 0x4A, 0x00, 0x20, 0xAF, 0xC7, 0xAC, 0x4D);


// 0057D0E0-3573-11CF-AE69-08002B2E1262
DEFINE_GUID(VID_LargeIcons, 0x0057D0E0L, 0x3573, 0x11CF, 0xAE, 0x69, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);
// 089000C0-3573-11CF-AE69-08002B2E1262
DEFINE_GUID(VID_SmallIcons, 0x089000C0L, 0x3573, 0x11CF, 0xAE, 0x69, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);
// 0E1FA5E0-3573-11CF-AE69-08002B2E1262
DEFINE_GUID(VID_List      , 0x0E1FA5E0L, 0x3573, 0x11CF, 0xAE, 0x69, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);
// 137E7700-3573-11CF-AE69-08002B2E1262
DEFINE_GUID(VID_Details   , 0x137E7700L, 0x3573, 0x11CF, 0xAE, 0x69, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);
// 5984FFE0-28D4-11CF-AE66-08002B2E1262
DEFINE_GUID(VID_Tile      , 0x65f125e5L, 0x7be1, 0x4810, 0xba, 0x9d, 0xd2, 0x71, 0xc8, 0x43, 0x2c, 0xe3);
// 65F125E5-7BE1-4810-BA9D-D271C8432CE3


// NOTE: This has to be the same as the old CLSID_Thumbnails
// {8BEBB290-52D0-11d0-B7F4-00C04FD706EC}
DEFINE_GUID(VID_Thumbnails,     0x8bebb290, 0x52d0, 0x11d0, 0xb7, 0xf4, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

// ThumbStrip
// {8EEFA624-D1E9-445B-94B7-74FBCE2EA11A}
DEFINE_GUID(VID_ThumbStrip, 0x8EEFA624, 0xD1E9, 0x445B, 0x94, 0xB7, 0x74, 0xFB, 0xCE, 0x2E, 0xA1, 0x1A);


#define SID_SShellBrowser IID_IShellBrowser
#if (_WIN32_IE >= 0x0400)
#define SID_SShellDesktop CLSID_ShellDesktop
#endif

#if (_WIN32_IE >= 0x0400)
//
//  IShellDiscardable is an IID-only interface. If the object supports this
// interface it can be discarded anytime. IWebBrowser::PutProperty QI's for
// this interface to detect discardable properties.
//
DEFINE_GUID(IID_IDiscardableBrowserProperty, 0x49c3de7c, 0xd329, 0x11d0, 0xab, 0x73, 0x00, 0xc0, 0x4f, 0xc3, 0x3e, 0x80);

// IShellChangeNotify is a sink of LPCITEMIDLIST notification events
//
// D82BE2B1-5764-11D0-A96E-00C04FD705A2
DEFINE_GUID(IID_IShellChangeNotify, 0xD82BE2B1L, 0x5764, 0x11D0, 0xA9, 0x6E, 0x00, 0xC0, 0x4F, 0xD7, 0x05, 0xA2);

#endif // _WIN32_IE >= 0x0400

#ifdef UNICODE
#define IID_IFileViewer         IID_IFileViewerW
#define IID_IShellLink          IID_IShellLinkW
#define IID_IExtractIcon        IID_IExtractIconW
#define IID_IShellCopyHook      IID_IShellCopyHookW
#define IID_IShellExecuteHook   IID_IShellExecuteHookW
#define IID_INewShortcutHook    IID_INewShortcutHookW
#else
#define IID_IFileViewer         IID_IFileViewerA
#define IID_IShellLink          IID_IShellLinkA
#define IID_IExtractIcon        IID_IExtractIconA
#define IID_IShellCopyHook      IID_IShellCopyHookA
#define IID_IShellExecuteHook   IID_IShellExecuteHookA
#define IID_INewShortcutHook    IID_INewShortcutHookA
#endif


#ifndef NO_INTSHCUT_GUIDS
#include <isguids.h>            // internet shortcut GUIDs
#endif

#ifndef NO_SHDOCVW_GUIDS

#ifndef GUID_DEFS_ONLY
#include <exdisp.h>
#include <shldisp.h>
#endif


#if (_WIN32_IE >= 0x0400)
// UrlHistory Guids
DEFINE_GUID(CLSID_CUrlHistory,          0x3C374A40L, 0xBAE4, 0x11CF, 0xBF, 0x7D, 0x00, 0xAA, 0x00, 0x69, 0x46, 0xEE);
#define SID_SUrlHistory         CLSID_CUrlHistory

//UrlSearchHook Guids
DEFINE_GUID(CLSID_CURLSearchHook,       0xCFBFAE00L, 0x17A6, 0x11D0, 0x99, 0xCB, 0x00, 0xC0, 0x4F, 0xD6, 0x44, 0x97);


#define SID_SInternetExplorer IID_IWebBrowserApp
#define SID_SWebBrowserApp    IID_IWebBrowserApp

#define SID_SWebBrowserEventsService IID_IWebBrowserEventsService

// AutoComplete Guids
DEFINE_GUID(IID_IObjMgr,                0x00BB2761L, 0x6A77, 0x11D0, 0xA5, 0x35, 0x00, 0xC0, 0x4F, 0xD7, 0xD0, 0x62);
DEFINE_GUID(IID_IACList,                0x77A130B0L, 0x94FD, 0x11D0, 0xA5, 0x44, 0x00, 0xC0, 0x4F, 0xD7, 0xd0, 0x62);
DEFINE_GUID(IID_IACList2,               0x470141a0L, 0x5186, 0x11d2, 0xbb, 0xb6, 0x00, 0x60, 0x97, 0x7b, 0x46, 0x4c);
DEFINE_GUID(IID_ICurrentWorkingDirectory, 0x91956d21L, 0x9276, 0x11d1, 0x92, 0x1a, 0x00, 0x60, 0x97, 0xdf, 0x5b, 0xd4);     // {91956D21-9276-11d1-921A-006097DF5BD4}
DEFINE_GUID(CLSID_AutoComplete,         0x00BB2763L, 0x6A77, 0x11D0, 0xA5, 0x35, 0x00, 0xC0, 0x4F, 0xD7, 0xD0, 0x62);
DEFINE_GUID(CLSID_ACLHistory,           0x00BB2764L, 0x6A77, 0x11D0, 0xA5, 0x35, 0x00, 0xC0, 0x4F, 0xD7, 0xD0, 0x62);
DEFINE_GUID(CLSID_ACListISF,            0x03C036F1L, 0xA186, 0x11D0, 0x82, 0x4A, 0x00, 0xAA, 0x00, 0x5B, 0x43, 0x83);
DEFINE_GUID(CLSID_ACLMRU,               0x6756a641L, 0xde71, 0x11d0, 0x83, 0x1b, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);          // {6756A641-DE71-11d0-831B-00AA005B4383}
DEFINE_GUID(CLSID_ACLMulti,             0x00BB2765L, 0x6A77, 0x11D0, 0xA5, 0x35, 0x00, 0xC0, 0x4F, 0xD7, 0xD0, 0x62);
#if (_WIN32_IE >= 0x0600)
DEFINE_GUID(CLSID_ACLCustomMRU,      0x6935db93, 0x21e8, 0x4ccc, 0xbe, 0xb9, 0x9f, 0xe3, 0xc7, 0x7a, 0x29, 0x7a);
#endif


#if (_WIN32_IE >= 0x0500)
// IProgressDialog
// {F8383852-FCD3-11d1-A6B9-006097DF5BD4}
DEFINE_GUID(CLSID_ProgressDialog,       0xf8383852, 0xfcd3, 0x11d1, 0xa6, 0xb9, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4);
// {EBBC7C04-315E-11d2-B62F-006097DF5BD4}
DEFINE_GUID(IID_IProgressDialog,        0xebbc7c04, 0x315e, 0x11d2, 0xb6, 0x2f, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4);
#endif // _WIN32_IE >= 0x0500

//
// Progress objects exposed via QueryService
//
#define SID_SProgressUI CLSID_ProgressDialog


//
// Top-most browser implementation in the heirarchy. use IServiceProvider::QueryService()
// to get to interfaces (IID_IShellBrowser, IID_IShellBrowserService, etc.)
//
DEFINE_GUID(SID_STopLevelBrowser,       0x4C96BE40L, 0x915C, 0x11CF, 0x99, 0xD3, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);

#endif // _WIN32_IE >= 0x0400

#endif // !NO_SHDOCVW_GUIDS


//B091E540-83E3-11CF-A713-0020AFD79762
DEFINE_GUID(CLSID_FileTypes, 0xB091E540, 0x83E3, 0x11CF, 0xA7,0x13,0x00,0x20,0xAF,0xD7,0x97,0x62);


#if (_WIN32_IE >= 0x0400)

// {75048700-EF1F-11D0-9888-006097DEACF9}
DEFINE_GUID( CLSID_ActiveDesktop, 0x75048700L, 0xEF1F, 0x11D0, 0x98, 0x88, 0x00, 0x60, 0x97, 0xDE, 0xAC, 0xF9);

// {F490EB00-1240-11D1-9888-006097DEACF9}
DEFINE_GUID(IID_IActiveDesktop, 0xF490EB00L, 0x1240, 0x11D1, 0x98, 0x88, 0x00, 0x60, 0x97, 0xDE, 0xAC, 0xF9);

// {52502EE0-EC80-11D0-89AB-00C04FC2972D}
DEFINE_GUID(IID_IActiveDesktopP, 0x52502EE0L, 0xEC80, 0x11D0, 0x89, 0xAB, 0x00, 0xC0, 0x4F, 0xC2, 0x97, 0x2D);

// {B22754E2-4574-11d1-9888-006097DEACF9}
DEFINE_GUID(IID_IADesktopP2, 0xb22754e2, 0x4574, 0x11d1, 0x98, 0x88, 0x0, 0x60, 0x97, 0xde, 0xac, 0xf9);

// {74C26041-70D1-11d1-B75A-00A0C90564FE}
DEFINE_GUID(IID_ISynchronizedCallBack, 0x74c26041, 0x70d1, 0x11d1, 0xb7, 0x5a, 0x0, 0xa0, 0xc9, 0x5, 0x64, 0xfe);

//  {c46ca590-3c3f-11d2-bee6-0000f805ca57}
DEFINE_GUID(IID_IQueryAssociations,          0xc46ca590, 0x3c3f, 0x11d2, 0xbe, 0xe6, 0x00, 0x00, 0xf8, 0x05, 0xca, 0x57);

// {a07034fd-6caa-4954-ac3f-97a27216f98a}
DEFINE_GUID(CLSID_QueryAssociations, 0xa07034fd, 0x6caa, 0x4954, 0xac, 0x3f, 0x97, 0xa2, 0x72, 0x16, 0xf9, 0x8a);


// {E8025004-1C42-11d2-BE2C-00A0C9A83DA1}
DEFINE_GUID(IID_IColumnProvider,        0xe8025004, 0x1c42, 0x11d2, 0xbe, 0x2c, 0x0, 0xa0, 0xc9, 0xa8, 0x3d, 0xa1);

// {24F14F02-7B1C-11d1-838f-0000F80461CF}
DEFINE_GUID(CLSID_LinkColumnProvider,    0x24f14f02, 0x7b1c, 0x11d1, 0x83, 0x8f, 0x0, 0x0, 0xf8, 0x4, 0x61, 0xcf);

// For Internet Shortcut Creation Command
// The shell uses this command to allow trident to save off it's per frame data in the shortcut
// and to allow it to fire the OnPersist() event on every frame
// {93A68750-951A-11d1-946F-000000000000}
DEFINE_GUID(CGID_ShortCut, 0x93a68750, 0x951a, 0x11d1, 0x94, 0x6f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0);


// {FB700430-952C-11d1-946F-000000000000}
DEFINE_GUID(IID_INamedPropertyBag, 0xfb700430, 0x952c, 0x11d1, 0x94, 0x6f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0);

// {1E796980-9CC5-11D1-A83F-00C04FC99D61}
DEFINE_GUID(CLSID_InternetButtons, 0x1E796980L, 0x9CC5, 0x11D1, 0xA8, 0x3F, 0x00, 0xC0, 0x4F, 0xC9, 0x9D, 0x61);

#if (_WIN32_IE >= 0x0500)
// {178F34B8-A282-11d2-86C5-00C04F8EEA99}
DEFINE_GUID(CLSID_MSOButtons, 0x178f34b8, 0xa282, 0x11d2, 0x86, 0xc5, 0x0, 0xc0, 0x4f, 0x8e, 0xea, 0x99);

// {2CE4B5D8-A28F-11d2-86C5-00C04F8EEA99}
DEFINE_GUID(CLSID_ToolbarExtButtons, 0x2ce4b5d8, 0xa28f, 0x11d2, 0x86, 0xc5, 0x0, 0xc0, 0x4f, 0x8e, 0xea, 0x99);
#endif // _WIN32_IE >= 0x0500

// {CFCCC7A0-A282-11D1-9082-006008059382}
DEFINE_GUID(CLSID_DarwinAppPublisher, 0xCFCCC7A0L, 0xA282, 0x11D1, 0x90, 0x82, 0x00, 0x60, 0x08, 0x05, 0x93, 0x82);

// {7057E952-BD1B-11d1-8919-00C04FC2C836}
DEFINE_GUID(CLSID_DocHostUIHandler, 0x7057e952, 0xbd1b, 0x11d1, 0x89, 0x19, 0x0, 0xc0, 0x4f, 0xc2, 0xc8, 0x36);
#endif  // _WIN32_IE >= 0x0400

#if (_WIN32_IE >= 0x0500)

// {93F2F68C-1D1B-11d3-A30E-00C04F79ABD1}
DEFINE_GUID(IID_IShellFolder2,  0x93f2f68c, 0x1d1b, 0x11d3, 0xa3, 0xe, 0x0, 0xc0, 0x4f, 0x79, 0xab, 0xd1);

// {28636aa6-953d-11d2-b5d6-00c04fd918d0}
#define PSGUID_SHELLDETAILS     {0x28636aa6, 0x953d, 0x11d2, 0xb5, 0xd6, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0}
DEFINE_GUID(FMTID_ShellDetails,  0x28636aa6, 0x953d, 0x11d2, 0xb5, 0xd6, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);
#define PID_FINDDATA        0
#define PID_NETRESOURCE     1
#define PID_DESCRIPTIONID   2
#define PID_WHICHFOLDER     3
#define PID_NETWORKLOCATION 4
#define PID_COMPUTERNAME    5

// PSGUID_STORAGE comes from ntquery.h
//#define PSGUID_STORAGE    {0xb725f130, 0x47ef, 0x101a, 0xa5, 0xf1, 0x02, 0x60, 0x8c, 0x9e, 0xeb, 0xac}
DEFINE_GUID(FMTID_Storage,   0xb725f130, 0x47ef, 0x101a, 0xa5, 0xf1, 0x02, 0x60, 0x8c, 0x9e, 0xeb, 0xac);

// Image properties
#define PSGUID_IMAGEPROPERTIES {0x14b81da1, 0x0135, 0x4d31, 0x96, 0xd9, 0x6c, 0xbf, 0xc9, 0x67, 0x1a, 0x99}
DEFINE_GUID(FMTID_ImageProperties, 0x14b81da1, 0x0135, 0x4d31, 0x96, 0xd9, 0x6c, 0xbf, 0xc9, 0x67, 0x1a, 0x99);

// Custom Image Properties (not EXIF tags, which go into the auxiliary image property store)
// {7ECD8B0E-C136-4a9b-9411-4EBD6673CCC3}
#define PSGUID_CUSTOMIMAGEPROPERTIES {0x7ecd8b0e, 0xc136, 0x4a9b, 0x94, 0x11, 0x4e, 0xbd, 0x66, 0x73, 0xcc, 0xc3}
DEFINE_GUID(FMTID_CustomImageProperties, 0x7ecd8b0e, 0xc136, 0x4a9b, 0x94, 0x11, 0x4e, 0xbd, 0x66, 0x73, 0xcc, 0xc3);

// The GUIDs used to identify shell item attributes (columns). See IShellFolder2::GetDetailsEx implementations...

// {9B174B33-40FF-11d2-A27E-00C04FC30871}
#define PSGUID_DISPLACED    {0x9b174b33, 0x40ff, 0x11d2, 0xa2, 0x7e, 0x0, 0xc0, 0x4f, 0xc3, 0x8, 0x71}
DEFINE_GUID(FMTID_Displaced, 0x9b174b33, 0x40ff, 0x11d2, 0xa2, 0x7e, 0x0, 0xc0, 0x4f, 0xc3, 0x8, 0x71);
#define PID_DISPLACED_FROM  2
#define PID_DISPLACED_DATE  3

// {328D8B21-7729-4bfc-954C-902B329D56B0}
#define PSGUID_BRIEFCASE    {0x328d8b21, 0x7729, 0x4bfc, 0x95, 0x4c, 0x90, 0x2b, 0x32, 0x9d, 0x56, 0xb0}
DEFINE_GUID(FMTID_Briefcase, 0x328d8b21, 0x7729, 0x4bfc, 0x95, 0x4c, 0x90, 0x2b, 0x32, 0x9d, 0x56, 0xb0);
#define PID_SYNC_COPY_IN    2


// {9B174B34-40FF-11d2-A27E-00C04FC30871}
#define PSGUID_MISC    {0x9b174b34, 0x40ff, 0x11d2, 0xa2, 0x7e, 0x0, 0xc0, 0x4f, 0xc3, 0x8, 0x71}
DEFINE_GUID(FMTID_Misc, 0x9b174b34, 0x40ff, 0x11d2, 0xa2, 0x7e, 0x0, 0xc0, 0x4f, 0xc3, 0x8, 0x71);
#define PID_MISC_STATUS         2
#define PID_MISC_ACCESSCOUNT    3
#define PID_MISC_OWNER          4
#define PID_HTMLINFOTIPFILE     5
#define PID_MISC_PICS           6
// Do not add more pids beyond what shipped in Server 2k3 - just add PROPERTYKEYs to propkey.w

// {F2275480-F782-4291-BD94-F13693513AEC}
#define PSGUID_WEBVIEW  {0xf2275480, 0xf782, 0x4291, 0xbd, 0x94, 0xf1, 0x36, 0x93, 0x51, 0x3a, 0xec}
DEFINE_GUID(FMTID_WebView, 0xf2275480, 0xf782, 0x4291, 0xbd, 0x94, 0xf1, 0x36, 0x93, 0x51, 0x3a, 0xec);
#define PID_DISPLAY_PROPERTIES  0
#define PID_INTROTEXT           1

// {56A3372E-CE9C-11d2-9F0E-006097C686F6}
#define PSGUID_MUSIC    {0x56a3372e, 0xce9c, 0x11d2, 0x9f, 0xe, 0x0, 0x60, 0x97, 0xc6, 0x86, 0xf6}
DEFINE_GUID(FMTID_MUSIC, 0x56a3372e, 0xce9c, 0x11d2, 0x9f, 0xe, 0x0, 0x60, 0x97, 0xc6, 0x86, 0xf6);
#define PIDSI_ARTIST    2
#define PIDSI_SONGTITLE 3
#define PIDSI_ALBUM     4
#define PIDSI_YEAR      5
#define PIDSI_COMMENT   6
#define PIDSI_TRACK     7
#define PIDSI_GENRE     11
#define PIDSI_LYRICS    12
// Do not add more pids to this file. Add new PROPERTYKEYs to propkey.w instead

// {AEAC19E4-89AE-4508-B9B7-BB867ABEE2ED}
#define PSGUID_DRM    {0xaeac19e4, 0x89ae, 0x4508, 0xb9, 0xb7, 0xbb, 0x86, 0x7a, 0xbe, 0xe2, 0xed}
DEFINE_GUID(FMTID_DRM, 0xaeac19e4, 0x89ae, 0x4508, 0xb9, 0xb7, 0xbb, 0x86, 0x7a, 0xbe, 0xe2, 0xed);
#define PIDDRSI_PROTECTED    2
#define PIDDRSI_DESCRIPTION  3
#define PIDDRSI_PLAYCOUNT    4
#define PIDDRSI_PLAYSTARTS   5
#define PIDDRSI_PLAYEXPIRES  6

// {64440491-4C8B-11D1-8B70-080036B11A03}
#define PSGUID_VIDEO   {0x64440491, 0x4c8b, 0x11d1, 0x8b, 0x70, 0x8, 0x0, 0x36, 0xb1, 0x1a, 0x3}
//  FMTID_VideoSummaryInformation property identifiers.  See propkey.h for their types.
#define PIDVSI_STREAM_NAME      0x00000002 // "System.Video.StreamName"   (old name "StreamName")
#define PIDVSI_FRAME_WIDTH      0x00000003 // "System.Video.FrameWidth"   (old name "FrameWidth")
#define PIDVSI_FRAME_HEIGHT     0x00000004 // "System.Video.FrameHeight"  (old name "FrameHeight")
#define PIDVSI_TIMELENGTH       0x00000007 //                             (old name "TimeLength")
#define PIDVSI_FRAME_COUNT      0x00000005 // "System.Media.FrameCount"   (old name "FrameCount")
#define PIDVSI_FRAME_RATE       0x00000006 // "System.Video.FrameRate"    (old name "FrameRate")
#define PIDVSI_DATA_RATE        0x00000008 // "System.Video.DataRate"     (old name "DataRate")
#define PIDVSI_SAMPLE_SIZE      0x00000009 // "System.Video.SampleSize"   (old name "SampleSize")
#define PIDVSI_COMPRESSION      0x0000000A // "System.Video.Compression"  (old name "Compression")
#define PIDVSI_STREAM_NUMBER    0x0000000B // "System.Video.StreamNumber" (old name "StreamNumber")

// {64440490-4C8B-11D1-8B70-080036B11A03}
#define PSGUID_AUDIO   {0x64440490, 0x4c8b, 0x11d1, 0x8b, 0x70, 0x8, 0x0, 0x36, 0xb1, 0x1a, 0x3}
//  FMTID_AudioSummaryInformation property identifiers
#define PIDASI_FORMAT           0x00000002 // VT_BSTR
#define PIDASI_TIMELENGTH       0x00000003 // VT_UI4, milliseconds
#define PIDASI_AVG_DATA_RATE    0x00000004 // VT_UI4,  Hz
#define PIDASI_SAMPLE_RATE      0x00000005 // VT_UI4,  bits
#define PIDASI_SAMPLE_SIZE      0x00000006 // VT_UI4,  bits
#define PIDASI_CHANNEL_COUNT    0x00000007 // VT_UI4
#define PIDASI_STREAM_NUMBER    0x00000008 // VT_UI2
#define PIDASI_STREAM_NAME      0x00000009 // VT_LPWSTR
#define PIDASI_COMPRESSION      0x0000000A // VT_LPWSTR
// Do not add more pids to this file. Add new PROPERTYKEYs to propkey.w instead


// {305CA226-D286-468e-B848-2B2E8E697B74}
#define PSGUID_CONTROLPANEL {0x305ca226, 0xd286, 0x468e, 0xb8, 0x48, 0x2b, 0x2e, 0x8e, 0x69, 0x7b, 0x74}
#define PID_CONTROLPANEL_CATEGORY 2
// Do not add more pids to this file. Add new PROPERTYKEYs to propkey.w instead

// {9B174B35-40FF-11d2-A27E-00C04FC30871}
#define PSGUID_VOLUME    {0x9b174b35, 0x40ff, 0x11d2, 0xa2, 0x7e, 0x0, 0xc0, 0x4f, 0xc3, 0x8, 0x71}
DEFINE_GUID(FMTID_Volume, 0x9b174b35, 0x40ff, 0x11d2, 0xa2, 0x7e, 0x0, 0xc0, 0x4f, 0xc3, 0x8, 0x71);
#define PID_VOLUME_FREE         2
#define PID_VOLUME_CAPACITY     3
#define PID_VOLUME_FILESYSTEM   4
// Do not add more pids to this file. Add new PROPERTYKEYs to propkey.w instead

// {D8C3986F-813B-449c-845D-87B95D674ADE}
#define PSGUID_SHARE    {0xd8c3986f, 0x813b, 0x449c, 0x84, 0x5d, 0x87, 0xb9, 0x5d, 0x67, 0x4a, 0xde}
#define PID_SHARE_CSC_STATUS    2   // server or share status, "online" "offline"
// Do not add more pids to this file. Add new PROPERTYKEYs to propkey.w instead

// {B9B4B3FC-2B51-4a42-B5D8-324146AFCF25}
#define PSGUID_LINK     {0xb9b4b3fc, 0x2b51, 0x4a42, 0xb5, 0xd8, 0x32, 0x41, 0x46, 0xaf, 0xcf, 0x25}
#define PID_LINK_TARGET         2
#define PID_LINK_TARGET_TYPE    3

#define PSGUID_QUERY_D {0x49691c90,0x7e17,0x101a, 0xa9,0x1c,0x08,0x00,0x2b,0x2e,0xcd,0xa9}
DEFINE_GUID(FMTID_Query, 0x49691c90,0x7e17,0x101a, 0xa9,0x1c,0x08,0x00,0x2b,0x2e,0xcd,0xa9);
#define PID_QUERY_RANK  2

// FMTID_SummaryInformation, see OLE docs for PID_ values for these
#define PSGUID_SUMMARYINFORMATION       {0xf29f85e0L, 0x4ff9, 0x1068, 0xab, 0x91, 0x08, 0x00, 0x2b, 0x27, 0xb3, 0xd9}
// FMTID_DocumentSummaryInformation, see OLE docs on the PID_ values for this
#define PSGUID_DOCUMENTSUMMARYINFORMATION {0xd5cdd502L, 0x2e9c, 0x101b, 0x93, 0x97, 0x08, 0x00, 0x2b, 0x2c, 0xf9, 0xae}

// FMTID_MediaFileSummaryInformation, see propidl.h PID_ values for this
#define PSGUID_MEDIAFILESUMMARYINFORMATION {0x64440492L, 0x4c8b, 0x11d1, 0x8b, 0x70, 0x08, 0x00, 0x36, 0xb1, 0x1a, 0x03}

// FMTID_ImageSummaryInformation
#define PSGUID_IMAGESUMMARYINFORMATION {0x6444048fL, 0x4c8b, 0x11d1, 0x8b, 0x70, 0x8, 0x00, 0x36, 0xb1, 0x1a, 0x03}

// {0E700BE1-9DB6-11d1-A1CE-00C04FD75D13}
DEFINE_GUID(IID_IEnumExtraSearch,  0xe700be1, 0x9db6, 0x11d1, 0xa1, 0xce, 0x0, 0xc0, 0x4f, 0xd7, 0x5d, 0x13);

// {FFB8655F-81B9-4fce-B89C-9A6BA76D13E7}
DEFINE_GUID(CLSID_HWShellExecute, 0xffb8655f, 0x81b9, 0x4fce, 0xb8, 0x9c, 0x9a, 0x6b, 0xa7, 0x6d, 0x13, 0xe7);

// {4657278A-411B-11d2-839A-00C04FD918D0}
DEFINE_GUID(CLSID_DragDropHelper,   0x4657278a, 0x411b, 0x11d2, 0x83, 0x9a, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);

// {3050f3BB-98b5-11cf-bb82-00aa00bdce0b}
DEFINE_GUID(CLSID_CAnchorBrowsePropertyPage, 0x3050f3BB, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b);

// {3050f3B3-98b5-11cf-bb82-00aa00bdce0b}
DEFINE_GUID(CLSID_CImageBrowsePropertyPage, 0x3050f3B3, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b);

// {3050f3B4-98b5-11cf-bb82-00aa00bdce0b}
DEFINE_GUID(CLSID_CDocBrowsePropertyPage, 0x3050f3B4, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b);

// {01E18D10-4D8B-11d2-855D-006008059367}
DEFINE_GUID(IID_IFileSystemBindData, 0x1e18d10, 0x4d8b, 0x11d2, 0x85, 0x5d, 0x0, 0x60, 0x8, 0x5, 0x93, 0x67);

// {49E1B500-4636-11d3-97F7-00C04F45D0B3}
DEFINE_GUID(SID_STopWindow, 0x49e1b500, 0x4636, 0x11d3, 0x97, 0xf7, 0x0, 0xc0, 0x4f, 0x45, 0xd0, 0xb3);

// {889A935D-971E-4B12-B90C-24DFC9E1E5E8}
DEFINE_GUID(SID_SGetViewFromViewDual, 0x889A935D, 0x971E, 0x4B12, 0xB9, 0x0C, 0x24, 0xDF, 0xC9, 0xE1, 0xE5, 0xE8);


// {FEF10FA2-355E-4e06-9381-9B24D7F7CC88}
DEFINE_GUID(CLSID_FolderItem, 0xfef10fa2, 0x355e, 0x4e06, 0x93, 0x81, 0x9b, 0x24, 0xd7, 0xf7, 0xcc, 0x88);

// {53C74826-AB99-4d33-ACA4-3117F51D3788}
DEFINE_GUID(CLSID_FolderItemsMultiLevel, 0x53c74826, 0xab99, 0x4d33, 0xac, 0xa4, 0x31, 0x17, 0xf5, 0x1d, 0x37, 0x88);

// {D969A300-E7FF-11d0-A93B-00A0C90F2719}
DEFINE_GUID(CLSID_NewMenu,0xd969a300, 0xe7ff, 0x11d0, 0xa9, 0x3b, 0x0, 0xa0, 0xc9, 0xf, 0x27, 0x19);


//  BHIDs for IShellItem::BindToHandler()


// use this for IShellFolder::BindToObject() objects; IShellFolder
//  {3981e224-f559-11d3-8e3a-00c04f6837d5}
DEFINE_GUID(BHID_SFObject, 0x3981e224, 0xf559, 0x11d3, 0x8e, 0x3a, 0x00, 0xc0, 0x4f, 0x68, 0x37, 0xd5);

// use this for IShellFolder::GetUIObject() objects; IContextMenu, IDataObject, IDropTarget, IQueryAssociation, etc.
//  {3981e225-f559-11d3-8e3a-00c04f6837d5}
DEFINE_GUID(BHID_SFUIObject, 0x3981e225, 0xf559, 0x11d3, 0x8e, 0x3a, 0x00, 0xc0, 0x4f, 0x68, 0x37, 0xd5);

// use this for IShellFolder::CreateViewObject() objects; IShellView, IDropTarget, IContextMenu
//  {3981e226-f559-11d3-8e3a-00c04f6837d5}
DEFINE_GUID(BHID_SFViewObject, 0x3981e226, 0xf559, 0x11d3, 0x8e, 0x3a, 0x00, 0xc0, 0x4f, 0x68, 0x37, 0xd5);

// use this for storage objects like IStream, IPropertyStore, IStorage
//  {3981e227-f559-11d3-8e3a-00c04f6837d5}
DEFINE_GUID(BHID_Storage, 0x3981e227, 0xf559, 0x11d3, 0x8e, 0x3a, 0x00, 0xc0, 0x4f, 0x68, 0x37, 0xd5);

// use this to get an IStream for the item
// {1CEBB3AB-7C10-499a-A417-92CA16C4CB83}
DEFINE_GUID(BHID_Stream, 0x1cebb3ab, 0x7c10, 0x499a, 0xa4, 0x17, 0x92, 0xca, 0x16, 0xc4, 0xcb, 0x83);

// use this to deref the item if it is a link to get its target item, use IShellItem
//  {3981e228-f559-11d3-8e3a-00c04f6837d5}
DEFINE_GUID(BHID_LinkTargetItem, 0x3981e228, 0xf559, 0x11d3, 0x8e, 0x3a, 0x00, 0xc0, 0x4f, 0x68, 0x37, 0xd5);

// if the item is a folder use this to get an IEnumShellItems that enumerates the storage contents
// {4621A4E3-F0D6-4773-8A9C-46E77B174840}
DEFINE_GUID(BHID_StorageEnum, 0x4621a4e3, 0xf0d6, 0x4773, 0x8a, 0x9c, 0x46, 0xe7, 0x7b, 0x17, 0x48, 0x40);

// if the item is a folder use this to get an ITransferSource or ITransferDestiation object
// {5D080304-FE2C-48fc-84CE-CF620B0F3C53}
DEFINE_GUID(BHID_Transfer, 0xd5e346a1, 0xf753, 0x4932, 0xb4, 0x3, 0x45, 0x74, 0x80, 0xe, 0x24, 0x98);

// use this to get an IPropertyStore or IPropertyStoreFactory
// to have more control over the property store for the item
// {0384e1a4-1523-439c-a4c8-ab911052f586}
DEFINE_GUID(BHID_PropertyStore, 0x0384e1a4, 0x1523, 0x439c, 0xa4, 0xc8, 0xab, 0x91, 0x10, 0x52, 0xf5, 0x86);

// use this to get IExtractImage / IThumbnailProvider for an item
// {7b2e650a-8e20-4f4a-b09e-6597afc72fb0}
DEFINE_GUID(BHID_ThumbnailHandler, 0x7b2e650a, 0x8e20, 0x4f4a, 0xb0, 0x9e, 0x65, 0x97, 0xaf, 0xc7, 0x2f, 0xb0);

// if the item is a folder use this to get an IEnumShellItems that enumerates all items
// in the folder including folders, non folders and hidden items
// {94f60519-2850-4924-aa5a-d15e84868039}
DEFINE_GUID(BHID_EnumItems, 0x94f60519, 0x2850, 0x4924, 0xaa, 0x5a, 0xd1, 0x5e, 0x84, 0x86, 0x80, 0x39);

// use this to get an IDataObject for an item or an array of items IShellItem/IShellItemArray::BindToHandler()
// {B8C0BD9F-ED24-455c-83E6-D5390C4FE8C4}
DEFINE_GUID(BHID_DataObject, 0xb8c0bd9f, 0xed24, 0x455c, 0x83, 0xe6, 0xd5, 0x39, 0xc, 0x4f, 0xe8, 0xc4);

// use this to get an IQueryAssociations for an item or an array of items IShellItem/IShellItemArray::BindToHandler()
// {bea9ef17-82f1-4f60-9284-4f8db75c3be9}
DEFINE_GUID(BHID_AssociationArray, 0xbea9ef17, 0x82f1, 0x4f60, 0x92, 0x84, 0x4f, 0x8d, 0xb7, 0x5c, 0x3b, 0xe9);

// use this to get an IFilter for an item
// {38d08778-f557-4690-9ebf-ba54706ad8f7}
DEFINE_GUID(BHID_Filter, 0x38d08778, 0xf557, 0x4690, 0x9e, 0xbf, 0xba, 0x54, 0x70, 0x6a, 0xd8, 0xf7);

#endif // _WIN32_IE >= 0x0500

#if _WIN32_IE >= 0x0600


// {faadfc40-b777-4b69-aa81-77035ef0e6e8}
DEFINE_GUID(SID_CtxQueryAssociations, 0xfaadfc40, 0xb777, 0x4b69, 0xaa, 0x81, 0x77, 0x03, 0x5e, 0xf0, 0xe6, 0xe8);

#endif // _WIN32_IE >= 0x0600


// {0x87D605E0L, 0xC511, 0x11CF, 0x89, 0xA9, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x29};
DEFINE_GUID(IID_IDocViewSite,     0x87D605E0, 0xC511, 0x11CF, 0x89, 0xA9, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x29);

// {0E5CBF21-D15F-11d0-8301-00AA005B4383}
DEFINE_GUID(CLSID_QuickLinks,           0xe5cbf21, 0xd15f, 0x11d0, 0x83, 0x1, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

// The IShellFolder band
// D82BE2B0-5764-11D0-A96E-00C04FD705A2
DEFINE_GUID(CLSID_ISFBand,              0xD82BE2B0L, 0x5764, 0x11D0, 0xA9, 0x6E, 0x00, 0xC0, 0x4F, 0xD7, 0x05, 0xA2);

// { 0x4434FF80L, 0xEF4C, 0x11CE, { 0xAE, 0x65, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62 } };
DEFINE_GUID(IID_CDefView,               0x4434FF80, 0xEF4C, 0x11CE, 0xAE, 0x65, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62 );

// {6D5313C0-8C62-11D1-B2CD-006097DF8C11}
DEFINE_GUID(CLSID_ShellFldSetExt,       0x6D5313C0, 0x8C62, 0x11D1, 0xB2,0xCD,0x00,0x60,0x97,0xDF,0x8C,0x11);

DEFINE_GUID(SID_SMenuBandChild,         0xed9cc020, 0x8b9, 0x11d1, 0x98, 0x23, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

DEFINE_GUID(SID_SMenuBandParent,        0x8c278eec, 0x3eab, 0x11d1, 0x8c, 0xb0, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);

// D1E7AFEB-6A2E-11d0-8C78-00C04FD918B4
DEFINE_GUID(SID_SMenuPopup,             0xD1E7AFEB, 0x6A2E, 0x11d0, 0x8C, 0x78, 0x0, 0xC0, 0x4F, 0xD9, 0x18, 0xB4);

// {165EBAF4-6D51-11d2-83AD-00C04FD918D0}
DEFINE_GUID(SID_SMenuBandBottomSelected, 0x165ebaf4, 0x6d51, 0x11d2, 0x83, 0xad, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);

DEFINE_GUID(SID_SMenuBandBottom,        0x743ca664, 0xdeb, 0x11d1, 0x98, 0x25, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {A6C17EB4-2D65-11d2-838F-00C04FD918D0}
DEFINE_GUID(SID_MenuShellFolder,   0xa6c17eb4, 0x2d65, 0x11d2, 0x83, 0x8f, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);

// {39545874-7162-465e-b783-2aa1874fef81}
DEFINE_GUID(SID_SMenuBandContextMenuModifier, 0x39545874, 0x7162, 0x465e, 0xb7, 0x83, 0x2a, 0xa1, 0x87, 0x4f, 0xef, 0x81);

// {164BBD86-1D0D-4de0-9A3B-D9729647C2B8}
DEFINE_GUID(SID_SMenuBandBKContextMenu, 0x164bbd86, 0x1d0d, 0x4de0, 0x9a, 0x3b, 0xd9, 0x72, 0x96, 0x47, 0xc2, 0xb8);

//Command Group ID for MenuDeskBar
// {5C9F0A12-959E-11d0-A3A4-00A0C9082636}
DEFINE_GUID(CGID_MENUDESKBAR,0x5c9f0a12, 0x959e, 0x11d0, 0xa3, 0xa4, 0x0, 0xa0, 0xc9, 0x8, 0x26, 0x36);

DEFINE_GUID(SID_SMenuBandTop,           0x9493a810, 0xec38, 0x11d0, 0xbc, 0x46, 0x0, 0xaa, 0x0, 0x6c, 0xe2, 0xf5);

// {40B96610-B522-11d1-B3B4-00AA006EFDE7}
DEFINE_GUID(CLSID_MenuToolbarBase,      0x40b96610, 0xb522, 0x11d1, 0xb3, 0xb4, 0x0, 0xaa, 0x0, 0x6e, 0xfd, 0xe7);

// {596A9A94-013E-11d1-8D34-00A0C90F2719}
DEFINE_GUID(IID_IBanneredBar,0x596a9a94, 0x13e, 0x11d1, 0x8d, 0x34, 0x0, 0xa0, 0xc9, 0xf, 0x27, 0x19);

// {E13EF4E4-D2F2-11d0-9816-00C04FD91972}
DEFINE_GUID(CLSID_MenuBandSite,             0xe13ef4e4, 0xd2f2, 0x11d0, 0x98, 0x16, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {80F30233-B7DF-11d2-A33B-006097DF5BD4}
DEFINE_GUID(SID_SCommDlgBrowser, 0x80f30233, 0xb7df, 0x11d2, 0xa3, 0x3b, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4);


//
// These GUIDs may be assigned to the CREDENTIAL_PROVIDER_FIELD_DESCRIPTOR::guidFieldType
// member by Microsoft ICredentialProvider implementations.
//

// {da15bbe8-954sd-4fd3-b0f4-1fb5b90b174b}
DEFINE_GUID(CPFG_LOGON_USERNAME, 0xda15bbe8, 0x954d, 0x4fd3, 0xb0, 0xf4, 0x1f, 0xb5, 0xb9, 0x0b, 0x17, 0x4b);

// {60624cfa-a477-47b1-8a8e-3a4a19981827}
DEFINE_GUID(CPFG_LOGON_PASSWORD, 0x60624cfa, 0xa477, 0x47b1, 0x8a, 0x8e, 0x3a, 0x4a, 0x19, 0x98, 0x18, 0x27);

// {3e1ecf69-568c-4d96-9d59-46444174e2d6}
DEFINE_GUID(CPFG_SMARTCARD_USERNAME, 0x3e1ecf69, 0x568c, 0x4d96, 0x9d, 0x59, 0x46, 0x44, 0x41, 0x74, 0xe2, 0xd6);

// {4fe5263b-9181-46c1-b0a4-9dedd4db7dea}
DEFINE_GUID(CPFG_SMARTCARD_PIN, 0x4fe5263b, 0x9181, 0x46c1, 0xb0, 0xa4, 0x9d, 0xed, 0xd4, 0xdb, 0x7d, 0xea);


//
//  Known Folder IDs
//
#include <knownfolders.h>


// some known folder types

// default value == GUID_NULL
// FOLDERTYPEID_NotSpecified:         {5c4f28b5-f869-4e84-8e60-f11db97c5cc7}
DEFINE_GUID(FOLDERTYPEID_NotSpecified,         0x5c4f28b5, 0xf869, 0x4e84, 0x8e, 0x60, 0xf1, 0x1d, 0xb9, 0x7c, 0x5c, 0xc7);

// FOLDERTYPEID_Invalid:              {57807898-8c4f-4462-bb63-71042380b109}
DEFINE_GUID(FOLDERTYPEID_Invalid,              0x57807898, 0x8c4f, 0x4462, 0xbb, 0x63, 0x71, 0x04, 0x23, 0x80, 0xb1, 0x09);

// typically under FOLDERID_Documents
// FOLDERTYPEID_Documents:            {7d49d726-3c21-4f05-99aa-fdc2c9474656}
DEFINE_GUID(FOLDERTYPEID_Documents,            0x7d49d726, 0x3c21, 0x4f05, 0x99, 0xaa, 0xfd, 0xc2, 0xc9, 0x47, 0x46, 0x56);

// typically under FOLDERID_Pictures, where there's fewer images
// FOLDERTYPEID_Pictures:             {b3690e58-e961-423b-b687-386ebfd83239}
DEFINE_GUID(FOLDERTYPEID_Pictures,             0xb3690e58, 0xe961, 0x423b, 0xb6, 0x87, 0x38, 0x6e, 0xbf, 0xd8, 0x32, 0x39);

// typically under FOLDERID_Music, where there's many songs in a list
// FOLDERTYPEID_MusicDetails:         {af9c03d6-7db9-4a15-9464-13bf9fb69a2a}
DEFINE_GUID(FOLDERTYPEID_MusicDetails,         0xaf9c03d6, 0x7db9, 0x4a15, 0x94, 0x64, 0x13, 0xbf, 0x9f, 0xb6, 0x9a, 0x2a);

// typically under FOLDERID_Music, where we're displaying a set of folders
// FOLDERTYPEID_MusicIcons:           {0b7467fb-84ba-4aae-a09b-15b71097af9e}
DEFINE_GUID(FOLDERTYPEID_MusicIcons,           0x0b7467fb, 0x84ba, 0x4aae, 0xa0, 0x9b, 0x15, 0xb7, 0x10, 0x97, 0xaf, 0x9e);

// FOLDERTYPEID_Games Folder {b689b0d0-76d3-4cbb-87f7-585d0e0ce070}
DEFINE_GUID(FOLDERTYPEID_Games, 0xb689b0d0, 0x76d3, 0x4cbb, 0x87, 0xf7, 0x58, 0x5d, 0x0e, 0x0c, 0xe0, 0x70);

// category view of control panel
// FOLDERTYPEID_ControlPanelCategory: {de4f0660-fa10-4b8f-a494-068b20b22307}
DEFINE_GUID(FOLDERTYPEID_ControlPanelCategory, 0xde4f0660, 0xfa10, 0x4b8f, 0xa4, 0x94, 0x06, 0x8b, 0x20, 0xb2, 0x23, 0x07);

// classic-mode control panel
// FOLDERTYPEID_ControlPanelClassic:  {0c3794f3-b545-43aa-a329-c37430c58d2a}
DEFINE_GUID(FOLDERTYPEID_ControlPanelClassic,  0x0c3794f3, 0xb545, 0x43aa, 0xa3, 0x29, 0xc3, 0x74, 0x30, 0xc5, 0x8d, 0x2a);

// prnfldr
// FOLDERTYPEID_Printers:             {2c7bbec6-c844-4a0a-91fa-cef6f59cfda1}
DEFINE_GUID(FOLDERTYPEID_Printers,             0x2c7bbec6, 0xc844, 0x4a0a, 0x91, 0xfa, 0xce, 0xf6, 0xf5, 0x9c, 0xfd, 0xa1);

// bbckfldr
// FOLDERTYPEID_RecycleBin:           {d6d9e004-cd87-442b-9d57-5e0aeb4f6f72}
DEFINE_GUID(FOLDERTYPEID_RecycleBin,           0xd6d9e004, 0xcd87, 0x442b, 0x9d, 0x57, 0x5e, 0x0a, 0xeb, 0x4f, 0x6f, 0x72);

// software explorer for ARP
// FOLDERTYPEID_SoftwareExplorer:     {d674391b-52d9-4e07-834e-67c98610f39d}
DEFINE_GUID(FOLDERTYPEID_SoftwareExplorer,     0xd674391b, 0x52d9, 0x4e07, 0x83, 0x4e, 0x67, 0xc9, 0x86, 0x10, 0xf3, 0x9d);

// ZIP folders
// FOLDERTYPEID_CompressedFolder:     {80213e82-bcfd-4c4f-8817-bb27601267a9}
DEFINE_GUID(FOLDERTYPEID_CompressedFolder,     0x80213e82, 0xbcfd, 0x4c4f, 0x88, 0x17, 0xbb, 0x27, 0x60, 0x12, 0x67, 0xa9);

// this only needs to be defined here because it's used by the multimedia depot
// contact folders under FOLDERID_Contacts
// FOLDERTYPEID_Contacts:             {de2b70ec-9bf7-4a93-bd3d-243f7881d492}
DEFINE_GUID(FOLDERTYPEID_Contacts,             0xde2b70ec, 0x9bf7, 0x4a93, 0xbd, 0x3d, 0x24, 0x3f, 0x78, 0x81, 0xd4, 0x92);

// default library views that don't have a more specific template
// FOLDERTYPEID_Library:              {4badfc68-c4ac-4716-a0a0-4d5daa6b0f3e}
DEFINE_GUID(FOLDERTYPEID_Library,              0x4badfc68, 0xc4ac, 0x4716, 0xa0, 0xa0, 0x4d, 0x5d, 0xaa, 0x6b, 0x0f, 0x3e);

// NetworkExplorerFolder
// FOLDERTYPEID_NetworkExplorer:      {25CC242B-9A7C-4f51-80E0-7A2928FEBE42}
DEFINE_GUID(FOLDERTYPEID_NetworkExplorer,      0x25cc242b, 0x9a7c, 0x4f51, 0x80, 0xe0, 0x7a, 0x29, 0x28, 0xfe, 0xbe, 0x42);

// User files folder
// FOLDERTYPEID_UserFiles:            {CD0FC69B-71E2-46e5-9690-5BCD9F57AAB3}
DEFINE_GUID(FOLDERTYPEID_UserFiles,            0xcd0fc69b, 0x71e2, 0x46e5, 0x96, 0x90, 0x5b, 0xcd, 0x9f, 0x57, 0xaa, 0xb3);


//
// Sync Manager object IDs.  These are GUIDs used in calls to the GetObject()
// method on ISyncMgrHandler and ISyncMgrSyncItem, defined in SyncMgr.idl.
//

// {6DBC85C3-5D07-4c72-A777-7FEC78072C06}
DEFINE_GUID(SYNCMGR_OBJECTID_Icon, 0x6dbc85c3, 0x5d07, 0x4c72, 0xa7, 0x77, 0x7f, 0xec, 0x78, 0x7, 0x2c, 0x6);

// {4BEF34B9-A786-4075-BA88-0C2B9D89A98F}
DEFINE_GUID(SYNCMGR_OBJECTID_EventStore, 0x4bef34b9, 0xa786, 0x4075, 0xba, 0x88, 0xc, 0x2b, 0x9d, 0x89, 0xa9, 0x8f);

// {D78181F4-2389-47e4-A960-60BCC2ED930B}
DEFINE_GUID(SYNCMGR_OBJECTID_ConflictStore, 0xd78181f4, 0x2389, 0x47e4, 0xa9, 0x60, 0x60, 0xbc, 0xc2, 0xed, 0x93, 0xb);

// {57CBB584-E9B4-47ae-A120-C4DF3335DEE2}
DEFINE_GUID(SYNCMGR_OBJECTID_BrowseContent, 0x57cbb584, 0xe9b4, 0x47ae, 0xa1, 0x20, 0xc4, 0xdf, 0x33, 0x35, 0xde, 0xe2);

// {EDC6F3E3-8441-4109-ADF3-6C1CA0B7DE47}
DEFINE_GUID(SYNCMGR_OBJECTID_ShowSchedule, 0xedc6f3e3, 0x8441, 0x4109, 0xad, 0xf3, 0x6c, 0x1c, 0xa0, 0xb7, 0xde, 0x47);

// {D882D80B-E7AA-49ed-86B7-E6E1F714CDFE}
DEFINE_GUID(SYNCMGR_OBJECTID_QueryBeforeActivate, 0xd882d80b, 0xe7aa, 0x49ed, 0x86, 0xb7, 0xe6, 0xe1, 0xf7, 0x14, 0xcd, 0xfe);

// {A0EFC282-60E0-460e-9374-EA88513CFC80}
DEFINE_GUID(SYNCMGR_OBJECTID_QueryBeforeDeactivate, 0xa0efc282, 0x60e0, 0x460e, 0x93, 0x74, 0xea, 0x88, 0x51, 0x3c, 0xfc, 0x80);

// {04CBF7F0-5BEB-4de1-BC90-908345C480F6}
DEFINE_GUID(SYNCMGR_OBJECTID_QueryBeforeEnable, 0x4cbf7f0, 0x5beb, 0x4de1, 0xbc, 0x90, 0x90, 0x83, 0x45, 0xc4, 0x80, 0xf6);

// {BB5F64AA-F004-4eb5-8E4D-26751966344C}
DEFINE_GUID(SYNCMGR_OBJECTID_QueryBeforeDisable, 0xbb5f64aa, 0xf004, 0x4eb5, 0x8e, 0x4d, 0x26, 0x75, 0x19, 0x66, 0x34, 0x4c);

// {F76C3397-AFB3-45d7-A59F-5A49E905437E}
DEFINE_GUID(SYNCMGR_OBJECTID_QueryBeforeDelete, 0xf76c3397, 0xafb3, 0x45d7, 0xa5, 0x9f, 0x5a, 0x49, 0xe9, 0x5, 0x43, 0x7e);

// {2203bdc1-1af1-4082-8c30-28399f41384c}
DEFINE_GUID(SYNCMGR_OBJECTID_EventLinkClick, 0x2203bdc1, 0x1af1, 0x4082, 0x8c, 0x30, 0x28, 0x39, 0x9f, 0x41, 0x38, 0x4c);

// IExplorerPaneVisibility constants
DEFINE_GUID(EP_NavPane,           0xcb316b22, 0x25f7, 0x42b8, 0x8a, 0x09, 0x54, 0x0d, 0x23, 0xa4, 0x3c, 0x2f);
DEFINE_GUID(EP_Commands,          0xd9745868, 0xca5f, 0x4a76, 0x91, 0xcd, 0xf5, 0xa1, 0x29, 0xfb, 0xb0, 0x76);
DEFINE_GUID(EP_Commands_Organize, 0x72e81700, 0xe3ec, 0x4660, 0xbf, 0x24, 0x3c, 0x3b, 0x7b, 0x64, 0x88, 0x06);
DEFINE_GUID(EP_Commands_View,     0x21f7c32d, 0xeeaa, 0x439b, 0xbb, 0x51, 0x37, 0xb9, 0x6f, 0xd6, 0xa9, 0x43);
DEFINE_GUID(EP_DetailsPane,       0x43abf98b, 0x89b8, 0x472d, 0xb9, 0xce, 0xe6, 0x9b, 0x82, 0x29, 0xf0, 0x19);
DEFINE_GUID(EP_PreviewPane,       0x893c63d1, 0x45c8, 0x4d17, 0xbe, 0x19, 0x22, 0x3b, 0xe7, 0x1b, 0xe3, 0x65);
DEFINE_GUID(EP_QueryPane,         0x65bcde4f, 0x4f07, 0x4f27, 0x83, 0xa7, 0x1a, 0xfc, 0xa4, 0xdf, 0x7d, 0xdd);
DEFINE_GUID(EP_AdvQueryPane,      0xb4e9db8b, 0x34ba, 0x4c39, 0xb5, 0xcc, 0x16, 0xa1, 0xbd, 0x2c, 0x41, 0x1c);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\ShlDisp.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for shldisp.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __shldisp_h__
#define __shldisp_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IFolderViewOC_FWD_DEFINED__
#define __IFolderViewOC_FWD_DEFINED__
typedef interface IFolderViewOC IFolderViewOC;
#endif 	/* __IFolderViewOC_FWD_DEFINED__ */


#ifndef __DShellFolderViewEvents_FWD_DEFINED__
#define __DShellFolderViewEvents_FWD_DEFINED__
typedef interface DShellFolderViewEvents DShellFolderViewEvents;
#endif 	/* __DShellFolderViewEvents_FWD_DEFINED__ */


#ifndef __ShellFolderViewOC_FWD_DEFINED__
#define __ShellFolderViewOC_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellFolderViewOC ShellFolderViewOC;
#else
typedef struct ShellFolderViewOC ShellFolderViewOC;
#endif /* __cplusplus */

#endif 	/* __ShellFolderViewOC_FWD_DEFINED__ */


#ifndef __DFConstraint_FWD_DEFINED__
#define __DFConstraint_FWD_DEFINED__
typedef interface DFConstraint DFConstraint;
#endif 	/* __DFConstraint_FWD_DEFINED__ */


#ifndef __FolderItem_FWD_DEFINED__
#define __FolderItem_FWD_DEFINED__
typedef interface FolderItem FolderItem;
#endif 	/* __FolderItem_FWD_DEFINED__ */


#ifndef __FolderItems_FWD_DEFINED__
#define __FolderItems_FWD_DEFINED__
typedef interface FolderItems FolderItems;
#endif 	/* __FolderItems_FWD_DEFINED__ */


#ifndef __FolderItemVerb_FWD_DEFINED__
#define __FolderItemVerb_FWD_DEFINED__
typedef interface FolderItemVerb FolderItemVerb;
#endif 	/* __FolderItemVerb_FWD_DEFINED__ */


#ifndef __FolderItemVerbs_FWD_DEFINED__
#define __FolderItemVerbs_FWD_DEFINED__
typedef interface FolderItemVerbs FolderItemVerbs;
#endif 	/* __FolderItemVerbs_FWD_DEFINED__ */


#ifndef __Folder_FWD_DEFINED__
#define __Folder_FWD_DEFINED__
typedef interface Folder Folder;
#endif 	/* __Folder_FWD_DEFINED__ */


#ifndef __Folder2_FWD_DEFINED__
#define __Folder2_FWD_DEFINED__
typedef interface Folder2 Folder2;
#endif 	/* __Folder2_FWD_DEFINED__ */


#ifndef __Folder3_FWD_DEFINED__
#define __Folder3_FWD_DEFINED__
typedef interface Folder3 Folder3;
#endif 	/* __Folder3_FWD_DEFINED__ */


#ifndef __FolderItem2_FWD_DEFINED__
#define __FolderItem2_FWD_DEFINED__
typedef interface FolderItem2 FolderItem2;
#endif 	/* __FolderItem2_FWD_DEFINED__ */


#ifndef __ShellFolderItem_FWD_DEFINED__
#define __ShellFolderItem_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellFolderItem ShellFolderItem;
#else
typedef struct ShellFolderItem ShellFolderItem;
#endif /* __cplusplus */

#endif 	/* __ShellFolderItem_FWD_DEFINED__ */


#ifndef __FolderItems2_FWD_DEFINED__
#define __FolderItems2_FWD_DEFINED__
typedef interface FolderItems2 FolderItems2;
#endif 	/* __FolderItems2_FWD_DEFINED__ */


#ifndef __FolderItems3_FWD_DEFINED__
#define __FolderItems3_FWD_DEFINED__
typedef interface FolderItems3 FolderItems3;
#endif 	/* __FolderItems3_FWD_DEFINED__ */


#ifndef __IShellLinkDual_FWD_DEFINED__
#define __IShellLinkDual_FWD_DEFINED__
typedef interface IShellLinkDual IShellLinkDual;
#endif 	/* __IShellLinkDual_FWD_DEFINED__ */


#ifndef __IShellLinkDual2_FWD_DEFINED__
#define __IShellLinkDual2_FWD_DEFINED__
typedef interface IShellLinkDual2 IShellLinkDual2;
#endif 	/* __IShellLinkDual2_FWD_DEFINED__ */


#ifndef __ShellLinkObject_FWD_DEFINED__
#define __ShellLinkObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellLinkObject ShellLinkObject;
#else
typedef struct ShellLinkObject ShellLinkObject;
#endif /* __cplusplus */

#endif 	/* __ShellLinkObject_FWD_DEFINED__ */


#ifndef __IShellFolderViewDual_FWD_DEFINED__
#define __IShellFolderViewDual_FWD_DEFINED__
typedef interface IShellFolderViewDual IShellFolderViewDual;
#endif 	/* __IShellFolderViewDual_FWD_DEFINED__ */


#ifndef __IShellFolderViewDual2_FWD_DEFINED__
#define __IShellFolderViewDual2_FWD_DEFINED__
typedef interface IShellFolderViewDual2 IShellFolderViewDual2;
#endif 	/* __IShellFolderViewDual2_FWD_DEFINED__ */


#ifndef __IShellFolderViewDual3_FWD_DEFINED__
#define __IShellFolderViewDual3_FWD_DEFINED__
typedef interface IShellFolderViewDual3 IShellFolderViewDual3;
#endif 	/* __IShellFolderViewDual3_FWD_DEFINED__ */


#ifndef __ShellFolderView_FWD_DEFINED__
#define __ShellFolderView_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellFolderView ShellFolderView;
#else
typedef struct ShellFolderView ShellFolderView;
#endif /* __cplusplus */

#endif 	/* __ShellFolderView_FWD_DEFINED__ */


#ifndef __IShellDispatch_FWD_DEFINED__
#define __IShellDispatch_FWD_DEFINED__
typedef interface IShellDispatch IShellDispatch;
#endif 	/* __IShellDispatch_FWD_DEFINED__ */


#ifndef __IShellDispatch2_FWD_DEFINED__
#define __IShellDispatch2_FWD_DEFINED__
typedef interface IShellDispatch2 IShellDispatch2;
#endif 	/* __IShellDispatch2_FWD_DEFINED__ */


#ifndef __IShellDispatch3_FWD_DEFINED__
#define __IShellDispatch3_FWD_DEFINED__
typedef interface IShellDispatch3 IShellDispatch3;
#endif 	/* __IShellDispatch3_FWD_DEFINED__ */


#ifndef __IShellDispatch4_FWD_DEFINED__
#define __IShellDispatch4_FWD_DEFINED__
typedef interface IShellDispatch4 IShellDispatch4;
#endif 	/* __IShellDispatch4_FWD_DEFINED__ */


#ifndef __IShellDispatch5_FWD_DEFINED__
#define __IShellDispatch5_FWD_DEFINED__
typedef interface IShellDispatch5 IShellDispatch5;
#endif 	/* __IShellDispatch5_FWD_DEFINED__ */


#ifndef __Shell_FWD_DEFINED__
#define __Shell_FWD_DEFINED__

#ifdef __cplusplus
typedef class Shell Shell;
#else
typedef struct Shell Shell;
#endif /* __cplusplus */

#endif 	/* __Shell_FWD_DEFINED__ */


#ifndef __ShellDispatchInproc_FWD_DEFINED__
#define __ShellDispatchInproc_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellDispatchInproc ShellDispatchInproc;
#else
typedef struct ShellDispatchInproc ShellDispatchInproc;
#endif /* __cplusplus */

#endif 	/* __ShellDispatchInproc_FWD_DEFINED__ */


#ifndef __IFileSearchBand_FWD_DEFINED__
#define __IFileSearchBand_FWD_DEFINED__
typedef interface IFileSearchBand IFileSearchBand;
#endif 	/* __IFileSearchBand_FWD_DEFINED__ */


#ifndef __FileSearchBand_FWD_DEFINED__
#define __FileSearchBand_FWD_DEFINED__

#ifdef __cplusplus
typedef class FileSearchBand FileSearchBand;
#else
typedef struct FileSearchBand FileSearchBand;
#endif /* __cplusplus */

#endif 	/* __FileSearchBand_FWD_DEFINED__ */


#ifndef __IWebWizardHost_FWD_DEFINED__
#define __IWebWizardHost_FWD_DEFINED__
typedef interface IWebWizardHost IWebWizardHost;
#endif 	/* __IWebWizardHost_FWD_DEFINED__ */


#ifndef __INewWDEvents_FWD_DEFINED__
#define __INewWDEvents_FWD_DEFINED__
typedef interface INewWDEvents INewWDEvents;
#endif 	/* __INewWDEvents_FWD_DEFINED__ */


#ifndef __IAutoComplete_FWD_DEFINED__
#define __IAutoComplete_FWD_DEFINED__
typedef interface IAutoComplete IAutoComplete;
#endif 	/* __IAutoComplete_FWD_DEFINED__ */


#ifndef __IAutoComplete2_FWD_DEFINED__
#define __IAutoComplete2_FWD_DEFINED__
typedef interface IAutoComplete2 IAutoComplete2;
#endif 	/* __IAutoComplete2_FWD_DEFINED__ */


#ifndef __IEnumACString_FWD_DEFINED__
#define __IEnumACString_FWD_DEFINED__
typedef interface IEnumACString IEnumACString;
#endif 	/* __IEnumACString_FWD_DEFINED__ */


#ifndef __IAsyncOperation_FWD_DEFINED__
#define __IAsyncOperation_FWD_DEFINED__
typedef interface IAsyncOperation IAsyncOperation;
#endif 	/* __IAsyncOperation_FWD_DEFINED__ */


/* header files for imported files */
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_shldisp_0000_0000 */
/* [local] */ 


#pragma once


extern RPC_IF_HANDLE __MIDL_itf_shldisp_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shldisp_0000_0000_v0_0_s_ifspec;


#ifndef __Shell32_LIBRARY_DEFINED__
#define __Shell32_LIBRARY_DEFINED__

/* library Shell32 */
/* [version][lcid][helpstring][uuid] */ 





typedef /* [helpstring][uuid] */  DECLSPEC_UUID("35f1a0d0-3e9a-11d2-8499-005345000000") 
enum OfflineFolderStatus
    {	OFS_INACTIVE	= -1,
	OFS_ONLINE	= ( OFS_INACTIVE + 1 ) ,
	OFS_OFFLINE	= ( OFS_ONLINE + 1 ) ,
	OFS_SERVERBACK	= ( OFS_OFFLINE + 1 ) ,
	OFS_DIRTYCACHE	= ( OFS_SERVERBACK + 1 ) 
    } 	OfflineFolderStatus;

typedef /* [helpstring][uuid] */  DECLSPEC_UUID("742A99A0-C77E-11D0-A32C-00A0C91EEDBA") 
enum ShellFolderViewOptions
    {	SFVVO_SHOWALLOBJECTS	= 0x1,
	SFVVO_SHOWEXTENSIONS	= 0x2,
	SFVVO_SHOWCOMPCOLOR	= 0x8,
	SFVVO_SHOWSYSFILES	= 0x20,
	SFVVO_WIN95CLASSIC	= 0x40,
	SFVVO_DOUBLECLICKINWEBVIEW	= 0x80,
	SFVVO_DESKTOPHTML	= 0x200
    } 	ShellFolderViewOptions;

typedef /* [helpstring][uuid] */  DECLSPEC_UUID("CA31EA20-48D0-11CF-8350-444553540000") 
enum ShellSpecialFolderConstants
    {	ssfDESKTOP	= 0,
	ssfPROGRAMS	= 0x2,
	ssfCONTROLS	= 0x3,
	ssfPRINTERS	= 0x4,
	ssfPERSONAL	= 0x5,
	ssfFAVORITES	= 0x6,
	ssfSTARTUP	= 0x7,
	ssfRECENT	= 0x8,
	ssfSENDTO	= 0x9,
	ssfBITBUCKET	= 0xa,
	ssfSTARTMENU	= 0xb,
	ssfDESKTOPDIRECTORY	= 0x10,
	ssfDRIVES	= 0x11,
	ssfNETWORK	= 0x12,
	ssfNETHOOD	= 0x13,
	ssfFONTS	= 0x14,
	ssfTEMPLATES	= 0x15,
	ssfCOMMONSTARTMENU	= 0x16,
	ssfCOMMONPROGRAMS	= 0x17,
	ssfCOMMONSTARTUP	= 0x18,
	ssfCOMMONDESKTOPDIR	= 0x19,
	ssfAPPDATA	= 0x1a,
	ssfPRINTHOOD	= 0x1b,
	ssfLOCALAPPDATA	= 0x1c,
	ssfALTSTARTUP	= 0x1d,
	ssfCOMMONALTSTARTUP	= 0x1e,
	ssfCOMMONFAVORITES	= 0x1f,
	ssfINTERNETCACHE	= 0x20,
	ssfCOOKIES	= 0x21,
	ssfHISTORY	= 0x22,
	ssfCOMMONAPPDATA	= 0x23,
	ssfWINDOWS	= 0x24,
	ssfSYSTEM	= 0x25,
	ssfPROGRAMFILES	= 0x26,
	ssfMYPICTURES	= 0x27,
	ssfPROFILE	= 0x28,
	ssfSYSTEMx86	= 0x29,
	ssfPROGRAMFILESx86	= 0x30
    } 	ShellSpecialFolderConstants;


EXTERN_C const IID LIBID_Shell32;

#ifndef __IFolderViewOC_INTERFACE_DEFINED__
#define __IFolderViewOC_INTERFACE_DEFINED__

/* interface IFolderViewOC */
/* [object][dual][oleautomation][hidden][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IFolderViewOC;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9BA05970-F6A8-11CF-A442-00A0C90A8F39")
    IFolderViewOC : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE SetFolderView( 
            /* [in] */ __RPC__in_opt IDispatch *pdisp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFolderViewOCVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFolderViewOC * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFolderViewOC * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFolderViewOC * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFolderViewOC * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFolderViewOC * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFolderViewOC * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFolderViewOC * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetFolderView )( 
            IFolderViewOC * This,
            /* [in] */ __RPC__in_opt IDispatch *pdisp);
        
        END_INTERFACE
    } IFolderViewOCVtbl;

    interface IFolderViewOC
    {
        CONST_VTBL struct IFolderViewOCVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFolderViewOC_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFolderViewOC_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFolderViewOC_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFolderViewOC_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IFolderViewOC_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IFolderViewOC_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IFolderViewOC_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IFolderViewOC_SetFolderView(This,pdisp)	\
    ( (This)->lpVtbl -> SetFolderView(This,pdisp) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFolderViewOC_INTERFACE_DEFINED__ */


#ifndef __DShellFolderViewEvents_DISPINTERFACE_DEFINED__
#define __DShellFolderViewEvents_DISPINTERFACE_DEFINED__

/* dispinterface DShellFolderViewEvents */
/* [helpstring][uuid] */ 


EXTERN_C const IID DIID_DShellFolderViewEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("62112AA2-EBE4-11cf-A5FB-0020AFE7292D")
    DShellFolderViewEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct DShellFolderViewEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            DShellFolderViewEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            DShellFolderViewEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            DShellFolderViewEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            DShellFolderViewEvents * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            DShellFolderViewEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            DShellFolderViewEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            DShellFolderViewEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } DShellFolderViewEventsVtbl;

    interface DShellFolderViewEvents
    {
        CONST_VTBL struct DShellFolderViewEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DShellFolderViewEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define DShellFolderViewEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define DShellFolderViewEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define DShellFolderViewEvents_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define DShellFolderViewEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define DShellFolderViewEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define DShellFolderViewEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __DShellFolderViewEvents_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_ShellFolderViewOC;

#ifdef __cplusplus

class DECLSPEC_UUID("9BA05971-F6A8-11CF-A442-00A0C90A8F39")
ShellFolderViewOC;
#endif

#ifndef __DFConstraint_INTERFACE_DEFINED__
#define __DFConstraint_INTERFACE_DEFINED__

/* interface DFConstraint */
/* [object][dual][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_DFConstraint;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4a3df050-23bd-11d2-939f-00a0c91eedba")
    DFConstraint : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbs) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [retval][out] */ __RPC__out VARIANT *pv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct DFConstraintVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            DFConstraint * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            DFConstraint * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            DFConstraint * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            DFConstraint * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            DFConstraint * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            DFConstraint * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            DFConstraint * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            DFConstraint * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Value )( 
            DFConstraint * This,
            /* [retval][out] */ __RPC__out VARIANT *pv);
        
        END_INTERFACE
    } DFConstraintVtbl;

    interface DFConstraint
    {
        CONST_VTBL struct DFConstraintVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DFConstraint_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define DFConstraint_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define DFConstraint_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define DFConstraint_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define DFConstraint_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define DFConstraint_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define DFConstraint_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define DFConstraint_get_Name(This,pbs)	\
    ( (This)->lpVtbl -> get_Name(This,pbs) ) 

#define DFConstraint_get_Value(This,pv)	\
    ( (This)->lpVtbl -> get_Value(This,pv) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __DFConstraint_INTERFACE_DEFINED__ */


#ifndef __FolderItem_INTERFACE_DEFINED__
#define __FolderItem_INTERFACE_DEFINED__

/* interface FolderItem */
/* [object][dual][oleautomation][helpstring][uuid] */ 

typedef /* [unique] */  __RPC_unique_pointer FolderItem *LPFOLDERITEM;


EXTERN_C const IID IID_FolderItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAC32C80-CBE4-11CE-8350-444553540000")
    FolderItem : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbs) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ __RPC__in BSTR bs) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Path( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbs) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_GetLink( 
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_GetFolder( 
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_IsLink( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pb) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_IsFolder( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pb) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_IsFileSystem( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pb) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_IsBrowsable( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pb) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ModifyDate( 
            /* [retval][out] */ __RPC__out DATE *pdt) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_ModifyDate( 
            /* [in] */ DATE dt) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Size( 
            /* [retval][out] */ __RPC__out LONG *pul) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbs) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Verbs( 
            /* [retval][out] */ __RPC__deref_out_opt FolderItemVerbs **ppfic) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InvokeVerb( 
            /* [optional][in] */ VARIANT vVerb) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct FolderItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            FolderItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            FolderItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            FolderItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            FolderItem * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            FolderItem * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            FolderItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            FolderItem * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Application )( 
            FolderItem * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            FolderItem * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            FolderItem * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbs);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            FolderItem * This,
            /* [in] */ __RPC__in BSTR bs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Path )( 
            FolderItem * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GetLink )( 
            FolderItem * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GetFolder )( 
            FolderItem * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsLink )( 
            FolderItem * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pb);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsFolder )( 
            FolderItem * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pb);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsFileSystem )( 
            FolderItem * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pb);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsBrowsable )( 
            FolderItem * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pb);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ModifyDate )( 
            FolderItem * This,
            /* [retval][out] */ __RPC__out DATE *pdt);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ModifyDate )( 
            FolderItem * This,
            /* [in] */ DATE dt);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Size )( 
            FolderItem * This,
            /* [retval][out] */ __RPC__out LONG *pul);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            FolderItem * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbs);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Verbs )( 
            FolderItem * This,
            /* [retval][out] */ __RPC__deref_out_opt FolderItemVerbs **ppfic);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *InvokeVerb )( 
            FolderItem * This,
            /* [optional][in] */ VARIANT vVerb);
        
        END_INTERFACE
    } FolderItemVtbl;

    interface FolderItem
    {
        CONST_VTBL struct FolderItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define FolderItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define FolderItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define FolderItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define FolderItem_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define FolderItem_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define FolderItem_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define FolderItem_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define FolderItem_get_Application(This,ppid)	\
    ( (This)->lpVtbl -> get_Application(This,ppid) ) 

#define FolderItem_get_Parent(This,ppid)	\
    ( (This)->lpVtbl -> get_Parent(This,ppid) ) 

#define FolderItem_get_Name(This,pbs)	\
    ( (This)->lpVtbl -> get_Name(This,pbs) ) 

#define FolderItem_put_Name(This,bs)	\
    ( (This)->lpVtbl -> put_Name(This,bs) ) 

#define FolderItem_get_Path(This,pbs)	\
    ( (This)->lpVtbl -> get_Path(This,pbs) ) 

#define FolderItem_get_GetLink(This,ppid)	\
    ( (This)->lpVtbl -> get_GetLink(This,ppid) ) 

#define FolderItem_get_GetFolder(This,ppid)	\
    ( (This)->lpVtbl -> get_GetFolder(This,ppid) ) 

#define FolderItem_get_IsLink(This,pb)	\
    ( (This)->lpVtbl -> get_IsLink(This,pb) ) 

#define FolderItem_get_IsFolder(This,pb)	\
    ( (This)->lpVtbl -> get_IsFolder(This,pb) ) 

#define FolderItem_get_IsFileSystem(This,pb)	\
    ( (This)->lpVtbl -> get_IsFileSystem(This,pb) ) 

#define FolderItem_get_IsBrowsable(This,pb)	\
    ( (This)->lpVtbl -> get_IsBrowsable(This,pb) ) 

#define FolderItem_get_ModifyDate(This,pdt)	\
    ( (This)->lpVtbl -> get_ModifyDate(This,pdt) ) 

#define FolderItem_put_ModifyDate(This,dt)	\
    ( (This)->lpVtbl -> put_ModifyDate(This,dt) ) 

#define FolderItem_get_Size(This,pul)	\
    ( (This)->lpVtbl -> get_Size(This,pul) ) 

#define FolderItem_get_Type(This,pbs)	\
    ( (This)->lpVtbl -> get_Type(This,pbs) ) 

#define FolderItem_Verbs(This,ppfic)	\
    ( (This)->lpVtbl -> Verbs(This,ppfic) ) 

#define FolderItem_InvokeVerb(This,vVerb)	\
    ( (This)->lpVtbl -> InvokeVerb(This,vVerb) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __FolderItem_INTERFACE_DEFINED__ */


#ifndef __FolderItems_INTERFACE_DEFINED__
#define __FolderItems_INTERFACE_DEFINED__

/* interface FolderItems */
/* [object][dual][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_FolderItems;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("744129E0-CBE5-11CE-8350-444553540000")
    FolderItems : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *plCount) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [optional][in] */ VARIANT index,
            /* [retval][out] */ __RPC__deref_out_opt FolderItem **ppid) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE _NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppunk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct FolderItemsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            FolderItems * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            FolderItems * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            FolderItems * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            FolderItems * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            FolderItems * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            FolderItems * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            FolderItems * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            FolderItems * This,
            /* [retval][out] */ __RPC__out long *plCount);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Application )( 
            FolderItems * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            FolderItems * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            FolderItems * This,
            /* [optional][in] */ VARIANT index,
            /* [retval][out] */ __RPC__deref_out_opt FolderItem **ppid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *_NewEnum )( 
            FolderItems * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppunk);
        
        END_INTERFACE
    } FolderItemsVtbl;

    interface FolderItems
    {
        CONST_VTBL struct FolderItemsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define FolderItems_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define FolderItems_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define FolderItems_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define FolderItems_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define FolderItems_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define FolderItems_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define FolderItems_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define FolderItems_get_Count(This,plCount)	\
    ( (This)->lpVtbl -> get_Count(This,plCount) ) 

#define FolderItems_get_Application(This,ppid)	\
    ( (This)->lpVtbl -> get_Application(This,ppid) ) 

#define FolderItems_get_Parent(This,ppid)	\
    ( (This)->lpVtbl -> get_Parent(This,ppid) ) 

#define FolderItems_Item(This,index,ppid)	\
    ( (This)->lpVtbl -> Item(This,index,ppid) ) 

#define FolderItems__NewEnum(This,ppunk)	\
    ( (This)->lpVtbl -> _NewEnum(This,ppunk) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __FolderItems_INTERFACE_DEFINED__ */


#ifndef __FolderItemVerb_INTERFACE_DEFINED__
#define __FolderItemVerb_INTERFACE_DEFINED__

/* interface FolderItemVerb */
/* [object][dual][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_FolderItemVerb;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("08EC3E00-50B0-11CF-960C-0080C7F4EE85")
    FolderItemVerb : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbs) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DoIt( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct FolderItemVerbVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            FolderItemVerb * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            FolderItemVerb * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            FolderItemVerb * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            FolderItemVerb * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            FolderItemVerb * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            FolderItemVerb * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            FolderItemVerb * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Application )( 
            FolderItemVerb * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            FolderItemVerb * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            FolderItemVerb * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbs);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DoIt )( 
            FolderItemVerb * This);
        
        END_INTERFACE
    } FolderItemVerbVtbl;

    interface FolderItemVerb
    {
        CONST_VTBL struct FolderItemVerbVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define FolderItemVerb_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define FolderItemVerb_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define FolderItemVerb_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define FolderItemVerb_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define FolderItemVerb_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define FolderItemVerb_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define FolderItemVerb_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define FolderItemVerb_get_Application(This,ppid)	\
    ( (This)->lpVtbl -> get_Application(This,ppid) ) 

#define FolderItemVerb_get_Parent(This,ppid)	\
    ( (This)->lpVtbl -> get_Parent(This,ppid) ) 

#define FolderItemVerb_get_Name(This,pbs)	\
    ( (This)->lpVtbl -> get_Name(This,pbs) ) 

#define FolderItemVerb_DoIt(This)	\
    ( (This)->lpVtbl -> DoIt(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __FolderItemVerb_INTERFACE_DEFINED__ */


#ifndef __FolderItemVerbs_INTERFACE_DEFINED__
#define __FolderItemVerbs_INTERFACE_DEFINED__

/* interface FolderItemVerbs */
/* [object][dual][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_FolderItemVerbs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1F8352C0-50B0-11CF-960C-0080C7F4EE85")
    FolderItemVerbs : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *plCount) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [optional][in] */ VARIANT index,
            /* [retval][out] */ __RPC__deref_out_opt FolderItemVerb **ppid) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE _NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppunk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct FolderItemVerbsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            FolderItemVerbs * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            FolderItemVerbs * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            FolderItemVerbs * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            FolderItemVerbs * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            FolderItemVerbs * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            FolderItemVerbs * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            FolderItemVerbs * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            FolderItemVerbs * This,
            /* [retval][out] */ __RPC__out long *plCount);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Application )( 
            FolderItemVerbs * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            FolderItemVerbs * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            FolderItemVerbs * This,
            /* [optional][in] */ VARIANT index,
            /* [retval][out] */ __RPC__deref_out_opt FolderItemVerb **ppid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *_NewEnum )( 
            FolderItemVerbs * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppunk);
        
        END_INTERFACE
    } FolderItemVerbsVtbl;

    interface FolderItemVerbs
    {
        CONST_VTBL struct FolderItemVerbsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define FolderItemVerbs_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define FolderItemVerbs_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define FolderItemVerbs_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define FolderItemVerbs_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define FolderItemVerbs_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define FolderItemVerbs_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define FolderItemVerbs_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define FolderItemVerbs_get_Count(This,plCount)	\
    ( (This)->lpVtbl -> get_Count(This,plCount) ) 

#define FolderItemVerbs_get_Application(This,ppid)	\
    ( (This)->lpVtbl -> get_Application(This,ppid) ) 

#define FolderItemVerbs_get_Parent(This,ppid)	\
    ( (This)->lpVtbl -> get_Parent(This,ppid) ) 

#define FolderItemVerbs_Item(This,index,ppid)	\
    ( (This)->lpVtbl -> Item(This,index,ppid) ) 

#define FolderItemVerbs__NewEnum(This,ppunk)	\
    ( (This)->lpVtbl -> _NewEnum(This,ppunk) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __FolderItemVerbs_INTERFACE_DEFINED__ */


#ifndef __Folder_INTERFACE_DEFINED__
#define __Folder_INTERFACE_DEFINED__

/* interface Folder */
/* [object][dual][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_Folder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BBCBDE60-C3FF-11CE-8350-444553540000")
    Folder : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Title( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbs) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ParentFolder( 
            /* [retval][out] */ __RPC__deref_out_opt Folder **ppsf) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Items( 
            /* [retval][out] */ __RPC__deref_out_opt FolderItems **ppid) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ParseName( 
            /* [in] */ __RPC__in BSTR bName,
            /* [retval][out] */ __RPC__deref_out_opt FolderItem **ppid) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE NewFolder( 
            /* [in] */ __RPC__in BSTR bName,
            /* [optional][in] */ VARIANT vOptions) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MoveHere( 
            /* [in] */ VARIANT vItem,
            /* [optional][in] */ VARIANT vOptions) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CopyHere( 
            /* [in] */ VARIANT vItem,
            /* [optional][in] */ VARIANT vOptions) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDetailsOf( 
            /* [in] */ VARIANT vItem,
            /* [in] */ int iColumn,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbs) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct FolderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            Folder * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            Folder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            Folder * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            Folder * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            Folder * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            Folder * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            Folder * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Title )( 
            Folder * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Application )( 
            Folder * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            Folder * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ParentFolder )( 
            Folder * This,
            /* [retval][out] */ __RPC__deref_out_opt Folder **ppsf);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Items )( 
            Folder * This,
            /* [retval][out] */ __RPC__deref_out_opt FolderItems **ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ParseName )( 
            Folder * This,
            /* [in] */ __RPC__in BSTR bName,
            /* [retval][out] */ __RPC__deref_out_opt FolderItem **ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *NewFolder )( 
            Folder * This,
            /* [in] */ __RPC__in BSTR bName,
            /* [optional][in] */ VARIANT vOptions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *MoveHere )( 
            Folder * This,
            /* [in] */ VARIANT vItem,
            /* [optional][in] */ VARIANT vOptions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CopyHere )( 
            Folder * This,
            /* [in] */ VARIANT vItem,
            /* [optional][in] */ VARIANT vOptions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDetailsOf )( 
            Folder * This,
            /* [in] */ VARIANT vItem,
            /* [in] */ int iColumn,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbs);
        
        END_INTERFACE
    } FolderVtbl;

    interface Folder
    {
        CONST_VTBL struct FolderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define Folder_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define Folder_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define Folder_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define Folder_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define Folder_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define Folder_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define Folder_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define Folder_get_Title(This,pbs)	\
    ( (This)->lpVtbl -> get_Title(This,pbs) ) 

#define Folder_get_Application(This,ppid)	\
    ( (This)->lpVtbl -> get_Application(This,ppid) ) 

#define Folder_get_Parent(This,ppid)	\
    ( (This)->lpVtbl -> get_Parent(This,ppid) ) 

#define Folder_get_ParentFolder(This,ppsf)	\
    ( (This)->lpVtbl -> get_ParentFolder(This,ppsf) ) 

#define Folder_Items(This,ppid)	\
    ( (This)->lpVtbl -> Items(This,ppid) ) 

#define Folder_ParseName(This,bName,ppid)	\
    ( (This)->lpVtbl -> ParseName(This,bName,ppid) ) 

#define Folder_NewFolder(This,bName,vOptions)	\
    ( (This)->lpVtbl -> NewFolder(This,bName,vOptions) ) 

#define Folder_MoveHere(This,vItem,vOptions)	\
    ( (This)->lpVtbl -> MoveHere(This,vItem,vOptions) ) 

#define Folder_CopyHere(This,vItem,vOptions)	\
    ( (This)->lpVtbl -> CopyHere(This,vItem,vOptions) ) 

#define Folder_GetDetailsOf(This,vItem,iColumn,pbs)	\
    ( (This)->lpVtbl -> GetDetailsOf(This,vItem,iColumn,pbs) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __Folder_INTERFACE_DEFINED__ */


#ifndef __Folder2_INTERFACE_DEFINED__
#define __Folder2_INTERFACE_DEFINED__

/* interface Folder2 */
/* [object][dual][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_Folder2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f0d2d8ef-3890-11d2-bf8b-00c04fb93661")
    Folder2 : public Folder
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Self( 
            /* [retval][out] */ __RPC__deref_out_opt FolderItem **ppfi) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_OfflineStatus( 
            /* [retval][out] */ __RPC__out LONG *pul) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Synchronize( void) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HaveToShowWebViewBarricade( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbHaveToShowWebViewBarricade) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DismissedWebViewBarricade( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct Folder2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            Folder2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            Folder2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            Folder2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            Folder2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            Folder2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            Folder2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            Folder2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Title )( 
            Folder2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Application )( 
            Folder2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            Folder2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ParentFolder )( 
            Folder2 * This,
            /* [retval][out] */ __RPC__deref_out_opt Folder **ppsf);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Items )( 
            Folder2 * This,
            /* [retval][out] */ __RPC__deref_out_opt FolderItems **ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ParseName )( 
            Folder2 * This,
            /* [in] */ __RPC__in BSTR bName,
            /* [retval][out] */ __RPC__deref_out_opt FolderItem **ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *NewFolder )( 
            Folder2 * This,
            /* [in] */ __RPC__in BSTR bName,
            /* [optional][in] */ VARIANT vOptions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *MoveHere )( 
            Folder2 * This,
            /* [in] */ VARIANT vItem,
            /* [optional][in] */ VARIANT vOptions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CopyHere )( 
            Folder2 * This,
            /* [in] */ VARIANT vItem,
            /* [optional][in] */ VARIANT vOptions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDetailsOf )( 
            Folder2 * This,
            /* [in] */ VARIANT vItem,
            /* [in] */ int iColumn,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Self )( 
            Folder2 * This,
            /* [retval][out] */ __RPC__deref_out_opt FolderItem **ppfi);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OfflineStatus )( 
            Folder2 * This,
            /* [retval][out] */ __RPC__out LONG *pul);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Synchronize )( 
            Folder2 * This);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_HaveToShowWebViewBarricade )( 
            Folder2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbHaveToShowWebViewBarricade);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DismissedWebViewBarricade )( 
            Folder2 * This);
        
        END_INTERFACE
    } Folder2Vtbl;

    interface Folder2
    {
        CONST_VTBL struct Folder2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define Folder2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define Folder2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define Folder2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define Folder2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define Folder2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define Folder2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define Folder2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define Folder2_get_Title(This,pbs)	\
    ( (This)->lpVtbl -> get_Title(This,pbs) ) 

#define Folder2_get_Application(This,ppid)	\
    ( (This)->lpVtbl -> get_Application(This,ppid) ) 

#define Folder2_get_Parent(This,ppid)	\
    ( (This)->lpVtbl -> get_Parent(This,ppid) ) 

#define Folder2_get_ParentFolder(This,ppsf)	\
    ( (This)->lpVtbl -> get_ParentFolder(This,ppsf) ) 

#define Folder2_Items(This,ppid)	\
    ( (This)->lpVtbl -> Items(This,ppid) ) 

#define Folder2_ParseName(This,bName,ppid)	\
    ( (This)->lpVtbl -> ParseName(This,bName,ppid) ) 

#define Folder2_NewFolder(This,bName,vOptions)	\
    ( (This)->lpVtbl -> NewFolder(This,bName,vOptions) ) 

#define Folder2_MoveHere(This,vItem,vOptions)	\
    ( (This)->lpVtbl -> MoveHere(This,vItem,vOptions) ) 

#define Folder2_CopyHere(This,vItem,vOptions)	\
    ( (This)->lpVtbl -> CopyHere(This,vItem,vOptions) ) 

#define Folder2_GetDetailsOf(This,vItem,iColumn,pbs)	\
    ( (This)->lpVtbl -> GetDetailsOf(This,vItem,iColumn,pbs) ) 


#define Folder2_get_Self(This,ppfi)	\
    ( (This)->lpVtbl -> get_Self(This,ppfi) ) 

#define Folder2_get_OfflineStatus(This,pul)	\
    ( (This)->lpVtbl -> get_OfflineStatus(This,pul) ) 

#define Folder2_Synchronize(This)	\
    ( (This)->lpVtbl -> Synchronize(This) ) 

#define Folder2_get_HaveToShowWebViewBarricade(This,pbHaveToShowWebViewBarricade)	\
    ( (This)->lpVtbl -> get_HaveToShowWebViewBarricade(This,pbHaveToShowWebViewBarricade) ) 

#define Folder2_DismissedWebViewBarricade(This)	\
    ( (This)->lpVtbl -> DismissedWebViewBarricade(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __Folder2_INTERFACE_DEFINED__ */


#ifndef __Folder3_INTERFACE_DEFINED__
#define __Folder3_INTERFACE_DEFINED__

/* interface Folder3 */
/* [object][dual][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_Folder3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A7AE5F64-C4D7-4d7f-9307-4D24EE54B841")
    Folder3 : public Folder2
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowWebViewBarricade( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbShowWebViewBarricade) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowWebViewBarricade( 
            /* [in] */ VARIANT_BOOL bShowWebViewBarricade) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct Folder3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            Folder3 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            Folder3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            Folder3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            Folder3 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            Folder3 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            Folder3 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            Folder3 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Title )( 
            Folder3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Application )( 
            Folder3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            Folder3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ParentFolder )( 
            Folder3 * This,
            /* [retval][out] */ __RPC__deref_out_opt Folder **ppsf);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Items )( 
            Folder3 * This,
            /* [retval][out] */ __RPC__deref_out_opt FolderItems **ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ParseName )( 
            Folder3 * This,
            /* [in] */ __RPC__in BSTR bName,
            /* [retval][out] */ __RPC__deref_out_opt FolderItem **ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *NewFolder )( 
            Folder3 * This,
            /* [in] */ __RPC__in BSTR bName,
            /* [optional][in] */ VARIANT vOptions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *MoveHere )( 
            Folder3 * This,
            /* [in] */ VARIANT vItem,
            /* [optional][in] */ VARIANT vOptions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CopyHere )( 
            Folder3 * This,
            /* [in] */ VARIANT vItem,
            /* [optional][in] */ VARIANT vOptions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDetailsOf )( 
            Folder3 * This,
            /* [in] */ VARIANT vItem,
            /* [in] */ int iColumn,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Self )( 
            Folder3 * This,
            /* [retval][out] */ __RPC__deref_out_opt FolderItem **ppfi);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OfflineStatus )( 
            Folder3 * This,
            /* [retval][out] */ __RPC__out LONG *pul);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Synchronize )( 
            Folder3 * This);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_HaveToShowWebViewBarricade )( 
            Folder3 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbHaveToShowWebViewBarricade);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DismissedWebViewBarricade )( 
            Folder3 * This);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowWebViewBarricade )( 
            Folder3 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbShowWebViewBarricade);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowWebViewBarricade )( 
            Folder3 * This,
            /* [in] */ VARIANT_BOOL bShowWebViewBarricade);
        
        END_INTERFACE
    } Folder3Vtbl;

    interface Folder3
    {
        CONST_VTBL struct Folder3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define Folder3_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define Folder3_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define Folder3_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define Folder3_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define Folder3_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define Folder3_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define Folder3_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define Folder3_get_Title(This,pbs)	\
    ( (This)->lpVtbl -> get_Title(This,pbs) ) 

#define Folder3_get_Application(This,ppid)	\
    ( (This)->lpVtbl -> get_Application(This,ppid) ) 

#define Folder3_get_Parent(This,ppid)	\
    ( (This)->lpVtbl -> get_Parent(This,ppid) ) 

#define Folder3_get_ParentFolder(This,ppsf)	\
    ( (This)->lpVtbl -> get_ParentFolder(This,ppsf) ) 

#define Folder3_Items(This,ppid)	\
    ( (This)->lpVtbl -> Items(This,ppid) ) 

#define Folder3_ParseName(This,bName,ppid)	\
    ( (This)->lpVtbl -> ParseName(This,bName,ppid) ) 

#define Folder3_NewFolder(This,bName,vOptions)	\
    ( (This)->lpVtbl -> NewFolder(This,bName,vOptions) ) 

#define Folder3_MoveHere(This,vItem,vOptions)	\
    ( (This)->lpVtbl -> MoveHere(This,vItem,vOptions) ) 

#define Folder3_CopyHere(This,vItem,vOptions)	\
    ( (This)->lpVtbl -> CopyHere(This,vItem,vOptions) ) 

#define Folder3_GetDetailsOf(This,vItem,iColumn,pbs)	\
    ( (This)->lpVtbl -> GetDetailsOf(This,vItem,iColumn,pbs) ) 


#define Folder3_get_Self(This,ppfi)	\
    ( (This)->lpVtbl -> get_Self(This,ppfi) ) 

#define Folder3_get_OfflineStatus(This,pul)	\
    ( (This)->lpVtbl -> get_OfflineStatus(This,pul) ) 

#define Folder3_Synchronize(This)	\
    ( (This)->lpVtbl -> Synchronize(This) ) 

#define Folder3_get_HaveToShowWebViewBarricade(This,pbHaveToShowWebViewBarricade)	\
    ( (This)->lpVtbl -> get_HaveToShowWebViewBarricade(This,pbHaveToShowWebViewBarricade) ) 

#define Folder3_DismissedWebViewBarricade(This)	\
    ( (This)->lpVtbl -> DismissedWebViewBarricade(This) ) 


#define Folder3_get_ShowWebViewBarricade(This,pbShowWebViewBarricade)	\
    ( (This)->lpVtbl -> get_ShowWebViewBarricade(This,pbShowWebViewBarricade) ) 

#define Folder3_put_ShowWebViewBarricade(This,bShowWebViewBarricade)	\
    ( (This)->lpVtbl -> put_ShowWebViewBarricade(This,bShowWebViewBarricade) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __Folder3_INTERFACE_DEFINED__ */


#ifndef __FolderItem2_INTERFACE_DEFINED__
#define __FolderItem2_INTERFACE_DEFINED__

/* interface FolderItem2 */
/* [object][dual][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_FolderItem2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("edc817aa-92b8-11d1-b075-00c04fc33aa5")
    FolderItem2 : public FolderItem
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InvokeVerbEx( 
            /* [optional][in] */ VARIANT vVerb,
            /* [optional][in] */ VARIANT vArgs) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ExtendedProperty( 
            /* [in] */ __RPC__in BSTR bstrPropName,
            /* [retval][out] */ __RPC__out VARIANT *pvRet) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct FolderItem2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            FolderItem2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            FolderItem2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            FolderItem2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            FolderItem2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            FolderItem2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            FolderItem2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            FolderItem2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Application )( 
            FolderItem2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            FolderItem2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            FolderItem2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbs);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            FolderItem2 * This,
            /* [in] */ __RPC__in BSTR bs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Path )( 
            FolderItem2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GetLink )( 
            FolderItem2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GetFolder )( 
            FolderItem2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsLink )( 
            FolderItem2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pb);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsFolder )( 
            FolderItem2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pb);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsFileSystem )( 
            FolderItem2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pb);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsBrowsable )( 
            FolderItem2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pb);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ModifyDate )( 
            FolderItem2 * This,
            /* [retval][out] */ __RPC__out DATE *pdt);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ModifyDate )( 
            FolderItem2 * This,
            /* [in] */ DATE dt);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Size )( 
            FolderItem2 * This,
            /* [retval][out] */ __RPC__out LONG *pul);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            FolderItem2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbs);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Verbs )( 
            FolderItem2 * This,
            /* [retval][out] */ __RPC__deref_out_opt FolderItemVerbs **ppfic);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *InvokeVerb )( 
            FolderItem2 * This,
            /* [optional][in] */ VARIANT vVerb);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *InvokeVerbEx )( 
            FolderItem2 * This,
            /* [optional][in] */ VARIANT vVerb,
            /* [optional][in] */ VARIANT vArgs);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ExtendedProperty )( 
            FolderItem2 * This,
            /* [in] */ __RPC__in BSTR bstrPropName,
            /* [retval][out] */ __RPC__out VARIANT *pvRet);
        
        END_INTERFACE
    } FolderItem2Vtbl;

    interface FolderItem2
    {
        CONST_VTBL struct FolderItem2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define FolderItem2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define FolderItem2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define FolderItem2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define FolderItem2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define FolderItem2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define FolderItem2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define FolderItem2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define FolderItem2_get_Application(This,ppid)	\
    ( (This)->lpVtbl -> get_Application(This,ppid) ) 

#define FolderItem2_get_Parent(This,ppid)	\
    ( (This)->lpVtbl -> get_Parent(This,ppid) ) 

#define FolderItem2_get_Name(This,pbs)	\
    ( (This)->lpVtbl -> get_Name(This,pbs) ) 

#define FolderItem2_put_Name(This,bs)	\
    ( (This)->lpVtbl -> put_Name(This,bs) ) 

#define FolderItem2_get_Path(This,pbs)	\
    ( (This)->lpVtbl -> get_Path(This,pbs) ) 

#define FolderItem2_get_GetLink(This,ppid)	\
    ( (This)->lpVtbl -> get_GetLink(This,ppid) ) 

#define FolderItem2_get_GetFolder(This,ppid)	\
    ( (This)->lpVtbl -> get_GetFolder(This,ppid) ) 

#define FolderItem2_get_IsLink(This,pb)	\
    ( (This)->lpVtbl -> get_IsLink(This,pb) ) 

#define FolderItem2_get_IsFolder(This,pb)	\
    ( (This)->lpVtbl -> get_IsFolder(This,pb) ) 

#define FolderItem2_get_IsFileSystem(This,pb)	\
    ( (This)->lpVtbl -> get_IsFileSystem(This,pb) ) 

#define FolderItem2_get_IsBrowsable(This,pb)	\
    ( (This)->lpVtbl -> get_IsBrowsable(This,pb) ) 

#define FolderItem2_get_ModifyDate(This,pdt)	\
    ( (This)->lpVtbl -> get_ModifyDate(This,pdt) ) 

#define FolderItem2_put_ModifyDate(This,dt)	\
    ( (This)->lpVtbl -> put_ModifyDate(This,dt) ) 

#define FolderItem2_get_Size(This,pul)	\
    ( (This)->lpVtbl -> get_Size(This,pul) ) 

#define FolderItem2_get_Type(This,pbs)	\
    ( (This)->lpVtbl -> get_Type(This,pbs) ) 

#define FolderItem2_Verbs(This,ppfic)	\
    ( (This)->lpVtbl -> Verbs(This,ppfic) ) 

#define FolderItem2_InvokeVerb(This,vVerb)	\
    ( (This)->lpVtbl -> InvokeVerb(This,vVerb) ) 


#define FolderItem2_InvokeVerbEx(This,vVerb,vArgs)	\
    ( (This)->lpVtbl -> InvokeVerbEx(This,vVerb,vArgs) ) 

#define FolderItem2_ExtendedProperty(This,bstrPropName,pvRet)	\
    ( (This)->lpVtbl -> ExtendedProperty(This,bstrPropName,pvRet) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __FolderItem2_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_ShellFolderItem;

#ifdef __cplusplus

class DECLSPEC_UUID("2fe352ea-fd1f-11d2-b1f4-00c04f8eeb3e")
ShellFolderItem;
#endif

#ifndef __FolderItems2_INTERFACE_DEFINED__
#define __FolderItems2_INTERFACE_DEFINED__

/* interface FolderItems2 */
/* [object][dual][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_FolderItems2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C94F0AD0-F363-11d2-A327-00C04F8EEC7F")
    FolderItems2 : public FolderItems
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InvokeVerbEx( 
            /* [optional][in] */ VARIANT vVerb,
            /* [optional][in] */ VARIANT vArgs) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct FolderItems2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            FolderItems2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            FolderItems2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            FolderItems2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            FolderItems2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            FolderItems2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            FolderItems2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            FolderItems2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            FolderItems2 * This,
            /* [retval][out] */ __RPC__out long *plCount);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Application )( 
            FolderItems2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            FolderItems2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            FolderItems2 * This,
            /* [optional][in] */ VARIANT index,
            /* [retval][out] */ __RPC__deref_out_opt FolderItem **ppid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *_NewEnum )( 
            FolderItems2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppunk);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *InvokeVerbEx )( 
            FolderItems2 * This,
            /* [optional][in] */ VARIANT vVerb,
            /* [optional][in] */ VARIANT vArgs);
        
        END_INTERFACE
    } FolderItems2Vtbl;

    interface FolderItems2
    {
        CONST_VTBL struct FolderItems2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define FolderItems2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define FolderItems2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define FolderItems2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define FolderItems2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define FolderItems2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define FolderItems2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define FolderItems2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define FolderItems2_get_Count(This,plCount)	\
    ( (This)->lpVtbl -> get_Count(This,plCount) ) 

#define FolderItems2_get_Application(This,ppid)	\
    ( (This)->lpVtbl -> get_Application(This,ppid) ) 

#define FolderItems2_get_Parent(This,ppid)	\
    ( (This)->lpVtbl -> get_Parent(This,ppid) ) 

#define FolderItems2_Item(This,index,ppid)	\
    ( (This)->lpVtbl -> Item(This,index,ppid) ) 

#define FolderItems2__NewEnum(This,ppunk)	\
    ( (This)->lpVtbl -> _NewEnum(This,ppunk) ) 


#define FolderItems2_InvokeVerbEx(This,vVerb,vArgs)	\
    ( (This)->lpVtbl -> InvokeVerbEx(This,vVerb,vArgs) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __FolderItems2_INTERFACE_DEFINED__ */


#ifndef __FolderItems3_INTERFACE_DEFINED__
#define __FolderItems3_INTERFACE_DEFINED__

/* interface FolderItems3 */
/* [object][dual][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_FolderItems3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("eaa7c309-bbec-49d5-821d-64d966cb667f")
    FolderItems3 : public FolderItems2
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Filter( 
            /* [in] */ long grfFlags,
            /* [in] */ __RPC__in BSTR bstrFileSpec) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Verbs( 
            /* [retval][out] */ __RPC__deref_out_opt FolderItemVerbs **ppfic) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct FolderItems3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            FolderItems3 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            FolderItems3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            FolderItems3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            FolderItems3 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            FolderItems3 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            FolderItems3 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            FolderItems3 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            FolderItems3 * This,
            /* [retval][out] */ __RPC__out long *plCount);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Application )( 
            FolderItems3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            FolderItems3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            FolderItems3 * This,
            /* [optional][in] */ VARIANT index,
            /* [retval][out] */ __RPC__deref_out_opt FolderItem **ppid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *_NewEnum )( 
            FolderItems3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppunk);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *InvokeVerbEx )( 
            FolderItems3 * This,
            /* [optional][in] */ VARIANT vVerb,
            /* [optional][in] */ VARIANT vArgs);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Filter )( 
            FolderItems3 * This,
            /* [in] */ long grfFlags,
            /* [in] */ __RPC__in BSTR bstrFileSpec);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Verbs )( 
            FolderItems3 * This,
            /* [retval][out] */ __RPC__deref_out_opt FolderItemVerbs **ppfic);
        
        END_INTERFACE
    } FolderItems3Vtbl;

    interface FolderItems3
    {
        CONST_VTBL struct FolderItems3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define FolderItems3_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define FolderItems3_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define FolderItems3_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define FolderItems3_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define FolderItems3_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define FolderItems3_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define FolderItems3_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define FolderItems3_get_Count(This,plCount)	\
    ( (This)->lpVtbl -> get_Count(This,plCount) ) 

#define FolderItems3_get_Application(This,ppid)	\
    ( (This)->lpVtbl -> get_Application(This,ppid) ) 

#define FolderItems3_get_Parent(This,ppid)	\
    ( (This)->lpVtbl -> get_Parent(This,ppid) ) 

#define FolderItems3_Item(This,index,ppid)	\
    ( (This)->lpVtbl -> Item(This,index,ppid) ) 

#define FolderItems3__NewEnum(This,ppunk)	\
    ( (This)->lpVtbl -> _NewEnum(This,ppunk) ) 


#define FolderItems3_InvokeVerbEx(This,vVerb,vArgs)	\
    ( (This)->lpVtbl -> InvokeVerbEx(This,vVerb,vArgs) ) 


#define FolderItems3_Filter(This,grfFlags,bstrFileSpec)	\
    ( (This)->lpVtbl -> Filter(This,grfFlags,bstrFileSpec) ) 

#define FolderItems3_get_Verbs(This,ppfic)	\
    ( (This)->lpVtbl -> get_Verbs(This,ppfic) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __FolderItems3_INTERFACE_DEFINED__ */


#ifndef __IShellLinkDual_INTERFACE_DEFINED__
#define __IShellLinkDual_INTERFACE_DEFINED__

/* interface IShellLinkDual */
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_IShellLinkDual;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("88A05C00-F000-11CE-8350-444553540000")
    IShellLinkDual : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Path( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbs) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Path( 
            /* [in] */ __RPC__in BSTR bs) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbs) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Description( 
            /* [in] */ __RPC__in BSTR bs) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_WorkingDirectory( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbs) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_WorkingDirectory( 
            /* [in] */ __RPC__in BSTR bs) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Arguments( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbs) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Arguments( 
            /* [in] */ __RPC__in BSTR bs) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Hotkey( 
            /* [retval][out] */ __RPC__out int *piHK) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Hotkey( 
            /* [in] */ int iHK) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ShowCommand( 
            /* [retval][out] */ __RPC__out int *piShowCommand) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_ShowCommand( 
            /* [in] */ int iShowCommand) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Resolve( 
            /* [in] */ int fFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetIconLocation( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbs,
            /* [retval][out] */ __RPC__out int *piIcon) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetIconLocation( 
            /* [in] */ __RPC__in BSTR bs,
            /* [in] */ int iIcon) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Save( 
            /* [optional][in] */ VARIANT vWhere) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellLinkDualVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellLinkDual * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellLinkDual * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellLinkDual * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IShellLinkDual * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IShellLinkDual * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IShellLinkDual * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IShellLinkDual * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Path )( 
            IShellLinkDual * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbs);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Path )( 
            IShellLinkDual * This,
            /* [in] */ __RPC__in BSTR bs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            IShellLinkDual * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbs);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Description )( 
            IShellLinkDual * This,
            /* [in] */ __RPC__in BSTR bs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_WorkingDirectory )( 
            IShellLinkDual * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbs);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_WorkingDirectory )( 
            IShellLinkDual * This,
            /* [in] */ __RPC__in BSTR bs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Arguments )( 
            IShellLinkDual * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbs);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Arguments )( 
            IShellLinkDual * This,
            /* [in] */ __RPC__in BSTR bs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Hotkey )( 
            IShellLinkDual * This,
            /* [retval][out] */ __RPC__out int *piHK);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Hotkey )( 
            IShellLinkDual * This,
            /* [in] */ int iHK);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ShowCommand )( 
            IShellLinkDual * This,
            /* [retval][out] */ __RPC__out int *piShowCommand);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ShowCommand )( 
            IShellLinkDual * This,
            /* [in] */ int iShowCommand);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Resolve )( 
            IShellLinkDual * This,
            /* [in] */ int fFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetIconLocation )( 
            IShellLinkDual * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbs,
            /* [retval][out] */ __RPC__out int *piIcon);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetIconLocation )( 
            IShellLinkDual * This,
            /* [in] */ __RPC__in BSTR bs,
            /* [in] */ int iIcon);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Save )( 
            IShellLinkDual * This,
            /* [optional][in] */ VARIANT vWhere);
        
        END_INTERFACE
    } IShellLinkDualVtbl;

    interface IShellLinkDual
    {
        CONST_VTBL struct IShellLinkDualVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellLinkDual_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellLinkDual_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellLinkDual_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellLinkDual_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IShellLinkDual_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IShellLinkDual_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IShellLinkDual_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IShellLinkDual_get_Path(This,pbs)	\
    ( (This)->lpVtbl -> get_Path(This,pbs) ) 

#define IShellLinkDual_put_Path(This,bs)	\
    ( (This)->lpVtbl -> put_Path(This,bs) ) 

#define IShellLinkDual_get_Description(This,pbs)	\
    ( (This)->lpVtbl -> get_Description(This,pbs) ) 

#define IShellLinkDual_put_Description(This,bs)	\
    ( (This)->lpVtbl -> put_Description(This,bs) ) 

#define IShellLinkDual_get_WorkingDirectory(This,pbs)	\
    ( (This)->lpVtbl -> get_WorkingDirectory(This,pbs) ) 

#define IShellLinkDual_put_WorkingDirectory(This,bs)	\
    ( (This)->lpVtbl -> put_WorkingDirectory(This,bs) ) 

#define IShellLinkDual_get_Arguments(This,pbs)	\
    ( (This)->lpVtbl -> get_Arguments(This,pbs) ) 

#define IShellLinkDual_put_Arguments(This,bs)	\
    ( (This)->lpVtbl -> put_Arguments(This,bs) ) 

#define IShellLinkDual_get_Hotkey(This,piHK)	\
    ( (This)->lpVtbl -> get_Hotkey(This,piHK) ) 

#define IShellLinkDual_put_Hotkey(This,iHK)	\
    ( (This)->lpVtbl -> put_Hotkey(This,iHK) ) 

#define IShellLinkDual_get_ShowCommand(This,piShowCommand)	\
    ( (This)->lpVtbl -> get_ShowCommand(This,piShowCommand) ) 

#define IShellLinkDual_put_ShowCommand(This,iShowCommand)	\
    ( (This)->lpVtbl -> put_ShowCommand(This,iShowCommand) ) 

#define IShellLinkDual_Resolve(This,fFlags)	\
    ( (This)->lpVtbl -> Resolve(This,fFlags) ) 

#define IShellLinkDual_GetIconLocation(This,pbs,piIcon)	\
    ( (This)->lpVtbl -> GetIconLocation(This,pbs,piIcon) ) 

#define IShellLinkDual_SetIconLocation(This,bs,iIcon)	\
    ( (This)->lpVtbl -> SetIconLocation(This,bs,iIcon) ) 

#define IShellLinkDual_Save(This,vWhere)	\
    ( (This)->lpVtbl -> Save(This,vWhere) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellLinkDual_INTERFACE_DEFINED__ */


#ifndef __IShellLinkDual2_INTERFACE_DEFINED__
#define __IShellLinkDual2_INTERFACE_DEFINED__

/* interface IShellLinkDual2 */
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_IShellLinkDual2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("317EE249-F12E-11d2-B1E4-00C04F8EEB3E")
    IShellLinkDual2 : public IShellLinkDual
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Target( 
            /* [retval][out] */ __RPC__deref_out_opt FolderItem **ppfi) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellLinkDual2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellLinkDual2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellLinkDual2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellLinkDual2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IShellLinkDual2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IShellLinkDual2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IShellLinkDual2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IShellLinkDual2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Path )( 
            IShellLinkDual2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbs);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Path )( 
            IShellLinkDual2 * This,
            /* [in] */ __RPC__in BSTR bs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            IShellLinkDual2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbs);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Description )( 
            IShellLinkDual2 * This,
            /* [in] */ __RPC__in BSTR bs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_WorkingDirectory )( 
            IShellLinkDual2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbs);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_WorkingDirectory )( 
            IShellLinkDual2 * This,
            /* [in] */ __RPC__in BSTR bs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Arguments )( 
            IShellLinkDual2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbs);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Arguments )( 
            IShellLinkDual2 * This,
            /* [in] */ __RPC__in BSTR bs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Hotkey )( 
            IShellLinkDual2 * This,
            /* [retval][out] */ __RPC__out int *piHK);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Hotkey )( 
            IShellLinkDual2 * This,
            /* [in] */ int iHK);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ShowCommand )( 
            IShellLinkDual2 * This,
            /* [retval][out] */ __RPC__out int *piShowCommand);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ShowCommand )( 
            IShellLinkDual2 * This,
            /* [in] */ int iShowCommand);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Resolve )( 
            IShellLinkDual2 * This,
            /* [in] */ int fFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetIconLocation )( 
            IShellLinkDual2 * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbs,
            /* [retval][out] */ __RPC__out int *piIcon);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetIconLocation )( 
            IShellLinkDual2 * This,
            /* [in] */ __RPC__in BSTR bs,
            /* [in] */ int iIcon);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Save )( 
            IShellLinkDual2 * This,
            /* [optional][in] */ VARIANT vWhere);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Target )( 
            IShellLinkDual2 * This,
            /* [retval][out] */ __RPC__deref_out_opt FolderItem **ppfi);
        
        END_INTERFACE
    } IShellLinkDual2Vtbl;

    interface IShellLinkDual2
    {
        CONST_VTBL struct IShellLinkDual2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellLinkDual2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellLinkDual2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellLinkDual2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellLinkDual2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IShellLinkDual2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IShellLinkDual2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IShellLinkDual2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IShellLinkDual2_get_Path(This,pbs)	\
    ( (This)->lpVtbl -> get_Path(This,pbs) ) 

#define IShellLinkDual2_put_Path(This,bs)	\
    ( (This)->lpVtbl -> put_Path(This,bs) ) 

#define IShellLinkDual2_get_Description(This,pbs)	\
    ( (This)->lpVtbl -> get_Description(This,pbs) ) 

#define IShellLinkDual2_put_Description(This,bs)	\
    ( (This)->lpVtbl -> put_Description(This,bs) ) 

#define IShellLinkDual2_get_WorkingDirectory(This,pbs)	\
    ( (This)->lpVtbl -> get_WorkingDirectory(This,pbs) ) 

#define IShellLinkDual2_put_WorkingDirectory(This,bs)	\
    ( (This)->lpVtbl -> put_WorkingDirectory(This,bs) ) 

#define IShellLinkDual2_get_Arguments(This,pbs)	\
    ( (This)->lpVtbl -> get_Arguments(This,pbs) ) 

#define IShellLinkDual2_put_Arguments(This,bs)	\
    ( (This)->lpVtbl -> put_Arguments(This,bs) ) 

#define IShellLinkDual2_get_Hotkey(This,piHK)	\
    ( (This)->lpVtbl -> get_Hotkey(This,piHK) ) 

#define IShellLinkDual2_put_Hotkey(This,iHK)	\
    ( (This)->lpVtbl -> put_Hotkey(This,iHK) ) 

#define IShellLinkDual2_get_ShowCommand(This,piShowCommand)	\
    ( (This)->lpVtbl -> get_ShowCommand(This,piShowCommand) ) 

#define IShellLinkDual2_put_ShowCommand(This,iShowCommand)	\
    ( (This)->lpVtbl -> put_ShowCommand(This,iShowCommand) ) 

#define IShellLinkDual2_Resolve(This,fFlags)	\
    ( (This)->lpVtbl -> Resolve(This,fFlags) ) 

#define IShellLinkDual2_GetIconLocation(This,pbs,piIcon)	\
    ( (This)->lpVtbl -> GetIconLocation(This,pbs,piIcon) ) 

#define IShellLinkDual2_SetIconLocation(This,bs,iIcon)	\
    ( (This)->lpVtbl -> SetIconLocation(This,bs,iIcon) ) 

#define IShellLinkDual2_Save(This,vWhere)	\
    ( (This)->lpVtbl -> Save(This,vWhere) ) 


#define IShellLinkDual2_get_Target(This,ppfi)	\
    ( (This)->lpVtbl -> get_Target(This,ppfi) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellLinkDual2_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_ShellLinkObject;

#ifdef __cplusplus

class DECLSPEC_UUID("11219420-1768-11d1-95BE-00609797EA4F")
ShellLinkObject;
#endif

#ifndef __IShellFolderViewDual_INTERFACE_DEFINED__
#define __IShellFolderViewDual_INTERFACE_DEFINED__

/* interface IShellFolderViewDual */
/* [object][dual][hidden][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_IShellFolderViewDual;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E7A1AF80-4D96-11CF-960C-0080C7F4EE85")
    IShellFolderViewDual : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Folder( 
            /* [retval][out] */ __RPC__deref_out_opt Folder **ppid) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SelectedItems( 
            /* [retval][out] */ __RPC__deref_out_opt FolderItems **ppid) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_FocusedItem( 
            /* [retval][out] */ __RPC__deref_out_opt FolderItem **ppid) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SelectItem( 
            /* [in] */ __RPC__in VARIANT *pvfi,
            /* [in] */ int dwFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE PopupItemMenu( 
            /* [in] */ __RPC__in_opt FolderItem *pfi,
            /* [optional][in] */ VARIANT vx,
            /* [optional][in] */ VARIANT vy,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbs) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Script( 
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppDisp) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ViewOptions( 
            /* [retval][out] */ __RPC__out long *plViewOptions) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellFolderViewDualVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellFolderViewDual * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellFolderViewDual * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellFolderViewDual * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IShellFolderViewDual * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IShellFolderViewDual * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IShellFolderViewDual * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IShellFolderViewDual * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Application )( 
            IShellFolderViewDual * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            IShellFolderViewDual * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Folder )( 
            IShellFolderViewDual * This,
            /* [retval][out] */ __RPC__deref_out_opt Folder **ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SelectedItems )( 
            IShellFolderViewDual * This,
            /* [retval][out] */ __RPC__deref_out_opt FolderItems **ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FocusedItem )( 
            IShellFolderViewDual * This,
            /* [retval][out] */ __RPC__deref_out_opt FolderItem **ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SelectItem )( 
            IShellFolderViewDual * This,
            /* [in] */ __RPC__in VARIANT *pvfi,
            /* [in] */ int dwFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *PopupItemMenu )( 
            IShellFolderViewDual * This,
            /* [in] */ __RPC__in_opt FolderItem *pfi,
            /* [optional][in] */ VARIANT vx,
            /* [optional][in] */ VARIANT vy,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbs);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Script )( 
            IShellFolderViewDual * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppDisp);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ViewOptions )( 
            IShellFolderViewDual * This,
            /* [retval][out] */ __RPC__out long *plViewOptions);
        
        END_INTERFACE
    } IShellFolderViewDualVtbl;

    interface IShellFolderViewDual
    {
        CONST_VTBL struct IShellFolderViewDualVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellFolderViewDual_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellFolderViewDual_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellFolderViewDual_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellFolderViewDual_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IShellFolderViewDual_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IShellFolderViewDual_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IShellFolderViewDual_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IShellFolderViewDual_get_Application(This,ppid)	\
    ( (This)->lpVtbl -> get_Application(This,ppid) ) 

#define IShellFolderViewDual_get_Parent(This,ppid)	\
    ( (This)->lpVtbl -> get_Parent(This,ppid) ) 

#define IShellFolderViewDual_get_Folder(This,ppid)	\
    ( (This)->lpVtbl -> get_Folder(This,ppid) ) 

#define IShellFolderViewDual_SelectedItems(This,ppid)	\
    ( (This)->lpVtbl -> SelectedItems(This,ppid) ) 

#define IShellFolderViewDual_get_FocusedItem(This,ppid)	\
    ( (This)->lpVtbl -> get_FocusedItem(This,ppid) ) 

#define IShellFolderViewDual_SelectItem(This,pvfi,dwFlags)	\
    ( (This)->lpVtbl -> SelectItem(This,pvfi,dwFlags) ) 

#define IShellFolderViewDual_PopupItemMenu(This,pfi,vx,vy,pbs)	\
    ( (This)->lpVtbl -> PopupItemMenu(This,pfi,vx,vy,pbs) ) 

#define IShellFolderViewDual_get_Script(This,ppDisp)	\
    ( (This)->lpVtbl -> get_Script(This,ppDisp) ) 

#define IShellFolderViewDual_get_ViewOptions(This,plViewOptions)	\
    ( (This)->lpVtbl -> get_ViewOptions(This,plViewOptions) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellFolderViewDual_INTERFACE_DEFINED__ */


#ifndef __IShellFolderViewDual2_INTERFACE_DEFINED__
#define __IShellFolderViewDual2_INTERFACE_DEFINED__

/* interface IShellFolderViewDual2 */
/* [object][dual][hidden][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_IShellFolderViewDual2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("31C147b6-0ADE-4A3C-B514-DDF932EF6D17")
    IShellFolderViewDual2 : public IShellFolderViewDual
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentViewMode( 
            /* [retval][out] */ __RPC__out UINT *pViewMode) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_CurrentViewMode( 
            /* [in] */ UINT ViewMode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SelectItemRelative( 
            /* [in] */ int iRelative) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellFolderViewDual2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellFolderViewDual2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellFolderViewDual2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellFolderViewDual2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IShellFolderViewDual2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IShellFolderViewDual2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IShellFolderViewDual2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IShellFolderViewDual2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Application )( 
            IShellFolderViewDual2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            IShellFolderViewDual2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Folder )( 
            IShellFolderViewDual2 * This,
            /* [retval][out] */ __RPC__deref_out_opt Folder **ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SelectedItems )( 
            IShellFolderViewDual2 * This,
            /* [retval][out] */ __RPC__deref_out_opt FolderItems **ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FocusedItem )( 
            IShellFolderViewDual2 * This,
            /* [retval][out] */ __RPC__deref_out_opt FolderItem **ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SelectItem )( 
            IShellFolderViewDual2 * This,
            /* [in] */ __RPC__in VARIANT *pvfi,
            /* [in] */ int dwFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *PopupItemMenu )( 
            IShellFolderViewDual2 * This,
            /* [in] */ __RPC__in_opt FolderItem *pfi,
            /* [optional][in] */ VARIANT vx,
            /* [optional][in] */ VARIANT vy,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbs);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Script )( 
            IShellFolderViewDual2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppDisp);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ViewOptions )( 
            IShellFolderViewDual2 * This,
            /* [retval][out] */ __RPC__out long *plViewOptions);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentViewMode )( 
            IShellFolderViewDual2 * This,
            /* [retval][out] */ __RPC__out UINT *pViewMode);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CurrentViewMode )( 
            IShellFolderViewDual2 * This,
            /* [in] */ UINT ViewMode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SelectItemRelative )( 
            IShellFolderViewDual2 * This,
            /* [in] */ int iRelative);
        
        END_INTERFACE
    } IShellFolderViewDual2Vtbl;

    interface IShellFolderViewDual2
    {
        CONST_VTBL struct IShellFolderViewDual2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellFolderViewDual2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellFolderViewDual2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellFolderViewDual2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellFolderViewDual2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IShellFolderViewDual2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IShellFolderViewDual2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IShellFolderViewDual2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IShellFolderViewDual2_get_Application(This,ppid)	\
    ( (This)->lpVtbl -> get_Application(This,ppid) ) 

#define IShellFolderViewDual2_get_Parent(This,ppid)	\
    ( (This)->lpVtbl -> get_Parent(This,ppid) ) 

#define IShellFolderViewDual2_get_Folder(This,ppid)	\
    ( (This)->lpVtbl -> get_Folder(This,ppid) ) 

#define IShellFolderViewDual2_SelectedItems(This,ppid)	\
    ( (This)->lpVtbl -> SelectedItems(This,ppid) ) 

#define IShellFolderViewDual2_get_FocusedItem(This,ppid)	\
    ( (This)->lpVtbl -> get_FocusedItem(This,ppid) ) 

#define IShellFolderViewDual2_SelectItem(This,pvfi,dwFlags)	\
    ( (This)->lpVtbl -> SelectItem(This,pvfi,dwFlags) ) 

#define IShellFolderViewDual2_PopupItemMenu(This,pfi,vx,vy,pbs)	\
    ( (This)->lpVtbl -> PopupItemMenu(This,pfi,vx,vy,pbs) ) 

#define IShellFolderViewDual2_get_Script(This,ppDisp)	\
    ( (This)->lpVtbl -> get_Script(This,ppDisp) ) 

#define IShellFolderViewDual2_get_ViewOptions(This,plViewOptions)	\
    ( (This)->lpVtbl -> get_ViewOptions(This,plViewOptions) ) 


#define IShellFolderViewDual2_get_CurrentViewMode(This,pViewMode)	\
    ( (This)->lpVtbl -> get_CurrentViewMode(This,pViewMode) ) 

#define IShellFolderViewDual2_put_CurrentViewMode(This,ViewMode)	\
    ( (This)->lpVtbl -> put_CurrentViewMode(This,ViewMode) ) 

#define IShellFolderViewDual2_SelectItemRelative(This,iRelative)	\
    ( (This)->lpVtbl -> SelectItemRelative(This,iRelative) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellFolderViewDual2_INTERFACE_DEFINED__ */


#ifndef __IShellFolderViewDual3_INTERFACE_DEFINED__
#define __IShellFolderViewDual3_INTERFACE_DEFINED__

/* interface IShellFolderViewDual3 */
/* [object][dual][hidden][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_IShellFolderViewDual3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("29EC8E6C-46D3-411f-BAAA-611A6C9CAC66")
    IShellFolderViewDual3 : public IShellFolderViewDual2
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_GroupBy( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrGroupBy) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_GroupBy( 
            /* [in] */ __RPC__in BSTR bstrGroupBy) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_FolderFlags( 
            /* [retval][out] */ __RPC__out DWORD *pdwFlags) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_FolderFlags( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_SortColumns( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrSortColumns) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_SortColumns( 
            /* [in] */ __RPC__in BSTR bstrSortColumns) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_IconSize( 
            /* [in] */ int iIconSize) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_IconSize( 
            /* [retval][out] */ __RPC__out int *piIconSize) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FilterView( 
            /* [unique][in] */ __RPC__in_opt BSTR bstrFilterText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellFolderViewDual3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellFolderViewDual3 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellFolderViewDual3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellFolderViewDual3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IShellFolderViewDual3 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IShellFolderViewDual3 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IShellFolderViewDual3 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IShellFolderViewDual3 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Application )( 
            IShellFolderViewDual3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            IShellFolderViewDual3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Folder )( 
            IShellFolderViewDual3 * This,
            /* [retval][out] */ __RPC__deref_out_opt Folder **ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SelectedItems )( 
            IShellFolderViewDual3 * This,
            /* [retval][out] */ __RPC__deref_out_opt FolderItems **ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FocusedItem )( 
            IShellFolderViewDual3 * This,
            /* [retval][out] */ __RPC__deref_out_opt FolderItem **ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SelectItem )( 
            IShellFolderViewDual3 * This,
            /* [in] */ __RPC__in VARIANT *pvfi,
            /* [in] */ int dwFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *PopupItemMenu )( 
            IShellFolderViewDual3 * This,
            /* [in] */ __RPC__in_opt FolderItem *pfi,
            /* [optional][in] */ VARIANT vx,
            /* [optional][in] */ VARIANT vy,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbs);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Script )( 
            IShellFolderViewDual3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppDisp);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ViewOptions )( 
            IShellFolderViewDual3 * This,
            /* [retval][out] */ __RPC__out long *plViewOptions);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentViewMode )( 
            IShellFolderViewDual3 * This,
            /* [retval][out] */ __RPC__out UINT *pViewMode);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CurrentViewMode )( 
            IShellFolderViewDual3 * This,
            /* [in] */ UINT ViewMode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SelectItemRelative )( 
            IShellFolderViewDual3 * This,
            /* [in] */ int iRelative);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GroupBy )( 
            IShellFolderViewDual3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrGroupBy);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_GroupBy )( 
            IShellFolderViewDual3 * This,
            /* [in] */ __RPC__in BSTR bstrGroupBy);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FolderFlags )( 
            IShellFolderViewDual3 * This,
            /* [retval][out] */ __RPC__out DWORD *pdwFlags);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FolderFlags )( 
            IShellFolderViewDual3 * This,
            /* [in] */ DWORD dwFlags);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SortColumns )( 
            IShellFolderViewDual3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrSortColumns);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SortColumns )( 
            IShellFolderViewDual3 * This,
            /* [in] */ __RPC__in BSTR bstrSortColumns);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_IconSize )( 
            IShellFolderViewDual3 * This,
            /* [in] */ int iIconSize);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IconSize )( 
            IShellFolderViewDual3 * This,
            /* [retval][out] */ __RPC__out int *piIconSize);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FilterView )( 
            IShellFolderViewDual3 * This,
            /* [unique][in] */ __RPC__in_opt BSTR bstrFilterText);
        
        END_INTERFACE
    } IShellFolderViewDual3Vtbl;

    interface IShellFolderViewDual3
    {
        CONST_VTBL struct IShellFolderViewDual3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellFolderViewDual3_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellFolderViewDual3_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellFolderViewDual3_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellFolderViewDual3_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IShellFolderViewDual3_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IShellFolderViewDual3_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IShellFolderViewDual3_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IShellFolderViewDual3_get_Application(This,ppid)	\
    ( (This)->lpVtbl -> get_Application(This,ppid) ) 

#define IShellFolderViewDual3_get_Parent(This,ppid)	\
    ( (This)->lpVtbl -> get_Parent(This,ppid) ) 

#define IShellFolderViewDual3_get_Folder(This,ppid)	\
    ( (This)->lpVtbl -> get_Folder(This,ppid) ) 

#define IShellFolderViewDual3_SelectedItems(This,ppid)	\
    ( (This)->lpVtbl -> SelectedItems(This,ppid) ) 

#define IShellFolderViewDual3_get_FocusedItem(This,ppid)	\
    ( (This)->lpVtbl -> get_FocusedItem(This,ppid) ) 

#define IShellFolderViewDual3_SelectItem(This,pvfi,dwFlags)	\
    ( (This)->lpVtbl -> SelectItem(This,pvfi,dwFlags) ) 

#define IShellFolderViewDual3_PopupItemMenu(This,pfi,vx,vy,pbs)	\
    ( (This)->lpVtbl -> PopupItemMenu(This,pfi,vx,vy,pbs) ) 

#define IShellFolderViewDual3_get_Script(This,ppDisp)	\
    ( (This)->lpVtbl -> get_Script(This,ppDisp) ) 

#define IShellFolderViewDual3_get_ViewOptions(This,plViewOptions)	\
    ( (This)->lpVtbl -> get_ViewOptions(This,plViewOptions) ) 


#define IShellFolderViewDual3_get_CurrentViewMode(This,pViewMode)	\
    ( (This)->lpVtbl -> get_CurrentViewMode(This,pViewMode) ) 

#define IShellFolderViewDual3_put_CurrentViewMode(This,ViewMode)	\
    ( (This)->lpVtbl -> put_CurrentViewMode(This,ViewMode) ) 

#define IShellFolderViewDual3_SelectItemRelative(This,iRelative)	\
    ( (This)->lpVtbl -> SelectItemRelative(This,iRelative) ) 


#define IShellFolderViewDual3_get_GroupBy(This,pbstrGroupBy)	\
    ( (This)->lpVtbl -> get_GroupBy(This,pbstrGroupBy) ) 

#define IShellFolderViewDual3_put_GroupBy(This,bstrGroupBy)	\
    ( (This)->lpVtbl -> put_GroupBy(This,bstrGroupBy) ) 

#define IShellFolderViewDual3_get_FolderFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_FolderFlags(This,pdwFlags) ) 

#define IShellFolderViewDual3_put_FolderFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_FolderFlags(This,dwFlags) ) 

#define IShellFolderViewDual3_get_SortColumns(This,pbstrSortColumns)	\
    ( (This)->lpVtbl -> get_SortColumns(This,pbstrSortColumns) ) 

#define IShellFolderViewDual3_put_SortColumns(This,bstrSortColumns)	\
    ( (This)->lpVtbl -> put_SortColumns(This,bstrSortColumns) ) 

#define IShellFolderViewDual3_put_IconSize(This,iIconSize)	\
    ( (This)->lpVtbl -> put_IconSize(This,iIconSize) ) 

#define IShellFolderViewDual3_get_IconSize(This,piIconSize)	\
    ( (This)->lpVtbl -> get_IconSize(This,piIconSize) ) 

#define IShellFolderViewDual3_FilterView(This,bstrFilterText)	\
    ( (This)->lpVtbl -> FilterView(This,bstrFilterText) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellFolderViewDual3_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_ShellFolderView;

#ifdef __cplusplus

class DECLSPEC_UUID("62112AA1-EBE4-11cf-A5FB-0020AFE7292D")
ShellFolderView;
#endif

#ifndef __IShellDispatch_INTERFACE_DEFINED__
#define __IShellDispatch_INTERFACE_DEFINED__

/* interface IShellDispatch */
/* [object][dual][hidden][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_IShellDispatch;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D8F015C0-C278-11CE-A49E-444553540000")
    IShellDispatch : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE NameSpace( 
            /* [in] */ VARIANT vDir,
            /* [retval][out] */ __RPC__deref_out_opt Folder **ppsdf) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE BrowseForFolder( 
            /* [in] */ long Hwnd,
            /* [in] */ __RPC__in BSTR Title,
            /* [in] */ long Options,
            /* [optional][in] */ VARIANT RootFolder,
            /* [retval][out] */ __RPC__deref_out_opt Folder **ppsdf) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Windows( 
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ VARIANT vDir) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Explore( 
            /* [in] */ VARIANT vDir) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MinimizeAll( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UndoMinimizeALL( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FileRun( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CascadeWindows( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE TileVertically( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE TileHorizontally( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ShutdownWindows( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Suspend( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EjectPC( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetTime( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE TrayProperties( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Help( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FindFiles( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FindComputer( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RefreshMenu( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ControlPanelItem( 
            /* [in] */ __RPC__in BSTR bstrDir) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellDispatchVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellDispatch * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellDispatch * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellDispatch * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IShellDispatch * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IShellDispatch * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IShellDispatch * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IShellDispatch * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Application )( 
            IShellDispatch * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            IShellDispatch * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *NameSpace )( 
            IShellDispatch * This,
            /* [in] */ VARIANT vDir,
            /* [retval][out] */ __RPC__deref_out_opt Folder **ppsdf);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *BrowseForFolder )( 
            IShellDispatch * This,
            /* [in] */ long Hwnd,
            /* [in] */ __RPC__in BSTR Title,
            /* [in] */ long Options,
            /* [optional][in] */ VARIANT RootFolder,
            /* [retval][out] */ __RPC__deref_out_opt Folder **ppsdf);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Windows )( 
            IShellDispatch * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Open )( 
            IShellDispatch * This,
            /* [in] */ VARIANT vDir);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Explore )( 
            IShellDispatch * This,
            /* [in] */ VARIANT vDir);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *MinimizeAll )( 
            IShellDispatch * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *UndoMinimizeALL )( 
            IShellDispatch * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FileRun )( 
            IShellDispatch * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CascadeWindows )( 
            IShellDispatch * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *TileVertically )( 
            IShellDispatch * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *TileHorizontally )( 
            IShellDispatch * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ShutdownWindows )( 
            IShellDispatch * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Suspend )( 
            IShellDispatch * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EjectPC )( 
            IShellDispatch * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetTime )( 
            IShellDispatch * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *TrayProperties )( 
            IShellDispatch * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Help )( 
            IShellDispatch * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FindFiles )( 
            IShellDispatch * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FindComputer )( 
            IShellDispatch * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RefreshMenu )( 
            IShellDispatch * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ControlPanelItem )( 
            IShellDispatch * This,
            /* [in] */ __RPC__in BSTR bstrDir);
        
        END_INTERFACE
    } IShellDispatchVtbl;

    interface IShellDispatch
    {
        CONST_VTBL struct IShellDispatchVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellDispatch_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellDispatch_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellDispatch_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellDispatch_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IShellDispatch_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IShellDispatch_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IShellDispatch_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IShellDispatch_get_Application(This,ppid)	\
    ( (This)->lpVtbl -> get_Application(This,ppid) ) 

#define IShellDispatch_get_Parent(This,ppid)	\
    ( (This)->lpVtbl -> get_Parent(This,ppid) ) 

#define IShellDispatch_NameSpace(This,vDir,ppsdf)	\
    ( (This)->lpVtbl -> NameSpace(This,vDir,ppsdf) ) 

#define IShellDispatch_BrowseForFolder(This,Hwnd,Title,Options,RootFolder,ppsdf)	\
    ( (This)->lpVtbl -> BrowseForFolder(This,Hwnd,Title,Options,RootFolder,ppsdf) ) 

#define IShellDispatch_Windows(This,ppid)	\
    ( (This)->lpVtbl -> Windows(This,ppid) ) 

#define IShellDispatch_Open(This,vDir)	\
    ( (This)->lpVtbl -> Open(This,vDir) ) 

#define IShellDispatch_Explore(This,vDir)	\
    ( (This)->lpVtbl -> Explore(This,vDir) ) 

#define IShellDispatch_MinimizeAll(This)	\
    ( (This)->lpVtbl -> MinimizeAll(This) ) 

#define IShellDispatch_UndoMinimizeALL(This)	\
    ( (This)->lpVtbl -> UndoMinimizeALL(This) ) 

#define IShellDispatch_FileRun(This)	\
    ( (This)->lpVtbl -> FileRun(This) ) 

#define IShellDispatch_CascadeWindows(This)	\
    ( (This)->lpVtbl -> CascadeWindows(This) ) 

#define IShellDispatch_TileVertically(This)	\
    ( (This)->lpVtbl -> TileVertically(This) ) 

#define IShellDispatch_TileHorizontally(This)	\
    ( (This)->lpVtbl -> TileHorizontally(This) ) 

#define IShellDispatch_ShutdownWindows(This)	\
    ( (This)->lpVtbl -> ShutdownWindows(This) ) 

#define IShellDispatch_Suspend(This)	\
    ( (This)->lpVtbl -> Suspend(This) ) 

#define IShellDispatch_EjectPC(This)	\
    ( (This)->lpVtbl -> EjectPC(This) ) 

#define IShellDispatch_SetTime(This)	\
    ( (This)->lpVtbl -> SetTime(This) ) 

#define IShellDispatch_TrayProperties(This)	\
    ( (This)->lpVtbl -> TrayProperties(This) ) 

#define IShellDispatch_Help(This)	\
    ( (This)->lpVtbl -> Help(This) ) 

#define IShellDispatch_FindFiles(This)	\
    ( (This)->lpVtbl -> FindFiles(This) ) 

#define IShellDispatch_FindComputer(This)	\
    ( (This)->lpVtbl -> FindComputer(This) ) 

#define IShellDispatch_RefreshMenu(This)	\
    ( (This)->lpVtbl -> RefreshMenu(This) ) 

#define IShellDispatch_ControlPanelItem(This,bstrDir)	\
    ( (This)->lpVtbl -> ControlPanelItem(This,bstrDir) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellDispatch_INTERFACE_DEFINED__ */


#ifndef __IShellDispatch2_INTERFACE_DEFINED__
#define __IShellDispatch2_INTERFACE_DEFINED__

/* interface IShellDispatch2 */
/* [object][dual][hidden][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_IShellDispatch2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A4C6892C-3BA9-11d2-9DEA-00C04FB16162")
    IShellDispatch2 : public IShellDispatch
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsRestricted( 
            /* [in] */ __RPC__in BSTR Group,
            /* [in] */ __RPC__in BSTR Restriction,
            /* [retval][out] */ __RPC__out long *plRestrictValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ShellExecute( 
            /* [in] */ __RPC__in BSTR File,
            /* [optional][in] */ VARIANT vArgs,
            /* [optional][in] */ VARIANT vDir,
            /* [optional][in] */ VARIANT vOperation,
            /* [optional][in] */ VARIANT vShow) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FindPrinter( 
            /* [optional][in] */ __RPC__in BSTR name,
            /* [optional][in] */ __RPC__in BSTR location,
            /* [optional][in] */ __RPC__in BSTR model) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSystemInformation( 
            /* [in] */ __RPC__in BSTR name,
            /* [retval][out] */ __RPC__out VARIANT *pv) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ServiceStart( 
            /* [in] */ __RPC__in BSTR ServiceName,
            /* [in] */ VARIANT Persistent,
            /* [retval][out] */ __RPC__out VARIANT *pSuccess) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ServiceStop( 
            /* [in] */ __RPC__in BSTR ServiceName,
            /* [in] */ VARIANT Persistent,
            /* [retval][out] */ __RPC__out VARIANT *pSuccess) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsServiceRunning( 
            /* [in] */ __RPC__in BSTR ServiceName,
            /* [retval][out] */ __RPC__out VARIANT *pRunning) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CanStartStopService( 
            /* [in] */ __RPC__in BSTR ServiceName,
            /* [retval][out] */ __RPC__out VARIANT *pCanStartStop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ShowBrowserBar( 
            /* [in] */ __RPC__in BSTR bstrClsid,
            /* [in] */ VARIANT bShow,
            /* [retval][out] */ __RPC__out VARIANT *pSuccess) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellDispatch2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellDispatch2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellDispatch2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellDispatch2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IShellDispatch2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IShellDispatch2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IShellDispatch2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IShellDispatch2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Application )( 
            IShellDispatch2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            IShellDispatch2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *NameSpace )( 
            IShellDispatch2 * This,
            /* [in] */ VARIANT vDir,
            /* [retval][out] */ __RPC__deref_out_opt Folder **ppsdf);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *BrowseForFolder )( 
            IShellDispatch2 * This,
            /* [in] */ long Hwnd,
            /* [in] */ __RPC__in BSTR Title,
            /* [in] */ long Options,
            /* [optional][in] */ VARIANT RootFolder,
            /* [retval][out] */ __RPC__deref_out_opt Folder **ppsdf);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Windows )( 
            IShellDispatch2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Open )( 
            IShellDispatch2 * This,
            /* [in] */ VARIANT vDir);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Explore )( 
            IShellDispatch2 * This,
            /* [in] */ VARIANT vDir);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *MinimizeAll )( 
            IShellDispatch2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *UndoMinimizeALL )( 
            IShellDispatch2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FileRun )( 
            IShellDispatch2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CascadeWindows )( 
            IShellDispatch2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *TileVertically )( 
            IShellDispatch2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *TileHorizontally )( 
            IShellDispatch2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ShutdownWindows )( 
            IShellDispatch2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Suspend )( 
            IShellDispatch2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EjectPC )( 
            IShellDispatch2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetTime )( 
            IShellDispatch2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *TrayProperties )( 
            IShellDispatch2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Help )( 
            IShellDispatch2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FindFiles )( 
            IShellDispatch2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FindComputer )( 
            IShellDispatch2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RefreshMenu )( 
            IShellDispatch2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ControlPanelItem )( 
            IShellDispatch2 * This,
            /* [in] */ __RPC__in BSTR bstrDir);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *IsRestricted )( 
            IShellDispatch2 * This,
            /* [in] */ __RPC__in BSTR Group,
            /* [in] */ __RPC__in BSTR Restriction,
            /* [retval][out] */ __RPC__out long *plRestrictValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ShellExecute )( 
            IShellDispatch2 * This,
            /* [in] */ __RPC__in BSTR File,
            /* [optional][in] */ VARIANT vArgs,
            /* [optional][in] */ VARIANT vDir,
            /* [optional][in] */ VARIANT vOperation,
            /* [optional][in] */ VARIANT vShow);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FindPrinter )( 
            IShellDispatch2 * This,
            /* [optional][in] */ __RPC__in BSTR name,
            /* [optional][in] */ __RPC__in BSTR location,
            /* [optional][in] */ __RPC__in BSTR model);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSystemInformation )( 
            IShellDispatch2 * This,
            /* [in] */ __RPC__in BSTR name,
            /* [retval][out] */ __RPC__out VARIANT *pv);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ServiceStart )( 
            IShellDispatch2 * This,
            /* [in] */ __RPC__in BSTR ServiceName,
            /* [in] */ VARIANT Persistent,
            /* [retval][out] */ __RPC__out VARIANT *pSuccess);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ServiceStop )( 
            IShellDispatch2 * This,
            /* [in] */ __RPC__in BSTR ServiceName,
            /* [in] */ VARIANT Persistent,
            /* [retval][out] */ __RPC__out VARIANT *pSuccess);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *IsServiceRunning )( 
            IShellDispatch2 * This,
            /* [in] */ __RPC__in BSTR ServiceName,
            /* [retval][out] */ __RPC__out VARIANT *pRunning);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CanStartStopService )( 
            IShellDispatch2 * This,
            /* [in] */ __RPC__in BSTR ServiceName,
            /* [retval][out] */ __RPC__out VARIANT *pCanStartStop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ShowBrowserBar )( 
            IShellDispatch2 * This,
            /* [in] */ __RPC__in BSTR bstrClsid,
            /* [in] */ VARIANT bShow,
            /* [retval][out] */ __RPC__out VARIANT *pSuccess);
        
        END_INTERFACE
    } IShellDispatch2Vtbl;

    interface IShellDispatch2
    {
        CONST_VTBL struct IShellDispatch2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellDispatch2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellDispatch2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellDispatch2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellDispatch2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IShellDispatch2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IShellDispatch2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IShellDispatch2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IShellDispatch2_get_Application(This,ppid)	\
    ( (This)->lpVtbl -> get_Application(This,ppid) ) 

#define IShellDispatch2_get_Parent(This,ppid)	\
    ( (This)->lpVtbl -> get_Parent(This,ppid) ) 

#define IShellDispatch2_NameSpace(This,vDir,ppsdf)	\
    ( (This)->lpVtbl -> NameSpace(This,vDir,ppsdf) ) 

#define IShellDispatch2_BrowseForFolder(This,Hwnd,Title,Options,RootFolder,ppsdf)	\
    ( (This)->lpVtbl -> BrowseForFolder(This,Hwnd,Title,Options,RootFolder,ppsdf) ) 

#define IShellDispatch2_Windows(This,ppid)	\
    ( (This)->lpVtbl -> Windows(This,ppid) ) 

#define IShellDispatch2_Open(This,vDir)	\
    ( (This)->lpVtbl -> Open(This,vDir) ) 

#define IShellDispatch2_Explore(This,vDir)	\
    ( (This)->lpVtbl -> Explore(This,vDir) ) 

#define IShellDispatch2_MinimizeAll(This)	\
    ( (This)->lpVtbl -> MinimizeAll(This) ) 

#define IShellDispatch2_UndoMinimizeALL(This)	\
    ( (This)->lpVtbl -> UndoMinimizeALL(This) ) 

#define IShellDispatch2_FileRun(This)	\
    ( (This)->lpVtbl -> FileRun(This) ) 

#define IShellDispatch2_CascadeWindows(This)	\
    ( (This)->lpVtbl -> CascadeWindows(This) ) 

#define IShellDispatch2_TileVertically(This)	\
    ( (This)->lpVtbl -> TileVertically(This) ) 

#define IShellDispatch2_TileHorizontally(This)	\
    ( (This)->lpVtbl -> TileHorizontally(This) ) 

#define IShellDispatch2_ShutdownWindows(This)	\
    ( (This)->lpVtbl -> ShutdownWindows(This) ) 

#define IShellDispatch2_Suspend(This)	\
    ( (This)->lpVtbl -> Suspend(This) ) 

#define IShellDispatch2_EjectPC(This)	\
    ( (This)->lpVtbl -> EjectPC(This) ) 

#define IShellDispatch2_SetTime(This)	\
    ( (This)->lpVtbl -> SetTime(This) ) 

#define IShellDispatch2_TrayProperties(This)	\
    ( (This)->lpVtbl -> TrayProperties(This) ) 

#define IShellDispatch2_Help(This)	\
    ( (This)->lpVtbl -> Help(This) ) 

#define IShellDispatch2_FindFiles(This)	\
    ( (This)->lpVtbl -> FindFiles(This) ) 

#define IShellDispatch2_FindComputer(This)	\
    ( (This)->lpVtbl -> FindComputer(This) ) 

#define IShellDispatch2_RefreshMenu(This)	\
    ( (This)->lpVtbl -> RefreshMenu(This) ) 

#define IShellDispatch2_ControlPanelItem(This,bstrDir)	\
    ( (This)->lpVtbl -> ControlPanelItem(This,bstrDir) ) 


#define IShellDispatch2_IsRestricted(This,Group,Restriction,plRestrictValue)	\
    ( (This)->lpVtbl -> IsRestricted(This,Group,Restriction,plRestrictValue) ) 

#define IShellDispatch2_ShellExecute(This,File,vArgs,vDir,vOperation,vShow)	\
    ( (This)->lpVtbl -> ShellExecute(This,File,vArgs,vDir,vOperation,vShow) ) 

#define IShellDispatch2_FindPrinter(This,name,location,model)	\
    ( (This)->lpVtbl -> FindPrinter(This,name,location,model) ) 

#define IShellDispatch2_GetSystemInformation(This,name,pv)	\
    ( (This)->lpVtbl -> GetSystemInformation(This,name,pv) ) 

#define IShellDispatch2_ServiceStart(This,ServiceName,Persistent,pSuccess)	\
    ( (This)->lpVtbl -> ServiceStart(This,ServiceName,Persistent,pSuccess) ) 

#define IShellDispatch2_ServiceStop(This,ServiceName,Persistent,pSuccess)	\
    ( (This)->lpVtbl -> ServiceStop(This,ServiceName,Persistent,pSuccess) ) 

#define IShellDispatch2_IsServiceRunning(This,ServiceName,pRunning)	\
    ( (This)->lpVtbl -> IsServiceRunning(This,ServiceName,pRunning) ) 

#define IShellDispatch2_CanStartStopService(This,ServiceName,pCanStartStop)	\
    ( (This)->lpVtbl -> CanStartStopService(This,ServiceName,pCanStartStop) ) 

#define IShellDispatch2_ShowBrowserBar(This,bstrClsid,bShow,pSuccess)	\
    ( (This)->lpVtbl -> ShowBrowserBar(This,bstrClsid,bShow,pSuccess) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellDispatch2_INTERFACE_DEFINED__ */


#ifndef __IShellDispatch3_INTERFACE_DEFINED__
#define __IShellDispatch3_INTERFACE_DEFINED__

/* interface IShellDispatch3 */
/* [object][dual][hidden][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_IShellDispatch3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("177160ca-bb5a-411c-841d-bd38facdeaa0")
    IShellDispatch3 : public IShellDispatch2
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddToRecent( 
            /* [in] */ VARIANT varFile,
            /* [optional][in] */ __RPC__in BSTR bstrCategory) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellDispatch3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellDispatch3 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellDispatch3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellDispatch3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IShellDispatch3 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IShellDispatch3 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IShellDispatch3 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IShellDispatch3 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Application )( 
            IShellDispatch3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            IShellDispatch3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *NameSpace )( 
            IShellDispatch3 * This,
            /* [in] */ VARIANT vDir,
            /* [retval][out] */ __RPC__deref_out_opt Folder **ppsdf);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *BrowseForFolder )( 
            IShellDispatch3 * This,
            /* [in] */ long Hwnd,
            /* [in] */ __RPC__in BSTR Title,
            /* [in] */ long Options,
            /* [optional][in] */ VARIANT RootFolder,
            /* [retval][out] */ __RPC__deref_out_opt Folder **ppsdf);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Windows )( 
            IShellDispatch3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Open )( 
            IShellDispatch3 * This,
            /* [in] */ VARIANT vDir);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Explore )( 
            IShellDispatch3 * This,
            /* [in] */ VARIANT vDir);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *MinimizeAll )( 
            IShellDispatch3 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *UndoMinimizeALL )( 
            IShellDispatch3 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FileRun )( 
            IShellDispatch3 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CascadeWindows )( 
            IShellDispatch3 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *TileVertically )( 
            IShellDispatch3 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *TileHorizontally )( 
            IShellDispatch3 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ShutdownWindows )( 
            IShellDispatch3 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Suspend )( 
            IShellDispatch3 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EjectPC )( 
            IShellDispatch3 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetTime )( 
            IShellDispatch3 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *TrayProperties )( 
            IShellDispatch3 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Help )( 
            IShellDispatch3 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FindFiles )( 
            IShellDispatch3 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FindComputer )( 
            IShellDispatch3 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RefreshMenu )( 
            IShellDispatch3 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ControlPanelItem )( 
            IShellDispatch3 * This,
            /* [in] */ __RPC__in BSTR bstrDir);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *IsRestricted )( 
            IShellDispatch3 * This,
            /* [in] */ __RPC__in BSTR Group,
            /* [in] */ __RPC__in BSTR Restriction,
            /* [retval][out] */ __RPC__out long *plRestrictValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ShellExecute )( 
            IShellDispatch3 * This,
            /* [in] */ __RPC__in BSTR File,
            /* [optional][in] */ VARIANT vArgs,
            /* [optional][in] */ VARIANT vDir,
            /* [optional][in] */ VARIANT vOperation,
            /* [optional][in] */ VARIANT vShow);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FindPrinter )( 
            IShellDispatch3 * This,
            /* [optional][in] */ __RPC__in BSTR name,
            /* [optional][in] */ __RPC__in BSTR location,
            /* [optional][in] */ __RPC__in BSTR model);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSystemInformation )( 
            IShellDispatch3 * This,
            /* [in] */ __RPC__in BSTR name,
            /* [retval][out] */ __RPC__out VARIANT *pv);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ServiceStart )( 
            IShellDispatch3 * This,
            /* [in] */ __RPC__in BSTR ServiceName,
            /* [in] */ VARIANT Persistent,
            /* [retval][out] */ __RPC__out VARIANT *pSuccess);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ServiceStop )( 
            IShellDispatch3 * This,
            /* [in] */ __RPC__in BSTR ServiceName,
            /* [in] */ VARIANT Persistent,
            /* [retval][out] */ __RPC__out VARIANT *pSuccess);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *IsServiceRunning )( 
            IShellDispatch3 * This,
            /* [in] */ __RPC__in BSTR ServiceName,
            /* [retval][out] */ __RPC__out VARIANT *pRunning);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CanStartStopService )( 
            IShellDispatch3 * This,
            /* [in] */ __RPC__in BSTR ServiceName,
            /* [retval][out] */ __RPC__out VARIANT *pCanStartStop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ShowBrowserBar )( 
            IShellDispatch3 * This,
            /* [in] */ __RPC__in BSTR bstrClsid,
            /* [in] */ VARIANT bShow,
            /* [retval][out] */ __RPC__out VARIANT *pSuccess);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddToRecent )( 
            IShellDispatch3 * This,
            /* [in] */ VARIANT varFile,
            /* [optional][in] */ __RPC__in BSTR bstrCategory);
        
        END_INTERFACE
    } IShellDispatch3Vtbl;

    interface IShellDispatch3
    {
        CONST_VTBL struct IShellDispatch3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellDispatch3_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellDispatch3_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellDispatch3_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellDispatch3_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IShellDispatch3_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IShellDispatch3_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IShellDispatch3_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IShellDispatch3_get_Application(This,ppid)	\
    ( (This)->lpVtbl -> get_Application(This,ppid) ) 

#define IShellDispatch3_get_Parent(This,ppid)	\
    ( (This)->lpVtbl -> get_Parent(This,ppid) ) 

#define IShellDispatch3_NameSpace(This,vDir,ppsdf)	\
    ( (This)->lpVtbl -> NameSpace(This,vDir,ppsdf) ) 

#define IShellDispatch3_BrowseForFolder(This,Hwnd,Title,Options,RootFolder,ppsdf)	\
    ( (This)->lpVtbl -> BrowseForFolder(This,Hwnd,Title,Options,RootFolder,ppsdf) ) 

#define IShellDispatch3_Windows(This,ppid)	\
    ( (This)->lpVtbl -> Windows(This,ppid) ) 

#define IShellDispatch3_Open(This,vDir)	\
    ( (This)->lpVtbl -> Open(This,vDir) ) 

#define IShellDispatch3_Explore(This,vDir)	\
    ( (This)->lpVtbl -> Explore(This,vDir) ) 

#define IShellDispatch3_MinimizeAll(This)	\
    ( (This)->lpVtbl -> MinimizeAll(This) ) 

#define IShellDispatch3_UndoMinimizeALL(This)	\
    ( (This)->lpVtbl -> UndoMinimizeALL(This) ) 

#define IShellDispatch3_FileRun(This)	\
    ( (This)->lpVtbl -> FileRun(This) ) 

#define IShellDispatch3_CascadeWindows(This)	\
    ( (This)->lpVtbl -> CascadeWindows(This) ) 

#define IShellDispatch3_TileVertically(This)	\
    ( (This)->lpVtbl -> TileVertically(This) ) 

#define IShellDispatch3_TileHorizontally(This)	\
    ( (This)->lpVtbl -> TileHorizontally(This) ) 

#define IShellDispatch3_ShutdownWindows(This)	\
    ( (This)->lpVtbl -> ShutdownWindows(This) ) 

#define IShellDispatch3_Suspend(This)	\
    ( (This)->lpVtbl -> Suspend(This) ) 

#define IShellDispatch3_EjectPC(This)	\
    ( (This)->lpVtbl -> EjectPC(This) ) 

#define IShellDispatch3_SetTime(This)	\
    ( (This)->lpVtbl -> SetTime(This) ) 

#define IShellDispatch3_TrayProperties(This)	\
    ( (This)->lpVtbl -> TrayProperties(This) ) 

#define IShellDispatch3_Help(This)	\
    ( (This)->lpVtbl -> Help(This) ) 

#define IShellDispatch3_FindFiles(This)	\
    ( (This)->lpVtbl -> FindFiles(This) ) 

#define IShellDispatch3_FindComputer(This)	\
    ( (This)->lpVtbl -> FindComputer(This) ) 

#define IShellDispatch3_RefreshMenu(This)	\
    ( (This)->lpVtbl -> RefreshMenu(This) ) 

#define IShellDispatch3_ControlPanelItem(This,bstrDir)	\
    ( (This)->lpVtbl -> ControlPanelItem(This,bstrDir) ) 


#define IShellDispatch3_IsRestricted(This,Group,Restriction,plRestrictValue)	\
    ( (This)->lpVtbl -> IsRestricted(This,Group,Restriction,plRestrictValue) ) 

#define IShellDispatch3_ShellExecute(This,File,vArgs,vDir,vOperation,vShow)	\
    ( (This)->lpVtbl -> ShellExecute(This,File,vArgs,vDir,vOperation,vShow) ) 

#define IShellDispatch3_FindPrinter(This,name,location,model)	\
    ( (This)->lpVtbl -> FindPrinter(This,name,location,model) ) 

#define IShellDispatch3_GetSystemInformation(This,name,pv)	\
    ( (This)->lpVtbl -> GetSystemInformation(This,name,pv) ) 

#define IShellDispatch3_ServiceStart(This,ServiceName,Persistent,pSuccess)	\
    ( (This)->lpVtbl -> ServiceStart(This,ServiceName,Persistent,pSuccess) ) 

#define IShellDispatch3_ServiceStop(This,ServiceName,Persistent,pSuccess)	\
    ( (This)->lpVtbl -> ServiceStop(This,ServiceName,Persistent,pSuccess) ) 

#define IShellDispatch3_IsServiceRunning(This,ServiceName,pRunning)	\
    ( (This)->lpVtbl -> IsServiceRunning(This,ServiceName,pRunning) ) 

#define IShellDispatch3_CanStartStopService(This,ServiceName,pCanStartStop)	\
    ( (This)->lpVtbl -> CanStartStopService(This,ServiceName,pCanStartStop) ) 

#define IShellDispatch3_ShowBrowserBar(This,bstrClsid,bShow,pSuccess)	\
    ( (This)->lpVtbl -> ShowBrowserBar(This,bstrClsid,bShow,pSuccess) ) 


#define IShellDispatch3_AddToRecent(This,varFile,bstrCategory)	\
    ( (This)->lpVtbl -> AddToRecent(This,varFile,bstrCategory) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellDispatch3_INTERFACE_DEFINED__ */


#ifndef __IShellDispatch4_INTERFACE_DEFINED__
#define __IShellDispatch4_INTERFACE_DEFINED__

/* interface IShellDispatch4 */
/* [object][dual][hidden][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_IShellDispatch4;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("efd84b2d-4bcf-4298-be25-eb542a59fbda")
    IShellDispatch4 : public IShellDispatch3
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE WindowsSecurity( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ToggleDesktop( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ExplorerPolicy( 
            /* [in] */ __RPC__in BSTR bstrPolicyName,
            /* [retval][out] */ __RPC__out VARIANT *pValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSetting( 
            /* [in] */ long lSetting,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellDispatch4Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellDispatch4 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellDispatch4 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellDispatch4 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IShellDispatch4 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IShellDispatch4 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IShellDispatch4 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IShellDispatch4 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Application )( 
            IShellDispatch4 * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            IShellDispatch4 * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *NameSpace )( 
            IShellDispatch4 * This,
            /* [in] */ VARIANT vDir,
            /* [retval][out] */ __RPC__deref_out_opt Folder **ppsdf);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *BrowseForFolder )( 
            IShellDispatch4 * This,
            /* [in] */ long Hwnd,
            /* [in] */ __RPC__in BSTR Title,
            /* [in] */ long Options,
            /* [optional][in] */ VARIANT RootFolder,
            /* [retval][out] */ __RPC__deref_out_opt Folder **ppsdf);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Windows )( 
            IShellDispatch4 * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Open )( 
            IShellDispatch4 * This,
            /* [in] */ VARIANT vDir);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Explore )( 
            IShellDispatch4 * This,
            /* [in] */ VARIANT vDir);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *MinimizeAll )( 
            IShellDispatch4 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *UndoMinimizeALL )( 
            IShellDispatch4 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FileRun )( 
            IShellDispatch4 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CascadeWindows )( 
            IShellDispatch4 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *TileVertically )( 
            IShellDispatch4 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *TileHorizontally )( 
            IShellDispatch4 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ShutdownWindows )( 
            IShellDispatch4 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Suspend )( 
            IShellDispatch4 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EjectPC )( 
            IShellDispatch4 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetTime )( 
            IShellDispatch4 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *TrayProperties )( 
            IShellDispatch4 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Help )( 
            IShellDispatch4 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FindFiles )( 
            IShellDispatch4 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FindComputer )( 
            IShellDispatch4 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RefreshMenu )( 
            IShellDispatch4 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ControlPanelItem )( 
            IShellDispatch4 * This,
            /* [in] */ __RPC__in BSTR bstrDir);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *IsRestricted )( 
            IShellDispatch4 * This,
            /* [in] */ __RPC__in BSTR Group,
            /* [in] */ __RPC__in BSTR Restriction,
            /* [retval][out] */ __RPC__out long *plRestrictValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ShellExecute )( 
            IShellDispatch4 * This,
            /* [in] */ __RPC__in BSTR File,
            /* [optional][in] */ VARIANT vArgs,
            /* [optional][in] */ VARIANT vDir,
            /* [optional][in] */ VARIANT vOperation,
            /* [optional][in] */ VARIANT vShow);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FindPrinter )( 
            IShellDispatch4 * This,
            /* [optional][in] */ __RPC__in BSTR name,
            /* [optional][in] */ __RPC__in BSTR location,
            /* [optional][in] */ __RPC__in BSTR model);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSystemInformation )( 
            IShellDispatch4 * This,
            /* [in] */ __RPC__in BSTR name,
            /* [retval][out] */ __RPC__out VARIANT *pv);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ServiceStart )( 
            IShellDispatch4 * This,
            /* [in] */ __RPC__in BSTR ServiceName,
            /* [in] */ VARIANT Persistent,
            /* [retval][out] */ __RPC__out VARIANT *pSuccess);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ServiceStop )( 
            IShellDispatch4 * This,
            /* [in] */ __RPC__in BSTR ServiceName,
            /* [in] */ VARIANT Persistent,
            /* [retval][out] */ __RPC__out VARIANT *pSuccess);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *IsServiceRunning )( 
            IShellDispatch4 * This,
            /* [in] */ __RPC__in BSTR ServiceName,
            /* [retval][out] */ __RPC__out VARIANT *pRunning);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CanStartStopService )( 
            IShellDispatch4 * This,
            /* [in] */ __RPC__in BSTR ServiceName,
            /* [retval][out] */ __RPC__out VARIANT *pCanStartStop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ShowBrowserBar )( 
            IShellDispatch4 * This,
            /* [in] */ __RPC__in BSTR bstrClsid,
            /* [in] */ VARIANT bShow,
            /* [retval][out] */ __RPC__out VARIANT *pSuccess);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddToRecent )( 
            IShellDispatch4 * This,
            /* [in] */ VARIANT varFile,
            /* [optional][in] */ __RPC__in BSTR bstrCategory);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *WindowsSecurity )( 
            IShellDispatch4 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ToggleDesktop )( 
            IShellDispatch4 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ExplorerPolicy )( 
            IShellDispatch4 * This,
            /* [in] */ __RPC__in BSTR bstrPolicyName,
            /* [retval][out] */ __RPC__out VARIANT *pValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSetting )( 
            IShellDispatch4 * This,
            /* [in] */ long lSetting,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pResult);
        
        END_INTERFACE
    } IShellDispatch4Vtbl;

    interface IShellDispatch4
    {
        CONST_VTBL struct IShellDispatch4Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellDispatch4_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellDispatch4_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellDispatch4_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellDispatch4_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IShellDispatch4_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IShellDispatch4_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IShellDispatch4_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IShellDispatch4_get_Application(This,ppid)	\
    ( (This)->lpVtbl -> get_Application(This,ppid) ) 

#define IShellDispatch4_get_Parent(This,ppid)	\
    ( (This)->lpVtbl -> get_Parent(This,ppid) ) 

#define IShellDispatch4_NameSpace(This,vDir,ppsdf)	\
    ( (This)->lpVtbl -> NameSpace(This,vDir,ppsdf) ) 

#define IShellDispatch4_BrowseForFolder(This,Hwnd,Title,Options,RootFolder,ppsdf)	\
    ( (This)->lpVtbl -> BrowseForFolder(This,Hwnd,Title,Options,RootFolder,ppsdf) ) 

#define IShellDispatch4_Windows(This,ppid)	\
    ( (This)->lpVtbl -> Windows(This,ppid) ) 

#define IShellDispatch4_Open(This,vDir)	\
    ( (This)->lpVtbl -> Open(This,vDir) ) 

#define IShellDispatch4_Explore(This,vDir)	\
    ( (This)->lpVtbl -> Explore(This,vDir) ) 

#define IShellDispatch4_MinimizeAll(This)	\
    ( (This)->lpVtbl -> MinimizeAll(This) ) 

#define IShellDispatch4_UndoMinimizeALL(This)	\
    ( (This)->lpVtbl -> UndoMinimizeALL(This) ) 

#define IShellDispatch4_FileRun(This)	\
    ( (This)->lpVtbl -> FileRun(This) ) 

#define IShellDispatch4_CascadeWindows(This)	\
    ( (This)->lpVtbl -> CascadeWindows(This) ) 

#define IShellDispatch4_TileVertically(This)	\
    ( (This)->lpVtbl -> TileVertically(This) ) 

#define IShellDispatch4_TileHorizontally(This)	\
    ( (This)->lpVtbl -> TileHorizontally(This) ) 

#define IShellDispatch4_ShutdownWindows(This)	\
    ( (This)->lpVtbl -> ShutdownWindows(This) ) 

#define IShellDispatch4_Suspend(This)	\
    ( (This)->lpVtbl -> Suspend(This) ) 

#define IShellDispatch4_EjectPC(This)	\
    ( (This)->lpVtbl -> EjectPC(This) ) 

#define IShellDispatch4_SetTime(This)	\
    ( (This)->lpVtbl -> SetTime(This) ) 

#define IShellDispatch4_TrayProperties(This)	\
    ( (This)->lpVtbl -> TrayProperties(This) ) 

#define IShellDispatch4_Help(This)	\
    ( (This)->lpVtbl -> Help(This) ) 

#define IShellDispatch4_FindFiles(This)	\
    ( (This)->lpVtbl -> FindFiles(This) ) 

#define IShellDispatch4_FindComputer(This)	\
    ( (This)->lpVtbl -> FindComputer(This) ) 

#define IShellDispatch4_RefreshMenu(This)	\
    ( (This)->lpVtbl -> RefreshMenu(This) ) 

#define IShellDispatch4_ControlPanelItem(This,bstrDir)	\
    ( (This)->lpVtbl -> ControlPanelItem(This,bstrDir) ) 


#define IShellDispatch4_IsRestricted(This,Group,Restriction,plRestrictValue)	\
    ( (This)->lpVtbl -> IsRestricted(This,Group,Restriction,plRestrictValue) ) 

#define IShellDispatch4_ShellExecute(This,File,vArgs,vDir,vOperation,vShow)	\
    ( (This)->lpVtbl -> ShellExecute(This,File,vArgs,vDir,vOperation,vShow) ) 

#define IShellDispatch4_FindPrinter(This,name,location,model)	\
    ( (This)->lpVtbl -> FindPrinter(This,name,location,model) ) 

#define IShellDispatch4_GetSystemInformation(This,name,pv)	\
    ( (This)->lpVtbl -> GetSystemInformation(This,name,pv) ) 

#define IShellDispatch4_ServiceStart(This,ServiceName,Persistent,pSuccess)	\
    ( (This)->lpVtbl -> ServiceStart(This,ServiceName,Persistent,pSuccess) ) 

#define IShellDispatch4_ServiceStop(This,ServiceName,Persistent,pSuccess)	\
    ( (This)->lpVtbl -> ServiceStop(This,ServiceName,Persistent,pSuccess) ) 

#define IShellDispatch4_IsServiceRunning(This,ServiceName,pRunning)	\
    ( (This)->lpVtbl -> IsServiceRunning(This,ServiceName,pRunning) ) 

#define IShellDispatch4_CanStartStopService(This,ServiceName,pCanStartStop)	\
    ( (This)->lpVtbl -> CanStartStopService(This,ServiceName,pCanStartStop) ) 

#define IShellDispatch4_ShowBrowserBar(This,bstrClsid,bShow,pSuccess)	\
    ( (This)->lpVtbl -> ShowBrowserBar(This,bstrClsid,bShow,pSuccess) ) 


#define IShellDispatch4_AddToRecent(This,varFile,bstrCategory)	\
    ( (This)->lpVtbl -> AddToRecent(This,varFile,bstrCategory) ) 


#define IShellDispatch4_WindowsSecurity(This)	\
    ( (This)->lpVtbl -> WindowsSecurity(This) ) 

#define IShellDispatch4_ToggleDesktop(This)	\
    ( (This)->lpVtbl -> ToggleDesktop(This) ) 

#define IShellDispatch4_ExplorerPolicy(This,bstrPolicyName,pValue)	\
    ( (This)->lpVtbl -> ExplorerPolicy(This,bstrPolicyName,pValue) ) 

#define IShellDispatch4_GetSetting(This,lSetting,pResult)	\
    ( (This)->lpVtbl -> GetSetting(This,lSetting,pResult) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellDispatch4_INTERFACE_DEFINED__ */


#ifndef __IShellDispatch5_INTERFACE_DEFINED__
#define __IShellDispatch5_INTERFACE_DEFINED__

/* interface IShellDispatch5 */
/* [object][dual][hidden][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_IShellDispatch5;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("866738b9-6cf2-4de8-8767-f794ebe74f4e")
    IShellDispatch5 : public IShellDispatch4
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE WindowSwitcher( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellDispatch5Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellDispatch5 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellDispatch5 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellDispatch5 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IShellDispatch5 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IShellDispatch5 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IShellDispatch5 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IShellDispatch5 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Application )( 
            IShellDispatch5 * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            IShellDispatch5 * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *NameSpace )( 
            IShellDispatch5 * This,
            /* [in] */ VARIANT vDir,
            /* [retval][out] */ __RPC__deref_out_opt Folder **ppsdf);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *BrowseForFolder )( 
            IShellDispatch5 * This,
            /* [in] */ long Hwnd,
            /* [in] */ __RPC__in BSTR Title,
            /* [in] */ long Options,
            /* [optional][in] */ VARIANT RootFolder,
            /* [retval][out] */ __RPC__deref_out_opt Folder **ppsdf);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Windows )( 
            IShellDispatch5 * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Open )( 
            IShellDispatch5 * This,
            /* [in] */ VARIANT vDir);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Explore )( 
            IShellDispatch5 * This,
            /* [in] */ VARIANT vDir);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *MinimizeAll )( 
            IShellDispatch5 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *UndoMinimizeALL )( 
            IShellDispatch5 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FileRun )( 
            IShellDispatch5 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CascadeWindows )( 
            IShellDispatch5 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *TileVertically )( 
            IShellDispatch5 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *TileHorizontally )( 
            IShellDispatch5 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ShutdownWindows )( 
            IShellDispatch5 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Suspend )( 
            IShellDispatch5 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EjectPC )( 
            IShellDispatch5 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetTime )( 
            IShellDispatch5 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *TrayProperties )( 
            IShellDispatch5 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Help )( 
            IShellDispatch5 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FindFiles )( 
            IShellDispatch5 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FindComputer )( 
            IShellDispatch5 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RefreshMenu )( 
            IShellDispatch5 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ControlPanelItem )( 
            IShellDispatch5 * This,
            /* [in] */ __RPC__in BSTR bstrDir);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *IsRestricted )( 
            IShellDispatch5 * This,
            /* [in] */ __RPC__in BSTR Group,
            /* [in] */ __RPC__in BSTR Restriction,
            /* [retval][out] */ __RPC__out long *plRestrictValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ShellExecute )( 
            IShellDispatch5 * This,
            /* [in] */ __RPC__in BSTR File,
            /* [optional][in] */ VARIANT vArgs,
            /* [optional][in] */ VARIANT vDir,
            /* [optional][in] */ VARIANT vOperation,
            /* [optional][in] */ VARIANT vShow);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FindPrinter )( 
            IShellDispatch5 * This,
            /* [optional][in] */ __RPC__in BSTR name,
            /* [optional][in] */ __RPC__in BSTR location,
            /* [optional][in] */ __RPC__in BSTR model);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSystemInformation )( 
            IShellDispatch5 * This,
            /* [in] */ __RPC__in BSTR name,
            /* [retval][out] */ __RPC__out VARIANT *pv);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ServiceStart )( 
            IShellDispatch5 * This,
            /* [in] */ __RPC__in BSTR ServiceName,
            /* [in] */ VARIANT Persistent,
            /* [retval][out] */ __RPC__out VARIANT *pSuccess);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ServiceStop )( 
            IShellDispatch5 * This,
            /* [in] */ __RPC__in BSTR ServiceName,
            /* [in] */ VARIANT Persistent,
            /* [retval][out] */ __RPC__out VARIANT *pSuccess);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *IsServiceRunning )( 
            IShellDispatch5 * This,
            /* [in] */ __RPC__in BSTR ServiceName,
            /* [retval][out] */ __RPC__out VARIANT *pRunning);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CanStartStopService )( 
            IShellDispatch5 * This,
            /* [in] */ __RPC__in BSTR ServiceName,
            /* [retval][out] */ __RPC__out VARIANT *pCanStartStop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ShowBrowserBar )( 
            IShellDispatch5 * This,
            /* [in] */ __RPC__in BSTR bstrClsid,
            /* [in] */ VARIANT bShow,
            /* [retval][out] */ __RPC__out VARIANT *pSuccess);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddToRecent )( 
            IShellDispatch5 * This,
            /* [in] */ VARIANT varFile,
            /* [optional][in] */ __RPC__in BSTR bstrCategory);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *WindowsSecurity )( 
            IShellDispatch5 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ToggleDesktop )( 
            IShellDispatch5 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ExplorerPolicy )( 
            IShellDispatch5 * This,
            /* [in] */ __RPC__in BSTR bstrPolicyName,
            /* [retval][out] */ __RPC__out VARIANT *pValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSetting )( 
            IShellDispatch5 * This,
            /* [in] */ long lSetting,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pResult);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *WindowSwitcher )( 
            IShellDispatch5 * This);
        
        END_INTERFACE
    } IShellDispatch5Vtbl;

    interface IShellDispatch5
    {
        CONST_VTBL struct IShellDispatch5Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellDispatch5_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellDispatch5_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellDispatch5_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellDispatch5_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IShellDispatch5_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IShellDispatch5_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IShellDispatch5_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IShellDispatch5_get_Application(This,ppid)	\
    ( (This)->lpVtbl -> get_Application(This,ppid) ) 

#define IShellDispatch5_get_Parent(This,ppid)	\
    ( (This)->lpVtbl -> get_Parent(This,ppid) ) 

#define IShellDispatch5_NameSpace(This,vDir,ppsdf)	\
    ( (This)->lpVtbl -> NameSpace(This,vDir,ppsdf) ) 

#define IShellDispatch5_BrowseForFolder(This,Hwnd,Title,Options,RootFolder,ppsdf)	\
    ( (This)->lpVtbl -> BrowseForFolder(This,Hwnd,Title,Options,RootFolder,ppsdf) ) 

#define IShellDispatch5_Windows(This,ppid)	\
    ( (This)->lpVtbl -> Windows(This,ppid) ) 

#define IShellDispatch5_Open(This,vDir)	\
    ( (This)->lpVtbl -> Open(This,vDir) ) 

#define IShellDispatch5_Explore(This,vDir)	\
    ( (This)->lpVtbl -> Explore(This,vDir) ) 

#define IShellDispatch5_MinimizeAll(This)	\
    ( (This)->lpVtbl -> MinimizeAll(This) ) 

#define IShellDispatch5_UndoMinimizeALL(This)	\
    ( (This)->lpVtbl -> UndoMinimizeALL(This) ) 

#define IShellDispatch5_FileRun(This)	\
    ( (This)->lpVtbl -> FileRun(This) ) 

#define IShellDispatch5_CascadeWindows(This)	\
    ( (This)->lpVtbl -> CascadeWindows(This) ) 

#define IShellDispatch5_TileVertically(This)	\
    ( (This)->lpVtbl -> TileVertically(This) ) 

#define IShellDispatch5_TileHorizontally(This)	\
    ( (This)->lpVtbl -> TileHorizontally(This) ) 

#define IShellDispatch5_ShutdownWindows(This)	\
    ( (This)->lpVtbl -> ShutdownWindows(This) ) 

#define IShellDispatch5_Suspend(This)	\
    ( (This)->lpVtbl -> Suspend(This) ) 

#define IShellDispatch5_EjectPC(This)	\
    ( (This)->lpVtbl -> EjectPC(This) ) 

#define IShellDispatch5_SetTime(This)	\
    ( (This)->lpVtbl -> SetTime(This) ) 

#define IShellDispatch5_TrayProperties(This)	\
    ( (This)->lpVtbl -> TrayProperties(This) ) 

#define IShellDispatch5_Help(This)	\
    ( (This)->lpVtbl -> Help(This) ) 

#define IShellDispatch5_FindFiles(This)	\
    ( (This)->lpVtbl -> FindFiles(This) ) 

#define IShellDispatch5_FindComputer(This)	\
    ( (This)->lpVtbl -> FindComputer(This) ) 

#define IShellDispatch5_RefreshMenu(This)	\
    ( (This)->lpVtbl -> RefreshMenu(This) ) 

#define IShellDispatch5_ControlPanelItem(This,bstrDir)	\
    ( (This)->lpVtbl -> ControlPanelItem(This,bstrDir) ) 


#define IShellDispatch5_IsRestricted(This,Group,Restriction,plRestrictValue)	\
    ( (This)->lpVtbl -> IsRestricted(This,Group,Restriction,plRestrictValue) ) 

#define IShellDispatch5_ShellExecute(This,File,vArgs,vDir,vOperation,vShow)	\
    ( (This)->lpVtbl -> ShellExecute(This,File,vArgs,vDir,vOperation,vShow) ) 

#define IShellDispatch5_FindPrinter(This,name,location,model)	\
    ( (This)->lpVtbl -> FindPrinter(This,name,location,model) ) 

#define IShellDispatch5_GetSystemInformation(This,name,pv)	\
    ( (This)->lpVtbl -> GetSystemInformation(This,name,pv) ) 

#define IShellDispatch5_ServiceStart(This,ServiceName,Persistent,pSuccess)	\
    ( (This)->lpVtbl -> ServiceStart(This,ServiceName,Persistent,pSuccess) ) 

#define IShellDispatch5_ServiceStop(This,ServiceName,Persistent,pSuccess)	\
    ( (This)->lpVtbl -> ServiceStop(This,ServiceName,Persistent,pSuccess) ) 

#define IShellDispatch5_IsServiceRunning(This,ServiceName,pRunning)	\
    ( (This)->lpVtbl -> IsServiceRunning(This,ServiceName,pRunning) ) 

#define IShellDispatch5_CanStartStopService(This,ServiceName,pCanStartStop)	\
    ( (This)->lpVtbl -> CanStartStopService(This,ServiceName,pCanStartStop) ) 

#define IShellDispatch5_ShowBrowserBar(This,bstrClsid,bShow,pSuccess)	\
    ( (This)->lpVtbl -> ShowBrowserBar(This,bstrClsid,bShow,pSuccess) ) 


#define IShellDispatch5_AddToRecent(This,varFile,bstrCategory)	\
    ( (This)->lpVtbl -> AddToRecent(This,varFile,bstrCategory) ) 


#define IShellDispatch5_WindowsSecurity(This)	\
    ( (This)->lpVtbl -> WindowsSecurity(This) ) 

#define IShellDispatch5_ToggleDesktop(This)	\
    ( (This)->lpVtbl -> ToggleDesktop(This) ) 

#define IShellDispatch5_ExplorerPolicy(This,bstrPolicyName,pValue)	\
    ( (This)->lpVtbl -> ExplorerPolicy(This,bstrPolicyName,pValue) ) 

#define IShellDispatch5_GetSetting(This,lSetting,pResult)	\
    ( (This)->lpVtbl -> GetSetting(This,lSetting,pResult) ) 


#define IShellDispatch5_WindowSwitcher(This)	\
    ( (This)->lpVtbl -> WindowSwitcher(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellDispatch5_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_Shell;

#ifdef __cplusplus

class DECLSPEC_UUID("13709620-C279-11CE-A49E-444553540000")
Shell;
#endif

EXTERN_C const CLSID CLSID_ShellDispatchInproc;

#ifdef __cplusplus

class DECLSPEC_UUID("0A89A860-D7B1-11CE-8350-444553540000")
ShellDispatchInproc;
#endif

#ifndef __IFileSearchBand_INTERFACE_DEFINED__
#define __IFileSearchBand_INTERFACE_DEFINED__

/* interface IFileSearchBand */
/* [object][unique][hidden][dual][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_IFileSearchBand;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2D91EEA1-9932-11d2-BE86-00A0C9A83DA1")
    IFileSearchBand : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetFocus( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetSearchParameters( 
            /* [in] */ __RPC__deref_in_opt BSTR *pbstrSearchID,
            /* [in] */ VARIANT_BOOL bNavToResults,
            /* [optional][in] */ __RPC__in VARIANT *pvarScope,
            /* [optional][in] */ __RPC__in VARIANT *pvarQueryFile) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SearchID( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrSearchID) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Scope( 
            /* [retval][out] */ __RPC__out VARIANT *pvarScope) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_QueryFile( 
            /* [retval][out] */ __RPC__out VARIANT *pvarFile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFileSearchBandVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFileSearchBand * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFileSearchBand * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFileSearchBand * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFileSearchBand * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFileSearchBand * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFileSearchBand * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFileSearchBand * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetFocus )( 
            IFileSearchBand * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetSearchParameters )( 
            IFileSearchBand * This,
            /* [in] */ __RPC__deref_in_opt BSTR *pbstrSearchID,
            /* [in] */ VARIANT_BOOL bNavToResults,
            /* [optional][in] */ __RPC__in VARIANT *pvarScope,
            /* [optional][in] */ __RPC__in VARIANT *pvarQueryFile);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SearchID )( 
            IFileSearchBand * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrSearchID);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Scope )( 
            IFileSearchBand * This,
            /* [retval][out] */ __RPC__out VARIANT *pvarScope);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_QueryFile )( 
            IFileSearchBand * This,
            /* [retval][out] */ __RPC__out VARIANT *pvarFile);
        
        END_INTERFACE
    } IFileSearchBandVtbl;

    interface IFileSearchBand
    {
        CONST_VTBL struct IFileSearchBandVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFileSearchBand_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFileSearchBand_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFileSearchBand_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFileSearchBand_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IFileSearchBand_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IFileSearchBand_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IFileSearchBand_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IFileSearchBand_SetFocus(This)	\
    ( (This)->lpVtbl -> SetFocus(This) ) 

#define IFileSearchBand_SetSearchParameters(This,pbstrSearchID,bNavToResults,pvarScope,pvarQueryFile)	\
    ( (This)->lpVtbl -> SetSearchParameters(This,pbstrSearchID,bNavToResults,pvarScope,pvarQueryFile) ) 

#define IFileSearchBand_get_SearchID(This,pbstrSearchID)	\
    ( (This)->lpVtbl -> get_SearchID(This,pbstrSearchID) ) 

#define IFileSearchBand_get_Scope(This,pvarScope)	\
    ( (This)->lpVtbl -> get_Scope(This,pvarScope) ) 

#define IFileSearchBand_get_QueryFile(This,pvarFile)	\
    ( (This)->lpVtbl -> get_QueryFile(This,pvarFile) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFileSearchBand_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_FileSearchBand;

#ifdef __cplusplus

class DECLSPEC_UUID("C4EE31F3-4768-11D2-BE5C-00A0C9A83DA1")
FileSearchBand;
#endif

#ifndef __IWebWizardHost_INTERFACE_DEFINED__
#define __IWebWizardHost_INTERFACE_DEFINED__

/* interface IWebWizardHost */
/* [helpstring][dual][object][uuid] */ 


EXTERN_C const IID IID_IWebWizardHost;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("18bcc359-4990-4bfb-b951-3c83702be5f9")
    IWebWizardHost : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE FinalBack( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE FinalNext( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Caption( 
            /* [in] */ __RPC__in BSTR bstrCaption) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Caption( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrCaption) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Property( 
            /* [in] */ __RPC__in BSTR bstrPropertyName,
            /* [in] */ __RPC__in VARIANT *pvProperty) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Property( 
            /* [in] */ __RPC__in BSTR bstrPropertyName,
            /* [retval][out] */ __RPC__out VARIANT *pvProperty) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetWizardButtons( 
            /* [in] */ VARIANT_BOOL vfEnableBack,
            /* [in] */ VARIANT_BOOL vfEnableNext,
            /* [in] */ VARIANT_BOOL vfLastPage) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetHeaderText( 
            /* [in] */ __RPC__in BSTR bstrHeaderTitle,
            /* [in] */ __RPC__in BSTR bstrHeaderSubtitle) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWebWizardHostVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWebWizardHost * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWebWizardHost * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWebWizardHost * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWebWizardHost * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWebWizardHost * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWebWizardHost * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWebWizardHost * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *FinalBack )( 
            IWebWizardHost * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *FinalNext )( 
            IWebWizardHost * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            IWebWizardHost * This);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Caption )( 
            IWebWizardHost * This,
            /* [in] */ __RPC__in BSTR bstrCaption);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Caption )( 
            IWebWizardHost * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrCaption);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Property )( 
            IWebWizardHost * This,
            /* [in] */ __RPC__in BSTR bstrPropertyName,
            /* [in] */ __RPC__in VARIANT *pvProperty);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Property )( 
            IWebWizardHost * This,
            /* [in] */ __RPC__in BSTR bstrPropertyName,
            /* [retval][out] */ __RPC__out VARIANT *pvProperty);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *SetWizardButtons )( 
            IWebWizardHost * This,
            /* [in] */ VARIANT_BOOL vfEnableBack,
            /* [in] */ VARIANT_BOOL vfEnableNext,
            /* [in] */ VARIANT_BOOL vfLastPage);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *SetHeaderText )( 
            IWebWizardHost * This,
            /* [in] */ __RPC__in BSTR bstrHeaderTitle,
            /* [in] */ __RPC__in BSTR bstrHeaderSubtitle);
        
        END_INTERFACE
    } IWebWizardHostVtbl;

    interface IWebWizardHost
    {
        CONST_VTBL struct IWebWizardHostVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWebWizardHost_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWebWizardHost_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWebWizardHost_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWebWizardHost_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWebWizardHost_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWebWizardHost_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWebWizardHost_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWebWizardHost_FinalBack(This)	\
    ( (This)->lpVtbl -> FinalBack(This) ) 

#define IWebWizardHost_FinalNext(This)	\
    ( (This)->lpVtbl -> FinalNext(This) ) 

#define IWebWizardHost_Cancel(This)	\
    ( (This)->lpVtbl -> Cancel(This) ) 

#define IWebWizardHost_put_Caption(This,bstrCaption)	\
    ( (This)->lpVtbl -> put_Caption(This,bstrCaption) ) 

#define IWebWizardHost_get_Caption(This,pbstrCaption)	\
    ( (This)->lpVtbl -> get_Caption(This,pbstrCaption) ) 

#define IWebWizardHost_put_Property(This,bstrPropertyName,pvProperty)	\
    ( (This)->lpVtbl -> put_Property(This,bstrPropertyName,pvProperty) ) 

#define IWebWizardHost_get_Property(This,bstrPropertyName,pvProperty)	\
    ( (This)->lpVtbl -> get_Property(This,bstrPropertyName,pvProperty) ) 

#define IWebWizardHost_SetWizardButtons(This,vfEnableBack,vfEnableNext,vfLastPage)	\
    ( (This)->lpVtbl -> SetWizardButtons(This,vfEnableBack,vfEnableNext,vfLastPage) ) 

#define IWebWizardHost_SetHeaderText(This,bstrHeaderTitle,bstrHeaderSubtitle)	\
    ( (This)->lpVtbl -> SetHeaderText(This,bstrHeaderTitle,bstrHeaderSubtitle) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWebWizardHost_INTERFACE_DEFINED__ */


#ifndef __INewWDEvents_INTERFACE_DEFINED__
#define __INewWDEvents_INTERFACE_DEFINED__

/* interface INewWDEvents */
/* [helpstring][dual][object][uuid] */ 


EXTERN_C const IID IID_INewWDEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0751c551-7568-41c9-8e5b-e22e38919236")
    INewWDEvents : public IWebWizardHost
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE PassportAuthenticate( 
            /* [in] */ __RPC__in BSTR bstrSignInUrl,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pvfAuthenitcated) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INewWDEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INewWDEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INewWDEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INewWDEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            INewWDEvents * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            INewWDEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            INewWDEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INewWDEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *FinalBack )( 
            INewWDEvents * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *FinalNext )( 
            INewWDEvents * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            INewWDEvents * This);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Caption )( 
            INewWDEvents * This,
            /* [in] */ __RPC__in BSTR bstrCaption);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Caption )( 
            INewWDEvents * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrCaption);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Property )( 
            INewWDEvents * This,
            /* [in] */ __RPC__in BSTR bstrPropertyName,
            /* [in] */ __RPC__in VARIANT *pvProperty);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Property )( 
            INewWDEvents * This,
            /* [in] */ __RPC__in BSTR bstrPropertyName,
            /* [retval][out] */ __RPC__out VARIANT *pvProperty);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *SetWizardButtons )( 
            INewWDEvents * This,
            /* [in] */ VARIANT_BOOL vfEnableBack,
            /* [in] */ VARIANT_BOOL vfEnableNext,
            /* [in] */ VARIANT_BOOL vfLastPage);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *SetHeaderText )( 
            INewWDEvents * This,
            /* [in] */ __RPC__in BSTR bstrHeaderTitle,
            /* [in] */ __RPC__in BSTR bstrHeaderSubtitle);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *PassportAuthenticate )( 
            INewWDEvents * This,
            /* [in] */ __RPC__in BSTR bstrSignInUrl,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pvfAuthenitcated);
        
        END_INTERFACE
    } INewWDEventsVtbl;

    interface INewWDEvents
    {
        CONST_VTBL struct INewWDEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INewWDEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INewWDEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INewWDEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INewWDEvents_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INewWDEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INewWDEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INewWDEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INewWDEvents_FinalBack(This)	\
    ( (This)->lpVtbl -> FinalBack(This) ) 

#define INewWDEvents_FinalNext(This)	\
    ( (This)->lpVtbl -> FinalNext(This) ) 

#define INewWDEvents_Cancel(This)	\
    ( (This)->lpVtbl -> Cancel(This) ) 

#define INewWDEvents_put_Caption(This,bstrCaption)	\
    ( (This)->lpVtbl -> put_Caption(This,bstrCaption) ) 

#define INewWDEvents_get_Caption(This,pbstrCaption)	\
    ( (This)->lpVtbl -> get_Caption(This,pbstrCaption) ) 

#define INewWDEvents_put_Property(This,bstrPropertyName,pvProperty)	\
    ( (This)->lpVtbl -> put_Property(This,bstrPropertyName,pvProperty) ) 

#define INewWDEvents_get_Property(This,bstrPropertyName,pvProperty)	\
    ( (This)->lpVtbl -> get_Property(This,bstrPropertyName,pvProperty) ) 

#define INewWDEvents_SetWizardButtons(This,vfEnableBack,vfEnableNext,vfLastPage)	\
    ( (This)->lpVtbl -> SetWizardButtons(This,vfEnableBack,vfEnableNext,vfLastPage) ) 

#define INewWDEvents_SetHeaderText(This,bstrHeaderTitle,bstrHeaderSubtitle)	\
    ( (This)->lpVtbl -> SetHeaderText(This,bstrHeaderTitle,bstrHeaderSubtitle) ) 


#define INewWDEvents_PassportAuthenticate(This,bstrSignInUrl,pvfAuthenitcated)	\
    ( (This)->lpVtbl -> PassportAuthenticate(This,bstrSignInUrl,pvfAuthenitcated) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INewWDEvents_INTERFACE_DEFINED__ */

#endif /* __Shell32_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_shldisp_0001_0067 */
/* [local] */ 


//-------------------------------------------------------------------------
//
// IAutoComplete interface
//
//
// [Member functions]
//
// IAutoComplete::Init(hwndEdit, punkACL, pwszRegKeyPath, pwszQuickComplete)
//   This function initializes an AutoComplete object, telling it
//   what control to subclass, and what list of strings to process.
//
// IAutoComplete::Enable(fEnable)
//   This function enables or disables the AutoComplete functionality.
//
//-------------------------------------------------------------------------


extern RPC_IF_HANDLE __MIDL_itf_shldisp_0001_0067_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shldisp_0001_0067_v0_0_s_ifspec;

#ifndef __IAutoComplete_INTERFACE_DEFINED__
#define __IAutoComplete_INTERFACE_DEFINED__

/* interface IAutoComplete */
/* [unique][uuid][object][local][helpstring] */ 

typedef /* [unique] */ IAutoComplete *LPAUTOCOMPLETE;


EXTERN_C const IID IID_IAutoComplete;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00bb2762-6a77-11d0-a535-00c04fd7d062")
    IAutoComplete : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( 
            /* [in] */ 
            __in  HWND hwndEdit,
            /* [unique][in] */ 
            __in  IUnknown *punkACL,
            /* [unique][in] */ 
            __in_opt  LPCWSTR pwszRegKeyPath,
            /* [in] */ 
            __in_opt  LPCWSTR pwszQuickComplete) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Enable( 
            /* [in] */ BOOL fEnable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAutoCompleteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAutoComplete * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAutoComplete * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAutoComplete * This);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IAutoComplete * This,
            /* [in] */ 
            __in  HWND hwndEdit,
            /* [unique][in] */ 
            __in  IUnknown *punkACL,
            /* [unique][in] */ 
            __in_opt  LPCWSTR pwszRegKeyPath,
            /* [in] */ 
            __in_opt  LPCWSTR pwszQuickComplete);
        
        HRESULT ( STDMETHODCALLTYPE *Enable )( 
            IAutoComplete * This,
            /* [in] */ BOOL fEnable);
        
        END_INTERFACE
    } IAutoCompleteVtbl;

    interface IAutoComplete
    {
        CONST_VTBL struct IAutoCompleteVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAutoComplete_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAutoComplete_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAutoComplete_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAutoComplete_Init(This,hwndEdit,punkACL,pwszRegKeyPath,pwszQuickComplete)	\
    ( (This)->lpVtbl -> Init(This,hwndEdit,punkACL,pwszRegKeyPath,pwszQuickComplete) ) 

#define IAutoComplete_Enable(This,fEnable)	\
    ( (This)->lpVtbl -> Enable(This,fEnable) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAutoComplete_INTERFACE_DEFINED__ */


#ifndef __IAutoComplete2_INTERFACE_DEFINED__
#define __IAutoComplete2_INTERFACE_DEFINED__

/* interface IAutoComplete2 */
/* [unique][uuid][object][local][helpstring] */ 

typedef /* [unique] */ IAutoComplete2 *LPAUTOCOMPLETE2;

typedef 
enum _tagAUTOCOMPLETEOPTIONS
    {	ACO_NONE	= 0,
	ACO_AUTOSUGGEST	= 0x1,
	ACO_AUTOAPPEND	= 0x2,
	ACO_SEARCH	= 0x4,
	ACO_FILTERPREFIXES	= 0x8,
	ACO_USETAB	= 0x10,
	ACO_UPDOWNKEYDROPSLIST	= 0x20,
	ACO_RTLREADING	= 0x40,
	ACO_WORD_FILTER	= 0x80,
	ACO_NOPREFIXFILTERING	= 0x100
    } 	AUTOCOMPLETEOPTIONS;


EXTERN_C const IID IID_IAutoComplete2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EAC04BC0-3791-11d2-BB95-0060977B464C")
    IAutoComplete2 : public IAutoComplete
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetOptions( 
            /* [in] */ DWORD dwFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOptions( 
            /* [out] */ 
            __out  DWORD *pdwFlag) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAutoComplete2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAutoComplete2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAutoComplete2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAutoComplete2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IAutoComplete2 * This,
            /* [in] */ 
            __in  HWND hwndEdit,
            /* [unique][in] */ 
            __in  IUnknown *punkACL,
            /* [unique][in] */ 
            __in_opt  LPCWSTR pwszRegKeyPath,
            /* [in] */ 
            __in_opt  LPCWSTR pwszQuickComplete);
        
        HRESULT ( STDMETHODCALLTYPE *Enable )( 
            IAutoComplete2 * This,
            /* [in] */ BOOL fEnable);
        
        HRESULT ( STDMETHODCALLTYPE *SetOptions )( 
            IAutoComplete2 * This,
            /* [in] */ DWORD dwFlag);
        
        HRESULT ( STDMETHODCALLTYPE *GetOptions )( 
            IAutoComplete2 * This,
            /* [out] */ 
            __out  DWORD *pdwFlag);
        
        END_INTERFACE
    } IAutoComplete2Vtbl;

    interface IAutoComplete2
    {
        CONST_VTBL struct IAutoComplete2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAutoComplete2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAutoComplete2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAutoComplete2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAutoComplete2_Init(This,hwndEdit,punkACL,pwszRegKeyPath,pwszQuickComplete)	\
    ( (This)->lpVtbl -> Init(This,hwndEdit,punkACL,pwszRegKeyPath,pwszQuickComplete) ) 

#define IAutoComplete2_Enable(This,fEnable)	\
    ( (This)->lpVtbl -> Enable(This,fEnable) ) 


#define IAutoComplete2_SetOptions(This,dwFlag)	\
    ( (This)->lpVtbl -> SetOptions(This,dwFlag) ) 

#define IAutoComplete2_GetOptions(This,pdwFlag)	\
    ( (This)->lpVtbl -> GetOptions(This,pdwFlag) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAutoComplete2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shldisp_0000_0002 */
/* [local] */ 

// INTERFACE: IEnumACString
//
// This interface was implemented to return autocomplete strings
// into the caller's buffer (to reduce the number of memory allocations).
// A sort index is also returned to control the order of items displayed.
// by autocomplete.  The sort index should be set to zero if unused.
//
// The NextItem method increments the current index by one (similar to Next
// when one item is requested).
//


extern RPC_IF_HANDLE __MIDL_itf_shldisp_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shldisp_0000_0002_v0_0_s_ifspec;

#ifndef __IEnumACString_INTERFACE_DEFINED__
#define __IEnumACString_INTERFACE_DEFINED__

/* interface IEnumACString */
/* [unique][uuid][object][local][helpstring] */ 

typedef /* [unique] */ IEnumACString *PENUMACSTRING;

typedef /* [unique] */ IEnumACString *LPENUMACSTRING;

typedef 
enum _tagACENUMOPTION
    {	ACEO_NONE	= 0,
	ACEO_MOSTRECENTFIRST	= 0x1,
	ACEO_FIRSTUNUSED	= 0x10000
    } 	ACENUMOPTION;


EXTERN_C const IID IID_IEnumACString;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8E74C210-CF9D-4eaf-A403-7356428F0A5A")
    IEnumACString : public IEnumString
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NextItem( 
            /* [size_is][unique][string][out] */ 
            __out_ecount_opt(cchMax)  LPWSTR pszUrl,
            /* [in] */ ULONG cchMax,
            /* [out] */ 
            __out  ULONG *pulSortIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnumOptions( 
            /* [in] */ DWORD dwOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnumOptions( 
            /* [out] */ 
            __out  DWORD *pdwOptions) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumACStringVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumACString * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumACString * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumACString * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumACString * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ 
            __RPC__out_ecount_part(celt,*pceltFetched)  LPOLESTR *rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumACString * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumACString * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumACString * This,
            /* [out] */ IEnumString **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *NextItem )( 
            IEnumACString * This,
            /* [size_is][unique][string][out] */ 
            __out_ecount_opt(cchMax)  LPWSTR pszUrl,
            /* [in] */ ULONG cchMax,
            /* [out] */ 
            __out  ULONG *pulSortIndex);
        
        HRESULT ( STDMETHODCALLTYPE *SetEnumOptions )( 
            IEnumACString * This,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnumOptions )( 
            IEnumACString * This,
            /* [out] */ 
            __out  DWORD *pdwOptions);
        
        END_INTERFACE
    } IEnumACStringVtbl;

    interface IEnumACString
    {
        CONST_VTBL struct IEnumACStringVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumACString_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumACString_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumACString_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumACString_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumACString_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumACString_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumACString_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 


#define IEnumACString_NextItem(This,pszUrl,cchMax,pulSortIndex)	\
    ( (This)->lpVtbl -> NextItem(This,pszUrl,cchMax,pulSortIndex) ) 

#define IEnumACString_SetEnumOptions(This,dwOptions)	\
    ( (This)->lpVtbl -> SetEnumOptions(This,dwOptions) ) 

#define IEnumACString_GetEnumOptions(This,pdwOptions)	\
    ( (This)->lpVtbl -> GetEnumOptions(This,pdwOptions) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumACString_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shldisp_0000_0003 */
/* [local] */ 

// INTERFACE: IAsyncOperation
//
// This interface was implemented to turn some previously synchronous
// interfaces into async.  The following example is for
// doing the IDataObject::Drop() operation asynchronously.
//
// Sometimes the rendering of the IDataObject data (IDataObject::GetData() or
// STGMEDIUM.pStream->Read()) can be time intensive.  The IDropTarget
// may want to do this on another thread.
//
// Implimentation Check list:
// DoDragDrop Caller:
//    If this code can support asynch operations, then it needs to
//    QueryInterface() the IDataObject for IAsyncOperation.
//    IAsyncOperation::SetAsyncMode(VARIANT_TRUE).
//    After calling DoDragDrop(), call InOperation().  If any call fails
//    or InOperation() return FALSE, use the pdwEffect returned by DoDragDrop()
//    and the operation completed synchrously.
//
// OleSetClipboard Caller:
//    If this code can support asynch operations, then it needs to
//    QueryInterface() the IDataObject for IAsyncOperation.  Then call
//    IAsyncOperation::SetAsyncMode(VARIANT_TRUE).
//    If any of that fails, the final dwEffect should be passed to the IDataObject via
//    CFSTR_PERFORMEDDROPEFFECT.
//
// IDataObect Object:
//    IAsyncOperation::GetAsyncMode() should return whatever was last passed in
//          fDoOpAsync to ::SetAsyncMode() or VARIANT_FALSE if ::SetAsyncMode()
//          was never called.
//    IAsyncOperation::SetAsyncMode() should AddRef and store paocb.
//    IAsyncOperation::StartOperation() should store the fact that this was called and
//          cause InOperation() to return VARIANT_TRUE.  pbcReserved is not used and needs
//          to be NULL.
//    IAsyncOperation::InOperation() should return VARIANT_TRUE only if ::StartOperation()
//          was called.
//    IAsyncOperation::EndOperation() needs to call paocbpaocb->EndOperation() with the same
//          parameters.  Then release paocb.
//    IDataObject::SetData(CFSTR_PERFORMEDDROPEFFECT) When this happens, call
//          EndOperation(<into VAR>S_OK, NULL, <into VAR>dwEffect) and pass the dwEffect from the hglobal.
//
// IDropTarget Object:
//    IDropTarget::Drop() If asynch operations aren't supported, nothing is required.
//          The asynch operation can only happen if GetAsyncMode() returns VARIANT_TRUE.
//          Before starting the asynch operation, StartOperation(NULL) needs to be called before
//          returning from IDropTarget::Drop().



extern RPC_IF_HANDLE __MIDL_itf_shldisp_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shldisp_0000_0003_v0_0_s_ifspec;

#ifndef __IAsyncOperation_INTERFACE_DEFINED__
#define __IAsyncOperation_INTERFACE_DEFINED__

/* interface IAsyncOperation */
/* [object][uuid][helpstring] */ 

typedef /* [unique] */  __RPC_unique_pointer IAsyncOperation *LPASYNCOPERATION;


EXTERN_C const IID IID_IAsyncOperation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3D8B0590-F691-11d2-8EA9-006097DF5BD4")
    IAsyncOperation : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetAsyncMode( 
            /* [in] */ BOOL fDoOpAsync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAsyncMode( 
            /* [out] */ __RPC__out BOOL *pfIsOpAsync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartOperation( 
            /* [optional][unique][in] */ __RPC__in_opt IBindCtx *pbcReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InOperation( 
            /* [out] */ __RPC__out BOOL *pfInAsyncOp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndOperation( 
            /* [in] */ HRESULT hResult,
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbcReserved,
            /* [in] */ DWORD dwEffects) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAsyncOperationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAsyncOperation * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAsyncOperation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAsyncOperation * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetAsyncMode )( 
            IAsyncOperation * This,
            /* [in] */ BOOL fDoOpAsync);
        
        HRESULT ( STDMETHODCALLTYPE *GetAsyncMode )( 
            IAsyncOperation * This,
            /* [out] */ __RPC__out BOOL *pfIsOpAsync);
        
        HRESULT ( STDMETHODCALLTYPE *StartOperation )( 
            IAsyncOperation * This,
            /* [optional][unique][in] */ __RPC__in_opt IBindCtx *pbcReserved);
        
        HRESULT ( STDMETHODCALLTYPE *InOperation )( 
            IAsyncOperation * This,
            /* [out] */ __RPC__out BOOL *pfInAsyncOp);
        
        HRESULT ( STDMETHODCALLTYPE *EndOperation )( 
            IAsyncOperation * This,
            /* [in] */ HRESULT hResult,
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbcReserved,
            /* [in] */ DWORD dwEffects);
        
        END_INTERFACE
    } IAsyncOperationVtbl;

    interface IAsyncOperation
    {
        CONST_VTBL struct IAsyncOperationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAsyncOperation_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAsyncOperation_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAsyncOperation_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAsyncOperation_SetAsyncMode(This,fDoOpAsync)	\
    ( (This)->lpVtbl -> SetAsyncMode(This,fDoOpAsync) ) 

#define IAsyncOperation_GetAsyncMode(This,pfIsOpAsync)	\
    ( (This)->lpVtbl -> GetAsyncMode(This,pfIsOpAsync) ) 

#define IAsyncOperation_StartOperation(This,pbcReserved)	\
    ( (This)->lpVtbl -> StartOperation(This,pbcReserved) ) 

#define IAsyncOperation_InOperation(This,pfInAsyncOp)	\
    ( (This)->lpVtbl -> InOperation(This,pfInAsyncOp) ) 

#define IAsyncOperation_EndOperation(This,hResult,pbcReserved,dwEffects)	\
    ( (This)->lpVtbl -> EndOperation(This,hResult,pbcReserved,dwEffects) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAsyncOperation_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\ShTypes.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for shtypes.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __shtypes_h__
#define __shtypes_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "wtypes.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_shtypes_0000_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------
//===========================================================================
//
// Object identifiers in the explorer's name space (ItemID and IDList)
//
//  All the items that the user can browse with the explorer (such as files,
// directories, servers, work-groups, etc.) has an identifier which is unique
// among items within the parent folder. Those identifiers are called item
// IDs (SHITEMID). Since all its parent folders have their own item IDs,
// any items can be uniquely identified by a list of item IDs, which is called
// an ID list (ITEMIDLIST).
//
//  ID lists are almost always allocated by the task allocator (see some
// description below as well as OLE 2.0 SDK) and may be passed across
// some of shell interfaces (such as IShellFolder). Each item ID in an ID list
// is only meaningful to its parent folder (which has generated it), and all
// the clients must treat it as an opaque binary data except the first two
// bytes, which indicates the size of the item ID.
//
//  When a shell extension -- which implements the IShellFolder interace --
// generates an item ID, it may put any information in it, not only the data
// with that it needs to identifies the item, but also some additional
// information, which would help implementing some other functions efficiently.
// For example, the shell's IShellFolder implementation of file system items
// stores the primary (long) name of a file or a directory as the item
// identifier, but it also stores its alternative (short) name, size and date
// etc.
//
//  When an ID list is passed to one of shell APIs (such as SHGetPathFromIDList),
// it is always an absolute path -- relative from the root of the name space,
// which is the desktop folder. When an ID list is passed to one of IShellFolder
// member function, it is always a relative path from the folder (unless it
// is explicitly specified).
//
//===========================================================================
//
// SHITEMID -- Item ID  (mkid)
//     USHORT      cb;             // Size of the ID (including cb itself)
//     BYTE        abID[];         // The item ID (variable length)
//
#include <pshpack1.h>
typedef struct _SHITEMID
    {
    USHORT cb;
    BYTE abID[ 1 ];
    } 	SHITEMID;

#include <poppack.h>
#if defined(_M_IX86)
#define __unaligned
#endif // __unaligned
typedef SHITEMID __unaligned *LPSHITEMID;

typedef const SHITEMID __unaligned *LPCSHITEMID;

//
// ITEMIDLIST -- List if item IDs (combined with 0-terminator)
//
#include <pshpack1.h>
typedef struct _ITEMIDLIST
    {
    SHITEMID mkid;
    } 	ITEMIDLIST;

#if defined(STRICT_TYPED_ITEMIDS) && defined(__cplusplus)
typedef struct _ITEMIDLIST_RELATIVE : ITEMIDLIST {} ITEMIDLIST_RELATIVE;
typedef struct _ITEMID_CHILD : ITEMIDLIST_RELATIVE {} ITEMID_CHILD;
typedef struct _ITEMIDLIST_ABSOLUTE : ITEMIDLIST_RELATIVE {} ITEMIDLIST_ABSOLUTE;
#else // !(defined(STRICT_TYPED_ITEMIDS) && defined(__cplusplus))
typedef ITEMIDLIST ITEMIDLIST_RELATIVE;

typedef ITEMIDLIST ITEMID_CHILD;

typedef ITEMIDLIST ITEMIDLIST_ABSOLUTE;

#endif // defined(STRICT_TYPED_ITEMIDS) && defined(__cplusplus)
#include <poppack.h>
typedef /* [unique] */  __RPC_unique_pointer BYTE_BLOB *wirePIDL;

typedef /* [wire_marshal] */ ITEMIDLIST __unaligned *LPITEMIDLIST;

typedef /* [wire_marshal] */ const ITEMIDLIST __unaligned *LPCITEMIDLIST;

#if defined(STRICT_TYPED_ITEMIDS) && defined(__cplusplus)
typedef /* [wire_marshal] */ ITEMIDLIST_ABSOLUTE *PIDLIST_ABSOLUTE;

typedef /* [wire_marshal] */ const ITEMIDLIST_ABSOLUTE *PCIDLIST_ABSOLUTE;

typedef /* [wire_marshal] */ const ITEMIDLIST_ABSOLUTE __unaligned *PCUIDLIST_ABSOLUTE;

typedef /* [wire_marshal] */ ITEMIDLIST_RELATIVE *PIDLIST_RELATIVE;

typedef /* [wire_marshal] */ const ITEMIDLIST_RELATIVE *PCIDLIST_RELATIVE;

typedef /* [wire_marshal] */ ITEMIDLIST_RELATIVE __unaligned *PUIDLIST_RELATIVE;

typedef /* [wire_marshal] */ const ITEMIDLIST_RELATIVE __unaligned *PCUIDLIST_RELATIVE;

typedef /* [wire_marshal] */ ITEMID_CHILD *PITEMID_CHILD;

typedef /* [wire_marshal] */ const ITEMID_CHILD *PCITEMID_CHILD;

typedef /* [wire_marshal] */ ITEMID_CHILD __unaligned *PUITEMID_CHILD;

typedef /* [wire_marshal] */ const ITEMID_CHILD __unaligned *PCUITEMID_CHILD;

typedef const PCUITEMID_CHILD *PCUITEMID_CHILD_ARRAY;

typedef const PCUIDLIST_RELATIVE *PCUIDLIST_RELATIVE_ARRAY;

typedef const PCIDLIST_ABSOLUTE *PCIDLIST_ABSOLUTE_ARRAY;

typedef const PCUIDLIST_ABSOLUTE *PCUIDLIST_ABSOLUTE_ARRAY;

#else // !(defined(STRICT_TYPED_ITEMIDS) && defined(__cplusplus))
#define PIDLIST_ABSOLUTE         LPITEMIDLIST
#define PCIDLIST_ABSOLUTE        LPCITEMIDLIST
#define PCUIDLIST_ABSOLUTE       LPCITEMIDLIST
#define PIDLIST_RELATIVE         LPITEMIDLIST
#define PCIDLIST_RELATIVE        LPCITEMIDLIST
#define PUIDLIST_RELATIVE        LPITEMIDLIST
#define PCUIDLIST_RELATIVE       LPCITEMIDLIST
#define PITEMID_CHILD            LPITEMIDLIST
#define PCITEMID_CHILD           LPCITEMIDLIST
#define PUITEMID_CHILD           LPITEMIDLIST
#define PCUITEMID_CHILD          LPCITEMIDLIST
#define PCUITEMID_CHILD_ARRAY    LPCITEMIDLIST *
#define PCUIDLIST_RELATIVE_ARRAY LPCITEMIDLIST *
#define PCIDLIST_ABSOLUTE_ARRAY  LPCITEMIDLIST *
#define PCUIDLIST_ABSOLUTE_ARRAY LPCITEMIDLIST *
#endif // defined(STRICT_TYPED_ITEMIDS) && defined(__cplusplus)
#ifdef MIDL_PASS
typedef struct _WIN32_FIND_DATAA
    {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
    CHAR cFileName[ 260 ];
    CHAR cAlternateFileName[ 14 ];
    } 	WIN32_FIND_DATAA;

typedef struct _WIN32_FIND_DATAA *PWIN32_FIND_DATAA;

typedef struct _WIN32_FIND_DATAA *LPWIN32_FIND_DATAA;

typedef struct _WIN32_FIND_DATAW
    {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
    WCHAR cFileName[ 260 ];
    WCHAR cAlternateFileName[ 14 ];
    } 	WIN32_FIND_DATAW;

typedef struct _WIN32_FIND_DATAW *PWIN32_FIND_DATAW;

typedef struct _WIN32_FIND_DATAW *LPWIN32_FIND_DATAW;

#endif // MIDL_PASS
//-------------------------------------------------------------------------
//
// struct STRRET
//
// structure for returning strings from IShellFolder member functions
//
//-------------------------------------------------------------------------
//
//  uType indicate which union member to use 
//    STRRET_WSTR    Use STRRET.pOleStr     must be freed by caller of GetDisplayNameOf
//    STRRET_OFFSET  Use STRRET.uOffset     Offset into SHITEMID for ANSI string 
//    STRRET_CSTR    Use STRRET.cStr        ANSI Buffer
//
typedef /* [v1_enum] */ 
enum tagSTRRET_TYPE
    {	STRRET_WSTR	= 0,
	STRRET_OFFSET	= 0x1,
	STRRET_CSTR	= 0x2
    } 	STRRET_TYPE;

#if defined(_MSC_VER) && (_MSC_VER >= 1200)
#pragma warning(push)
#pragma warning(disable:4201) /* nonstandard extension used : nameless struct/union */
#pragma once
#endif
#include <pshpack8.h>
typedef struct _STRRET
    {
    UINT uType;
    union 
        {
        LPWSTR pOleStr;
        UINT uOffset;
        char cStr[ 260 ];
        } 	DUMMYUNIONNAME;
    } 	STRRET;

#include <poppack.h>
#if defined(_MSC_VER) && (_MSC_VER >= 1200)
#pragma warning(pop)
#endif
typedef STRRET *LPSTRRET;

//-------------------------------------------------------------------------
//
// struct SHELLDETAILS
//
// structure for returning strings from IShellDetails
//
//-------------------------------------------------------------------------
//
//  fmt;            // LVCFMT_* value (header only)
//  cxChar;         // Number of 'average' characters (header only)
//  str;            // String information
//
#include <pshpack1.h>
typedef struct _SHELLDETAILS
    {
    int fmt;
    int cxChar;
    STRRET str;
    } 	SHELLDETAILS;

typedef struct _SHELLDETAILS *LPSHELLDETAILS;

#include <poppack.h>

#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
typedef /* [v1_enum] */ 
enum tagPERCEIVED
    {	PERCEIVED_TYPE_FIRST	= -3,
	PERCEIVED_TYPE_CUSTOM	= -3,
	PERCEIVED_TYPE_UNSPECIFIED	= -2,
	PERCEIVED_TYPE_FOLDER	= -1,
	PERCEIVED_TYPE_UNKNOWN	= 0,
	PERCEIVED_TYPE_TEXT	= 1,
	PERCEIVED_TYPE_IMAGE	= 2,
	PERCEIVED_TYPE_AUDIO	= 3,
	PERCEIVED_TYPE_VIDEO	= 4,
	PERCEIVED_TYPE_COMPRESSED	= 5,
	PERCEIVED_TYPE_DOCUMENT	= 6,
	PERCEIVED_TYPE_SYSTEM	= 7,
	PERCEIVED_TYPE_APPLICATION	= 8,
	PERCEIVED_TYPE_GAMEMEDIA	= 9,
	PERCEIVED_TYPE_CONTACTS	= 10,
	PERCEIVED_TYPE_LAST	= 10
    } 	PERCEIVED;

#define PERCEIVEDFLAG_UNDEFINED     0x0000
#define PERCEIVEDFLAG_SOFTCODED     0x0001
#define PERCEIVEDFLAG_HARDCODED     0x0002
#define PERCEIVEDFLAG_NATIVESUPPORT 0x0004
#define PERCEIVEDFLAG_GDIPLUS       0x0010
#define PERCEIVEDFLAG_WMSDK         0x0020
#define PERCEIVEDFLAG_ZIPFOLDER     0x0040
typedef DWORD PERCEIVEDFLAG;

#endif  // _WIN32_IE_IE60SP2

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef struct _COMDLG_FILTERSPEC
    {
    LPCWSTR pszName;
    LPCWSTR pszSpec;
    } 	COMDLG_FILTERSPEC;

typedef GUID KNOWNFOLDERID;

#if 0
typedef KNOWNFOLDERID *REFKNOWNFOLDERID;

#endif // 0
#ifdef __cplusplus
#define REFKNOWNFOLDERID const KNOWNFOLDERID &
#else // !__cplusplus
#define REFKNOWNFOLDERID const KNOWNFOLDERID * __MIDL_CONST
#endif // __cplusplus
#endif  // NTDDI_VISTA
typedef GUID FOLDERTYPEID;

#if 0
typedef FOLDERTYPEID *REFFOLDERTYPEID;

#endif // 0
#ifdef __cplusplus
#define REFFOLDERTYPEID const FOLDERTYPEID &
#else // !__cplusplus
#define REFFOLDERTYPEID const FOLDERTYPEID * __MIDL_CONST
#endif // __cplusplus
typedef GUID TASKOWNERID;

#if 0
typedef TASKOWNERID *REFTASKOWNERID;

#endif // 0
#ifdef __cplusplus
#define REFTASKOWNERID const TASKOWNERID &
#else // !__cplusplus
#define REFTASKOWNERID const TASKOWNERID * __MIDL_CONST
#endif // __cplusplus
#ifndef LF_FACESIZE
typedef struct tagLOGFONTA
    {
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    CHAR lfFaceName[ 32 ];
    } 	LOGFONTA;

typedef struct tagLOGFONTW
    {
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    WCHAR lfFaceName[ 32 ];
    } 	LOGFONTW;

typedef LOGFONTA LOGFONT;

#endif // LF_FACESIZE
typedef /* [v1_enum] */ 
enum tagSHCOLSTATE
    {	SHCOLSTATE_TYPE_STR	= 0x1,
	SHCOLSTATE_TYPE_INT	= 0x2,
	SHCOLSTATE_TYPE_DATE	= 0x3,
	SHCOLSTATE_TYPEMASK	= 0xf,
	SHCOLSTATE_ONBYDEFAULT	= 0x10,
	SHCOLSTATE_SLOW	= 0x20,
	SHCOLSTATE_EXTENDED	= 0x40,
	SHCOLSTATE_SECONDARYUI	= 0x80,
	SHCOLSTATE_HIDDEN	= 0x100,
	SHCOLSTATE_PREFER_VARCMP	= 0x200,
	SHCOLSTATE_PREFER_FMTCMP	= 0x400,
	SHCOLSTATE_NOSORTBYFOLDERNESS	= 0x800,
	SHCOLSTATE_VIEWONLY	= 0x10000,
	SHCOLSTATE_BATCHREAD	= 0x20000,
	SHCOLSTATE_NO_GROUPBY	= 0x40000,
	SHCOLSTATE_FIXED_WIDTH	= 0x1000,
	SHCOLSTATE_NODPISCALE	= 0x2000,
	SHCOLSTATE_FIXED_RATIO	= 0x4000,
	SHCOLSTATE_DISPLAYMASK	= 0xf000
    } 	SHCOLSTATE;

typedef DWORD SHCOLSTATEF;

typedef PROPERTYKEY SHCOLUMNID;

typedef const SHCOLUMNID *LPCSHCOLUMNID;



extern RPC_IF_HANDLE __MIDL_itf_shtypes_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shtypes_0000_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\simpdata.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for simpdata.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __simpdata_h__
#define __simpdata_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __OLEDBSimpleProviderListener_FWD_DEFINED__
#define __OLEDBSimpleProviderListener_FWD_DEFINED__
typedef interface OLEDBSimpleProviderListener OLEDBSimpleProviderListener;
#endif 	/* __OLEDBSimpleProviderListener_FWD_DEFINED__ */


#ifndef __OLEDBSimpleProvider_FWD_DEFINED__
#define __OLEDBSimpleProvider_FWD_DEFINED__
typedef interface OLEDBSimpleProvider OLEDBSimpleProvider;
#endif 	/* __OLEDBSimpleProvider_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_simpdata_0000_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// simpdata.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//--------------------------------------------------------------------------
// OLE DB Simple Provider Toolkit

#ifndef SIMPDATA_H
#define SIMPDATA_H

#ifdef _WIN64

typedef LONGLONG DBROWCOUNT;

typedef LONGLONG DB_LORDINAL;


#else

typedef LONG DBROWCOUNT;

typedef LONG DB_LORDINAL;

#endif	// _WIN64
#define OSP_IndexLabel      (0)
#define OSP_IndexAll        (~0)
#define OSP_IndexUnknown    (~0)



extern RPC_IF_HANDLE __MIDL_itf_simpdata_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_simpdata_0000_0000_v0_0_s_ifspec;


#ifndef __MSDAOSP_LIBRARY_DEFINED__
#define __MSDAOSP_LIBRARY_DEFINED__

/* library MSDAOSP */
/* [version][lcid][helpstring][uuid] */ 

typedef 
enum OSPFORMAT
    {	OSPFORMAT_RAW	= 0,
	OSPFORMAT_DEFAULT	= 0,
	OSPFORMAT_FORMATTED	= 1,
	OSPFORMAT_HTML	= 2
    } 	OSPFORMAT;

typedef 
enum OSPRW
    {	OSPRW_DEFAULT	= 1,
	OSPRW_READONLY	= 0,
	OSPRW_READWRITE	= 1,
	OSPRW_MIXED	= 2
    } 	OSPRW;

typedef 
enum OSPFIND
    {	OSPFIND_DEFAULT	= 0,
	OSPFIND_UP	= 1,
	OSPFIND_CASESENSITIVE	= 2,
	OSPFIND_UPCASESENSITIVE	= 3
    } 	OSPFIND;

typedef 
enum OSPCOMP
    {	OSPCOMP_EQ	= 1,
	OSPCOMP_DEFAULT	= 1,
	OSPCOMP_LT	= 2,
	OSPCOMP_LE	= 3,
	OSPCOMP_GE	= 4,
	OSPCOMP_GT	= 5,
	OSPCOMP_NE	= 6
    } 	OSPCOMP;

typedef 
enum OSPXFER
    {	OSPXFER_COMPLETE	= 0,
	OSPXFER_ABORT	= 1,
	OSPXFER_ERROR	= 2
    } 	OSPXFER;

typedef OLEDBSimpleProvider *LPOLEDBSimpleProvider;

EXTERN_C const IID LIBID_MSDAOSP;

#ifndef __OLEDBSimpleProviderListener_INTERFACE_DEFINED__
#define __OLEDBSimpleProviderListener_INTERFACE_DEFINED__

/* interface OLEDBSimpleProviderListener */
/* [version][oleautomation][unique][uuid][object] */ 


EXTERN_C const IID IID_OLEDBSimpleProviderListener;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E0E270C1-C0BE-11d0-8FE4-00A0C90A6341")
    OLEDBSimpleProviderListener : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE aboutToChangeCell( 
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DB_LORDINAL iColumn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE cellChanged( 
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DB_LORDINAL iColumn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE aboutToDeleteRows( 
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DBROWCOUNT cRows) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE deletedRows( 
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DBROWCOUNT cRows) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE aboutToInsertRows( 
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DBROWCOUNT cRows) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE insertedRows( 
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DBROWCOUNT cRows) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE rowsAvailable( 
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DBROWCOUNT cRows) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE transferComplete( 
            /* [in] */ OSPXFER xfer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct OLEDBSimpleProviderListenerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            OLEDBSimpleProviderListener * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            OLEDBSimpleProviderListener * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            OLEDBSimpleProviderListener * This);
        
        HRESULT ( STDMETHODCALLTYPE *aboutToChangeCell )( 
            OLEDBSimpleProviderListener * This,
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DB_LORDINAL iColumn);
        
        HRESULT ( STDMETHODCALLTYPE *cellChanged )( 
            OLEDBSimpleProviderListener * This,
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DB_LORDINAL iColumn);
        
        HRESULT ( STDMETHODCALLTYPE *aboutToDeleteRows )( 
            OLEDBSimpleProviderListener * This,
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DBROWCOUNT cRows);
        
        HRESULT ( STDMETHODCALLTYPE *deletedRows )( 
            OLEDBSimpleProviderListener * This,
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DBROWCOUNT cRows);
        
        HRESULT ( STDMETHODCALLTYPE *aboutToInsertRows )( 
            OLEDBSimpleProviderListener * This,
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DBROWCOUNT cRows);
        
        HRESULT ( STDMETHODCALLTYPE *insertedRows )( 
            OLEDBSimpleProviderListener * This,
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DBROWCOUNT cRows);
        
        HRESULT ( STDMETHODCALLTYPE *rowsAvailable )( 
            OLEDBSimpleProviderListener * This,
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DBROWCOUNT cRows);
        
        HRESULT ( STDMETHODCALLTYPE *transferComplete )( 
            OLEDBSimpleProviderListener * This,
            /* [in] */ OSPXFER xfer);
        
        END_INTERFACE
    } OLEDBSimpleProviderListenerVtbl;

    interface OLEDBSimpleProviderListener
    {
        CONST_VTBL struct OLEDBSimpleProviderListenerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define OLEDBSimpleProviderListener_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define OLEDBSimpleProviderListener_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define OLEDBSimpleProviderListener_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define OLEDBSimpleProviderListener_aboutToChangeCell(This,iRow,iColumn)	\
    ( (This)->lpVtbl -> aboutToChangeCell(This,iRow,iColumn) ) 

#define OLEDBSimpleProviderListener_cellChanged(This,iRow,iColumn)	\
    ( (This)->lpVtbl -> cellChanged(This,iRow,iColumn) ) 

#define OLEDBSimpleProviderListener_aboutToDeleteRows(This,iRow,cRows)	\
    ( (This)->lpVtbl -> aboutToDeleteRows(This,iRow,cRows) ) 

#define OLEDBSimpleProviderListener_deletedRows(This,iRow,cRows)	\
    ( (This)->lpVtbl -> deletedRows(This,iRow,cRows) ) 

#define OLEDBSimpleProviderListener_aboutToInsertRows(This,iRow,cRows)	\
    ( (This)->lpVtbl -> aboutToInsertRows(This,iRow,cRows) ) 

#define OLEDBSimpleProviderListener_insertedRows(This,iRow,cRows)	\
    ( (This)->lpVtbl -> insertedRows(This,iRow,cRows) ) 

#define OLEDBSimpleProviderListener_rowsAvailable(This,iRow,cRows)	\
    ( (This)->lpVtbl -> rowsAvailable(This,iRow,cRows) ) 

#define OLEDBSimpleProviderListener_transferComplete(This,xfer)	\
    ( (This)->lpVtbl -> transferComplete(This,xfer) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __OLEDBSimpleProviderListener_INTERFACE_DEFINED__ */


#ifndef __OLEDBSimpleProvider_INTERFACE_DEFINED__
#define __OLEDBSimpleProvider_INTERFACE_DEFINED__

/* interface OLEDBSimpleProvider */
/* [version][oleautomation][unique][uuid][object] */ 


EXTERN_C const IID IID_OLEDBSimpleProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E0E270C0-C0BE-11d0-8FE4-00A0C90A6341")
    OLEDBSimpleProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE getRowCount( 
            /* [retval][out] */ __RPC__out DBROWCOUNT *pcRows) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getColumnCount( 
            /* [retval][out] */ __RPC__out DB_LORDINAL *pcColumns) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getRWStatus( 
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DB_LORDINAL iColumn,
            /* [retval][out] */ __RPC__out OSPRW *prwStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getVariant( 
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DB_LORDINAL iColumn,
            /* [in] */ OSPFORMAT format,
            /* [retval][out] */ __RPC__out VARIANT *pVar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE setVariant( 
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DB_LORDINAL iColumn,
            /* [in] */ OSPFORMAT format,
            /* [in] */ VARIANT Var) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getLocale( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrLocale) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE deleteRows( 
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DBROWCOUNT cRows,
            /* [retval][out] */ __RPC__out DBROWCOUNT *pcRowsDeleted) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE insertRows( 
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DBROWCOUNT cRows,
            /* [retval][out] */ __RPC__out DBROWCOUNT *pcRowsInserted) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE find( 
            /* [in] */ DBROWCOUNT iRowStart,
            /* [in] */ DB_LORDINAL iColumn,
            /* [in] */ VARIANT val,
            /* [in] */ OSPFIND findFlags,
            /* [in] */ OSPCOMP compType,
            /* [retval][out] */ __RPC__out DBROWCOUNT *piRowFound) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE addOLEDBSimpleProviderListener( 
            /* [in] */ __RPC__in_opt OLEDBSimpleProviderListener *pospIListener) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE removeOLEDBSimpleProviderListener( 
            /* [in] */ __RPC__in_opt OLEDBSimpleProviderListener *pospIListener) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE isAsync( 
            /* [retval][out] */ __RPC__out BOOL *pbAsynch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getEstimatedRows( 
            /* [retval][out] */ __RPC__out DBROWCOUNT *piRows) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE stopTransfer( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct OLEDBSimpleProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            OLEDBSimpleProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            OLEDBSimpleProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            OLEDBSimpleProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *getRowCount )( 
            OLEDBSimpleProvider * This,
            /* [retval][out] */ __RPC__out DBROWCOUNT *pcRows);
        
        HRESULT ( STDMETHODCALLTYPE *getColumnCount )( 
            OLEDBSimpleProvider * This,
            /* [retval][out] */ __RPC__out DB_LORDINAL *pcColumns);
        
        HRESULT ( STDMETHODCALLTYPE *getRWStatus )( 
            OLEDBSimpleProvider * This,
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DB_LORDINAL iColumn,
            /* [retval][out] */ __RPC__out OSPRW *prwStatus);
        
        HRESULT ( STDMETHODCALLTYPE *getVariant )( 
            OLEDBSimpleProvider * This,
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DB_LORDINAL iColumn,
            /* [in] */ OSPFORMAT format,
            /* [retval][out] */ __RPC__out VARIANT *pVar);
        
        HRESULT ( STDMETHODCALLTYPE *setVariant )( 
            OLEDBSimpleProvider * This,
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DB_LORDINAL iColumn,
            /* [in] */ OSPFORMAT format,
            /* [in] */ VARIANT Var);
        
        HRESULT ( STDMETHODCALLTYPE *getLocale )( 
            OLEDBSimpleProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrLocale);
        
        HRESULT ( STDMETHODCALLTYPE *deleteRows )( 
            OLEDBSimpleProvider * This,
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DBROWCOUNT cRows,
            /* [retval][out] */ __RPC__out DBROWCOUNT *pcRowsDeleted);
        
        HRESULT ( STDMETHODCALLTYPE *insertRows )( 
            OLEDBSimpleProvider * This,
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DBROWCOUNT cRows,
            /* [retval][out] */ __RPC__out DBROWCOUNT *pcRowsInserted);
        
        HRESULT ( STDMETHODCALLTYPE *find )( 
            OLEDBSimpleProvider * This,
            /* [in] */ DBROWCOUNT iRowStart,
            /* [in] */ DB_LORDINAL iColumn,
            /* [in] */ VARIANT val,
            /* [in] */ OSPFIND findFlags,
            /* [in] */ OSPCOMP compType,
            /* [retval][out] */ __RPC__out DBROWCOUNT *piRowFound);
        
        HRESULT ( STDMETHODCALLTYPE *addOLEDBSimpleProviderListener )( 
            OLEDBSimpleProvider * This,
            /* [in] */ __RPC__in_opt OLEDBSimpleProviderListener *pospIListener);
        
        HRESULT ( STDMETHODCALLTYPE *removeOLEDBSimpleProviderListener )( 
            OLEDBSimpleProvider * This,
            /* [in] */ __RPC__in_opt OLEDBSimpleProviderListener *pospIListener);
        
        HRESULT ( STDMETHODCALLTYPE *isAsync )( 
            OLEDBSimpleProvider * This,
            /* [retval][out] */ __RPC__out BOOL *pbAsynch);
        
        HRESULT ( STDMETHODCALLTYPE *getEstimatedRows )( 
            OLEDBSimpleProvider * This,
            /* [retval][out] */ __RPC__out DBROWCOUNT *piRows);
        
        HRESULT ( STDMETHODCALLTYPE *stopTransfer )( 
            OLEDBSimpleProvider * This);
        
        END_INTERFACE
    } OLEDBSimpleProviderVtbl;

    interface OLEDBSimpleProvider
    {
        CONST_VTBL struct OLEDBSimpleProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define OLEDBSimpleProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define OLEDBSimpleProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define OLEDBSimpleProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define OLEDBSimpleProvider_getRowCount(This,pcRows)	\
    ( (This)->lpVtbl -> getRowCount(This,pcRows) ) 

#define OLEDBSimpleProvider_getColumnCount(This,pcColumns)	\
    ( (This)->lpVtbl -> getColumnCount(This,pcColumns) ) 

#define OLEDBSimpleProvider_getRWStatus(This,iRow,iColumn,prwStatus)	\
    ( (This)->lpVtbl -> getRWStatus(This,iRow,iColumn,prwStatus) ) 

#define OLEDBSimpleProvider_getVariant(This,iRow,iColumn,format,pVar)	\
    ( (This)->lpVtbl -> getVariant(This,iRow,iColumn,format,pVar) ) 

#define OLEDBSimpleProvider_setVariant(This,iRow,iColumn,format,Var)	\
    ( (This)->lpVtbl -> setVariant(This,iRow,iColumn,format,Var) ) 

#define OLEDBSimpleProvider_getLocale(This,pbstrLocale)	\
    ( (This)->lpVtbl -> getLocale(This,pbstrLocale) ) 

#define OLEDBSimpleProvider_deleteRows(This,iRow,cRows,pcRowsDeleted)	\
    ( (This)->lpVtbl -> deleteRows(This,iRow,cRows,pcRowsDeleted) ) 

#define OLEDBSimpleProvider_insertRows(This,iRow,cRows,pcRowsInserted)	\
    ( (This)->lpVtbl -> insertRows(This,iRow,cRows,pcRowsInserted) ) 

#define OLEDBSimpleProvider_find(This,iRowStart,iColumn,val,findFlags,compType,piRowFound)	\
    ( (This)->lpVtbl -> find(This,iRowStart,iColumn,val,findFlags,compType,piRowFound) ) 

#define OLEDBSimpleProvider_addOLEDBSimpleProviderListener(This,pospIListener)	\
    ( (This)->lpVtbl -> addOLEDBSimpleProviderListener(This,pospIListener) ) 

#define OLEDBSimpleProvider_removeOLEDBSimpleProviderListener(This,pospIListener)	\
    ( (This)->lpVtbl -> removeOLEDBSimpleProviderListener(This,pospIListener) ) 

#define OLEDBSimpleProvider_isAsync(This,pbAsynch)	\
    ( (This)->lpVtbl -> isAsync(This,pbAsynch) ) 

#define OLEDBSimpleProvider_getEstimatedRows(This,piRows)	\
    ( (This)->lpVtbl -> getEstimatedRows(This,piRows) ) 

#define OLEDBSimpleProvider_stopTransfer(This)	\
    ( (This)->lpVtbl -> stopTransfer(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __OLEDBSimpleProvider_INTERFACE_DEFINED__ */

#endif /* __MSDAOSP_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_simpdata_0001_0023 */
/* [local] */ 

#endif


extern RPC_IF_HANDLE __MIDL_itf_simpdata_0001_0023_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_simpdata_0001_0023_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\ShlObj.h ===
/*===========================================================================

Copyright (c) Microsoft Corporation. All rights reserved.

File: shlobj.h

===========================================================================*/

#ifndef _SHLOBJ_H_
#define _SHLOBJ_H_

#if (_MSC_VER >= 800)
#if (_MSC_VER >= 1200)
#pragma warning(push)
#endif
#pragma warning(disable:4001) /* nonstandard extension : single line comment */
#endif

#ifndef SNDMSG
#ifdef __cplusplus
#define SNDMSG ::SendMessage
#else
#define SNDMSG SendMessage
#endif
#endif // ifndef SNDMSG

//
// Define API decoration for direct importing of DLL references.
//
#ifndef WINSHELLAPI
#if defined(_SHELL32_)
#define WINSHELLAPI
#else
#define WINSHELLAPI       DECLSPEC_IMPORT
#endif
#endif // WINSHELLAPI

#ifndef SHSTDAPI
#if defined(_SHELL32_)
#define SHSTDAPI          STDAPI
#define SHSTDAPI_(type)   STDAPI_(type)
#else
#define SHSTDAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define SHSTDAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#endif
#endif // SHSTDAPI

#ifndef SHDOCAPI
#if defined(_SHDOCVW_)
#define SHDOCAPI          STDAPI
#define SHDOCAPI_(type)   STDAPI_(type)
#else
#define SHDOCAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define SHDOCAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#endif
#endif // SHDOCAPI

// shell32 APIs that are also exported from shdocvw
#ifndef SHSTDDOCAPI
#if defined(_SHDOCVW_) || defined(_SHELL32_)
#define SHSTDDOCAPI          STDAPI
#define SHSTDDOCAPI_(type)   STDAPI_(type)
#else
#define SHSTDDOCAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define SHSTDDOCAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#endif
#endif // SHSTDDOCAPI

#ifndef BROWSEUIAPI
#if defined(_BROWSEUI_)
#define BROWSEUIAPI           STDAPI
#define BROWSEUIAPI_(type)    STDAPI_(type)
#else
#define BROWSEUIAPI           EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define BROWSEUIAPI_(type)    EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#endif // defined(_BROWSEUI_)
#endif // BROWSEUIAPI

// shell32 APIs that are also exported from shfolder
#ifndef SHFOLDERAPI
#if defined(_SHFOLDER_) || defined(_SHELL32_)
#define SHFOLDERAPI           STDAPI
#else
#define SHFOLDERAPI           EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#endif
#endif



#include <ole2.h>
#ifndef _PRSHT_H_
#include <prsht.h>
#endif
#ifndef _INC_COMMCTRL
#include <commctrl.h>   // for LPTBBUTTON
#endif

#ifndef INITGUID
#include <shlguid.h>
#endif /* !INITGUID */


#include <shtypes.h>
#include <shobjidl.h>

#if defined(_MSC_VER) && (_MSC_VER >= 1200)
#pragma once
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif /* __cplusplus */

#include <pshpack1.h>   /* Assume byte packing throughout */

//===========================================================================
//
// Legacy exports that are no longer needed, call the COM API instead
//
//===========================================================================

SHSTDAPI SHGetMalloc(__out IMalloc **ppMalloc); // CoGetMalloc(MEMCTX_TASK,ppMalloc)
SHSTDAPI_(void *) SHAlloc(SIZE_T cb);           // CoTaskMemAlloc(cb)
SHSTDAPI_(void)   SHFree(__in_opt void * pv);   // CoTaskMemFree(pv)



//===========================================================================
//
// IExtractIcon interface
//
//  This interface is used in two different places in the shell.
//
// Case-1: Icons of sub-folders for the scope-pane of the explorer.
//
//  It is used by the explorer to get the "icon location" of
// sub-folders from each shell folders. When the user expands a folder
// in the scope pane of the explorer, the explorer does following:
//  (1) binds to the folder (gets IShellFolder),
//  (2) enumerates its sub-folders by calling its EnumObjects member,
//  (3) calls its GetUIObjectOf member to get IExtractIcon interface
//     for each sub-folders.
//  In this case, the explorer uses only IExtractIcon::GetIconLocation
// member to get the location of the appropriate icon. An icon location
// always consists of a file name (typically DLL or EXE) and either an icon
// resource or an icon index.
//
//
// Case-2: Extracting an icon image from a file
//
//  It is used by the shell when it extracts an icon image
// from a file. When the shell is extracting an icon from a file,
// it does following:
//  (1) creates the icon extraction handler object (by getting its CLSID
//     under the {ProgID}\shell\ExtractIconHanler key and calling
//     CoCreateInstance requesting for IExtractIcon interface).
//  (2) Calls IExtractIcon::GetIconLocation.
//  (3) Then, calls IExtractIcon::ExtractIcon with the location/index pair.
//  (4) If (3) returns S_OK, it uses the returned icon.
//  (5) Otherwise, it recursively calls this logic with new location
//     assuming that the location string contains a fully qualified path name.
//
//  From extension programmer's point of view, there are only two cases
// where they provide implementations of IExtractIcon:
//  Case-1) providing explorer extensions (i.e., IShellFolder).
//  Case-2) providing per-instance icons for some types of files.
//
// Because Case-1 is described above, we'll explain only Case-2 here.
//
// When the shell is about display an icon for a file, it does following:
//  (1) Finds its ProgID and ClassID.
//  (2) If the file has a ClassID, it gets the icon location string from the
//    "DefaultIcon" key under it. The string indicates either per-class
//    icon (e.g., "FOOBAR.DLL,2") or per-instance icon (e.g., "%1,1").
//  (3) If a per-instance icon is specified, the shell creates an icon
//    extraction handler object for it, and extracts the icon from it
//    (which is described above).
//
//  It is important to note that the shell calls IExtractIcon::GetIconLocation
// first, then calls IExtractIcon::Extract. Most application programs
// that support per-instance icons will probably store an icon location
// (DLL/EXE name and index/id) rather than an icon image in each file.
// In those cases, a programmer needs to implement only the GetIconLocation
// member and it Extract member simply returns S_FALSE. They need to
// implement Extract member only if they decided to store the icon images
// within files themselved or some other database (which is very rare).
//
//
//
// [Member functions]
//
//
// IExtractIcon::GetIconLocation
//
//  This function returns an icon location.
//
//  Parameters:
//   uFlags     [in]  -- Specifies if it is opened or not (GIL_OPENICON or 0)
//   szIconFile [out] -- Specifies the string buffer buffer for a location name.
//   cchMax     [in]  -- Specifies the size of szIconFile (almost always MAX_PATH)
//   piIndex    [out] -- Sepcifies the address of UINT for the index.
//   pwFlags    [out] -- Returns GIL_* flags
//  Returns:
//   S_OK, if it returns a valid location; S_FALSE, if the shell use a
//   default icon.
//
//  Notes: The location may or may not be a path to a file. The caller can
//   not assume anything unless the subsequent Extract member call returns
//   S_FALSE.
//
//   if the returned location is not a path to a file, GIL_NOTFILENAME should
//   be set in the returned flags.
//
// IExtractIcon::Extract
//
//  This function extracts an icon image from a specified file.
//
//  Parameters:
//   pszFile [in] -- Specifies the icon location (typically a path to a file).
//   nIconIndex [in] -- Specifies the icon index.
//   phiconLarge [out] -- Specifies the HICON variable for large icon.
//   phiconSmall [out] -- Specifies the HICON variable for small icon.
//   nIconSize [in] -- Specifies the size icon required (size of large icon)
//                     LOWORD is the requested large icon size
//                     HIWORD is the requested small icon size
//  Returns:
//   S_OK, if it extracted the from the file.
//   S_FALSE, if the caller should extract from the file specified in the
//           location.
//
//===========================================================================

// GetIconLocation() input flags

#define GIL_OPENICON      0x0001            // allows containers to specify an "open" look
#define GIL_FORSHELL      0x0002            // icon is to be displayed in a ShellFolder
#define GIL_ASYNC         0x0020            // this is an async extract, return E_PENDING
#define GIL_DEFAULTICON   0x0040            // get the default icon location if the final one takes too long to get
#define GIL_FORSHORTCUT   0x0080            // the icon is for a shortcut to the object
#define GIL_CHECKSHIELD   0x0200            // return GIL_SHIELD or GIL_FORCENOSHIELD, don't block if GIL_ASYNC is set

// GetIconLocation() return flags

#define GIL_SIMULATEDOC   0x0001      // simulate this document icon for this
#define GIL_PERINSTANCE   0x0002      // icons from this class are per instance (each file has its own)
#define GIL_PERCLASS      0x0004      // icons from this class per class (shared for all files of this type)
#define GIL_NOTFILENAME   0x0008      // location is not a filename, must call ::ExtractIcon
#define GIL_DONTCACHE     0x0010      // this icon should not be cached
#define GIL_SHIELD        0x0200      // icon should be "stamped" with the LUA shield
#define GIL_FORCENOSHIELD 0x0400      // icon must *not* be "stamped" with the LUA shield

#undef  INTERFACE
#define INTERFACE   IExtractIconA

DECLARE_INTERFACE_IID_(IExtractIconA, IUnknown, "000214eb-0000-0000-c000-000000000046")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExtractIcon methods ***
    STDMETHOD(GetIconLocation)(THIS_
                               UINT   uFlags,
          __out_ecount(cchMax) LPSTR  szIconFile,
                               UINT   cchMax,
                         __out int   * piIndex,
                         __out UINT  * pwFlags) PURE;

    STDMETHOD(Extract)(THIS_
                       LPCSTR  pszFile,
                       UINT    nIconIndex,
             __out_opt HICON   *phiconLarge,
             __out_opt HICON   *phiconSmall,
                       UINT    nIconSize) PURE;
};

typedef IExtractIconA * LPEXTRACTICONA;

#undef  INTERFACE
#define INTERFACE   IExtractIconW

DECLARE_INTERFACE_IID_(IExtractIconW, IUnknown, "000214fa-0000-0000-c000-000000000046")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExtractIcon methods ***
    STDMETHOD(GetIconLocation)(THIS_
                               UINT   uFlags,
          __out_ecount(cchMax) LPWSTR pszIconFile,
                               UINT   cchMax,
                         __out int   * piIndex,
                         __out UINT  * pwFlags) PURE;

    STDMETHOD(Extract)(THIS_
                       LPCWSTR pszFile,
                       UINT    nIconIndex,
             __out_opt HICON   *phiconLarge,
             __out_opt HICON   *phiconSmall,
                       UINT    nIconSize) PURE;
};

typedef IExtractIconW * LPEXTRACTICONW;

#ifdef UNICODE
#define IExtractIcon        IExtractIconW
#define IExtractIconVtbl    IExtractIconWVtbl
#define LPEXTRACTICON       LPEXTRACTICONW
#else
#define IExtractIcon        IExtractIconA
#define IExtractIconVtbl    IExtractIconAVtbl
#define LPEXTRACTICON       LPEXTRACTICONA
#endif

//===========================================================================
//
// IShellIconOverlayIdentifier
//
// Used to identify a file as a member of the group of files that have this specific
// icon overlay
//
// Users can create new IconOverlayIdentifiers and place them in the following registry
// location together with the Icon overlay image and their priority.
// HKEY_LOCAL_MACHINE "Software\\Microsoft\\Windows\\CurrentVersion\\ShellIconOverlayIdentifiers"
//
// The shell will enumerate through all IconOverlayIdentifiers at start, and prioritize
// them according to internal rules, in case the internal rules don't apply, we use their
// input priority
//
// IShellIconOverlayIdentifier:IsMemberOf(LPCWSTR pwszPath, DWORD dwAttrib)
//      pwszPath        full path of the file
//      dwAttrib        attribute of this file
//
//  returns:
//      S_OK,    if the file is a member
//      S_FALSE, if the file is not a member
//      E_FAIL,  if the operation failed due to bad WIN32_FIND_DATA
//
// IShellIconOverlayIdentifier::GetOverlayInfo(LPWSTR pwszIconFile, int * pIndex, DWORD * dwFlags) PURE;
//      pszIconFile    the path of the icon file
//      pIndex         Depend on the flags, this could contain the IconIndex
//      dwFlags        defined below
//
// IShellIconOverlayIdentifier::GetPriority(int * pIPriority) PURE;
//      pIPriority     the priority of this Overlay Identifier
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IShellIconOverlayIdentifier

DECLARE_INTERFACE_IID_(IShellIconOverlayIdentifier, IUnknown, "0c6c4200-c589-11d0-999a-00c04fd655e1")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellIconOverlayIdentifier methods ***
    STDMETHOD (IsMemberOf)(THIS_ LPCWSTR pwszPath, DWORD dwAttrib) PURE;
    STDMETHOD (GetOverlayInfo)(THIS_ __out_ecount(cchMax) LPWSTR pwszIconFile, int cchMax, __out int * pIndex, __out DWORD * pdwFlags) PURE;
    STDMETHOD (GetPriority)(THIS_ __out int * pIPriority) PURE;
};

#define ISIOI_ICONFILE            0x00000001          // path is returned through pwszIconFile
#define ISIOI_ICONINDEX           0x00000002          // icon index in pwszIconFile is returned through pIndex

//===========================================================================
//
// IShellIconOverlayManager
//
// Used to return the icon overlay information including OverlayIndex, Image Index or Priority for an IShellFolder object.
//
// IShellIconOverlayManager:GetFileOverlayInfo(LPCWSTR pwszPath, DWORD dwAttrib, int * pIndex, DWORD dwflags)
//      pwszPath        full path of the file
//      dwAttrib        attribute of this file
//      pIndex          pointer to the Icon Index in the system image list
//      pOverlayIndex   pointer to the OverlayIndex in the system image list
//      pPriority       pointer to the Priority of this overlay
// IShellIconOverlayManager:GetReservedOverlayInfo(LPCWSTR pwszPath, DWORD dwAttrib, int * pIndex, DWORD dwflags, int iReservedID)
//      iReservedID     reserved icon overlay id
//  returns:
//      S_OK,  if the index of an Overlay is found
//      S_FALSE, if no Overlay exists for this file
//      E_FAIL, if lpfd is bad
// IShellIconOverlayManager:RefreshOverlayImages(DWORD dwFlags)
//      This will refresh the overlay cache, depends on the dwFlags passed in
//      It will reload the icons into the imagelist, when passed SIOM_ICONINDEX
// IShellIconOverlayManager::LoadNonloadedOverlayIdentifiers()
//      This method loads any registered overlay identifiers (handlers) that
//      are not currently loaded.
// IShellIconOverlayManager::OverlayIndexFromImageIndex(int iImage, int *piIndex, BOOL fAdd)
//      iImage          existing shell image list index to look for
//      piIndex         returned overlay index
//      fAdd            Add image if not already present?
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IShellIconOverlayManager

DECLARE_INTERFACE_IID_(IShellIconOverlayManager, IUnknown, "f10b5e34-dd3b-42a7-aa7d-2f4ec54bb09b")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellIconOverlayManager methods ***
    STDMETHOD(GetFileOverlayInfo)(THIS_ __in LPCWSTR pwszPath, DWORD dwAttrib, __out int * pIndex, DWORD dwflags) PURE;
    STDMETHOD(GetReservedOverlayInfo)(THIS_ __in_opt LPCWSTR pwszPath, DWORD dwAttrib, __out int * pIndex, DWORD dwflags, int iReservedID) PURE;
    STDMETHOD(RefreshOverlayImages)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD(LoadNonloadedOverlayIdentifiers)(THIS) PURE;
    STDMETHOD(OverlayIndexFromImageIndex)(THIS_ int iImage, __out int * piIndex, BOOL fAdd) PURE;
};

#define SIOM_OVERLAYINDEX         1
#define SIOM_ICONINDEX            2
// #define SIOM_PRIORITY          3
#define SIOM_RESERVED_SHARED      0
#define SIOM_RESERVED_LINK        1
#define SIOM_RESERVED_SLOWFILE    2

//===========================================================================
//
// IShellIconOverlay
//
// Used to return the icon overlay index or its icon index for an IShellFolder object,
// this is always implemented with IShellFolder
//
// IShellIconOverlay:GetOverlayIndex(LPCITEMIDLIST pidl, DWORD * pdwIndex)
//      pidl            object to identify icon overlay for.
//      pdwIndex        the Overlay Index in the system image list
//
// IShellIconOverlay:GetOverlayIconIndex(LPCITEMIDLIST pidl, DWORD * pdwIndex)
//      pdwIconIndex    the Overlay Icon index in the system image list
// This method is only used for those who are interested in seeing the real bits
// of the Overlay Icon
//
//  returns:
//      S_OK,  if the index of an Overlay is found
//      S_FALSE, if no Overlay exists for this file
//      E_FAIL, if pidl is bad
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IShellIconOverlay

DECLARE_INTERFACE_IID_(IShellIconOverlay, IUnknown, "7d688a70-c613-11d0-999b-00c04fd655e1")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellIconOverlay methods ***
    STDMETHOD(GetOverlayIndex)(THIS_ PCUITEMID_CHILD pidl, __inout int * pIndex) PURE;
    STDMETHOD(GetOverlayIconIndex)(THIS_ PCUITEMID_CHILD pidl, __inout int * pIconIndex) PURE;
};

#define OI_DEFAULT 0x00000000
#define OI_ASYNC 0xFFFFEEEE

//-------------------------------------------------------------------------
//
// SHGetIconOverlayIndex
//
// This function takes the path and icon/res id to the icon and convert it into
// an overlay index in the system image list.
// Note: there are totally only 15 slots for system image overlays, some of which
// was reserved by the system, or taken by the overlayidentifiers, so it's possible
// that this function would fail and return -1;
//
// To get the default overlays in the system, such as the share hand, link shortcut
// and slow files, pass NULL as the file name, then the IDO_SHGIOI_* flags as the icon index
//-------------------------------------------------------------------------

#define IDO_SHGIOI_SHARE  0x0FFFFFFF
#define IDO_SHGIOI_LINK   0x0FFFFFFE
#define IDO_SHGIOI_SLOWFILE 0x0FFFFFFFD
SHSTDAPI_(int) SHGetIconOverlayIndexA(LPCSTR pszIconPath, int iIconIndex);
SHSTDAPI_(int) SHGetIconOverlayIndexW(LPCWSTR pszIconPath, int iIconIndex);
#ifdef UNICODE
#define SHGetIconOverlayIndex  SHGetIconOverlayIndexW
#else
#define SHGetIconOverlayIndex  SHGetIconOverlayIndexA
#endif // !UNICODE


#if (_WIN32_IE >= 0x0400)

// IShellLinkDataList::GetFlags()/SetFlags()
typedef enum {
    SLDF_HAS_ID_LIST                            = 0x00000001,   // Shell link saved with ID list
    SLDF_HAS_LINK_INFO                          = 0x00000002,   // Shell link saved with LinkInfo
    SLDF_HAS_NAME                               = 0x00000004,
    SLDF_HAS_RELPATH                            = 0x00000008,
    SLDF_HAS_WORKINGDIR                         = 0x00000010,
    SLDF_HAS_ARGS                               = 0x00000020,
    SLDF_HAS_ICONLOCATION                       = 0x00000040,
    SLDF_UNICODE                                = 0x00000080,   // the strings are unicode
    SLDF_FORCE_NO_LINKINFO                      = 0x00000100,   // disable LINKINFO tracking information (used to track network drives and compute UNC paths if one exists)
    SLDF_HAS_EXP_SZ                             = 0x00000200,   // the link contains expandable env strings
    SLDF_RUN_IN_SEPARATE                        = 0x00000400,   // Run the 16-bit target exe in a separate VDM/WOW
#if (NTDDI_VERSION < NTDDI_VISTA)
    SLDF_HAS_LOGO3ID                            = 0x00000800,   // not used anymore
#endif
    SLDF_HAS_DARWINID                           = 0x00001000,   // MSI (Darwin) link that can be installed on demand
    SLDF_RUNAS_USER                             = 0x00002000,   // Run target as a different user
    SLDF_HAS_EXP_ICON_SZ                        = 0x00004000,   // contains expandable env string for icon path
#if (NTDDI_VERSION >= NTDDI_WINXP)
    SLDF_NO_PIDL_ALIAS                          = 0x00008000,   // disable IDList alias mapping when parsing the IDList from the path
    SLDF_FORCE_UNCNAME                          = 0x00010000,   // make GetPath() prefer the UNC name to the local name
    SLDF_RUN_WITH_SHIMLAYER                     = 0x00020000,   // activate target of this link with shim layer active
#if (NTDDI_VERSION >= NTDDI_VISTA)
    SLDF_FORCE_NO_LINKTRACK                     = 0x00040000,   // disable ObjectID tracking information
    SLDF_ENABLE_TARGET_METADATA                 = 0x00080000,   // enable caching of target metadata into link
    SLDF_DISABLE_KNOWNFOLDER_RELATIVE_TRACKING  = 0x00200000,   // disable KnownFolder tracking information (EXP_KNOWN_FOLDER)
    SLDF_VALID                                  = 0x003FF7FF,   // bits that are valid for ::SetFlags()
#endif
    SLDF_RESERVED                               = (int) 0x80000000,   // Reserved-- so we can use the low word as an index value in the future
#endif
} SHELL_LINK_DATA_FLAGS;

#if !defined(__cplusplus) && defined(_MSC_VER) && (_MSC_VER >= 1200)
#pragma warning(push)
#pragma warning(disable:4201) /* nonstandard extension used : nameless struct/union */
#endif

typedef struct tagDATABLOCKHEADER
{
    DWORD   cbSize;             // Size of this extra data block
    DWORD   dwSignature;        // signature of this extra data block
} DATABLOCK_HEADER, *LPDATABLOCK_HEADER, *LPDBLIST;

typedef struct {
#ifdef __cplusplus
    DATABLOCK_HEADER dbh;
#else
    DATABLOCK_HEADER DUMMYSTRUCTNAME;
#endif
    WORD     wFillAttribute;         // fill attribute for console
    WORD     wPopupFillAttribute;    // fill attribute for console popups
    COORD    dwScreenBufferSize;     // screen buffer size for console
    COORD    dwWindowSize;           // window size for console
    COORD    dwWindowOrigin;         // window origin for console
    DWORD    nFont;
    DWORD    nInputBufferSize;
    COORD    dwFontSize;
    UINT     uFontFamily;
    UINT     uFontWeight;
    WCHAR    FaceName[LF_FACESIZE];
    UINT     uCursorSize;
    BOOL     bFullScreen;
    BOOL     bQuickEdit;
    BOOL     bInsertMode;
    BOOL     bAutoPosition;
    UINT     uHistoryBufferSize;
    UINT     uNumberOfHistoryBuffers;
    BOOL     bHistoryNoDup;
    COLORREF ColorTable[ 16 ];
} NT_CONSOLE_PROPS, *LPNT_CONSOLE_PROPS;
#define NT_CONSOLE_PROPS_SIG 0xA0000002

// This is a FE Console property
typedef struct {
#ifdef __cplusplus
    DATABLOCK_HEADER dbh;
#else
    DATABLOCK_HEADER DUMMYSTRUCTNAME;
#endif
    UINT     uCodePage;
} NT_FE_CONSOLE_PROPS, *LPNT_FE_CONSOLE_PROPS;
#define NT_FE_CONSOLE_PROPS_SIG 0xA0000004

#if (_WIN32_IE >= 0x0500)
typedef struct {
#ifdef __cplusplus
    DATABLOCK_HEADER dbh;
#else
    DATABLOCK_HEADER DUMMYSTRUCTNAME;
#endif
    CHAR        szDarwinID[MAX_PATH];  // ANSI darwin ID associated with link
    WCHAR       szwDarwinID[MAX_PATH]; // UNICODE darwin ID associated with link
} EXP_DARWIN_LINK, *LPEXP_DARWIN_LINK;
#define EXP_DARWIN_ID_SIG       0xA0000006
#endif

#if !defined(__cplusplus) && defined(_MSC_VER) && (_MSC_VER >= 1200)
#pragma warning(pop)
#endif

#define EXP_SPECIAL_FOLDER_SIG         0xA0000005   // LPEXP_SPECIAL_FOLDER


typedef struct
{
    DWORD       cbSize;             // Size of this extra data block
    DWORD       dwSignature;        // signature of this extra data block
    DWORD       idSpecialFolder;    // special folder id this link points into
    DWORD       cbOffset;           // ofset into pidl from SLDF_HAS_ID_LIST for child
} EXP_SPECIAL_FOLDER, *LPEXP_SPECIAL_FOLDER;


typedef struct
{
    DWORD       cbSize;             // Size of this extra data block
    DWORD       dwSignature;        // signature of this extra data block
    CHAR        szTarget[ MAX_PATH ];   // ANSI target name w/EXP_SZ in it
    WCHAR       swzTarget[ MAX_PATH ];  // UNICODE target name w/EXP_SZ in it
} EXP_SZ_LINK, *LPEXP_SZ_LINK;
#define EXP_SZ_LINK_SIG                0xA0000001   // LPEXP_SZ_LINK (target)
#define EXP_SZ_ICON_SIG                0xA0000007   // LPEXP_SZ_LINK (icon)

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef struct
{
    DWORD       cbSize;             // Size of this extra data block
    DWORD       dwSignature;        // signature of this extra data block
    BYTE abPropertyStorage[1];
} EXP_PROPERTYSTORAGE;
#define EXP_PROPERTYSTORAGE_SIG     0xA0000009
#endif

#endif // (_WIN32_IE >= 0x0400)


#ifdef _INC_SHELLAPI    /* for LPSHELLEXECUTEINFO */
//===========================================================================
//
// IShellExecuteHook Interface
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IShellExecuteHookA

DECLARE_INTERFACE_IID_(IShellExecuteHookA, IUnknown, "000214f5-0000-0000-c000-000000000046")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IShellExecuteHookA methods ***
    STDMETHOD(Execute)(THIS_ __inout LPSHELLEXECUTEINFOA pei) PURE;
};

#undef  INTERFACE
#define INTERFACE   IShellExecuteHookW

DECLARE_INTERFACE_IID_(IShellExecuteHookW, IUnknown, "000214fb-0000-0000-c000-000000000046")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IShellExecuteHookW methods ***
    STDMETHOD(Execute)(THIS_ __inout LPSHELLEXECUTEINFOW pei) PURE;
};

#ifdef UNICODE
#define IShellExecuteHook       IShellExecuteHookW
#define IShellExecuteHookVtbl   IShellExecuteHookWVtbl
#else
#define IShellExecuteHook       IShellExecuteHookA
#define IShellExecuteHookVtbl   IShellExecuteHookAVtbl
#endif
#endif

//===========================================================================
//
// IURLSearchHook Interface
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IURLSearchHook

DECLARE_INTERFACE_IID_(IURLSearchHook, IUnknown, "ac60f6a0-0fd9-11d0-99cb-00c04fd64497")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IURLSearchHook methods ***
    STDMETHOD(Translate)(THIS_ __out_ecount(cchBufferSize) LPWSTR lpwszSearchURL, DWORD cchBufferSize) PURE;
};

#undef  INTERFACE
#define INTERFACE   ISearchContext

DECLARE_INTERFACE_IID_(ISearchContext, IUnknown, "09F656A2-41AF-480C-88F7-16CC0D164615")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** ISearchContext methods ***
    STDMETHOD(GetSearchUrl)(THIS_ __out BSTR * pbstrSearchUrl) PURE;
    STDMETHOD(GetSearchText)(THIS_ __out BSTR * pbstrSearchText) PURE;
    STDMETHOD(GetSearchStyle)(THIS_ __out DWORD * pdwSearchStyle) PURE;
};

#undef  INTERFACE
#define INTERFACE   IURLSearchHook2

DECLARE_INTERFACE_IID_(IURLSearchHook2, IURLSearchHook, "5ee44da4-6d32-46e3-86bc-07540dedd0e0")
{
    // *** IURLSearchHook2 methods ***
    STDMETHOD(TranslateWithSearchContext)(THIS_ __out_ecount(cchBufferSize) LPWSTR lpwszSearchURL, DWORD cchBufferSize, __in_opt ISearchContext * pSearchContext) PURE;
};

//===========================================================================
//
// INewShortcutHook Interface
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   INewShortcutHookA

DECLARE_INTERFACE_IID_(INewShortcutHookA, IUnknown, "000214e1-0000-0000-c000-000000000046")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** INewShortcutHook methods ***
    STDMETHOD(SetReferent)(THIS_ LPCSTR pcszReferent, HWND hwnd) PURE;
    STDMETHOD(GetReferent)(THIS_ __out_ecount(cchReferent) LPSTR pszReferent, int cchReferent) PURE;
    STDMETHOD(SetFolder)(THIS_ LPCSTR pcszFolder) PURE;
    STDMETHOD(GetFolder)(THIS_ __out_ecount(cchFolder) LPSTR pszFolder, int cchFolder) PURE;
    STDMETHOD(GetName)(THIS_ __out_ecount(cchName) LPSTR pszName, int cchName) PURE;
    STDMETHOD(GetExtension)(THIS_ __out_ecount(cchExtension) LPSTR pszExtension, int cchExtension) PURE;
};

#undef  INTERFACE
#define INTERFACE   INewShortcutHookW

DECLARE_INTERFACE_IID_(INewShortcutHookW, IUnknown, "000214f7-0000-0000-c000-000000000046")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** INewShortcutHook methods ***
    STDMETHOD(SetReferent)(THIS_ LPCWSTR pcszReferent, HWND hwnd) PURE;
    STDMETHOD(GetReferent)(THIS_ __out_ecount(cchReferent) LPWSTR pszReferent, int cchReferent) PURE;
    STDMETHOD(SetFolder)(THIS_ LPCWSTR pcszFolder) PURE;
    STDMETHOD(GetFolder)(THIS_ __out_ecount(cchFolder) LPWSTR pszFolder, int cchFolder) PURE;
    STDMETHOD(GetName)(THIS_ __out_ecount(cchName) LPWSTR pszName, int cchName) PURE;
    STDMETHOD(GetExtension)(THIS_ __out_ecount(cchExtension) LPWSTR pszExtension, int cchExtension) PURE;
};

#ifdef UNICODE
#define INewShortcutHook        INewShortcutHookW
#define INewShortcutHookVtbl    INewShortcutHookWVtbl
#else
#define INewShortcutHook        INewShortcutHookA
#define INewShortcutHookVtbl    INewShortcutHookAVtbl
#endif

//===========================================================================
//
// ICopyHook Interface
//
//  The copy hook is called whenever file system directories are
//  copy/moved/deleted/renamed via the shell.  It is also called by the shell
//  on changes of status of printers.
//
//  Clients register their id under STRREG_SHEX_COPYHOOK for file system hooks
//  and STRREG_SHEx_PRNCOPYHOOK for printer hooks.
//  the CopyCallback is called prior to the action, so the hook has the chance
//  to allow, deny or cancel the operation by returning the falues:
//     IDYES  -  means allow the operation
//     IDNO   -  means disallow the operation on this file, but continue with
//              any other operations (eg. batch copy)
//     IDCANCEL - means disallow the current operation and cancel any pending
//              operations
//
//   arguments to the CopyCallback
//      hwnd - window to use for any UI
//      wFunc - what operation is being done
//      wFlags - and flags (FOF_*) set in the initial call to the file operation
//      pszSrcFile - name of the source file
//      dwSrcAttribs - file attributes of the source file
//      pszDestFile - name of the destiation file (for move and renames)
//      dwDestAttribs - file attributes of the destination file
//
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   ICopyHookA

DECLARE_INTERFACE_IID_(ICopyHookA, IUnknown, "000214EF-0000-0000-c000-000000000046")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ICopyHook methods ***
    STDMETHOD_(UINT,CopyCallback) (THIS_ HWND hwnd, UINT wFunc, UINT wFlags, LPCSTR pszSrcFile, DWORD dwSrcAttribs,
                                   LPCSTR pszDestFile, DWORD dwDestAttribs) PURE;
};

typedef ICopyHookA *    LPCOPYHOOKA;

#undef  INTERFACE
#define INTERFACE   ICopyHookW

DECLARE_INTERFACE_IID_(ICopyHookW, IUnknown, "000214FC-0000-0000-c000-000000000046")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ICopyHook methods ***
    STDMETHOD_(UINT,CopyCallback) (THIS_ HWND hwnd, UINT wFunc, UINT wFlags, LPCWSTR pszSrcFile, DWORD dwSrcAttribs,
                                   LPCWSTR pszDestFile, DWORD dwDestAttribs) PURE;
};

typedef ICopyHookW *    LPCOPYHOOKW;

#ifdef UNICODE
#define ICopyHook       ICopyHookW
#define ICopyHookVtbl   ICopyHookWVtbl
#define LPCOPYHOOK      LPCOPYHOOKW
#else
#define ICopyHook       ICopyHookA
#define ICopyHookVtbl   ICopyHookAVtbl
#define LPCOPYHOOK      LPCOPYHOOKA
#endif

// IFileViewer, IFileViewerSite not supported as of win2k
#if (NTDDI_VERSION < NTDDI_WIN2K)

//===========================================================================
//
// IFileViewerSite Interface
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IFileViewerSite

DECLARE_INTERFACE_IID_(IFileViewerSite, IUnknown, "000214f3-0000-0000-c000-000000000046")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IFileViewerSite methods ***
    STDMETHOD(SetPinnedWindow) (THIS_ HWND hwnd) PURE;
    STDMETHOD(GetPinnedWindow) (THIS_ __out HWND *phwnd) PURE;
};

typedef IFileViewerSite * LPFILEVIEWERSITE;

//===========================================================================
//
// IFileViewer Interface
//
// Implemented in a FileViewer component object.  Used to tell a
// FileViewer to PrintTo or to view, the latter happening though
// ShowInitialize and Show.  The filename is always given to the
// viewer through IPersistFile.
//
//===========================================================================

#include <pshpack8.h>

typedef struct
{
    // Stuff passed into viewer (in)
    DWORD cbSize;           // Size of structure for future expansion...
    HWND hwndOwner;         // who is the owner window.
    int iShow;              // The show command

    // Passed in and updated  (in/Out)
    DWORD dwFlags;          // flags
    RECT rect;              // Where to create the window may have defaults
    IUnknown *punkRel;      // Relese this interface when window is visible

    // Stuff that might be returned from viewer (out)
    OLECHAR strNewFile[MAX_PATH];   // New File to view.

} FVSHOWINFO, *LPFVSHOWINFO;

#include <poppack.h>        /* Return to byte packing */

    // Define File View Show Info Flags.
#define FVSIF_RECT      0x00000001      // The rect variable has valid data.
#define FVSIF_PINNED    0x00000002      // We should Initialize pinned

#define FVSIF_NEWFAILED 0x08000000      // The new file passed back failed
                                        // to be viewed.

#define FVSIF_NEWFILE   0x80000000      // A new file to view has been returned
#define FVSIF_CANVIEWIT 0x40000000      // The viewer can view it.

#undef  INTERFACE
#define INTERFACE   IFileViewerA

DECLARE_INTERFACE_IID(IFileViewerA, "000214f0-0000-0000-c000-000000000046")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IFileViewer methods ***
    STDMETHOD(ShowInitialize) (THIS_ __in LPFILEVIEWERSITE lpfsi) PURE;
    STDMETHOD(Show) (THIS_ __in LPFVSHOWINFO pvsi) PURE;
    STDMETHOD(PrintTo) (THIS_ __in_opt LPSTR pszDriver, BOOL fSuppressUI) PURE;
};

typedef IFileViewerA * LPFILEVIEWERA;

#undef  INTERFACE
#define INTERFACE   IFileViewerW

DECLARE_INTERFACE_IID(IFileViewerW, "000214f8-0000-0000-c000-000000000046")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IFileViewer methods ***
    STDMETHOD(ShowInitialize) (THIS_ __in LPFILEVIEWERSITE lpfsi) PURE;
    STDMETHOD(Show) (THIS_ __in LPFVSHOWINFO pvsi) PURE;
    STDMETHOD(PrintTo) (THIS_ __in_opt LPWSTR pszDriver, BOOL fSuppressUI) PURE;
};

typedef IFileViewerW * LPFILEVIEWERW;

#ifdef UNICODE
#define IFileViewer IFileViewerW
#define LPFILEVIEWER LPFILEVIEWERW
#else
#define IFileViewer IFileViewerA
#define LPFILEVIEWER LPFILEVIEWERA
#endif

// IFileViewer, IFileViewerSite not supported as of win2k
#endif // (NTDDI_VERSION < NTDDI_WIN2K)


//--------------------------------------------------------------------------
//
// Command/menuitem IDs
//
//  The explorer dispatches WM_COMMAND messages based on the range of
// command/menuitem IDs. All the IDs of menuitems that the view (right
// pane) inserts must be in FCIDM_SHVIEWFIRST/LAST (otherwise, the explorer
// won't dispatch them). The view should not deal with any menuitems
// in FCIDM_BROWSERFIRST/LAST (otherwise, it won't work with the future
// version of the shell).
//
//  FCIDM_SHVIEWFIRST/LAST      for the right pane (IShellView)
//  FCIDM_BROWSERFIRST/LAST     for the explorer frame (IShellBrowser)
//  FCIDM_GLOBAL/LAST           for the explorer's submenu IDs
//
//--------------------------------------------------------------------------

#define FCIDM_SHVIEWFIRST           0x0000
#define FCIDM_SHVIEWLAST            0x7fff
#define FCIDM_BROWSERFIRST          0xa000
#define FCIDM_BROWSERLAST           0xbf00
#define FCIDM_GLOBALFIRST           0x8000
#define FCIDM_GLOBALLAST            0x9fff

//
// Global submenu IDs and separator IDs
//
#define FCIDM_MENU_FILE             (FCIDM_GLOBALFIRST+0x0000)
#define FCIDM_MENU_EDIT             (FCIDM_GLOBALFIRST+0x0040)
#define FCIDM_MENU_VIEW             (FCIDM_GLOBALFIRST+0x0080)
#define FCIDM_MENU_VIEW_SEP_OPTIONS (FCIDM_GLOBALFIRST+0x0081)
#define FCIDM_MENU_TOOLS            (FCIDM_GLOBALFIRST+0x00c0) // for Win9x compat
#define FCIDM_MENU_TOOLS_SEP_GOTO   (FCIDM_GLOBALFIRST+0x00c1) // for Win9x compat
#define FCIDM_MENU_HELP             (FCIDM_GLOBALFIRST+0x0100)
#define FCIDM_MENU_FIND             (FCIDM_GLOBALFIRST+0x0140)
#define FCIDM_MENU_EXPLORE          (FCIDM_GLOBALFIRST+0x0150)
#define FCIDM_MENU_FAVORITES        (FCIDM_GLOBALFIRST+0x0170)

//--------------------------------------------------------------------------
// control IDs known to the view
//--------------------------------------------------------------------------

#define FCIDM_TOOLBAR      (FCIDM_BROWSERFIRST + 0)
#define FCIDM_STATUS       (FCIDM_BROWSERFIRST + 1)

#if (_WIN32_IE >= 0x0400)
//--------------------------------------------------------------------------
//
// The resource id of the offline cursor
// This cursor is avaialble in shdocvw.dll
#define IDC_OFFLINE_HAND        103
#if (_WIN32_IE >= _WIN32_IE_IE70)
#define IDC_PANTOOL_HAND_OPEN   104
#define IDC_PANTOOL_HAND_CLOSED 105
#endif
//
//--------------------------------------------------------------------------
#endif


// SBCMDID_GETPANE - not necessarily in order
#define PANE_NONE        ((DWORD)-1)
#define PANE_ZONE        1
#define PANE_OFFLINE     2
#define PANE_PRINTER     3
#define PANE_SSL         4
#define PANE_NAVIGATION  5
#define PANE_PROGRESS    6
#if (_WIN32_IE >= _WIN32_IE_IE60)
#define PANE_PRIVACY     7
#endif


// SHGetPathFromIDListEx returns a win32 file system path for the item in the name space.
//  and has a few special cases that include returning UNC printer names too!
typedef enum tagGPFIDL_FLAGS
{
    GPFIDL_DEFAULT    = 0x0000,      // normal Win32 file name, servers and drive roots included
    GPFIDL_ALTNAME    = 0x0001,      // short file name
    GPFIDL_UNCPRINTER = 0x0002,      // include UNC printer names too (non file system item)
};
typedef int GPFIDL_FLAGS;
SHSTDAPI_(BOOL) SHGetPathFromIDListEx(__in PCIDLIST_ABSOLUTE pidl, __out_ecount(cchPath) PWSTR pszPath, __in DWORD cchPath, __in GPFIDL_FLAGS uOpts);
//
// SHGetPathFromIDListW is the old version of SHGetPathFromIDListEx that assumes the size of the buffer (MAX_PATH).
// The pidl should point to a file system object.
SHSTDAPI_(BOOL) SHGetPathFromIDListA(PCIDLIST_ABSOLUTE pidl, __out_ecount(MAX_PATH) LPSTR pszPath);
//
// SHGetPathFromIDListW is the old version of SHGetPathFromIDListEx that assumes the size of the buffer (MAX_PATH).
// The pidl should point to a file system object.
SHSTDAPI_(BOOL) SHGetPathFromIDListW(PCIDLIST_ABSOLUTE pidl, __out_ecount(MAX_PATH) LPWSTR pszPath);
#ifdef UNICODE
#define SHGetPathFromIDList  SHGetPathFromIDListW
#else
#define SHGetPathFromIDList  SHGetPathFromIDListA
#endif // !UNICODE

SHSTDAPI_(int) SHCreateDirectory(HWND hwnd, LPCWSTR pszPath);
SHSTDAPI_(int) SHCreateDirectoryExA(HWND hwnd, LPCSTR pszPath, const SECURITY_ATTRIBUTES *psa);
SHSTDAPI_(int) SHCreateDirectoryExW(HWND hwnd, LPCWSTR pszPath, const SECURITY_ATTRIBUTES *psa);
#ifdef UNICODE
#define SHCreateDirectoryEx  SHCreateDirectoryExW
#else
#define SHCreateDirectoryEx  SHCreateDirectoryExA
#endif // !UNICODE

#if (NTDDI_VERSION >= NTDDI_VISTA)
#define OFASI_EDIT          0x0001
#define OFASI_OPENDESKTOP   0x0002
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)

SHSTDAPI SHOpenFolderAndSelectItems(PCIDLIST_ABSOLUTE pidlFolder, UINT cidl, __in_ecount_opt(cidl) PCUITEMID_CHILD_ARRAY apidl, DWORD dwFlags);

//  deprecated because of parameter ambiguity
//  call SHCreateItemWithParent() or SHCreateItemFromIDList() instead
SHSTDAPI SHCreateShellItem(__in_opt PCIDLIST_ABSOLUTE pidlParent, __in_opt IShellFolder *psfParent, __in PCUITEMID_CHILD pidl, __out IShellItem **ppsi);

#endif

//
// SHGetSpecialFolderLocation
//
//  Caller should use SHGetMalloc to obtain an allocator that can free the pidl
//
// registry entries for special paths are kept in :
#define REGSTR_PATH_SPECIAL_FOLDERS     REGSTR_PATH_EXPLORER TEXT("\\Shell Folders")


#define CSIDL_DESKTOP                   0x0000        // <desktop>
#define CSIDL_INTERNET                  0x0001        // Internet Explorer (icon on desktop)
#define CSIDL_PROGRAMS                  0x0002        // Start Menu\Programs
#define CSIDL_CONTROLS                  0x0003        // My Computer\Control Panel
#define CSIDL_PRINTERS                  0x0004        // My Computer\Printers
#define CSIDL_PERSONAL                  0x0005        // My Documents
#define CSIDL_FAVORITES                 0x0006        // <user name>\Favorites
#define CSIDL_STARTUP                   0x0007        // Start Menu\Programs\Startup
#define CSIDL_RECENT                    0x0008        // <user name>\Recent
#define CSIDL_SENDTO                    0x0009        // <user name>\SendTo
#define CSIDL_BITBUCKET                 0x000a        // <desktop>\Recycle Bin
#define CSIDL_STARTMENU                 0x000b        // <user name>\Start Menu
#define CSIDL_MYDOCUMENTS               CSIDL_PERSONAL //  Personal was just a silly name for My Documents
#define CSIDL_MYMUSIC                   0x000d        // "My Music" folder
#define CSIDL_MYVIDEO                   0x000e        // "My Videos" folder
#define CSIDL_DESKTOPDIRECTORY          0x0010        // <user name>\Desktop
#define CSIDL_DRIVES                    0x0011        // My Computer
#define CSIDL_NETWORK                   0x0012        // Network Neighborhood (My Network Places)
#define CSIDL_NETHOOD                   0x0013        // <user name>\nethood
#define CSIDL_FONTS                     0x0014        // windows\fonts
#define CSIDL_TEMPLATES                 0x0015
#define CSIDL_COMMON_STARTMENU          0x0016        // All Users\Start Menu
#define CSIDL_COMMON_PROGRAMS           0X0017        // All Users\Start Menu\Programs
#define CSIDL_COMMON_STARTUP            0x0018        // All Users\Startup
#define CSIDL_COMMON_DESKTOPDIRECTORY   0x0019        // All Users\Desktop
#define CSIDL_APPDATA                   0x001a        // <user name>\Application Data
#define CSIDL_PRINTHOOD                 0x001b        // <user name>\PrintHood

#ifndef CSIDL_LOCAL_APPDATA
#define CSIDL_LOCAL_APPDATA             0x001c        // <user name>\Local Settings\Applicaiton Data (non roaming)
#endif // CSIDL_LOCAL_APPDATA

#define CSIDL_ALTSTARTUP                0x001d        // non localized startup
#define CSIDL_COMMON_ALTSTARTUP         0x001e        // non localized common startup
#define CSIDL_COMMON_FAVORITES          0x001f

#ifndef _SHFOLDER_H_
#define CSIDL_INTERNET_CACHE            0x0020
#define CSIDL_COOKIES                   0x0021
#define CSIDL_HISTORY                   0x0022
#define CSIDL_COMMON_APPDATA            0x0023        // All Users\Application Data
#define CSIDL_WINDOWS                   0x0024        // GetWindowsDirectory()
#define CSIDL_SYSTEM                    0x0025        // GetSystemDirectory()
#define CSIDL_PROGRAM_FILES             0x0026        // C:\Program Files
#define CSIDL_MYPICTURES                0x0027        // C:\Program Files\My Pictures
#endif // _SHFOLDER_H_

#define CSIDL_PROFILE                   0x0028        // USERPROFILE
#define CSIDL_SYSTEMX86                 0x0029        // x86 system directory on RISC
#define CSIDL_PROGRAM_FILESX86          0x002a        // x86 C:\Program Files on RISC

#ifndef _SHFOLDER_H_
#define CSIDL_PROGRAM_FILES_COMMON      0x002b        // C:\Program Files\Common
#endif // _SHFOLDER_H_

#define CSIDL_PROGRAM_FILES_COMMONX86   0x002c        // x86 Program Files\Common on RISC
#define CSIDL_COMMON_TEMPLATES          0x002d        // All Users\Templates

#ifndef _SHFOLDER_H_
#define CSIDL_COMMON_DOCUMENTS          0x002e        // All Users\Documents
#define CSIDL_COMMON_ADMINTOOLS         0x002f        // All Users\Start Menu\Programs\Administrative Tools
#define CSIDL_ADMINTOOLS                0x0030        // <user name>\Start Menu\Programs\Administrative Tools
#endif // _SHFOLDER_H_

#define CSIDL_CONNECTIONS               0x0031        // Network and Dial-up Connections
#define CSIDL_COMMON_MUSIC              0x0035        // All Users\My Music
#define CSIDL_COMMON_PICTURES           0x0036        // All Users\My Pictures
#define CSIDL_COMMON_VIDEO              0x0037        // All Users\My Video
#define CSIDL_RESOURCES                 0x0038        // Resource Direcotry

#ifndef _SHFOLDER_H_
#define CSIDL_RESOURCES_LOCALIZED       0x0039        // Localized Resource Direcotry
#endif // _SHFOLDER_H_

#define CSIDL_COMMON_OEM_LINKS          0x003a        // Links to All Users OEM specific apps
#define CSIDL_CDBURN_AREA               0x003b        // USERPROFILE\Local Settings\Application Data\Microsoft\CD Burning
// unused                               0x003c
#define CSIDL_COMPUTERSNEARME           0x003d        // Computers Near Me (computered from Workgroup membership)

#ifndef _SHFOLDER_H_
#define CSIDL_FLAG_CREATE               0x8000        // combine with CSIDL_ value to force folder creation in SHGetFolderPath()
#endif // _SHFOLDER_H_

#define CSIDL_FLAG_DONT_VERIFY          0x4000        // combine with CSIDL_ value to return an unverified folder path
#define CSIDL_FLAG_DONT_UNEXPAND        0x2000        // combine with CSIDL_ value to avoid unexpanding environment variables
#if (NTDDI_VERSION >= NTDDI_WINXP)
#define CSIDL_FLAG_NO_ALIAS             0x1000        // combine with CSIDL_ value to insure non-alias versions of the pidl
#define CSIDL_FLAG_PER_USER_INIT        0x0800        // combine with CSIDL_ value to indicate per-user init (eg. upgrade)
#endif  // NTDDI_WINXP
#define CSIDL_FLAG_MASK                 0xFF00        // mask for all possible flag values

SHSTDAPI SHGetSpecialFolderLocation(HWND hwnd, int csidl, __out PIDLIST_ABSOLUTE *ppidl);

SHSTDAPI_(PIDLIST_ABSOLUTE) SHCloneSpecialIDList(HWND hwnd, int csidl, BOOL fCreate);
SHSTDAPI_(BOOL) SHGetSpecialFolderPathA(HWND hwnd, __out_ecount(MAX_PATH) LPSTR pszPath, int csidl, BOOL fCreate);
SHSTDAPI_(BOOL) SHGetSpecialFolderPathW(HWND hwnd, __out_ecount(MAX_PATH) LPWSTR pszPath, int csidl, BOOL fCreate);
#ifdef UNICODE
#define SHGetSpecialFolderPath  SHGetSpecialFolderPathW
#else
#define SHGetSpecialFolderPath  SHGetSpecialFolderPathA
#endif // !UNICODE

#if (NTDDI_VERSION >= NTDDI_WIN2K)
SHSTDAPI_(void) SHFlushSFCache(void);

typedef enum {
    SHGFP_TYPE_CURRENT  = 0,   // current value for user, verify it exists
    SHGFP_TYPE_DEFAULT  = 1,   // default value, may not exist
} SHGFP_TYPE;

SHFOLDERAPI SHGetFolderPathA(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, __out_ecount(MAX_PATH) LPSTR pszPath);
SHFOLDERAPI SHGetFolderPathW(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, __out_ecount(MAX_PATH) LPWSTR pszPath);
#ifdef UNICODE
#define SHGetFolderPath  SHGetFolderPathW
#else
#define SHGetFolderPath  SHGetFolderPathA
#endif // !UNICODE
SHSTDAPI SHGetFolderLocation(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, __out PIDLIST_ABSOLUTE *ppidl);
SHSTDAPI SHSetFolderPathA(int csidl, HANDLE hToken, DWORD dwFlags, LPCSTR pszPath);
SHSTDAPI SHSetFolderPathW(int csidl, HANDLE hToken, DWORD dwFlags, LPCWSTR pszPath);
#ifdef UNICODE
#define SHSetFolderPath  SHSetFolderPathW
#else
#define SHSetFolderPath  SHSetFolderPathA
#endif // !UNICODE
#endif  // NTDDI_WIN2K

#if (NTDDI_VERSION >= NTDDI_WINXP)
SHSTDAPI SHGetFolderPathAndSubDirA(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPCSTR pszSubDir, __out_ecount(MAX_PATH) LPSTR pszPath);
SHSTDAPI SHGetFolderPathAndSubDirW(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPCWSTR pszSubDir, __out_ecount(MAX_PATH) LPWSTR pszPath);
#ifdef UNICODE
#define SHGetFolderPathAndSubDir  SHGetFolderPathAndSubDirW
#else
#define SHGetFolderPathAndSubDir  SHGetFolderPathAndSubDirA
#endif // !UNICODE
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)

//
//  KNOWNFOLDERID based APIs
//

#define KF_FLAG_CREATE              0x00008000  // Make sure that the folder already exists or create it and apply security specified in folder definition
                                                // If folder can not be created then function will return failure and no folder path (IDList) will be returned
                                                // If folder is located on the network the function may take long time to execute

#define KF_FLAG_DONT_VERIFY         0x00004000  // If this flag is specified then the folder path is returned and no verification is performed
                                                // Use this flag is you want to get folder's path (IDList) and do not need to verify folder's existence
                                                //
                                                // If this flag is NOT specified then Known Folder API will try to verify that the folder exists
                                                //     If folder does not exist or can not be accessed then function will return failure and no folder path (IDList) will be returned
                                                //     If folder is located on the network the function may take long time to execute

#define KF_FLAG_DONT_UNEXPAND       0x00002000  // Set folder path as is and do not try to substitute parts of the path with environments variables.
                                                // If flag is not specified then Known Folder will try to replace parts of the path with some
                                                // known environment variables (%USERPROFILE%, %APPDATA% etc.)

#define KF_FLAG_NO_ALIAS            0x00001000  // Get file system based IDList if available. If the flag is not specified the Known Folder API
                                                // will try to return aliased IDList by default. Example for FOLDERID_Documents -
                                                // Aliased - [desktop]\[user]\[Documents] - exact location is determined by shell namespace layout and might change
                                                // Non aliased - [desktop]\[computer]\[disk_c]\[users]\[user]\[Documents] - location is determined by folder location in the file system

#define KF_FLAG_INIT                0x00000800  // Initialize the folder with desktop.ini settings
                                                // If folder can not be initialized then function will return failure and no folder path will be returned
                                                // If folder is located on the network the function may take long time to execute

#define KF_FLAG_DEFAULT_PATH        0x00000400  // Get the default path, will also verify folder existence unless KF_FLAG_DONT_VERIFY is also specified
#define KF_FLAG_NOT_PARENT_RELATIVE 0x00000200  // Get the not-parent-relative default path. Only valid with KF_FLAG_DEFAULT_PATH

#define KF_FLAG_SIMPLE_IDLIST       0x00000100  // Build simple pidl


STDAPI SHGetKnownFolderIDList(REFKNOWNFOLDERID rfid,
                             DWORD dwFlags,
                             HANDLE hToken,
                             __out PIDLIST_ABSOLUTE *ppidl);

STDAPI SHSetKnownFolderPath(REFKNOWNFOLDERID rfid,
                         DWORD dwFlags,
                         HANDLE hToken,
                         __in_opt PCWSTR pszPath);

STDAPI SHGetKnownFolderPath(REFKNOWNFOLDERID rfid,
                         DWORD dwFlags,
                         HANDLE hToken,
                         __out PWSTR *ppszPath); // free *ppszPath with CoTaskMemFree

#endif  // NTDDI_VISTA

#if (NTDDI_VERSION >= NTDDI_WIN2K)

#define FCS_READ                    0x00000001
#define FCS_FORCEWRITE              0x00000002
#define FCS_WRITE                   (FCS_READ | FCS_FORCEWRITE)

#define FCS_FLAG_DRAGDROP           2

// Mask which values have been retreived or being set.
#define FCSM_VIEWID                 0x00000001    // deprecated
#define FCSM_WEBVIEWTEMPLATE        0x00000002  // deprecated
#define FCSM_INFOTIP                0x00000004
#define FCSM_CLSID                  0x00000008
#define FCSM_ICONFILE               0x00000010
#define FCSM_LOGO                   0x00000020
#define FCSM_FLAGS                  0x00000040

#include <pshpack8.h>

// Used by SHGetSetFolderCustomSettings
typedef struct
{
    DWORD           dwSize;
    DWORD           dwMask;              // IN/OUT  Which Attributes to Get/Set
    SHELLVIEWID*    pvid;                // OUT - if dwReadWrite is FCS_READ, IN - otherwise
    // The folder's WebView template path
    LPWSTR          pszWebViewTemplate;   // OUT - if dwReadWrite is FCS_READ, IN - otherwise
    DWORD           cchWebViewTemplate;   // IN - Specifies the size of the buffer pointed to by pszWebViewTemplate
                                         // Ignored if dwReadWrite is FCS_READ
    LPWSTR           pszWebViewTemplateVersion;  // currently IN only
    // Infotip for the folder
    LPWSTR          pszInfoTip;          // OUT - if dwReadWrite is FCS_READ, IN - otherwise
    DWORD           cchInfoTip;          // IN - Specifies the size of the buffer pointed to by pszInfoTip
                                         // Ignored if dwReadWrite is FCS_READ
    // CLSID that points to more info in the registry
    CLSID*          pclsid;              // OUT - if dwReadWrite is FCS_READ, IN - otherwise
    // Other flags for the folder. Takes FCS_FLAG_* values
    DWORD           dwFlags;             // OUT - if dwReadWrite is FCS_READ, IN - otherwise


    LPWSTR           pszIconFile;        // OUT - if dwReadWrite is FCS_READ, IN - otherwise
    DWORD            cchIconFile;        // IN - Specifies the size of the buffer pointed to by pszIconFile
                                         // Ignored if dwReadWrite is FCS_READ

    int              iIconIndex;         // OUT - if dwReadWrite is FCS_READ, IN - otherwise

    LPWSTR           pszLogo;        // OUT - if dwReadWrite is FCS_READ, IN - otherwise
    DWORD            cchLogo;        // IN - Specifies the size of the buffer pointed to by pszIconFile
                                         // Ignored if dwReadWrite is FCS_READ
} SHFOLDERCUSTOMSETTINGS, *LPSHFOLDERCUSTOMSETTINGS;

#include <poppack.h>        /* Return to byte packing */

// Gets/Sets the Folder Custom Settings for pszPath based on dwReadWrite. dwReadWrite can be FCS_READ/FCS_WRITE/FCS_FORCEWRITE
SHSTDAPI SHGetSetFolderCustomSettings(__inout LPSHFOLDERCUSTOMSETTINGS pfcs, LPCWSTR pszPath, DWORD dwReadWrite);

#endif  // NTDDI_WIN2K

//-------------------------------------------------------------------------
//
// SHBrowseForFolder API
//
//
//-------------------------------------------------------------------------

typedef int (CALLBACK* BFFCALLBACK)(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData);

#include <pshpack8.h>

typedef struct _browseinfoA {
    HWND        hwndOwner;
    PCIDLIST_ABSOLUTE pidlRoot;
    LPSTR        pszDisplayName;        // Return display name of item selected.
    LPCSTR       lpszTitle;                     // text to go in the banner over the tree.
    UINT         ulFlags;                       // Flags that control the return stuff
    BFFCALLBACK  lpfn;
    LPARAM       lParam;                        // extra info that's passed back in callbacks
    int          iImage;                        // output var: where to return the Image index.
} BROWSEINFOA, *PBROWSEINFOA, *LPBROWSEINFOA;

typedef struct _browseinfoW {
    HWND        hwndOwner;
    PCIDLIST_ABSOLUTE pidlRoot;
    LPWSTR       pszDisplayName;        // Return display name of item selected.
    LPCWSTR      lpszTitle;                     // text to go in the banner over the tree.
    UINT         ulFlags;                       // Flags that control the return stuff
    BFFCALLBACK  lpfn;
    LPARAM       lParam;                        // extra info that's passed back in callbacks
    int          iImage;                        // output var: where to return the Image index.
} BROWSEINFOW, *PBROWSEINFOW, *LPBROWSEINFOW;

#include <poppack.h>        /* Return to byte packing */

#ifdef UNICODE
#define BROWSEINFO      BROWSEINFOW
#define PBROWSEINFO     PBROWSEINFOW
#define LPBROWSEINFO    LPBROWSEINFOW
#else
#define BROWSEINFO      BROWSEINFOA
#define PBROWSEINFO     PBROWSEINFOA
#define LPBROWSEINFO    LPBROWSEINFOA
#endif

// Browsing for directory.
#define BIF_RETURNONLYFSDIRS   0x0001  // For finding a folder to start document searching
#define BIF_DONTGOBELOWDOMAIN  0x0002  // For starting the Find Computer
#define BIF_STATUSTEXT         0x0004   // Top of the dialog has 2 lines of text for BROWSEINFO.lpszTitle and one line if
                                        // this flag is set.  Passing the message BFFM_SETSTATUSTEXTA to the hwnd can set the
                                        // rest of the text.  This is not used with BIF_USENEWUI and BROWSEINFO.lpszTitle gets
                                        // all three lines of text.
#define BIF_RETURNFSANCESTORS  0x0008
#define BIF_EDITBOX            0x0010   // Add an editbox to the dialog
#define BIF_VALIDATE           0x0020   // insist on valid result (or CANCEL)

#define BIF_NEWDIALOGSTYLE     0x0040   // Use the new dialog layout with the ability to resize
                                        // Caller needs to call OleInitialize() before using this API

#define BIF_USENEWUI           (BIF_NEWDIALOGSTYLE | BIF_EDITBOX)

#define BIF_BROWSEINCLUDEURLS  0x0080   // Allow URLs to be displayed or entered. (Requires BIF_USENEWUI)
#define BIF_UAHINT             0x0100   // Add a UA hint to the dialog, in place of the edit box. May not be combined with BIF_EDITBOX
#define BIF_NONEWFOLDERBUTTON  0x0200   // Do not add the "New Folder" button to the dialog.  Only applicable with BIF_NEWDIALOGSTYLE.
#define BIF_NOTRANSLATETARGETS 0x0400   // don't traverse target as shortcut

#define BIF_BROWSEFORCOMPUTER  0x1000  // Browsing for Computers.
#define BIF_BROWSEFORPRINTER   0x2000  // Browsing for Printers
#define BIF_BROWSEINCLUDEFILES 0x4000  // Browsing for Everything
#define BIF_SHAREABLE          0x8000  // sharable resources displayed (remote shares, requires BIF_USENEWUI)

// message from browser
#define BFFM_INITIALIZED        1
#define BFFM_SELCHANGED         2
#define BFFM_VALIDATEFAILEDA    3   // lParam:szPath ret:1(cont),0(EndDialog)
#define BFFM_VALIDATEFAILEDW    4   // lParam:wzPath ret:1(cont),0(EndDialog)
#define BFFM_IUNKNOWN           5   // provides IUnknown to client. lParam: IUnknown*

// messages to browser
#define BFFM_SETSTATUSTEXTA     (WM_USER + 100)
#define BFFM_ENABLEOK           (WM_USER + 101)
#define BFFM_SETSELECTIONA      (WM_USER + 102)
#define BFFM_SETSELECTIONW      (WM_USER + 103)
#define BFFM_SETSTATUSTEXTW     (WM_USER + 104)
#define BFFM_SETOKTEXT          (WM_USER + 105) // Unicode only
#define BFFM_SETEXPANDED        (WM_USER + 106) // Unicode only

SHSTDAPI_(PIDLIST_ABSOLUTE) SHBrowseForFolderA(LPBROWSEINFOA lpbi);
SHSTDAPI_(PIDLIST_ABSOLUTE) SHBrowseForFolderW(LPBROWSEINFOW lpbi);

#ifdef UNICODE
#define SHBrowseForFolder   SHBrowseForFolderW
#define BFFM_SETSTATUSTEXT  BFFM_SETSTATUSTEXTW
#define BFFM_SETSELECTION   BFFM_SETSELECTIONW

#define BFFM_VALIDATEFAILED BFFM_VALIDATEFAILEDW
#else
#define SHBrowseForFolder   SHBrowseForFolderA
#define BFFM_SETSTATUSTEXT  BFFM_SETSTATUSTEXTA
#define BFFM_SETSELECTION   BFFM_SETSELECTIONA

#define BFFM_VALIDATEFAILED BFFM_VALIDATEFAILEDA
#endif

//-------------------------------------------------------------------------
//
// SHLoadInProc
//
//   This function is no longer implemented. It will return E_NOTIMPL.
//
//-------------------------------------------------------------------------

SHSTDAPI SHLoadInProc(REFCLSID rclsid);


//-------------------------------------------------------------------------
//
// Internet Shortcut Object
//
//-------------------------------------------------------------------------
// Cmds for CGID_ShortCut
#if (_WIN32_IE >= _WIN32_IE_IE501)
enum
{
    ISHCUTCMDID_DOWNLOADICON      = 0,
    ISHCUTCMDID_INTSHORTCUTCREATE = 1,
#if (_WIN32_IE >= _WIN32_IE_IE70)
    ISHCUTCMDID_COMMITHISTORY     = 2,
    ISHCUTCMDID_SETUSERAWURL      = 3,
#endif
};
#define CMDID_INTSHORTCUTCREATE ISHCUTCMDID_INTSHORTCUTCREATE
#endif


//
// Helper function which returns a IShellFolder interface to the desktop
// folder. This is equivalent to call CoCreateInstance with CLSID_ShellDesktop.
//
//  CoCreateInstance(CLSID_Desktop, NULL, CLSCTX_INPROC, IID_PPV_ARGS(&pshf));
//
SHSTDAPI SHGetDesktopFolder(__out IShellFolder **ppshf);

// this interface is deprecated, data sources should
// implement IShellFolder2::GetDetailsOf()/GetDetailsEx() instead

#undef  INTERFACE
#define INTERFACE   IShellDetails

DECLARE_INTERFACE_IID_(IShellDetails, IUnknown, "000214EC-0000-0000-c000-000000000046")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellDetails methods ***
    STDMETHOD(GetDetailsOf)(THIS_ PCUITEMID_CHILD pidl, UINT iColumn, __out SHELLDETAILS *pDetails) PURE;
    STDMETHOD(ColumnClick)(THIS_ UINT iColumn) PURE;
};


//
// IObjMgr::Append(punk)
//   This function adds an object to the end of a list of objects.
//
// IObjMgr::Remove(punk)
//   This function removes an object from a list of objects.
//
// This is implemented by CLSID_ACLMulti so each AutoComplete List
// (CLSID_ACLHistory, CLSID_ACListISF, CLSID_ACLMRU) can be added.
// CLSID_ACLMulti's IEnumString will then be the union of the results
// from the COM Objects added.
//

#undef INTERFACE
#define INTERFACE IObjMgr

DECLARE_INTERFACE_IID_(IObjMgr, IUnknown, "00BB2761-6A77-11D0-A535-00C04FD7D062")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IObjMgr specific methods ***
    STDMETHOD(Append) (THIS_ __in IUnknown *punk) PURE;
    STDMETHOD(Remove) (THIS_ __in IUnknown *punk) PURE;
};

//
// ICurrentWorkingDirectory::GetDirectory(LPWSTR pwzPath, DWORD cchSize)
//   This function gets the Current Working Directory from a COM object that
//   stores such state.
//
// ICurrentWorkingDirectory::SetDirectory(LPCWSTR pwzPath)
//   This function sets the Current Working Directory of a COM object that
//   stores such state.
//
// This function can be used generically.  One COM object that implements it
// is CLSID_ACListISF so that the AutoComplete engine can complete relative
// paths.  SetDirectory() will set the "Current Working Directory" and
// AutoComplete with then complete both absolute and relative paths.
// For Example, if ::SetDirectory(L"C:\Program Files") is called, then
// the user can AutoComplete "..\winnt".  In order to set the current
// working directory for non-file system paths, "ftp://ftp.microsoft.com/" or
// "Control Panel" for example, use IPersistFolder.
//

#undef INTERFACE
#define INTERFACE ICurrentWorkingDirectory

DECLARE_INTERFACE_IID_(ICurrentWorkingDirectory, IUnknown, "91956D21-9276-11d1-921A-006097DF5BD4")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** ICurrentWorkingDirectory specific methods ***
    STDMETHOD(GetDirectory) (THIS_ __out_ecount(cchSize) LPWSTR pwzPath, DWORD cchSize) PURE;
    STDMETHOD(SetDirectory) (THIS_ LPCWSTR pwzPath) PURE;
};


//
// IACList::Expand(LPCWSTR)
//   This function tells an autocomplete list to expand a specific string.
//
// If the user enters a multi-level path, AutoComplete (CLSID_AutoComplete)
// will use this interface to tell the "AutoComplete Lists" where to expand
// the results.
//
// For Example, if the user enters "C:\Program Files\Micros", AutoComplete
// first completely enumerate the "AutoComplete Lists" via IEnumString.  Then it
// will call the "AutoComplete Lists" with IACList::Expand(L"C:\Program Files").
// It will then enumerate the IEnumString interface again to get results in
// that directory.
//

#undef INTERFACE
#define INTERFACE IACList

DECLARE_INTERFACE_IID_(IACList, IUnknown, "77A130B0-94FD-11D0-A544-00C04FD7d062")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IACList specific methods ***
    STDMETHOD(Expand) (THIS_ LPCWSTR pszExpand) PURE;
};

// This interface exists to allow the caller to set filter criteria
// for an AutoComplete List.  AutoComplete Lists generates the list of
// possible AutoComplete completions.  CLSID_ACListISF is one AutoComplete
// List COM object that implements this interface.

#undef INTERFACE
#define INTERFACE IACList2

typedef enum _tagAUTOCOMPLETELISTOPTIONS
{
    ACLO_NONE            = 0,    // don't enumerate anything
    ACLO_CURRENTDIR      = 1,    // enumerate current directory
    ACLO_MYCOMPUTER      = 2,    // enumerate MyComputer
    ACLO_DESKTOP         = 4,    // enumerate Desktop Folder
    ACLO_FAVORITES       = 8,    // enumerate Favorites Folder
    ACLO_FILESYSONLY     = 16,   // enumerate only the file system
#if (_WIN32_IE >= _WIN32_IE_IE60)
    ACLO_FILESYSDIRS     = 32,   // enumerate only the file system dirs, UNC shares, and UNC servers.
#endif
#if (_WIN32_IE >= _WIN32_IE_IE70)
    ACLO_VIRTUALNAMESPACE = 64,  // enumereate on the virual namespace
#endif
} AUTOCOMPLETELISTOPTIONS;

DECLARE_INTERFACE_IID_(IACList2, IACList, "470141a0-5186-11d2-bbb6-0060977b464c")
{
    // *** IACList2 specific methods ***
    STDMETHOD(SetOptions)(THIS_ DWORD dwFlag) PURE;
    STDMETHOD(GetOptions)(THIS_ __out DWORD* pdwFlag) PURE;
};


/*-------------------------------------------------------------------------*\
    INTERFACE: IProgressDialog

    DESCRIPTION:
        CLSID_ProgressDialog/IProgressDialog exist to allow a caller to create
    a progress dialog, set it's title, animation, text lines, progress, and
    it will do all the work of updating on a background thread, being modeless,
    handling the user canceling the operation, and estimating the time remaining
    until the operation completes.

    USAGE:
        This is how the dialog is used during operations that require progress
    and the ability to cancel:
    {
        DWORD dwComplete, dwTotal;
        IProgressDialog * ppd;
        CoCreateInstance(CLSID_ProgressDialog, NULL, CLSCTX_INPROC_SERVER, IID_IProgressDialog, (void **)&ppd);
        ppd->SetTitle(L"My Slow Operation");                                // Set the title of the dialog.
        ppd->SetAnimation(hInstApp, IDA_OPERATION_ANIMATION);               // Set the animation to play.
        ppd->StartProgressDialog(hwndParent, punk, PROGDLG_AUTOTIME, NULL); // Display and enable automatic estimated time remaining.
        ppd->SetCancelMsg(L"Please wait while the current operation is cleaned up", NULL);   // Will only be displayed if Cancel button is pressed.

        dwComplete = 0;
        dwTotal = CalcTotalUnitsToDo();

        // Reset because CalcTotalUnitsToDo() took a long time and the estimated time
        // is based on the time between ::StartProgressDialog() and the first
        // ::SetProgress() call.
        ppd->Timer(PDTIMER_RESET, NULL);

        for (nIndex = 0; nIndex < nTotal; nIndex++)
        {
            if (TRUE == ppd->HasUserCancelled())
                break;

            ppd->SetLine(2, L"I'm processing item n", FALSE, NULL);
            dwComplete += DoSlowOperation();

            ppd->SetProgress(dwCompleted, dwTotal);
        }

        ppd->StopProgressDialog();
        ppd->Release();
    }
\*-------------------------------------------------------------------------*/

// Flags for IProgressDialog::StartProgressDialog() (dwFlags)
// The flag space includes OPPROGDLG_ and PROGDLG_ values, please guarantee they don't conflict. See shobjidl.idl for OPPROGDLG_*
#define PROGDLG_NORMAL          0x00000000      // default normal progress dlg behavior
#define PROGDLG_MODAL           0x00000001      // the dialog is modal to its hwndParent (default is modeless)
#define PROGDLG_AUTOTIME        0x00000002      // automatically updates the "Line3" text with the "time remaining" (you cant call SetLine3 if you passs this!)
#define PROGDLG_NOTIME          0x00000004      // we dont show the "time remaining" if this is set. We need this if dwTotal < dwCompleted for sparse files
#define PROGDLG_NOMINIMIZE      0x00000008      // Do not have a minimize button in the caption bar.
#define PROGDLG_NOPROGRESSBAR   0x00000010      // Don't display the progress bar
#if (_WIN32_IE >= _WIN32_IE_IE70)
#define PROGDLG_MARQUEEPROGRESS 0x00000020      // Use marquee progress (comctl32 v6 required)
#define PROGDLG_NOCANCEL        0x00000040      // No cancel button (operation cannot be canceled) (use sparingly)
#endif

// Time Actions (dwTimerAction)
#define PDTIMER_RESET       0x00000001       // Reset the timer so the progress will be calculated from now until the first ::SetProgress() is called so
                                             // those this time will correspond to the values passed to ::SetProgress().  Only do this before ::SetProgress() is called.
#if (_WIN32_IE >= _WIN32_IE_IE70)
#define PDTIMER_PAUSE       0x00000002       // Progress has been suspended
#define PDTIMER_RESUME      0x00000003       // Progress has resumed
#endif


#undef  INTERFACE
#define INTERFACE   IProgressDialog

DECLARE_INTERFACE_IID_(IProgressDialog, IUnknown, "EBBC7C04-315E-11d2-B62F-006097DF5BD4")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IProgressDialog specific methods
    STDMETHOD(StartProgressDialog)(THIS_ __in_opt HWND hwndParent, __in_opt IUnknown * punkEnableModless, DWORD dwFlags, __reserved LPCVOID pvResevered) PURE;
    STDMETHOD(StopProgressDialog)(THIS) PURE;
    STDMETHOD(SetTitle)(THIS_ LPCWSTR pwzTitle) PURE;
    STDMETHOD(SetAnimation)(THIS_ HINSTANCE hInstAnimation, UINT idAnimation) PURE;
    STDMETHOD_(BOOL,HasUserCancelled) (THIS) PURE;
    STDMETHOD(SetProgress)(THIS_ DWORD dwCompleted, DWORD dwTotal) PURE;
    STDMETHOD(SetProgress64)(THIS_ ULONGLONG ullCompleted, ULONGLONG ullTotal) PURE;
    STDMETHOD(SetLine)(THIS_ DWORD dwLineNum, LPCWSTR pwzString, BOOL fCompactPath, __reserved LPCVOID pvResevered) PURE;
    STDMETHOD(SetCancelMsg)(THIS_ LPCWSTR pwzCancelMsg, __reserved LPCVOID pvResevered) PURE;
    STDMETHOD(Timer)(THIS_ DWORD dwTimerAction, __reserved LPCVOID pvResevered) PURE;
};


//==========================================================================
// IDockingWindowSite/IDockingWindow/IDockingWindowFrame interfaces
// IInputObjectSite/IInputObject interfaces
//
//  These interfaces allow us (or ISVs) to install/update external Internet
// Toolbar for IE and the shell. The frame will simply get the CLSID from
// registry (to be defined) and CoCreateInstance it.
//
//==========================================================================


//-------------------------------------------------------------------------
//
// IDockingWindowSite interface
//
//   A site implements this interface so the object can negotiate for
// and inquire about real estate on the site.
//
// [Member functions]
//
// IDockingWindowSite::GetBorderDW(punkObj, prcBorder)
//   Site returns the bounding rectangle of the given source object
//   (punkObj).
//
// IDockingWindowSite::RequestBorderSpaceDW(punkObj, pbw)
//   Object requests that the site makes room for it, as specified in
//   *pbw.
//
// IDockingWindowSite::SetBorderSpaceDW(punkObj, pbw)
//   Object requests that the site set the border spacing to the size
//   specified in *pbw.
//
//-------------------------------------------------------------------------


#undef  INTERFACE
#define INTERFACE   IDockingWindowSite

DECLARE_INTERFACE_IID_(IDockingWindowSite, IOleWindow, "2a342fc2-7b26-11d0-8ca9-00a0c92dbfe8")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND * lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IDockingWindowSite methods ***
    STDMETHOD(GetBorderDW) (THIS_ IUnknown* punkObj, LPRECT prcBorder) PURE;
    STDMETHOD(RequestBorderSpaceDW) (THIS_ IUnknown* punkObj, LPCBORDERWIDTHS pbw) PURE;
    STDMETHOD(SetBorderSpaceDW) (THIS_ IUnknown* punkObj, LPCBORDERWIDTHS pbw) PURE;
};



//-------------------------------------------------------------------------
//
// IDockingWindowFrame interface
//
// [Member functions]
//
// IDockingWindowFrame::AddToolbar(punkSrc, pwszItem, dwReserved)
//
// IDockingWindowFrame::RemoveToolbar(punkSrc, dwRemoveFlags)
//
// IDockingWindowFrame::FindToolbar(pwszItem, riid, ppv)
//
//-------------------------------------------------------------------------


// flags for RemoveToolbar
#define DWFRF_NORMAL            0x0000
#define DWFRF_DELETECONFIGDATA  0x0001


// flags for AddToolbar
#define DWFAF_HIDDEN    0x0001   // add hidden
#define DWFAF_GROUP1    0x0002   // insert at end of group 1
#define DWFAF_GROUP2    0x0004   // insert at end of group 2
#define DWFAF_AUTOHIDE  0x0010   // The toolbar will be subject to AutoHide in Full Screen mode


#undef  INTERFACE
#define INTERFACE   IDockingWindowFrame

DECLARE_INTERFACE_IID_(IDockingWindowFrame, IOleWindow, "47d2657a-7b27-11d0-8ca9-00a0c92dbfe8")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND * lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IDockingWindowFrame methods ***
    STDMETHOD(AddToolbar) (THIS_ IUnknown* punkSrc, LPCWSTR pwszItem, DWORD dwAddFlags) PURE;
    STDMETHOD(RemoveToolbar) (THIS_ IUnknown* punkSrc, DWORD dwRemoveFlags) PURE;
    STDMETHOD(FindToolbar) (THIS_ LPCWSTR pwszItem, REFIID riid, void **ppv) PURE;
};



#if (_WIN32_IE >= 0x0400)

/* ***************** IThumbnailCapture
 * CaptureThumbnail : takes an IHTMLDocument2 and returns a thumbnail of specified
 *                    size as an hbitmap
 */

#undef  INTERFACE
#define INTERFACE   IThumbnailCapture

DECLARE_INTERFACE_IID_(IThumbnailCapture, IUnknown, "4ea39266-7211-409f-b622-f63dbd16c533")
{
    // *** IThumbnailCapture methods ***
    STDMETHOD (CaptureThumbnail)    ( THIS_ const SIZE * pMaxSize,
                                      IUnknown * pHTMLDoc2,
                                      HBITMAP * phbmThumbnail ) PURE;
};
typedef IThumbnailCapture * LPTHUMBNAILCAPTURE;

#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K && NTDDI_VERSION < NTDDI_VISTA)

#include <pshpack8.h>

typedef struct _EnumImageStoreDATAtag
{
    WCHAR     szPath[MAX_PATH];
    FILETIME  ftTimeStamp;
} ENUMSHELLIMAGESTOREDATA, * PENUMSHELLIMAGESTOREDATA;

#include <poppack.h>        /* Return to byte packing */

#undef  INTERFACE
#define INTERFACE   IEnumShellImageStore

DECLARE_INTERFACE_IID_( IEnumShellImageStore, IUnknown, "6DFD582B-92E3-11D1-98A3-00C04FB687DA" )
{
    STDMETHOD ( QueryInterface ) ( THIS_ REFIID riid, void **ppv ) PURE;
    STDMETHOD_( ULONG, AddRef ) ( THIS ) PURE;
    STDMETHOD_( ULONG, Release ) ( THIS ) PURE;

    STDMETHOD ( Reset ) ( THIS ) PURE;
    STDMETHOD ( Next ) ( THIS_ ULONG celt, PENUMSHELLIMAGESTOREDATA * prgElt, ULONG * pceltFetched ) PURE;
    STDMETHOD ( Skip ) ( THIS_ ULONG celt ) PURE;
    STDMETHOD ( Clone ) ( THIS_ IEnumShellImageStore ** ppEnum ) PURE;
};

typedef IEnumShellImageStore * LPENUMSHELLIMAGESTORE;


// flags used to determine the capabilities of the storage for the images
#define SHIMSTCAPFLAG_LOCKABLE    0x0001       // does the store require/support locking
#define SHIMSTCAPFLAG_PURGEABLE   0x0002       // does the store require dead items purging externally ?

#undef  INTERFACE
#define INTERFACE   IShellImageStore

// this interface is used to manipulate the Image cache. It can potentially be used
// in a free threaded manner in conjunction with the Lock parameter to Open and close
DECLARE_INTERFACE_IID_( IShellImageStore, IUnknown, "48C8118C-B924-11D1-98D5-00C04FB687DA" )
{
    STDMETHOD ( QueryInterface )( THIS_ REFIID riid, void **ppv ) PURE;
    STDMETHOD_( ULONG, AddRef ) ( THIS ) PURE;
    STDMETHOD_( ULONG, Release ) ( THIS ) PURE;

    // if the lock parameter is used, then all other calls into
    // open and/or create will block until the lock is released.
    STDMETHOD ( Open ) ( THIS_ DWORD dwMode, DWORD * pdwLock ) PURE;
    STDMETHOD ( Create ) ( THIS_ DWORD dwMode, DWORD * pdwLock ) PURE;

    // if the lock is passed to either of these two methods, it releases the lock
    // once the operation is complete.
    STDMETHOD ( ReleaseLock ) ( THIS_ DWORD const * pdwLock ) PURE;
    STDMETHOD ( Close ) ( THIS_ DWORD const * pdwLock ) PURE;
    STDMETHOD ( Commit ) ( THIS_ DWORD const * pdwLock ) PURE;
    STDMETHOD ( IsLocked ) ( THIS ) PURE;

    STDMETHOD ( GetMode ) ( THIS_ DWORD * pdwMode ) PURE;
    STDMETHOD ( GetCapabilities ) ( THIS_ DWORD * pdwCapMask ) PURE;

    STDMETHOD ( AddEntry ) ( THIS_ LPCWSTR pszName, const FILETIME * pftTimeStamp, DWORD dwMode, HBITMAP hImage ) PURE;
    STDMETHOD ( GetEntry ) ( THIS_ LPCWSTR pszName, DWORD dwMode, HBITMAP * phImage ) PURE;
    STDMETHOD ( DeleteEntry ) ( THIS_ LPCWSTR pszName ) PURE;
    STDMETHOD ( IsEntryInStore ) ( THIS_ LPCWSTR pszName, FILETIME * pftTimeStamp ) PURE;

    STDMETHOD ( Enum ) ( THIS_ LPENUMSHELLIMAGESTORE * ppEnum ) PURE;
};

typedef IShellImageStore * LPSHELLIMAGESTORE;

#endif  // (NTDDI_VERSION >= NTDDI_WIN2K && NTDDI_VERSION < NTDDI_VISTA)

#if (_WIN32_IE >= 0x0400)

////  IShellFolderBand

// Field mask
#define ISFB_MASK_STATE          0x00000001 // TRUE if dwStateMask and dwState is valid
#define ISFB_MASK_BKCOLOR        0x00000002 // TRUE if crBkgnd field is valid
#define ISFB_MASK_VIEWMODE       0x00000004 // TRUE if wViewMode field is valid
#define ISFB_MASK_SHELLFOLDER    0x00000008
#define ISFB_MASK_IDLIST         0x00000010
#define ISFB_MASK_COLORS         0x00000020 // TRUE if crXXXX fields are valid (except bkgnd)

#define ISFB_STATE_DEFAULT       0x00000000
#define ISFB_STATE_DEBOSSED      0x00000001
#define ISFB_STATE_ALLOWRENAME   0x00000002
#define ISFB_STATE_NOSHOWTEXT    0x00000004 // TRUE if _fNoShowText
#define ISFB_STATE_CHANNELBAR    0x00000010 // TRUE if we want NavigateTarget support
#define ISFB_STATE_QLINKSMODE    0x00000020 // TRUE if we want to turn off drag & drop onto content items
#define ISFB_STATE_FULLOPEN      0x00000040 // TRUE if band should maximize when opened
#define ISFB_STATE_NONAMESORT    0x00000080 // TRUE if band should _not_ sort icons by name
#define ISFB_STATE_BTNMINSIZE    0x00000100 // TRUE if band should report min thickness of button

#define ISFBVIEWMODE_SMALLICONS   0x0001
#define ISFBVIEWMODE_LARGEICONS   0x0002
#if (_WIN32_IE < _WIN32_IE_IE70)
#define ISFBVIEWMODE_LOGOS        0x0003
#endif

#include <pshpack8.h>

typedef struct {
    DWORD       dwMask;       // [in] ISFB_MASK mask of valid fields from crBkgnd on
    DWORD       dwStateMask;  // [in] ISFB_STATE mask of dwState bits being set/queried
    DWORD       dwState;      // [in/out] ISFB_STATE bits
    COLORREF    crBkgnd;      // [in/out]
    COLORREF    crBtnLt;      // [in/out]
    COLORREF    crBtnDk;      // [in/out]
    WORD        wViewMode;    // [in/out]
    WORD        wAlign;       // not used (yet)
    IShellFolder * psf;       // [out]
    PIDLIST_ABSOLUTE pidl;      // [out]
} BANDINFOSFB, *PBANDINFOSFB;

#include <poppack.h>        /* Return to byte packing */

#undef INTERFACE
#define INTERFACE IShellFolderBand

DECLARE_INTERFACE_IID_(IShellFolderBand, IUnknown, "7FE80CC8-C247-11d0-B93A-00A0C90312E1")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellFolderBand Methods ***
    STDMETHOD(InitializeSFB)(THIS_ __in_opt IShellFolder *psf, __in_opt PCIDLIST_ABSOLUTE pidl) PURE;
    STDMETHOD(SetBandInfoSFB)(THIS_ __in PBANDINFOSFB pbi) PURE;
    STDMETHOD(GetBandInfoSFB)(THIS_ __inout PBANDINFOSFB pbi) PURE;
};

// Command Target IDs
enum {
    SFBID_PIDLCHANGED,
};

////  IDeskBarClient

#undef  INTERFACE
#define INTERFACE   IDeskBarClient

DECLARE_INTERFACE_IID_(IDeskBarClient, IOleWindow, "EB0FE175-1A3A-11D0-89B3-00A0C90A90AC")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ __out HWND * lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IDeskBarClient methods ***
    STDMETHOD(SetDeskBarSite) (THIS_ __in_opt IUnknown* punkSite) PURE;
    STDMETHOD(SetModeDBC) (THIS_ DWORD dwMode) PURE;
    STDMETHOD(UIActivateDBC) (THIS_ DWORD dwState) PURE;
    STDMETHOD(GetSize) (THIS_ DWORD dwWhich, __out LPRECT prc) PURE;
};

#define DBC_GS_IDEAL          0  // get the ideal size
#define DBC_GS_SIZEDOWN       1  // clip the height of a rect to a multiple of the rebar's integral size


#define DBC_HIDE        0 // Band is hidden (being destroyed)
#define DBC_SHOW        1 // Band is visible
#define DBC_SHOWOBSCURE 2 // Band is completely obscured


enum {
    DBCID_EMPTY = 0,        // bandsite is empty
    DBCID_ONDRAG = 1,       // (down)DragMoveEnter/Leave vaIn:I4:eDrag
    DBCID_CLSIDOFBAR = 2,   // clsid of bar inside
    DBCID_RESIZE = 3,       // resize from keyboard
    DBCID_GETBAR = 4,       // returns vaOut:VT_UNKNOWN of hosting dockbar (IDeskBar)
};

#endif // _WIN32_IE > 0x0400


#if (_WIN32_IE >= 0x400)
//
// We need to make sure that WININET.H is included before this interface is
// used because the COMPONENT structure uses INTERNET_MAX_URL_LENGTH
//
#ifdef _WININET_
//
//  Flags and structures used by IActiveDesktop
//

typedef struct _tagWALLPAPEROPT
{
    DWORD   dwSize;     // size of this Structure.
    DWORD   dwStyle;    // WPSTYLE_* mentioned above
}
WALLPAPEROPT;

typedef WALLPAPEROPT  *LPWALLPAPEROPT;
typedef const WALLPAPEROPT *LPCWALLPAPEROPT;

typedef struct _tagCOMPONENTSOPT
{
    DWORD   dwSize;             //Size of this structure
    BOOL    fEnableComponents;  //Enable components?
    BOOL    fActiveDesktop;     // Active desktop enabled ?
}
COMPONENTSOPT;

typedef COMPONENTSOPT   *LPCOMPONENTSOPT;
typedef const COMPONENTSOPT   *LPCCOMPONENTSOPT;

typedef struct _tagCOMPPOS
{
    DWORD   dwSize;             //Size of this structure
    int     iLeft;              //Left of top-left corner in screen co-ordinates.
    int     iTop;               //Top of top-left corner in screen co-ordinates.
    DWORD   dwWidth;            // Width in pixels.
    DWORD   dwHeight;           // Height in pixels.
    int     izIndex;            // Indicates the Z-order of the component.
    BOOL    fCanResize;         // Is the component resizeable?
    BOOL    fCanResizeX;        // Resizeable in X-direction?
    BOOL    fCanResizeY;        // Resizeable in Y-direction?
    int     iPreferredLeftPercent;    //Left of top-left corner as percent of screen width
    int     iPreferredTopPercent;     //Top of top-left corner as percent of screen height
}
COMPPOS;

typedef COMPPOS *LPCOMPPOS;
typedef const COMPPOS *LPCCOMPPOS;

typedef struct  _tagCOMPSTATEINFO
{
    DWORD   dwSize;             // Size of this structure.
    int     iLeft;              // Left of the top-left corner in screen co-ordinates.
    int     iTop;               // Top of top-left corner in screen co-ordinates.
    DWORD   dwWidth;            // Width in pixels.
    DWORD   dwHeight;           // Height in pixels.
    DWORD   dwItemState;        // State of the component (full-screen mode or split-screen or normal state.
}
COMPSTATEINFO;

typedef COMPSTATEINFO   *LPCOMPSTATEINFO;
typedef const COMPSTATEINFO *LPCCOMPSTATEINFO;



#define COMPONENT_TOP (0x3fffffff)  // izOrder value meaning component is at the top


// iCompType values
#define COMP_TYPE_HTMLDOC       0
#define COMP_TYPE_PICTURE       1
#define COMP_TYPE_WEBSITE       2
#define COMP_TYPE_CONTROL       3
#define COMP_TYPE_CFHTML        4
#define COMP_TYPE_MAX           4

// The following is the COMPONENT structure used in IE4.01, IE4.0 and Memphis. It is kept here for compatibility
// reasons.
typedef struct _tagIE4COMPONENT
{
    DWORD   dwSize;             //Size of this structure
    DWORD   dwID;               //Reserved: Set it always to zero.
    int     iComponentType;     //One of COMP_TYPE_*
    BOOL    fChecked;           // Is this component enabled?
    BOOL    fDirty;             // Had the component been modified and not yet saved to disk?
    BOOL    fNoScroll;          // Is the component scrollable?
    COMPPOS cpPos;              // Width, height etc.,
    WCHAR   wszFriendlyName[MAX_PATH];          // Friendly name of component.
    WCHAR   wszSource[INTERNET_MAX_URL_LENGTH]; //URL of the component.
    WCHAR   wszSubscribedURL[INTERNET_MAX_URL_LENGTH]; //Subscrined URL
}
IE4COMPONENT;

typedef IE4COMPONENT *LPIE4COMPONENT;
typedef const IE4COMPONENT *LPCIE4COMPONENT;

//
// The following is the new NT5 component structure. Note that the initial portion of this component exactly
// matches the IE4COMPONENT structure. All new fields are added at the bottom and the dwSize field is used to
// distinguish between IE4COMPONENT and the new COMPONENT structures.
//
typedef struct _tagCOMPONENT
{
    DWORD   dwSize;             //Size of this structure
    DWORD   dwID;               //Reserved: Set it always to zero.
    int     iComponentType;     //One of COMP_TYPE_*
    BOOL    fChecked;           // Is this component enabled?
    BOOL    fDirty;             // Had the component been modified and not yet saved to disk?
    BOOL    fNoScroll;          // Is the component scrollable?
    COMPPOS cpPos;              // Width, height etc.,
    WCHAR   wszFriendlyName[MAX_PATH];          // Friendly name of component.
    WCHAR   wszSource[INTERNET_MAX_URL_LENGTH]; //URL of the component.
    WCHAR   wszSubscribedURL[INTERNET_MAX_URL_LENGTH]; //Subscrined URL

    //New fields are added below. Everything above here must exactly match the IE4COMPONENT Structure.
    DWORD           dwCurItemState; // Current state of the Component.
    COMPSTATEINFO   csiOriginal;    // Original state of the component when it was first added.
    COMPSTATEINFO   csiRestored;    // Restored state of the component.
}
COMPONENT;

typedef COMPONENT *LPCOMPONENT;
typedef const COMPONENT *LPCCOMPONENT;


// Defines for dwCurItemState
#define IS_NORMAL               0x00000001
#define IS_FULLSCREEN           0x00000002
#define IS_SPLIT                0x00000004
#define IS_VALIDSIZESTATEBITS   (IS_NORMAL | IS_SPLIT | IS_FULLSCREEN)  // The set of IS_* state bits which define the "size" of the component - these bits are mutually exclusive.
#define IS_VALIDSTATEBITS       (IS_NORMAL | IS_SPLIT | IS_FULLSCREEN | 0x80000000 | 0x40000000)  // All of the currently defined IS_* bits.

////////////////////////////////////////////
// Flags for IActiveDesktop::ApplyChanges()
#define AD_APPLY_SAVE             0x00000001
#define AD_APPLY_HTMLGEN          0x00000002
#define AD_APPLY_REFRESH          0x00000004
#define AD_APPLY_ALL              (AD_APPLY_SAVE | AD_APPLY_HTMLGEN | AD_APPLY_REFRESH)
#define AD_APPLY_FORCE            0x00000008
#define AD_APPLY_BUFFERED_REFRESH 0x00000010
#define AD_APPLY_DYNAMICREFRESH   0x00000020

////////////////////////////////////////////
// Flags for IActiveDesktop::GetWallpaper()
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define AD_GETWP_BMP            0x00000000
#define AD_GETWP_IMAGE          0x00000001
#define AD_GETWP_LAST_APPLIED   0x00000002
#endif

////////////////////////////////////////////
// Flags for IActiveDesktop::GetWallpaperOptions()
//           IActiveDesktop::SetWallpaperOptions()
#define WPSTYLE_CENTER      0
#define WPSTYLE_TILE        1
#define WPSTYLE_STRETCH     2
#define WPSTYLE_MAX         3


////////////////////////////////////////////
// Flags for IActiveDesktop::ModifyComponent()

#define COMP_ELEM_TYPE          0x00000001
#define COMP_ELEM_CHECKED       0x00000002
#define COMP_ELEM_DIRTY         0x00000004
#define COMP_ELEM_NOSCROLL      0x00000008
#define COMP_ELEM_POS_LEFT      0x00000010
#define COMP_ELEM_POS_TOP       0x00000020
#define COMP_ELEM_SIZE_WIDTH    0x00000040
#define COMP_ELEM_SIZE_HEIGHT   0x00000080
#define COMP_ELEM_POS_ZINDEX    0x00000100
#define COMP_ELEM_SOURCE        0x00000200
#define COMP_ELEM_FRIENDLYNAME  0x00000400
#define COMP_ELEM_SUBSCRIBEDURL 0x00000800
#define COMP_ELEM_ORIGINAL_CSI  0x00001000
#define COMP_ELEM_RESTORED_CSI  0x00002000
#define COMP_ELEM_CURITEMSTATE  0x00004000

#define COMP_ELEM_ALL   (COMP_ELEM_TYPE | COMP_ELEM_CHECKED | COMP_ELEM_DIRTY |                     \
                         COMP_ELEM_NOSCROLL | COMP_ELEM_POS_LEFT | COMP_ELEM_SIZE_WIDTH  |          \
                         COMP_ELEM_SIZE_HEIGHT | COMP_ELEM_POS_ZINDEX | COMP_ELEM_SOURCE |          \
                         COMP_ELEM_FRIENDLYNAME | COMP_ELEM_POS_TOP | COMP_ELEM_SUBSCRIBEDURL |     \
                         COMP_ELEM_ORIGINAL_CSI | COMP_ELEM_RESTORED_CSI | COMP_ELEM_CURITEMSTATE)


////////////////////////////////////////////
// Flags for IActiveDesktop::AddDesktopItemWithUI()
typedef enum tagDTI_ADTIWUI
{
    DTI_ADDUI_DEFAULT               = 0x00000000,
    DTI_ADDUI_DISPSUBWIZARD         = 0x00000001,
    DTI_ADDUI_POSITIONITEM          = 0x00000002,
};


////////////////////////////////////////////
// Flags for IActiveDesktop::AddUrl()
#define ADDURL_SILENT           0X0001


////////////////////////////////////////////
// Default positions for ADI
#define COMPONENT_DEFAULT_LEFT    (0xFFFF)
#define COMPONENT_DEFAULT_TOP     (0xFFFF)




//
//  Interface for manipulating the Active Desktop.
//

#undef INTERFACE
#define INTERFACE IActiveDesktop

DECLARE_INTERFACE_IID_(IActiveDesktop, IUnknown, "f490eb00-1240-11d1-9888-006097deacf9")
{
    // IUnknown methods
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) ( THIS ) PURE;
    STDMETHOD_(ULONG, Release) ( THIS ) PURE;

    // IActiveDesktop methods
    STDMETHOD (ApplyChanges)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD (GetWallpaper)(THIS_ __out_ecount(cchWallpaper) LPWSTR pwszWallpaper, UINT cchWallpaper, DWORD dwFlags) PURE;
    STDMETHOD (SetWallpaper)(THIS_ LPCWSTR pwszWallpaper, DWORD dwReserved) PURE;
    STDMETHOD (GetWallpaperOptions)(THIS_ __inout LPWALLPAPEROPT pwpo, DWORD dwReserved) PURE;
    STDMETHOD (SetWallpaperOptions)(THIS_ __in LPCWALLPAPEROPT pwpo, DWORD dwReserved) PURE;
    STDMETHOD (GetPattern)(THIS_ __out_ecount(cchPattern) LPWSTR pwszPattern, UINT cchPattern, DWORD dwReserved) PURE;
    STDMETHOD (SetPattern)(THIS_ LPCWSTR pwszPattern, DWORD dwReserved) PURE;
    STDMETHOD (GetDesktopItemOptions)(THIS_ __inout LPCOMPONENTSOPT pco, DWORD dwReserved) PURE;
    STDMETHOD (SetDesktopItemOptions)(THIS_ __in LPCCOMPONENTSOPT pco, DWORD dwReserved) PURE;
    STDMETHOD (AddDesktopItem)(THIS_ __in LPCCOMPONENT pcomp, DWORD dwReserved) PURE;
    STDMETHOD (AddDesktopItemWithUI)(THIS_ HWND hwnd, __in LPCOMPONENT pcomp, DWORD dwReserved) PURE;
    STDMETHOD (ModifyDesktopItem)(THIS_ __inout LPCCOMPONENT pcomp, DWORD dwFlags) PURE;
    STDMETHOD (RemoveDesktopItem)(THIS_ __in LPCCOMPONENT pcomp, DWORD dwReserved) PURE;
    STDMETHOD (GetDesktopItemCount)(THIS_ __out LPINT lpiCount, DWORD dwReserved) PURE;
    STDMETHOD (GetDesktopItem)(THIS_ int nComponent, __inout LPCOMPONENT pcomp, DWORD dwReserved) PURE;
    STDMETHOD (GetDesktopItemByID)(THIS_ ULONG_PTR dwID, __inout LPCOMPONENT pcomp, DWORD dwReserved) PURE;
    STDMETHOD (GenerateDesktopItemHtml)(THIS_ LPCWSTR pwszFileName, __in LPCOMPONENT pcomp, DWORD dwReserved) PURE;
    STDMETHOD (AddUrl)(THIS_ HWND hwnd, LPCWSTR pszSource, __in LPCOMPONENT pcomp, DWORD dwFlags) PURE;
    STDMETHOD (GetDesktopItemBySource)(THIS_ LPCWSTR pwszSource, __inout LPCOMPONENT pcomp, DWORD dwReserved) PURE;
};

typedef IActiveDesktop * LPACTIVEDESKTOP;

// Flags for SetSafeMode
#define SSM_CLEAR   0x0000
#define SSM_SET     0x0001
#define SSM_REFRESH 0x0002
#define SSM_UPDATE  0x0004

// Flags for Set/GetScheme
#define SCHEME_DISPLAY          0x0001
#define SCHEME_EDIT             0x0002
#define SCHEME_LOCAL            0x0004
#define SCHEME_GLOBAL           0x0008
#define SCHEME_REFRESH          0x0010
#define SCHEME_UPDATE           0x0020
#define SCHEME_DONOTUSE 0x0040 // used to be SCHEME_ENUMERATE; no longer supported
#define SCHEME_CREATE           0x0080

#undef INTERFACE
#define INTERFACE IActiveDesktopP

DECLARE_INTERFACE_IID_(IActiveDesktopP, IUnknown, "52502EE0-EC80-11D0-89AB-00C04FC2972D")
{
    // IUnknown methods
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) ( THIS ) PURE;
    STDMETHOD_(ULONG, Release) ( THIS ) PURE;

    // IActiveDesktopP methods
    STDMETHOD (SetSafeMode)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD (EnsureUpdateHTML)(THIS) PURE;
    STDMETHOD (SetScheme)(THIS_ LPCWSTR pwszSchemeName, DWORD dwFlags) PURE;
    STDMETHOD (GetScheme)(THIS_ __out_ecount(*lpdwcchBuffer) LPWSTR pwszSchemeName, __inout DWORD *lpdwcchBuffer, DWORD dwFlags) PURE;
    //
};

typedef IActiveDesktopP * LPACTIVEDESKTOPP;

//Flags for GetObjectFlags
#define GADOF_DIRTY    0x00000001

#undef INTERFACE
#define INTERFACE IADesktopP2

DECLARE_INTERFACE_IID_(IADesktopP2, IUnknown, "B22754E2-4574-11d1-9888-006097DEACF9")
{
    // IUnknown methods
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) ( THIS ) PURE;
    STDMETHOD_(ULONG, Release) ( THIS ) PURE;

    // IADesktopP2 methods
    STDMETHOD (ReReadWallpaper)(THIS) PURE;
    STDMETHOD (GetADObjectFlags)(THIS_ __out DWORD *lpdwFlags, DWORD dwMask) PURE;
    STDMETHOD (UpdateAllDesktopSubscriptions)(THIS) PURE;
    STDMETHOD (MakeDynamicChanges)(THIS_ __in IOleObject *pOleObj) PURE;
};

typedef IADesktopP2 * LPADESKTOPP2;


#endif // _WININET_

#if (_WIN32_IE >= 0x0500)

#define MAX_COLUMN_NAME_LEN 80
#define MAX_COLUMN_DESC_LEN 128

#include <pshpack1.h>

typedef struct {
    SHCOLUMNID  scid;                           // OUT the unique identifier of this column
    VARTYPE     vt;                             // OUT the native type of the data returned
    DWORD       fmt;                            // OUT this listview format (LVCFMT_LEFT, usually)
    UINT        cChars;                         // OUT the default width of the column, in characters
    DWORD       csFlags;                        // OUT SHCOLSTATE flags
    WCHAR wszTitle[MAX_COLUMN_NAME_LEN];        // OUT the title of the column
    WCHAR wszDescription[MAX_COLUMN_DESC_LEN];  // OUT full description of this column
} SHCOLUMNINFO, *LPSHCOLUMNINFO;
typedef const SHCOLUMNINFO* LPCSHCOLUMNINFO;

#include <poppack.h>        /* Return to default */

#include <pshpack8.h>

typedef struct {
    ULONG   dwFlags;              // initialization flags
    ULONG   dwReserved;           // reserved for future use.
    WCHAR   wszFolder[MAX_PATH];  // fully qualified folder path (or empty if multiple folders)
} SHCOLUMNINIT, *LPSHCOLUMNINIT;
typedef const SHCOLUMNINIT* LPCSHCOLUMNINIT;

#define SHCDF_UPDATEITEM        0x00000001      // this flag is a hint that the file has changed since the last call to GetItemData

typedef struct {
    ULONG   dwFlags;             // combination of SHCDF_ flags.
    DWORD   dwFileAttributes;    // file attributes.
    ULONG   dwReserved;          // reserved for future use.
    WCHAR*  pwszExt;             // address of file name extension
    WCHAR   wszFile[MAX_PATH];   // Absolute path of file.
} SHCOLUMNDATA, *LPSHCOLUMNDATA;
typedef const SHCOLUMNDATA* LPCSHCOLUMNDATA;

#include <poppack.h>        /* Return to byte packing */

#undef INTERFACE
#define INTERFACE IColumnProvider

// Note: these objects must be threadsafe!  GetItemData _will_ be called
// simultaneously from multiple threads.
DECLARE_INTERFACE_IID_(IColumnProvider, IUnknown, "E8025004-1C42-11d2-BE2C-00A0C9A83DA1")
{
    // IUnknown methods
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // IColumnProvider methods
    STDMETHOD (Initialize)(THIS_ LPCSHCOLUMNINIT psci) PURE;
    STDMETHOD (GetColumnInfo)(THIS_ DWORD dwIndex, __out SHCOLUMNINFO *psci) PURE;
    STDMETHOD (GetItemData)(THIS_ LPCSHCOLUMNID pscid, LPCSHCOLUMNDATA pscd, __out VARIANT *pvarData) PURE;
};

#endif // _WIN32_IE >= 0x0500
#endif // _WIN32_IE

//==========================================================================
// Clipboard format which may be supported by IDataObject from system
// defined shell folders (such as directories, network, ...).
//==========================================================================

#define CFSTR_SHELLIDLIST                   TEXT("Shell IDList Array")                  // CF_IDLIST
#define CFSTR_SHELLIDLISTOFFSET             TEXT("Shell Object Offsets")                // CF_OBJECTPOSITIONS
#define CFSTR_NETRESOURCES                  TEXT("Net Resource")                        // CF_NETRESOURCE
#define CFSTR_FILEDESCRIPTORA               TEXT("FileGroupDescriptor")                 // CF_FILEGROUPDESCRIPTORA
#define CFSTR_FILEDESCRIPTORW               TEXT("FileGroupDescriptorW")                // CF_FILEGROUPDESCRIPTORW
#define CFSTR_FILECONTENTS                  TEXT("FileContents")                        // CF_FILECONTENTS
#define CFSTR_FILENAMEA                     TEXT("FileName")                            // CF_FILENAMEA
#define CFSTR_FILENAMEW                     TEXT("FileNameW")                           // CF_FILENAMEW
#define CFSTR_PRINTERGROUP                  TEXT("PrinterFriendlyName")                 // CF_PRINTERS
#define CFSTR_FILENAMEMAPA                  TEXT("FileNameMap")                         // CF_FILENAMEMAPA
#define CFSTR_FILENAMEMAPW                  TEXT("FileNameMapW")                        // CF_FILENAMEMAPW
#define CFSTR_SHELLURL                      TEXT("UniformResourceLocator")
#define CFSTR_INETURLA                      CFSTR_SHELLURL
#define CFSTR_INETURLW                      TEXT("UniformResourceLocatorW")
#define CFSTR_PREFERREDDROPEFFECT           TEXT("Preferred DropEffect")
#define CFSTR_PERFORMEDDROPEFFECT           TEXT("Performed DropEffect")
#define CFSTR_PASTESUCCEEDED                TEXT("Paste Succeeded")
#define CFSTR_INDRAGLOOP                    TEXT("InShellDragLoop")
#define CFSTR_MOUNTEDVOLUME                 TEXT("MountedVolume")
#define CFSTR_PERSISTEDDATAOBJECT           TEXT("PersistedDataObject")
#define CFSTR_TARGETCLSID                   TEXT("TargetCLSID")                         // HGLOBAL with a CLSID of the drop target
#define CFSTR_LOGICALPERFORMEDDROPEFFECT    TEXT("Logical Performed DropEffect")
#define CFSTR_AUTOPLAY_SHELLIDLISTS         TEXT("Autoplay Enumerated IDList Array")    // (HGLOBAL with LPIDA)
#define CFSTR_UNTRUSTEDDRAGDROP             TEXT("UntrustedDragDrop")                   //  DWORD
#define CFSTR_FILE_ATTRIBUTES_ARRAY         TEXT("File Attributes Array")               // (FILE_ATTRIBUTES_ARRAY format on HGLOBAL)
#define CFSTR_INVOKECOMMAND_DROPPARAM       TEXT("InvokeCommand DropParam")             // (HGLOBAL with LPWSTR)
#define CFSTR_SHELLDROPHANDLER              TEXT("DropHandlerCLSID")                    // (HGLOBAL with CLSID of drop handler)
#define CFSTR_DROPDESCRIPTION               TEXT("DropDescription")                     // (HGLOBAL with DROPDESCRIPTION)

#ifdef UNICODE
#define CFSTR_FILEDESCRIPTOR    CFSTR_FILEDESCRIPTORW
#define CFSTR_FILENAME          CFSTR_FILENAMEW
#define CFSTR_FILENAMEMAP       CFSTR_FILENAMEMAPW
#define CFSTR_INETURL           CFSTR_INETURLW
#else
#define CFSTR_FILEDESCRIPTOR    CFSTR_FILEDESCRIPTORA
#define CFSTR_FILENAME          CFSTR_FILENAMEA
#define CFSTR_FILENAMEMAP       CFSTR_FILENAMEMAPA
#define CFSTR_INETURL           CFSTR_INETURLA
#endif

#define DVASPECT_SHORTNAME      2 // use for CF_HDROP to get short name version of file paths
#define DVASPECT_COPY           3 // use to indicate format is a "Copy" of the data (FILECONTENTS, FILEDESCRIPTOR, etc)
#define DVASPECT_LINK           4 // use to indicate format is a "Shortcut" to the data (FILECONTENTS, FILEDESCRIPTOR, etc)

#include <pshpack8.h>
//
// format of CF_NETRESOURCE
//
typedef struct _NRESARRAY {     // anr
    UINT cItems;
    NETRESOURCE nr[1];
} NRESARRAY, * LPNRESARRAY;
#include <poppack.h>        /* Return to byte packing */

//
// format of CF_IDLIST
//
typedef struct _IDA {
    UINT cidl;          // number of relative IDList
    UINT aoffset[1];    // [0]: folder IDList, [1]-[cidl]: item IDList
} CIDA, * LPIDA;

//
// FILEDESCRIPTOR.dwFlags field indicate which fields are valid in the FILEDESCRIPTOR struct
//
typedef enum {
    FD_CLSID            = 0x00000001,
    FD_SIZEPOINT        = 0x00000002,
    FD_ATTRIBUTES       = 0x00000004,
    FD_CREATETIME       = 0x00000008,
    FD_ACCESSTIME       = 0x00000010,
    FD_WRITESTIME       = 0x00000020,
    FD_FILESIZE         = 0x00000040,
    FD_PROGRESSUI       = 0x00004000,       // Show Progress UI w/Drag and Drop
    FD_LINKUI           = 0x00008000,       // 'link' UI is prefered
#if (NTDDI_VERSION >= NTDDI_VISTA)
    FD_UNICODE          = (int) 0x80000000,       // this descriptor is UNICODE
#endif
} FD_FLAGS;

typedef struct _FILEDESCRIPTORA {
    DWORD dwFlags;
    CLSID clsid;
    SIZEL sizel;
    POINTL pointl;
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    CHAR   cFileName[ MAX_PATH ];
} FILEDESCRIPTORA, *LPFILEDESCRIPTORA;

typedef struct _FILEDESCRIPTORW {
    DWORD dwFlags;

    CLSID clsid;
    SIZEL sizel;
    POINTL pointl;

    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    WCHAR  cFileName[ MAX_PATH ];
} FILEDESCRIPTORW, *LPFILEDESCRIPTORW;

#ifdef UNICODE
#define FILEDESCRIPTOR      FILEDESCRIPTORW
#define LPFILEDESCRIPTOR    LPFILEDESCRIPTORW
#else
#define FILEDESCRIPTOR      FILEDESCRIPTORA
#define LPFILEDESCRIPTOR    LPFILEDESCRIPTORA
#endif

//
// format of CF_FILEGROUPDESCRIPTOR
//
typedef struct _FILEGROUPDESCRIPTORA { // fgd
     UINT cItems;
     FILEDESCRIPTORA fgd[1];
} FILEGROUPDESCRIPTORA, * LPFILEGROUPDESCRIPTORA;

typedef struct _FILEGROUPDESCRIPTORW { // fgd
     UINT cItems;
     FILEDESCRIPTORW fgd[1];
} FILEGROUPDESCRIPTORW, * LPFILEGROUPDESCRIPTORW;

#ifdef UNICODE
#define FILEGROUPDESCRIPTOR     FILEGROUPDESCRIPTORW
#define LPFILEGROUPDESCRIPTOR   LPFILEGROUPDESCRIPTORW
#else
#define FILEGROUPDESCRIPTOR     FILEGROUPDESCRIPTORA
#define LPFILEGROUPDESCRIPTOR   LPFILEGROUPDESCRIPTORA
#endif

//
// format of CF_HDROP and CF_PRINTERS, in the HDROP case the data that follows
// is a double null terinated list of file names, for printers they are printer
// friendly names
//
typedef struct _DROPFILES {
   DWORD pFiles;                       // offset of file list
   POINT pt;                           // drop point (client coords)
   BOOL fNC;                           // is it on NonClient area
                                       // and pt is in screen coords
   BOOL fWide;                         // WIDE character switch
} DROPFILES, *LPDROPFILES;


#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef struct
{
    UINT cItems;                    // number of items in rgdwFileAttributes array
    DWORD dwSumFileAttributes;      // all of the attributes ORed together
    DWORD dwProductFileAttributes;  // all of the attributes ANDed together
    DWORD rgdwFileAttributes[1];    // array
} FILE_ATTRIBUTES_ARRAY;            // clipboard format definition for CFSTR_FILE_ATTRIBUTES_ARRAY
#endif


#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef enum
{
    DROPIMAGE_INVALID             = -1,                // no drop image at all
    DROPIMAGE_NONE                = 0,                 // red "no" circle
    DROPIMAGE_COPY                = DROPEFFECT_COPY,   // plus for copy
    DROPIMAGE_MOVE                = DROPEFFECT_MOVE,   // movement arrow for move
    DROPIMAGE_LINK                = DROPEFFECT_LINK,   // link arrow for link
    DROPIMAGE_LABEL               = 6,                 // tag icon to indicate metadata will be changed
    DROPIMAGE_WARNING             = 7,                 // yellow exclamation, something is amiss with the operation
} DROPIMAGETYPE;

typedef struct
{
    DROPIMAGETYPE type;                 // indicates the stock image to use

// text such as "Move to %1"
    WCHAR szMessage[MAX_PATH];

// text such as "Documents", inserted as specified by szMessage
    WCHAR szInsert[MAX_PATH];

// some UI coloring is applied to the text in szInsert, if used by specifying %1 in szMessage.
// %% and %1 are the subset of FormatMessage markers that are processed here.
} DROPDESCRIPTION;

#endif // (NTDDI_VERSION >= NTDDI_VISTA)


//====== File System Notification APIs ===============================
//
typedef struct _SHChangeNotifyEntry
{
    PCIDLIST_ABSOLUTE pidl;
    BOOL   fRecursive;
} SHChangeNotifyEntry;


//
//  File System Notification flags
//

#define SHCNRF_InterruptLevel      0x0001
#define SHCNRF_ShellLevel          0x0002
#define SHCNRF_RecursiveInterrupt  0x1000
#define SHCNRF_NewDelivery         0x8000

#define SHCNE_RENAMEITEM          0x00000001L
#define SHCNE_CREATE              0x00000002L
#define SHCNE_DELETE              0x00000004L
#define SHCNE_MKDIR               0x00000008L
#define SHCNE_RMDIR               0x00000010L
#define SHCNE_MEDIAINSERTED       0x00000020L
#define SHCNE_MEDIAREMOVED        0x00000040L
#define SHCNE_DRIVEREMOVED        0x00000080L
#define SHCNE_DRIVEADD            0x00000100L
#define SHCNE_NETSHARE            0x00000200L
#define SHCNE_NETUNSHARE          0x00000400L
#define SHCNE_ATTRIBUTES          0x00000800L
#define SHCNE_UPDATEDIR           0x00001000L
#define SHCNE_UPDATEITEM          0x00002000L
#define SHCNE_SERVERDISCONNECT    0x00004000L
#define SHCNE_UPDATEIMAGE         0x00008000L
#define SHCNE_DRIVEADDGUI         0x00010000L
#define SHCNE_RENAMEFOLDER        0x00020000L
#define SHCNE_FREESPACE           0x00040000L

#if (_WIN32_IE >= 0x0400)
// SHCNE_EXTENDED_EVENT: the extended event is identified in dwItem1,
// packed in LPITEMIDLIST format (same as SHCNF_DWORD packing).
// Additional information can be passed in the dwItem2 parameter
// of SHChangeNotify (called "pidl2" below), which if present, must also
// be in LPITEMIDLIST format.
//
// Unlike the standard events, the extended events are ORDINALs, so we
// don't run out of bits.  Extended events follow the SHCNEE_* naming
// convention.
//
// The dwItem2 parameter varies according to the extended event.

#define SHCNE_EXTENDED_EVENT      0x04000000L
#endif      // _WIN32_IE >= 0x0400

#define SHCNE_ASSOCCHANGED        0x08000000L

#define SHCNE_DISKEVENTS          0x0002381FL
#define SHCNE_GLOBALEVENTS        0x0C0581E0L // Events that dont match pidls first
#define SHCNE_ALLEVENTS           0x7FFFFFFFL
#define SHCNE_INTERRUPT           0x80000000L // The presence of this flag indicates
                                            // that the event was generated by an
                                            // interrupt.  It is stripped out before
                                            // the clients of SHCNNotify_ see it.

#if (_WIN32_IE >= 0x0400)
// SHCNE_EXTENDED_EVENT extended events.  These events are ordinals.
// This is not a bitfield.

#define SHCNEE_ORDERCHANGED         2L  // pidl2 is the changed folder
#define SHCNEE_MSI_CHANGE           4L  // pidl2 is a SHChangeProductKeyAsIDList
#define SHCNEE_MSI_UNINSTALL        5L  // pidl2 is a SHChangeProductKeyAsIDList
#endif

// Flags
// uFlags & SHCNF_TYPE is an ID which indicates what dwItem1 and dwItem2 mean
#define SHCNF_IDLIST      0x0000        // LPITEMIDLIST
#define SHCNF_PATHA       0x0001        // path name
#define SHCNF_PRINTERA    0x0002        // printer friendly name
#define SHCNF_DWORD       0x0003        // DWORD
#define SHCNF_PATHW       0x0005        // path name
#define SHCNF_PRINTERW    0x0006        // printer friendly name
#define SHCNF_TYPE        0x00FF
#define SHCNF_FLUSH       0x1000
#define SHCNF_FLUSHNOWAIT 0x2000

#define SHCNF_NOTIFYRECURSIVE      0x10000 // Notify clients registered for any child

#ifdef UNICODE
#define SHCNF_PATH      SHCNF_PATHW
#define SHCNF_PRINTER   SHCNF_PRINTERW
#else
#define SHCNF_PATH      SHCNF_PATHA
#define SHCNF_PRINTER   SHCNF_PRINTERA
#endif

//
//  APIs
//
SHSTDAPI_(void) SHChangeNotify(LONG wEventId, UINT uFlags, LPCVOID dwItem1, LPCVOID dwItem2);

//
// IShellChangeNotify
//
#undef  INTERFACE
#define INTERFACE  IShellChangeNotify

DECLARE_INTERFACE_IID_(IShellChangeNotify, IUnknown, "D82BE2B1-5764-11D0-A96E-00C04FD705A2")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellChangeNotify methods ***
    STDMETHOD(OnChange) (THIS_ LONG lEvent, PCIDLIST_ABSOLUTE pidl1, PCIDLIST_ABSOLUTE pidl2) PURE;
} ;

//
// IQueryInfo
//
//-------------------------------------------------------------------------
//
// IQueryInfo interface
//
// [Methods]
//              ::GetInfoTip()
//-------------------------------------------------------------------------

#undef  INTERFACE
#define INTERFACE  IQueryInfo

DECLARE_INTERFACE_IID_(IQueryInfo, IUnknown, "00021500-0000-0000-c000-000000000046")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IQueryInfo methods ***
    STDMETHOD(GetInfoTip)(THIS_ DWORD dwFlags, __out WCHAR **ppwszTip) PURE;
    STDMETHOD(GetInfoFlags)(THIS_ __out DWORD *pdwFlags) PURE;
} ;

#define QITIPF_DEFAULT          0x00000000
#define QITIPF_USENAME          0x00000001
#define QITIPF_LINKNOTARGET     0x00000002
#define QITIPF_LINKUSETARGET    0x00000004
#if (NTDDI_VERSION >= NTDDI_WINXP)
#define QITIPF_USESLOWTIP       0x00000008  // Flag says it's OK to take a long time generating tip
#endif
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define QITIPF_SINGLELINE       0x00000010
#endif

#define QIF_CACHED              0x00000001
#define QIF_DONTEXPANDFOLDER    0x00000002


//
// SHAddToRecentDocs
//
#define SHARD_PIDL      0x00000001L
#define SHARD_PATHA     0x00000002L
#define SHARD_PATHW     0x00000003L

#ifdef UNICODE
#define SHARD_PATH  SHARD_PATHW
#else
#define SHARD_PATH  SHARD_PATHA
#endif

SHSTDAPI_(void) SHAddToRecentDocs(UINT uFlags, LPCVOID pv);

typedef struct _SHChangeDWORDAsIDList {
    USHORT   cb;
    DWORD    dwItem1;
    DWORD    dwItem2;
    USHORT   cbZero;
} SHChangeDWORDAsIDList, *LPSHChangeDWORDAsIDList;


#if (NTDDI_VERSION >= NTDDI_WIN2K)


typedef struct _SHChangeUpdateImageIDList {
    USHORT cb;
    int iIconIndex;
    int iCurIndex;
    UINT uFlags;
    DWORD dwProcessID;
    WCHAR szName[MAX_PATH];
    USHORT cbZero;
} SHChangeUpdateImageIDList, * LPSHChangeUpdateImageIDList;
SHSTDAPI_(int) SHHandleUpdateImage(PCIDLIST_ABSOLUTE pidlExtra);


typedef struct _SHChangeProductKeyAsIDList {
    USHORT cb;
    WCHAR wszProductKey[39];
    USHORT cbZero;
} SHChangeProductKeyAsIDList, *LPSHChangeProductKeyAsIDList;


SHSTDAPI_(void) SHUpdateImageA(LPCSTR pszHashItem, int iIndex, UINT uFlags, int iImageIndex);
SHSTDAPI_(void) SHUpdateImageW(LPCWSTR pszHashItem, int iIndex, UINT uFlags, int iImageIndex);
#ifdef UNICODE
#define SHUpdateImage  SHUpdateImageW
#else
#define SHUpdateImage  SHUpdateImageA
#endif // !UNICODE
#endif /* NTDDI_WIN2K */

SHSTDAPI_(ULONG) SHChangeNotifyRegister(HWND hwnd, int fSources, LONG fEvents, UINT wMsg, int cEntries, const SHChangeNotifyEntry *pshcne);
SHSTDAPI_(BOOL) SHChangeNotifyDeregister(unsigned long ulID);

typedef enum
{
    SCNRT_ENABLE  = 0,
    SCNRT_DISABLE = 1,
} SCNRT_STATUS;

//  use SHChangeNotifyRegisterThread() to enable Async Register and Deregister.
//  call with SCNRT_ENABLE at the thread proc begining and SCNRT_DISABLE at the end
//  the call with SCNRT_DISABLE can block while it synchronizes with the main ChangeNotify thread
STDAPI_(void) SHChangeNotifyRegisterThread(SCNRT_STATUS status);

SHSTDAPI_(HANDLE) SHChangeNotification_Lock(HANDLE hChange, DWORD dwProcId, __deref_opt_out_ecount(2) PIDLIST_ABSOLUTE **pppidl, __out_opt LONG *plEvent);
SHSTDAPI_(BOOL) SHChangeNotification_Unlock(HANDLE hLock);
#if (_WIN32_IE >= 0x0400)
// The pidls that are given to the view via the ChangeNotifyEvents are simple Pidls,
// SHGetRealIDL() will convert them to true PIDLs.
SHSTDAPI SHGetRealIDL(IShellFolder *psf, PCUITEMID_CHILD pidlSimple, __out PITEMID_CHILD *ppidlReal);
#endif // _WIN32_IE >= 0x0400


SHSTDAPI SHGetInstanceExplorer(__out IUnknown **ppunk);

//
// SHGetDataFromIDListA/W
//
// SHGetDataFromIDList nFormat values TCHAR
#define SHGDFIL_FINDDATA        1
#define SHGDFIL_NETRESOURCE     2
#define SHGDFIL_DESCRIPTIONID   3

#define SHDID_ROOT_REGITEM          1
#define SHDID_FS_FILE               2
#define SHDID_FS_DIRECTORY          3
#define SHDID_FS_OTHER              4
#define SHDID_COMPUTER_DRIVE35      5
#define SHDID_COMPUTER_DRIVE525     6
#define SHDID_COMPUTER_REMOVABLE    7
#define SHDID_COMPUTER_FIXED        8
#define SHDID_COMPUTER_NETDRIVE     9
#define SHDID_COMPUTER_CDROM        10
#define SHDID_COMPUTER_RAMDISK      11
#define SHDID_COMPUTER_OTHER        12
#define SHDID_NET_DOMAIN            13
#define SHDID_NET_SERVER            14
#define SHDID_NET_SHARE             15
#define SHDID_NET_RESTOFNET         16
#define SHDID_NET_OTHER             17
#if (NTDDI_VERSION >= NTDDI_WINXP)
#define SHDID_COMPUTER_IMAGING      18
#define SHDID_COMPUTER_AUDIO        19
#define SHDID_COMPUTER_SHAREDDOCS   20
#endif
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define SHDID_MOBILE_DEVICE         21  // PDA/PalmPC
#endif

#include <pshpack8.h>

typedef struct _SHDESCRIPTIONID {
    DWORD   dwDescriptionId;
    CLSID   clsid;
} SHDESCRIPTIONID, *LPSHDESCRIPTIONID;

#include <poppack.h>        /* Return to byte packing */

// these delegate to IShellFolder2::GetDetailsEx()

SHSTDAPI SHGetDataFromIDListA(IShellFolder *psf, PCUITEMID_CHILD pidl, int nFormat, __out_bcount(cb) void *pv, int cb);
SHSTDAPI SHGetDataFromIDListW(IShellFolder *psf, PCUITEMID_CHILD pidl, int nFormat, __out_bcount(cb) void *pv, int cb);
#ifdef UNICODE
#define SHGetDataFromIDList  SHGetDataFromIDListW
#else
#define SHGetDataFromIDList  SHGetDataFromIDListA
#endif // !UNICODE


//===========================================================================

// PathResolve flags
#define PRF_VERIFYEXISTS            0x0001
#define PRF_TRYPROGRAMEXTENSIONS    (0x0002 | PRF_VERIFYEXISTS)
#define PRF_FIRSTDIRDEF             0x0004
#define PRF_DONTFINDLNK             0x0008      // if PRF_TRYPROGRAMEXTENSIONS is specified
#if (NTDDI_VERSION >= NTDDI_WINXPSP2)
#define PRF_REQUIREABSOLUTE         0x0010
#endif

SHSTDAPI_(int) RestartDialog(HWND hwnd, LPCWSTR lpPrompt, DWORD dwReturn);
#if (NTDDI_VERSION >= NTDDI_WINXP)
SHSTDAPI_(int) RestartDialogEx(HWND hwnd, LPCWSTR lpPrompt, DWORD dwReturn, DWORD dwReasonCode);
#endif

SHSTDAPI SHCoCreateInstance(__in_opt LPCWSTR pszCLSID, __in_opt const CLSID *pclsid, __in_opt IUnknown *pUnkOuter, __in REFIID riid, __deref_out void **ppv);

#if (NTDDI_VERSION >= NTDDI_VISTA)
SHSTDAPI SHCreateDataObject(__in PCIDLIST_ABSOLUTE pidlFolder, UINT cidl, __in_ecount_opt(cidl) PCUITEMID_CHILD_ARRAY apidl, __in_opt IDataObject *pdtInner, REFIID riid, __deref_out void **ppv);
#endif
SHSTDAPI CIDLData_CreateFromIDArray(__in PCIDLIST_ABSOLUTE pidlFolder, UINT cidl, __in_ecount_opt(cidl) PCUIDLIST_RELATIVE_ARRAY apidl, __out IDataObject **ppdtobj);
SHSTDAPI SHCreateStdEnumFmtEtc(UINT cfmt, __in_ecount(cfmt) const FORMATETC afmt[], __out IEnumFORMATETC **ppenumFormatEtc);
SHSTDAPI SHDoDragDrop(HWND hwnd, IDataObject *pdata, IDropSource *pdsrc, DWORD dwEffect, __out DWORD *pdwEffect);
// stuff for doing auto scrolling
#define NUM_POINTS      3
typedef struct {        // asd
    int iNextSample;
    DWORD dwLastScroll;
    BOOL bFull;
    POINT pts[NUM_POINTS];
    DWORD dwTimes[NUM_POINTS];
} AUTO_SCROLL_DATA;

SHSTDAPI_(BOOL) DAD_SetDragImage(HIMAGELIST him, POINT * pptOffset);
SHSTDAPI_(BOOL) DAD_DragEnterEx(HWND hwndTarget, const POINT ptStart);
SHSTDAPI_(BOOL) DAD_DragEnterEx2(HWND hwndTarget, const POINT ptStart, IDataObject *pdtObject);
SHSTDAPI_(BOOL) DAD_ShowDragImage(BOOL fShow);
SHSTDAPI_(BOOL) DAD_DragMove(POINT pt);
SHSTDAPI_(BOOL) DAD_DragLeave(void);
SHSTDAPI_(BOOL) DAD_AutoScroll(HWND hwnd, AUTO_SCROLL_DATA *pad, const POINT *pptNow);
typedef struct {
    WORD cLength;
    WORD nVersion;

    BOOL fFullPathTitle            : 1;
    BOOL fSaveLocalView            : 1;
    BOOL fNotShell                 : 1;
    BOOL fSimpleDefault            : 1;
    BOOL fDontShowDescBar          : 1;
    BOOL fNewWindowMode            : 1;
    BOOL fShowCompColor            : 1;  // NT: Show compressed volumes in a different colour
    BOOL fDontPrettyNames          : 1;  // NT: Do 8.3 name conversion, or not!
    BOOL fAdminsCreateCommonGroups : 1;  // NT: Administrators create comon groups
    UINT fUnusedFlags : 7;

    UINT fMenuEnumFilter;

} CABINETSTATE, * LPCABINETSTATE;

#define CABINETSTATE_VERSION 2

// APIs for reading and writing the cabinet state.
SHSTDAPI_(BOOL) ReadCabinetState(__out_bcount(cLength) CABINETSTATE *pcs, int cLength);
SHSTDAPI_(BOOL) WriteCabinetState(__in CABINETSTATE *pcs);
SHSTDAPI_(BOOL) PathMakeUniqueName(__out_ecount(cchMax) LPWSTR pszUniqueName, UINT cchMax, LPCWSTR pszTemplate, LPCWSTR pszLongPlate, LPCWSTR pszDir);
SHSTDAPI_(void) PathQualify(__inout LPWSTR psz);
SHSTDAPI_(BOOL) PathIsExe(LPCWSTR pszPath);
SHSTDAPI_(BOOL) PathIsSlowA(LPCSTR pszFile, DWORD dwAttr);
SHSTDAPI_(BOOL) PathIsSlowW(LPCWSTR pszFile, DWORD dwAttr);
#ifdef UNICODE
#define PathIsSlow  PathIsSlowW
#else
#define PathIsSlow  PathIsSlowA
#endif // !UNICODE
//
//  Return codes from PathCleanupSpec.  Negative return values are
//  unrecoverable errors
//
#define PCS_FATAL           0x80000000
#define PCS_REPLACEDCHAR    0x00000001
#define PCS_REMOVEDCHAR     0x00000002
#define PCS_TRUNCATED       0x00000004
#define PCS_PATHTOOLONG     0x00000008  // Always combined with FATAL

SHSTDAPI_(int) PathCleanupSpec(LPCWSTR pszDir, __inout LPWSTR pszSpec);
SHSTDAPI_(int) PathResolve(__out_ecount(MAX_PATH) LPWSTR lpszPath, __in_opt __nullterminated LPCWSTR dirs[], UINT fFlags);
SHSTDAPI_(BOOL) GetFileNameFromBrowse(HWND hwnd, __inout_ecount(cchFilePath) LPWSTR pszFilePath, UINT cchFilePath,
                                      LPCWSTR pszWorkingDir, LPCWSTR pszDefExt, LPCWSTR pszFilters, LPCWSTR pszTitle);
SHSTDAPI_(int) DriveType(int iDrive);

SHSTDAPI_(int) RealDriveType(int iDrive, BOOL fOKToHitNet);
SHSTDAPI_(int) IsNetDrive(int iDrive);
// Flags for Shell_MergeMenus
#define MM_ADDSEPARATOR         0x00000001L
#define MM_SUBMENUSHAVEIDS      0x00000002L
#define MM_DONTREMOVESEPS       0x00000004L

SHSTDAPI_(UINT) Shell_MergeMenus(HMENU hmDst, HMENU hmSrc, UINT uInsert, UINT uIDAdjust, UINT uIDAdjustMax, ULONG uFlags);


/*
 * The SHObjectProperties API provides an easy way to invoke the Properties
 *   context menu command on a subset of the shell item namespace.
 *
 *   PARAMETERS
 *
 *     hwnd              The window handle of the window which will own the dialog
 *     shopObjectType    A SHOP_ value as defined below
 *     pszObjectName     Name of the object, see SHOP_ values below
 *     pszPropertyPage   The name of the property sheet page to open to or NULL.
 *
 *   RETURN
 *
 *     TRUE if the Properties command was invoked
 */
SHSTDAPI_(BOOL) SHObjectProperties(__in_opt HWND hwnd, __in DWORD shopObjectType, __in PCWSTR pszObjectName, __in_opt PCWSTR pszPropertyPage);

#define SHOP_PRINTERNAME 0x00000001  // pszObjectName points to a printer friendly name
#define SHOP_FILEPATH    0x00000002  // pszObjectName points to a fully qualified path+file name
#define SHOP_VOLUMEGUID  0x00000004  // pszObjectName points to a Volume GUID


/*
 * The SHFormatDrive API provides access to the Shell
 *   format dialog. This allows apps which want to format disks
 *   to bring up the same dialog that the Shell does to do it.
 *
 *   This dialog is not sub-classable. You cannot put custom
 *   controls in it. If you want this ability, you will have
 *   to write your own front end for the DMaint_FormatDrive
 *   engine.
 *
 *   NOTE that the user can format as many diskettes in the specified
 *   drive, or as many times, as he/she wishes to. There is no way to
 *   force any specififc number of disks to format. If you want this
 *   ability, you will have to write your own front end for the
 *   DMaint_FormatDrive engine.
 *
 *   NOTE also that the format will not start till the user pushes the
 *   start button in the dialog. There is no way to do auto start. If
 *   you want this ability, you will have to write your own front end
 *   for the DMaint_FormatDrive engine.
 *
 *   PARAMETERS
 *
 *     hwnd    = The window handle of the window which will own the dialog
 *               NOTE that unlike SHCheckDrive, hwnd == NULL does not cause
 *               this dialog to come up as a "top level application" window.
 *               This parameter should always be non-null, this dialog is
 *               only designed to be the child of another window, not a
 *               stand-alone application.
 *     drive   = The 0 based (A: == 0) drive number of the drive to format
 *     fmtID   = The ID of the physical format to format the disk with
 *               NOTE: The special value SHFMT_ID_DEFAULT means "use the
 *                     default format specified by the DMaint_FormatDrive
 *                     engine". If you want to FORCE a particular format
 *                     ID "up front" you will have to call
 *                     DMaint_GetFormatOptions yourself before calling
 *                     this to obtain the valid list of phys format IDs
 *                     (contents of the PhysFmtIDList array in the
 *                     FMTINFOSTRUCT).
 *     options = There is currently only two option bits defined
 *
 *                SHFMT_OPT_FULL
 *                SHFMT_OPT_SYSONLY
 *
 *               The normal defualt in the Shell format dialog is
 *               "Quick Format", setting this option bit indicates that
 *               the caller wants to start with FULL format selected
 *               (this is useful for folks detecting "unformatted" disks
 *               and wanting to bring up the format dialog).
 *
 *               The SHFMT_OPT_SYSONLY initializes the dialog to
 *               default to just sys the disk.
 *
 *               All other bits are reserved for future expansion and
 *               must be 0.
 *
 *               Please note that this is a bit field and not a value
 *               and treat it accordingly.
 *
 *   RETURN
 *      The return is either one of the SHFMT_* values, or if the
 *      returned DWORD value is not == to one of these values, then
 *      the return is the physical format ID of the last succesful
 *      format. The LOWORD of this value can be passed on subsequent
 *      calls as the fmtID parameter to "format the same type you did
 *      last time".
 *
 */
SHSTDAPI_(DWORD) SHFormatDrive(HWND hwnd, UINT drive, UINT fmtID, UINT options);

//
// Special value of fmtID which means "use the default format"
//
#define SHFMT_ID_DEFAULT    0xFFFF

//
// Option bits for options parameter
//
#define SHFMT_OPT_FULL     0x0001
#define SHFMT_OPT_SYSONLY  0x0002

//
// Special return values. PLEASE NOTE that these are DWORD values.
//
#define SHFMT_ERROR     0xFFFFFFFFL     // Error on last format, drive may be formatable
#define SHFMT_CANCEL    0xFFFFFFFEL     // Last format was canceled
#define SHFMT_NOFORMAT  0xFFFFFFFDL     // Drive is not formatable

#ifndef HPSXA_DEFINED
#define HPSXA_DEFINED
DECLARE_HANDLE( HPSXA );
#endif
WINSHELLAPI HPSXA WINAPI SHCreatePropSheetExtArray( HKEY hKey, LPCWSTR pszSubKey, UINT max_iface );
WINSHELLAPI void WINAPI SHDestroyPropSheetExtArray(__in HPSXA hpsxa );
WINSHELLAPI UINT WINAPI SHAddFromPropSheetExtArray(__in HPSXA hpsxa, LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam );
WINSHELLAPI UINT WINAPI SHReplaceFromPropSheetExtArray(__in HPSXA hpsxa, UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam );

SHSTDAPI_(PIDLIST_RELATIVE)     ILClone(__in PCUIDLIST_RELATIVE pidl);
SHSTDAPI_(PITEMID_CHILD)        ILCloneFirst(__in PCUIDLIST_RELATIVE pidl);
SHSTDAPI_(PIDLIST_ABSOLUTE)     ILCombine(__in PCIDLIST_ABSOLUTE pidl1, __in PCUIDLIST_RELATIVE pidl2);
SHSTDAPI_(void)                 ILFree(__in_opt PIDLIST_RELATIVE pidl);
SHSTDAPI_(PUIDLIST_RELATIVE)    ILGetNext(__in PCUIDLIST_RELATIVE pidl);
SHSTDAPI_(UINT)                 ILGetSize(__in PCUIDLIST_RELATIVE pidl);
SHSTDAPI_(PUIDLIST_RELATIVE)    ILFindChild(__in PCIDLIST_ABSOLUTE pidlParent, __in PCIDLIST_ABSOLUTE pidlChild);
SHSTDAPI_(__out PUITEMID_CHILD) ILFindLastID(__in PCUIDLIST_RELATIVE pidl);
SHSTDAPI_(BOOL)                 ILRemoveLastID(__inout PUIDLIST_RELATIVE pidl);
SHSTDAPI_(BOOL)                 ILIsEqual(__in PCIDLIST_ABSOLUTE pidl1, __in PCIDLIST_ABSOLUTE pidl2);
SHSTDAPI_(BOOL)                 ILIsParent(__in PCIDLIST_ABSOLUTE pidl1, __in PCIDLIST_ABSOLUTE pidl2, BOOL fImmediate);
SHSTDAPI                        ILSaveToStream(__in IStream *pstm, __in PCUIDLIST_RELATIVE pidl);
DECLSPEC_DEPRECATED SHSTDAPI    ILLoadFromStream(__in IStream *pstm, __inout PIDLIST_RELATIVE *pidl);
SHSTDAPI                        ILLoadFromStreamEx(__in IStream *pstm, __deref_out PIDLIST_RELATIVE *pidl);

#if (_WIN32_IE >= 0x0400)

SHSTDAPI_(PIDLIST_ABSOLUTE)     ILCreateFromPathA(LPCSTR pszPath);
SHSTDAPI_(PIDLIST_ABSOLUTE)     ILCreateFromPathW(LPCWSTR pszPath);

#ifdef NO_WRAPPERS_FOR_ILCREATEFROMPATH
SHSTDAPI_(PIDLIST_ABSOLUTE)     ILCreateFromPath(LPCTSTR pszPath);
#else
#ifdef UNICODE
#define ILCreateFromPath        ILCreateFromPathW
#else
#define ILCreateFromPath        ILCreateFromPathA
#endif  // !UNICODE
#endif  // NO_WRAPPERS_FOR_ILCREATEFROMPATH

#endif  // (_WIN32_IE >= 0x0400)

SHSTDAPI SHILCreateFromPath(LPCWSTR pszPath, __out PIDLIST_ABSOLUTE *ppidl, __inout_opt DWORD *rgfInOut);


#define VOID_OFFSET(pv, cb)     ((void*)(((BYTE*)(pv))+(cb)))

#if defined(STRICT_TYPED_ITEMIDS) && defined(__cplusplus)

} // extern "C"

inline PIDLIST_ABSOLUTE ILCloneFull(__in PCUIDLIST_ABSOLUTE pidl) { return reinterpret_cast<PIDLIST_ABSOLUTE>(ILClone(pidl)); }
inline PITEMID_CHILD    ILCloneChild(__in PCUITEMID_CHILD pidl)   { return ILCloneFirst(pidl); }

inline HRESULT ILLoadFromStreamEx(__in IStream *pstm, __deref_out PIDLIST_ABSOLUTE *ppidl) { return ILLoadFromStreamEx(pstm, reinterpret_cast<PIDLIST_RELATIVE*>(ppidl)); }
inline HRESULT ILLoadFromStreamEx(__in IStream *pstm, __deref_out PITEMID_CHILD *ppidl)    { return ILLoadFromStreamEx(pstm, reinterpret_cast<PIDLIST_RELATIVE*>(ppidl)); }

inline PCUIDLIST_RELATIVE ILSkip(__in PCUIDLIST_RELATIVE pidl, UINT cb) { return reinterpret_cast<PCUIDLIST_RELATIVE>(VOID_OFFSET(pidl, cb)); }
inline PUIDLIST_RELATIVE  ILSkip(__in PUIDLIST_RELATIVE  pidl, UINT cb) { return const_cast<PUIDLIST_RELATIVE>(ILSkip(const_cast<PCUIDLIST_RELATIVE>(pidl), cb)); }

inline PCUIDLIST_RELATIVE ILNext(__in PCUIDLIST_RELATIVE pidl) { return ILSkip(pidl, pidl->mkid.cb); }
inline PUIDLIST_RELATIVE  ILNext(__in PUIDLIST_RELATIVE  pidl) { return const_cast<PUIDLIST_RELATIVE>(ILNext(const_cast<PCUIDLIST_RELATIVE>(pidl))); }

inline BOOL ILIsAligned(__in PCUIDLIST_RELATIVE pidl)       { return (((DWORD_PTR)(pidl) & (sizeof(void*) - 1)) == 0); }

inline BOOL ILIsEmpty(__in_opt PCUIDLIST_RELATIVE pidl)     { return ((pidl == NULL) || (pidl->mkid.cb==0)); }

// ILIsChild does not guarantee that pidl is non-null or non-empty.
inline BOOL ILIsChild(__in_opt PCUIDLIST_RELATIVE pidl)         { return (ILIsEmpty(pidl) || ILIsEmpty(ILNext(pidl))); }

extern "C" {

#else // !defined(STRICT_TYPED_ITEMIDS) || !defined(__cplusplus)

#define ILCloneFull             ILClone
#define ILCloneChild            ILCloneFirst

#define ILSkip(pidl, cb)        ((PUIDLIST_RELATIVE)VOID_OFFSET((pidl), (cb)))
#define ILNext(pidl)            ILSkip(pidl, (pidl)->mkid.cb)

#define ILIsAligned(pidl)       (((DWORD_PTR)(pidl) & (sizeof(void*) - 1)) == 0)

#define ILIsEmpty(pidl)         ((pidl) == NULL || (pidl)->mkid.cb==0)

// ILIsChild does not guarantee that pidl is non-null or non-empty.
#define ILIsChild(pidl)         (ILIsEmpty(pidl) || ILIsEmpty(ILNext(pidl)))

#endif // defined(STRICT_TYPED_ITEMIDS) && defined(__cplusplus)

SHSTDAPI_(PIDLIST_RELATIVE) ILAppendID(PIDLIST_RELATIVE pidl, LPCSHITEMID pmkid, BOOL fAppend);

#if (NTDDI_VERSION >= NTDDI_WIN2K && NTDDI_VERSION < NTDDI_VISTA)
#undef  INTERFACE
#define INTERFACE   IDefViewFrame
DECLARE_INTERFACE_IID_(IDefViewFrame, IUnknown, "710EB7A0-45ED-11D0-924A-0020AFC7AC4D")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IDefViewFrame methods ***
    STDMETHOD(GetWindowLV) (THIS_ __out HWND * phwnd) PURE;
    STDMETHOD(ReleaseWindowLV) (THIS) PURE;
    STDMETHOD(GetShellFolder)(THIS_ __out IShellFolder **ppsf) PURE;
};
#endif
//===========================================================================
// Shell restrictions. (Parameter for SHRestricted)
// SHRestricted has been deprecated in favor of SHWindowsPolicy
//--- do not add restrictions here, see winpolicy.cpp c_rgWindowsPolicies
typedef enum RESTRICTIONS
{
    REST_NONE                       = 0x00000000,
    REST_NORUN                      = 0x00000001,
    REST_NOCLOSE                    = 0x00000002,
    REST_NOSAVESET                  = 0x00000004,
    REST_NOFILEMENU                 = 0x00000008,
    REST_NOSETFOLDERS               = 0x00000010,
    REST_NOSETTASKBAR               = 0x00000020,
    REST_NODESKTOP                  = 0x00000040,
    REST_NOFIND                     = 0x00000080,
    REST_NODRIVES                   = 0x00000100,
    REST_NODRIVEAUTORUN             = 0x00000200,
    REST_NODRIVETYPEAUTORUN         = 0x00000400,
    REST_NONETHOOD                  = 0x00000800,
    REST_STARTBANNER                = 0x00001000,
    REST_RESTRICTRUN                = 0x00002000,
    REST_NOPRINTERTABS              = 0x00004000,
    REST_NOPRINTERDELETE            = 0x00008000,
    REST_NOPRINTERADD               = 0x00010000,
    REST_NOSTARTMENUSUBFOLDERS      = 0x00020000,
    REST_MYDOCSONNET                = 0x00040000,
    REST_NOEXITTODOS                = 0x00080000,
    REST_ENFORCESHELLEXTSECURITY    = 0x00100000,
    REST_LINKRESOLVEIGNORELINKINFO  = 0x00200000,
    REST_NOCOMMONGROUPS             = 0x00400000,
    REST_SEPARATEDESKTOPPROCESS     = 0x00800000,
    REST_NOWEB                      = 0x01000000,
    REST_NOTRAYCONTEXTMENU          = 0x02000000,
    REST_NOVIEWCONTEXTMENU          = 0x04000000,
    REST_NONETCONNECTDISCONNECT     = 0x08000000,
    REST_STARTMENULOGOFF            = 0x10000000,
    REST_NOSETTINGSASSIST           = 0x20000000,
    REST_NOINTERNETICON             = 0x40000001,
    REST_NORECENTDOCSHISTORY        = 0x40000002,
    REST_NORECENTDOCSMENU           = 0x40000003,
    REST_NOACTIVEDESKTOP            = 0x40000004,
    REST_NOACTIVEDESKTOPCHANGES     = 0x40000005,
    REST_NOFAVORITESMENU            = 0x40000006,
    REST_CLEARRECENTDOCSONEXIT      = 0x40000007,
    REST_CLASSICSHELL               = 0x40000008,
    REST_NOCUSTOMIZEWEBVIEW         = 0x40000009,
    REST_NOHTMLWALLPAPER            = 0x40000010,
    REST_NOCHANGINGWALLPAPER        = 0x40000011,
    REST_NODESKCOMP                 = 0x40000012,
    REST_NOADDDESKCOMP              = 0x40000013,
    REST_NODELDESKCOMP              = 0x40000014,
    REST_NOCLOSEDESKCOMP            = 0x40000015,
    REST_NOCLOSE_DRAGDROPBAND       = 0x40000016,   // Disable Close and Drag & Drop on ALL Bands
    REST_NOMOVINGBAND               = 0x40000017,   // Disable Moving ALL Bands
    REST_NOEDITDESKCOMP             = 0x40000018,
    REST_NORESOLVESEARCH            = 0x40000019,
    REST_NORESOLVETRACK             = 0x4000001A,
    REST_FORCECOPYACLWITHFILE       = 0x4000001B,
#if (NTDDI_VERSION < NTDDI_VISTA)
    REST_NOLOGO3CHANNELNOTIFY       = 0x4000001C,
#endif
    REST_NOFORGETSOFTWAREUPDATE     = 0x4000001D,
    REST_NOSETACTIVEDESKTOP         = 0x4000001E,   // No Active desktop on Settings Menu
    REST_NOUPDATEWINDOWS            = 0x4000001F,   // No Windows Update on Settings Menu
    REST_NOCHANGESTARMENU           = 0x40000020,   // No Context menu or Drag and Drop on Start menu
    REST_NOFOLDEROPTIONS            = 0x40000021,   // No Folder Options on Settings Menu
    REST_HASFINDCOMPUTERS           = 0x40000022,   // Show Start/Search/Computers
    REST_INTELLIMENUS               = 0x40000023,
    REST_RUNDLGMEMCHECKBOX          = 0x40000024,
    REST_ARP_ShowPostSetup          = 0x40000025,   // ARP: Show Post-Setup page
    REST_NOCSC                      = 0x40000026,   // Disable the ClientSide caching on SM
    REST_NOCONTROLPANEL             = 0x40000027,   // Remove the Control Panel only from SM|Settings
    REST_ENUMWORKGROUP              = 0x40000028,   // Enumerate workgroup in root of nethood
    REST_ARP_NOARP                  = 0x40000029,   // ARP: Don't Allow ARP to come up at all
    REST_ARP_NOREMOVEPAGE           = 0x4000002A,   // ARP: Don't allow Remove page
    REST_ARP_NOADDPAGE              = 0x4000002B,   // ARP: Don't allow Add page
    REST_ARP_NOWINSETUPPAGE         = 0x4000002C,   // ARP: Don't allow opt components page
    REST_GREYMSIADS                 = 0x4000002D,    // SM: Allow the greying of Darwin Ads in SM
    REST_NOCHANGEMAPPEDDRIVELABEL   = 0x4000002E,   // Don't enable the UI which allows users to rename mapped drive labels
    REST_NOCHANGEMAPPEDDRIVECOMMENT = 0x4000002F,   // Don't enable the UI which allows users to change mapped drive comments
    REST_MaxRecentDocs              = 0x40000030,
    REST_NONETWORKCONNECTIONS       = 0x40000031,   // No Start Menu | Settings |Network Connections
    REST_FORCESTARTMENULOGOFF       = 0x40000032,   // Force logoff on the Start Menu
    REST_NOWEBVIEW                  = 0x40000033,   // Disable Web View
    REST_NOCUSTOMIZETHISFOLDER      = 0x40000034,   // Disable Customize This Folder
    REST_NOENCRYPTION               = 0x40000035,   // Don't allow file encryption
//  Do NOT use me                     0x40000036,
    REST_DONTSHOWSUPERHIDDEN        = 0x40000037,   // don't show super hidden files
    REST_NOSHELLSEARCHBUTTON        = 0x40000038,
    REST_NOHARDWARETAB              = 0x40000039,   // No Hardware tab on Drives or in control panel
    REST_NORUNASINSTALLPROMPT       = 0x4000003A,   // Don't bring up "Run As" prompt for install programs
    REST_PROMPTRUNASINSTALLNETPATH  = 0x4000003B,   // Force the  "Run As" prompt for install programs on unc/network shares
    REST_NOMANAGEMYCOMPUTERVERB     = 0x4000003C,   // No Manage verb on My Computer
//  Do NOT use me                     0x4000003D,
    REST_DISALLOWRUN                = 0x4000003E,   // don't allow certain apps to be run
    REST_NOWELCOMESCREEN            = 0x4000003F,   // don't allow the welcome screen to be displayed.
    REST_RESTRICTCPL                = 0x40000040,   // only allow certain cpls to be run
    REST_DISALLOWCPL                = 0x40000041,   // don't allow certain cpls to be run
    REST_NOSMBALLOONTIP             = 0x40000042,   // No Start Menu Balloon Tip
    REST_NOSMHELP                   = 0x40000043,   // No Help on the Start Menu
    REST_NOWINKEYS                  = 0x40000044,   // No Windows-X Hot keys
    REST_NOENCRYPTONMOVE            = 0x40000045,   // Don't automatically try to encrypt files that are moved to encryped directories
    REST_NOLOCALMACHINERUN          = 0x40000046,   // ignore HKLM\sw\ms\win\cv\Run and all of it's sub keys
    REST_NOCURRENTUSERRUN           = 0x40000047,   // ignore HKCU\sw\ms\win\cv\Run and all of it's sub keys
    REST_NOLOCALMACHINERUNONCE      = 0x40000048,   // ignore HKLM\sw\ms\win\cv\RunOnce and all of it's sub keys
    REST_NOCURRENTUSERRUNONCE       = 0x40000049,   // ignore HKCU\sw\ms\win\cv\RunOnce and all of it's sub keys
    REST_FORCEACTIVEDESKTOPON       = 0x4000004A,   // Force ActiveDesktop to be turned ON all the time.
//  Do NOT use me                     0x4000004B,
    REST_NOVIEWONDRIVE              = 0x4000004C,   // disallows CreateViewObject() on specified drives (CFSFolder only)
#if (NTDDI_VERSION >= NTDDI_WINXP) || defined(IE_BACKCOMPAT_VERSION)
    REST_NONETCRAWL                 = 0x4000004D,   // disables the crawling of the WNet namespace.
    REST_NOSHAREDDOCUMENTS          = 0x4000004E,   // don't auto share the Shared Documents/create link
#endif  // NTDDI_WINXP
    REST_NOSMMYDOCS                 = 0x4000004F,   // Don't show the My Documents item on the Start Menu.
#if (NTDDI_VERSION >= NTDDI_WINXP)
    REST_NOSMMYPICS                 = 0x40000050,   // Don't show the My Pictures item on the Start Menu
    REST_ALLOWBITBUCKDRIVES         = 0x40000051,   // Bit mask indicating which which drives have bit bucket support
    REST_NONLEGACYSHELLMODE         = 0x40000052,   // new consumer shell modes
    REST_NOCONTROLPANELBARRICADE    = 0x40000053,   // The webview barricade in Control Panel
    REST_NOSTARTPAGE                = 0x40000054,   // Whistler Start Page on desktop.
    REST_NOAUTOTRAYNOTIFY           = 0x40000055,   // Whistler auto-tray notify feature
    REST_NOTASKGROUPING             = 0x40000056,   // Whistler taskbar button grouping feature
    REST_NOCDBURNING                = 0x40000057,   // whistler cd burning feature
#endif  // NTDDI_WINXP
#if (NTDDI_VERSION >= NTDDI_WIN2KSP3)
    REST_MYCOMPNOPROP               = 0x40000058,   // disables Properties on My Computer's context menu
    REST_MYDOCSNOPROP               = 0x40000059,   // disables Properties on My Documents' context menu
#endif  // NTDDI_WIN2KSP3
#if (NTDDI_VERSION >= NTDDI_WINXP)
    REST_NOSTARTPANEL               = 0x4000005A,   // Windows start panel (New start menu) for Whistler.
    REST_NODISPLAYAPPEARANCEPAGE    = 0x4000005B,   // disable Themes and Appearance tabs in the Display Control Panel.
    REST_NOTHEMESTAB                = 0x4000005C,   // disable the Themes tab in the Display Control Panel.
    REST_NOVISUALSTYLECHOICE        = 0x4000005D,   // disable the visual style drop down in the Appearance tab of the Display Control Panel.
    REST_NOSIZECHOICE               = 0x4000005E,   // disable the size drop down in the Appearance tab of the Display Control Panel.
    REST_NOCOLORCHOICE              = 0x4000005F,   // disable the color drop down in the Appearance tab of the Display Control Panel.
    REST_SETVISUALSTYLE             = 0x40000060,   // Load the specified file as the visual style.
#endif  // NTDDI_WINXP
#if (NTDDI_VERSION >= NTDDI_WIN2KSP3)
    REST_STARTRUNNOHOMEPATH         = 0x40000061,   // dont use the %HOMEPATH% env var for the Start-Run dialog
#endif  // NTDDI_WIN2KSP3
#if (NTDDI_VERSION >= NTDDI_WINXP)
    REST_NOUSERNAMEINSTARTPANEL     = 0x40000062,   // don't show the username is the startpanel.
    REST_NOMYCOMPUTERICON           = 0x40000063,   // don't show my computer anywhere, hide its contents
    REST_NOSMNETWORKPLACES          = 0x40000064,   // don't show network places in startpanel.
    REST_NOSMPINNEDLIST             = 0x40000065,   // don't show the pinned list in startpanel.
    REST_NOSMMYMUSIC                = 0x40000066,   // don't show MyMusic folder in startpanel
    REST_NOSMEJECTPC                = 0x40000067,   // don't show "Undoc PC" command in startmenu
    REST_NOSMMOREPROGRAMS           = 0x40000068,   // don't show "More Programs" button in StartPanel.
    REST_NOSMMFUPROGRAMS            = 0x40000069,   // don't show the MFU programs list in StartPanel.
    REST_NOTRAYITEMSDISPLAY         = 0x4000006A,   // disables the display of the system tray
    REST_NOTOOLBARSONTASKBAR        = 0x4000006B,   // disables toolbar display on the taskbar
#endif  // NTDDI_WINXP
#if (NTDDI_VERSION >= NTDDI_WIN2KSP3)
    REST_NOSMCONFIGUREPROGRAMS      = 0x4000006F,   // No Configure Programs on Settings Menu
#endif  // NTDDI_WIN2KSP3
#if (NTDDI_VERSION >= NTDDI_WINXP)
    REST_HIDECLOCK                  = 0x40000070,   // don't show the clock
    REST_NOLOWDISKSPACECHECKS       = 0x40000071,   // disable the low disk space checking
#endif  // NTDDI_WINXP
#if (NTDDI_VERSION >= NTDDI_WIN2KSP4)
    REST_NOENTIRENETWORK            = 0x40000072,   // removes the "Entire Network" link (i.e. from "My Network Places")
#endif  // NTDDI_WIN2KSP4
#if (NTDDI_VERSION >= NTDDI_WINXP)
    REST_NODESKTOPCLEANUP           = 0x40000073,   // disable the desktop cleanup wizard
    REST_BITBUCKNUKEONDELETE        = 0x40000074,   // disables recycling of files
    REST_BITBUCKCONFIRMDELETE       = 0x40000075,   // always show the delete confirmation dialog when deleting files
    REST_BITBUCKNOPROP              = 0x40000076,   // disables Properties on Recycle Bin's context menu
    REST_NODISPBACKGROUND           = 0x40000077,   // disables the Desktop tab in the Display CPL
    REST_NODISPSCREENSAVEPG         = 0x40000078,   // disables the Screen Saver tab in the Display CPL
    REST_NODISPSETTINGSPG           = 0x40000079,   // disables the Settings tab in the Display CPL
    REST_NODISPSCREENSAVEPREVIEW    = 0x4000007A,   // disables the screen saver on the Screen Saver tab in the Display CPL
    REST_NODISPLAYCPL               = 0x4000007B,   // disables the Display CPL
    REST_HIDERUNASVERB              = 0x4000007C,   // hides the "Run As..." context menu item
    REST_NOTHUMBNAILCACHE           = 0x4000007D,   // disables use of the thumbnail cache
#endif  // NTDDI_WINXP
#if (NTDDI_VERSION >= NTDDI_WINXPSP1) || defined(IE_BACKCOMPAT_VERSION)
    REST_NOSTRCMPLOGICAL            = 0x4000007E,   // dont use StrCmpLogical() instead use default CompareString()
    REST_NOPUBLISHWIZARD            = 0x4000007F,   // disables publishing wizard (WPW)
    REST_NOONLINEPRINTSWIZARD       = 0x40000080,   // disables online prints wizard (OPW)
    REST_NOWEBSERVICES              = 0x40000081,   // disables the web specified services for both OPW and WPW
#endif  // NTDDI_WINXPSP1
#if (NTDDI_VERSION >= NTDDI_WIN2KSP3)
    REST_ALLOWUNHASHEDWEBVIEW       = 0x40000082,   // allow the user to be promted to accept web view templates that don't already have an md5 hash in the registry
#endif  // NTDDI_WIN2KSP3
    REST_ALLOWLEGACYWEBVIEW         = 0x40000083,   // allow legacy webview template to be shown.
#if (NTDDI_VERSION >= NTDDI_WIN2KSP3)
    REST_REVERTWEBVIEWSECURITY      = 0x40000084,   // disable added webview security measures (revert to w2k functionality).
#endif  // NTDDI_WIN2KSP3
#if (NTDDI_VERSION >= NTDDI_WIN2KSP4)
    REST_INHERITCONSOLEHANDLES      = 0x40000086,   // ShellExec() will check for the current process and target process being console processes to inherit handles
#endif  // NTDDI_WIN2KSP4
#if (NTDDI_VERSION >= NTDDI_WINXPSP2 && NTDDI_VERSION < NTDDI_VISTA)
    REST_SORTMAXITEMCOUNT           = 0x40000087,   // Do not sort views with more items than this key. Useful for viewing big amount of files in one folder.
#endif
#if (NTDDI_VERSION >= NTDDI_WINXPSP2)
    REST_NOREMOTERECURSIVEEVENTS    = 0x40000089,   // Dont register network change events recursively to avoid network traffic
#endif  // NTDDI_WINXPSP2
#if (NTDDI_VERSION >= NTDDI_WINXPSP2)
    REST_NOREMOTECHANGENOTIFY       = 0x40000091,   // Do not notify for remote changy notifies
#if (NTDDI_VERSION < NTDDI_VISTA)
    REST_NOSIMPLENETIDLIST          = 0x40000092,   // No simple network IDLists
#endif
    REST_NOENUMENTIRENETWORK        = 0x40000093,   // Don't enumerate entire network if we happen to get to it (in conjunction with REST_NOENTIRENETWORK)
#if (NTDDI_VERSION < NTDDI_VISTA)
    REST_NODETAILSTHUMBNAILONNETWORK= 0x40000094,   // Disable Thumbnail for Network files in DUI Details pane
#endif
    REST_NOINTERNETOPENWITH         = 0x40000095,   // dont allow looking on the internet for file associations
#endif  // NTDDI_WINXPSP2
#if (NTDDI_VERSION >= NTDDI_WINXPSP2)
    REST_DONTRETRYBADNETNAME        = 0x4000009B,   // In Network Places: if provider returns ERROR_BAD_NET_NAME, give up
    REST_ALLOWFILECLSIDJUNCTIONS    = 0x4000009C,   // re-enable legacy support for file.{guid} junctions in FileSystem Folder
    REST_NOUPNPINSTALL              = 0x4000009D,   // disable "install UPnP" task in My Net Places
#endif  // NTDDI_WINXPSP2
    REST_ARP_DONTGROUPPATCHES       = 0x400000AC,   //List individual patches in Add/Remove Programs
    REST_ARP_NOCHOOSEPROGRAMSPAGE   = 0x400000AD,   //Choose programs page

    REST_NODISCONNECT               = 0x41000001,   // No Disconnect option in Start menu
    REST_NOSECURITY                 = 0x41000002,   // No Security option in start menu
    REST_NOFILEASSOCIATE            = 0x41000003,   // Do not allow user to change file association
#if (NTDDI_VERSION >= NTDDI_WINXPSP2)
    REST_ALLOWCOMMENTTOGGLE         = 0x41000004,   // Allow the user to toggle the positions of the Comment and the Computer Name
#if (NTDDI_VERSION < NTDDI_VISTA)
    REST_USEDESKTOPINICACHE         = 0x41000005,   // Cache desktop.ini entries from network folders
#endif  // NTDDI_VISTA
#endif  // NTDDI_WINXPSP2
} RESTRICTIONS;
SHSTDAPI_(IStream *) OpenRegStream(HKEY hkey, LPCWSTR pszSubkey, LPCWSTR pszValue, DWORD grfMode);
SHSTDAPI_(BOOL) SHFindFiles(PCIDLIST_ABSOLUTE pidlFolder, PCIDLIST_ABSOLUTE pidlSaveFile);
SHSTDAPI_(void) PathGetShortPath(__inout_ecount(MAX_PATH) LPWSTR pszLongPath);
SHSTDAPI_(BOOL) PathYetAnotherMakeUniqueName(__out_ecount(MAX_PATH) LPWSTR  pszUniqueName, LPCWSTR pszPath, LPCWSTR pszShort, LPCWSTR pszFileSpec);
SHSTDAPI_(BOOL) Win32DeleteFile(LPCWSTR pszPath);
#if (NTDDI_VERSION < NTDDI_VISTA)
//
// Path processing function
//
#define PPCF_ADDQUOTES               0x00000001        // return a quoted name if required
#define PPCF_ADDARGUMENTS            0x00000003        // appends arguments (and wraps in quotes if required)
#define PPCF_NODIRECTORIES           0x00000010        // don't match to directories
#define PPCF_FORCEQUALIFY            0x00000040        // qualify even non-relative names
#define PPCF_LONGESTPOSSIBLE         0x00000080        // always find the longest possible name

SHSTDAPI_(LONG) PathProcessCommand(LPCWSTR lpSrc, LPWSTR lpDest, int iMax, DWORD dwFlags);
#endif
SHSTDAPI_(DWORD) SHRestricted(RESTRICTIONS rest);
SHSTDAPI_(BOOL) SignalFileOpen(PCIDLIST_ABSOLUTE pidl);
SHSTDAPI_(PIDLIST_ABSOLUTE) SHSimpleIDListFromPath(LPCWSTR pszPath);

#if (NTDDI_VERSION >= NTDDI_VISTA)
SHSTDAPI AssocGetDetailsOfPropKey(__in IShellFolder *psf, __in PCUITEMID_CHILD pidl, __in const PROPERTYKEY *pkey, __out VARIANT *pv, __out_opt BOOL *pfFoundPropKey);
#endif

#if (NTDDI_VERSION < NTDDI_VISTA)
SHSTDAPI SHLoadOLE(LPARAM lParam);
#endif

// both ANSI and UNICODE
SHSTDAPI SHStartNetConnectionDialogA(HWND hwnd, __in_opt LPCSTR pszRemoteName, DWORD dwType);
// both ANSI and UNICODE
SHSTDAPI SHStartNetConnectionDialogW(HWND hwnd, __in_opt LPCWSTR pszRemoteName, DWORD dwType);
#ifdef UNICODE
#define SHStartNetConnectionDialog  SHStartNetConnectionDialogW
#else
#define SHStartNetConnectionDialog  SHStartNetConnectionDialogA
#endif // !UNICODE
SHSTDAPI SHDefExtractIconA(LPCSTR pszIconFile, int iIndex, UINT uFlags,
                           __out_opt HICON *phiconLarge, __out_opt HICON *phiconSmall, UINT nIconSize);
SHSTDAPI SHDefExtractIconW(LPCWSTR pszIconFile, int iIndex, UINT uFlags,
                           __out_opt HICON *phiconLarge, __out_opt HICON *phiconSmall, UINT nIconSize);
#ifdef UNICODE
#define SHDefExtractIcon  SHDefExtractIconW
#else
#define SHDefExtractIcon  SHDefExtractIconA
#endif // !UNICODE

// Elevation

// OpenAsInfo flags
enum tagOPEN_AS_INFO_FLAGS {
    OAIF_ALLOW_REGISTRATION = 0x00000001,     // enable the "always use this file" checkbox (NOTE if you don't pass this, it will be disabled)
    OAIF_REGISTER_EXT       = 0x00000002,     // do the registration after the user hits "ok"
    OAIF_EXEC               = 0x00000004,     // execute file after registering
    OAIF_FORCE_REGISTRATION = 0x00000008,     // force the "always use this file" checkbox to be checked (normally, you won't use the OAIF_ALLOW_REGISTRATION when you pass this)
#if (NTDDI_VERSION >= NTDDI_VISTA)
    OAIF_HIDE_REGISTRATION  = 0x00000020,     // hide the "always use this file" checkbox
    OAIF_URL_PROTOCOL       = 0x00000040,     // the "extension" passed is actually a protocol, and open with should show apps registered as capable of handling that protocol
#endif
};
typedef int OPEN_AS_INFO_FLAGS;


#include <pshpack8.h>

typedef struct _openasinfo
{
    LPCTSTR pcszFile;               // [in] file name, or protocol name if
                                    //      OAIF_URL_PROTOCOL is set.
    LPCTSTR pcszClass;              // [in] file class description. NULL means
                                    //      use pcszFile's extension. ignored
                                    //      if OAIF_URL_PROTOCOL is set.
    OPEN_AS_INFO_FLAGS oaifInFlags; // [in] input flags from OPEN_AS_INFO_FLAGS enumeration
} OPENASINFO, * POPENASINFO;

#include <poppack.h>        /* Return to byte packing */

SHSTDAPI SHOpenWithDialog(__in HWND hwndParent, __in const OPENASINFO* poainfo);

SHSTDAPI_(BOOL) Shell_GetImageLists(__out_opt HIMAGELIST *phiml, __out_opt HIMAGELIST *phimlSmall);
SHSTDAPI_(int)  Shell_GetCachedImageIndex(LPCWSTR pwszIconPath, int iIconIndex, UINT uIconFlags);
SHSTDAPI_(int)  Shell_GetCachedImageIndexA(LPCSTR pszIconPath, int iIconIndex, UINT uIconFlags);
SHSTDAPI_(int)  Shell_GetCachedImageIndexW(LPCWSTR pszIconPath, int iIconIndex, UINT uIconFlags);
#ifdef UNICODE
#define Shell_GetCachedImageIndex  Shell_GetCachedImageIndexW
#else
#define Shell_GetCachedImageIndex  Shell_GetCachedImageIndexA
#endif // !UNICODE

//
// IDocViewSite
//
#undef  INTERFACE
#define INTERFACE  IDocViewSite
DECLARE_INTERFACE_IID_(IDocViewSite, IUnknown, "87D605E0-C511-11CF-89A9-00A0C9054129")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IDocViewSite methods ***
    STDMETHOD(OnSetTitle) (THIS_ VARIANTARG *pvTitle) PURE;

} ;
#define VALIDATEUNC_CONNECT     0x0001          // connect a drive letter
#define VALIDATEUNC_NOUI        0x0002          // don't bring up UI
#define VALIDATEUNC_PRINT       0x0004          // validate as print share instead of disk share
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define VALIDATEUNC_PERSIST     0x0008          // the connection should be made persistent
#define VALIDATEUNC_VALID       0x000F          // valid flags
#else
#define VALIDATEUNC_VALID       0x0007          // valid flags
#endif

SHSTDAPI_(BOOL) SHValidateUNC(HWND hwndOwner, __inout LPWSTR pszFile, UINT fConnect);
#define OPENPROPS_NONE          0x0000
#define OPENPROPS_INHIBITPIF    0x8000
#define GETPROPS_NONE           0x0000
#define SETPROPS_NONE           0x0000
#define CLOSEPROPS_NONE         0x0000
#define CLOSEPROPS_DISCARD      0x0001

#define PIFNAMESIZE     30
#define PIFSTARTLOCSIZE 63
#define PIFDEFPATHSIZE  64
#define PIFPARAMSSIZE   64
#define PIFSHPROGSIZE   64
#define PIFSHDATASIZE   64
#define PIFDEFFILESIZE  80
#define PIFMAXFILEPATH  260

typedef struct PROPPRG {                    /* prg */
    WORD    flPrg;                          // see PRG_ flags
    WORD    flPrgInit;                      // see PRGINIT_ flags
    CHAR    achTitle[PIFNAMESIZE];          // name[30]
    CHAR    achCmdLine[PIFSTARTLOCSIZE+PIFPARAMSSIZE+1];// startfile[63] + params[64]
    CHAR    achWorkDir[PIFDEFPATHSIZE];     // defpath[64]
    WORD    wHotKey;                        // PfHotKeyScan thru PfHotKeyVal
    CHAR    achIconFile[PIFDEFFILESIZE];    // name of file containing icon
    WORD    wIconIndex;                     // index of icon within file
    DWORD   dwEnhModeFlags;                 // reserved enh-mode flags
    DWORD   dwRealModeFlags;                // real-mode flags (see RMOPT_*)
    CHAR    achOtherFile[PIFDEFFILESIZE];   // name of "other" file in directory
    CHAR    achPIFFile[PIFMAXFILEPATH];     // name of PIF file
} PROPPRG;
typedef UNALIGNED PROPPRG *PPROPPRG;
typedef UNALIGNED PROPPRG FAR *LPPROPPRG;
typedef const UNALIGNED PROPPRG FAR *LPCPROPPRG;

SHSTDAPI_(HANDLE) PifMgr_OpenProperties(LPCWSTR pszApp, __in_opt LPCWSTR pszPIF, UINT hInf, UINT flOpt);
SHSTDAPI_(int)    PifMgr_GetProperties(__in_opt HANDLE hProps, __in_opt LPCSTR pszGroup, __out_bcount_opt(cbProps) void *lpProps, int cbProps, UINT flOpt);
SHSTDAPI_(int)    PifMgr_SetProperties(__in_opt HANDLE hProps, __in_opt LPCSTR pszGroup, __in_bcount(cbProps) const void *lpProps, int cbProps, UINT flOpt);
SHSTDAPI_(HANDLE) PifMgr_CloseProperties(__in_opt HANDLE hProps, UINT flOpt);

SHSTDAPI_(void) SHSetInstanceExplorer(IUnknown *punk);
SHSTDAPI_(BOOL) IsUserAnAdmin(void);

#undef  INTERFACE
#define INTERFACE   IInitializeObject

DECLARE_INTERFACE_IID_(IInitializeObject, IUnknown, "4622AD16-FF23-11d0-8D34-00A0C90F2719")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IInitializeObject methods
    STDMETHOD(Initialize)(THIS) PURE;
};


enum
{
    BMICON_LARGE = 0,
    BMICON_SMALL
};

#undef  INTERFACE
#define INTERFACE   IBanneredBar

DECLARE_INTERFACE_IID_(IBanneredBar, IUnknown, "596A9A94-013E-11d1-8D34-00A0C90F2719")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IBanneredBar methods ***
    STDMETHOD(SetIconSize)(THIS_ DWORD iIcon) PURE;
    STDMETHOD(GetIconSize)(THIS_ DWORD* piIcon) PURE;
    STDMETHOD(SetBitmap)(THIS_ HBITMAP hBitmap) PURE;
    STDMETHOD(GetBitmap)(THIS_ HBITMAP* phBitmap) PURE;

};

SHSTDAPI_(LRESULT) SHShellFolderView_Message(HWND hwndMain, UINT uMsg, LPARAM lParam);

//
// Callback interface for the IShellView object returned from SHCreateShellFolderView.

//
#undef  INTERFACE
#define INTERFACE   IShellFolderViewCB

DECLARE_INTERFACE_IID_(IShellFolderViewCB, IUnknown, "2047E320-F2A9-11CE-AE65-08002B2E1262")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellFolderViewCB methods ***
    STDMETHOD(MessageSFVCB)(THIS_ UINT uMsg, WPARAM wParam, LPARAM lParam) PURE;
};


#include <pshpack8.h>

#define QCMINFO_PLACE_BEFORE    0
#define QCMINFO_PLACE_AFTER     1
typedef struct _QCMINFO_IDMAP_PLACEMENT
{
    UINT id;
    UINT fFlags;
} QCMINFO_IDMAP_PLACEMENT;

typedef struct _QCMINFO_IDMAP
{
    UINT                    nMaxIds;
    QCMINFO_IDMAP_PLACEMENT pIdList[1];
} QCMINFO_IDMAP;

typedef struct _QCMINFO
{
    HMENU       hmenu;          // in
    UINT        indexMenu;      // in
    UINT        idCmdFirst;     // in/out
    UINT        idCmdLast;      // in
    QCMINFO_IDMAP const*  pIdMap; // in / unused
} QCMINFO;
typedef QCMINFO * LPQCMINFO;

// TBINFO flags
#define TBIF_APPEND     0
#define TBIF_PREPEND    1
#define TBIF_REPLACE    2
#define TBIF_DEFAULT      0x00000000
#define TBIF_INTERNETBAR  0x00010000
#define TBIF_STANDARDTOOLBAR   0x00020000
#define TBIF_NOTOOLBAR  0x00030000

typedef struct _TBINFO
{
    UINT        cbuttons;       // out
    UINT        uFlags;         // out (one of TBIF_ flags)
} TBINFO;
typedef TBINFO * LPTBINFO;


typedef struct _DETAILSINFO
{
    PCUITEMID_CHILD pidl;
    int fmt;
    int cxChar;
    STRRET str;
    int iImage;
} DETAILSINFO;
typedef DETAILSINFO *PDETAILSINFO;

typedef struct _SFVM_PROPPAGE_DATA
{
    DWORD                dwReserved;
    LPFNADDPROPSHEETPAGE pfn;
    LPARAM               lParam;
} SFVM_PROPPAGE_DATA;

typedef struct _SFVM_HELPTOPIC_DATA
{
    WCHAR wszHelpFile[MAX_PATH];
    WCHAR wszHelpTopic[MAX_PATH];
} SFVM_HELPTOPIC_DATA;

//                                 uMsg    wParam             lParam
#define SFVM_MERGEMENU             1    // -                  LPQCMINFO
#define SFVM_INVOKECOMMAND         2    // idCmd              -
#define SFVM_GETHELPTEXT           3    // idCmd,cchMax       pszText
#define SFVM_GETTOOLTIPTEXT        4    // idCmd,cchMax       pszText
#define SFVM_GETBUTTONINFO         5    // -                  LPTBINFO
#define SFVM_GETBUTTONS            6    // idCmdFirst,cbtnMax LPTBBUTTON
#define SFVM_INITMENUPOPUP         7    // idCmdFirst,nIndex  hmenu
#define SFVM_FSNOTIFY             14    // LPCITEMIDLIST*     lEvent
#define SFVM_WINDOWCREATED        15    // hwnd               -
#define SFVM_GETDETAILSOF         23    // iColumn            DETAILSINFO*
#define SFVM_COLUMNCLICK          24    // iColumn            -
#define SFVM_QUERYFSNOTIFY        25    // -                  SHChangeNotifyEntry *
#define SFVM_DEFITEMCOUNT         26    // -                  UINT*
#define SFVM_DEFVIEWMODE          27    // -                  FOLDERVIEWMODE*
#define SFVM_UNMERGEMENU          28    // -                  hmenu
#define SFVM_UPDATESTATUSBAR      31    // fInitialize        -
#define SFVM_BACKGROUNDENUM       32    // -                  -
#define SFVM_DIDDRAGDROP          36    // dwEffect           IDataObject *
#define SFVM_SETISFV              39    // -                  IShellFolderView*
#define SFVM_THISIDLIST           41    // -                  LPITMIDLIST*
#define SFVM_ADDPROPERTYPAGES     47    // -                  SFVM_PROPPAGE_DATA *
#define SFVM_BACKGROUNDENUMDONE   48    // -                  -
#define SFVM_GETNOTIFY            49    // LPITEMIDLIST*      LONG*
// Note: SFVM_QUERYSTANDARDVIEWS NOT USED: must use SFVM_GETVIEWDATA instead
#define SFVM_GETSORTDEFAULTS      53    // iDirection         iParamSort
#define SFVM_SIZE                 57    // -                  -
#define SFVM_GETZONE              58    // -                  DWORD*
#define SFVM_GETPANE              59    // Pane ID            DWORD*
#define SFVM_GETHELPTOPIC         63    // -                  SFVM_HELPTOPIC_DATA *
#define SFVM_GETANIMATION         68    // HINSTANCE *        WCHAR *

// IShellFolderView
//
// Deprecated: use IFolderView and IFolderView2 instead.
//
// IShellFolderView is supported by the IShellView object returned from SHCreateShellFolderView.
//
// Warnings:
//  - Some methods on this interface do not follow standard COM rules.
//  - Some methods can be used to configure the IShellView or cause it to behave incorrectly.
//  - Few of these methods have parameter or range validation, so callers can cause the IShellView to fault.

typedef struct _ITEMSPACING
{
    int cxSmall;
    int cySmall;
    int cxLarge;
    int cyLarge;
} ITEMSPACING;

// defines for IShellFolderView::SetObjectCount
#define SFVSOC_INVALIDATE_ALL   0x00000001  // Assumed to reset only what is neccessary...
#define SFVSOC_NOSCROLL         LVSICF_NOSCROLL

// defines for IShellFolderView::SelectItems()
#define SFVS_SELECT_NONE        0x0 // unselect all
#define SFVS_SELECT_ALLITEMS    0x1 // select all
#define SFVS_SELECT_INVERT      0x2 // Inver the selection

#undef  INTERFACE
#define INTERFACE   IShellFolderView

DECLARE_INTERFACE_IID_(IShellFolderView, IUnknown, "37A378C0-F82D-11CE-AE65-08002B2E1262")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellFolderView methods ***
    STDMETHOD(Rearrange) (THIS_ LPARAM lParamSort) PURE; // use IFolderView2::SetSortColumns
    STDMETHOD(GetArrangeParam) (THIS_ LPARAM *plParamSort) PURE; // use IFolderView2::GetSortColumns
    STDMETHOD(ArrangeGrid) (THIS) PURE; // select Arrange by Grid
    STDMETHOD(AutoArrange) (THIS) PURE; // select Auto Arrange
    STDMETHOD(GetAutoArrange) (THIS) PURE; // use IFolderView::GetAutoArrange
    STDMETHOD(AddObject) (THIS_ PUITEMID_CHILD pidl, UINT *puItem) PURE; // items added here may disappear (the data source is the final arbiter of which items are available to the view)
    STDMETHOD(GetObject) (THIS_ PITEMID_CHILD *ppidl, UINT uItem) PURE; // use IFolderView::Item
    STDMETHOD(RemoveObject) (THIS_ PUITEMID_CHILD pidl, UINT *puItem) PURE; // items removed here may reappear (the data source is the final arbiter of which items are available to the view)
    STDMETHOD(GetObjectCount) (THIS_ UINT *puCount) PURE; // use IFolderView::ItemCount
    STDMETHOD(SetObjectCount) (THIS_ UINT uCount, UINT dwFlags) PURE; // not implemented on Vista.  Sends LVM_SETITEMCOUNT with WPARAM=uCount and LPARAM=dwFlags to listview on XP.
    STDMETHOD(UpdateObject) (THIS_ PUITEMID_CHILD pidlOld, PUITEMID_CHILD pidlNew, UINT *puItem) PURE; // swaps ITEMID_CHILDs, returning new index.  Changes may be discarded (the data source is the final arbiter of which items are available to the view)
    STDMETHOD(RefreshObject) (THIS_ PUITEMID_CHILD pidl, UINT *puItem) PURE; // tickles the listview to re-draw the item
    STDMETHOD(SetRedraw) (THIS_ BOOL bRedraw) PURE; // sends WM_SETREDRAW to the listview
    STDMETHOD(GetSelectedCount) (THIS_ UINT *puSelected) PURE; // use IFolderView2::GetSelection
    // NOTE: GetSelectedObjects hands out const pointers to internal ITEMID_CHILD structures. The caller is expected to act on them immediately (and not cache them).  LocalFree the array, but not the items it contains.
    STDMETHOD(GetSelectedObjects) (THIS_ PCUITEMID_CHILD **pppidl, UINT *puItems) PURE; // use IFolderView2::GetSelection.
    STDMETHOD(IsDropOnSource) (THIS_ IDropTarget *pDropTarget) PURE; // use IFolderView2::IsMoveInSameFolder
    STDMETHOD(GetDragPoint) (THIS_ POINT *ppt) PURE; // returns point corresponding to drag-and-drop operation
    STDMETHOD(GetDropPoint) (THIS_ POINT *ppt) PURE; // returns point corresponding to drag-and-drop operation
    STDMETHOD(MoveIcons) (THIS_ IDataObject *pDataObject) PURE; // not implemented
    STDMETHOD(SetItemPos) (THIS_ PCUITEMID_CHILD pidl, POINT *ppt) PURE; // use IFolderView::SelectAndPositionItems
    STDMETHOD(IsBkDropTarget) (THIS_ IDropTarget *pDropTarget) PURE; // returns S_OK if drag-and-drop is on the background, S_FALSE otherwise
    STDMETHOD(SetClipboard) (THIS_ BOOL bMove) PURE; // if bMove is TRUE, this attempts to cut (edit.cut, ctrl-x) the current selection.  bMove of FALSE is not supported.
    STDMETHOD(SetPoints) (THIS_ IDataObject *pDataObject) PURE; // copies points of current selection in to data object.  Call is not needed if drag operation was originated by the IShellView.
    STDMETHOD(GetItemSpacing) (THIS_ ITEMSPACING *pSpacing) PURE; // use IFolderView::GetSpacing instead.  GetItemSpacing returns the spacing for small and large view modes only, returning S_OK if the current view mode is is positionable, S_FALSE otherwise.
    STDMETHOD(SetCallback) (THIS_ IShellFolderViewCB* pNewCB, IShellFolderViewCB** ppOldCB) PURE; // replace the IShellFolderViewCB that the IShellView uses
    STDMETHOD(Select) ( THIS_  UINT dwFlags ) PURE; // SFVS_ select flags: select all, select none, invert selection
    STDMETHOD(QuerySupport) (THIS_ UINT * pdwSupport ) PURE; // does nothing, returns S_OK.
    STDMETHOD(SetAutomationObject)(THIS_ IDispatch* pdisp) PURE; // replaces the IShellView's internal automation object.
} ;

// SHCreateShellFolderView struct
typedef struct _SFV_CREATE
{
    UINT            cbSize;     // must be sizeof(SFV_CREATE)
    IShellFolder*   pshf;       // IShellFolder the IShellView will use
    IShellView*     psvOuter;   // optional: IShellView to pass to psfvcb
    IShellFolderViewCB* psfvcb; // No callback if NULL
} SFV_CREATE;

SHSTDAPI SHCreateShellFolderView(__in const SFV_CREATE* pcsfv, __deref_out IShellView ** ppsv);
typedef HRESULT (CALLBACK * LPFNDFMCALLBACK)(IShellFolder *psf, HWND hwnd,
                                             IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam);

SHSTDAPI CDefFolderMenu_Create2(__in PCIDLIST_ABSOLUTE pidlFolder, __in_opt HWND hwnd,
                                __in_opt UINT cidl, __in_ecount_opt(cidl) PCUITEMID_CHILD_ARRAY apidl,
                                __in IShellFolder *psf, __in LPFNDFMCALLBACK pfn,
                                __in UINT nKeys, __in_ecount(nKeys) const HKEY *ahkeys,
                                __deref_out IContextMenu **ppcm);
typedef struct {
    HWND hwnd;
    IContextMenuCB *pcmcb;          // optional: callback object
    PCIDLIST_ABSOLUTE pidlFolder;   // optional: IDList to folder of the items, computed from psf if NULL
    IShellFolder *psf;              // folder of the items
    UINT cidl;                      // # of items in apidl
    PCUITEMID_CHILD_ARRAY apidl;    // items operating on, used to get IDataObject and IAssociationArray
    IUnknown *punkAssociationInfo;  // optional: IQueryAssociations, specifies where to load extensions from, computed from apidl if NULL
    UINT cKeys;                     // # of items in aKeys, may be zero
    const HKEY *aKeys;              // optional: specifies where to load extensions from
} DEFCONTEXTMENU;

// creates object that implements IContextMenu/IContextMenu2/IContextMenu3, typically
// used in the implemetnation of ::GetUIObjectOf()

SHSTDAPI SHCreateDefaultContextMenu(__in const DEFCONTEXTMENU *pdcm, __in REFIID riid, __deref_out void **ppv);

SHSTDAPI_(BOOL) SHOpenPropSheetA(__in_opt LPCSTR pszCaption, __in_ecount_opt(cikeys) HKEY ahkeys[], UINT cikeys,
                                 __in_opt const CLSID * pclsidDefault, __in IDataObject *pdtobj,
                                 __in_opt IShellBrowser *psb, __in_opt LPCSTR pStartPage);
SHSTDAPI_(BOOL) SHOpenPropSheetW(__in_opt LPCWSTR pszCaption, __in_ecount_opt(cikeys) HKEY ahkeys[], UINT cikeys,
                                 __in_opt const CLSID * pclsidDefault, __in IDataObject *pdtobj,
                                 __in_opt IShellBrowser *psb, __in_opt LPCWSTR pStartPage);
#ifdef UNICODE
#define SHOpenPropSheet  SHOpenPropSheetW
#else
#define SHOpenPropSheet  SHOpenPropSheetA
#endif // !UNICODE

// structure for lParam of DFM_INFOKECOMMANDEX
typedef struct
{
    DWORD  cbSize;
    DWORD  fMask;   // CMIC_MASK_ values for the invoke
    LPARAM lParam;  // same as lParam of DFM_INFOKECOMMAND
    UINT idCmdFirst;
    UINT idDefMax;
    LPCMINVOKECOMMANDINFO pici; // the whole thing so you can re-invoke on a child
#if (NTDDI_VERSION >= NTDDI_VISTA)
    IUnknown *punkSite;         // site pointer for context menu handler
#endif
} DFMICS, *PDFMICS;

// Note on context menus ranges:
//  Standard Items // DFM_MERGECONTEXTMENU, context menu extensions, DFM_MERGECONTEXTMENU_TOP
//  Separator
//  View Items   // context menu extensions can get here
//  Separator
//  (defcm S_FALSE "default" items, if applicable)
//  Separator
//  Folder Items // context menu extensions can get here
//  Separator
//  Bottom Items // DFM_MERGECONTEXTMENU_BOTTOM

//                                  uMsg       wParam       lParam
#define DFM_MERGECONTEXTMENU         1      // uFlags       LPQCMINFO
#define DFM_INVOKECOMMAND            2      // idCmd        pszArgs
#define DFM_GETHELPTEXT              5      // idCmd,cchMax pszText -Ansi
#define DFM_WM_MEASUREITEM           6      // ---from the message---
#define DFM_WM_DRAWITEM              7      // ---from the message---
#define DFM_WM_INITMENUPOPUP         8      // ---from the message---
#define DFM_VALIDATECMD              9      // idCmd        0
#define DFM_MERGECONTEXTMENU_TOP     10     // uFlags       LPQCMINFO
#define DFM_GETHELPTEXTW             11     // idCmd,cchMax pszText -Unicode
#define DFM_INVOKECOMMANDEX          12     // idCmd        PDFMICS
#define DFM_MAPCOMMANDNAME           13     // idCmd *      pszCommandName
#define DFM_GETDEFSTATICID           14     // idCmd *      0
#define DFM_GETVERBW                 15     // idCmd,cchMax pszText -Unicode
#define DFM_GETVERBA                 16     // idCmd,cchMax pszText -Ansi
#define DFM_MERGECONTEXTMENU_BOTTOM  17     // uFlags       LPQCMINFO

// Commands from DFM_INVOKECOMMAND when strings are passed in
#define DFM_CMD_DELETE          ((UINT)-1)
#define DFM_CMD_MOVE            ((UINT)-2)
#define DFM_CMD_COPY            ((UINT)-3)
#define DFM_CMD_LINK            ((UINT)-4)
#define DFM_CMD_PROPERTIES      ((UINT)-5)
#define DFM_CMD_NEWFOLDER       ((UINT)-6)
#define DFM_CMD_PASTE           ((UINT)-7)
#define DFM_CMD_VIEWLIST        ((UINT)-8)
#define DFM_CMD_VIEWDETAILS     ((UINT)-9)
#define DFM_CMD_PASTELINK       ((UINT)-10)
#define DFM_CMD_PASTESPECIAL    ((UINT)-11)
#define DFM_CMD_MODALPROP       ((UINT)-12)
#define DFM_CMD_RENAME          ((UINT)-13)


typedef HRESULT (CALLBACK * LPFNVIEWCALLBACK)(IShellView *psvOuter,
                                                IShellFolder *psf,
                                                HWND hwndMain,
                                                UINT uMsg,
                                                WPARAM wParam,
                                                LPARAM lParam);

// SHCreateShellFolderViewEx struct
typedef struct _CSFV
{
    UINT              cbSize;
    IShellFolder *    pshf;
    IShellView *      psvOuter;
    PCIDLIST_ABSOLUTE pidl;
    LONG              lEvents;
    LPFNVIEWCALLBACK  pfnCallback;       // No callback if NULL
    FOLDERVIEWMODE    fvm;
} CSFV, * LPCSFV;


// Tell the FolderView to rearrange.  The lParam will be passed to
// IShellFolder::CompareIDs
#define SFVM_REARRANGE          0x00000001
#define ShellFolderView_ReArrange(_hwnd, _lparam) \
        (BOOL)SHShellFolderView_Message(_hwnd, SFVM_REARRANGE, _lparam)
// Add an OBJECT into the view
#define SFVM_ADDOBJECT         0x00000003
#define ShellFolderView_AddObject(_hwnd, _pidl) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_ADDOBJECT, (LPARAM)(_pidl))
// Remove an OBJECT into the view
#define SFVM_REMOVEOBJECT         0x00000006
#define ShellFolderView_RemoveObject(_hwnd, _pidl) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_REMOVEOBJECT, (LPARAM)(_pidl))

// updates an object by passing in pointer to two PIDLS, the first
// is the old pidl, the second one is the one with update information.
//
// _ppidl[1] must be a *copy* of a pidl, as control over the lifetime
// of the pidl belongs to the view after successful completion of
// this call.  (Unsuccessful completion (a -1 return) implies failure
// and the caller must free the memory.)  Win95 waits a while before
// freeing the pidl, IE4 frees the pidl immediately.
// IShellFolderView::UpdateObject does not suffer from this problem.
//
#define SFVM_UPDATEOBJECT         0x00000007
#define ShellFolderView_UpdateObject(_hwnd, _ppidl) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_UPDATEOBJECT, (LPARAM)(_ppidl))


// Returns an array of the selected IDS to the caller.
//     lparam is a pointer to receive the idlists into
//     return value is the count of items in the array.
#define SFVM_GETSELECTEDOBJECTS 0x00000009
#define ShellFolderView_GetSelectedObjects(_hwnd, ppidl) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_GETSELECTEDOBJECTS, (LPARAM)(ppidl))
typedef struct _SFV_SETITEMPOS
{
        PCUITEMID_CHILD pidl;
        POINT pt;
} SFV_SETITEMPOS;
typedef SFV_SETITEMPOS *LPSFV_SETITEMPOS;
typedef const SFV_SETITEMPOS *PCSFV_SETITEMPOS;

// Sets the position of an item in the viewer
//     lparam is a pointer to a SVF_SETITEMPOS
//     return value is unused
#define SFVM_SETITEMPOS         0x0000000e
#define ShellFolderView_SetItemPos(_hwnd, _pidl, _x, _y) \
{       SFV_SETITEMPOS _sip = {_pidl, {_x, _y}}; \
        SHShellFolderView_Message(_hwnd, SFVM_SETITEMPOS, (LPARAM)(LPSFV_SETITEMPOS)&_sip);}
//  Notifies a ShellView when one of its objects get put on the clipboard
//  as a result of a menu command.
//
//
//     lparam is the dwEffect (DROPEFFECT_MOVE, DROPEFFECT_COPY)
//     return value is void.
#define SFVM_SETCLIPBOARD       0x00000010
#define ShellFolderView_SetClipboard(_hwnd, _dwEffect) \
        (void)SHShellFolderView_Message(_hwnd, SFVM_SETCLIPBOARD, (LPARAM)(DWORD)(_dwEffect))
#define SFVM_SETPOINTS           0x00000017
#define ShellFolderView_SetPoints(_hwnd, _pdtobj) \
        (void)SHShellFolderView_Message(_hwnd, SFVM_SETPOINTS, (LPARAM)(_pdtobj))
#include <poppack.h>        /* Return to byte packing */
SHSTDAPI_(IContextMenu *) SHFind_InitMenuPopup(HMENU hmenu, HWND hwndOwner, UINT idCmdFirst, UINT idCmdLast);
SHSTDAPI SHCreateShellFolderViewEx(LPCSFV pcsfv, __out IShellView ** ppsv);

// Legacy PROPIDs for Internet Shortcuts (FMTID_Intshcut) to be used with
// IPropertySetStorage/IPropertyStorage.
//
// The known property ids and their variant types are:
//      PID_IS_URL          [VT_LPWSTR]   URL
//      PID_IS_NAME         [VT_LPWSTR]   Name of the internet shortcut
//      PID_IS_WORKINGDIR   [VT_LPWSTR]   Working directory for the shortcut
//      PID_IS_HOTKEY       [VT_UI2]      Hotkey for the shortcut
//      PID_IS_SHOWCMD      [VT_I4]       Show command for shortcut
//      PID_IS_ICONINDEX    [VT_I4]       Index into file that has icon
//      PID_IS_ICONFILE     [VT_LPWSTR]   File that has the icon
//      PID_IS_WHATSNEW     [VT_LPWSTR]   What's New text
//      PID_IS_AUTHOR       [VT_LPWSTR]   Author
//      PID_IS_DESCRIPTION  [VT_LPWSTR]   Description text of site
//      PID_IS_COMMENT      [VT_LPWSTR]   User annotated comment

#define PID_IS_URL           2
#define PID_IS_NAME          4
#define PID_IS_WORKINGDIR    5
#define PID_IS_HOTKEY        6
#define PID_IS_SHOWCMD       7
#define PID_IS_ICONINDEX     8
#define PID_IS_ICONFILE      9
#define PID_IS_WHATSNEW      10
#define PID_IS_AUTHOR        11
#define PID_IS_DESCRIPTION   12
#define PID_IS_COMMENT       13

// PROPIDs for Internet Sites (FMTID_InternetSite) to be used with
// IPropertySetStorage/IPropertyStorage
//
// The known property ids and their variant types are:
//      PID_INTSITE_WHATSNEW     [VT_LPWSTR]   What's New text
//      PID_INTSITE_AUTHOR       [VT_LPWSTR]   Author
//      PID_INTSITE_LASTVISIT    [VT_FILETIME] Time site was last visited
//      PID_INTSITE_LASTMOD      [VT_FILETIME] Time site was last modified
//      PID_INTSITE_VISITCOUNT   [VT_UI4]      Number of times user has visited
//      PID_INTSITE_DESCRIPTION  [VT_LPWSTR]   Description text of site
//      PID_INTSITE_COMMENT      [VT_LPWSTR]   User annotated comment
//      PID_INTSITE_RECURSE      [VT_UI4]      Levels to recurse (0-3)
//      PID_INTSITE_WATCH        [VT_UI4]      PIDISM_ flags
//      PID_INTSITE_SUBSCRIPTION [VT_UI8]      Subscription cookie
//      PID_INTSITE_URL          [VT_LPWSTR]   URL
//      PID_INTSITE_TITLE        [VT_LPWSTR]   Title
//      PID_INTSITE_CODEPAGE     [VT_UI4]      Codepage of the document
//      PID_INTSITE_TRACKING     [VT_UI4]      Tracking
//      PID_INTSITE_ICONINDEX    [VT_I4]       Retrieve the index to the icon
//      PID_INTSITE_ICONFILE     [VT_LPWSTR]   Retrieve the file containing the icon index.
//      PID_INTSITE_RAWURL       [VT_LPWSTR]   The raw, un-encoded, unicode url.

#define PID_INTSITE_WHATSNEW      2
#define PID_INTSITE_AUTHOR        3
#define PID_INTSITE_LASTVISIT     4
#define PID_INTSITE_LASTMOD       5
#define PID_INTSITE_VISITCOUNT    6
#define PID_INTSITE_DESCRIPTION   7
#define PID_INTSITE_COMMENT       8
#define PID_INTSITE_FLAGS         9
#define PID_INTSITE_CONTENTLEN    10
#define PID_INTSITE_CONTENTCODE   11
#define PID_INTSITE_RECURSE       12
#define PID_INTSITE_WATCH         13
#define PID_INTSITE_SUBSCRIPTION  14
#define PID_INTSITE_URL           15
#define PID_INTSITE_TITLE         16
#define PID_INTSITE_CODEPAGE      18
#define PID_INTSITE_TRACKING      19
#define PID_INTSITE_ICONINDEX     20
#define PID_INTSITE_ICONFILE      21

// Flags for PID_IS_FLAGS
#define PIDISF_RECENTLYCHANGED  0x00000001
#define PIDISF_CACHEDSTICKY     0x00000002
#define PIDISF_CACHEIMAGES      0x00000010
#define PIDISF_FOLLOWALLLINKS   0x00000020


// Values for PID_INTSITE_WATCH
#define PIDISM_GLOBAL           0       // Monitor based on global setting
#define PIDISM_WATCH            1       // User says watch
#define PIDISM_DONTWATCH        2       // User says don't watch


////////////////////////////////////////////////////////////////////
//
// The shell keeps track of some per-user state to handle display
// options that is of major interest to ISVs.
// The key one requested right now is "DoubleClickInWebView".

typedef struct {
    BOOL fShowAllObjects : 1;
    BOOL fShowExtensions : 1;
    BOOL fNoConfirmRecycle : 1;

    BOOL fShowSysFiles : 1;
    BOOL fShowCompColor : 1;
    BOOL fDoubleClickInWebView : 1;
    BOOL fDesktopHTML : 1;
    BOOL fWin95Classic : 1;
    BOOL fDontPrettyPath : 1;
    BOOL fShowAttribCol : 1; // No longer used, dead bit
    BOOL fMapNetDrvBtn : 1;
    BOOL fShowInfoTip : 1;
    BOOL fHideIcons : 1;
    BOOL fWebView : 1;
    BOOL fFilter : 1;
    BOOL fShowSuperHidden : 1;
    BOOL fNoNetCrawling : 1;

    DWORD dwWin95Unused; // Win95 only - no longer supported pszHiddenFileExts
    UINT  uWin95Unused; // Win95 only - no longer supported cbHiddenFileExts

    // Note: Not a typo!  This is a persisted structure so we cannot use LPARAM
    LONG   lParamSort;
    int    iSortDirection;

    UINT   version;

    // new for win2k. need notUsed var to calc the right size of ie4 struct
    // FIELD_OFFSET does not work on bit fields
    UINT uNotUsed; // feel free to rename and use
    BOOL fSepProcess: 1;

    // new for Whistler.
    BOOL fStartPanelOn: 1;       //Indicates if the Whistler StartPanel mode is ON or OFF.
    BOOL fShowStartPage: 1;      //Indicates if the Whistler StartPage on desktop is ON or OFF.

    // new for Longhorn
    BOOL fAutoCheckSelect: 1;
    BOOL fIconsOnly: 1;
    BOOL fShowTypeOverlay: 1;

    UINT fSpareFlags : 11;

} SHELLSTATEA, *LPSHELLSTATEA;

typedef struct {
    BOOL fShowAllObjects : 1;
    BOOL fShowExtensions : 1;
    BOOL fNoConfirmRecycle : 1;
    BOOL fShowSysFiles : 1;
    BOOL fShowCompColor : 1;
    BOOL fDoubleClickInWebView : 1;
    BOOL fDesktopHTML : 1;
    BOOL fWin95Classic : 1;
    BOOL fDontPrettyPath : 1;
    BOOL fShowAttribCol : 1;
    BOOL fMapNetDrvBtn : 1;
    BOOL fShowInfoTip : 1;
    BOOL fHideIcons : 1;
    BOOL fWebView : 1;
    BOOL fFilter : 1;
    BOOL fShowSuperHidden : 1;
    BOOL fNoNetCrawling : 1;

    DWORD dwWin95Unused; // Win95 only - no longer supported pszHiddenFileExts
    UINT  uWin95Unused; // Win95 only - no longer supported cbHiddenFileExts

    // Note: Not a typo!  This is a persisted structure so we cannot use LPARAM
    LONG   lParamSort;
    int    iSortDirection;
    UINT   version;

    // new for win2k. need notUsed var to calc the right size of ie4 struct
    // FIELD_OFFSET does not work on bit fields
    UINT uNotUsed; // feel free to rename and use
    BOOL fSepProcess: 1;

    // new for Whistler.
    BOOL fStartPanelOn: 1;       //Indicates if the Whistler StartPage mode is ON or OFF.
    BOOL fShowStartPage: 1;      //Indicates if the Whistler StartPage on desktop is ON or OFF.

    // new for Longhorn
    BOOL fAutoCheckSelect: 1;
    BOOL fIconsOnly: 1;
    BOOL fShowTypeOverlay: 1;

    // If you need a new flag, steal a bit from from fSpareFlags.
    UINT fSpareFlags : 11;

} SHELLSTATEW, *LPSHELLSTATEW;

#define SHELLSTATEVERSION_IE4   9
#define SHELLSTATEVERSION_WIN2K 10

#ifdef UNICODE
#define SHELLSTATE   SHELLSTATEW
#define LPSHELLSTATE LPSHELLSTATEW
#else
#define SHELLSTATE   SHELLSTATEA
#define LPSHELLSTATE LPSHELLSTATEA
#endif

#define SHELLSTATE_SIZE_WIN95 FIELD_OFFSET(SHELLSTATE,lParamSort)
#define SHELLSTATE_SIZE_NT4   FIELD_OFFSET(SHELLSTATE,version)
#define SHELLSTATE_SIZE_IE4   FIELD_OFFSET(SHELLSTATE,uNotUsed)
#define SHELLSTATE_SIZE_WIN2K sizeof(SHELLSTATE)

SHSTDAPI_(void) SHGetSetSettings(__inout_opt LPSHELLSTATE lpss, DWORD dwMask, BOOL bSet);

//
//  SysFiles are these windows special files:
//      "dll sys vxd 386 drv"
//
//  hidden files are files with the FILE_ATTRIBUTE_HIDDEN attribute
//
//  system files are files with the FILE_ATTRIBUTE_SYSTEM attribute
//
//      fShowAllObjects fShowSysFiles   Result
//      --------------- -------------   ------
//      0               0               hide hidden + SysFiles + system files
//      0               1               hide hidden files.
//      1               0               show all files.
//      1               1               show all files.
//
typedef struct {
    BOOL fShowAllObjects : 1;
    BOOL fShowExtensions : 1;
    BOOL fNoConfirmRecycle : 1;
    BOOL fShowSysFiles : 1;
    BOOL fShowCompColor : 1;
    BOOL fDoubleClickInWebView : 1;
    BOOL fDesktopHTML : 1;
    BOOL fWin95Classic : 1;
    BOOL fDontPrettyPath : 1;
    BOOL fShowAttribCol : 1;
    BOOL fMapNetDrvBtn : 1;
    BOOL fShowInfoTip : 1;
    BOOL fHideIcons : 1;
#if (NTDDI_VERSION >= NTDDI_VISTA)
    BOOL fAutoCheckSelect: 1;
    BOOL fIconsOnly: 1;
    UINT fRestFlags : 1;
#else
    UINT fRestFlags : 3;
#endif
} SHELLFLAGSTATE, *LPSHELLFLAGSTATE;

#define SSF_SHOWALLOBJECTS          0x00000001
#define SSF_SHOWEXTENSIONS          0x00000002
#define SSF_HIDDENFILEEXTS          0x00000004
#define SSF_SERVERADMINUI           0x00000004
#define SSF_SHOWCOMPCOLOR           0x00000008
#define SSF_SORTCOLUMNS             0x00000010
#define SSF_SHOWSYSFILES            0x00000020
#define SSF_DOUBLECLICKINWEBVIEW    0x00000080
#define SSF_SHOWATTRIBCOL           0x00000100
#define SSF_DESKTOPHTML             0x00000200
#define SSF_WIN95CLASSIC            0x00000400
#define SSF_DONTPRETTYPATH          0x00000800
#define SSF_SHOWINFOTIP             0x00002000
#define SSF_MAPNETDRVBUTTON         0x00001000
#define SSF_NOCONFIRMRECYCLE        0x00008000
#define SSF_HIDEICONS               0x00004000
#define SSF_FILTER                  0x00010000
#define SSF_WEBVIEW                 0x00020000
#define SSF_SHOWSUPERHIDDEN         0x00040000
#define SSF_SEPPROCESS              0x00080000
#if (NTDDI_VERSION >= NTDDI_WINXP)
#define SSF_NONETCRAWLING           0x00100000
#define SSF_STARTPANELON            0x00200000
#define SSF_SHOWSTARTPAGE           0x00400000
#endif  // NTDDI_WINXP
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define SSF_AUTOCHECKSELECT         0x00800000

#define SSF_ICONSONLY               0x01000000
#define SSF_SHOWTYPEOVERLAY         0x02000000

#endif  // NTDDI_VISTA

//
// Specify the bits you are interested in in dwMask and they will be
// filled out in the lpss structure.
//
// When these settings change, a WM_SETTINGCHANGE message is sent
// with the string lParam value of "ShellState".
//
SHSTDAPI_(void) SHGetSettings(__out SHELLFLAGSTATE *psfs, DWORD dwMask);

//
// Given a pidl, you can get an interface pointer (as specified by riid) of the pidl's parent folder (in ppv)
// If ppidlLast is non-NULL, you can also get the pidl of the last item.
//
SHSTDAPI SHBindToParent(PCIDLIST_ABSOLUTE pidl, REFIID riid, __out void **ppv, __out_opt PCUITEMID_CHILD *ppidlLast);


#if (NTDDI_VERSION >= NTDDI_VISTA)

// Same as SHBindToParent, except you also specify which root to use.
SHSTDAPI SHBindToFolderIDListParent(IShellFolder *psfRoot, PCUIDLIST_RELATIVE pidl, REFIID riid, __out void **ppv, __out_opt PCUITEMID_CHILD *ppidlLast);

// same as SHBindToFolderIDListParent but with a IBindCtx *pbc;
SHSTDAPI SHBindToFolderIDListParentEx(IShellFolder *psfRoot, PCUIDLIST_RELATIVE pidl, __in_opt IBindCtx *ppbc, REFIID riid, __out void **ppv, __out_opt PCUITEMID_CHILD *ppidlLast);

// helper function that gets the desktop object, then calls BindToObject on that
SHSTDAPI SHBindToObject(__in_opt IShellFolder *psf, __in PCUIDLIST_RELATIVE pidl, __in_opt IBindCtx *pbc, __in REFIID riid, __deref_out void **ppv);

#endif // NTDDI_VISTA

//
//  given a string it will call psfDesktop->ParseDisplayName() to try and create a pidl
//  if no pbc specified, it uses the preferred options for parsing.
//  this includes mapping file system paths to their appropriate aliased location (RegisterObjectParam(STR_PARSE_TRANSLATE_ALIASES))
//  psfgaoOut is optional for SFGAO attributes
//
#if (NTDDI_VERSION >= NTDDI_WINXP)
SHSTDAPI SHParseDisplayName(PCWSTR pszName, __in_opt IBindCtx *pbc, __out PIDLIST_ABSOLUTE *ppidl, SFGAOF sfgaoIn, __out_opt SFGAOF *psfgaoOut);
#endif // NTDDI_WINXP

//
// This API will make its best effort to prepare the path for the caller.  This includes:
// 1. Prompting for the ejectable media to be re-inserted. (Floppy, CD-ROM, ZIP drive, etc.)
// 2. Prompting for the media to be formatted. (Floppy, hard drive, etc.)
// 3. Remount mapped drives if the connection was lost. (\\unc\share mapped to N: becomes disconnected)
// 4. If the path doesn't exist, create it.  (SHPPFW_DIRCREATE and SHPPFW_ASKDIRCREATE)
// 5. Display an error if the media is read only. (SHPPFW_NOWRITECHECK not set)
//
// PARAMETERS:
//      hwnd: Parernt window for UI.  NULL means don't display UI. OPTIONAL
//      punkEnableModless: Parent that will be set to modal during UI using IOleInPlaceActiveObject::EnableModeless(). OPTIONAL
//      pszPath: Path to verify is valid for writting.  This can be a UNC or file drive path.  The path
//               should only contain directories.  Pass SHPPFW_IGNOREFILENAME if the last path segment
//               is always filename to ignore.
//      dwFlags: SHPPFW_* Flags to modify behavior

#define SHPPFW_NONE             0x00000000
#define SHPPFW_DEFAULT          SHPPFW_DIRCREATE        // May change
#define SHPPFW_DIRCREATE        0x00000001              // Create the directory if it doesn't exist without asking the user.
#define SHPPFW_ASKDIRCREATE     0x00000002              // Create the directory if it doesn't exist after asking the user.
#define SHPPFW_IGNOREFILENAME   0x00000004              // Ignore the last item in pszPath because it's a file.  Example: pszPath="C:\DirA\DirB", only use "C:\DirA".
#define SHPPFW_NOWRITECHECK     0x00000008              // Caller only needs to read from the drive, so don't check if it's READ ONLY.
#if (NTDDI_VERSION >= NTDDI_WINXP)
#define SHPPFW_MEDIACHECKONLY   0x00000010              // do the retrys on the media (or net path), return errors if the file can't be found
#endif // NTDDI_WINXP

SHSTDAPI SHPathPrepareForWriteA(HWND hwnd, IUnknown *punkEnableModless, LPCSTR pszPath, DWORD dwFlags);
SHSTDAPI SHPathPrepareForWriteW(HWND hwnd, IUnknown *punkEnableModless, LPCWSTR pszPath, DWORD dwFlags);
#ifdef UNICODE
#define SHPathPrepareForWrite  SHPathPrepareForWriteW
#else
#define SHPathPrepareForWrite  SHPathPrepareForWriteA
#endif // !UNICODE


//--------------------------------------------------------------------------
//
// Interface used for exposing the INI file methods on a shortcut file
//
//
//--------------------------------------------------------------------------
#undef  INTERFACE
#define INTERFACE  INamedPropertyBag
DECLARE_INTERFACE_IID_(INamedPropertyBag, IUnknown, "FB700430-952C-11d1-946F-000000000000")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;
    // *** INamedPropertyBag methods ***
    STDMETHOD(ReadPropertyNPB) (THIS_  /* [in] */ LPCWSTR pszBagname,
                            /* [in] */ LPCWSTR pszPropName,
                            /* [out][in] */ PROPVARIANT *pVar) PURE;

    STDMETHOD(WritePropertyNPB)(THIS_ /* [in] */ LPCWSTR pszBagname,
                           /* [in] */ LPCWSTR pszPropName,
                           /* [in] */ PROPVARIANT  *pVar) PURE;

    STDMETHOD(RemovePropertyNPB)(THIS_ /* [in] */ LPCWSTR pszBagname,
                          /* [in] */ LPCWSTR pszPropName) PURE;
};

#ifdef __urlmon_h__
//    NOTE: urlmon.h must be included before shlobj.h to access this function.
//
//    SoftwareUpdateMessageBox
//
//    Provides a standard message box for the alerting the user that a software
//    update is available or installed. No UI will be displayed if there is no
//    update available or if the available update version is less than or equal
//    to the Advertised update version.
//
//    hWnd                - [in] Handle of owner window
//    szDistUnit          - [in] Unique identifier string for a code distribution unit. For
//                               ActiveX controls and Active Setup installed components, this
//                               is typically a GUID string.
//    dwFlags             - [in] Must be 0.
//    psdi                - [in,out] Pointer to SOFTDISTINFO ( see URLMon.h ). May be NULL.
//                                cbSize should be initialized
//                                by the caller to sizeof(SOFTDISTINFO), dwReserved should be set to 0.
//
//    RETURNS:
//
//    IDNO     - The user chose cancel. If *pbRemind is FALSE, the caller should save the
//               update version from the SOFTDISTINFO and pass it in as the Advertised
//               version in future calls.
//
//    IDYES    - The user has selected Update Now/About Update. The caller should navigate to
//               the SOFTDISTINFO's pszHREF to initiate the install or learn about it.
//               The caller should save the update version from the SOFTDISTINFO and pass
//               it in as the Advertised version in future calls.
//
//    IDIGNORE - There is no pending software update. Note: There is
//               no Ignore button in the standard UI. This occurs if the available
//               version is less than the installed version or is not present or if the
//               Advertised version is greater than or equal to the update version.
//
//    IDABORT  - An error occured. Call GetSoftwareUpdateInfo() for a more specific HRESULT.
//               Note: There is no Abort button in the standard UI.


SHDOCAPI_(DWORD) SoftwareUpdateMessageBox( HWND hWnd,
                                           LPCWSTR pszDistUnit,
                                           DWORD dwFlags,
                                           __out_opt LPSOFTDISTINFO psdi );
#endif // if __urlmon_h__


//  SHPropStgCreate()
//  Wrap of IPropertySetStorage::Open/Create
//
//  This function ensures proper handling of code page retrieval/assignment
//  for the requested property set operation.
//
//  psstg,          //  Address of IPropertySetStorage vtable
//  fmtid,          //  property set ID
//  pclsid,         //  class ID associated with the set. This can be NULL
//  grfFlags,       //  PROPSETFLAG_xxx.  All sets containing ansi bytes should be created with
                    //  PROPSETFLAG_ANSI, otherwise PROPSETFLAG_DEFAULT.
//  grfMode,        //  STGM_ flags.  Must contain STGM_DIRECT|STGM_EXCLUSIVE.
//  dwDisposition,  //  OPEN_EXISTING. OPEN_ALWAYS, CREATE_NEW, or CREATE_ALWAYS
//  IPropertyStorage** ppstg,  // Address to receive requested vtable
//  puCodePage      //  Optional address to receive the code page ID for the set.
//
SHSTDAPI SHPropStgCreate( IPropertySetStorage* psstg, REFFMTID fmtid, const CLSID *pclsid, DWORD grfFlags, DWORD grfMode, DWORD dwDisposition, __out IPropertyStorage** ppstg, __out_opt UINT* puCodePage );


//  SHPropStgReadMultiple()
//  IPropertyStorage::ReadMultiple wrap
//
//  The wrap ensures ANSI/UNICODE translations are handled properly for
//  legacy property sets.
//
//  pps,       // address of IPropertyStorage vtable.
//  uCodePage, //Code page value retrieved from SHCreatePropertySet
//  cpspec,    //Count of properties being read
//  rgpspec,   //Array of the properties to be read
//  rgvar      //Array of PROPVARIANTs containing the property values on return
//
SHSTDAPI SHPropStgReadMultiple( IPropertyStorage* pps, UINT uCodePage, ULONG cpspec, __in_ecount(cpspec) PROPSPEC const rgpspec[], __out_ecount_full(cpspec) PROPVARIANT rgvar[] );


//  SHPropStgWriteMultiple()
//  IPropertyStorage::WriteMultiple wrap
//
//  The wrap ensures ANSI/UNICODE translations are handled properly for
//  legacy property sets.
//
//  pps,       // address of IPropertyStorage vtable.
//  uCodePage, // code page retrieved from SHCreatePropertySet.
//  cpspec,    // The number of properties being set
//  rgpspec,   // Property specifiers
//  rgvar,     // Array of PROPVARIANT values
//  propidNameFirst // Minimum value for property identifiers. This value should be >= PID_FIRST_USABLE
//
SHSTDAPI SHPropStgWriteMultiple( IPropertyStorage* pps, __inout_opt UINT* puCodePage, ULONG cpspec, __in_ecount(cpspec) PROPSPEC const rgpspec[], __inout_ecount(cpspec) PROPVARIANT rgvar[], PROPID propidNameFirst );

#if (NTDDI_VERSION >= NTDDI_WINXP)
SHSTDAPI SHCreateFileExtractIconA(LPCSTR pszFile, DWORD dwFileAttributes, REFIID riid, __out void **ppv);
SHSTDAPI SHCreateFileExtractIconW(LPCWSTR pszFile, DWORD dwFileAttributes, REFIID riid, __out void **ppv);
#ifdef UNICODE
#define SHCreateFileExtractIcon  SHCreateFileExtractIconW
#else
#define SHCreateFileExtractIcon  SHCreateFileExtractIconA
#endif // !UNICODE
#include <pshpack8.h>
#include <poppack.h>        /* Return to byte packing */
SHSTDAPI SHLimitInputEdit(HWND hwndEdit, IShellFolder *psf);
STDAPI SHGetAttributesFromDataObject(IDataObject *pdo, DWORD dwAttributeMask, __out_opt DWORD *pdwAttributes, __out_opt UINT *pcItems);
#endif  // NTDDI_WINXP

#if (NTDDI_VERSION >= NTDDI_WIN2K)

//
// The SHMultiFileProperties API displays a property sheet for a
// set of files specified in an IDList Array.
//
// Parameters:
//      pdtobj  - Data object containing list of files.  The data
//                object must provide the "Shell IDList Array"
//                clipboard format.  The parent folder's implementation of
//                IShellFolder::GetDisplayNameOf must return a fully-qualified
//                filesystem path for each item in response to the
//                SHGDN_FORPARSING flag.
//
//      dwFlags - Reserved for future use.  Should be set to 0.
//
// Returns:
//      S_OK
//
SHSTDAPI SHMultiFileProperties(IDataObject *pdtobj, DWORD dwFlags);

#endif  // NTDDI_WIN2K

// A usefull function in Defview for mapping idlist into index into system
// image list.  Optionally it can also look up the index of the selected
// icon.
SHSTDAPI_(int) SHMapPIDLToSystemImageListIndex(IShellFolder *pshf, PCUITEMID_CHILD pidl, __out_opt int *piIndexSel);

SHSTDAPI SHCLSIDFromString(LPCWSTR psz, __out CLSID *pclsid);
SHSTDAPI SHCreateQueryCancelAutoPlayMoniker(__out IMoniker** ppmoniker);    // deprecated: use CreateClassMoniker(CLSID_YourOwnClsid, ...)
STDAPI_(void) PerUserInit(void);
SHSTDAPI_(BOOL)SHRunControlPanel(LPCWSTR lpcszCmdLine, HWND hwndMsgParent);

SHSTDAPI_(int) PickIconDlg(HWND hwnd, __inout_ecount(cchIconPath) LPWSTR pszIconPath, UINT cchIconPath, __inout_opt int *piIconIndex);

#include <pshpack8.h>

typedef struct tagAAMENUFILENAME
{
  SHORT  cbTotal;
  BYTE   rgbReserved[12];
  WCHAR  szFileName[1];     // variable length string
} AASHELLMENUFILENAME, *LPAASHELLMENUFILENAME;

typedef struct tagAASHELLMENUITEM
{
  void*  lpReserved1;
  int    iReserved;
  UINT   uiReserved;
  LPAASHELLMENUFILENAME lpName; // name of file
  LPWSTR psz;           // text to use if no file
} AASHELLMENUITEM, *LPAASHELLMENUITEM;

#include <poppack.h>        /* Return to byte packing */


#if (_WIN32_IE >= _WIN32_IE_IE70)
typedef enum tagIESHORTCUTFLAGS
{
    IESHORTCUT_NEWBROWSER    = 0x01,
    IESHORTCUT_OPENNEWTAB    = 0x02,
    IESHORTCUT_FORCENAVIGATE = 0x04,
    IESHORTCUT_BACKGROUNDTAB = 0x08,
} IESHORTCUTFLAGS;
#endif // _WIN32_IE_IE70

#if (_WIN32_IE >= _WIN32_IE_XP)

SHDOCAPI_(BOOL) ImportPrivacySettings(LPCWSTR pszFilename, __inout BOOL* pfParsePrivacyPreferences, __inout BOOL* pfParsePerSiteRules);
#ifndef IEnumPrivacyRecords
typedef interface IEnumPrivacyRecords IEnumPrivacyRecords;
#endif
SHDOCAPI DoPrivacyDlg(HWND hwndOwner, __in LPWSTR pszUrl, __in IEnumPrivacyRecords *pPrivacyEnum, BOOL fReportAllSites);

#endif  // _WIN32_IE_XP


#include <poppack.h>

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#if (_MSC_VER >= 800)
#if (_MSC_VER >= 1200)
#pragma warning(pop)
#else
#pragma warning(default:4001)
#endif
#endif

#endif /* _SHLOBJ_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\sisbkup.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    sisbackup.h

Abstract:

    External interface for the SIS Backup dll.


Revision History:

--*/

#ifndef __SISBKUP_H__
#define __SISBKUP_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus
extern "C" {
#endif  // __cplusplus

BOOL __stdcall
SisCreateBackupStructure(
    __in PWCHAR                         volumeRoot,
    __out PVOID                         *sisBackupStructure,
    __out PWCHAR                        *commonStoreRootPathname,
    __out PULONG                        countOfCommonStoreFilesToBackup,
    __out PWCHAR                        **commonStoreFilesToBackup);


BOOL __stdcall
SisCSFilesToBackupForLink(
    __in PVOID                          sisBackupStructure,
    __in_bcount(reparseDataSize) PVOID  reparseData,
    __in ULONG                          reparseDataSize,
    __in_opt PVOID                      thisFileContext,
    __out_opt PVOID                     *matchingFileContext,
    __out PULONG                        countOfCommonStoreFilesToBackup,
    __out PWCHAR                        **commonStoreFilesToBackup);

BOOL __stdcall
SisFreeBackupStructure(
    __in PVOID                          sisBackupStructure);

BOOL __stdcall
SisCreateRestoreStructure(
    __in PWCHAR                         volumeRoot,
    __out PVOID                         *sisRestoreStructure,
    __out PWCHAR                        *commonStoreRootPathname,
    __out PULONG                        countOfCommonStoreFilesToRestore,
    __out PWCHAR                        **commonStoreFilesToRestore);

BOOL __stdcall
SisRestoredLink(
    __in PVOID                          sisRestoreStructure,
    __in PWCHAR                         restoredFileName,
    __in_bcount(reparseDataSize) PVOID  reparseData,
    __in ULONG                          reparseDataSize,
    __out PULONG                        countOfCommonStoreFilesToRestore,
    __out PWCHAR                        **commonStoreFilesToRestore);

BOOL __stdcall
SisRestoredCommonStoreFile(
    __in PVOID                          sisRestoreStructure,
    __in PWCHAR                         commonStoreFileName);

BOOL __stdcall
SisFreeRestoreStructure(
    __in PVOID                          sisRestoreStructure);

VOID __stdcall
SisFreeAllocatedMemory(
    __in PVOID                          allocatedSpace);


//
// SIS entry function typedefs
//
typedef BOOL ( FAR __stdcall *PF_SISCREATEBACKUPSTRUCTURE )( PWCHAR, PVOID *, PWCHAR *, PULONG, PWCHAR ** );
typedef BOOL ( FAR __stdcall *PF_SISCSFILESTOBACKUPFORLINK )  (PVOID, PVOID, ULONG, PVOID, PVOID *, PULONG, PWCHAR ** ) ;
typedef BOOL ( FAR __stdcall *PF_SISFREEBACKUPSTRUCTURE )  ( PVOID ) ;

typedef BOOL ( FAR __stdcall *PF_SISCREATERESTORESTRUCTURE)  ( PWCHAR, PVOID *, PWCHAR *, PULONG, PWCHAR ** );
typedef BOOL ( FAR __stdcall *PF_SISRESTOREDLINK )  ( PVOID, PWCHAR, PVOID, ULONG, PULONG, PWCHAR ** ) ;
typedef BOOL ( FAR __stdcall *PF_SISRESTOREDCOMMONSTORFILE) ( PVOID, PWCHAR ) ;

typedef BOOL ( FAR __stdcall *PF_SISFREERESTORESTRUCTURE )( PVOID ) ;
typedef BOOL ( FAR __stdcall *PF_SISFREEALLOCATEDMEMORY )( PVOID ) ;

#ifdef  __cplusplus
}
#endif  // __cplusplus

#endif  // __SISBKUP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\SipBase.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996-1999
//
//  File:       sipbase.h
//
//  Contents:   Generic SIP Provider Main Include File
//
//  History:    14-Feb-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef SIPBASE_H
#define SIPBASE_H

#if _MSC_VER > 1000
#pragma once
#endif

// all moved to mssip.h
#include <mssip.h>

#endif // SIPBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\Shlwapi.h ===
/*****************************************************************************\
*                                                                             *
* shlwapi.h - Interface for the Windows light-weight utility APIs             *
*                                                                             *
* Version 1.0                                                                 *
*                                                                             *
* Copyright (c) Microsoft Corporation. All rights reserved.                   *
*                                                                             *
\*****************************************************************************/


#ifndef _INC_SHLWAPI
#define _INC_SHLWAPI

#ifndef NOSHLWAPI

#include <SpecStrings.h>
#include <objbase.h>
#include <shtypes.h>



#ifdef UNIX
typedef interface IInternetSecurityMgrSite IInternetSecurityMgrSite;
typedef interface IInternetSecurityManager IInternetSecurityManager;
typedef interface IInternetHostSecurityManager IInternetHostSecurityManager;
#endif

//
// Define API decoration for direct importing of DLL references.
//
#ifndef WINSHLWAPI
#if !defined(_SHLWAPI_)
#define LWSTDAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define LWSTDAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#define LWSTDAPIV         EXTERN_C DECLSPEC_IMPORT HRESULT STDAPIVCALLTYPE
#define LWSTDAPIV_(type)  EXTERN_C DECLSPEC_IMPORT type STDAPIVCALLTYPE
#else
#define LWSTDAPI          STDAPI
#define LWSTDAPI_(type)   STDAPI_(type)
#define LWSTDAPIV         STDAPIV
#define LWSTDAPIV_(type)  STDAPIV_(type)
#endif
#endif // WINSHLWAPI

#ifdef _WIN32
#include <pshpack8.h>
#endif

#if defined(DEPRECATE_SUPPORTED)
#pragma warning(push)
#pragma warning(disable:4995)
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if defined(__cplusplus) && defined(STRICT_CONST)
#define USE_STRICT_CONST
#endif
//
// Users of this header may define any number of these constants to avoid
// the definitions of each functional group.
//
//    NO_SHLWAPI_STRFCNS    String functions
//    NO_SHLWAPI_PATH       Path functions
//    NO_SHLWAPI_REG        Registry functions
//    NO_SHLWAPI_STREAM     Stream functions
//    NO_SHLWAPI_GDI        GDI helper functions

#ifndef NO_SHLWAPI_STRFCNS
//
//=============== String Routines ===================================
//

#ifdef USE_STRICT_CONST
LWSTDAPI_(LPCSTR)    StrChrA(LPCSTR lpStart, WORD wMatch);
LWSTDAPI_(LPCWSTR)   StrChrW(LPCWSTR lpStart, WCHAR wMatch);
LWSTDAPI_(LPCSTR)    StrChrIA(LPCSTR lpStart, WORD wMatch);
LWSTDAPI_(LPCWSTR)   StrChrIW(LPCWSTR lpStart, WCHAR wMatch);
#if (_WIN32_IE >= _WIN32_IE_IE60)
LWSTDAPI_(LPCWSTR)   StrChrNW(LPCWSTR lpStart, WCHAR wMatch, UINT cchMax);
LWSTDAPI_(LPCWSTR)   StrChrNIW(LPCWSTR lpStart, WCHAR wMatch, UINT cchMax);
#endif // _WIN32_IE_IE60
#else
LWSTDAPI_(LPSTR)    StrChrA(LPCSTR lpStart, WORD wMatch);
LWSTDAPI_(LPWSTR)   StrChrW(LPCWSTR lpStart, WCHAR wMatch);
LWSTDAPI_(LPSTR)    StrChrIA(LPCSTR lpStart, WORD wMatch);
LWSTDAPI_(LPWSTR)   StrChrIW(LPCWSTR lpStart, WCHAR wMatch);
#if (_WIN32_IE >= _WIN32_IE_IE60)
LWSTDAPI_(LPWSTR)   StrChrNW(LPCWSTR lpStart, WCHAR wMatch, UINT cchMax);
LWSTDAPI_(LPWSTR)   StrChrNIW(LPCWSTR lpStart, WCHAR wMatch, UINT cchMax);
#endif // _WIN32_IE_IE60
#endif
LWSTDAPI_(int)      StrCmpNA(__in LPCSTR lpStr1, __in LPCSTR lpStr2, int nChar);
LWSTDAPI_(int)      StrCmpNW(__in LPCWSTR lpStr1, __in LPCWSTR lpStr2, int nChar);
LWSTDAPI_(int)      StrCmpNIA(__in LPCSTR lpStr1, __in LPCSTR lpStr2, int nChar);
LWSTDAPI_(int)      StrCmpNIW(__in LPCWSTR lpStr1, __in LPCWSTR lpStr2, int nChar);
LWSTDAPI_(int)      StrCSpnA(LPCSTR lpStr, LPCSTR lpSet);
LWSTDAPI_(int)      StrCSpnW(LPCWSTR lpStr, LPCWSTR lpSet);
LWSTDAPI_(int)      StrCSpnIA(LPCSTR lpStr, LPCSTR lpSet);
LWSTDAPI_(int)      StrCSpnIW(LPCWSTR lpStr, LPCWSTR lpSet);
LWSTDAPI_(LPSTR)    StrDupA(LPCSTR lpSrch);
LWSTDAPI_(LPWSTR)   StrDupW(LPCWSTR lpSrch);

// StrFormatByteSizeEx takes a ULONGLONG as a byte count and formats a string
// representing that number of bytes in an appropriately concise manner, where
// "appropriate manner" is determine by several factors:
//
// 1) order - is this most appropriately expressed as KB? MB? GB?
//    for example: 1039 -> "1.01 KB", 5454608466 -> "5.08 GB", etc
//
// 2) number of whole number places shown - if there are more than a few whole
//    number places to display, decimal places are omitted.
//    for example: 1024 -> "1.00 KB", 12288 -> "12.0 KB", 125952 -> "123 KB"
//
// 3) the caller can specify whether the result should involve rounding to the
//    nearest displayed digit, or truncation of undisplayed digits. the caller
//    must specify either rounding or truncation when calling the API.
//    for example: with rounding,   2147483647 -> "2.00 GB"
//                 with truncation, 2147483647 -> "1.99 GB"

enum tagSFBS_FLAGS {
    SFBS_FLAGS_ROUND_TO_NEAREST_DISPLAYED_DIGIT     = 0x0001,   // round to the nearest displayed digit
    SFBS_FLAGS_TRUNCATE_UNDISPLAYED_DECIMAL_DIGITS  = 0x0002,   // discard undisplayed digits
};
typedef int SFBS_FLAGS;

LWSTDAPI            StrFormatByteSizeEx(__in ULONGLONG ull, __in SFBS_FLAGS flags, __out_ecount(cchBuf) LPWSTR pszBuf, __in_range(>,0) UINT cchBuf);

LWSTDAPI_(LPSTR)    StrFormatByteSizeA(DWORD dw, __out_ecount(cchBuf) LPSTR pszBuf, UINT cchBuf);
LWSTDAPI_(LPSTR)    StrFormatByteSize64A(LONGLONG qdw, __out_ecount(cchBuf) LPSTR pszBuf, UINT cchBuf);
LWSTDAPI_(LPWSTR)   StrFormatByteSizeW(LONGLONG qdw, __out_ecount(cchBuf) LPWSTR pszBuf, UINT cchBuf);
LWSTDAPI_(LPWSTR)   StrFormatKBSizeW(LONGLONG qdw, __out_ecount(cchBuf) LPWSTR pszBuf, UINT cchBuf);
LWSTDAPI_(LPSTR)    StrFormatKBSizeA(LONGLONG qdw, __out_ecount(cchBuf) LPSTR pszBuf, UINT cchBuf);
LWSTDAPI_(int)      StrFromTimeIntervalA(__out_ecount(cchMax) LPSTR pszOut, UINT cchMax, DWORD dwTimeMS, int digits);
LWSTDAPI_(int)      StrFromTimeIntervalW(__out_ecount(cchMax) LPWSTR pwszOut, UINT cchMax, DWORD dwTimeMS, int digits);
LWSTDAPI_(BOOL)     StrIsIntlEqualA(__in BOOL fCaseSens, __in LPCSTR lpString1, __in LPCSTR lpString2, __in int nChar);
LWSTDAPI_(BOOL)     StrIsIntlEqualW(__in BOOL fCaseSens, __in LPCWSTR lpString1, __in LPCWSTR lpString2, __in int nChar);
LWSTDAPI_(LPSTR)    StrNCatA(__inout_ecount(cchMax) LPSTR psz1, LPCSTR psz2, int cchMax);
LWSTDAPI_(LPWSTR)   StrNCatW(__inout_ecount(cchMax) LPWSTR psz1, LPCWSTR psz2, int cchMax);
#ifdef USE_STRICT_CONST
LWSTDAPI_(LPCSTR)    StrPBrkA(__in LPCSTR psz, __in LPCSTR pszSet);
LWSTDAPI_(LPCWSTR)   StrPBrkW(__in LPCWSTR psz, __in LPCWSTR pszSet);
LWSTDAPI_(LPCSTR)    StrRChrA(__in LPCSTR lpStart, __in_opt LPCSTR lpEnd, __in WORD wMatch);
LWSTDAPI_(LPCWSTR)   StrRChrW(__in LPCWSTR lpStart, __in_opt LPCWSTR lpEnd, __in WCHAR wMatch);
LWSTDAPI_(LPCSTR)    StrRChrIA(__in LPCSTR lpStart, __in_opt LPCSTR lpEnd, __in WORD wMatch);
LWSTDAPI_(LPCWSTR)   StrRChrIW(__in LPCWSTR lpStart, __in_opt LPCWSTR lpEnd, __in WCHAR wMatch);
LWSTDAPI_(LPCSTR)    StrRStrIA(__in LPCSTR lpSource, __in_opt LPCSTR lpLast, __in LPCSTR lpSrch);
LWSTDAPI_(LPCWSTR)   StrRStrIW(__in LPCWSTR lpSource, __in_opt LPCWSTR lpLast, __in LPCWSTR lpSrch);
#else
LWSTDAPI_(LPSTR)    StrPBrkA(__in LPCSTR psz, __in LPCSTR pszSet);
LWSTDAPI_(LPWSTR)   StrPBrkW(__in LPCWSTR psz, __in LPCWSTR pszSet);
LWSTDAPI_(LPSTR)    StrRChrA(__in LPCSTR lpStart, __in_opt LPCSTR lpEnd, __in WORD wMatch);
LWSTDAPI_(LPWSTR)   StrRChrW(__in LPCWSTR lpStart, __in_opt LPCWSTR lpEnd, __in WCHAR wMatch);
LWSTDAPI_(LPSTR)    StrRChrIA(__in LPCSTR lpStart, __in_opt LPCSTR lpEnd, __in WORD wMatch);
LWSTDAPI_(LPWSTR)   StrRChrIW(__in LPCWSTR lpStart, __in_opt LPCWSTR lpEnd, __in WCHAR wMatch);
LWSTDAPI_(LPSTR)    StrRStrIA(__in LPCSTR lpSource, __in_opt LPCSTR lpLast, __in LPCSTR lpSrch);
LWSTDAPI_(LPWSTR)   StrRStrIW(__in LPCWSTR lpSource, __in_opt LPCWSTR lpLast, __in LPCWSTR lpSrch);
#endif
LWSTDAPI_(int)      StrSpnA(__in LPCSTR psz, __in LPCSTR pszSet);
LWSTDAPI_(int)      StrSpnW(__in LPCWSTR psz, __in LPCWSTR pszSet);
#ifdef USE_STRICT_CONST
LWSTDAPI_(LPCSTR)    StrStrA(__in LPCSTR lpFirst, __in LPCSTR lpSrch);
LWSTDAPI_(LPCWSTR)   StrStrW(__in LPCWSTR lpFirst, __in LPCWSTR lpSrch);
LWSTDAPI_(LPCSTR)    StrStrIA(__in LPCSTR lpFirst, __in LPCSTR lpSrch);
LWSTDAPI_(LPCWSTR)   StrStrIW(__in LPCWSTR lpFirst, __in LPCWSTR lpSrch);
#if (_WIN32_IE >= _WIN32_IE_IE6)
LWSTDAPI_(LPCWSTR)   StrStrNW(__in LPCWSTR lpFirst, __in LPCWSTR lpSrch, __in UINT cchMax);
LWSTDAPI_(LPCWSTR)   StrStrNIW(__in LPCWSTR lpFirst, __in LPCWSTR lpSrch, __in UINT cchMax);
#endif // _WIN32_IE_IE6
#else
LWSTDAPI_(LPSTR)    StrStrA(__in LPCSTR lpFirst, __in LPCSTR lpSrch);
LWSTDAPI_(LPWSTR)   StrStrW(__in LPCWSTR lpFirst, __in LPCWSTR lpSrch);
LWSTDAPI_(LPSTR)    StrStrIA(__in LPCSTR lpFirst, __in LPCSTR lpSrch);
LWSTDAPI_(LPWSTR)   StrStrIW(__in LPCWSTR lpFirst, __in LPCWSTR lpSrch);
#if (_WIN32_IE >= _WIN32_IE_IE60)
LWSTDAPI_(LPWSTR)   StrStrNW(__in LPCWSTR lpFirst, __in LPCWSTR lpSrch, __in UINT cchMax);
LWSTDAPI_(LPWSTR)   StrStrNIW(__in LPCWSTR lpFirst, __in LPCWSTR lpSrch, __in UINT cchMax);
#endif // _WIN32_IE_IE60
#endif

#define STIF_DEFAULT        0x00000000L
#define STIF_SUPPORT_HEX    0x00000001L
typedef int STIF_FLAGS;
LWSTDAPI_(int)      StrToIntA(__in LPCSTR lpSrc);
LWSTDAPI_(int)      StrToIntW(__in LPCWSTR lpSrc);
LWSTDAPI_(BOOL)     StrToIntExA(__in LPCSTR pszString, __in STIF_FLAGS dwFlags, __out int * piRet);
LWSTDAPI_(BOOL)     StrToIntExW(__in LPCWSTR pszString, __in STIF_FLAGS dwFlags, __out int * piRet);
#if (_WIN32_IE >= _WIN32_IE_IE60)
LWSTDAPI_(BOOL)     StrToInt64ExA(__in LPCSTR pszString, __in STIF_FLAGS dwFlags, __out LONGLONG * pllRet);
LWSTDAPI_(BOOL)     StrToInt64ExW(__in LPCWSTR pszString, __in STIF_FLAGS dwFlags, __out LONGLONG * pllRet);
#endif // _WIN32_IE_IE60

LWSTDAPI_(BOOL)     StrTrimA(__inout LPSTR psz, LPCSTR pszTrimChars);
LWSTDAPI_(BOOL)     StrTrimW(__inout LPWSTR psz, LPCWSTR pszTrimChars);

LWSTDAPI_(LPWSTR)   StrCatW(__inout LPWSTR psz1, LPCWSTR psz2);
LWSTDAPI_(int)      StrCmpW(__in LPCWSTR psz1, __in LPCWSTR psz2);
LWSTDAPI_(int)      StrCmpIW(__in LPCWSTR psz1, __in LPCWSTR psz2);
LWSTDAPI_(LPWSTR)   StrCpyW(__out LPWSTR psz1, LPCWSTR psz2);
LWSTDAPI_(LPWSTR)   StrCpyNW(__out_ecount(cchMax) LPWSTR psz1, LPCWSTR psz2, int cchMax);

LWSTDAPI_(LPWSTR)   StrCatBuffW(__inout_ecount(cchDestBuffSize) LPWSTR pszDest, LPCWSTR pszSrc, int cchDestBuffSize);
LWSTDAPI_(LPSTR)    StrCatBuffA(__inout_ecount(cchDestBuffSize) LPSTR pszDest, LPCSTR pszSrc, int cchDestBuffSize);
LWSTDAPI_(BOOL)     ChrCmpIA(__in WORD w1, __in WORD w2);
LWSTDAPI_(BOOL)     ChrCmpIW(__in WCHAR w1, __in WCHAR w2);

LWSTDAPI_(int)      wvnsprintfA(__out_ecount(cchLimitIn) LPSTR lpOut, int cchLimitIn, LPCSTR lpFmt, __in va_list arglist);
LWSTDAPI_(int)      wvnsprintfW(__out_ecount(cchLimitIn) LPWSTR lpOut, int cchLimitIn, LPCWSTR lpFmt, __in va_list arglist);
LWSTDAPIV_(int)     wnsprintfA(__out_ecount(cchLimitIn) LPSTR lpOut, int cchLimitIn, LPCSTR lpFmt, ...);
LWSTDAPIV_(int)     wnsprintfW(__out_ecount(cchLimitIn) LPWSTR lpOut, int cchLimitIn, LPCWSTR lpFmt, ...);

#define StrIntlEqNA( s1, s2, nChar) StrIsIntlEqualA( TRUE, s1, s2, nChar)
#define StrIntlEqNW( s1, s2, nChar) StrIsIntlEqualW( TRUE, s1, s2, nChar)
#define StrIntlEqNIA(s1, s2, nChar) StrIsIntlEqualA(FALSE, s1, s2, nChar)
#define StrIntlEqNIW(s1, s2, nChar) StrIsIntlEqualW(FALSE, s1, s2, nChar)

LWSTDAPI StrRetToStrA(__inout STRRET *pstr, __in_opt PCUITEMID_CHILD pidl, __out LPSTR *ppsz);
LWSTDAPI StrRetToStrW(__inout STRRET *pstr, __in_opt PCUITEMID_CHILD pidl, __out LPWSTR *ppsz);
#ifdef UNICODE
#define StrRetToStr  StrRetToStrW
#else
#define StrRetToStr  StrRetToStrA
#endif // !UNICODE
LWSTDAPI StrRetToBufA(__inout STRRET *pstr, __in_opt PCUITEMID_CHILD pidl, __out_ecount(cchBuf) LPSTR pszBuf, UINT cchBuf);
LWSTDAPI StrRetToBufW(__inout STRRET *pstr, __in_opt PCUITEMID_CHILD pidl, __out_ecount(cchBuf) LPWSTR pszBuf, UINT cchBuf);
#ifdef UNICODE
#define StrRetToBuf  StrRetToBufW
#else
#define StrRetToBuf  StrRetToBufA
#endif // !UNICODE

// helper to duplicate a string using the task allocator

LWSTDAPI SHStrDupA(__in LPCSTR psz, __deref_out LPWSTR *ppwsz);
LWSTDAPI SHStrDupW(__in LPCWSTR psz, __deref_out LPWSTR *ppwsz);
#ifdef UNICODE
#define SHStrDup  SHStrDupW
#else
#define SHStrDup  SHStrDupA
#endif // !UNICODE

#ifdef __cplusplus
// make the above helper function a bit easier to use in the HRESULT world
inline HRESULT SHLocalStrDupW(LPCWSTR psz, __out LPWSTR *ppsz)
{
    *ppsz = StrDupW(psz);
    return *ppsz ? S_OK : E_OUTOFMEMORY;
}
inline HRESULT SHLocalStrDupA(LPCSTR psz, __out LPSTR *ppsz)
{
    *ppsz = StrDupA(psz);
    return *ppsz ? S_OK : E_OUTOFMEMORY;
}
#ifdef UNICODE
#define SHLocalStrDup SHLocalStrDupW
#else
#define SHLocalStrDup SHLocalStrDupA
#endif
#endif // __cplusplus

#if (_WIN32_IE >= _WIN32_IE_IE55)
LWSTDAPI_(int) StrCmpLogicalW(__in LPCWSTR psz1, __in LPCWSTR psz2);
LWSTDAPI_(DWORD) StrCatChainW(__out_ecount(cchDst) LPWSTR pszDst, DWORD cchDst, DWORD ichAt, LPCWSTR pszSrc);
LWSTDAPI StrRetToBSTR(__inout STRRET *pstr, __in PCUITEMID_CHILD pidl, __out BSTR *pbstr);
LWSTDAPI SHLoadIndirectString(LPCWSTR pszSource, __out_ecount(cchOutBuf) LPWSTR pszOutBuf, UINT cchOutBuf, __in_opt void **ppvReserved);
#endif // _WIN32_IE_IE55


#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
LWSTDAPI_(BOOL) IsCharSpaceA(__in CHAR wch);
LWSTDAPI_(BOOL) IsCharSpaceW(__in WCHAR wch);
#ifdef UNICODE
#define IsCharSpace  IsCharSpaceW
#else
#define IsCharSpace  IsCharSpaceA
#endif // !UNICODE

LWSTDAPI_(int)  StrCmpCA(__in LPCSTR pszStr1, __in LPCSTR pszStr2);
LWSTDAPI_(int)  StrCmpCW(__in LPCWSTR pszStr1, __in LPCWSTR pszStr2);
#ifdef UNICODE
#define StrCmpC  StrCmpCW
#else
#define StrCmpC  StrCmpCA
#endif // !UNICODE

LWSTDAPI_(int)  StrCmpICA(__in LPCSTR pszStr1, __in LPCSTR pszStr2);
LWSTDAPI_(int)  StrCmpICW(__in LPCWSTR pszStr1, __in LPCWSTR pszStr2);
#ifdef UNICODE
#define StrCmpIC  StrCmpICW
#else
#define StrCmpIC  StrCmpICA
#endif // !UNICODE
#endif // _WIN32_IE_IE60SP2

#ifdef UNICODE
#define StrChr                  StrChrW
#define StrRChr                 StrRChrW
#define StrChrI                 StrChrIW
#define StrRChrI                StrRChrIW
#define StrCmpN                 StrCmpNW
#define StrCmpNI                StrCmpNIW
#define StrStr                  StrStrW
#define StrStrI                 StrStrIW
#define StrDup                  StrDupW
#define StrRStrI                StrRStrIW
#define StrCSpn                 StrCSpnW
#define StrCSpnI                StrCSpnIW
#define StrSpn                  StrSpnW
#define StrToInt                StrToIntW
#define StrPBrk                 StrPBrkW
#define StrToIntEx              StrToIntExW
#if (_WIN32_IE >= 0x0600)
#define StrToInt64Ex            StrToInt64ExW
#endif
#define StrFromTimeInterval     StrFromTimeIntervalW
#define StrIntlEqN              StrIntlEqNW
#define StrIntlEqNI             StrIntlEqNIW
#define StrFormatByteSize       StrFormatByteSizeW
#define StrFormatByteSize64     StrFormatByteSizeW
#define StrFormatKBSize         StrFormatKBSizeW
#define StrNCat                 StrNCatW
#define StrTrim                 StrTrimW
#define StrCatBuff              StrCatBuffW
#define ChrCmpI                 ChrCmpIW
#define wvnsprintf              wvnsprintfW
#define wnsprintf               wnsprintfW
#define StrIsIntlEqual          StrIsIntlEqualW


#else
#define StrChr                  StrChrA
#define StrRChr                 StrRChrA
#define StrChrI                 StrChrIA
#define StrRChrI                StrRChrIA
#define StrCmpN                 StrCmpNA
#define StrCmpNI                StrCmpNIA
#define StrStr                  StrStrA
#define StrStrI                 StrStrIA
#define StrDup                  StrDupA
#define StrRStrI                StrRStrIA
#define StrCSpn                 StrCSpnA
#define StrCSpnI                StrCSpnIA
#define StrSpn                  StrSpnA
#define StrToInt                StrToIntA
#define StrPBrk                 StrPBrkA
#define StrToIntEx              StrToIntExA
#if (_WIN32_IE >= 0x0600)
#define StrToInt64Ex            StrToInt64ExA
#endif
#define StrFromTimeInterval     StrFromTimeIntervalA
#define StrIntlEqN              StrIntlEqNA
#define StrIntlEqNI             StrIntlEqNIA
#define StrFormatByteSize       StrFormatByteSizeA
#define StrFormatByteSize64     StrFormatByteSize64A
#define StrFormatKBSize         StrFormatKBSizeA
#define StrNCat                 StrNCatA
#define StrTrim                 StrTrimA
#define StrCatBuff              StrCatBuffA
#define ChrCmpI                 ChrCmpIA
#define wvnsprintf              wvnsprintfA
#define wnsprintf               wnsprintfA
#define StrIsIntlEqual          StrIsIntlEqualA
#endif

#if (_WIN32_IE >= _WIN32_IE_IE50)
// StrCmp*C* - Compare strings using C runtime collation rules.
LWSTDAPI_(int)  StrCmpNCA(__in LPCSTR lpStr1, __in LPCSTR lpStr2, __in int nChar);
// StrCmp*C* - Compare strings using C runtime collation rules.
LWSTDAPI_(int)  StrCmpNCW(__in LPCWSTR lpStr1, __in LPCWSTR lpStr2, __in int nChar);
#ifdef UNICODE
#define StrCmpNC  StrCmpNCW
#else
#define StrCmpNC  StrCmpNCA
#endif // !UNICODE
LWSTDAPI_(int)  StrCmpNICA(__in LPCSTR lpStr1, __in LPCSTR lpStr2, __in int nChar);
LWSTDAPI_(int)  StrCmpNICW(__in LPCWSTR lpStr1, __in LPCWSTR lpStr2, __in int nChar);
#ifdef UNICODE
#define StrCmpNIC  StrCmpNICW
#else
#define StrCmpNIC  StrCmpNICA
#endif // !UNICODE
#endif  // _WIN32_IE_IE50


// Backward compatible to NT's non-standard naming (strictly
// for comctl32)
//
LWSTDAPI_(BOOL)     IntlStrEqWorkerA(BOOL fCaseSens, __in_ecount(nChar) LPCSTR lpString1, __in_ecount(nChar) LPCSTR lpString2, int nChar);
LWSTDAPI_(BOOL)     IntlStrEqWorkerW(BOOL fCaseSens, __in_ecount(nChar) LPCWSTR lpString1, __in_ecount(nChar) LPCWSTR lpString2, int nChar);

#define IntlStrEqNA( s1, s2, nChar) IntlStrEqWorkerA( TRUE, s1, s2, nChar)
#define IntlStrEqNW( s1, s2, nChar) IntlStrEqWorkerW( TRUE, s1, s2, nChar)
#define IntlStrEqNIA(s1, s2, nChar) IntlStrEqWorkerA(FALSE, s1, s2, nChar)
#define IntlStrEqNIW(s1, s2, nChar) IntlStrEqWorkerW(FALSE, s1, s2, nChar)

#ifdef UNICODE
#define IntlStrEqN              IntlStrEqNW
#define IntlStrEqNI             IntlStrEqNIW
#else
#define IntlStrEqN              IntlStrEqNA
#define IntlStrEqNI             IntlStrEqNIA
#endif

#define SZ_CONTENTTYPE_HTMLA       "text/html"
#define SZ_CONTENTTYPE_HTMLW       L"text/html"
#define SZ_CONTENTTYPE_CDFA        "application/x-cdf"
#define SZ_CONTENTTYPE_CDFW        L"application/x-cdf"

#ifdef UNICODE
#define SZ_CONTENTTYPE_HTML     SZ_CONTENTTYPE_HTMLW
#define SZ_CONTENTTYPE_CDF      SZ_CONTENTTYPE_CDFW
#else
#define SZ_CONTENTTYPE_HTML     SZ_CONTENTTYPE_HTMLA
#define SZ_CONTENTTYPE_CDF      SZ_CONTENTTYPE_CDFA
#endif

#define PathIsHTMLFileA(pszPath)     PathIsContentTypeA(pszPath, SZ_CONTENTTYPE_HTMLA)
#define PathIsHTMLFileW(pszPath)     PathIsContentTypeW(pszPath, SZ_CONTENTTYPE_HTMLW)


#define StrCatA                 lstrcatA
#define StrCmpA                 lstrcmpA
#define StrCmpIA                lstrcmpiA
#define StrCpyA                 lstrcpyA
#define StrCpyNA                lstrcpynA


#define StrToLong               StrToInt
#define StrNCmp                 StrCmpN
#define StrNCmpI                StrCmpNI
#define StrNCpy                 StrCpyN
#define StrCatN                 StrNCat

#ifdef UNICODE
#define StrCat                  StrCatW
#define StrCmp                  StrCmpW
#define StrCmpI                 StrCmpIW
#define StrCpy                  StrCpyW
#define StrCpyN                 StrCpyNW
#define StrCatBuff              StrCatBuffW
#else
#define StrCat                  lstrcatA
#define StrCmp                  lstrcmpA
#define StrCmpI                 lstrcmpiA
#define StrCpy                  lstrcpyA
#define StrCpyN                 lstrcpynA
#define StrCatBuff              StrCatBuffA
#endif


#endif //  NO_SHLWAPI_STRFCNS


#ifndef NO_SHLWAPI_PATH

//
//=============== Path Routines ===================================
//

LWSTDAPI_(LPSTR)  PathAddBackslashA(__inout_ecount(MAX_PATH) LPSTR pszPath);
LWSTDAPI_(LPWSTR)  PathAddBackslashW(__inout_ecount(MAX_PATH) LPWSTR pszPath);
#ifdef UNICODE
#define PathAddBackslash  PathAddBackslashW
#else
#define PathAddBackslash  PathAddBackslashA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathAddExtensionA(__inout_ecount(MAX_PATH) LPSTR pszPath, LPCSTR pszExt);
LWSTDAPI_(BOOL)     PathAddExtensionW(__inout_ecount(MAX_PATH) LPWSTR pszPath, LPCWSTR pszExt);
#ifdef UNICODE
#define PathAddExtension  PathAddExtensionW
#else
#define PathAddExtension  PathAddExtensionA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathAppendA(__inout_ecount(MAX_PATH) LPSTR pszPath, LPCSTR pMore);
LWSTDAPI_(BOOL)     PathAppendW(__inout_ecount(MAX_PATH) LPWSTR pszPath, LPCWSTR pMore);
LWSTDAPI_(LPSTR)  PathBuildRootA(__out_ecount(4) LPSTR pszRoot, int iDrive);
LWSTDAPI_(LPWSTR)  PathBuildRootW(__out_ecount(4) LPWSTR pszRoot, int iDrive);
#ifdef UNICODE
#define PathBuildRoot  PathBuildRootW
#else
#define PathBuildRoot  PathBuildRootA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathCanonicalizeA(__out_ecount(MAX_PATH) LPSTR pszBuf, LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathCanonicalizeW(__out_ecount(MAX_PATH) LPWSTR pszBuf, LPCWSTR pszPath);
LWSTDAPI_(LPSTR)  PathCombineA(__out_ecount(MAX_PATH) LPSTR pszDest, LPCSTR pszDir, LPCSTR pszFile);
LWSTDAPI_(LPWSTR)  PathCombineW(__out_ecount(MAX_PATH) LPWSTR pszDest, LPCWSTR pszDir, LPCWSTR pszFile);
#ifdef UNICODE
#define PathCombine  PathCombineW
#else
#define PathCombine  PathCombineA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathCompactPathA(HDC hDC, __inout_ecount(MAX_PATH) LPSTR pszPath, UINT dx);
LWSTDAPI_(BOOL)     PathCompactPathW(HDC hDC, __inout_ecount(MAX_PATH) LPWSTR pszPath, UINT dx);
LWSTDAPI_(BOOL)     PathCompactPathExA(__out_ecount(cchMax) LPSTR pszOut, LPCSTR pszSrc, UINT cchMax, DWORD dwFlags);
LWSTDAPI_(BOOL)     PathCompactPathExW(__out_ecount(cchMax) LPWSTR pszOut, LPCWSTR pszSrc, UINT cchMax, DWORD dwFlags);
LWSTDAPI_(int)      PathCommonPrefixA(LPCSTR pszFile1, LPCSTR pszFile2, __out_ecount_opt(MAX_PATH)  LPSTR achPath);
LWSTDAPI_(int)      PathCommonPrefixW(LPCWSTR pszFile1, LPCWSTR pszFile2, __out_ecount_opt(MAX_PATH)  LPWSTR achPath);
LWSTDAPI_(BOOL)     PathFileExistsA(__in LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathFileExistsW(__in LPCWSTR pszPath);
#ifdef UNICODE
#define PathFileExists  PathFileExistsW
#else
#define PathFileExists  PathFileExistsA
#endif // !UNICODE
#ifdef USE_STRICT_CONST
LWSTDAPI_(LPCSTR)  PathFindExtensionA(__in LPCSTR pszPath);
LWSTDAPI_(LPCWSTR)  PathFindExtensionW(__in LPCWSTR pszPath);
#ifdef UNICODE
#define PathFindExtension  PathFindExtensionW
#else
#define PathFindExtension  PathFindExtensionA
#endif // !UNICODE
LWSTDAPI_(LPCSTR)  PathFindFileNameA(__in LPCSTR pszPath);
LWSTDAPI_(LPCWSTR)  PathFindFileNameW(__in LPCWSTR pszPath);
#ifdef UNICODE
#define PathFindFileName  PathFindFileNameW
#else
#define PathFindFileName  PathFindFileNameA
#endif // !UNICODE
LWSTDAPI_(LPCSTR)  PathFindNextComponentA(__in LPCSTR pszPath);
LWSTDAPI_(LPCWSTR)  PathFindNextComponentW(__in LPCWSTR pszPath);
#ifdef UNICODE
#define PathFindNextComponent  PathFindNextComponentW
#else
#define PathFindNextComponent  PathFindNextComponentA
#endif // !UNICODE
#else
LWSTDAPI_(LPSTR)  PathFindExtensionA(__in LPCSTR pszPath);
LWSTDAPI_(LPWSTR)  PathFindExtensionW(__in LPCWSTR pszPath);
#ifdef UNICODE
#define PathFindExtension  PathFindExtensionW
#else
#define PathFindExtension  PathFindExtensionA
#endif // !UNICODE
LWSTDAPI_(LPSTR)  PathFindFileNameA(__in LPCSTR pszPath);
LWSTDAPI_(LPWSTR)  PathFindFileNameW(__in LPCWSTR pszPath);
#ifdef UNICODE
#define PathFindFileName  PathFindFileNameW
#else
#define PathFindFileName  PathFindFileNameA
#endif // !UNICODE
LWSTDAPI_(LPSTR)  PathFindNextComponentA(__in LPCSTR pszPath);
LWSTDAPI_(LPWSTR)  PathFindNextComponentW(__in LPCWSTR pszPath);
#ifdef UNICODE
#define PathFindNextComponent  PathFindNextComponentW
#else
#define PathFindNextComponent  PathFindNextComponentA
#endif // !UNICODE
#endif
LWSTDAPI_(BOOL)     PathFindOnPathA(__inout_ecount(MAX_PATH) LPSTR pszPath, __in_opt __nullterminated LPCSTR * ppszOtherDirs);
LWSTDAPI_(BOOL)     PathFindOnPathW(__inout_ecount(MAX_PATH) LPWSTR pszPath, __in_opt __nullterminated LPCWSTR * ppszOtherDirs);
LWSTDAPI_(LPCSTR) PathFindSuffixArrayA(LPCSTR pszPath, __in_ecount(iArraySize) const LPCSTR *apszSuffix, int iArraySize);
LWSTDAPI_(LPCWSTR) PathFindSuffixArrayW(LPCWSTR pszPath, __in_ecount(iArraySize) const LPCWSTR *apszSuffix, int iArraySize);
#ifdef UNICODE
#define PathFindSuffixArray  PathFindSuffixArrayW
#else
#define PathFindSuffixArray  PathFindSuffixArrayA
#endif // !UNICODE
#ifdef USE_STRICT_CONST
LWSTDAPI_(LPCSTR)  PathGetArgsA(__in LPCSTR pszPath);
LWSTDAPI_(LPCWSTR)  PathGetArgsW(__in LPCWSTR pszPath);
#ifdef UNICODE
#define PathGetArgs  PathGetArgsW
#else
#define PathGetArgs  PathGetArgsA
#endif // !UNICODE
#else
LWSTDAPI_(LPSTR)  PathGetArgsA(__in LPCSTR pszPath);
LWSTDAPI_(LPWSTR)  PathGetArgsW(__in LPCWSTR pszPath);
#ifdef UNICODE
#define PathGetArgs  PathGetArgsW
#else
#define PathGetArgs  PathGetArgsA
#endif // !UNICODE
#endif
LWSTDAPI_(BOOL)     PathIsLFNFileSpecA(LPCSTR lpName);
LWSTDAPI_(BOOL)     PathIsLFNFileSpecW(LPCWSTR lpName);
#ifdef UNICODE
#define PathIsLFNFileSpec  PathIsLFNFileSpecW
#else
#define PathIsLFNFileSpec  PathIsLFNFileSpecA
#endif // !UNICODE
LWSTDAPI_(UINT)     PathGetCharTypeA(__in UCHAR ch);
LWSTDAPI_(UINT)     PathGetCharTypeW(__in WCHAR ch);

// Return flags for PathGetCharType
#define GCT_INVALID             0x0000
#define GCT_LFNCHAR             0x0001
#define GCT_SHORTCHAR           0x0002
#define GCT_WILD                0x0004
#define GCT_SEPARATOR           0x0008

LWSTDAPI_(int)      PathGetDriveNumberA(__in LPCSTR pszPath);
LWSTDAPI_(int)      PathGetDriveNumberW(__in LPCWSTR pszPath);
#ifdef UNICODE
#define PathGetDriveNumber  PathGetDriveNumberW
#else
#define PathGetDriveNumber  PathGetDriveNumberA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsDirectoryA(__in LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsDirectoryW(__in LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsDirectory  PathIsDirectoryW
#else
#define PathIsDirectory  PathIsDirectoryA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsDirectoryEmptyA(__in LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsDirectoryEmptyW(__in LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsDirectoryEmpty  PathIsDirectoryEmptyW
#else
#define PathIsDirectoryEmpty  PathIsDirectoryEmptyA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsFileSpecA(__in LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsFileSpecW(__in LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsFileSpec  PathIsFileSpecW
#else
#define PathIsFileSpec  PathIsFileSpecA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsPrefixA(__in LPCSTR pszPrefix, __in LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsPrefixW(__in LPCWSTR pszPrefix, __in LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsPrefix  PathIsPrefixW
#else
#define PathIsPrefix  PathIsPrefixA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsRelativeA(__in LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsRelativeW(__in LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsRelative  PathIsRelativeW
#else
#define PathIsRelative  PathIsRelativeA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsRootA(__in LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsRootW(__in LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsRoot  PathIsRootW
#else
#define PathIsRoot  PathIsRootA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsSameRootA(__in LPCSTR pszPath1, __in LPCSTR pszPath2);
LWSTDAPI_(BOOL)     PathIsSameRootW(__in LPCWSTR pszPath1, __in LPCWSTR pszPath2);
#ifdef UNICODE
#define PathIsSameRoot  PathIsSameRootW
#else
#define PathIsSameRoot  PathIsSameRootA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsUNCA(__in LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsUNCW(__in LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsUNC  PathIsUNCW
#else
#define PathIsUNC  PathIsUNCA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsNetworkPathA(__in LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsNetworkPathW(__in LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsNetworkPath  PathIsNetworkPathW
#else
#define PathIsNetworkPath  PathIsNetworkPathA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsUNCServerA(__in LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsUNCServerW(__in LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsUNCServer  PathIsUNCServerW
#else
#define PathIsUNCServer  PathIsUNCServerA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsUNCServerShareA(__in LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsUNCServerShareW(__in LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsUNCServerShare  PathIsUNCServerShareW
#else
#define PathIsUNCServerShare  PathIsUNCServerShareA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsContentTypeA(__in LPCSTR pszPath, __in LPCSTR pszContentType);
LWSTDAPI_(BOOL)     PathIsContentTypeW(__in LPCWSTR pszPath, __in LPCWSTR pszContentType);
LWSTDAPI_(BOOL)     PathIsURLA(__in LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsURLW(__in LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsURL  PathIsURLW
#else
#define PathIsURL  PathIsURLA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathMakePrettyA(__inout LPSTR pszPath);
LWSTDAPI_(BOOL)     PathMakePrettyW(__inout LPWSTR pszPath);
LWSTDAPI_(BOOL)     PathMatchSpecA(__in LPCSTR pszFile, __in LPCSTR pszSpec);
LWSTDAPI_(BOOL)     PathMatchSpecW(__in LPCWSTR pszFile, __in LPCWSTR pszSpec);

#if (_WIN32_IE >= _WIN32_IE_IE70)
// Flags for PathMatchSpecEx
#define PMSF_NORMAL            0x00000000
#define PMSF_MULTIPLE          0x00000001
#define PMSF_DONT_STRIP_SPACES 0x00010000  // modifies either of the above

LWSTDAPI PathMatchSpecExA(LPCSTR pszFile, LPCSTR pszSpec, DWORD dwFlags);
LWSTDAPI PathMatchSpecExW(LPCWSTR pszFile, LPCWSTR pszSpec, DWORD dwFlags);
#endif // _WIN32_IE_IE70

LWSTDAPI_(int)      PathParseIconLocationA(__inout LPSTR pszIconFile);
LWSTDAPI_(int)      PathParseIconLocationW(__inout LPWSTR pszIconFile);
LWSTDAPI_(BOOL)     PathQuoteSpacesA(__inout_ecount(MAX_PATH) LPSTR lpsz);
LWSTDAPI_(BOOL)     PathQuoteSpacesW(__inout_ecount(MAX_PATH) LPWSTR lpsz);
LWSTDAPI_(BOOL)     PathRelativePathToA(__out_ecount(MAX_PATH) LPSTR pszPath, LPCSTR pszFrom, DWORD dwAttrFrom, LPCSTR pszTo, DWORD dwAttrTo);
LWSTDAPI_(BOOL)     PathRelativePathToW(__out_ecount(MAX_PATH) LPWSTR pszPath, LPCWSTR pszFrom, DWORD dwAttrFrom, LPCWSTR pszTo, DWORD dwAttrTo);
LWSTDAPI_(void)     PathRemoveArgsA(__inout LPSTR pszPath);
LWSTDAPI_(void)     PathRemoveArgsW(__inout LPWSTR pszPath);
LWSTDAPI_(LPSTR)  PathRemoveBackslashA(__inout LPSTR pszPath);
LWSTDAPI_(LPWSTR)  PathRemoveBackslashW(__inout LPWSTR pszPath);
#ifdef UNICODE
#define PathRemoveBackslash  PathRemoveBackslashW
#else
#define PathRemoveBackslash  PathRemoveBackslashA
#endif // !UNICODE
LWSTDAPI_(void)     PathRemoveBlanksA(__inout LPSTR pszPath);
LWSTDAPI_(void)     PathRemoveBlanksW(__inout LPWSTR pszPath);
LWSTDAPI_(void)     PathRemoveExtensionA(__inout LPSTR pszPath);
LWSTDAPI_(void)     PathRemoveExtensionW(__inout LPWSTR pszPath);
LWSTDAPI_(BOOL)     PathRemoveFileSpecA(__inout LPSTR pszPath);
LWSTDAPI_(BOOL)     PathRemoveFileSpecW(__inout LPWSTR pszPath);
LWSTDAPI_(BOOL)     PathRenameExtensionA(__inout_ecount(MAX_PATH) LPSTR pszPath, LPCSTR pszExt);
LWSTDAPI_(BOOL)     PathRenameExtensionW(__inout_ecount(MAX_PATH) LPWSTR pszPath, LPCWSTR pszExt);
LWSTDAPI_(BOOL)     PathSearchAndQualifyA(LPCSTR pszPath, __out_ecount(cchBuf) LPSTR pszBuf, UINT cchBuf);
LWSTDAPI_(BOOL)     PathSearchAndQualifyW(LPCWSTR pszPath, __out_ecount(cchBuf) LPWSTR pszBuf, UINT cchBuf);
LWSTDAPI_(void)     PathSetDlgItemPathA(__in HWND hDlg, int id, LPCSTR pszPath);
LWSTDAPI_(void)     PathSetDlgItemPathW(__in HWND hDlg, int id, LPCWSTR pszPath);
#ifdef USE_STRICT_CONST
LWSTDAPI_(LPCSTR)  PathSkipRootA(LPCSTR pszPath);
LWSTDAPI_(LPCWSTR)  PathSkipRootW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathSkipRoot  PathSkipRootW
#else
#define PathSkipRoot  PathSkipRootA
#endif // !UNICODE
#else
LWSTDAPI_(LPSTR)  PathSkipRootA(LPCSTR pszPath);
LWSTDAPI_(LPWSTR)  PathSkipRootW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathSkipRoot  PathSkipRootW
#else
#define PathSkipRoot  PathSkipRootA
#endif // !UNICODE
#endif
LWSTDAPI_(void)     PathStripPathA(__inout LPSTR pszPath);
LWSTDAPI_(void)     PathStripPathW(__inout LPWSTR pszPath);
#ifdef UNICODE
#define PathStripPath  PathStripPathW
#else
#define PathStripPath  PathStripPathA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathStripToRootA(__inout LPSTR pszPath);
LWSTDAPI_(BOOL)     PathStripToRootW(__inout LPWSTR pszPath);
#ifdef UNICODE
#define PathStripToRoot  PathStripToRootW
#else
#define PathStripToRoot  PathStripToRootA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathUnquoteSpacesA(__inout LPSTR lpsz);
LWSTDAPI_(BOOL)     PathUnquoteSpacesW(__inout LPWSTR lpsz);
LWSTDAPI_(BOOL)     PathMakeSystemFolderA(LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathMakeSystemFolderW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathMakeSystemFolder  PathMakeSystemFolderW
#else
#define PathMakeSystemFolder  PathMakeSystemFolderA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathUnmakeSystemFolderA(LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathUnmakeSystemFolderW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathUnmakeSystemFolder  PathUnmakeSystemFolderW
#else
#define PathUnmakeSystemFolder  PathUnmakeSystemFolderA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsSystemFolderA(LPCSTR pszPath, DWORD dwAttrb);
LWSTDAPI_(BOOL)     PathIsSystemFolderW(LPCWSTR pszPath, DWORD dwAttrb);
#ifdef UNICODE
#define PathIsSystemFolder  PathIsSystemFolderW
#else
#define PathIsSystemFolder  PathIsSystemFolderA
#endif // !UNICODE
LWSTDAPI_(void)     PathUndecorateA(__inout LPSTR pszPath);
LWSTDAPI_(void)     PathUndecorateW(__inout LPWSTR pszPath);
#ifdef UNICODE
#define PathUndecorate  PathUndecorateW
#else
#define PathUndecorate  PathUndecorateA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathUnExpandEnvStringsA(LPCSTR pszPath, __out_ecount(cchBuf) LPSTR pszBuf, UINT cchBuf);
LWSTDAPI_(BOOL)     PathUnExpandEnvStringsW(LPCWSTR pszPath, __out_ecount(cchBuf) LPWSTR pszBuf, UINT cchBuf);
#ifdef UNICODE
#define PathUnExpandEnvStrings  PathUnExpandEnvStringsW
#else
#define PathUnExpandEnvStrings  PathUnExpandEnvStringsA
#endif // !UNICODE


#ifdef UNICODE
#define PathAppend              PathAppendW
#define PathCanonicalize        PathCanonicalizeW
#define PathCompactPath         PathCompactPathW
#define PathCompactPathEx       PathCompactPathExW
#define PathCommonPrefix        PathCommonPrefixW
#define PathFindOnPath          PathFindOnPathW
#define PathGetCharType         PathGetCharTypeW
#define PathIsContentType       PathIsContentTypeW
#define PathIsHTMLFile          PathIsHTMLFileW
#define PathMakePretty          PathMakePrettyW
#define PathMatchSpec           PathMatchSpecW
#if (_WIN32_IE >= _WIN32_IE_IE70)
#define PathMatchSpecEx         PathMatchSpecExW
#endif // _WIN32_IE_IE70
#define PathParseIconLocation   PathParseIconLocationW
#define PathQuoteSpaces         PathQuoteSpacesW
#define PathRelativePathTo      PathRelativePathToW
#define PathRemoveArgs          PathRemoveArgsW
#define PathRemoveBlanks        PathRemoveBlanksW
#define PathRemoveExtension     PathRemoveExtensionW
#define PathRemoveFileSpec      PathRemoveFileSpecW
#define PathRenameExtension     PathRenameExtensionW
#define PathSearchAndQualify    PathSearchAndQualifyW
#define PathSetDlgItemPath      PathSetDlgItemPathW
#define PathUnquoteSpaces       PathUnquoteSpacesW
#else
#define PathAppend              PathAppendA
#define PathCanonicalize        PathCanonicalizeA
#define PathCompactPath         PathCompactPathA
#define PathCompactPathEx       PathCompactPathExA
#define PathCommonPrefix        PathCommonPrefixA
#define PathFindOnPath          PathFindOnPathA
#define PathGetCharType         PathGetCharTypeA
#define PathIsContentType       PathIsContentTypeA
#define PathIsHTMLFile          PathIsHTMLFileA
#define PathMakePretty          PathMakePrettyA
#define PathMatchSpec           PathMatchSpecA
#if (_WIN32_IE >= _WIN32_IE_IE70)
#define PathMatchSpecEx         PathMatchSpecExA
#endif // _WIN32_IE_IE70
#define PathParseIconLocation   PathParseIconLocationA
#define PathQuoteSpaces         PathQuoteSpacesA
#define PathRelativePathTo      PathRelativePathToA
#define PathRemoveArgs          PathRemoveArgsA
#define PathRemoveBlanks        PathRemoveBlanksA
#define PathRemoveExtension     PathRemoveExtensionA
#define PathRemoveFileSpec      PathRemoveFileSpecA
#define PathRenameExtension     PathRenameExtensionA
#define PathSearchAndQualify    PathSearchAndQualifyA
#define PathSetDlgItemPath      PathSetDlgItemPathA
#define PathUnquoteSpaces       PathUnquoteSpacesA
#endif

typedef enum {
    URL_SCHEME_INVALID     = -1,
    URL_SCHEME_UNKNOWN     =  0,
    URL_SCHEME_FTP,
    URL_SCHEME_HTTP,
    URL_SCHEME_GOPHER,
    URL_SCHEME_MAILTO,
    URL_SCHEME_NEWS,
    URL_SCHEME_NNTP,
    URL_SCHEME_TELNET,
    URL_SCHEME_WAIS,
    URL_SCHEME_FILE,
    URL_SCHEME_MK,
    URL_SCHEME_HTTPS,
    URL_SCHEME_SHELL,
    URL_SCHEME_SNEWS,
    URL_SCHEME_LOCAL,
    URL_SCHEME_JAVASCRIPT,
    URL_SCHEME_VBSCRIPT,
    URL_SCHEME_ABOUT,
    URL_SCHEME_RES,
#if (_WIN32_IE >= _WIN32_IE_IE60)
    URL_SCHEME_MSSHELLROOTED,
    URL_SCHEME_MSSHELLIDLIST,
    URL_SCHEME_MSHELP,
#endif // _WIN32_IE_IE60
#if (_WIN32_IE >= _WIN32_IE_IE70)
    URL_SCHEME_MSSHELLDEVICE,
    URL_SCHEME_WILDCARD,
#endif // _WIN32_IE_IE70
    URL_SCHEME_SEARCH_MS,
    URL_SCHEME_SEARCH,
    URL_SCHEME_MAXVALUE,
} URL_SCHEME;

typedef enum {
    URL_PART_NONE       = 0,
    URL_PART_SCHEME     = 1,
    URL_PART_HOSTNAME,
    URL_PART_USERNAME,
    URL_PART_PASSWORD,
    URL_PART_PORT,
    URL_PART_QUERY,
} URL_PART;

typedef enum {
    URLIS_URL,
    URLIS_OPAQUE,
    URLIS_NOHISTORY,
    URLIS_FILEURL,
    URLIS_APPLIABLE,
    URLIS_DIRECTORY,
    URLIS_HASQUERY,
} URLIS;

#define URL_UNESCAPE                    0x10000000
#define URL_ESCAPE_UNSAFE               0x20000000
#define URL_PLUGGABLE_PROTOCOL          0x40000000
#define URL_WININET_COMPATIBILITY       0x80000000
#define URL_DONT_ESCAPE_EXTRA_INFO      0x02000000
#define URL_DONT_UNESCAPE_EXTRA_INFO    URL_DONT_ESCAPE_EXTRA_INFO
#define URL_BROWSER_MODE                URL_DONT_ESCAPE_EXTRA_INFO
#define URL_ESCAPE_SPACES_ONLY          0x04000000
#define URL_DONT_SIMPLIFY               0x08000000
#define URL_NO_META                     URL_DONT_SIMPLIFY
#define URL_UNESCAPE_INPLACE            0x00100000
#define URL_CONVERT_IF_DOSPATH          0x00200000
#define URL_UNESCAPE_HIGH_ANSI_ONLY     0x00400000
#define URL_INTERNAL_PATH               0x00800000  // Will escape #'s in paths
#define URL_FILE_USE_PATHURL            0x00010000
#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
#define URL_DONT_UNESCAPE               0x00020000  // Do not unescape the path/url at all
#endif // _WIN32_IE_IE60SP2
#define URL_ESCAPE_PERCENT              0x00001000
#define URL_ESCAPE_SEGMENT_ONLY         0x00002000  // Treat the entire URL param as one URL segment.

#define URL_PARTFLAG_KEEPSCHEME         0x00000001

#define URL_APPLY_DEFAULT               0x00000001
#define URL_APPLY_GUESSSCHEME           0x00000002
#define URL_APPLY_GUESSFILE             0x00000004
#define URL_APPLY_FORCEAPPLY            0x00000008


LWSTDAPI_(int)          UrlCompareA(__in LPCSTR psz1, __in LPCSTR psz2, __in BOOL fIgnoreSlash);
LWSTDAPI_(int)          UrlCompareW(__in LPCWSTR psz1, __in  LPCWSTR psz2, __in BOOL fIgnoreSlash);
LWSTDAPI                UrlCombineA(LPCSTR pszBase, LPCSTR pszRelative, __out_ecount_opt(*pcchCombined) LPSTR pszCombined, __inout LPDWORD pcchCombined, DWORD dwFlags);
LWSTDAPI                UrlCombineW(LPCWSTR pszBase, LPCWSTR pszRelative, __out_ecount_opt(*pcchCombined) LPWSTR pszCombined, __inout LPDWORD pcchCombined, DWORD dwFlags);
LWSTDAPI                UrlCanonicalizeA(LPCSTR pszUrl, __out_ecount(*pcchCanonicalized) LPSTR pszCanonicalized, __inout LPDWORD pcchCanonicalized, DWORD dwFlags);
LWSTDAPI                UrlCanonicalizeW(LPCWSTR pszUrl, __out_ecount(*pcchCanonicalized) LPWSTR pszCanonicalized, __inout LPDWORD pcchCanonicalized, DWORD dwFlags);
LWSTDAPI_(BOOL)         UrlIsOpaqueA(LPCSTR pszURL);
LWSTDAPI_(BOOL)         UrlIsOpaqueW(LPCWSTR pszURL);
LWSTDAPI_(BOOL)         UrlIsNoHistoryA(LPCSTR pszURL);
LWSTDAPI_(BOOL)         UrlIsNoHistoryW(LPCWSTR pszURL);
#define                 UrlIsFileUrlA(pszURL) UrlIsA(pszURL, URLIS_FILEURL)
#define                 UrlIsFileUrlW(pszURL) UrlIsW(pszURL, URLIS_FILEURL)
LWSTDAPI_(BOOL)         UrlIsA(LPCSTR pszUrl, __in URLIS UrlIs);
LWSTDAPI_(BOOL)         UrlIsW(LPCWSTR pszUrl, __in URLIS UrlIs);
LWSTDAPI_(LPCSTR)       UrlGetLocationA(LPCSTR psz1);
LWSTDAPI_(LPCWSTR)      UrlGetLocationW(LPCWSTR psz1);
LWSTDAPI                UrlUnescapeA(__inout LPSTR pszUrl, __out_ecount_opt(*pcchUnescaped) LPSTR pszUnescaped, __inout_opt LPDWORD pcchUnescaped, DWORD dwFlags);
LWSTDAPI                UrlUnescapeW(__inout LPWSTR pszUrl, __out_ecount_opt(*pcchUnescaped) LPWSTR pszUnescaped, __inout_opt LPDWORD pcchUnescaped, DWORD dwFlags);
LWSTDAPI                UrlEscapeA(LPCSTR pszUrl, __out_ecount(*pcchEscaped) LPSTR pszEscaped, __inout LPDWORD pcchEscaped, DWORD dwFlags);
LWSTDAPI                UrlEscapeW(LPCWSTR pszUrl, __out_ecount(*pcchEscaped) LPWSTR pszEscaped, __inout LPDWORD pcchEscaped, DWORD dwFlags);
LWSTDAPI                UrlCreateFromPathA(LPCSTR pszPath, __out_ecount(*pcchUrl) LPSTR pszUrl, __inout LPDWORD pcchUrl, DWORD dwFlags);
LWSTDAPI                UrlCreateFromPathW(LPCWSTR pszPath, __out_ecount(*pcchUrl) LPWSTR pszUrl, __inout LPDWORD pcchUrl, DWORD dwFlags);
LWSTDAPI                PathCreateFromUrlA(LPCSTR pszUrl, __out_ecount(*pcchPath) LPSTR pszPath, __inout LPDWORD pcchPath, DWORD dwFlags);
LWSTDAPI                PathCreateFromUrlW(LPCWSTR pszUrl, __out_ecount(*pcchPath) LPWSTR pszPath, __inout LPDWORD pcchPath, DWORD dwFlags);
#if (_WIN32_IE >= _WIN32_IE_IE70)
LWSTDAPI                PathCreateFromUrlAlloc(LPCWSTR pszIn, __out LPWSTR *ppszOut, DWORD dwFlags);
#endif // _WIN32_IE_IE70
LWSTDAPI                UrlHashA(LPCSTR pszUrl, __out_ecount(cbHash) LPBYTE pbHash, DWORD cbHash);
LWSTDAPI                UrlHashW(LPCWSTR pszUrl, __out_ecount(cbHash) LPBYTE pbHash, DWORD cbHash);
LWSTDAPI                UrlGetPartW(LPCWSTR pszIn, __out_ecount(*pcchOut) LPWSTR pszOut, __inout LPDWORD pcchOut, DWORD dwPart, DWORD dwFlags);
LWSTDAPI                UrlGetPartA(LPCSTR pszIn, __out_ecount(*pcchOut) LPSTR pszOut, __inout LPDWORD pcchOut, DWORD dwPart, DWORD dwFlags);
LWSTDAPI                UrlApplySchemeA(LPCSTR pszIn, __out_ecount(*pcchOut) LPSTR pszOut, __inout LPDWORD pcchOut, DWORD dwFlags);
LWSTDAPI                UrlApplySchemeW(LPCWSTR pszIn, __out_ecount(*pcchOut) LPWSTR pszOut, __inout LPDWORD pcchOut, DWORD dwFlags);
LWSTDAPI                HashData(__in_ecount(cbData) LPBYTE pbData, DWORD cbData, __out_ecount(cbHash) LPBYTE pbHash, DWORD cbHash);
LWSTDAPI                UrlFixupW(LPCWSTR pszIn, __out_ecount(cchOut) LPWSTR pszOut, DWORD cchOut);


#ifdef UNICODE
#define UrlCompare              UrlCompareW
#define UrlCombine              UrlCombineW
#define UrlCanonicalize         UrlCanonicalizeW
#define UrlIsOpaque             UrlIsOpaqueW
#define UrlIsFileUrl            UrlIsFileUrlW
#define UrlGetLocation          UrlGetLocationW
#define UrlUnescape             UrlUnescapeW
#define UrlEscape               UrlEscapeW
#define UrlCreateFromPath       UrlCreateFromPathW
#define PathCreateFromUrl       PathCreateFromUrlW
#define UrlHash                 UrlHashW
#define UrlGetPart              UrlGetPartW
#define UrlApplyScheme          UrlApplySchemeW
#define UrlIs                   UrlIsW
#define UrlFixup                UrlFixupW
#else //!UNICODE
#define UrlCompare              UrlCompareA
#define UrlCombine              UrlCombineA
#define UrlCanonicalize         UrlCanonicalizeA
#define UrlIsOpaque             UrlIsOpaqueA
#define UrlIsFileUrl            UrlIsFileUrlA
#define UrlGetLocation          UrlGetLocationA
#define UrlUnescape             UrlUnescapeA
#define UrlEscape               UrlEscapeA
#define UrlCreateFromPath       UrlCreateFromPathA
#define PathCreateFromUrl       PathCreateFromUrlA
#define UrlHash                 UrlHashA
#define UrlGetPart              UrlGetPartA
#define UrlApplyScheme          UrlApplySchemeA
#define UrlIs                   UrlIsA
// no UrlFixupA
#endif //UNICODE

#define UrlEscapeSpaces(pszUrl, pszEscaped, pcchEscaped)        UrlCanonicalize(pszUrl, pszEscaped, pcchEscaped, URL_ESCAPE_SPACES_ONLY |URL_DONT_ESCAPE_EXTRA_INFO )
#define UrlUnescapeInPlace(pszUrl, dwFlags)                     UrlUnescape(pszUrl, NULL, NULL, dwFlags | URL_UNESCAPE_INPLACE)


#if (_WIN32_IE >= _WIN32_IE_IE50)

typedef struct tagPARSEDURLA {
    DWORD     cbSize;
    // Pointers into the buffer that was provided to ParseURL
    LPCSTR    pszProtocol;
    UINT      cchProtocol;
    LPCSTR    pszSuffix;
    UINT      cchSuffix;
    UINT      nScheme;            // One of URL_SCHEME_*
    } PARSEDURLA, * PPARSEDURLA;
typedef struct tagPARSEDURLW {
    DWORD     cbSize;
    // Pointers into the buffer that was provided to ParseURL
    LPCWSTR   pszProtocol;
    UINT      cchProtocol;
    LPCWSTR   pszSuffix;
    UINT      cchSuffix;
    UINT      nScheme;            // One of URL_SCHEME_*
    } PARSEDURLW, * PPARSEDURLW;
#ifdef UNICODE
typedef PARSEDURLW PARSEDURL;
typedef PPARSEDURLW PPARSEDURL;
#else
typedef PARSEDURLA PARSEDURL;
typedef PPARSEDURLA PPARSEDURL;
#endif // UNICODE

LWSTDAPI            ParseURLA(LPCSTR pcszURL, __inout PARSEDURLA * ppu);
LWSTDAPI            ParseURLW(LPCWSTR pcszURL, __inout PARSEDURLW * ppu);
#ifdef UNICODE
#define ParseURL  ParseURLW
#else
#define ParseURL  ParseURLA
#endif // !UNICODE

#endif  // _WIN32_IE_IE50


#endif //  NO_SHLWAPI_PATH



#ifndef NO_SHLWAPI_REG
//
//=============== Registry Routines ===================================
//


// SHDeleteEmptyKey mimics RegDeleteKey as it behaves on NT.
// SHDeleteKey mimics RegDeleteKey as it behaves on Win95.

LWSTDAPI_(LSTATUS)  SHDeleteEmptyKeyA(__in HKEY hkey, __in_opt LPCSTR pszSubKey);
LWSTDAPI_(LSTATUS)  SHDeleteEmptyKeyW(__in HKEY hkey, __in_opt LPCWSTR pszSubKey);
#ifdef UNICODE
#define SHDeleteEmptyKey  SHDeleteEmptyKeyW
#else
#define SHDeleteEmptyKey  SHDeleteEmptyKeyA
#endif // !UNICODE
LWSTDAPI_(LSTATUS)  SHDeleteKeyA(__in HKEY hkey, __in_opt LPCSTR pszSubKey);
LWSTDAPI_(LSTATUS)  SHDeleteKeyW(__in HKEY hkey, __in_opt LPCWSTR pszSubKey);
#ifdef UNICODE
#define SHDeleteKey  SHDeleteKeyW
#else
#define SHDeleteKey  SHDeleteKeyA
#endif // !UNICODE
LWSTDAPI_(HKEY)     SHRegDuplicateHKey(__in HKEY hkey);


// These functions open the key, get/set/delete the value, then close
// the key.

LWSTDAPI_(LSTATUS)    SHDeleteValueA(__in HKEY hkey, __in_opt LPCSTR pszSubKey, __in_opt LPCSTR pszValue);
LWSTDAPI_(LSTATUS)    SHDeleteValueW(__in HKEY hkey, __in_opt LPCWSTR pszSubKey, __in_opt LPCWSTR pszValue);
#ifdef UNICODE
#define SHDeleteValue  SHDeleteValueW
#else
#define SHDeleteValue  SHDeleteValueA
#endif // !UNICODE
LWSTDAPI_(LSTATUS)    SHGetValueA(
    __in                       HKEY hkey,
    __in_opt                   LPCSTR  pszSubKey,
    __in_opt                   LPCSTR  pszValue,
    __out_opt                  DWORD    *pdwType,
    __out_bcount_opt(*pcbData) void     *pvData,
    __inout_opt                DWORD    *pcbData);
LWSTDAPI_(LSTATUS)    SHGetValueW(
    __in                       HKEY hkey,
    __in_opt                   LPCWSTR  pszSubKey,
    __in_opt                   LPCWSTR  pszValue,
    __out_opt                  DWORD    *pdwType,
    __out_bcount_opt(*pcbData) void     *pvData,
    __inout_opt                DWORD    *pcbData);
#ifdef UNICODE
#define SHGetValue  SHGetValueW
#else
#define SHGetValue  SHGetValueA
#endif // !UNICODE
LWSTDAPI_(LSTATUS)    SHSetValueA(__in HKEY hkey, __in_opt LPCSTR pszSubKey, __in_opt LPCSTR pszValue, __in DWORD dwType,
    __typefix(LPBYTE) __in_bcount_opt(cbData) LPCVOID pvData, __in_opt DWORD cbData);
LWSTDAPI_(LSTATUS)    SHSetValueW(__in HKEY hkey, __in_opt LPCWSTR pszSubKey, __in_opt LPCWSTR pszValue, __in DWORD dwType,
    __typefix(LPBYTE) __in_bcount_opt(cbData) LPCVOID pvData, __in_opt DWORD cbData);
#ifdef UNICODE
#define SHSetValue  SHSetValueW
#else
#define SHSetValue  SHSetValueA
#endif // !UNICODE

#if (_WIN32_IE >= 0x0602)
//
// SRRF - Shell Registry Routine Flags (for SHRegGetValue)
//

typedef int SRRF;

#define SRRF_RT_REG_NONE        0x00000001  // restrict type to REG_NONE      (other data types will not return ERROR_SUCCESS)
#define SRRF_RT_REG_SZ          0x00000002  // restrict type to REG_SZ        (other data types will not return ERROR_SUCCESS) (automatically converts REG_EXPAND_SZ to REG_SZ unless SRRF_NOEXPAND is specified)
#define SRRF_RT_REG_EXPAND_SZ   0x00000004  // restrict type to REG_EXPAND_SZ (other data types will not return ERROR_SUCCESS) (must specify SRRF_NOEXPAND or SHRegGetValue will fail with ERROR_INVALID_PARAMETER)
#define SRRF_RT_REG_BINARY      0x00000008  // restrict type to REG_BINARY    (other data types will not return ERROR_SUCCESS)
#define SRRF_RT_REG_DWORD       0x00000010  // restrict type to REG_DWORD     (other data types will not return ERROR_SUCCESS)
#define SRRF_RT_REG_MULTI_SZ    0x00000020  // restrict type to REG_MULTI_SZ  (other data types will not return ERROR_SUCCESS)
#define SRRF_RT_REG_QWORD       0x00000040  // restrict type to REG_QWORD     (other data types will not return ERROR_SUCCESS)

#define SRRF_RT_DWORD           (SRRF_RT_REG_BINARY | SRRF_RT_REG_DWORD) // restrict type to *32-bit* SRRF_RT_REG_BINARY or SRRF_RT_REG_DWORD (other data types will not return ERROR_SUCCESS)
#define SRRF_RT_QWORD           (SRRF_RT_REG_BINARY | SRRF_RT_REG_QWORD) // restrict type to *64-bit* SRRF_RT_REG_BINARY or SRRF_RT_REG_DWORD (other data types will not return ERROR_SUCCESS)
#define SRRF_RT_ANY             0x0000ffff                               // no type restriction

#define SRRF_RM_ANY             0x00000000  // no mode restriction (default is to allow any mode)
#define SRRF_RM_NORMAL          0x00010000  // restrict system startup mode to "normal boot"               (other startup modes will not return ERROR_SUCCESS)
#define SRRF_RM_SAFE            0x00020000  // restrict system startup mode to "safe mode"                 (other startup modes will not return ERROR_SUCCESS)
#define SRRF_RM_SAFENETWORK     0x00040000  // restrict system startup mode to "safe mode with networking" (other startup modes will not return ERROR_SUCCESS)

#define SRRF_NOEXPAND           0x10000000  // do not automatically expand environment strings if value is of type REG_EXPAND_SZ
#define SRRF_ZEROONFAILURE      0x20000000  // if pvData is not NULL, set content to all zeros on failure
#define SRRF_NOVIRT             0x40000000  // if the requested key is virtualized, then fail with ERROR_FILE_NOT_FOUND


// Function:
//
//  SHRegGetValue()
//
// Purpose:
//
//  Gets a registry value.  SHRegGetValue() provides the following benefits:
//
//  - data type checking
//  - boot mode checking
//  - auto-expansion of REG_EXPAND_SZ data
//  - guaranteed NULL termination of REG_SZ, REG_EXPAND_SZ, REG_MULTI_SZ data
//
// Parameters:
//
//  hkey        - handle to a currently open key.
//
//  pszSubKey   - pointer to a null-terminated string specifying the relative
//                path from hkey to one of its subkeys from which the data is
//                to be retrieved.  this will be opened with KEY_READ sam.
//
//                Note1: pszSubKey can be NULL or "".  In either of these two
//                       cases, the data is retrieved from the hkey itself.
//                Note2: *** PERF ***
//                       If pszSubKey is not NULL or "", the subkey will be
//                       automatically be opened and closed by this routine
//                       in order to obtain the data.  If you are retrieving
//                       multiple values from the same subkey, it is better
//                       for perf to open the subkey via RegOpenKeyEx() prior
//                       to calling this method, and using this opened key as
//                       hkey with pszSubKey set to NULL.
//
//  pszValue    - pointer to a null-terminated string specifying the name of
//                the value to query for data
//
//                Note1: pszValue can be NULL or "".  In either of these two
//                       cases, the data is retrieved from the unnamed or
//                       default value.
//
//  srrfFlags   - bitwise or of SRRF_ flags, which cannot be 0:  at least one
//                type restriction must be specified (SRRF_RT_...), or if any
//                type is desired then SRRF_RT_ANY can be specified
//
//                Note1: SRRF_RT_ANY will allow any data type to be returned.
//                Note2: The following two type restrictions have special
//                       handling semantics:
//
//                         SRRF_RT_DWORD == SRRF_RT_REG_BINARY | SRRF_RT_REG_DWORD
//                         SRRF_RT_QWORD == SRRF_RT_REG_BINARY | SRRF_RT_REG_QWORD
//
//                       If either of these are specified, with no other type
//                       restrictions, then in the prior case the restriction
//                       will limit "valid" returned data to either REG_DWORD
//                       or 32-bit REG_BINARY data, and in the latter case
//                       the restriction will limit "valid" returned data to
//                       either REG_QWORD or 64-bit REG_BINARY.
//
//  pdwType     - pointer to a dword which receives a code indicating the
//                type of data stored in the specified value
//
//                Note1: pdwType can be NULL if no type information is wanted
//                Note2: If pdwType is not NULL, and the SRRF_NOEXPAND flag
//                       has not been set, data types of REG_EXPAND_SZ will
//                       be returned as REG_SZ since they are automatically
//                       expanded in this method.
//
//  pvData      - pointer to a buffer that receives the value's data
//
//                Note1: pvData can be NULL if the data is not required.
//                       pvData is usually NULL if doing either a simple
//                       existence test, or if interested in the size only.
//                Note2: *** PERF ***
//                       Reference 'perf' note for pcbData.
//
//  pcbData     - when pvData is NULL:
//                  optional pointer to a dword that receives a size in bytes
//                  which would be sufficient to hold the registry data (note
//                  this size is not guaranteed to be exact, merely sufficient)
//                when pvData is not NULL:
//                  required pointer to a dword that specifies the size in
//                  bytes of the buffer pointed to by the pvData parameter
//                  and receives a size in bytes of:
//                  a) the number of bytes read into pvData on ERROR_SUCCESS
//                     (note this size is guaranteed to be exact)
//                  b) the number of bytes which would be sufficient to hold
//                     the registry data on ERROR_MORE_DATA -- pvData was of
//                     insufficient size (note this size is not guaranteed to
//                     be exact, merely sufficient)
//
//                Note1: pcbData can be NULL only if pvData is NULL.
//                Note2: *** PERF ***
//                       The potential for an 'extra' call to the registry to
//                       read (or re-read) in the data exists when the data
//                       type is REG_EXPAND_SZ and the SRRF_NOEXPAND flag has
//                       not been set.  The following conditions will result
//                       in this 'extra' read operation:
//                       i)  when pvData is NULL and pcbData is not NULL
//                           we must read in the data from the registry
//                           anyway in order to obtain the string and perform
//                           an expand on it to obtain and return the total
//                           required size in pcbData
//                       ii) when pvData is not NULL but is of insufficient
//                           size we must re-read in the data from the
//                           registry in order to obtain the entire string
//                           and perform an expand on it to obtain and return
//                           the total required size in pcbData
//
// Remarks:
//
//  The key identified by hkey must have been opened with KEY_QUERY_VALUE
//  access.  If pszSubKey is not NULL or "", it must be able to be opened
//  with KEY_QUERY_VALUE access in the current calling context.
//
//  If the data type is REG_SZ, REG_EXPAND_SZ or REG_MULTI_SZ then any
//  returned data is guaranteed to take into account proper null termination.
//  For example:  if pcbData is not NULL, its returned size will include the
//  bytes for a null terminator  if pvData is not NULL, its returned data
//  will be properly null terminated.
//
//  If the data type is REG_EXPAND_SZ, then unless the SRRF_NOEXPAND flag
//  is set the data will be automatically expanded prior to being returned.
//  For example:  if pdwType is not NULL, its returned type will be changed
//  to REG_SZ,  if pcbData is not NULL, its returned size will include the
//  bytes for a properly expanded string.  if pvData is not NULL, its
//  returned data will be the expanded version of the string.
//
//  Reference MSDN documentation for RegQueryValueEx() for more information
//  of the behaviour when pdwType, pvData, and/or pcbData are equal to NULL.
//
// Return Values:
//
//  If the function succeeds, the return value is ERROR_SUCCESS and all out
//  parameters requested (pdwType, pvData, pcbData) are valid.
//
//  If the function fails due to insufficient space in a provided non-NULL
//  pvData, the return value is ERROR_MORE_DATA and only pdwType and pcbData
//  can contain valid data.  The content of pvData in this case is undefined.
//
// Examples:
//
//  1) read REG_SZ (or REG_EXPAND_SZ as REG_SZ) "string" data from the (default) value of an open hkey
//
//      TCHAR szData[128]
//      DWORD cbData = sizeof(pszData)
//      if (ERROR_SUCCESS == SHRegGetValue(hkey, NULL, NULL, SRRF_RT_REG_SZ, NULL, szData, &cbData))
//      {
//          // use sz (successful read)
//      }
//
//  2) read REG_SZ (or REG_EXPAND_SZ as REG_SZ) "string" data of unknown size from the "MyValue" value of an open hkey
//
//      DWORD cbData
//      if (ERROR_SUCCESS == SHRegGetValue(hkey, NULL, TEXT("MyValue"), SRRF_RT_REG_SZ, NULL, NULL, &cbData))
//      {
//          TCHAR *pszData = new TCHAR[cbData/sizeof(TCHAR)]
//          if (pszData)
//          {
//              if (ERROR_SUCCESS == SHRegGetValue(hkey, NULL, TEXT("MyValue"), SRRF_RT_REG_SZ, NULL, pszData, &cbData))
//              {
//                  // use pszData (successful read)
//              }
//              delete[] pszData
//          }
//      }
//
//  3) read "dword" data from the "MyValue" value of the "MySubKey" subkey of an open hkey
//
//      DWORD dwData
//      DWORD cbData = sizeof(dwData)
//      if (ERROR_SUCCESS == SHRegGetValue(hkey, TEXT("MySubKey"), TEXT("MyValue"), SRRF_RT_REG_DWORD, NULL, &dwData, &cbData))
//      {
//          // use dwData (successful read)
//      }
//
//  4) read "dword" data from the "MyValue" value of the "MySubKey" subkey of an open hkey (32-bit binary data also ok)
//
//      DWORD dwData
//      DWORD cbData = sizeof(dwData)
//      if (ERROR_SUCCESS == SHRegGetValue(hkey, TEXT("MySubKey"), TEXT("MyValue"), SRRF_RT_DWORD, NULL, &dwData, &cbData))
//      {
//          // use dwData (successful read)
//      }
//
//  5) determine existence of "MyValue" value of an open hkey
//
//      BOOL bExists = ERROR_SUCCESS == SHRegGetValue(hkey, NULL, TEXT("MyValue"), SRRF_RT_ANY, NULL, NULL, NULL)

LWSTDAPI_(LSTATUS) SHRegGetValueA(__in HKEY hkey, __in_opt LPCSTR pszSubKey, __in_opt LPCSTR pszValue,
    __in SRRF srrfFlags, __out_opt DWORD *pdwType, __out_bcount_part_opt(*pcbData,*pcbData) __typefix(LPBYTE) void *pvData,
    __inout_opt DWORD *pcbData);
LWSTDAPI_(LSTATUS) SHRegGetValueW(__in HKEY hkey, __in_opt LPCWSTR pszSubKey, __in_opt LPCWSTR pszValue,
    __in SRRF srrfFlags, __out_opt DWORD *pdwType, __out_bcount_part_opt(*pcbData,*pcbData) __typefix(LPBYTE) void *pvData,
    __inout_opt DWORD *pcbData);
#ifdef UNICODE
#define SHRegGetValue  SHRegGetValueW
#else
#define SHRegGetValue  SHRegGetValueA
#endif // !UNICODE

LWSTDAPI_(LSTATUS) SHRegSetValue(__in HKEY    hkey, __in_opt LPCWSTR pszSubKey, __in_opt LPCWSTR pszValue, __in SRRF srrfFlags,
    __in DWORD dwType, __in_bcount_opt(cbData) LPCVOID pvData, __in_opt DWORD cbData);

LWSTDAPI_(LSTATUS) SHRegGetValueFromHKCUHKLM(__in PCWSTR pwszKey, __in_opt PCWSTR pwszValue, __in SRRF srrfFlags,
                                        __out_opt DWORD* pdwType, __out_bcount_part_opt(*pcbData,*pcbData) __typefix(LPBYTE) void* pvData,
                                        __inout_opt DWORD * pcbData);
STDAPI_(BOOL) SHRegGetBoolValueFromHKCUHKLM(__in PCWSTR pszKey, __in_opt PCWSTR pszValue, __in BOOL fDefault);
#endif  // (_WIN32_IE >= 0x0602)

// These functions behave just like RegQueryValueEx(), except if the data
// type is REG_SZ, REG_EXPAND_SZ or REG_MULTI_SZ then the string is
// guaranteed to be properly null terminated.
//
// Additionally, if the data type is REG_EXPAND_SZ these functions will
// go ahead and expand out the string, and "massage" the returned *pdwType
// to be REG_SZ.
LWSTDAPI_(LSTATUS) SHQueryValueExA(
    __in                       HKEY      hkey,
    __in_opt                   LPCSTR  pszValue,
    __reserved                 DWORD    *pdwReserved,
    __out_opt                  DWORD    *pdwType,
    __out_bcount_part_opt(*pcbData,*pcbData) void  *pvData,
    __inout_opt                DWORD    *pcbData);
// These functions behave just like RegQueryValueEx(), except if the data
// type is REG_SZ, REG_EXPAND_SZ or REG_MULTI_SZ then the string is
// guaranteed to be properly null terminated.
//
// Additionally, if the data type is REG_EXPAND_SZ these functions will
// go ahead and expand out the string, and "massage" the returned *pdwType
// to be REG_SZ.
LWSTDAPI_(LSTATUS) SHQueryValueExW(
    __in                       HKEY      hkey,
    __in_opt                   LPCWSTR  pszValue,
    __reserved                 DWORD    *pdwReserved,
    __out_opt                  DWORD    *pdwType,
    __out_bcount_part_opt(*pcbData,*pcbData) void  *pvData,
    __inout_opt                DWORD    *pcbData);
#ifdef UNICODE
#define SHQueryValueEx  SHQueryValueExW
#else
#define SHQueryValueEx  SHQueryValueExA
#endif // !UNICODE

// Enumeration functions support.

LWSTDAPI_(LSTATUS)     SHEnumKeyExA(__in HKEY hkey, DWORD dwIndex, __out_ecount(*pcchName) LPSTR pszName, __inout LPDWORD pcchName);
LWSTDAPI_(LSTATUS)     SHEnumKeyExW(__in HKEY hkey, DWORD dwIndex, __out_ecount(*pcchName) LPWSTR pszName, __inout LPDWORD pcchName);
LWSTDAPI_(LSTATUS)     SHEnumValueA(__in HKEY hkey, __in DWORD dwIndex, __out_ecount_opt(*pcchValueName) PSTR pszValueName,
    __inout_opt LPDWORD pcchValueName, __out_opt LPDWORD pdwType, __out_bcount_part_opt(*pcbData,*pcbData) __typefix(LPBYTE) void *pvData,
    __inout_opt LPDWORD pcbData);
LWSTDAPI_(LSTATUS)     SHEnumValueW(__in HKEY hkey, __in DWORD dwIndex, __out_ecount_opt(*pcchValueName) PWSTR pszValueName,
    __inout_opt LPDWORD pcchValueName, __out_opt LPDWORD pdwType, __out_bcount_part_opt(*pcbData,*pcbData) __typefix(LPBYTE) void *pvData,
    __inout_opt LPDWORD pcbData);
LWSTDAPI_(LSTATUS)     SHQueryInfoKeyA(__in HKEY hkey, __out_opt LPDWORD pcSubKeys, __out_opt LPDWORD pcchMaxSubKeyLen, __out_opt LPDWORD pcValues, __out_opt LPDWORD pcchMaxValueNameLen);
LWSTDAPI_(LSTATUS)     SHQueryInfoKeyW(__in HKEY hkey, __out_opt LPDWORD pcSubKeys, __out_opt LPDWORD pcchMaxSubKeyLen, __out_opt LPDWORD pcValues, __out_opt LPDWORD pcchMaxValueNameLen);

// recursive key copy
LWSTDAPI_(LSTATUS)     SHCopyKeyA(__in HKEY hkeySrc, __in_opt LPCSTR   szSrcSubKey, __in HKEY hkeyDest, __reserved DWORD fReserved);
LWSTDAPI_(LSTATUS)     SHCopyKeyW(__in HKEY hkeySrc, __in_opt LPCWSTR wszSrcSubKey, __in HKEY hkeyDest, __reserved DWORD fReserved);

// Getting and setting file system paths with environment variables

LWSTDAPI_(LSTATUS)    SHRegGetPathA(__in HKEY hKey, __in_opt LPCSTR pcszSubKey, __in_opt LPCSTR pcszValue, __out_ecount(MAX_PATH) LPSTR pszPath, __in DWORD dwFlags);
LWSTDAPI_(LSTATUS)    SHRegGetPathW(__in HKEY hKey, __in_opt LPCWSTR pcszSubKey, __in_opt LPCWSTR pcszValue, __out_ecount(MAX_PATH) LPWSTR pszPath, __in DWORD dwFlags);
LWSTDAPI_(LSTATUS)    SHRegSetPathA(__in HKEY hKey, __in_opt LPCSTR pcszSubKey, __in_opt LPCSTR pcszValue, __in LPCSTR pcszPath, __in DWORD dwFlags);
LWSTDAPI_(LSTATUS)    SHRegSetPathW(__in HKEY hKey, __in_opt LPCWSTR pcszSubKey, __in_opt LPCWSTR pcszValue, __in LPCWSTR pcszPath, __in DWORD dwFlags);

#ifdef UNICODE
#define SHEnumKeyEx           SHEnumKeyExW
#define SHEnumValue           SHEnumValueW
#define SHQueryInfoKey        SHQueryInfoKeyW
#define SHCopyKey             SHCopyKeyW
#define SHRegGetPath          SHRegGetPathW
#define SHRegSetPath          SHRegSetPathW
#else
#define SHEnumKeyEx           SHEnumKeyExA
#define SHEnumValue           SHEnumValueA
#define SHQueryInfoKey        SHQueryInfoKeyA
#define SHCopyKey             SHCopyKeyA
#define SHRegGetPath          SHRegGetPathA
#define SHRegSetPath          SHRegSetPathA
#endif


//////////////////////////////////////////////
// User Specific Registry Access Functions
//////////////////////////////////////////////

//
// Type definitions.
//

typedef enum
{
    SHREGDEL_DEFAULT = 0x00000000,       // Delete's HKCU, or HKLM if HKCU is not found.
    SHREGDEL_HKCU    = 0x00000001,       // Delete HKCU only
    SHREGDEL_HKLM    = 0x00000010,       // Delete HKLM only.
    SHREGDEL_BOTH    = 0x00000011,       // Delete both HKCU and HKLM.
} SHREGDEL_FLAGS;

typedef enum
{
    SHREGENUM_DEFAULT = 0x00000000,       // Enumerates HKCU or HKLM if not found.
    SHREGENUM_HKCU    = 0x00000001,       // Enumerates HKCU only
    SHREGENUM_HKLM    = 0x00000010,       // Enumerates HKLM only.
    SHREGENUM_BOTH    = 0x00000011,       // Enumerates both HKCU and HKLM without duplicates.
                                          // This option is NYI.
} SHREGENUM_FLAGS;

#define     SHREGSET_HKCU           0x00000001       // Write to HKCU if empty.
#define     SHREGSET_FORCE_HKCU     0x00000002       // Write to HKCU.
#define     SHREGSET_HKLM           0x00000004       // Write to HKLM if empty.
#define     SHREGSET_FORCE_HKLM     0x00000008       // Write to HKLM.
#define     SHREGSET_DEFAULT        (SHREGSET_FORCE_HKCU | SHREGSET_HKLM)          // Default is SHREGSET_FORCE_HKCU | SHREGSET_HKLM.

typedef HANDLE HUSKEY;  // HUSKEY is a Handle to a User Specific KEY.
typedef HUSKEY *PHUSKEY;

LWSTDAPI_(LSTATUS)     SHRegCreateUSKeyA(__in LPCSTR pszPath, __in REGSAM samDesired, __in_opt HUSKEY hRelativeUSKey, __out PHUSKEY phNewUSKey, __in DWORD dwFlags);
LWSTDAPI_(LSTATUS)     SHRegCreateUSKeyW(__in LPCWSTR pwzPath, __in REGSAM samDesired, __in_opt HUSKEY hRelativeUSKey, __out PHUSKEY phNewUSKey, __in DWORD dwFlags);
LWSTDAPI_(LSTATUS)     SHRegOpenUSKeyA(__in LPCSTR pszPath, __in REGSAM samDesired, __in_opt HUSKEY hRelativeUSKey, __out PHUSKEY phNewUSKey, __in BOOL fIgnoreHKCU);
LWSTDAPI_(LSTATUS)     SHRegOpenUSKeyW(__in LPCWSTR pwzPath, __in REGSAM samDesired, __in_opt HUSKEY hRelativeUSKey, __out PHUSKEY phNewUSKey, __in BOOL fIgnoreHKCU);
LWSTDAPI_(LSTATUS)     SHRegQueryUSValueA(
    __in                                      HUSKEY  hUSKey,
    __in_opt                                  LPCSTR  pszValue,
    __inout_opt                               DWORD * pdwType,
    __out_bcount_part_opt(*pcbData, *pcbData) void *  pvData,
    __inout_opt                               DWORD * pcbData,
    __in                                      BOOL    fIgnoreHKCU,
    __in_bcount_opt(dwDefaultDataSize)        void *  pvDefaultData,
    __in_opt                                  DWORD   dwDefaultDataSize);
LWSTDAPI_(LSTATUS)     SHRegQueryUSValueW(
    __in                                      HUSKEY  hUSKey,
    __in_opt                                  LPCWSTR  pszValue,
    __inout_opt                               DWORD * pdwType,
    __out_bcount_part_opt(*pcbData, *pcbData) void *  pvData,
    __inout_opt                               DWORD * pcbData,
    __in                                      BOOL    fIgnoreHKCU,
    __in_bcount_opt(dwDefaultDataSize)        void *  pvDefaultData,
    __in_opt                                  DWORD   dwDefaultDataSize);
LWSTDAPI_(LSTATUS)     SHRegWriteUSValueA(__in HUSKEY hUSKey, __in LPCSTR pszValue, __in DWORD dwType, __in_bcount(cbData) const void *pvData, __in DWORD cbData, __in DWORD dwFlags);
LWSTDAPI_(LSTATUS)     SHRegWriteUSValueW(__in HUSKEY hUSKey, __in LPCWSTR pwzValue, __in DWORD dwType, __in_bcount(cbData) const void *pvData, __in DWORD cbData, __in DWORD dwFlags);
LWSTDAPI_(LSTATUS)     SHRegDeleteUSValueA(__in HUSKEY hUSKey, __in LPCSTR pszValue, __in SHREGDEL_FLAGS delRegFlags);
LWSTDAPI_(LSTATUS)     SHRegDeleteUSValueW(__in HUSKEY hUSKey, __in LPCWSTR pwzValue, __in SHREGDEL_FLAGS delRegFlags);
LWSTDAPI_(LSTATUS)     SHRegDeleteEmptyUSKeyW(__in HUSKEY hUSKey, __in LPCWSTR pwzSubKey, __in SHREGDEL_FLAGS delRegFlags);
LWSTDAPI_(LSTATUS)     SHRegDeleteEmptyUSKeyA(__in HUSKEY hUSKey, __in LPCSTR pszSubKey, __in SHREGDEL_FLAGS delRegFlags);
LWSTDAPI_(LSTATUS)     SHRegEnumUSKeyA(__in HUSKEY hUSKey, __in DWORD dwIndex, __out_ecount_part(*pcchName,*pcchName) LPSTR pszName, __inout LPDWORD pcchName, __in SHREGENUM_FLAGS enumRegFlags);
LWSTDAPI_(LSTATUS)     SHRegEnumUSKeyW(__in HUSKEY hUSKey, __in DWORD dwIndex, __out_ecount_part(*pcchName,*pcchName) LPWSTR pwzName, __inout LPDWORD pcchName, __in SHREGENUM_FLAGS enumRegFlags);
LWSTDAPI_(LSTATUS)     SHRegEnumUSValueA(__in HUSKEY hUSkey, __in DWORD dwIndex,
    __out_ecount_part(*pcchValueName,*pcchValueName) LPSTR pszValueName, __inout LPDWORD pcchValueName, __out_opt LPDWORD pdwType,
    __out_bcount_opt(*pcbData) void *pvData, __inout_opt LPDWORD pcbData, __in SHREGENUM_FLAGS enumRegFlags);
LWSTDAPI_(LSTATUS)     SHRegEnumUSValueW(__in HUSKEY hUSkey, __in DWORD dwIndex,
    __out_ecount_part(*pcchValueName,*pcchValueName) LPWSTR pszValueName, __inout LPDWORD pcchValueName, __out_opt LPDWORD pdwType,
    __out_bcount_opt(*pcbData) void *pvData, __inout_opt LPDWORD pcbData, __in SHREGENUM_FLAGS enumRegFlags);
LWSTDAPI_(LSTATUS)     SHRegQueryInfoUSKeyA(__in HUSKEY hUSKey, __out_opt LPDWORD pcSubKeys, __out_opt LPDWORD pcchMaxSubKeyLen, __out_opt LPDWORD pcValues, __out_opt LPDWORD pcchMaxValueNameLen, __in SHREGENUM_FLAGS enumRegFlags);
LWSTDAPI_(LSTATUS)     SHRegQueryInfoUSKeyW(__in HUSKEY hUSKey, __out_opt LPDWORD pcSubKeys, __out_opt LPDWORD pcchMaxSubKeyLen, __out_opt LPDWORD pcValues, __out_opt LPDWORD pcchMaxValueNameLen, __in SHREGENUM_FLAGS enumRegFlags);
LWSTDAPI_(LSTATUS)     SHRegCloseUSKey(__in HUSKEY hUSKey);


// These calls are equal to an SHRegOpenUSKey, SHRegQueryUSValue, and then a SHRegCloseUSKey.
STDAPI_(LSTATUS) SHRegGetUSValueA(
    __in                                      LPCSTR  pszSubKey,
    __in_opt                                  LPCSTR  pszValue,
    __inout_opt                               DWORD  *pdwType,
    __out_bcount_part_opt(*pcbData, *pcbData) void   *pvData,
    __inout_opt                               DWORD  *pcbData,
    __in                                      BOOL    fIgnoreHKCU,
    __in_bcount_opt(dwDefaultDataSize)        void   *pvDefaultData,
    __in_opt                                  DWORD   dwDefaultDataSize);
STDAPI_(LSTATUS) SHRegGetUSValueW(
    __in                                      LPCWSTR  pszSubKey,
    __in_opt                                  LPCWSTR  pszValue,
    __inout_opt                               DWORD  *pdwType,
    __out_bcount_part_opt(*pcbData, *pcbData) void   *pvData,
    __inout_opt                               DWORD  *pcbData,
    __in                                      BOOL    fIgnoreHKCU,
    __in_bcount_opt(dwDefaultDataSize)        void   *pvDefaultData,
    __in_opt                                  DWORD   dwDefaultDataSize);
LWSTDAPI_(LSTATUS)     SHRegSetUSValueA(__in LPCSTR pszSubKey, __in LPCSTR pszValue, __in DWORD dwType, __in_bcount_opt(cbData) const void *pvData, __in_opt DWORD cbData, __in_opt DWORD dwFlags);
LWSTDAPI_(LSTATUS)     SHRegSetUSValueW(__in LPCWSTR pwzSubKey, __in LPCWSTR pwzValue, __in DWORD dwType, __in_bcount_opt(cbData) const void *pvData, __in_opt DWORD cbData, __in_opt DWORD dwFlags);
LWSTDAPI_(int)         SHRegGetIntW(__in HKEY hk, __in_opt PCWSTR pwzKey, __in int iDefault);

#ifdef UNICODE
#define SHRegCreateUSKey        SHRegCreateUSKeyW
#define SHRegOpenUSKey          SHRegOpenUSKeyW
#define SHRegQueryUSValue       SHRegQueryUSValueW
#define SHRegWriteUSValue       SHRegWriteUSValueW
#define SHRegDeleteUSValue      SHRegDeleteUSValueW
#define SHRegDeleteEmptyUSKey   SHRegDeleteEmptyUSKeyW
#define SHRegEnumUSKey          SHRegEnumUSKeyW
#define SHRegEnumUSValue        SHRegEnumUSValueW
#define SHRegQueryInfoUSKey     SHRegQueryInfoUSKeyW
#define SHRegGetUSValue         SHRegGetUSValueW
#define SHRegSetUSValue         SHRegSetUSValueW
#define SHRegGetInt             SHRegGetIntW
#else
#define SHRegCreateUSKey        SHRegCreateUSKeyA
#define SHRegOpenUSKey          SHRegOpenUSKeyA
#define SHRegQueryUSValue       SHRegQueryUSValueA
#define SHRegWriteUSValue       SHRegWriteUSValueA
#define SHRegDeleteUSValue      SHRegDeleteUSValueA
#define SHRegDeleteEmptyUSKey   SHRegDeleteEmptyUSKeyA
#define SHRegEnumUSKey          SHRegEnumUSKeyA
#define SHRegEnumUSValue        SHRegEnumUSValueA
#define SHRegQueryInfoUSKey     SHRegQueryInfoUSKeyA
#define SHRegGetUSValue         SHRegGetUSValueA
#define SHRegSetUSValue         SHRegSetUSValueA
#endif

LWSTDAPI_(BOOL) SHRegGetBoolUSValueA(__in LPCSTR pszSubKey, __in LPCSTR pszValue, __in BOOL fIgnoreHKCU, __in BOOL fDefault);
LWSTDAPI_(BOOL) SHRegGetBoolUSValueW(__in LPCWSTR pszSubKey, __in LPCWSTR pszValue, __in BOOL fIgnoreHKCU, __in BOOL fDefault);
#ifdef UNICODE
#define SHRegGetBoolUSValue  SHRegGetBoolUSValueW
#else
#define SHRegGetBoolUSValue  SHRegGetBoolUSValueA
#endif // !UNICODE

//
//  Association APIs
//
//  these APIs are to assist in accessing the data in HKCR
//  getting the Command strings and exe paths
//  for different verbs and extensions are simplified this way
//

enum {
    ASSOCF_INIT_NOREMAPCLSID           = 0x00000001,  //  do not remap clsids to progids
    ASSOCF_INIT_BYEXENAME              = 0x00000002,  //  executable is being passed in
    ASSOCF_OPEN_BYEXENAME              = 0x00000002,  //  executable is being passed in
    ASSOCF_INIT_DEFAULTTOSTAR          = 0x00000004,  //  treat "*" as the BaseClass
    ASSOCF_INIT_DEFAULTTOFOLDER        = 0x00000008,  //  treat "Folder" as the BaseClass
    ASSOCF_NOUSERSETTINGS              = 0x00000010,  //  dont use HKCU
    ASSOCF_NOTRUNCATE                  = 0x00000020,  //  dont truncate the return string
    ASSOCF_VERIFY                      = 0x00000040,  //  verify data is accurate (DISK HITS)
    ASSOCF_REMAPRUNDLL                 = 0x00000080,  //  actually gets info about rundlls target if applicable
    ASSOCF_NOFIXUPS                    = 0x00000100,  //  attempt to fix errors if found
    ASSOCF_IGNOREBASECLASS             = 0x00000200,  //  dont recurse into the baseclass
    ASSOCF_INIT_IGNOREUNKNOWN          = 0x00000400,  //  dont use the "Unknown" progid, instead fail
};

typedef DWORD ASSOCF;


typedef enum {
    ASSOCSTR_COMMAND      = 1,  //  shell\verb\command string
    ASSOCSTR_EXECUTABLE,        //  the executable part of command string
    ASSOCSTR_FRIENDLYDOCNAME,   //  friendly name of the document type
    ASSOCSTR_FRIENDLYAPPNAME,   //  friendly name of executable
    ASSOCSTR_NOOPEN,            //  noopen value
    ASSOCSTR_SHELLNEWVALUE,     //  query values under the shellnew key
    ASSOCSTR_DDECOMMAND,        //  template for DDE commands
    ASSOCSTR_DDEIFEXEC,         //  DDECOMMAND to use if just create a process
    ASSOCSTR_DDEAPPLICATION,    //  Application name in DDE broadcast
    ASSOCSTR_DDETOPIC,          //  Topic Name in DDE broadcast
    ASSOCSTR_INFOTIP,           //  info tip for an item, or list of properties to create info tip from
#if (_WIN32_IE >= _WIN32_IE_IE60)
    ASSOCSTR_QUICKTIP,          //  same as ASSOCSTR_INFOTIP, except, this list contains only quickly retrievable properties
    ASSOCSTR_TILEINFO,          //  similar to ASSOCSTR_INFOTIP - lists important properties for tileview
    ASSOCSTR_CONTENTTYPE,       //  MIME Content type
    ASSOCSTR_DEFAULTICON,       //  Default icon source
    ASSOCSTR_SHELLEXTENSION,    //  Guid string pointing to the Shellex\Shellextensionhandler value.
#endif // _WIN32_IE_IE60
    ASSOCSTR_MAX                //  last item in enum...
} ASSOCSTR;

typedef enum {
    ASSOCKEY_SHELLEXECCLASS = 1,  //  the key that should be passed to ShellExec(hkeyClass)
    ASSOCKEY_APP,                 //  the "Application" key for the association
    ASSOCKEY_CLASS,               //  the progid or class key
    ASSOCKEY_BASECLASS,           //  the BaseClass key
    ASSOCKEY_MAX                  //  last item in enum...
} ASSOCKEY;

typedef enum {
    ASSOCDATA_MSIDESCRIPTOR = 1,  //  Component Descriptor to pass to MSI APIs
    ASSOCDATA_NOACTIVATEHANDLER,  //  restrict attempts to activate window
    ASSOCDATA_QUERYCLASSSTORE,    //  should check with the NT Class Store
    ASSOCDATA_HASPERUSERASSOC,    //  defaults to user specified association
#if (_WIN32_IE >= _WIN32_IE_IE60)
    ASSOCDATA_EDITFLAGS,          //  Edit flags.
    ASSOCDATA_VALUE,              //  use pszExtra as the Value name
#endif // _WIN32_IE_IE60
    ASSOCDATA_MAX
} ASSOCDATA;

typedef enum {
    ASSOCENUM_NONE
} ASSOCENUM;

#undef INTERFACE
#define INTERFACE IQueryAssociations

DECLARE_INTERFACE_IID_( IQueryAssociations, IUnknown, "c46ca590-3c3f-11d2-bee6-0000f805ca57" )
{
    // IUnknown methods
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) ( THIS ) PURE;
    STDMETHOD_(ULONG, Release) ( THIS ) PURE;

    // IQueryAssociations methods
    STDMETHOD (Init)(THIS_ ASSOCF flags, LPCWSTR pszAssoc, HKEY hkProgid, HWND hwnd) PURE;
    STDMETHOD (GetString)(THIS_ ASSOCF flags, ASSOCSTR str, LPCWSTR pszExtra, __out_ecount_opt(*pcchOut) LPWSTR pszOut, __inout DWORD *pcchOut) PURE;
    STDMETHOD (GetKey)(THIS_ ASSOCF flags, ASSOCKEY key, LPCWSTR pszExtra, __out HKEY *phkeyOut) PURE;
    STDMETHOD (GetData)(THIS_ ASSOCF flags, ASSOCDATA data, LPCWSTR pszExtra, __out_bcount_opt(*pcbOut) void * pvOut, __inout_opt DWORD *pcbOut) PURE;
    STDMETHOD (GetEnum)(THIS_ ASSOCF flags, ASSOCENUM assocenum, LPCWSTR pszExtra, REFIID riid, __out void **ppvOut) PURE;
};


// use CLSID_QueryAssociations for clsid, object implements IQueryAssociations
// AssocCreateForClasses() is the more functional version of this API
LWSTDAPI AssocCreate(__in CLSID clsid, __in REFIID riid, __out void **ppv);

//  wrappers for the interface
LWSTDAPI AssocQueryStringA(__in ASSOCF flags, __in ASSOCSTR str, __in LPCSTR pszAssoc, __in_opt LPCSTR pszExtra, __out_ecount(*pcchOut) LPSTR pszOut, __inout DWORD *pcchOut);
//  wrappers for the interface
LWSTDAPI AssocQueryStringW(__in ASSOCF flags, __in ASSOCSTR str, __in LPCWSTR pszAssoc, __in_opt LPCWSTR pszExtra, __out_ecount(*pcchOut) LPWSTR pszOut, __inout DWORD *pcchOut);
#ifdef UNICODE
#define AssocQueryString  AssocQueryStringW
#else
#define AssocQueryString  AssocQueryStringA
#endif // !UNICODE
LWSTDAPI AssocQueryStringByKeyA(__in ASSOCF flags, __in ASSOCSTR str, __in HKEY hkAssoc, __in_opt LPCSTR pszExtra, __out_ecount(*pcchOut) LPSTR pszOut, __inout DWORD *pcchOut);
LWSTDAPI AssocQueryStringByKeyW(__in ASSOCF flags, __in ASSOCSTR str, __in HKEY hkAssoc, __in_opt LPCWSTR pszExtra, __out_ecount(*pcchOut) LPWSTR pszOut, __inout DWORD *pcchOut);
#ifdef UNICODE
#define AssocQueryStringByKey  AssocQueryStringByKeyW
#else
#define AssocQueryStringByKey  AssocQueryStringByKeyA
#endif // !UNICODE
LWSTDAPI AssocQueryKeyA(__in ASSOCF flags, __in ASSOCKEY key, __in LPCSTR pszAssoc, __in_opt LPCSTR pszExtra, __out HKEY *phkeyOut);
LWSTDAPI AssocQueryKeyW(__in ASSOCF flags, __in ASSOCKEY key, __in LPCWSTR pszAssoc, __in_opt LPCWSTR pszExtra, __out HKEY *phkeyOut);
#ifdef UNICODE
#define AssocQueryKey  AssocQueryKeyW
#else
#define AssocQueryKey  AssocQueryKeyA
#endif // !UNICODE

#if (_WIN32_IE >= 0x0601)
//  AssocIsDangerous() checks a file type to determine whether it is "Dangerous"
//      this maps to the IE download dialog's forcing a prompt to open or save.
//      dangerous file types should be handled more carefully than other file types.
//
//  Parameter:  pszAssoc - type to check.  may be an extension or progid.  (".exe" or "exefile" would both be valid)
//
//  Returns: TRUE if the file type is dangerous.
//
//  NOTES:
//
//      this API first checks a hardcoded list of known dangerous types.
//      then it checks the editflags for the file type looking for the FTA_AlwaysUnsafe bit.
//      then it checks Safer policies.
//
LWSTDAPI_(BOOL) AssocIsDangerous(LPCWSTR pszAssoc);

#endif  // _WIN32_IE >= 0x0601

#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
LWSTDAPI AssocGetPerceivedType(__in LPCWSTR pszExt, __out PERCEIVED *ptype, __out PERCEIVEDFLAG *pflag, __out_opt LPWSTR *ppszType);
#endif



#endif //  NO_SHLWAPI_REG



#ifndef NO_SHLWAPI_STREAM
//
//=============== Stream Routines ===================================
//

LWSTDAPI_(struct IStream *) SHOpenRegStreamA(__in HKEY hkey, LPCSTR pszSubkey, LPCSTR pszValue, DWORD grfMode);
LWSTDAPI_(struct IStream *) SHOpenRegStreamW(__in HKEY hkey, LPCWSTR pszSubkey, LPCWSTR pszValue, DWORD grfMode);
#ifdef UNICODE
#define SHOpenRegStream  SHOpenRegStreamW
#else
#define SHOpenRegStream  SHOpenRegStreamA
#endif // !UNICODE
LWSTDAPI_(struct IStream *) SHOpenRegStream2A(__in HKEY hkey, LPCSTR pszSubkey, LPCSTR pszValue, DWORD grfMode);
LWSTDAPI_(struct IStream *) SHOpenRegStream2W(__in HKEY hkey, LPCWSTR pszSubkey, LPCWSTR pszValue, DWORD grfMode);
#ifdef UNICODE
#define SHOpenRegStream2  SHOpenRegStream2W
#else
#define SHOpenRegStream2  SHOpenRegStream2A
#endif // !UNICODE
// New code always wants new implementation...
#undef SHOpenRegStream
#define SHOpenRegStream SHOpenRegStream2

LWSTDAPI SHCreateStreamOnFileA(LPCSTR pszFile, DWORD grfMode, __out struct IStream **ppstm);
LWSTDAPI SHCreateStreamOnFileW(LPCWSTR pszFile, DWORD grfMode, __out struct IStream **ppstm);
#ifdef UNICODE
#define SHCreateStreamOnFile  SHCreateStreamOnFileW
#else
#define SHCreateStreamOnFile  SHCreateStreamOnFileA
#endif // !UNICODE


#if (_WIN32_IE >= 0x0600)

LWSTDAPI SHCreateStreamOnFileEx(LPCWSTR pszFile, DWORD grfMode, DWORD dwAttributes, BOOL fCreate, __in_opt struct IStream * pstmTemplate, __out struct IStream **ppstm);

#endif // (_WIN32_IE >= 0x0600)

#if (_WIN32_IE >= _WIN32_IE_IE501)

LWSTDAPI_(struct IStream *) SHCreateMemStream(__in_bcount_opt(cbInit) const BYTE *pInit, UINT cbInit);

#endif // (_WIN32_IE >= _WIN32_IE_IE501)



#endif // NO_SHLWAPI_STREAM


#ifndef NO_SHLWAPI_MLUI
//
//=============== Multi Language UI Routines ===================================
//


#if (_WIN32_IE >= _WIN32_IE_IE501)

LWSTDAPI_(HINSTANCE) MLLoadLibraryA(LPCSTR lpLibFileName, __in HMODULE hModule, DWORD dwCrossCodePage);
LWSTDAPI_(HINSTANCE) MLLoadLibraryW(LPCWSTR lpLibFileName, __in HMODULE hModule, DWORD dwCrossCodePage);
#ifdef UNICODE
#define MLLoadLibrary  MLLoadLibraryW
#else
#define MLLoadLibrary  MLLoadLibraryA
#endif // !UNICODE
LWSTDAPI_(BOOL) MLFreeLibrary(__in HMODULE hModule);

#define ML_NO_CROSSCODEPAGE     0
#define ML_CROSSCODEPAGE_NT     1
#define ML_CROSSCODEPAGE        2
#define ML_SHELL_LANGUAGE       4
#define ML_CROSSCODEPAGE_MASK   7

#endif // (_WIN32_IE >= _WIN32_IE_IE501)


#endif // NO_SHLWAPI_MLUI

#ifndef NO_SHLWAPI_HTTP
//
//=============== HTTP helper Routines ===================================
//

#if (_WIN32_IE >= 0x0603)
LWSTDAPI   GetAcceptLanguagesA(__out_ecount(*pcch) LPSTR psz, LPDWORD pcch);
LWSTDAPI   GetAcceptLanguagesW(__out_ecount(*pcch) LPWSTR psz, LPDWORD pcch);
#ifdef UNICODE
#define GetAcceptLanguages  GetAcceptLanguagesW
#else
#define GetAcceptLanguages  GetAcceptLanguagesA
#endif // !UNICODE
#endif // (_WIN32_IE >= 0x0603)

#endif // NO_SHLWAPI_HTTP


#if (_WIN32_IE < _WIN32_IE_IE70) && !defined(NO_SHLWAPI_STOPWATCH)

#define SPMODE_SHELL      0x00000001
#define SPMODE_DEBUGOUT   0x00000002
#define SPMODE_TEST       0x00000004
#define SPMODE_BROWSER    0x00000008
#define SPMODE_FLUSH      0x00000010
#define SPMODE_EVENT      0x00000020
#define SPMODE_MSVM       0x00000040
#define SPMODE_FORMATTEXT 0x00000080
#define SPMODE_PROFILE    0x00000100
#define SPMODE_DEBUGBREAK 0x00000200
#define SPMODE_MSGTRACE   0x00000400
#define SPMODE_PERFTAGS   0x00000800
#define SPMODE_MEMWATCH   0x00001000
#define SPMODE_DBMON      0x00002000
#define SPMODE_MULTISTOP  0x00004000
#ifndef NO_ETW_TRACING
#define SPMODE_EVENTTRACE 0x00008000 // Event Tracing for Windows Enabled
#endif

DWORD WINAPI StopWatchMode(void);
DWORD WINAPI StopWatchFlush(void);

#endif // (_WIN32_IE < _WIN32_IE_IE70) && !defined(NO_SHLWAPI_STOPWATCH)

#ifndef __IConnectionPoint_FWD_DEFINED__
#define __IConnectionPoint_FWD_DEFINED__
typedef struct IConnectionPoint IConnectionPoint;
#endif  /* __IConnectionPoint_FWD_DEFINED__ */


#if (_WIN32_IE >= _WIN32_IE_IE501)

    LWSTDAPI_(void) IUnknown_Set(__deref_inout IUnknown ** ppunk, __in_opt IUnknown * punk);
    LWSTDAPI_(void) IUnknown_AtomicRelease(__inout_opt void ** ppunk);
    LWSTDAPI IUnknown_GetWindow(__in IUnknown* punk, __out HWND* phwnd);
    LWSTDAPI IUnknown_SetSite(__in IUnknown *punk, __in_opt IUnknown *punkSite);
    LWSTDAPI IUnknown_GetSite(__in IUnknown *punk, __in REFIID riid, __deref_out void **ppv);
    LWSTDAPI IUnknown_QueryService(__in_opt IUnknown* punk, __in REFGUID guidService, __in REFIID riid, __deref_out void ** ppvOut);

#endif // (_WIN32_IE >= _WIN32_IE_IE501)


#if (_WIN32_IE >= _WIN32_IE_IE501)

#if !defined(__cplusplus) && defined(COBJMACROS)
#undef IStream_Read
#undef IStream_Write
#endif

LWSTDAPI IStream_Read(__in IStream *pstm, __out_bcount_full(cb) void *pv, __in ULONG cb);
LWSTDAPI IStream_Write(__in IStream *pstm, __in_bcount(cb) const void *pv, __in ULONG cb);
LWSTDAPI IStream_Reset(__in IStream *pstm);
LWSTDAPI IStream_Size(__in IStream *pstm, __out ULARGE_INTEGER *pui);

LWSTDAPI ConnectToConnectionPoint(__in_opt IUnknown* punk, __in REFIID riidEvent, __in BOOL fConnect, __in IUnknown* punkTarget, __out DWORD* pdwCookie, __deref_out_opt IConnectionPoint** ppcpOut);

#endif // (_WIN32_IE >= _WIN32_IE_IE501)

#if (_WIN32_IE >= _WIN32_IE_IE60)

LWSTDAPI IStream_ReadPidl(__in IStream *pstm, __deref_out PIDLIST_RELATIVE *ppidlOut);
LWSTDAPI IStream_WritePidl(__in IStream *pstm, __in PCUIDLIST_RELATIVE pidlWrite);

#endif // (_WIN32_IE >= _WIN32_IE_IE60)

#if (_WIN32_IE >= _WIN32_IE_IE70)

LWSTDAPI IStream_ReadStr(__in IStream *pstm, __deref_out PWSTR *ppsz);
LWSTDAPI IStream_WriteStr(__in IStream *pstm, __in PCWSTR psz);

LWSTDAPI IStream_Copy(__in IStream *pstmFrom, __in IStream *pstmTo, DWORD cb);

#endif // (_WIN32_IE >= _WIN32_IE_IE70)


#if (_WIN32_IE >= 0x0600)
#define SHGVSPB_PERUSER             0x00000001 // must have one of PERUSER or ALLUSERS
#define SHGVSPB_ALLUSERS            0x00000002
#define SHGVSPB_PERFOLDER           0x00000004 // must have one of PERFOLDER ALLFOLDERS or INHERIT
#define SHGVSPB_ALLFOLDERS          0x00000008
#define SHGVSPB_INHERIT             0x00000010
#define SHGVSPB_ROAM                0x00000020 // modifies the above
#define SHGVSPB_NOAUTODEFAULTS      0x80000000 // turns off read delegation to more general property bags

#define SHGVSPB_FOLDER              (SHGVSPB_PERUSER | SHGVSPB_PERFOLDER)
#define SHGVSPB_FOLDERNODEFAULTS    (SHGVSPB_PERUSER | SHGVSPB_PERFOLDER | SHGVSPB_NOAUTODEFAULTS)
#define SHGVSPB_USERDEFAULTS        (SHGVSPB_PERUSER | SHGVSPB_ALLFOLDERS)
#define SHGVSPB_GLOBALDEAFAULTS     (SHGVSPB_ALLUSERS | SHGVSPB_ALLFOLDERS)

LWSTDAPI SHGetViewStatePropertyBag(__in_opt PCIDLIST_ABSOLUTE pidl, __in_opt LPCWSTR pszBagName, __in DWORD dwFlags, __in REFIID riid, __deref_out void** ppv);
#endif  // (_WIN32_IE >= 0x0600)

// SHFormatDateTime flags
//  (FDTF_SHORTDATE and FDTF_LONGDATE are mutually exclusive, as is
//   FDTF_SHORTIME and FDTF_LONGTIME.)
//
#define FDTF_SHORTTIME          0x00000001      // eg, "7:48 PM"
#define FDTF_SHORTDATE          0x00000002      // eg, "3/29/98"
#define FDTF_DEFAULT            (FDTF_SHORTDATE | FDTF_SHORTTIME) // eg, "3/29/98 7:48 PM"
#define FDTF_LONGDATE           0x00000004      // eg, "Monday, March 29, 1998"
#define FDTF_LONGTIME           0x00000008      // eg. "7:48:33 PM"
#define FDTF_RELATIVE           0x00000010      // uses "Yesterday", etc. if possible
#define FDTF_LTRDATE            0x00000100      // Left To Right reading order
#define FDTF_RTLDATE            0x00000200      // Right To Left reading order
#define FDTF_NOAUTOREADINGORDER 0x00000400      // Don't detect reading order automatically. Useful if you will be converting to Ansi and don't want Unicode reading order characters

LWSTDAPI_(int)  SHFormatDateTimeA(const FILETIME UNALIGNED * pft, __inout_opt DWORD * pdwFlags, __out_ecount(cchBuf) LPSTR pszBuf, UINT cchBuf);
LWSTDAPI_(int)  SHFormatDateTimeW(const FILETIME UNALIGNED * pft, __inout_opt DWORD * pdwFlags, __out_ecount(cchBuf) LPWSTR pszBuf, UINT cchBuf);
#ifdef UNICODE
#define SHFormatDateTime  SHFormatDateTimeW
#else
#define SHFormatDateTime  SHFormatDateTimeA
#endif // !UNICODE

#if (_WIN32_IE >= _WIN32_IE_IE501)

LWSTDAPI_(int)  SHAnsiToUnicode(LPCSTR pszSrc, __out_ecount(cwchBuf) LPWSTR pwszDst, int cwchBuf);
LWSTDAPI_(int)  SHAnsiToAnsi(LPCSTR pszSrc, __out_ecount(cchBuf) LPSTR pszDst, int cchBuf);
LWSTDAPI_(int)  SHUnicodeToAnsi(LPCWSTR pwszSrc, __out_ecount(cchBuf) LPSTR pszDst, int cchBuf);
LWSTDAPI_(int)  SHUnicodeToUnicode(LPCWSTR pwzSrc, __out_ecount(cwchBuf) LPWSTR pwzDst, int cwchBuf);

// The return value from all SH<Type>To<Type> is the size of szDest including the terminater.
#ifdef UNICODE
#define SHTCharToUnicode(wzSrc, wzDest, cchSize)                SHUnicodeToUnicode(wzSrc, wzDest, cchSize)
#define SHTCharToAnsi(wzSrc, szDest, cchSize)                   SHUnicodeToAnsi(wzSrc, szDest, cchSize)
#define SHUnicodeToTChar(wzSrc, wzDest, cchSize)                SHUnicodeToUnicode(wzSrc, wzDest, cchSize)
#define SHAnsiToTChar(szSrc, wzDest, cchSize)                   SHAnsiToUnicode(szSrc, wzDest, cchSize)
#else // UNICODE
#define SHTCharToUnicode(szSrc, wzDest, cchSize)                SHAnsiToUnicode(szSrc, wzDest, cchSize)
#define SHTCharToAnsi(szSrc, szDest, cchSize)                   SHAnsiToAnsi(szSrc, szDest, cchSize)
#define SHUnicodeToTChar(wzSrc, szDest, cchSize)                SHUnicodeToAnsi(wzSrc, szDest, cchSize)
#define SHAnsiToTChar(szSrc, szDest, cchSize)                   SHAnsiToAnsi(szSrc, szDest, cchSize)
#endif // UNICODE

#endif // (_WIN32_IE >= _WIN32_IE_IE501)


#if (_WIN32_IE >= _WIN32_IE_IE501)

LWSTDAPI_(int) SHMessageBoxCheckA(HWND hwnd, LPCSTR pszText, LPCSTR pszCaption, UINT uType, int iDefault, LPCSTR pszRegVal);
LWSTDAPI_(int) SHMessageBoxCheckW(HWND hwnd, LPCWSTR pszText, LPCWSTR pszCaption, UINT uType, int iDefault, LPCWSTR pszRegVal);
#ifdef UNICODE
#define SHMessageBoxCheck  SHMessageBoxCheckW
#else
#define SHMessageBoxCheck  SHMessageBoxCheckA
#endif // !UNICODE

#endif // (_WIN32_IE >= _WIN32_IE_IE501)


#if (_WIN32_IE >= _WIN32_IE_IE501)

// Prevents hang do to hung window on broadcast
LWSTDAPI_(LRESULT) SHSendMessageBroadcastA(UINT uMsg, __in WPARAM wParam, __in LPARAM lParam);
// Prevents hang do to hung window on broadcast
LWSTDAPI_(LRESULT) SHSendMessageBroadcastW(UINT uMsg, __in WPARAM wParam, __in LPARAM lParam);
#ifdef UNICODE
#define SHSendMessageBroadcast  SHSendMessageBroadcastW
#else
#define SHSendMessageBroadcast  SHSendMessageBroadcastA
#endif // !UNICODE

LWSTDAPI_(CHAR) SHStripMneumonicA(__inout LPSTR pszMenu);
LWSTDAPI_(WCHAR) SHStripMneumonicW(__inout LPWSTR pszMenu);
#ifdef UNICODE
#define SHStripMneumonic  SHStripMneumonicW
#else
#define SHStripMneumonic  SHStripMneumonicA
#endif // !UNICODE


// Returns TRUE/FALSE depending on question
#define OS_WINDOWS                  0           // Windows 9x vs. NT
#define OS_NT                       1           // Windows 9x vs. NT
#define OS_WIN95ORGREATER           2           // Win95 or greater
#define OS_NT4ORGREATER             3           // NT4 or greater
#define OS_WIN98ORGREATER           5           // Win98 or greater
#define OS_WIN98_GOLD               6           // Win98 Gold (Version 4.10 build 1998)
#define OS_WIN2000ORGREATER         7           // Some derivative of Win2000

// NOTE: these flags check explicitly for (dwMajorVersion == 5)
#define OS_WIN2000PRO               8           // Windows 2000 Professional (Workstation)
#define OS_WIN2000SERVER            9           // Windows 2000 Server
#define OS_WIN2000ADVSERVER         10          // Windows 2000 Advanced Server
#define OS_WIN2000DATACENTER        11          // Windows 2000 Data Center Server
#define OS_WIN2000TERMINAL          12          // Windows 2000 Terminal Server in "Application Server" mode (now simply called "Terminal Server")

#define OS_EMBEDDED                 13          // Embedded Windows Edition
#define OS_TERMINALCLIENT           14          // Windows Terminal Client (eg user is comming in via tsclient)
#define OS_TERMINALREMOTEADMIN      15          // Terminal Server in "Remote Administration" mode
#define OS_WIN95_GOLD               16          // Windows 95 Gold (Version 4.0 Build 1995)
#define OS_MEORGREATER              17          // Windows Millennium (Version 5.0)
#define OS_XPORGREATER              18          // Windows XP or greater
#define OS_HOME                     19          // Home Edition (eg NOT Professional, Server, Advanced Server, or Datacenter)
#define OS_PROFESSIONAL             20          // Professional     (aka Workstation; eg NOT Server, Advanced Server, or Datacenter)
#define OS_DATACENTER               21          // Datacenter       (eg NOT Server, Advanced Server, Professional, or Personal)
#define OS_ADVSERVER                22          // Advanced Server  (eg NOT Datacenter, Server, Professional, or Personal)
#define OS_SERVER                   23          // Server           (eg NOT Datacenter, Advanced Server, Professional, or Personal)
#define OS_TERMINALSERVER           24          // Terminal Server - server running in what used to be called "Application Server" mode (now simply called "Terminal Server")
#define OS_PERSONALTERMINALSERVER   25          // Personal Terminal Server - per/pro machine running in single user TS mode
#define OS_FASTUSERSWITCHING        26          // Fast User Switching
#define OS_WELCOMELOGONUI           27          // New friendly logon UI
#define OS_DOMAINMEMBER             28          // Is this machine a member of a domain (eg NOT a workgroup)
#define OS_ANYSERVER                29          // is this machine any type of server? (eg datacenter or advanced server or server)?
#define OS_WOW6432                  30          // Is this process a 32-bit process running on an 64-bit platform?
#define OS_WEBSERVER                31          // Web Edition Server
#define OS_SMALLBUSINESSSERVER      32          // SBS Server
#define OS_TABLETPC                 33          // Are we running on a TabletPC?
#define OS_SERVERADMINUI            34          // Should defaults lean towards those preferred by server administrators?
#define OS_MEDIACENTER              35          // eHome Freestyle Project
#define OS_APPLIANCE                36          // Windows .NET Appliance Server

LWSTDAPI_(BOOL) IsOS(DWORD dwOS);


#endif // (_WIN32_IE >= _WIN32_IE_IE501)


// Shared memory apis


#if (_WIN32_IE >= 0x0603)
LWSTDAPI_(HANDLE)   SHAllocShared(__in_bcount(dwSize) const void *pvData, __in DWORD dwSize, __in DWORD dwProcessId);
LWSTDAPI_(BOOL)     SHFreeShared(__in HANDLE hData, __in DWORD dwProcessId);
LWSTDAPI_(void *)   SHLockShared(__in HANDLE hData, __in DWORD dwProcessId);
LWSTDAPI_(BOOL)     SHUnlockShared(__in void *pvData);
#endif // _WIN32_IE >= 0x0603


#if (_WIN32_IE >= _WIN32_IE_IE501)

LWSTDAPI_(UINT) WhichPlatform(void);

// Return values of WhichPlatform
#define PLATFORM_UNKNOWN     0
#define PLATFORM_IE3         1      // obsolete: use PLATFORM_BROWSERONLY
#define PLATFORM_BROWSERONLY 1      // browser-only (no new shell)
#define PLATFORM_INTEGRATED  2      // integrated shell

//***   QueryInterface helpers
// NOTES
//  ATL has a fancier version of this.  if we need to extend ours, we
//  should probably just switch to ATL's rather than reinvent.
// EXAMPLE
//  Cfoo::QI(REFIID riid, void **ppv)
//  {
//      // (the IID_xxx comments make grep'ing work!)
//      static const QITAB qit = {
//          QITABENT(Cfoo, Iiface1),    // IID_Iiface1
//          ...
//          QITABENT(Cfoo, IifaceN),    // IID_IifaceN
//          { 0 },                      // n.b. don't forget the 0
//      };
//
//      // n.b. make sure you don't cast 'this'
//      hr = QISearch(this, qit, riid, ppv);
//      if (FAILED(hr))
//          hr = SUPER::QI(riid, ppv);
//      // custom code could be added here for FAILED() case
//      return hr;
//  }
//
//  If you have an interface that is implemented multiple times,
//  the compiler will claim an ambiguous cast, so you need to give
//  some help.  For example, if your class is defined as
//
//  class CClass : public IPersistStream, public IPersistFile
//
//  then you need to say
//
//      QITABENTMULTI(CClass, IPersist, IPersistStream)
//      QITABENT(CClass, IPersistStream)
//      QITABENT(CClass, IPersistFile)
//
//  The MULTI is needed for IPersist because the compiler doesn't
//  know whether you wanted the IPersist from IPersistStream
//  or the IPersist from IPersistFile.  Unless you have played weird
//  compiler tricks, they are the same implementation, so you can
//  just pick either one, doesn't matter.
//
//  Common mistake: You do not need to use MULTI if the base interface
//  can be unambiguously determined.  E.g.,
//
//  class CSimple : public IContextMenu3
//
//      QITABENT(CClass, IContextMenu)      // do not need MULTI
//      QITABENT(CClass, IContextMenu2)     // do not need MULTI
//      QITABENT(CClass, IContextMenu3)
//
//  Do not create an entry for IUnknown; the first entry in the
//  table will be used for IUnknown.
//

typedef struct
{
    const IID * piid;
    int         dwOffset;
} QITAB, *LPQITAB;
typedef const QITAB *LPCQITAB;

#ifdef __cplusplus

#define QITABENTMULTI(Cthis, Ifoo, Iimpl) \
    { &__uuidof(Ifoo), OFFSETOFCLASS(Iimpl, Cthis) }

#else

#define QITABENTMULTI(Cthis, Ifoo, Iimpl) \
    { (IID*) &IID_##Ifoo, OFFSETOFCLASS(Iimpl, Cthis) }

#endif  // __cplusplus

#define QITABENTMULTI2(Cthis, Ifoo, Iimpl) \
    { (IID*) &Ifoo, OFFSETOFCLASS(Iimpl, Cthis) }

#define QITABENT(Cthis, Ifoo) QITABENTMULTI(Cthis, Ifoo, Ifoo)

STDAPI QISearch(__inout void* that, __in LPCQITAB pqit, __in REFIID riid, __deref_out void **ppv);

#endif // (_WIN32_IE >= _WIN32_IE_IE501)

#ifndef STATIC_CAST
//***   STATIC_CAST -- 'portable' static_cast<>
// NOTES
//  do *not* use SAFE_CAST (see comment in OFFSETOFCLASS)
#define STATIC_CAST(typ)   static_cast<typ>
#ifndef _X86_
    // assume only intel compiler (>=vc5) supports static_cast for now
    // we could key off of _MSC_VER >= 1100 but i'm not sure that will work
    //
    // a straight cast will give the correct result but no error checking,
    // so we'll have to catch errors on intel.
    #undef  STATIC_CAST
    #define STATIC_CAST(typ)   (typ)
#endif
#endif

#ifndef OFFSETOFCLASS
//***   OFFSETOFCLASS -- (stolen from ATL)
// we use STATIC_CAST not SAFE_CAST because the compiler gets confused
// (it doesn't constant-fold the ,-op in SAFE_CAST so we end up generating
// code for the table!)

#define OFFSETOFCLASS(base, derived) \
    ((DWORD)(DWORD_PTR)(STATIC_CAST(base*)((derived*)8))-8)
#endif


// Types for SHIsLowMemoryMachine
#define ILMM_IE4    0       // 1997-era machine
LWSTDAPI_(BOOL) SHIsLowMemoryMachine(DWORD dwType);

// Menu Helpers
LWSTDAPI_(int)  GetMenuPosFromID(HMENU hmenu, UINT id);

LWSTDAPI        SHGetInverseCMAP(__out_bcount(cbMap) BYTE *pbMap, ULONG cbMap);


#if (_WIN32_IE >= 0x0500)

// SHAutoComplete
//      hwndEdit - HWND of editbox, ComboBox or ComboBoxEx.
//      dwFlags - Flags to indicate what to AutoAppend or AutoSuggest for the editbox.
//
// WARNING:
//    Caller needs to have called CoInitialize() or OleInitialize()
//    and cannot call CoUninit/OleUninit until after
//    WM_DESTROY on hwndEdit.
//
//  dwFlags values:
#define SHACF_DEFAULT                   0x00000000  // Currently (SHACF_FILESYSTEM | SHACF_URLALL)
#define SHACF_FILESYSTEM                0x00000001  // This includes the File System as well as the rest of the shell (Desktop\My Computer\Control Panel\)
#define SHACF_URLALL                    (SHACF_URLHISTORY | SHACF_URLMRU)
#define SHACF_URLHISTORY                0x00000002  // URLs in the User's History
#define SHACF_URLMRU                    0x00000004  // URLs in the User's Recently Used list.
#define SHACF_USETAB                    0x00000008  // Use the tab to move thru the autocomplete possibilities instead of to the next dialog/window control.
#define SHACF_FILESYS_ONLY              0x00000010  // This includes the File System
#if (_WIN32_IE >= 0x0600)
#define SHACF_FILESYS_DIRS              0x00000020  // Same as SHACF_FILESYS_ONLY except it only includes directories, UNC servers, and UNC server shares.
#endif // (_WIN32_IE >= 0x0600)
#if (_WIN32_IE >= _WIN32_IE_IE70)
#define SHACF_VIRTUAL_NAMESPACE         0x00000040  // Also include the virtual namespace
#endif // _WIN32_IE_IE70
#define SHACF_AUTOSUGGEST_FORCE_ON      0x10000000  // Ignore the registry default and force the feature on.
#define SHACF_AUTOSUGGEST_FORCE_OFF     0x20000000  // Ignore the registry default and force the feature off.
#define SHACF_AUTOAPPEND_FORCE_ON       0x40000000  // Ignore the registry default and force the feature on. (Also know as AutoComplete)
#define SHACF_AUTOAPPEND_FORCE_OFF      0x80000000  // Ignore the registry default and force the feature off. (Also know as AutoComplete)

LWSTDAPI SHAutoComplete(HWND hwndEdit, DWORD dwFlags);

#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
LWSTDAPI SHCreateThreadRef(__inout LONG *pcRef, __deref_out IUnknown **ppunk);
#endif // _WIN32_IE_IE60SP2
LWSTDAPI SHSetThreadRef(__in IUnknown *punk);
LWSTDAPI SHGetThreadRef(__deref_out IUnknown **ppunk);

LWSTDAPI_(BOOL) SHSkipJunction(__in_opt struct IBindCtx* pbc, const CLSID *pclsid);
#endif // (_WIN32_IE >= 0x0500)

#define CTF_INSIST                      0x00000001      // SHCreateThread() dwFlags - call pfnThreadProc synchronously if CreateThread() fails
#define CTF_THREAD_REF                  0x00000002      // hold a reference to the creating thread
#define CTF_PROCESS_REF                 0x00000004      // hold a reference to the creating process
#define CTF_COINIT_STA                  0x00000008      // init COM as STA for the created thread
#define CTF_COINIT                      CTF_COINIT_STA  // init COM as STA for the created thread
#if (_WIN32_IE >= _WIN32_IE_IE60)
#define CTF_FREELIBANDEXIT              0x00000010      // hold a ref to the DLL and call FreeLibraryAndExitThread() when done
#define CTF_REF_COUNTED                 0x00000020      // thread supports ref counting via SHGetThreadRef() or CTF_THREAD_REF so that child threads can keep this thread alive
#define CTF_WAIT_ALLOWCOM               0x00000040      // while waiting for pfnCallback, allow COM marshaling to the blocked calling thread
#endif // _WIN32_IE_IE60
#if (_WIN32_IE >= _WIN32_IE_IE70)
#define CTF_UNUSED                      0x00000080
#define CTF_INHERITWOW64                0x00000100      // new thread should inherit the wow64 disable state for the file system redirector
#endif // _WIN32_IE_IE70
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define CTF_WAIT_NO_REENTRANCY          0x00000200      // don't allow re-entrancy when waiting for the sync proc, this won't work with marshalled objects or SendMessages() from the sync proc
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

//#define CTF_COINIT_MTA      0x00000800      // init COM as STA for the created thread

LWSTDAPI_(BOOL) SHCreateThread(__in LPTHREAD_START_ROUTINE pfnThreadProc, __in_opt void *pData, DWORD dwFlags, __in_opt LPTHREAD_START_ROUTINE pfnCallback);


#if (_WIN32_IE >= _WIN32_IE_IE60)
LWSTDAPI SHReleaseThreadRef(); // release a CTF_THREAD_REF reference earlier than the return of pfnThreadProc
#endif // _WIN32_IE_IE60

#ifndef NO_SHLWAPI_GDI
//
//====== GDI helper functions  ================================================
//

LWSTDAPI_(HPALETTE) SHCreateShellPalette(__in_opt HDC hdc);

#if (_WIN32_IE >= 0x0500)

LWSTDAPI_(void)     ColorRGBToHLS(__in COLORREF clrRGB, __out WORD* pwHue, __out WORD* pwLuminance, __out WORD* pwSaturation);
LWSTDAPI_(COLORREF) ColorHLSToRGB(__in WORD wHue, __in WORD wLuminance, __in WORD wSaturation);
LWSTDAPI_(COLORREF) ColorAdjustLuma(__in COLORREF clrRGB, int n, BOOL fScale);


#endif  // _WIN32_IE >= 0x0500

#endif // NO_SHLWAPI_GDI

//
//====== DllGetVersion  =======================================================
//

typedef struct _DLLVERSIONINFO
{
    DWORD cbSize;
    DWORD dwMajorVersion;                   // Major version
    DWORD dwMinorVersion;                   // Minor version
    DWORD dwBuildNumber;                    // Build number
    DWORD dwPlatformID;                     // DLLVER_PLATFORM_*
} DLLVERSIONINFO;

// Platform IDs for DLLVERSIONINFO
#define DLLVER_PLATFORM_WINDOWS         0x00000001      // Windows 95
#define DLLVER_PLATFORM_NT              0x00000002      // Windows NT

#if (_WIN32_IE >= 0x0501)

typedef struct _DLLVERSIONINFO2
{
    DLLVERSIONINFO info1;
    DWORD dwFlags;                          // No flags currently defined
    ULONGLONG ullVersion;                   // Encoded as:
                                            // Major 0xFFFF 0000 0000 0000
                                            // Minor 0x0000 FFFF 0000 0000
                                            // Build 0x0000 0000 FFFF 0000
                                            // QFE   0x0000 0000 0000 FFFF
} DLLVERSIONINFO2;

#define DLLVER_MAJOR_MASK                    0xFFFF000000000000
#define DLLVER_MINOR_MASK                    0x0000FFFF00000000
#define DLLVER_BUILD_MASK                    0x00000000FFFF0000
#define DLLVER_QFE_MASK                      0x000000000000FFFF

#endif

#define MAKEDLLVERULL(major, minor, build, qfe) \
        (((ULONGLONG)(major) << 48) |        \
         ((ULONGLONG)(minor) << 32) |        \
         ((ULONGLONG)(build) << 16) |        \
         ((ULONGLONG)(  qfe) <<  0))

//
// The caller should always GetProcAddress("DllGetVersion"), not
// implicitly link to it.
//

typedef HRESULT (CALLBACK* DLLGETVERSIONPROC)(DLLVERSIONINFO *);

// DllInstall (to be implemented by self-installing DLLs)
STDAPI DllInstall(__in BOOL bInstall, __in LPCWSTR pszCmdLine);


#if (_WIN32_IE >= 0x0602)
// Function to see if Internet Explorer Enhanced Security Configuration is active for the current user
LWSTDAPI_(BOOL) IsInternetESCEnabled();
#endif // (_WIN32_IE >= 0x0602)


#ifdef __cplusplus
}


#if defined(USE_STRICT_CONST) && !defined(NO_SHLWAPI_STRFCNS)

//=============================================================================
// C++ versions to help detect "const" violations

__inline LPSTR StrChrA(__in LPSTR lpStart, WORD wMatch)
{
    return const_cast<LPSTR>(StrChrA(const_cast<LPCSTR>(lpStart), wMatch));
}
__inline LPWSTR StrChrW(__in LPWSTR lpStart, __in WCHAR wMatch)
{
    return const_cast<LPWSTR>(StrChrW(const_cast<LPCWSTR>(lpStart), wMatch));
}
__inline LPSTR StrChrIA(__in LPSTR lpStart, WORD wMatch)
{
    return const_cast<LPSTR>(StrChrIA(const_cast<LPCSTR>(lpStart), wMatch));
}
__inline LPWSTR StrChrIW(__in LPWSTR lpStart, __in WCHAR wMatch)
{
    return const_cast<LPWSTR>(StrChrIW(const_cast<LPCWSTR>(lpStart), wMatch));
}
#if (_WIN32_IE >= _WIN32_IE_IE60)
__inline LPWSTR StrChrNW(__in LPWSTR lpStart, __in WCHAR wMatch, UINT cchMax)
{
    return const_cast<LPWSTR>(StrChrNW(const_cast<LPCWSTR>(lpStart), wMatch, cchMax));
}
__inline LPWSTR StrChrNIW(__in LPWSTR lpStart, __in WCHAR wMatch, UINT cchMax)
{
    return const_cast<LPWSTR>(StrChrNIW(const_cast<LPCWSTR>(lpStart), wMatch, cchMax));
}
#endif // _WIN32_IE_IE60
__inline LPSTR StrPBrkA(__in LPSTR psz, __in LPCSTR pszSet)
{
    return const_cast<LPSTR>(StrPBrkA(const_cast<LPCSTR>(psz), pszSet));
}
__inline LPWSTR StrPBrkW(__in LPWSTR psz, __in LPCWSTR pszSet)
{
    return const_cast<LPWSTR>(StrPBrkW(const_cast<LPCWSTR>(psz), pszSet));
}
__inline LPSTR StrRChrA(__in LPSTR lpStart, __in_opt LPCSTR lpEnd, __in WORD wMatch)
{
    return const_cast<LPSTR>(StrRChrA(const_cast<LPCSTR>(lpStart), lpEnd, wMatch));
}
__inline LPWSTR StrRChrW(__in LPWSTR lpStart, __in_opt LPCWSTR lpEnd, __in WCHAR wMatch)
{
    return const_cast<LPWSTR>(StrRChrW(const_cast<LPCWSTR>(lpStart), lpEnd, wMatch));
}
__inline LPSTR StrRChrIA(__in LPSTR lpStart, __in_opt LPCSTR lpEnd, __in WORD wMatch)
{
    return const_cast<LPSTR>(StrRChrIA(const_cast<LPCSTR>(lpStart), lpEnd, wMatch));
}
__inline LPWSTR StrRChrIW(__in LPWSTR lpStart, __in_opt LPCWSTR lpEnd, __in WCHAR wMatch)
{
    return const_cast<LPWSTR>(StrRChrIW(const_cast<LPCWSTR>(lpStart), lpEnd, wMatch));
}
__inline LPSTR StrRStrIA(__in LPSTR lpSource, __in_opt LPCSTR lpLast, __in LPCSTR lpSrch)
{
    return const_cast<LPSTR>(StrRStrIA(const_cast<LPCSTR>(lpSource), lpLast, lpSrch));
}
__inline LPWSTR StrRStrIW(__in LPWSTR lpSource, __in_opt LPCWSTR lpLast, __in LPCWSTR lpSrch)
{
    return const_cast<LPWSTR>(StrRStrIW(const_cast<LPCWSTR>(lpSource), lpLast, lpSrch));
}
__inline LPSTR StrStrA(__in LPSTR lpFirst, __in LPCSTR lpSrch)
{
    return const_cast<LPSTR>(StrStrA(const_cast<LPCSTR>(lpFirst), lpSrch));
}
__inline LPWSTR StrStrW(__in LPWSTR lpFirst, __in LPCWSTR lpSrch)
{
    return const_cast<LPWSTR>(StrStrW(const_cast<LPCWSTR>(lpFirst), lpSrch));
}
__inline LPSTR StrStrIA(__in LPSTR lpFirst, __in LPCSTR lpSrch)
{
    return const_cast<LPSTR>(StrStrIA(const_cast<LPCSTR>(lpFirst), lpSrch));
}
__inline LPWSTR StrStrIW(__in LPWSTR lpFirst, __in LPCWSTR lpSrch)
{
    return const_cast<LPWSTR>(StrStrIW(const_cast<LPCWSTR>(lpFirst), lpSrch));
}
#if (_WIN32_IE >= _WIN32_IE_IE60)
__inline LPWSTR StrStrNW(__in LPWSTR lpFirst, __in LPCWSTR lpSrch, __in UINT cchMax)
{
    return const_cast<LPWSTR>(StrStrNW(const_cast<LPCWSTR>(lpFirst), lpSrch, cchMax));
}
__inline LPWSTR StrStrNIW(__in LPWSTR lpFirst, __in LPCWSTR lpSrch, __in UINT cchMax)
{
    return const_cast<LPWSTR>(StrStrNIW(const_cast<LPCWSTR>(lpFirst), lpSrch, cchMax));
}
#endif
__inline LPSTR PathFindExtensionA(__in LPSTR pszPath)
{
    return const_cast<LPSTR>(PathFindExtensionA(const_cast<LPCSTR>(pszPath)));
}
__inline LPWSTR PathFindExtensionW(__in LPWSTR pszPath)
{
    return const_cast<LPWSTR>(PathFindExtensionW(const_cast<LPCWSTR>(pszPath)));
}
__inline LPSTR PathFindFileNameA(__in LPSTR pszPath)
{
    return const_cast<LPSTR>(PathFindFileNameA(const_cast<LPCSTR>(pszPath)));
}
__inline LPWSTR PathFindFileNameW(__in LPWSTR pszPath)
{
    return const_cast<LPWSTR>(PathFindFileNameW(const_cast<LPCWSTR>(pszPath)));
}
__inline LPSTR PathFindNextComponentA(__in LPSTR pszPath)
{
    return const_cast<LPSTR>(PathFindNextComponentA(const_cast<LPCSTR>(pszPath)));
}
__inline LPWSTR PathFindNextComponentW(__in LPWSTR pszPath)
{
    return const_cast<LPWSTR>(PathFindNextComponentW(const_cast<LPCWSTR>(pszPath)));
}
__inline LPSTR PathGetArgsA(__in LPSTR pszPath)
{
    return const_cast<LPSTR>(PathGetArgsA(const_cast<LPCSTR>(pszPath)));
}
__inline LPWSTR PathGetArgsW(__in LPWSTR pszPath)
{
    return const_cast<LPWSTR>(PathGetArgsW(const_cast<LPCWSTR>(pszPath)));
}
__inline LPSTR PathSkipRootA(__in LPSTR pszPath)
{
    return const_cast<LPSTR>(PathSkipRootA(const_cast<LPCSTR>(pszPath)));
}
__inline LPWSTR PathSkipRootW(__in LPWSTR pszPath)
{
    return const_cast<LPWSTR>(PathSkipRootW(const_cast<LPCWSTR>(pszPath)));
}
#endif

#endif

#if defined(DEPRECATE_SUPPORTED)
#pragma warning(pop)
#endif

#ifdef _WIN32
#include <poppack.h>
#endif

#endif


#endif  // _INC_SHLWAPI
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\sliddefs.h ===
/*++

Copyright (C) Microsoft Corporation, 2006

Module Name:

    sliddefs.h

Abstract:

    Software Licensing GUID definitions
   
--*/
#pragma once

#ifndef _SLIDDEFS_H_
#define _SLIDDEFS_H_

#ifdef __cplusplus
extern "C" {
#endif

#ifndef _WINDOWS_SLID_
#define _WINDOWS_SLID_
DEFINE_GUID(WINDOWS_SLID, 0x55c92734, 0xd682, 0x4d71, 0x98, 0x3e, 0xd6, 0xec, 0x3f, 0x16, 0x05, 0x9f);
#endif

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\SMPMS.h ===
/*
 *  S M P M S . H
 *
 *  Definitions used by the Microsoft Sample Message Store Provider
 *  for service entry calls.
 *
 *  The following MAPI-defined properties are settable in service
 *  entry calls for the Sample Message Store Provider.
 *  
 *  Copyright 1993-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef _SMPMS_H_
#define _SMPMS_H_

#define SMS_EXTERN_PROPID_BASE  0x6700      /* From MAPITAGS.H comments */

#define PR_SMS_PATH         PROP_TAG(PT_STRING8, SMS_EXTERN_PROPID_BASE + 0)
#define PR_SMS_PASSWORD     PROP_TAG(PT_STRING8, SMS_EXTERN_PROPID_BASE + 1)
#define PR_SMS_REMEMBER_PW  PROP_TAG(PT_BOOLEAN, SMS_EXTERN_PROPID_BASE + 2)
#define PR_SMS_CREATE       PROP_TAG(PT_BOOLEAN, SMS_EXTERN_PROPID_BASE + 3)


/* 
 *  The following is a description of each of the Sample Message Store
 *  Provider properties:
 *
 *  PR_SMS_PATH
 *      The full pathname to the root directory of the sample message store.
 *
 *  PR_SMS_PASSWORD
 *      The password needed to open the store (if already present), or the
 *      new password (if creating the store).
 *
 *  PR_SMS_REMEMBER_PW
 *      If non-zero (TRUE), this property asks the service entry to save the
 *      password in the profile, and to not prompt for it.
 *
 *  PR_SMS_CREATE
 *      If non-zero (TRUE), this property asks the service entry to create the
 *      sample store. Otherwise, the service entry will attempt to open an
 *      existing store.
 */

/*
 *  PR_MDB_PROVIDER is the GUID that represent the Sample Message Store
 *  Provider.  This guid is available as a property in the stores
 *  table and on the message store object.
 */
#define SMPMS_UID_PROVIDER      \
    {   0x38, 0x5d, 0x47, 0x5f, \
        0xec, 0xf1, 0xcd, 0x11, \
        0x93, 0xdc, 0x5a, 0xab, \
        0x3C, 0x47, 0x84, 0x37 }

#endif  /* _SMPMS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\SMPXP.h ===
/*
 *  S M P X P . H
 *
 *  Definitions used by the Microsoft Sample Transport provider
 *  for service entry calls.
 *
 *  The following MAPI-defined properties are settable in service
 *  entry calls for the Sample Transport Provider.
 *  
 *  Copyright 1993-1999 Microsoft Corporation. All Rights Reserved.
 */

#define BASE_ID 0x6600      /* From MAPITAGS.H comments */

#define PR_SAMPLE_DISPLAY_NAME      PROP_TAG (PT_TSTRING,   (BASE_ID + 0x0001))
#define PR_SAMPLE_EMAIL_ADDR_TYPE   PROP_TAG (PT_TSTRING,   (BASE_ID + 0x0002))
#define PR_SAMPLE_EMAIL_ADDRESS     PROP_TAG (PT_TSTRING,   (BASE_ID + 0x0003))
#define PR_SAMPLE_INBOUND_DIR       PROP_TAG (PT_TSTRING,   (BASE_ID + 0x0004))
#define PR_SAMPLE_OUTBOUND_DIR      PROP_TAG (PT_TSTRING,   (BASE_ID + 0x0005))
#define PR_SAMPLE_FILENAME          PROP_TAG (PT_TSTRING,   (BASE_ID + 0x0006))
#define PR_SAMPLE_DIRECTORY         PROP_TAG (PT_TSTRING,   (BASE_ID + 0x0007))
#define PR_SAMPLE_FLAGS             PROP_TAG (PT_LONG,      (BASE_ID + 0x0008))

#define PR_SAMPLE_FLAG_PEER_TO_PEER ((ULONG) 0x00000001)
#define PR_SAMPLE_FLAG_UI_ALWAYS    ((ULONG) 0x00000002)
#define PR_SAMPLE_FLAG_LOG_EVENTS   ((ULONG) 0x00000004)
#define PR_SAMPLE_FLAG_SAVE_DATA    ((ULONG) 0x00000008)

#define PR_SAMPLE_LOGFILE           PROP_TAG (PT_TSTRING,   (BASE_ID + 0x0009))
#define PR_SAMPLE_LOGHIGHWATER      PROP_TAG (PT_LONG,      (BASE_ID + 0x000A))
#define PR_SAMPLE_LOGLOWWATER       PROP_TAG (PT_LONG,      (BASE_ID + 0x000B))

/* 
 *  The following is a description of each of the Sample Tranpsort 
 *  Provider properties:
 *
 *  PR_SAMPLE_DISPLAY_NAME
 *      Display name of user.
 *
 *  PR_SAMPLE_EMAIL_ADDR_TYPE
 *      Address type of sample transport. This will be used to construct inbound
 *      and outbound addresses where needed. It also will be used to tell the
 *      Spooler what address types we should get.
 *
 *  PR_SAMPLE_EMAIL_ADDRESS
 *      Email address. This will usually be the same as the inbound directory,
 *      although this may tend to have a more canonical form for remote access.
 *
 *  PR_SAMPLE_INBOUND_DIR
 *      Inbound directory. This is where the transport will look in order to
 *      determine whether it has received any mail.
 *
 *  PR_SAMPLE_OUTBOUND_DIR
 *      Outbound directory. The transport will store its message files here
 *      while it is in the process of sending them. The presence of a file
 *      in this directory implies that the transport still has work to do.
 *
 *  PR_SAMPLE_FILENAME
 *      Filename. This is an 8-character root for use by mail-enabled or
 *      workgroup applications to build a complete file specification (by
 *      adding an extension) for data they wish to store for this user.
 *
 *  PR_SAMPLE_DIRECTORY
 *      Directory. This is a directory in which workgroup applications may
 *      wish to store their files pertaining to this user.
 *
 *  PR_SAMPLE_FLAGS
 *      Flags. Contain various options for this transport provider.
 *      Valid values are:
 *
 *          PR_SAMPLE_FLAG_PEER_TO_PEER
 *          PR_SAMPLE_FLAG_UI_ALWAYS
 *          PR_SAMPLE_FLAG_LOG_EVENTS
 *          PR_SAMPLE_FLAG_SAVE_DATA
 *
 *  PR_SAMPLE_LOGFILE
 *      Logfile. This is where logging information will be written. If this
 *      property is not present, we will use (PR_SAMPLE_FILENAME)".LOG"
 *
 *  PR_SAMPLE_LOGHIGHWATER
 *      Logfile high water mark. This is the point at which the log writer will
 *      truncate the logfile so as not to fill up the disk.
 *
 *  PR_SAMPLE_LOGLOWWATER
 *      Logfile low water mark. This is the approximate size that the logfile
 *      writer will truncate the logfile to (modulo a line ending).
 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\SmtpGuid.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: smtpguid.h
//
// Contents: Event related GUIDS published from SMTPSVC
//
// Instructions: Include this file to declare the various
//               GUIDS/strings as external global variables.
//               To actually define these global variables,
//               #define SMTPINITGUID and #include <initguid.h> before this
//               header file.
//
// History:
// Jeffrey C Stamerjohn 1998/07/14 15:22:29: Created.
//
//-------------------------------------------------------------
#ifndef __SMTPGUID_H__
#define __SMTPGUID_H__

#ifdef SMTPINITGUID
#define DECLARE_EVENTGUID_STRING( Name, Value ) \
    CONST WCHAR Name##[] = L##Value

#else //SMTPINITGUID
#define DECLARE_EVENTGUID_STRING( Name, Value ) \
    extern CONST WCHAR Name##[]

#endif //SMTPINITGUID

// SMTP SourceType GUID
// {fb65c4dc-e468-11d1-aa67-00c04fa345f6}
DECLARE_EVENTGUID_STRING( g_szGuidSmtpSourceType, "{fb65c4dc-e468-11d1-aa67-00c04fa345f6}");
DEFINE_GUID(GUID_SMTP_SOURCE_TYPE, 0xfb65c4dc, 0xe468, 0x11d1, 0xaa, 0x67, 0x0, 0xc0, 0x4f, 0xa3, 0x45, 0xf6);

/*
** SMTP Source GUID
*/
// {1b3c0666-e470-11d1-aa67-00c04fa345f6}
DECLARE_EVENTGUID_STRING( g_szGuidSmtpSvcSource, "{1b3c0666-e470-11d1-aa67-00c04fa345f6}");
DEFINE_GUID(GUID_SMTPSVC_SOURCE, 0x1b3c0666, 0xe470, 0x11d1, 0xaa, 0x67, 0x0, 0xc0, 0x4f, 0xa3, 0x45, 0xf6);

/*
**  Protocol Events
*/
// SMTP OnInboundCommand
// {F6628C8D-0D5E-11d2-AA68-00C04FA35B82}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnInboundCommand, "{F6628C8D-0D5E-11d2-AA68-00C04FA35B82}");
DEFINE_GUID(CATID_SMTP_ON_INBOUND_COMMAND, 0xf6628c8d, 0xd5e, 0x11d2, 0xaa, 0x68, 0x0, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);

// SMTP OnServerResponse
// {F6628C8E-0D5E-11d2-AA68-00C04FA35B82}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnServerResponse, "{F6628C8E-0D5E-11d2-AA68-00C04FA35B82}");
DEFINE_GUID(CATID_SMTP_ON_SERVER_RESPONSE, 0xf6628c8e, 0xd5e, 0x11d2, 0xaa, 0x68, 0x0, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);

// SMTP OnSessionStart
// {F6628C8F-0D5E-11d2-AA68-00C04FA35B82}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnSessionStart, "{F6628C8F-0D5E-11d2-AA68-00C04FA35B82}");
DEFINE_GUID(CATID_SMTP_ON_SESSION_START, 0xf6628c8f, 0xd5e, 0x11d2, 0xaa, 0x68, 0x0, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);

// SMTP OnMessageStart
// {F6628C90-0D5E-11d2-AA68-00C04FA35B82}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnMessageStart, "{F6628C90-0D5E-11d2-AA68-00C04FA35B82}");
DEFINE_GUID(CATID_SMTP_ON_MESSAGE_START, 0xf6628c90, 0xd5e, 0x11d2, 0xaa, 0x68, 0x0, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);

// SMTP OnPerRecipient
// {F6628C91-0D5E-11d2-AA68-00C04FA35B82}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnPerRecipient, "{F6628C91-0D5E-11d2-AA68-00C04FA35B82}");
DEFINE_GUID(CATID_SMTP_ON_PER_RECIPIENT, 0xf6628c91, 0xd5e, 0x11d2, 0xaa, 0x68, 0x0, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);

// Smtp OnBeforeData
// {F6628C92-0D5E-11d2-AA68-00C04FA35B82}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnBeforeData, "{F6628C92-0D5E-11d2-AA68-00C04FA35B82}");
DEFINE_GUID(CATID_SMTP_ON_BEFORE_DATA, 0xf6628c92, 0xd5e, 0x11d2, 0xaa, 0x68, 0x0, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);

// SMTP OnSessionEnd
// {F6628C93-0D5E-11d2-AA68-00C04FA35B82}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnSessionEnd, "{F6628C93-0D5E-11d2-AA68-00C04FA35B82}");
DEFINE_GUID(CATID_SMTP_ON_SESSION_END, 0xf6628c93, 0xd5e, 0x11d2, 0xaa, 0x68, 0x0, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);


/*
** Transport Events
*/

// SMTP Store Events
// {59175850-e533-11d1-aa67-00c04fa345f6}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpStoreDriver, "{59175850-e533-11d1-aa67-00c04fa345f6}");
DEFINE_GUID(CATID_SMTP_STORE_DRIVER, 0x59175850, 0xe533, 0x11d1, 0xaa, 0x67, 0x0, 0xc0, 0x4f, 0xa3, 0x45, 0xf6);

// SMTP OnTransportSubmission
// {FF3CAA23-00B9-11d2-9DFB-00C04FA322BA}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnTransportSubmission, "{FF3CAA23-00B9-11d2-9DFB-00C04FA322BA}");
DEFINE_GUID(CATID_SMTP_TRANSPORT_SUBMISSION, 0xff3caa23, 0xb9, 0x11d2, 0x9d, 0xfb, 0x0, 0xc0, 0x4f, 0xa3, 0x22, 0xba);


// SMTP onPrecategorize
// {A3ACFB0D-83FF-11d2-9E14-00C04FA322BA}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnPrecategorize, "{A3ACFB0D-83FF-11d2-9E14-00C04FA322BA}");
DEFINE_GUID(CATID_SMTP_TRANSPORT_PRECATEGORIZE, 0xa3acfb0d, 0x83ff, 0x11d2, 0x9e, 0x14, 0x0, 0xc0, 0x4f, 0xa3, 0x22, 0xba);

// SMTP Categorizer events
// {960252A3-0A3A-11d2-9E00-00C04FA322BA}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnCategorize, "{960252A3-0A3A-11d2-9E00-00C04FA322BA}");
DEFINE_GUID(CATID_SMTP_TRANSPORT_CATEGORIZE, 0x960252a3, 0xa3a, 0x11d2, 0x9e, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0x22, 0xba);

// SMTP onPostcategorize
// {76719654-05A6-11d2-9DFD-00C04FA322BA}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnPostcategorize, "{76719654-05A6-11d2-9dfd-00C04FA322BA}");
DEFINE_GUID(CATID_SMTP_TRANSPORT_POSTCATEGORIZE,
0x76719654, 0x5a6, 0x11d2, 0x9d, 0xfd, 0x0, 0xc0, 0x4f, 0xa3, 0x22, 0xba);


// SMTP OnTransportRouter
// {283430C9-1850-11d2-9E03-00C04FA322BA}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnTransportRouter, "{283430C9-1850-11d2-9E03-00C04FA322BA}");
DEFINE_GUID(CATID_SMTP_TRANSPORT_ROUTER, 0x283430c9, 0x1850, 0x11d2, 0x9e, 0x3, 0x0, 0xc0, 0x4f, 0xa3, 0x22, 0xba);

// SMTP MsgTrackLog
// {c6df52aa-7db0-11d2-94f4-00c04f79f1d6}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpMsgTrackLog, "{c6df52aa-7db0-11d2-94f4-00c04f79f1d6}");
DEFINE_GUID(CATID_SMTP_MSGTRACKLOG, 0xc6df52aa, 0x7db0, 0x11d2, 0x94, 0xf4, 0x0, 0xc0, 0x4f, 0x79, 0xf1, 0xd6);

// SMTP DnsResolver
// {bd0b4366-8e03-11d2-94f6-00c04f79f1d6}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpDnsResolver, "{bd0b4366-8e03-11d2-94f6-00c04f79f1d6}");
DEFINE_GUID(CATID_SMTP_DNSRESOLVERRECORDSINK, 0xbd0b4366, 0x8e03, 0x11d2, 0x94, 0xf6, 0x0, 0xc0, 0x4f, 0x79, 0xf1, 0xd6);

// SMTP MaxMsgSize
// {ebf159de-a67e-11d2-94f7-00c04f79f1d6}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpMaxMsgSize, "{ebf159de-a67e-11d2-94f7-00c04f79f1d6}");
DEFINE_GUID(CATID_SMTP_MAXMSGSIZE, 0xebf159de, 0xa67e, 0x11d2, 0x94, 0xf7, 0x0, 0xc0, 0x4f, 0x79, 0xf1, 0xd6);

// SMTP Log
// {93d0a538-2c1e-4b68-a7c9-d73a8aa6ee97}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpLog, "{93d0a538-2c1e-4b68-a7c9-d73a8aa6ee97}");
DEFINE_GUID(CATID_SMTP_LOG, 0x93d0a538, 0x2c1e, 0x4b68, 0xa7, 0xc9, 0xd7, 0x3a, 0x8a, 0xa6, 0xee, 0x97);

// SMTP GET_AUX_DOMAIN_INFO_FLAGS
// {84ff368a-fab3-43d7-bcdf-692c5b46e6b1}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpGetAuxDomainInfoFlags, "{84ff368a-fab3-43d7-bcdf-692c5b46e6b1}");
DEFINE_GUID(CATID_SMTP_GET_AUX_DOMAIN_INFO_FLAGS, 0x84ff368a, 0xfab3, 0x43d7, 0xbc, 0xdf, 0x69, 0x2c, 0x5b, 0x46, 0xe6, 0xb1);

//
// CLSID of the CoCreateable categorizer
//
// {B23C35B7-9219-11d2-9E17-00C04FA322BA}"
DEFINE_GUID(CLSID_SmtpCat, 0xb23c35b7, 0x9219, 0x11d2, 0x9e, 0x17, 0x0, 0xc0, 0x4f, 0xa3, 0x22, 0xba);

//
// SMTP DSN
//
// {22B55731-F5F8-4d23-BD8F-87B52371A73A}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpDSN, "{22B55731-F5F8-4D23-BD8F-87B52371A73A}");
DEFINE_GUID(CATID_SMTP_DSN, 0x22b55731, 0xf5f8, 0x4d23, 0xbd, 0x8f, 0x87, 0xb5, 0x23, 0x71, 0xa7, 0x3a);

#define SZ_PROGID_SMTPCAT   "Smtp.Cat"


#endif //__SMTPGUID_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\spapidef.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    spapidef.h

Abstract:

    Public header file for Windows NT Setup and Device Installer services Dll.

--*/

#ifndef _INC_SPAPIDEF
#define _INC_SPAPIDEF

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef SP_LOG_TOKEN
typedef DWORDLONG SP_LOG_TOKEN;
typedef DWORDLONG *PSP_LOG_TOKEN;
#endif


//
// Special txtlog token values
//

#define LOGTOKEN_TYPE_MASK              3

#define LOGTOKEN_UNSPECIFIED            0
#define LOGTOKEN_NO_LOG                 1
#define LOGTOKEN_SETUPAPI_APPLOG        2
#define LOGTOKEN_SETUPAPI_DEVLOG        3


//
// Flags for SetupCreateTextLogSection
//

#define TXTLOG_SETUPAPI_DEVLOG      0x00000001            // 1 = setupdi.log, 0 = setupapi.log
#define TXTLOG_SETUPAPI_CMDLINE     0x00000002            // log the command line

#define TXTLOG_SETUPAPI_BITS        0x00000003


//
// Flags for SetupWriteTextLog
//

//
// Event Levels (bits 0-3)
//

#define TXTLOG_ERROR                    0x1             // shows entries which indicate a real problem
#define TXTLOG_WARNING                  0x2             // shows entries which indicate a potential problem
#define TXTLOG_SYSTEM_STATE_CHANGE      0x3             // system changes only
#define TXTLOG_SUMMARY                  0x4             // show basic operation surrounding system changes
#define TXTLOG_DETAILS                  0x5             // detailed operation of the install process
#define TXTLOG_VERBOSE                  0x6             // log entries which potentially generate a lot of data
#define TXTLOG_VERY_VERBOSE             0x7             // highest level shows all log entries

//
// Bits reserved for internal use
//

#define TXTLOG_RESERVED_FLAGS   0x0000FFF0

//
// Basic flags (bits 4-31)
//

#define TXTLOG_TIMESTAMP        0x00010000
#define TXTLOG_DEPTH_INCR       0x00020000
#define TXTLOG_DEPTH_DECR       0x00040000
#define TXTLOG_TAB_1            0x00080000
#define TXTLOG_FLUSH_FILE       0x00100000

#define TXTLOG_LEVEL(flags) (flags & 0xf)


//
// Setupapi, Setupdi event categories
//

#define TXTLOG_DEVINST          0x00000001
#define TXTLOG_INF              0x00000002
#define TXTLOG_FILEQ            0x00000004
#define TXTLOG_COPYFILES        0x00000008

#define TXTLOG_SIGVERIF         0x00000020

#define TXTLOG_BACKUP           0x00000080
#define TXTLOG_UI               0x00000100
#define TXTLOG_UTIL             0x00000200
#define TXTLOG_INFDB            0x00000400

#define TXTLOG_POLICY           0x00800000
#define TXTLOG_NEWDEV           0x01000000
#define TXTLOG_UMPNPMGR         0x02000000
#define TXTLOG_DRIVER_STORE     0x04000000
#define TXTLOG_SETUP            0x08000000
#define TXTLOG_CMI              0x10000000
#define TXTLOG_DEVMGR           0x20000000

#define TXTLOG_INSTALLER        0x40000000
#define TXTLOG_VENDOR           0x80000000


#endif // _INC_SPAPIDEF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\slpublic.h ===
/*++

Copyright (C) Microsoft Corporation, 2006

Module Name:

    slpublic.h

Abstract:

    Software Licensing and Geniune Advantage Client public API
   
--*/
#pragma once

#ifndef _SLPUBLIC_H_
#define _SLPUBLIC_H_

#ifdef __cplusplus
extern "C" {
#endif

#define SLFreeMemory(p) LocalFree(p)
    
#define SLWGAFreeMemory(p) LocalFree(p)
    
typedef GUID SLID;
    
typedef enum _tagSLDATATYPE
{
    SL_DATA_NONE        = REG_NONE,
    SL_DATA_SZ          = REG_SZ,
    SL_DATA_DWORD       = REG_DWORD,
    SL_DATA_BINARY      = REG_BINARY,
    SL_DATA_MULTI_SZ    = REG_MULTI_SZ,
    SL_DATA_SUM         = 100,
} SLDATATYPE;

typedef enum _SL_GENUINE_STATE
{
    SL_GEN_STATE_IS_GENUINE         = 0,
    SL_GEN_STATE_INVALID_LICENSE,
    SL_GEN_STATE_TAMPERED,
    SL_GEN_STATE_LAST, 
} SL_GENUINE_STATE;

typedef struct _tagSL_NONGENUINE_UI_OPTIONS
{
    DWORD                       cbSize;
    CONST SLID*                 pComponentId;
    HRESULT                     hResultUI;

} SL_NONGENUINE_UI_OPTIONS;


#define SL_PROP_BRT_DATA                                    L"SL_BRT_DATA"
#define SL_PROP_BRT_COMMIT                                  L"SL_BRT_COMMIT"
#define SL_PROP_GENUINE_RESULT                              L"SL_GENUINE_RESULT"
#define SL_PROP_NONGENUINE_GRACE_FLAG                       L"SL_NONGENUINE_GRACE_FLAG"

__control_entrypoint(DllExport)
HRESULT 
WINAPI
SLGetWindowsInformation(
    __in PCWSTR pwszValueName,
    __out_opt SLDATATYPE* peDataType,
    __out UINT* pcbValue,
    __deref_out_bcount(*pcbValue) PBYTE* ppbValue
    );
/*++
Routine Description:

    This function is used to for Windows components to get 
    component policy value.
    
Arguments:

    pwszValueName
        The name of the requested value.
        
    peDataType
        Data type. Following types are supported:
            SL_DATA_SZ     - UNICODE string
            SL_DATA_DWORD  - DWORD
            SL_DATA_BINARY - Binary blob
        
    pcbValue
        Size of the allocated buffer.
        
    ppbValue
        The value. If successful, the data is returned in the buffer 
        allocated by SLC.
        The caller has to call SLFreeMemory to free the memory. 
        
Return Error:
    E_INVALIDARG
    SL_E_VALUE_NOT_FOUND
    SL_E_RIGHT_NOT_GRANTED
    
--*/

__control_entrypoint(DllExport)
HRESULT 
WINAPI
SLGetWindowsInformationDWORD(
    __in PCWSTR pwszValueName,
    __out DWORD* pdwValue
    );
/*++
Routine Description:

    This function is used to for Windows components to get 
    component policy DWORD value.

Arguments:

    pwszValueName
        The name of the requested value.
        
    pdwValue
        The buffer to receive DWORD value
        
Return Error:
    E_INVALIDARG
    SL_E_VALUE_NOT_FOUND
    SL_E_RIGHT_NOT_GRANTED
    SL_E_DATATYPE_MISMATCHED
    
--*/

__control_entrypoint(DllExport)
HRESULT
WINAPI
SLIsGenuineLocal(
    __in                        CONST SLID*                 pAppId,
    __out                       SL_GENUINE_STATE *          pGenuineState,
    __inout_opt                 SL_NONGENUINE_UI_OPTIONS*   pUIOptions
    );
/*++
Routine Description:

    Determines if an installation is a Genuine Windows installation.
    It interrogates the license for pAppId and inspects the "Tampered"
    flag.  If either the license for pAppId is invalid or the "Tampered"
    flag is set, the installation is assumed to be invalid.

    pGenuineState is ONLY modified if the result is S_OK.  Otherwise, it is
    left in the state in which it was found on function entry.

Arguments:

    pAppId
        Application identifier. 

    pbGenuineState
        Output state value - one of the SL_GENUINE_STATE values

    pUIOptions
        Non genuine UI options. If NULL, no UI is displayed if 
        state is non-genuine. 

Return Error:

    S_OK
        Operation completed successfully.

    E_INVALIDARG
        pGenuineState is NULL.

--*/

__control_entrypoint(DllExport)
HRESULT
WINAPI
SLAcquireGenuineTicket(
    __deref_out_bcount(*pcbTicketBlob) void ** ppTicketBlob,  
    __out UINT *pcbTicketBlob,
    __in PCWSTR pwszTemplateId, 
    __in PCWSTR pwszServerUrl, 
    __in_opt PCWSTR pwszClientToken 
    );
/*++
Routine Description:

    Returns genuine ticket acquired from Software Licensing Server based
    on SLWGA template blob. 
    
    The client is responsible for freeing the buffer returned in ppGenuineBlob.
    SLWGAFreeMemory should be used to free the memory.

    The output parameters are only set if the function returns S_OK.  Otherwise,
    they are left as they were when the function was entered.

Arguments:

    ppTicketBlob
        Pointer to output pointer to be returned (XrML genuine ticket).

    pcbTicketBlob
        An output pointer that will contain the size, in bytes, of the region
        returned in ppTicketBlob.

    pwszTemplateId
        Id of genuine blob template kept on the server side. 

    pwszServerUrl
        Ticket acquisition server url. 

    pwszClientToken
        Client custom token. 

Return Error:

    S_OK
        Operation completed successfully.

--*/

__control_entrypoint(DllExport)
HRESULT
WINAPI
SLGetInstalledSAMLicenseApplications(
    __out UINT* pnReturnedAppIds,
    __deref_out_ecount(*pnReturnedAppIds) SLID** ppReturnedAppIds
    );
/*++
Routine Description:

    Obtains an array of Application Ids representing applications whose SAM
    licenses have been installed with SLInstallSAMLicense.

Arguments:
    pnReturnedAppIds
        Number of elements in ppReturnedAppIds array
    ppReturnedAppIds
        Array containing all installed Application Ids.
        The caller has to call SLFreeMemory to free the memory.         
        
Return Errors:

    S_OK
        Operation completed successfully
    E_INVALIDARG
        One or more arguments are invalid    
    
--*/

__control_entrypoint(DllExport)
HRESULT
WINAPI
SLGetSAMLicense(
    __in const SLID* pApplicationId,
    __out UINT* pcbXmlLicenseData,
    __deref_out_bcount(*pcbXmlLicenseData) PBYTE* ppbXmlLicenseData
    );
/*++
Routine Description:

    Obtain information about an installed SAM application.

Arguments:
    pApplicationId
        Id of Application for which to obtain its SAM License
    pcbXmlLicenseData
        Size of ppbXmlLicenseData in bytes
    ppbXmlLicenseData
        License file data for (SAM) application with Application Id pApplicationId.
        The caller has to call SLFreeMemory to free the memory. 
        
Return Errors:

    S_OK
        Operation completed successfully
    SL_E_LICENSE_FILE_NOT_INSTALLED
        License not installed
    E_INVALIDARG
        One or more arguments are invalid    
    
--*/

__control_entrypoint(DllExport)
HRESULT
WINAPI
SLInstallSAMLicense(
    __in const SLID* pApplicationId,
    __in UINT cbXmlLicenseData,
    __in_bcount(cbXmlLicenseData) CONST BYTE* pbXmlLicenseData
    );
/*++
Routine Description:

    Install SAM License

Arguments:
    pApplicationId
        Id of Application for which to install SAM License.
    cbXmlLicenseData
        Size of pbXmlLicenseData in bytes
    pbXmlLicenseData
        License file data
        
Return Errors:

    S_OK
        Operation completed successfully
    SL_E_LUA_ACCESSDENIED
        The Software Licensing Service reported that the action requires administrator privilege
    E_INVALIDARG
        One or more arguments are invalid    
--*/

__control_entrypoint(DllExport)
HRESULT
WINAPI
SLUninstallSAMLicense(
    __in const SLID* pApplicationId
    );
/*++
Routine Description:

    UnInstall SAM License

Arguments:
    pApplicationId
        Id of Application for which to uninstall SAM License.
        
Return Errors:

    S_OK
        Operation completed successfully
    SL_E_LICENSE_FILE_NOT_INSTALLED
        License not installed
    SL_E_LUA_ACCESSDENIED
        The Software Licensing Service reported that the action requires administrator privilege
    E_INVALIDARG
        One or more arguments are invalid    
    
--*/

__control_entrypoint(DllExport)
HRESULT
WINAPI
SLSetGenuineInformation(
    __in CONST SLID* pAppId,
    __in PCWSTR pwszValueName,
    __in SLDATATYPE eDataType,
    __in_opt UINT cbValue,
    __in_bcount_opt(cbValue) CONST BYTE* pbValue
    );
/*++
Routine Description:

    This function sets genuine information.

Arguments:

    hSLC
        Handle to current SLC session.

    pAppId
        Application ID. E.g. Windows AppId
        
    pwszValueName
        The name of value.
        TBD
                                                
    eType
        See SLDATATYPE
        
    cbValue
        Size of value
    
    pbValue
        Value.
        Some properties allows NULL pointer, which can be used to delete
        the property but some properties can't.

Return Value:
    HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW)
        The size of value is over expected size
    E_ACCESSDENIED
        Admin privilege required
    E_INVALIDAGR
        Some property does not allow NULL value
    SL_E_NOT_SUPPORTED
        The name of value is not supported
    SL_E_DEPENDENT_PROPERTY_NOT_SET    
        If entry has been set
    SL_E_DATATYPE_MISMATCHED
        The type of data is mismatched with the expected type 
        of specified value name
--*/

__control_entrypoint(DllExport)
HRESULT
WINAPI
SLGetGenuineInformation(
    __in CONST SLID* pAppId,
    __in PCWSTR pwszValueName,
    __out_opt SLDATATYPE* peDataType,
    __out UINT* pcbValue,
    __deref_out_bcount(*pcbValue) BYTE** ppbValue
    );
/*++
Routine Description:

    This function gets genuine information.

Arguments:

    hSLC
        Handle to current SLC session.

    pAppId
        Application ID. E.g. Windows AppId
        
    pwszValueName
        See SLSetOfflineGenuineInformation
        
    eType
        See SLDATATYPE
        
    cbValue
        Size of value
        
    pbValue
        Value

Return Value:
    SL_E_NOT_SUPPORTED
        The name of value is not supported
    SL_E_VALUE_NOT_FOUND
        The specified value can not be found    
--*/                

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\slerror.h ===
/*++

   slerror.h --  error code definitions for the Software Licensing

   Copyright (c) Microsoft Corp.  All rights reserved.

--*/

#ifndef __SLERROR_H__
#define __SLERROR_H__

#if defined (_MSC_VER) && (_MSC_VER >= 1020) && !defined(__midl)
#pragma once
#endif

#define SL_SERVER_ZONE     0xB000 // zone for SL server errors
#define SL_MSCH_ZONE       0xC000 // zone for SL clearing house errors
// 0XD000 is reserved for SP
#define SL_INTERNAL_ZONE   0xE000 // zone for SL service internal errors
#define SL_CLIENTAPI_ZONE  0xF000 // zone for SL client API errors

#define IS_SL_SERVER_ERROR(hr)     ((hr & 0xF000) == SL_SERVER_ZONE)
#define IS_SL_MSCH_ERROR(hr)       ((hr & 0xF000) == SL_MSCH_ZONE)
#define IS_SL_INTERNAL_ERROR(hr)   ((hr & 0xF000) == SL_INTERNAL_ZONE)
#define IS_SL_SERVICE_ERROR(hr)    ((hr & 0xF000) == SL_SERVICE_ZONE)
#define IS_SL_CLIENTAPI_ERROR(hr)  ((hr & 0xF000) == SL_CLIENTAPI_ZONE)

#define IS_SL_VGA_STRICT_ERROR(hr)  (((hr & 0xF000) == SL_MSCH_ZONE) && ((hr & 0xFFF) >= 0x401) && ((hr & 0xFFF) <= 0x496))
#define IS_SL_VGA_LITE_ERROR(hr)  (((hr & 0xF000) == SL_MSCH_ZONE) && ((hr & 0xFFF) >= 0x497) && ((hr & 0xFFF) <= 0x600))


//////////////////////////////////////////////////////////
//     SL Server errors
//     These error codes come from SL Server
//////////////////////////////////////////////////////////

//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_SL_ITF                  0x4


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: SL_E_SRV_INVALID_PUBLISH_LICENSE
//
// MessageText:
//
// The activation server determined that the license is invalid.
//
#define SL_E_SRV_INVALID_PUBLISH_LICENSE ((HRESULT)0xC004B001L)

//
// MessageId: SL_E_SRV_INVALID_PRODUCT_KEY_LICENSE
//
// MessageText:
//
// The activation server determined that the license is invalid.
//
#define SL_E_SRV_INVALID_PRODUCT_KEY_LICENSE ((HRESULT)0xC004B002L)

//
// MessageId: SL_E_SRV_INVALID_RIGHTS_ACCOUNT_LICENSE
//
// MessageText:
//
// The activation server determined that the license is invalid.
//
#define SL_E_SRV_INVALID_RIGHTS_ACCOUNT_LICENSE ((HRESULT)0xC004B003L)

//
// MessageId: SL_E_SRV_INVALID_LICENSE_STRUCTURE
//
// MessageText:
//
// The activation server determined that the license is invalid.
//
#define SL_E_SRV_INVALID_LICENSE_STRUCTURE ((HRESULT)0xC004B004L)

//
// MessageId: SL_E_SRV_AUTHORIZATION_FAILED
//
// MessageText:
//
// The activation server determined that the license is invalid.
//
#define SL_E_SRV_AUTHORIZATION_FAILED    ((HRESULT)0xC004B005L)

//
// MessageId: SL_E_SRV_INVALID_BINDING
//
// MessageText:
//
// The activation server determined that the license is invalid.
//
#define SL_E_SRV_INVALID_BINDING         ((HRESULT)0xC004B006L)

//
// MessageId: SL_E_SRV_SERVER_PONG
//
// MessageText:
//
// The activation server reported that the computer could not connect to the activation server.
//
#define SL_E_SRV_SERVER_PONG             ((HRESULT)0xC004B007L)

//
// MessageId: SL_E_SRV_INVALID_PAYLOAD
//
// MessageText:
//
// The activation server determined that the computer could not be activated.
//
#define SL_E_SRV_INVALID_PAYLOAD         ((HRESULT)0xC004B008L)

//
// MessageId: SL_E_SRV_TRIAL_KEY
//
// MessageText:
//
// The activation server determined that you are using a trial product key.  You must change your product key before you can activate.
//
#define SL_E_SRV_TRIAL_KEY               ((HRESULT)0xC004B009L)

//
// MessageId: SL_E_SRV_GENERAL_ERROR
//
// MessageText:
//
// The activation server determined that the computer could not be activated.
//
#define SL_E_SRV_GENERAL_ERROR           ((HRESULT)0xC004B100L)

////////////////////////////////////////////////////////////////
//     Clearing house errors
//     These error codes come from MSCH PA Implementation
////////////////////////////////////////////////////////////////

//
// MessageId: SL_E_CHPA_PRODUCT_KEY_OUT_OF_RANGE
//
// MessageText:
//
// The activation server determined the specified product key is invalid.
//
#define SL_E_CHPA_PRODUCT_KEY_OUT_OF_RANGE ((HRESULT)0xC004C001L)

//
// MessageId: SL_E_CHPA_INVALID_BINDING
//
// MessageText:
//
// The activation server determined there is a problem with the specified product key.
//
#define SL_E_CHPA_INVALID_BINDING        ((HRESULT)0xC004C002L)

//
// MessageId: SL_E_CHPA_PRODUCT_KEY_BLOCKED
//
// MessageText:
//
// The activation server determined the specified product key is in use.
//
#define SL_E_CHPA_PRODUCT_KEY_BLOCKED    ((HRESULT)0xC004C003L)

//
// MessageId: SL_E_CHPA_INVALID_PRODUCT_KEY
//
// MessageText:
//
// The activation server determined the specified product key is invalid. 
//
#define SL_E_CHPA_INVALID_PRODUCT_KEY    ((HRESULT)0xC004C004L)

//
// MessageId: SL_E_CHPA_BINDING_NOT_FOUND
//
// MessageText:
//
// The activation server determined the license is invalid.
//
#define SL_E_CHPA_BINDING_NOT_FOUND      ((HRESULT)0xC004C005L)

//
// MessageId: SL_E_CHPA_BINDING_MAPPING_NOT_FOUND
//
// MessageText:
//
// The activation server determined the license is invalid.
//
#define SL_E_CHPA_BINDING_MAPPING_NOT_FOUND ((HRESULT)0xC004C006L)

//
// MessageId: SL_E_CHPA_UNSUPPORTED_PRODUCT_KEY
//
// MessageText:
//
// The activation server determined the specified product key is invalid.
//
#define SL_E_CHPA_UNSUPPORTED_PRODUCT_KEY ((HRESULT)0xC004C007L)

//
// MessageId: SL_E_CHPA_MAXIMUM_UNLOCK_EXCEEDED
//
// MessageText:
//
// The activation server determined that the specified product key could not be used.
//
#define SL_E_CHPA_MAXIMUM_UNLOCK_EXCEEDED ((HRESULT)0xC004C008L)

//
// MessageId: SL_E_CHPA_ACTCONFIG_ID_NOT_FOUND
//
// MessageText:
//
// The activation server determined the license is invalid.
//
#define SL_E_CHPA_ACTCONFIG_ID_NOT_FOUND ((HRESULT)0xC004C009L)

//
// MessageId: SL_E_CHPA_INVALID_PRODUCT_DATA_ID
//
// MessageText:
//
// The activation server determined the license is invalid.
//
#define SL_E_CHPA_INVALID_PRODUCT_DATA_ID ((HRESULT)0xC004C00AL)

//
// MessageId: SL_E_CHPA_INVALID_PRODUCT_DATA
//
// MessageText:
//
// The activation server determined the license is invalid.
//
#define SL_E_CHPA_INVALID_PRODUCT_DATA   ((HRESULT)0xC004C00BL)

//
// MessageId: SL_E_CHPA_SYSTEM_ERROR
//
// MessageText:
//
// The activation server experienced an error.
//
#define SL_E_CHPA_SYSTEM_ERROR           ((HRESULT)0xC004C00CL)

//
// MessageId: SL_E_CHPA_INVALID_ACTCONFIG_ID
//
// MessageText:
//
// The activation server determined the license is invalid.
//
#define SL_E_CHPA_INVALID_ACTCONFIG_ID   ((HRESULT)0xC004C00DL)

//
// MessageId: SL_E_CHPA_INVALID_PRODUCT_KEY_LENGTH
//
// MessageText:
//
// The activation server determined the specified product key is invalid.
//
#define SL_E_CHPA_INVALID_PRODUCT_KEY_LENGTH ((HRESULT)0xC004C00EL)

//
// MessageId: SL_E_CHPA_INVALID_PRODUCT_KEY_FORMAT
//
// MessageText:
//
// The activation server determined the specified product key is invalid.
//
#define SL_E_CHPA_INVALID_PRODUCT_KEY_FORMAT ((HRESULT)0xC004C00FL)

//
// MessageId: SL_E_CHPA_INVALID_PRODUCT_KEY_CHAR
//
// MessageText:
//
// The activation server determined the specified product key is invalid.
//
#define SL_E_CHPA_INVALID_PRODUCT_KEY_CHAR ((HRESULT)0xC004C010L)

//
// MessageId: SL_E_CHPA_INVALID_BINDING_URI
//
// MessageText:
//
// The activation server determined the license is invalid.
//
#define SL_E_CHPA_INVALID_BINDING_URI    ((HRESULT)0xC004C011L)

//
// MessageId: SL_E_CHPA_NETWORK_ERROR
//
// MessageText:
//
// The activation server experienced a network error.
//
#define SL_E_CHPA_NETWORK_ERROR          ((HRESULT)0xC004C012L)

//
// MessageId: SL_E_CHPA_DATABASE_ERROR
//
// MessageText:
//
// The activation server experienced an error.
//
#define SL_E_CHPA_DATABASE_ERROR         ((HRESULT)0xC004C013L)

//
// MessageId: SL_E_CHPA_INVALID_ARGUMENT
//
// MessageText:
//
// The activation server experienced an error.
//
#define SL_E_CHPA_INVALID_ARGUMENT       ((HRESULT)0xC004C014L)

//
// MessageId: SL_E_CHPA_DMAK_LIMIT_EXCEEDED
//
// MessageText:
//
// The activation server reported that the Multiple Activation Key has exceeded its limit.
//
#define SL_E_CHPA_DMAK_LIMIT_EXCEEDED    ((HRESULT)0xC004C020L)

//
// MessageId: SL_E_CHPA_DMAK_EXTENSION_LIMIT_EXCEEDED
//
// MessageText:
//
// The activation server reported that the Multiple Activation Key extension limit has been exceeded.
//
#define SL_E_CHPA_DMAK_EXTENSION_LIMIT_EXCEEDED ((HRESULT)0xC004C021L)

//
// MessageId: SL_E_CHPA_REISSUANCE_LIMIT_NOT_FOUND
//
// MessageText:
//
// The activation server reported that the re-issuance limit was not found. 
//
#define SL_E_CHPA_REISSUANCE_LIMIT_NOT_FOUND ((HRESULT)0xC004C022L)

//
// MessageId: SL_E_CHPA_OVERRIDE_REQUEST_NOT_FOUND
//
// MessageText:
//
// The activation server reported that the override request was not found. 
//
#define SL_E_CHPA_OVERRIDE_REQUEST_NOT_FOUND ((HRESULT)0xC004C023L)

//
// MessageId: SL_E_CHPA_OEM_SLP_COA0
//
// MessageText:
//
// The activation server reported that the specified product key cannot be used for online activation.
//
#define SL_E_CHPA_OEM_SLP_COA0           ((HRESULT)0xC004C016L)

//
// MessageId: SL_E_CHPA_RESPONSE_NOT_AVAILABLE
//
// MessageText:
//
// The activation server experienced an error.
//
#define SL_E_CHPA_RESPONSE_NOT_AVAILABLE ((HRESULT)0xC004C015L)

//
// MessageId: SL_E_CHPA_GENERAL_ERROR
//
// MessageText:
//
// The activation server experienced a general error.
//
#define SL_E_CHPA_GENERAL_ERROR          ((HRESULT)0xC004C050L)

////////////////////////////////////////////////////////////////
//     VGA (Vista Genuine Advantage) error code range
////////////////////////////////////////////////////////////////
//
// MessageId: SL_E_VGA_NON_GENUINE_STATUS_FIRST
//
// MessageText:
//
// The Vista Genuine Advantage Service determined that the installation is not genuine. 
//
#define SL_E_VGA_NON_GENUINE_STATUS_FIRST ((HRESULT)0xC004C401L)

//
// MessageId: SL_E_VGA_NON_GENUINE_STATUS_LAST
//
// MessageText:
//
// The Vista Genuine Advantage Service determined that the installation is not genuine. 
//
#define SL_E_VGA_NON_GENUINE_STATUS_LAST ((HRESULT)0xC004C600L)

////////////////////////////////////////////////////////////////
//     Clearing house errors
//     These error codes come from MSCH Reference Implementation
////////////////////////////////////////////////////////////////

//
// MessageId: SL_E_CHREF_INVALID_PRODUCT_KEY
//
// MessageText:
//
// The activation server determined the specified product key is invalid.
//
#define SL_E_CHREF_INVALID_PRODUCT_KEY   ((HRESULT)0xC004C801L)

//
// MessageId: SL_E_CHREF_EXCLUDED_PRODUCT_KEY
//
// MessageText:
//
// The activation server determined the specified product key is invalid.
//
#define SL_E_CHREF_EXCLUDED_PRODUCT_KEY  ((HRESULT)0xC004C802L)

//
// MessageId: SL_E_CHREF_PRODUCT_KEY_REVOKED
//
// MessageText:
//
// The activation server determined the specified product key has been revoked.
//
#define SL_E_CHREF_PRODUCT_KEY_REVOKED   ((HRESULT)0xC004C803L)

//
// MessageId: SL_E_CHREF_INVALID_PRODUCT_KEY_ALGORITHM
//
// MessageText:
//
// The activation server determined the specified product key is invalid.
//
#define SL_E_CHREF_INVALID_PRODUCT_KEY_ALGORITHM ((HRESULT)0xC004C804L)

//
// MessageId: SL_E_CHREF_INVALID_PRODUCT_KEY_UNIQUEID
//
// MessageText:
//
// The activation server determined the specified product key is invalid.
//
#define SL_E_CHREF_INVALID_PRODUCT_KEY_UNIQUEID ((HRESULT)0xC004C805L)

//
// MessageId: SL_E_CHREF_INVALID_PRODUCT_DATA
//
// MessageText:
//
// The activation server determined the specified product key is invalid.
//
#define SL_E_CHREF_INVALID_PRODUCT_DATA  ((HRESULT)0xC004C810L)

//
// MessageId: SL_E_CHREF_CANNOT_CREATE_BINDING_ASSOC
//
// MessageText:
//
// The activation server determined the license is invalid.
//
#define SL_E_CHREF_CANNOT_CREATE_BINDING_ASSOC ((HRESULT)0xC004C811L)

//
// MessageId: SL_E_CHREF_BINDING_OUT_OF_TOLERANCE
//
// MessageText:
//
// The activation server determined that the specified product key has exceeded its activation count.
//
#define SL_E_CHREF_BINDING_OUT_OF_TOLERANCE ((HRESULT)0xC004C812L)

//
// MessageId: SL_E_CHREF_PRODUCT_KEY_POLICY_MISSING
//
// MessageText:
//
// The activation server determined the license is invalid.
//
#define SL_E_CHREF_PRODUCT_KEY_POLICY_MISSING ((HRESULT)0xC004C813L)

//
// MessageId: SL_E_CHREF_PRODUCT_KEY_POLICY_OVERLAPPED
//
// MessageText:
//
// The activation server determined the specified product key is invalid.
//
#define SL_E_CHREF_PRODUCT_KEY_POLICY_OVERLAPPED ((HRESULT)0xC004C814L)

//
// MessageId: SL_E_CHREF_PRODUCT_KEY_BINDING_MISMATCH
//
// MessageText:
//
// The activation server determined the license is invalid.
//
#define SL_E_CHREF_PRODUCT_KEY_BINDING_MISMATCH ((HRESULT)0xC004C815L)

//
// MessageId: SL_E_CHREF_OEM_SLP_COA0
//
// MessageText:
//
// The activation server reported that the specified product key cannot be used for online activation.
//
#define SL_E_CHREF_OEM_SLP_COA0          ((HRESULT)0xC004C816L)

//////////////////////////////////////////////////////////
// SL service internal error
//     Internal program errors for SL develpers
//////////////////////////////////////////////////////////

//
// MessageId: SL_E_INVALID_CONTEXT
//
// MessageText:
//
// The Software Licensing Service determined that the specified context is invalid.
//
#define SL_E_INVALID_CONTEXT             ((HRESULT)0xC004E001L)

//
// MessageId: SL_E_TOKEN_STORE_INVALID_STATE
//
// MessageText:
//
// The Software Licensing Service reported that the license store contains inconsistent data.
//
#define SL_E_TOKEN_STORE_INVALID_STATE   ((HRESULT)0xC004E002L)

//
// MessageId: SL_E_EVALUATION_FAILED
//
// MessageText:
//
// The Software Licensing Service reported that license evaluation failed.
//
#define SL_E_EVALUATION_FAILED           ((HRESULT)0xC004E003L)

//
// MessageId: SL_E_NOT_EVALUATED
//
// MessageText:
//
// The Software Licensing Service reported that the license has not been evaluated.
//
#define SL_E_NOT_EVALUATED               ((HRESULT)0xC004E004L)

//
// MessageId: SL_E_NOT_ACTIVATED
//
// MessageText:
//
// The Software Licensing Service reported that the license is not activated.
//
#define SL_E_NOT_ACTIVATED               ((HRESULT)0xC004E005L)

//
// MessageId: SL_E_INVALID_GUID
//
// MessageText:
//
// The Software Licensing Service reported that the license contains invalid data.
//
#define SL_E_INVALID_GUID                ((HRESULT)0xC004E006L)

//
// MessageId: SL_E_TOKSTO_TOKEN_NOT_FOUND
//
// MessageText:
//
// The Software Licensing Service reported that the license store does not contain the requested license.
//
#define SL_E_TOKSTO_TOKEN_NOT_FOUND      ((HRESULT)0xC004E007L)

//
// MessageId: SL_E_TOKSTO_NO_PROPERTIES
//
// MessageText:
//
// The Software Licensing Service reported that the license property is invalid.
//
#define SL_E_TOKSTO_NO_PROPERTIES        ((HRESULT)0xC004E008L)

//
// MessageId: SL_E_TOKSTO_NOT_INITIALIZED
//
// MessageText:
//
// The Software Licensing Service reported that the license store is not initialized.
//
#define SL_E_TOKSTO_NOT_INITIALIZED      ((HRESULT)0xC004E009L)

//
// MessageId: SL_E_TOKSTO_ALREADY_INITIALIZED
//
// MessageText:
//
// The Software Licensing Service reported that the license store is already initialized.
//
#define SL_E_TOKSTO_ALREADY_INITIALIZED  ((HRESULT)0xC004E00AL)

//
// MessageId: SL_E_TOKSTO_NO_ID_SET
//
// MessageText:
//
// The Software Licensing Service reported that the license property is invalid.
//
#define SL_E_TOKSTO_NO_ID_SET            ((HRESULT)0xC004E00BL)

//
// MessageId: SL_E_TOKSTO_CANT_CREATE_FILE
//
// MessageText:
//
// The Software Licensing Service reported that the license could not be opened or created.
//
#define SL_E_TOKSTO_CANT_CREATE_FILE     ((HRESULT)0xC004E00CL)

//
// MessageId: SL_E_TOKSTO_CANT_WRITE_TO_FILE
//
// MessageText:
//
// The Software Licensing Service reported that the license could not be written.
//
#define SL_E_TOKSTO_CANT_WRITE_TO_FILE   ((HRESULT)0xC004E00DL)

//
// MessageId: SL_E_TOKSTO_CANT_READ_FILE
//
// MessageText:
//
// The Software Licensing Service reported that the license store could not read the license file.
//
#define SL_E_TOKSTO_CANT_READ_FILE       ((HRESULT)0xC004E00EL)

//
// MessageId: SL_E_TOKSTO_CANT_PARSE_PROPERTIES
//
// MessageText:
//
// The Software Licensing Service reported that the license property is corrupted.
//
#define SL_E_TOKSTO_CANT_PARSE_PROPERTIES ((HRESULT)0xC004E00FL)

//
// MessageId: SL_E_TOKSTO_PROPERTY_NOT_FOUND
//
// MessageText:
//
// The Software Licensing Service reported that the license property is missing.
//
#define SL_E_TOKSTO_PROPERTY_NOT_FOUND   ((HRESULT)0xC004E010L)

//
// MessageId: SL_E_TOKSTO_INVALID_FILE
//
// MessageText:
//
// The Software Licensing Service reported that the license store contains an invalid license file.
//
#define SL_E_TOKSTO_INVALID_FILE         ((HRESULT)0xC004E011L)

//
// MessageId: SL_E_TOKSTO_CANT_CREATE_MUTEX
//
// MessageText:
//
// The Software Licensing Service reported that the license store failed to start synchronization properly.
//
#define SL_E_TOKSTO_CANT_CREATE_MUTEX    ((HRESULT)0xC004E012L)

//
// MessageId: SL_E_TOKSTO_CANT_ACQUIRE_MUTEX
//
// MessageText:
//
// The Software Licensing Service reported that the license store failed to synchronize properly.
//
#define SL_E_TOKSTO_CANT_ACQUIRE_MUTEX   ((HRESULT)0xC004E013L)

//
// MessageId: SL_E_TOKSTO_NO_TOKEN_DATA
//
// MessageText:
//
// The Software Licensing Service reported that the license property is invalid.
//
#define SL_E_TOKSTO_NO_TOKEN_DATA        ((HRESULT)0xC004E014L)

//
// MessageId: SL_E_EUL_CONSUMPTION_FAILED
//
// MessageText:
//
// The Software Licensing Service reported that license consumption failed.
//
#define SL_E_EUL_CONSUMPTION_FAILED      ((HRESULT)0xC004E015L)

//
// MessageId: SL_E_PKEY_INVALID_CONFIG
//
// MessageText:
//
// The Software Licensing Service reported that the product key is invalid.
//
#define SL_E_PKEY_INVALID_CONFIG         ((HRESULT)0xC004E016L)

//
// MessageId: SL_E_PKEY_INVALID_UNIQUEID
//
// MessageText:
//
// The Software Licensing Service reported that the product key is invalid.
//
#define SL_E_PKEY_INVALID_UNIQUEID       ((HRESULT)0xC004E017L)

//
// MessageId: SL_E_PKEY_INVALID_ALGORITHM
//
// MessageText:
//
// The Software Licensing Service reported that the product key is invalid.
//
#define SL_E_PKEY_INVALID_ALGORITHM      ((HRESULT)0xC004E018L)

//
// MessageId: SL_E_PKEY_INTERNAL_ERROR
//
// MessageText:
//
// The Software Licensing Service determined that validation of the specified product key failed.
//
#define SL_E_PKEY_INTERNAL_ERROR         ((HRESULT)0xC004E019L)

//
// MessageId: SL_E_LICENSE_INVALID_ADDON_INFO
//
// MessageText:
//
// The Software Licensing Service reported that invalid add-on information was found. 
//
#define SL_E_LICENSE_INVALID_ADDON_INFO  ((HRESULT)0xC004E01AL)

//
// MessageId: SL_E_HWID_ERROR
//
// MessageText:
//
// The Software Licensing Service reported that not all hardware information could be collected. 
//
#define SL_E_HWID_ERROR                  ((HRESULT)0xC004E01BL)

////////////////////////////////////////////////////////////////
//     Internal Token Store errors
//     0xE1xx is reserved for Token Store internal errors
////////////////////////////////////////////////////////////////

//
// MessageId: SL_E_SFS_INVALID_FS_VERSION
//
// MessageText:
//
// The Software Licensing Service reported that the Token Store file version is invalid. 
//
#define SL_E_SFS_INVALID_FS_VERSION      ((HRESULT)0x8004E101L)

//
// MessageId: SL_E_SFS_INVALID_FD_TABLE
//
// MessageText:
//
// The Software Licensing Service reported that the Token Store contains an invalid descriptor table. 
//
#define SL_E_SFS_INVALID_FD_TABLE        ((HRESULT)0x8004E102L)

//
// MessageId: SL_E_SFS_INVALID_SYNC
//
// MessageText:
//
// The Software Licensing Service reported that the Token Store contains a token with an invalid header/footer. 
//
#define SL_E_SFS_INVALID_SYNC            ((HRESULT)0x8004E103L)

//
// MessageId: SL_E_SFS_BAD_TOKEN_NAME
//
// MessageText:
//
// The Software Licensing Service reported that a Token Store token has an invalid name. 
//
#define SL_E_SFS_BAD_TOKEN_NAME          ((HRESULT)0x8004E104L)

//
// MessageId: SL_E_SFS_BAD_TOKEN_EXT
//
// MessageText:
//
// The Software Licensing Service reported that a Token Store token has an invalid extension. 
//
#define SL_E_SFS_BAD_TOKEN_EXT           ((HRESULT)0x8004E105L)

//
// MessageId: SL_E_SFS_DUPLICATE_TOKEN_NAME
//
// MessageText:
//
// The Software Licensing Service reported that the Token Store contains a duplicate token. 
//
#define SL_E_SFS_DUPLICATE_TOKEN_NAME    ((HRESULT)0x8004E106L)

//
// MessageId: SL_E_SFS_TOKEN_SIZE_MISMATCH
//
// MessageText:
//
// The Software Licensing Service reported that a token in the Token Store has a size mismatch. 
//
#define SL_E_SFS_TOKEN_SIZE_MISMATCH     ((HRESULT)0x8004E107L)

//
// MessageId: SL_E_SFS_INVALID_TOKEN_DATA_HASH
//
// MessageText:
//
// The Software Licensing Service reported that a token in the Token Store contains an invalid hash. 
//
#define SL_E_SFS_INVALID_TOKEN_DATA_HASH ((HRESULT)0x8004E108L)

//
// MessageId: SL_E_SFS_FILE_READ_ERROR
//
// MessageText:
//
// The Software Licensing Service reported that the Token Store was unable to read a token. 
//
#define SL_E_SFS_FILE_READ_ERROR         ((HRESULT)0x8004E109L)

//
// MessageId: SL_E_SFS_FILE_WRITE_ERROR
//
// MessageText:
//
// The Software Licensing Service reported that the Token Store was unable to write a token. 
//
#define SL_E_SFS_FILE_WRITE_ERROR        ((HRESULT)0x8004E10AL)

//
// MessageId: SL_E_SFS_INVALID_FILE_POSITION
//
// MessageText:
//
// The Software Licensing Service reported that the Token Store attempted an invalid file operation. 
//
#define SL_E_SFS_INVALID_FILE_POSITION   ((HRESULT)0x8004E10BL)


//////////////////////////////////////////////////////////
// Extended SL Client API error, license evaluation errors
//////////////////////////////////////////////////////////

//
// MessageId: SL_E_INTERNAL_ERROR
//
// MessageText:
//
// The Software Licensing Service reported an internal error.
//
#define SL_E_INTERNAL_ERROR              ((HRESULT)0xC004F001L)

//
// MessageId: SL_E_RIGHT_NOT_CONSUMED
//
// MessageText:
//
// The Software Licensing Service reported that rights consumption failed.
//
#define SL_E_RIGHT_NOT_CONSUMED          ((HRESULT)0xC004F002L)

//
// MessageId: SL_E_USE_LICENSE_NOT_INSTALLED
//
// MessageText:
//
// The Software Licensing Service reported that the required license could not be found.
//
#define SL_E_USE_LICENSE_NOT_INSTALLED   ((HRESULT)0xC004F003L)

//
// MessageId: SL_E_MISMATCHED_PKEY_RANGE
//
// MessageText:
//
// The Software Licensing Service reported that the product key does not match the range defined in the license.
//
#define SL_E_MISMATCHED_PKEY_RANGE       ((HRESULT)0xC004F004L)

//
// MessageId: SL_E_MISMATCHED_PID
//
// MessageText:
//
// The Software Licensing Service reported that the product key does not match the product key for the license.
//
#define SL_E_MISMATCHED_PID              ((HRESULT)0xC004F005L)

//
// MessageId: SL_E_EXTERNAL_SIGNATURE_NOT_FOUND
//
// MessageText:
//
// The Software Licensing Service reported that the signature file for the license is not available.
//
#define SL_E_EXTERNAL_SIGNATURE_NOT_FOUND ((HRESULT)0xC004F006L)

//
// MessageId: SL_E_RAC_NOT_AVAILABLE
//
// MessageText:
//
// The Software Licensing Service reported that the license could not be found.
//
#define SL_E_RAC_NOT_AVAILABLE           ((HRESULT)0xC004F007L)

//
// MessageId: SL_E_SPC_NOT_AVAILABLE
//
// MessageText:
//
// The Software Licensing Service reported that the license could not be found.
//
#define SL_E_SPC_NOT_AVAILABLE           ((HRESULT)0xC004F008L)

//
// MessageId: SL_E_GRACE_TIME_EXPIRED
//
// MessageText:
//
// The Software Licensing Service reported that the grace period expired.
//
#define SL_E_GRACE_TIME_EXPIRED          ((HRESULT)0xC004F009L)

//
// MessageId: SL_E_MISMATCHED_APPID
//
// MessageText:
//
// The Software Licensing Service reported that the application ID does not match the application ID for the license.
//
#define SL_E_MISMATCHED_APPID            ((HRESULT)0xC004F00AL)

//
// MessageId: SL_E_NO_PID_CONFIG_DATA
//
// MessageText:
//
// The Software Licensing Service reported that the product identification data is not available.
//
#define SL_E_NO_PID_CONFIG_DATA          ((HRESULT)0xC004F00BL)

//
// MessageId: SL_I_OOB_GRACE_PERIOD
//
// MessageText:
//
// The Software Licensing Service reported that the application is running within the valid grace period.
//
#define SL_I_OOB_GRACE_PERIOD            ((HRESULT)0x4004F00CL)

//
// MessageId: SL_I_OOT_GRACE_PERIOD
//
// MessageText:
//
// The Software Licensing Service reported that the application is running within the valid out of tolerance grace period.
//
#define SL_I_OOT_GRACE_PERIOD            ((HRESULT)0x4004F00DL)

//
// MessageId: SL_E_MISMATCHED_SECURITY_PROCESSOR
//
// MessageText:
//
// The Software Licensing Service determined that the license could not be used by the current version of the security processor component.
//
#define SL_E_MISMATCHED_SECURITY_PROCESSOR ((HRESULT)0xC004F00EL)

//
// MessageId: SL_E_OUT_OF_TOLERANCE
//
// MessageText:
//
// The Software Licensing Service reported that the hardware ID binding is beyond the level of tolerance.
//
#define SL_E_OUT_OF_TOLERANCE            ((HRESULT)0xC004F00FL)

//
// MessageId: SL_E_INVALID_PKEY
//
// MessageText:
//
// The Software Licensing Service reported that the product key is invalid.
//
#define SL_E_INVALID_PKEY                ((HRESULT)0xC004F010L)

//
// MessageId: SL_E_LICENSE_FILE_NOT_INSTALLED
//
// MessageText:
//
// The Software Licensing Service reported that the license file is not installed.
//
#define SL_E_LICENSE_FILE_NOT_INSTALLED  ((HRESULT)0xC004F011L)

//
// MessageId: SL_E_VALUE_NOT_FOUND
//
// MessageText:
//
// The Software Licensing Service reported that the call has failed because the value for the input key was not found.
//
#define SL_E_VALUE_NOT_FOUND             ((HRESULT)0xC004F012L)

//
// MessageId: SL_E_RIGHT_NOT_GRANTED
//
// MessageText:
//
// The Software Licensing Service determined that there is no permission to run the software.
//
#define SL_E_RIGHT_NOT_GRANTED           ((HRESULT)0xC004F013L)

//
// MessageId: SL_E_PKEY_NOT_INSTALLED
//
// MessageText:
//
// The Software Licensing Service reported that the product key is not available.
//
#define SL_E_PKEY_NOT_INSTALLED          ((HRESULT)0xC004F014L)

//
// MessageId: SL_E_PRODUCT_SKU_NOT_INSTALLED
//
// MessageText:
//
// The Software Licensing Service reported that the license is not installed.
//
#define SL_E_PRODUCT_SKU_NOT_INSTALLED   ((HRESULT)0xC004F015L)

//
// MessageId: SL_E_NOT_SUPPORTED
//
// MessageText:
//
// The Software Licensing Service determined that the request is not supported.
//
#define SL_E_NOT_SUPPORTED               ((HRESULT)0xC004F016L)

//
// MessageId: SL_E_PUBLISHING_LICENSE_NOT_INSTALLED
//
// MessageText:
//
// The Software Licensing Service reported that the license is not installed.
//
#define SL_E_PUBLISHING_LICENSE_NOT_INSTALLED ((HRESULT)0xC004F017L)

//
// MessageId: SL_E_LICENSE_SERVER_URL_NOT_FOUND
//
// MessageText:
//
// The Software Licensing Service reported that the license does not contain valid location data for the activation server.
//
#define SL_E_LICENSE_SERVER_URL_NOT_FOUND ((HRESULT)0xC004F018L)

//
// MessageId: SL_E_INVALID_EVENT_ID
//
// MessageText:
//
// The Software Licensing Service determined that the requested event ID is invalid.
//
#define SL_E_INVALID_EVENT_ID            ((HRESULT)0xC004F019L)

//
// MessageId: SL_E_EVENT_NOT_REGISTERED
//
// MessageText:
//
// The Software Licensing Service determined that the requested event is not registered with the service.
//
#define SL_E_EVENT_NOT_REGISTERED        ((HRESULT)0xC004F01AL)

//
// MessageId: SL_E_EVENT_ALREADY_REGISTERED
//
// MessageText:
//
// The Software Licensing Service reported that the event ID is already registered.
//
#define SL_E_EVENT_ALREADY_REGISTERED    ((HRESULT)0xC004F01BL)

//
// MessageId: SL_E_DECRYPTION_LICENSES_NOT_AVAILABLE
//
// MessageText:
//
// The Software Licensing Service reported that the license is not installed.
//
#define SL_E_DECRYPTION_LICENSES_NOT_AVAILABLE ((HRESULT)0xC004F01CL)

//
// MessageId: SL_E_LICENSE_SIGNATURE_VERIFICATION_FAILED
//
// MessageText:
//
// The Software Licensing Service reported that the verification of the license failed.
//
#define SL_E_LICENSE_SIGNATURE_VERIFICATION_FAILED ((HRESULT)0xC004F01DL)

//
// MessageId: SL_E_DATATYPE_MISMATCHED
//
// MessageText:
//
// The Software Licensing Service determined that the input data type does not match the data type in the license.
//
#define SL_E_DATATYPE_MISMATCHED         ((HRESULT)0xC004F01EL)

//
// MessageId: SL_E_INVALID_LICENSE
//
// MessageText:
//
// The Software Licensing Service determined that the license is invalid.
//
#define SL_E_INVALID_LICENSE             ((HRESULT)0xC004F01FL)

//
// MessageId: SL_E_INVALID_PACKAGE
//
// MessageText:
//
// The Software Licensing Service determined that the license package is invalid.
//
#define SL_E_INVALID_PACKAGE             ((HRESULT)0xC004F020L)

//
// MessageId: SL_E_VALIDITY_TIME_EXPIRED
//
// MessageText:
//
// The Software Licensing Service reported that the validity period of the license has expired.
//
#define SL_E_VALIDITY_TIME_EXPIRED       ((HRESULT)0xC004F021L)

//
// MessageId: SL_E_LICENSE_AUTHORIZATION_FAILED
//
// MessageText:
//
// The Software Licensing Service reported that the license authorization failed.
//
#define SL_E_LICENSE_AUTHORIZATION_FAILED ((HRESULT)0xC004F022L)

//
// MessageId: SL_E_LICENSE_DECRYPTION_FAILED
//
// MessageText:
//
// The Software Licensing Service reported that the license is invalid.
//
#define SL_E_LICENSE_DECRYPTION_FAILED   ((HRESULT)0xC004F023L)

//
// MessageId: SL_E_WINDOWS_INVALID_LICENSE_STATE
//
// MessageText:
//
// The Software Licensing Service reported that the license is invalid.
//
#define SL_E_WINDOWS_INVALID_LICENSE_STATE ((HRESULT)0xC004F024L)

//
// MessageId: SL_E_LUA_ACCESSDENIED
//
// MessageText:
//
// The Software Licensing Service reported that the action requires administrator privilege.
//
#define SL_E_LUA_ACCESSDENIED            ((HRESULT)0xC004F025L)

//
// MessageId: SL_E_PROXY_KEY_NOT_FOUND
//
// MessageText:
//
// The Software Licensing Service reported that the required data is not found.
//
#define SL_E_PROXY_KEY_NOT_FOUND         ((HRESULT)0xC004F026L)

//
// MessageId: SL_E_TAMPER_DETECTED
//
// MessageText:
//
// The Software Licensing Service reported that the license is tampered.
//
#define SL_E_TAMPER_DETECTED             ((HRESULT)0xC004F027L)

//
// MessageId: SL_E_POLICY_CACHE_INVALID
//
// MessageText:
//
// The Software Licensing Service reported that the policy cache is invalid.
//
#define SL_E_POLICY_CACHE_INVALID        ((HRESULT)0xC004F028L)

//
// MessageId: SL_E_INVALID_RUNNING_MODE
//
// MessageText:
//
// The Software Licensing Service cannot be started in the current OS mode.
//
#define SL_E_INVALID_RUNNING_MODE        ((HRESULT)0xC004F029L)

//
// MessageId: SL_E_SLP_NOT_SIGNED
//
// MessageText:
//
// The Software Licensing Service reported that the license is invalid.
//
#define SL_E_SLP_NOT_SIGNED              ((HRESULT)0xC004F02AL)

//
// MessageId: SL_I_LICENSE_FILE_NOT_DELETED
//
// MessageText:
//
// The Software Licensing Service determined that the license could not be deleted.
//
#define SL_I_LICENSE_FILE_NOT_DELETED    ((HRESULT)0x4004F02BL)

//
// MessageId: SL_E_CIDIID_INVALID_DATA
//
// MessageText:
//
// The Software Licensing Service reported that the format for the offline activation data is incorrect.
//
#define SL_E_CIDIID_INVALID_DATA         ((HRESULT)0xC004F02CL)

//
// MessageId: SL_E_CIDIID_INVALID_VERSION
//
// MessageText:
//
// The Software Licensing Service determined that the version of the offline Confirmation ID (CID) is incorrect.
//
#define SL_E_CIDIID_INVALID_VERSION      ((HRESULT)0xC004F02DL)

//
// MessageId: SL_E_CIDIID_VERSION_NOT_SUPPORTED
//
// MessageText:
//
// The Software Licensing Service determined that the version of the offline Confirmation ID (CID) is not supported.
//
#define SL_E_CIDIID_VERSION_NOT_SUPPORTED ((HRESULT)0xC004F02EL)

//
// MessageId: SL_E_CIDIID_INVALID_DATA_LENGTH
//
// MessageText:
//
// The Software Licensing Service reported that the length of the offline Confirmation ID (CID) is incorrect.
//
#define SL_E_CIDIID_INVALID_DATA_LENGTH  ((HRESULT)0xC004F02FL)

//
// MessageId: SL_E_CIDIID_NOT_DEPOSITED
//
// MessageText:
//
// The Software Licensing Service determined that the Installation ID (IID) or the Confirmation ID (CID) could not been saved.
//
#define SL_E_CIDIID_NOT_DEPOSITED        ((HRESULT)0xC004F030L)

//
// MessageId: SL_E_CIDIID_MISMATCHED
//
// MessageText:
//
// The Installation ID (IID) and the Confirmation ID (CID) do not match. Please confirm the IID and reacquire a new CID if necessary.
//
#define SL_E_CIDIID_MISMATCHED           ((HRESULT)0xC004F031L)

//
// MessageId: SL_E_INVALID_BINDING_BLOB
//
// MessageText:
//
// The Software Licensing Service determined that the binding data is invalid.
//
#define SL_E_INVALID_BINDING_BLOB        ((HRESULT)0xC004F032L)

//
// MessageId: SL_E_PRODUCT_KEY_INSTALLATION_NOT_ALLOWED
//
// MessageText:
//
// The Software Licensing Service reported that the product key is not allowed to be installed. Please see the eventlog for details.
//
#define SL_E_PRODUCT_KEY_INSTALLATION_NOT_ALLOWED ((HRESULT)0xC004F033L)

//
// MessageId: SL_E_EUL_NOT_AVAILABLE
//
// MessageText:
//
// The Software Licensing Service reported that the license could not be found or was invalid.
//
#define SL_E_EUL_NOT_AVAILABLE           ((HRESULT)0xC004F034L)

//
// MessageId: SL_E_VL_NOT_WINDOWS_SLP
//
// MessageText:
//
// The Software Licensing Service reported that the computer could not be activated with a Volume license product key. Volume-licensed systems require upgrading from a qualifying operating system. Please contact your system administrator or use a different type of key.
//
#define SL_E_VL_NOT_WINDOWS_SLP          ((HRESULT)0xC004F035L)

//
// MessageId: SL_E_VL_NOT_ENOUGH_COUNT
//
// MessageText:
//
// The Software Licensing Service reported that the computer could not be activated. The count reported by your Key Management Service (KMS) is insufficient. Please contact your system administrator.
//
#define SL_E_VL_NOT_ENOUGH_COUNT         ((HRESULT)0xC004F038L)

//
// MessageId: SL_E_VL_BINDING_SERVICE_NOT_ENABLED
//
// MessageText:
//
// The Software Licensing Service reported that the computer could not be activated.  The Key Management Service (KMS) is not enabled.
//
#define SL_E_VL_BINDING_SERVICE_NOT_ENABLED ((HRESULT)0xC004F039L)

//
// MessageId: SL_E_VL_INFO_PRODUCT_USER_RIGHT
//
// MessageText:
//
// The Software Licensing Service reported that the computer was activated but the owner should verify the Product Use Rights.
//
#define SL_E_VL_INFO_PRODUCT_USER_RIGHT  ((HRESULT)0x4004F040L)

//
// MessageId: SL_E_VL_KEY_MANAGEMENT_SERVICE_NOT_ACTIVATED
//
// MessageText:
//
// The Software Licensing Service determined that the Key Management Service (KMS) is not activated. KMS needs to be activated. Please contact system administrator.
//
#define SL_E_VL_KEY_MANAGEMENT_SERVICE_NOT_ACTIVATED ((HRESULT)0xC004F041L)

//
// MessageId: SL_E_VL_KEY_MANAGEMENT_SERVICE_ID_MISMATCH
//
// MessageText:
//
// The Software Licensing Service determined that the specified Key Management Service (KMS) cannot be used.
//
#define SL_E_VL_KEY_MANAGEMENT_SERVICE_ID_MISMATCH ((HRESULT)0xC004F042L)

//
// MessageId: SL_E_PROXY_POLICY_NOT_UPDATED
//
// MessageText:
//
// The Software Licensing Service reported that the proxy policy has not been updated.
//
#define SL_E_PROXY_POLICY_NOT_UPDATED    ((HRESULT)0xC004F047L)

//
// MessageId: SL_E_CIDIID_INVALID_CHECK_DIGITS
//
// MessageText:
//
// The Software Licensing Service determined that the Installation ID (IID) or the Confirmation ID (CID) is invalid.
//
#define SL_E_CIDIID_INVALID_CHECK_DIGITS ((HRESULT)0xC004F04DL)

//
// MessageId: SL_E_LICENSE_MANAGEMENT_DATA_NOT_FOUND
//
// MessageText:
//
// The Software Licensing Service reported that license management information was not found in the licenses.
//
#define SL_E_LICENSE_MANAGEMENT_DATA_NOT_FOUND ((HRESULT)0xC004F04FL)

//
// MessageId: SL_E_INVALID_PRODUCT_KEY
//
// MessageText:
//
// The Software Licensing Service reported that the product key is invalid.
//
#define SL_E_INVALID_PRODUCT_KEY         ((HRESULT)0xC004F050L)

//
// MessageId: SL_E_BLOCKED_PRODUCT_KEY
//
// MessageText:
//
// The Software Licensing Service reported that the product key is blocked.
//
#define SL_E_BLOCKED_PRODUCT_KEY         ((HRESULT)0xC004F051L)

//
// MessageId: SL_E_DUPLICATE_POLICY
//
// MessageText:
//
// The Software Licensing Service reported that the licenses contain duplicated properties. 
//
#define SL_E_DUPLICATE_POLICY            ((HRESULT)0xC004F052L)

//
// MessageId: SL_E_MISSING_OVERRIDE_ONLY_ATTRIBUTE
//
// MessageText:
//
// The Software Licensing Service determined that the license is invalid. The license contains an override policy that is not configured properly.
//
#define SL_E_MISSING_OVERRIDE_ONLY_ATTRIBUTE ((HRESULT)0xC004F053L)

//
// MessageId: SL_E_LICENSE_MANAGEMENT_DATA_DUPLICATED
//
// MessageText:
//
// The Software Licensing Service reported that license management information has duplicated data. 
//
#define SL_E_LICENSE_MANAGEMENT_DATA_DUPLICATED ((HRESULT)0xC004F054L)

//
// MessageId: SL_E_BASE_SKU_NOT_AVAILABLE
//
// MessageText:
//
// The Software Licensing Service reported that the base SKU is not available.
//
#define SL_E_BASE_SKU_NOT_AVAILABLE      ((HRESULT)0xC004F055L)

//
// MessageId: SL_E_VL_MACHINE_NOT_BOUND
//
// MessageText:
//
// The Software Licensing Service reported that the computer could not be activated using the Key Management Service (KMS).
//
#define SL_E_VL_MACHINE_NOT_BOUND        ((HRESULT)0xC004F056L)

//
// MessageId: SL_E_SLP_MISSING_ACPI_SLIC
//
// MessageText:
//
// The Software Licensing Service reported that the computer BIOS is missing a required license.
//
#define SL_E_SLP_MISSING_ACPI_SLIC       ((HRESULT)0xC004F057L)

//
// MessageId: SL_E_SLP_MISSING_SLP_MARKER
//
// MessageText:
//
// The Software Licensing Service reported that the computer BIOS is missing a required license.
//
#define SL_E_SLP_MISSING_SLP_MARKER      ((HRESULT)0xC004F058L)

//
// MessageId: SL_E_SLP_BAD_FORMAT
//
// MessageText:
//
// The Software Licensing Service reported that a license in the computer BIOS is invalid.
//
#define SL_E_SLP_BAD_FORMAT              ((HRESULT)0xC004F059L)

//
// MessageId: SL_E_INVALID_PACKAGE_VERSION
//
// MessageText:
//
// The Software Licensing Service determined that the version of the license package is invalid.
//
#define SL_E_INVALID_PACKAGE_VERSION     ((HRESULT)0xC004F060L)

//
// MessageId: SL_E_PKEY_INVALID_UPGRADE
//
// MessageText:
//
// The Software Licensing Service determined that this specified product key can only be used for upgrading, not for clean installations.
//
#define SL_E_PKEY_INVALID_UPGRADE        ((HRESULT)0xC004F061L)

//
// MessageId: SL_E_ISSUANCE_LICENSE_NOT_INSTALLED
//
// MessageText:
//
// The Software Licensing Service reported that a required license could not be found.
//
#define SL_E_ISSUANCE_LICENSE_NOT_INSTALLED ((HRESULT)0xC004F062L)

//
// MessageId: SL_E_SLP_OEM_CERT_MISSING
//
// MessageText:
//
// The Software Licensing Service reported that the computer BIOS is missing a required license.
//
#define SL_E_SLP_OEM_CERT_MISSING        ((HRESULT)0xC004F063L)

//
// MessageId: SL_E_NONGENUINE_GRACE_TIME_EXPIRED
//
// MessageText:
//
// The Software Licensing Service reported that the non-genuine grace period expired.
//
#define SL_E_NONGENUINE_GRACE_TIME_EXPIRED ((HRESULT)0xC004F064L)

//
// MessageId: SL_I_NONGENUINE_GRACE_PERIOD
//
// MessageText:
//
// The Software Licensing Service reported that the application is running within the valid non-genuine grace period.
//
#define SL_I_NONGENUINE_GRACE_PERIOD     ((HRESULT)0x4004F065L)

//
// MessageId: SL_E_DEPENDENT_PROPERTY_NOT_SET
//
// MessageText:
//
// The Software Licensing Service reported that the genuine information property can not be set before dependent property been set.
//
#define SL_E_DEPENDENT_PROPERTY_NOT_SET  ((HRESULT)0xC004F066L)

//
// MessageId: SL_E_NONGENUINE_GRACE_TIME_EXPIRED_2
//
// MessageText:
//
// The Software Licensing Service reported that the non-genuine grace period expired (type 2).
//
#define SL_E_NONGENUINE_GRACE_TIME_EXPIRED_2 ((HRESULT)0xC004F067L)

//
// MessageId: SL_I_NONGENUINE_GRACE_PERIOD_2
//
// MessageText:
//
// The Software Licensing Service reported that the application is running within the valid non-genuine grace period (type 2).
//
#define SL_I_NONGENUINE_GRACE_PERIOD_2   ((HRESULT)0x4004F068L)

//
// MessageId: SL_E_MISMATCHED_PRODUCT_SKU
//
// MessageText:
//
// The Software Licensing Service reported that the product SKU is not found.
//
#define SL_E_MISMATCHED_PRODUCT_SKU      ((HRESULT)0xC004F069L)

//
// MessageId: SL_E_OPERATION_NOT_ALLOWED
//
// MessageText:
//
// The Software Licensing Service reported that the requested operation is not allowed.
//
#define SL_E_OPERATION_NOT_ALLOWED       ((HRESULT)0xC004F06AL)

//
// MessageId: SL_E_VL_KEY_MANAGEMENT_SERVICE_VM_NOT_SUPPORTED
//
// MessageText:
//
// The Software Licensing Service determined that it is running in a virtual machine. The Key Management Service (KMS) is not supported in this mode.
//
#define SL_E_VL_KEY_MANAGEMENT_SERVICE_VM_NOT_SUPPORTED ((HRESULT)0xC004F06BL)

//
// MessageId: SL_E_VL_INVALID_TIMESTAMP
//
// MessageText:
//
// The Software Licensing Service reported that the computer could not be activated. The Key Management Service (KMS) determined that the request timestamp is invalid.
//
#define SL_E_VL_INVALID_TIMESTAMP        ((HRESULT)0xC004F06CL)

//
// MessageId: SL_E_NOT_GENUINE
//
// MessageText:
//
// The Software Licensing Service reported that current state is not genuine.
//
#define SL_E_NOT_GENUINE                 ((HRESULT)0xC004F200L)

//
// MessageId: E_RM_UNKNOWN_ERROR
//
// MessageText:
//
// A networking problem has occurred while activating your copy of Windows.
//
#define E_RM_UNKNOWN_ERROR               ((HRESULT)0xC004FC03L)

// ******************
// ******************
//
// The following errors are mappings to the SPAPI error strings for UX messaging
//
// ******************
// ******************

//////////////////////////////////////////////////////////
//SP_PUB_GENERAL_ZONE
//////////////////////////////////////////////////////////

//
// MessageId: SL_REMAPPING_SP_PUB_GENERAL_NOT_INITIALIZED
//
// MessageText:
//
// The security processor reported an initialization error.
//
#define SL_REMAPPING_SP_PUB_GENERAL_NOT_INITIALIZED ((HRESULT)0xC004D101L)

//
// MessageId: SL_REMAPPING_SP_STATUS_SYSTEM_TIME_SKEWED
//
// MessageText:
//
// The security processor reported that the machine time is inconsistent with the trusted time.
//
#define SL_REMAPPING_SP_STATUS_SYSTEM_TIME_SKEWED ((HRESULT)0x8004D102L)

//
// MessageId: SL_REMAPPING_SP_STATUS_GENERIC_FAILURE
//
// MessageText:
//
// The security processor reported that an error has occurred.
//
#define SL_REMAPPING_SP_STATUS_GENERIC_FAILURE ((HRESULT)0xC004D103L)

//
// MessageId: SL_REMAPPING_SP_STATUS_INVALIDARG
//
// MessageText:
//
// The security processor reported that invalid data was used.
//
#define SL_REMAPPING_SP_STATUS_INVALIDARG ((HRESULT)0xC004D104L)

//
// MessageId: SL_REMAPPING_SP_STATUS_ALREADY_EXISTS
//
// MessageText:
//
// The security processor reported that the value already exists.
//
#define SL_REMAPPING_SP_STATUS_ALREADY_EXISTS ((HRESULT)0xC004D105L)

//
// MessageId: SL_REMAPPING_SP_STATUS_INSUFFICIENT_BUFFER
//
// MessageText:
//
// The security processor reported that an insufficient buffer was used.
//
#define SL_REMAPPING_SP_STATUS_INSUFFICIENT_BUFFER ((HRESULT)0xC004D107L)

//
// MessageId: SL_REMAPPING_SP_STATUS_INVALIDDATA
//
// MessageText:
//
// The security processor reported that invalid data was used.
//
#define SL_REMAPPING_SP_STATUS_INVALIDDATA ((HRESULT)0xC004D108L)

//
// MessageId: SL_REMAPPING_SP_STATUS_INVALID_SPAPI_CALL
//
// MessageText:
//
// The security processor reported that an invalid call was made.
//
#define SL_REMAPPING_SP_STATUS_INVALID_SPAPI_CALL ((HRESULT)0xC004D109L)

//
// MessageId: SL_REMAPPING_SP_STATUS_INVALID_SPAPI_VERSION
//
// MessageText:
//
// The security processor reported a version mismatch error.
//
#define SL_REMAPPING_SP_STATUS_INVALID_SPAPI_VERSION ((HRESULT)0xC004D10AL)

//
// MessageId: SL_REMAPPING_SP_STATUS_DEBUGGER_DETECTED
//
// MessageText:
//
// The security processor cannot operate while a debugger is attached.
//
#define SL_REMAPPING_SP_STATUS_DEBUGGER_DETECTED ((HRESULT)0x8004D10BL)


//////////////////////////////////////////////////////////
// SP_PUB_TS_ZONE
//////////////////////////////////////////////////////////

//
// MessageId: SL_REMAPPING_SP_PUB_TS_TAMPERED
//
// MessageText:
//
// The security processor reported that the trusted data store was tampered.
//
#define SL_REMAPPING_SP_PUB_TS_TAMPERED  ((HRESULT)0xC004D301L)

//
// MessageId: SL_REMAPPING_SP_PUB_TS_REARMED
//
// MessageText:
//
// The security processor reported that the trusted data store was rearmed.
//
#define SL_REMAPPING_SP_PUB_TS_REARMED   ((HRESULT)0xC004D302L)

//
// MessageId: SL_REMAPPING_SP_PUB_TS_RECREATED
//
// MessageText:
//
// The security processor reported that the trusted store has been recreated.
//
#define SL_REMAPPING_SP_PUB_TS_RECREATED ((HRESULT)0xC004D303L)

//
// MessageId: SL_REMAPPING_SP_PUB_TS_ENTRY_KEY_NOT_FOUND
//
// MessageText:
//
// The security processor reported that entry key was not found in the trusted data store.
//
#define SL_REMAPPING_SP_PUB_TS_ENTRY_KEY_NOT_FOUND ((HRESULT)0xC004D304L)

//
// MessageId: SL_REMAPPING_SP_PUB_TS_ENTRY_KEY_ALREADY_EXISTS
//
// MessageText:
//
// The security processor reported that the entry key already exists in the trusted data store.
//
#define SL_REMAPPING_SP_PUB_TS_ENTRY_KEY_ALREADY_EXISTS ((HRESULT)0xC004D305L)

//
// MessageId: SL_REMAPPING_SP_PUB_TS_ENTRY_KEY_SIZE_TOO_BIG
//
// MessageText:
//
// The security processor reported that the entry key is too big to fit in the trusted data store.
//
#define SL_REMAPPING_SP_PUB_TS_ENTRY_KEY_SIZE_TOO_BIG ((HRESULT)0xC004D306L)

//
// MessageId: SL_REMAPPING_SP_PUB_TS_MAX_REARM_REACHED
//
// MessageText:
//
// The security processor reported that the maximum allowed number of re-arms has been exceeded.  You must re-install the OS before trying to re-arm again.
//
#define SL_REMAPPING_SP_PUB_TS_MAX_REARM_REACHED ((HRESULT)0xC004D307L)

//
// MessageId: SL_REMAPPING_SP_PUB_TS_DATA_SIZE_TOO_BIG
//
// MessageText:
//
// The security processor has reported that entry data size is too big to fit in the trusted data store.
//
#define SL_REMAPPING_SP_PUB_TS_DATA_SIZE_TOO_BIG ((HRESULT)0xC004D308L)

//
// MessageId: SL_REMAPPING_SP_PUB_TS_INVALID_HW_BINDING
//
// MessageText:
//
// The security processor has reported that the machine has gone out of hardware tolerance.
//
#define SL_REMAPPING_SP_PUB_TS_INVALID_HW_BINDING ((HRESULT)0xC004D309L)

//
// MessageId: SL_REMAPPING_SP_PUB_TIMER_ALREADY_EXISTS
//
// MessageText:
//
// The security processor has reported that the secure timer already exists.
//
#define SL_REMAPPING_SP_PUB_TIMER_ALREADY_EXISTS ((HRESULT)0xC004D30AL)

//
// MessageId: SL_REMAPPING_SP_PUB_TIMER_NOT_FOUND
//
// MessageText:
//
// The security processor has reported that the secure timer was not found.
//
#define SL_REMAPPING_SP_PUB_TIMER_NOT_FOUND ((HRESULT)0xC004D30BL)

//
// MessageId: SL_REMAPPING_SP_PUB_TIMER_EXPIRED
//
// MessageText:
//
// The security processor has reported that the secure timer has expired.
//
#define SL_REMAPPING_SP_PUB_TIMER_EXPIRED ((HRESULT)0xC004D30CL)

//
// MessageId: SL_REMAPPING_SP_PUB_TIMER_NAME_SIZE_TOO_BIG
//
// MessageText:
//
// The security processor has reported that the secure timer name is too long.
//
#define SL_REMAPPING_SP_PUB_TIMER_NAME_SIZE_TOO_BIG ((HRESULT)0xC004D30DL)

//
// MessageId: SL_REMAPPING_SP_PUB_TS_FULL
//
// MessageText:
//
// The security processor reported that the trusted data store is full.
//
#define SL_REMAPPING_SP_PUB_TS_FULL      ((HRESULT)0xC004D30EL)


//////////////////////////////////////////////////////////
// SP_PUB_MODAUTH_ZONE
//////////////////////////////////////////////////////////

//
// MessageId: SL_REMAPPING_SP_PUB_TAMPER_MODULE_AUTHENTICATION
//
// MessageText:
//
// The security processor reported a system file mismatch error.
//
#define SL_REMAPPING_SP_PUB_TAMPER_MODULE_AUTHENTICATION ((HRESULT)0xC004D401L)

//
// MessageId: SL_REMAPPING_SP_PUB_TAMPER_SECURITY_PROCESSOR_PATCHED
//
// MessageText:
//
// The security processor reported a system file mismatch error.
//
#define SL_REMAPPING_SP_PUB_TAMPER_SECURITY_PROCESSOR_PATCHED ((HRESULT)0xC004D402L)


//////////////////////////////////////////////////////////
// SP_PUB_KM_CACHE_ZONE (Error codes)
//////////////////////////////////////////////////////////

//
// MessageId: SL_REMAPPING_SP_PUB_KM_CACHE_TAMPER
//
// MessageText:
//
// The security processor reported an error with the kernel data.
//
#define SL_REMAPPING_SP_PUB_KM_CACHE_TAMPER ((HRESULT)0xC004D501L)

#endif//_SLERROR_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\Snmp.h ===
/*++

Copyright (C) 1992-1999 Microsoft Corporation

Module Name:

    snmp.h

Abstract:

    Definitions for SNMP development.

--*/

#ifndef _INC_SNMP
#define _INC_SNMP

#if _MSC_VER > 1000
#pragma once
#endif

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Additional Header Files                                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP Type Definitions                                                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <pshpack4.h>

typedef struct {
    BYTE * stream;
    UINT   length;
    BOOL   dynamic;
} AsnOctetString;

typedef struct {
    UINT   idLength;
    UINT * ids;
} AsnObjectIdentifier;

typedef LONG                    AsnInteger32;
typedef ULONG                   AsnUnsigned32;
typedef ULARGE_INTEGER          AsnCounter64;
typedef AsnUnsigned32           AsnCounter32;
typedef AsnUnsigned32           AsnGauge32;
typedef AsnUnsigned32           AsnTimeticks;
typedef AsnOctetString          AsnBits;
typedef AsnOctetString          AsnSequence;
typedef AsnOctetString          AsnImplicitSequence;
typedef AsnOctetString          AsnIPAddress;
typedef AsnOctetString          AsnNetworkAddress;
typedef AsnOctetString          AsnDisplayString;
typedef AsnOctetString          AsnOpaque;

typedef struct {
    BYTE asnType;
    union {
        AsnInteger32            number;     // ASN_INTEGER
                                            // ASN_INTEGER32
        AsnUnsigned32           unsigned32; // ASN_UNSIGNED32
        AsnCounter64            counter64;  // ASN_COUNTER64
        AsnOctetString          string;     // ASN_OCTETSTRING
        AsnBits                 bits;       // ASN_BITS
        AsnObjectIdentifier     object;     // ASN_OBJECTIDENTIFIER
        AsnSequence             sequence;   // ASN_SEQUENCE
        AsnIPAddress            address;    // ASN_IPADDRESS
        AsnCounter32            counter;    // ASN_COUNTER32
        AsnGauge32              gauge;      // ASN_GAUGE32
        AsnTimeticks            ticks;      // ASN_TIMETICKS
        AsnOpaque               arbitrary;  // ASN_OPAQUE
    } asnValue;
} AsnAny;

typedef AsnObjectIdentifier     AsnObjectName;
typedef AsnAny                  AsnObjectSyntax;

typedef struct {
    AsnObjectName    name;
    AsnObjectSyntax  value;
} SnmpVarBind;

typedef struct {
    SnmpVarBind * list;
    UINT          len;
} SnmpVarBindList;

#include <poppack.h>

#ifndef _INC_WINSNMP

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ASN/BER Base Types                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ASN_UNIVERSAL                   0x00
#define ASN_APPLICATION                 0x40
#define ASN_CONTEXT                     0x80
#define ASN_PRIVATE                     0xC0

#define ASN_PRIMITIVE                   0x00
#define ASN_CONSTRUCTOR                 0x20

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// PDU Type Values                                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SNMP_PDU_GET                (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x0)
#define SNMP_PDU_GETNEXT            (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x1)
#define SNMP_PDU_RESPONSE           (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x2)
#define SNMP_PDU_SET                (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x3)
#define SNMP_PDU_V1TRAP             (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x4)
#define SNMP_PDU_GETBULK            (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x5)
#define SNMP_PDU_INFORM             (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x6)
#define SNMP_PDU_TRAP               (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x7)

#endif // _INC_WINSNMP

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP Simple Syntax Values                                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ASN_INTEGER                 (ASN_UNIVERSAL | ASN_PRIMITIVE | 0x02)
#define ASN_BITS                    (ASN_UNIVERSAL | ASN_PRIMITIVE | 0x03)
#define ASN_OCTETSTRING             (ASN_UNIVERSAL | ASN_PRIMITIVE | 0x04)
#define ASN_NULL                    (ASN_UNIVERSAL | ASN_PRIMITIVE | 0x05)
#define ASN_OBJECTIDENTIFIER        (ASN_UNIVERSAL | ASN_PRIMITIVE | 0x06)
#define ASN_INTEGER32               ASN_INTEGER

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP Constructor Syntax Values                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ASN_SEQUENCE                (ASN_UNIVERSAL | ASN_CONSTRUCTOR | 0x10)
#define ASN_SEQUENCEOF              ASN_SEQUENCE

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP Application Syntax Values                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ASN_IPADDRESS               (ASN_APPLICATION | ASN_PRIMITIVE | 0x00)
#define ASN_COUNTER32               (ASN_APPLICATION | ASN_PRIMITIVE | 0x01)
#define ASN_GAUGE32                 (ASN_APPLICATION | ASN_PRIMITIVE | 0x02)
#define ASN_TIMETICKS               (ASN_APPLICATION | ASN_PRIMITIVE | 0x03)
#define ASN_OPAQUE                  (ASN_APPLICATION | ASN_PRIMITIVE | 0x04)
#define ASN_COUNTER64               (ASN_APPLICATION | ASN_PRIMITIVE | 0x06)
#define ASN_UINTEGER32              (ASN_APPLICATION | ASN_PRIMITIVE | 0x07)
#define ASN_RFC2578_UNSIGNED32      ASN_GAUGE32

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP Exception Conditions                                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SNMP_EXCEPTION_NOSUCHOBJECT     (ASN_CONTEXT | ASN_PRIMITIVE | 0x00)
#define SNMP_EXCEPTION_NOSUCHINSTANCE   (ASN_CONTEXT | ASN_PRIMITIVE | 0x01)
#define SNMP_EXCEPTION_ENDOFMIBVIEW     (ASN_CONTEXT | ASN_PRIMITIVE | 0x02)

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP Request Types (used in SnmpExtensionQueryEx)                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SNMP_EXTENSION_GET          SNMP_PDU_GET
#define SNMP_EXTENSION_GET_NEXT     SNMP_PDU_GETNEXT
#define SNMP_EXTENSION_GET_BULK     SNMP_PDU_GETBULK
#define SNMP_EXTENSION_SET_TEST     (ASN_PRIVATE | ASN_CONSTRUCTOR | 0x0)
#define SNMP_EXTENSION_SET_COMMIT   SNMP_PDU_SET
#define SNMP_EXTENSION_SET_UNDO     (ASN_PRIVATE | ASN_CONSTRUCTOR | 0x1)
#define SNMP_EXTENSION_SET_CLEANUP  (ASN_PRIVATE | ASN_CONSTRUCTOR | 0x2)

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP Error Codes                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SNMP_ERRORSTATUS_NOERROR                0
#define SNMP_ERRORSTATUS_TOOBIG                 1
#define SNMP_ERRORSTATUS_NOSUCHNAME             2
#define SNMP_ERRORSTATUS_BADVALUE               3
#define SNMP_ERRORSTATUS_READONLY               4
#define SNMP_ERRORSTATUS_GENERR                 5
#define SNMP_ERRORSTATUS_NOACCESS               6
#define SNMP_ERRORSTATUS_WRONGTYPE              7
#define SNMP_ERRORSTATUS_WRONGLENGTH            8
#define SNMP_ERRORSTATUS_WRONGENCODING          9
#define SNMP_ERRORSTATUS_WRONGVALUE             10
#define SNMP_ERRORSTATUS_NOCREATION             11
#define SNMP_ERRORSTATUS_INCONSISTENTVALUE      12
#define SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE    13
#define SNMP_ERRORSTATUS_COMMITFAILED           14
#define SNMP_ERRORSTATUS_UNDOFAILED             15
#define SNMP_ERRORSTATUS_AUTHORIZATIONERROR     16
#define SNMP_ERRORSTATUS_NOTWRITABLE            17
#define SNMP_ERRORSTATUS_INCONSISTENTNAME       18

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMPv1 Trap Types                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SNMP_GENERICTRAP_COLDSTART              0
#define SNMP_GENERICTRAP_WARMSTART              1
#define SNMP_GENERICTRAP_LINKDOWN               2
#define SNMP_GENERICTRAP_LINKUP                 3
#define SNMP_GENERICTRAP_AUTHFAILURE            4
#define SNMP_GENERICTRAP_EGPNEIGHLOSS           5
#define SNMP_GENERICTRAP_ENTERSPECIFIC          6

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP Access Types                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SNMP_ACCESS_NONE                        0
#define SNMP_ACCESS_NOTIFY                      1
#define SNMP_ACCESS_READ_ONLY                   2
#define SNMP_ACCESS_READ_WRITE                  3
#define SNMP_ACCESS_READ_CREATE                 4

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP API Return Code Definitions                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SNMPAPI                                 INT
#define SNMP_FUNC_TYPE                          WINAPI

#define SNMPAPI_NOERROR                         TRUE
#define SNMPAPI_ERROR                           FALSE

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP Extension API Prototypes                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
SNMP_FUNC_TYPE
SnmpExtensionInit(
    DWORD                 dwUptimeReference,
    HANDLE *              phSubagentTrapEvent,
    AsnObjectIdentifier * pFirstSupportedRegion
    );

BOOL
SNMP_FUNC_TYPE
SnmpExtensionInitEx(
    AsnObjectIdentifier * pNextSupportedRegion
    );

BOOL
SNMP_FUNC_TYPE
SnmpExtensionMonitor(
    LPVOID            pAgentMgmtData
    );

BOOL
SNMP_FUNC_TYPE
SnmpExtensionQuery(
    BYTE              bPduType,
    SnmpVarBindList * pVarBindList,
    AsnInteger32 *    pErrorStatus,
    AsnInteger32 *    pErrorIndex
    );

BOOL
SNMP_FUNC_TYPE
SnmpExtensionQueryEx(
    UINT              nRequestType,
    UINT              nTransactionId,
    SnmpVarBindList * pVarBindList,
    AsnOctetString *  pContextInfo,
    AsnInteger32 *    pErrorStatus,
    AsnInteger32 *    pErrorIndex
    );

BOOL
SNMP_FUNC_TYPE
SnmpExtensionTrap(
    AsnObjectIdentifier * pEnterpriseOid,
    AsnInteger32 *        pGenericTrapId,
    AsnInteger32 *        pSpecificTrapId,
    AsnTimeticks *        pTimeStamp,
    SnmpVarBindList *     pVarBindList
    );

VOID
SNMP_FUNC_TYPE
SnmpExtensionClose(
    );

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP Extension API Type Definitions                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef BOOL (SNMP_FUNC_TYPE * PFNSNMPEXTENSIONINIT)(
    DWORD                 dwUpTimeReference,
    HANDLE *              phSubagentTrapEvent,
    AsnObjectIdentifier * pFirstSupportedRegion
    );

typedef BOOL (SNMP_FUNC_TYPE * PFNSNMPEXTENSIONINITEX)(
    AsnObjectIdentifier * pNextSupportedRegion
    );

typedef BOOL (SNMP_FUNC_TYPE * PFNSNMPEXTENSIONMONITOR)(
    LPVOID            pAgentMgmtData
    );

typedef BOOL (SNMP_FUNC_TYPE * PFNSNMPEXTENSIONQUERY)(
    BYTE              bPduType,
    SnmpVarBindList * pVarBindList,
    AsnInteger32 *    pErrorStatus,
    AsnInteger32 *    pErrorIndex
    );

typedef BOOL (SNMP_FUNC_TYPE * PFNSNMPEXTENSIONQUERYEX)(
    UINT              nRequestType,
    UINT              nTransactionId,
    SnmpVarBindList * pVarBindList,
    AsnOctetString *  pContextInfo,
    AsnInteger32 *    pErrorStatus,
    AsnInteger32 *    pErrorIndex
    );

typedef BOOL (SNMP_FUNC_TYPE * PFNSNMPEXTENSIONTRAP)(
    AsnObjectIdentifier * pEnterpriseOid,
    AsnInteger32 *        pGenericTrapId,
    AsnInteger32 *        pSpecificTrapId,
    AsnTimeticks *        pTimeStamp,
    SnmpVarBindList *     pVarBindList
    );

typedef VOID (SNMP_FUNC_TYPE * PFNSNMPEXTENSIONCLOSE)(
    );

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP API Prototypes                                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SNMPAPI
SNMP_FUNC_TYPE
SnmpUtilOidCpy(
    AsnObjectIdentifier * pOidDst,
    AsnObjectIdentifier * pOidSrc
    );

SNMPAPI
SNMP_FUNC_TYPE
SnmpUtilOidAppend(
    AsnObjectIdentifier * pOidDst,
    AsnObjectIdentifier * pOidSrc
    );

SNMPAPI
SNMP_FUNC_TYPE
SnmpUtilOidNCmp(
    AsnObjectIdentifier * pOid1,
    AsnObjectIdentifier * pOid2,
    UINT                  nSubIds
    );

SNMPAPI
SNMP_FUNC_TYPE
SnmpUtilOidCmp(
    AsnObjectIdentifier * pOid1,
    AsnObjectIdentifier * pOid2
    );

VOID
SNMP_FUNC_TYPE
SnmpUtilOidFree(
    AsnObjectIdentifier * pOid
    );

SNMPAPI
SNMP_FUNC_TYPE
SnmpUtilOctetsCmp(
    AsnOctetString * pOctets1,
    AsnOctetString * pOctets2
    );

SNMPAPI
SNMP_FUNC_TYPE
SnmpUtilOctetsNCmp(
    AsnOctetString * pOctets1,
    AsnOctetString * pOctets2,
    UINT             nChars
    );

SNMPAPI
SNMP_FUNC_TYPE
SnmpUtilOctetsCpy(
    AsnOctetString * pOctetsDst,
    AsnOctetString * pOctetsSrc
    );

VOID
SNMP_FUNC_TYPE
SnmpUtilOctetsFree(
    AsnOctetString * pOctets
    );

SNMPAPI
SNMP_FUNC_TYPE
SnmpUtilAsnAnyCpy(
    AsnAny * pAnyDst,
    AsnAny * pAnySrc
    );

VOID
SNMP_FUNC_TYPE
SnmpUtilAsnAnyFree(
    AsnAny * pAny
    );

SNMPAPI
SNMP_FUNC_TYPE
SnmpUtilVarBindCpy(
    SnmpVarBind * pVbDst,
    SnmpVarBind * pVbSrc
    );

VOID
SNMP_FUNC_TYPE
SnmpUtilVarBindFree(
    SnmpVarBind * pVb
    );

SNMPAPI
SNMP_FUNC_TYPE
SnmpUtilVarBindListCpy(
    SnmpVarBindList * pVblDst,
    SnmpVarBindList * pVblSrc
    );

VOID
SNMP_FUNC_TYPE
SnmpUtilVarBindListFree(
    SnmpVarBindList * pVbl
    );

VOID
SNMP_FUNC_TYPE
SnmpUtilMemFree(
    LPVOID pMem
    );

LPVOID
SNMP_FUNC_TYPE
SnmpUtilMemAlloc(
    UINT nBytes
    );

LPVOID
SNMP_FUNC_TYPE
SnmpUtilMemReAlloc(
    LPVOID pMem,
    UINT   nBytes
    );

LPSTR
SNMP_FUNC_TYPE
SnmpUtilOidToA(
    IN AsnObjectIdentifier *Oid
    );

LPSTR
SNMP_FUNC_TYPE
SnmpUtilIdsToA(
    IN UINT *Ids,
    IN UINT IdLength
    );

VOID
SNMP_FUNC_TYPE
SnmpUtilPrintOid(
    IN AsnObjectIdentifier *Oid
    );

VOID
SNMP_FUNC_TYPE
SnmpUtilPrintAsnAny(
    AsnAny * pAny
    );

DWORD
SNMP_FUNC_TYPE
SnmpSvcGetUptime(
    );

VOID
SNMP_FUNC_TYPE
SnmpSvcSetLogLevel(
    INT nLogLevel
    );

VOID
SNMP_FUNC_TYPE
SnmpSvcSetLogType(
    INT nLogType
    );

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP Debugging Definitions                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SNMP_LOG_SILENT                 0x0
#define SNMP_LOG_FATAL                  0x1
#define SNMP_LOG_ERROR                  0x2
#define SNMP_LOG_WARNING                0x3
#define SNMP_LOG_TRACE                  0x4
#define SNMP_LOG_VERBOSE                0x5

#define SNMP_OUTPUT_TO_CONSOLE          0x1
#define SNMP_OUTPUT_TO_LOGFILE          0x2
#define SNMP_OUTPUT_TO_EVENTLOG         0x4  // no longer supported
#define SNMP_OUTPUT_TO_DEBUGGER         0x8

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP Debugging Prototypes                                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

VOID
SNMP_FUNC_TYPE
SnmpUtilDbgPrint(
    IN INT nLogLevel,   // see log levels above...
    __in __format_string LPSTR szFormat,
    IN ...
    );

#if DBG
#define SNMPDBG(_x_)                    SnmpUtilDbgPrint _x_
#else
#define SNMPDBG(_x_)
#endif

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Miscellaneous definitions                                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define DEFINE_SIZEOF(Array)        (sizeof(Array)/sizeof((Array)[0]))
#define DEFINE_OID(SubIdArray)      {DEFINE_SIZEOF(SubIdArray),(SubIdArray)}
#define DEFINE_NULLOID()            {0,NULL}
#define DEFINE_NULLOCTETS()         {NULL,0,FALSE}

#define DEFAULT_SNMP_PORT_UDP       161
#define DEFAULT_SNMP_PORT_IPX       36879
#define DEFAULT_SNMPTRAP_PORT_UDP   162
#define DEFAULT_SNMPTRAP_PORT_IPX   36880

#define SNMP_MAX_OID_LEN            128

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// API Error Code Definitions                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SNMP_MEM_ALLOC_ERROR            1
#define SNMP_BERAPI_INVALID_LENGTH      10
#define SNMP_BERAPI_INVALID_TAG         11
#define SNMP_BERAPI_OVERFLOW            12
#define SNMP_BERAPI_SHORT_BUFFER        13
#define SNMP_BERAPI_INVALID_OBJELEM     14
#define SNMP_PDUAPI_UNRECOGNIZED_PDU    20
#define SNMP_PDUAPI_INVALID_ES          21
#define SNMP_PDUAPI_INVALID_GT          22
#define SNMP_AUTHAPI_INVALID_VERSION    30
#define SNMP_AUTHAPI_INVALID_MSG_TYPE   31
#define SNMP_AUTHAPI_TRIV_AUTH_FAILED   32

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Support for old definitions (support disabled via SNMPSTRICT)             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#ifndef SNMPSTRICT

#define SNMP_oidcpy                     SnmpUtilOidCpy
#define SNMP_oidappend                  SnmpUtilOidAppend
#define SNMP_oidncmp                    SnmpUtilOidNCmp
#define SNMP_oidcmp                     SnmpUtilOidCmp
#define SNMP_oidfree                    SnmpUtilOidFree

#define SNMP_CopyVarBindList            SnmpUtilVarBindListCpy
#define SNMP_FreeVarBindList            SnmpUtilVarBindListFree
#define SNMP_CopyVarBind                SnmpUtilVarBindCpy
#define SNMP_FreeVarBind                SnmpUtilVarBindFree

#define SNMP_printany                   SnmpUtilPrintAsnAny

#define SNMP_free                       SnmpUtilMemFree
#define SNMP_malloc                     SnmpUtilMemAlloc
#define SNMP_realloc                    SnmpUtilMemReAlloc

#define SNMP_DBG_free                   SnmpUtilMemFree
#define SNMP_DBG_malloc                 SnmpUtilMemAlloc
#define SNMP_DBG_realloc                SnmpUtilMemReAlloc

#define ASN_RFC1155_IPADDRESS           ASN_IPADDRESS
#define ASN_RFC1155_COUNTER             ASN_COUNTER32
#define ASN_RFC1155_GAUGE               ASN_GAUGE32
#define ASN_RFC1155_TIMETICKS           ASN_TIMETICKS
#define ASN_RFC1155_OPAQUE              ASN_OPAQUE
#define ASN_RFC1213_DISPSTRING          ASN_OCTETSTRING

#define ASN_RFC1157_GETREQUEST          SNMP_PDU_GET
#define ASN_RFC1157_GETNEXTREQUEST      SNMP_PDU_GETNEXT
#define ASN_RFC1157_GETRESPONSE         SNMP_PDU_RESPONSE
#define ASN_RFC1157_SETREQUEST          SNMP_PDU_SET
#define ASN_RFC1157_TRAP                SNMP_PDU_V1TRAP

#define ASN_CONTEXTSPECIFIC             ASN_CONTEXT
#define ASN_PRIMATIVE                   ASN_PRIMITIVE

#define RFC1157VarBindList              SnmpVarBindList
#define RFC1157VarBind                  SnmpVarBind
#define AsnInteger                      AsnInteger32
#define AsnCounter                      AsnCounter32
#define AsnGauge                        AsnGauge32
#define ASN_UNSIGNED32                  ASN_UINTEGER32

#endif // SNMPSTRICT

#ifdef __cplusplus
}
#endif

#endif // _INC_SNMP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\SMPAB.h ===
/*
 *  S M P A B . H
 *  
 *  Definitions used by the Microsoft Sample Address Book
 *  provider for service entry calls
 *  
 *  Copyright 1993-1999 Microsoft Corporation. All Rights Reserved.
 */

/*
 *  Property tag definitions
 */

/*      The following MAPI-defined properties are settable in service entry */
/*      calls:                                                              */
/*                                                                          */
/*          PR_SAB_FILE_NAME                                                */
/*          PR_SAB_UID                                                      */

#define PR_SAB_FILE PROP_TAG(PT_STRING8,0x6604)
#define PR_SAB_UID  PROP_TAG(PT_BINARY,0x6601)

/*
 *  PR_SAB_FILE_NAME is the full path name of the .SAB file (e.g. c:\foo\mylist.sab).
 *                   This string must be ANSI.
 *
 *  PR_SAB_UID is the UID uniquely identifying this session of the SAB.  If you have
 *             multiple SABs configured, they must have different PR_SAB_UIDs.
 */

/*
 *  The Sample Address Book's PR_AB_PROVIDER_ID
 */
#define SAB_PROVIDER_ID {0x34,0xda,0x7e,0x60,0x03,0x1b,0x11,0xce,0x95,0x74,0x00,0xaa,0x00,0x3c,0xd2,0x07}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\SoftPub.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       softpub.h
//
//  Contents:   Microsoft Internet Security Authenticode Policy Provider
//
//--------------------------------------------------------------------------

#ifndef SOFTPUB_H
#define SOFTPUB_H

#include <wintrust.h>

#ifdef __cplusplus
extern "C"
{
#endif

#include <pshpack8.h>

//////////////////////////////////////////////////////////////////////////////
//
// Softpub Policy Provider defines
//----------------------------------------------------------------------------
//  The following are definitions of the Microsoft Authenticode Policy Provider
//  (WINTRUST.DLL's Policy Provider)
//

#define SP_POLICY_PROVIDER_DLL_NAME         L"WINTRUST.DLL"

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_ACTION_GENERIC_VERIFY_V2 Guid  (Authenticode)
//----------------------------------------------------------------------------
//  Assigned to the pgActionID parameter of WinVerifyTrust to verify the
//  authenticity of a file/object using the Microsoft Authenticode
//  Policy Provider,
//
//          {00AAC56B-CD44-11d0-8CC2-00C04FC295EE}
//
#define WINTRUST_ACTION_GENERIC_VERIFY_V2                       \
            { 0xaac56b,                                         \
              0xcd44,                                           \
              0x11d0,                                           \
              { 0x8c, 0xc2, 0x0, 0xc0, 0x4f, 0xc2, 0x95, 0xee } \
            }

#define SP_INIT_FUNCTION                    L"SoftpubInitialize"
#define SP_OBJTRUST_FUNCTION                L"SoftpubLoadMessage"
#define SP_SIGTRUST_FUNCTION                L"SoftpubLoadSignature"
#define SP_CHKCERT_FUNCTION                 L"SoftpubCheckCert"
#define SP_FINALPOLICY_FUNCTION             L"SoftpubAuthenticode"
#define SP_CLEANUPPOLICY_FUNCTION           L"SoftpubCleanup"

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_ACTION_TRUSTPROVIDER_TEST (Authenticode TEST)
//----------------------------------------------------------------------------
//  Assigned to the pgActionID parameter of WinVerifyTrust to dump
//  the CRYPT_PROVIDER_DATA structure to a file after calling the
//  Authenticode Policy Provider.
//
//          {573E31F8-DDBA-11d0-8CCB-00C04FC295EE}
//
#define WINTRUST_ACTION_TRUSTPROVIDER_TEST                      \
            { 0x573e31f8,                                       \
              0xddba,                                           \
              0x11d0,                                           \
              { 0x8c, 0xcb, 0x0, 0xc0, 0x4f, 0xc2, 0x95, 0xee } \
            }

#define SP_TESTDUMPPOLICY_FUNCTION_TEST     L"SoftpubDumpStructure"


//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_ACTION_GENERIC_CERT_VERIFY
//----------------------------------------------------------------------------
//  Assigned to the pgActionID parameter of WinVerifyTrust to verify
//  a certificate chain only.  This is only valid when passing in a
//  certificate context in the WinVerifyTrust input structures.
//
//          {189A3842-3041-11d1-85E1-00C04FC295EE}
//
#define WINTRUST_ACTION_GENERIC_CERT_VERIFY                     \
            { 0x189a3842,                                       \
              0x3041,                                           \
              0x11d1,                                           \
              { 0x85, 0xe1, 0x0, 0xc0, 0x4f, 0xc2, 0x95, 0xee } \
            }

#define SP_GENERIC_CERT_INIT_FUNCTION       L"SoftpubDefCertInit"


//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_ACTION_GENERIC_CHAIN_VERIFY
//----------------------------------------------------------------------------
//  Assigned to the pgActionID parameter of WinVerifyTrust to verify
//  certificate chains created from any object type: file, cert, signer, ...
//  A callback is provided to implement the final chain policy using
//  the chain context for each signer and counter signer.
//
//          {fc451c16-ac75-11d1-b4b8-00c04fb66ea0}
//
#define WINTRUST_ACTION_GENERIC_CHAIN_VERIFY                    \
            { 0xfc451c16,                                       \
              0xac75,                                           \
              0x11d1,                                           \
              { 0xb4, 0xb8, 0x00, 0xc0, 0x4f, 0xb6, 0x6e, 0xa0 }\
            }
#define GENERIC_CHAIN_FINALPOLICY_FUNCTION      L"GenericChainFinalProv"
#define GENERIC_CHAIN_CERTTRUST_FUNCTION        L"GenericChainCertificateTrust"


typedef struct _WTD_GENERIC_CHAIN_POLICY_SIGNER_INFO
    WTD_GENERIC_CHAIN_POLICY_SIGNER_INFO,
        *PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO;

struct _WTD_GENERIC_CHAIN_POLICY_SIGNER_INFO {
    union {
        DWORD                                   cbStruct;
        DWORD                                   cbSize;
    };
    PCCERT_CHAIN_CONTEXT                    pChainContext;

    // SGNR_TYPE_TIMESTAMP defined in wintrust.h
    DWORD                                   dwSignerType;
    PCMSG_SIGNER_INFO                       pMsgSignerInfo;
    DWORD                                   dwError;

    DWORD                                   cCounterSigner;
    PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO   *rgpCounterSigner;
};

typedef HRESULT (WINAPI *PFN_WTD_GENERIC_CHAIN_POLICY_CALLBACK)(
    IN PCRYPT_PROVIDER_DATA pProvData,
    IN DWORD dwStepError,
    IN DWORD dwRegPolicySettings,
    IN DWORD cSigner,
    IN PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO *rgpSigner,
    IN void *pvPolicyArg
    );

// The fields in the following data structure are passed to
// CertGetCertificateChain().
typedef struct _WTD_GENERIC_CHAIN_POLICY_CREATE_INFO {
    union {
        DWORD                                   cbStruct;
        DWORD                                   cbSize;
    };

    HCERTCHAINENGINE                        hChainEngine;
    PCERT_CHAIN_PARA                        pChainPara;
    DWORD                                   dwFlags;
    void                                    *pvReserved;
} WTD_GENERIC_CHAIN_POLICY_CREATE_INFO, *PWTD_GENERIC_CHAIN_POLICY_CREATE_INFO;

typedef struct _WTD_GENERIC_CHAIN_POLICY_DATA {
    union {
        DWORD                                   cbStruct;
        DWORD                                   cbSize;
    };

    PWTD_GENERIC_CHAIN_POLICY_CREATE_INFO   pSignerChainInfo;
    PWTD_GENERIC_CHAIN_POLICY_CREATE_INFO   pCounterSignerChainInfo;
    PFN_WTD_GENERIC_CHAIN_POLICY_CALLBACK   pfnPolicyCallback;
    void                                    *pvPolicyArg;
} WTD_GENERIC_CHAIN_POLICY_DATA, *PWTD_GENERIC_CHAIN_POLICY_DATA;


//////////////////////////////////////////////////////////////////////////////
//
// HTTPSPROV_ACTION Guid  (Authenticode add-on)
//----------------------------------------------------------------------------
//  Assigned to the pgActionID parameter of WinVerifyTrust to verify the
//  SSL/PCT connections through IE.
//
//          {573E31F8-AABA-11d0-8CCB-00C04FC295EE}
//
#define HTTPSPROV_ACTION                                        \
            { 0x573e31f8,                                       \
              0xaaba,                                           \
              0x11d0,                                           \
              { 0x8c, 0xcb, 0x0, 0xc0, 0x4f, 0xc2, 0x95, 0xee } \
            }

#define HTTPS_FINALPOLICY_FUNCTION          L"HTTPSFinalProv"
#define HTTPS_CHKCERT_FUNCTION              L"HTTPSCheckCertProv"
#define HTTPS_CERTTRUST_FUNCTION            L"HTTPSCertificateTrust"





//////////////////////////////////////////////////////////////////////////////
//
// OFFICESIGN_ACTION_VERIFY Guid  (Authenticode add-on)
//----------------------------------------------------------------------------
//  Assigned to the pgActionID parameter of WinVerifyTrust to verify the
//  authenticity of a Structured Storage file using the Microsoft Office
//  Authenticode add-on Policy Provider,
//
//          {5555C2CD-17FB-11d1-85C4-00C04FC295EE}
//
#define     OFFICESIGN_ACTION_VERIFY                                    \
                { 0x5555c2cd,                                           \
                  0x17fb,                                               \
                  0x11d1,                                               \
                  { 0x85, 0xc4, 0x0, 0xc0, 0x4f, 0xc2, 0x95, 0xee }     \
                }

#define     OFFICE_POLICY_PROVIDER_DLL_NAME             SP_POLICY_PROVIDER_DLL_NAME
#define     OFFICE_INITPROV_FUNCTION                    L"OfficeInitializePolicy"
#define     OFFICE_CLEANUPPOLICY_FUNCTION               L"OfficeCleanupPolicy"


//////////////////////////////////////////////////////////////////////////////
//
// DRIVER_ACTION_VERIFY Guid  (Authenticode add-on)
//----------------------------------------------------------------------------
//  Assigned to the pgActionID parameter of WinVerifyTrust to verify the
//  authenticity of a WHQL signed driver.  This is an Authenticode add-on
//  Policy Provider,
//
//          {F750E6C3-38EE-11d1-85E5-00C04FC295EE}
//
#define     DRIVER_ACTION_VERIFY                                        \
                { 0xf750e6c3,                                           \
                  0x38ee,                                               \
                  0x11d1,                                               \
                  { 0x85, 0xe5, 0x0, 0xc0, 0x4f, 0xc2, 0x95, 0xee }     \
                }

#define     DRIVER_INITPROV_FUNCTION                    L"DriverInitializePolicy"
#define     DRIVER_FINALPOLPROV_FUNCTION                L"DriverFinalPolicy"
#define     DRIVER_CLEANUPPOLICY_FUNCTION               L"DriverCleanupPolicy"

typedef struct DRIVER_VER_MAJORMINOR_
{
    DWORD           dwMajor;
    DWORD           dwMinor;
    
} DRIVER_VER_MAJORMINOR;

typedef struct DRIVER_VER_INFO_
{
    DWORD                               cbStruct;               // IN - set to sizeof(DRIVER_VER_INFO)

    ULONG_PTR                           dwReserved1;            // IN - set to NULL
    ULONG_PTR                           dwReserved2;            // IN - set to NULL

    DWORD                               dwPlatform;             // IN - OPTIONAL: platform to use
    DWORD                               dwVersion;              // IN - OPTIONAL: major version to use (NOT USED!!!)

    WCHAR                               wszVersion[MAX_PATH];   // OUT: version string from catalog file
    WCHAR                               wszSignedBy[MAX_PATH];  // OUT: signer display name from certificate
    PCCERT_CONTEXT                      pcSignerCertContext;    // OUT: client MUST free this!!!

    DRIVER_VER_MAJORMINOR               sOSVersionLow;          // IN - OPTIONAL: lowest compatible version
    DRIVER_VER_MAJORMINOR               sOSVersionHigh;         // IN - OPTIONAL: highest compatible version

    DWORD                               dwBuildNumberLow;       // IN - OPTIONAL: added to sOSVersionLow as 
                                                                //      third node for finer version granularity
    DWORD                               dwBuildNumberHigh;      // IN - OPTIONAL: added to sOSVersionHigh as 
                                                                //      third node for finer version granularity

    //
    // NOTES:
    // 1. dwPlatform _must_ be set to a non-zero value in order for proper version checking to be done.
    // 2. dwVersion is no longer used, sOSVersionLow and sOsVersionhigh have taken its place
    // 3. If dwBuildNumberLow and dwBuildNumberHigh are 0, they are unused.  Otherwise, they are considered 
    //    to be extensions of sOSVersionLow and sOSVersionHigh respectively.  Make special note of this when
    //    reading note 4.
    // 4. If you are validating against a single OS version, then set both sOSVersionLow and sOSVersion high,
    //    to the version you are validating against.  If sOSVersionLow and sOSVersionHigh are different, then
    //    the validation is done for the whole version range, from sOSVersionLow to sOSVersionHigh.
    //

} DRIVER_VER_INFO, *PDRIVER_VER_INFO;

#include <poppack.h>


#ifdef __cplusplus
}
#endif

#endif // SOFTPUB_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\spcollec.h ===
/*****************************************************************************
// Copyright Microsoft Corporation. All Rights Reserved. 
* SPCollec.h *
*------------*
*       This header file contains the SAPI5 collection class templates. These
*   are a modified version of the MFC template classes without the dependencies.
*-----------------------------------------------------------------------------
*****************************************************************************/
#ifndef SPCollec_h
#define SPCollec_h

#ifndef _INC_LIMITS
#include <limits.h>
#endif

#ifndef _INC_STDLIB
#include <stdlib.h>
#endif

#ifndef _INC_SEARCH
#include <search.h>
#endif

#include <intsafe.h>

#pragma once

/////////////////////////////////////////////////////////////////////////////
#define SPASSERT_VALID( a )             // This doesn't do anything right now

typedef void* SPLISTPOS;
typedef DWORD SPLISTHANDLE;

#define SP_BEFORE_START_POSITION ((void*)-1L)

inline BOOL SPIsValidAddress(const void* lp, UINT /* nBytes */, BOOL /* bReadWrite */)
{
    return (lp != NULL);
}

/////////////////////////////////////////////////////////////////////////////
// global helpers (can be overridden)

inline HRESULT SPConstructElementsVoid (void *pElements, size_t sizeof_TYPE, int nCount)
{
    HRESULT hr = S_OK;
    _ASSERT( nCount == 0 ||
             SPIsValidAddress( pElements, nCount * (UINT) sizeof_TYPE, TRUE ) );

    // default is bit-wise zero initialization
    memset(pElements, 0, nCount * sizeof_TYPE);
    return hr;
}

template<class TYPE>
inline HRESULT SPConstructElements(TYPE* pElements, int nCount)
{
    HRESULT hr = S_OK;
    _ASSERT( nCount == 0 ||
             SPIsValidAddress( pElements, nCount * sizeof(TYPE), TRUE ) );

    // default is bit-wise zero initialization
    memset((void*)pElements, 0, nCount * sizeof(TYPE));
    return hr;
}

inline void SPDestructElementsVoid(void* pElements, size_t sizeof_TYPE, int nCount)
{
    _ASSERT( ( nCount == 0 ||
               SPIsValidAddress( pElements, nCount * (UINT) sizeof_TYPE, TRUE  ) ) );
    pElements;  // not used
    nCount; // not used
    sizeof_TYPE; // not used

    // default does nothing
}

template<class TYPE>
inline void SPDestructElements(TYPE* pElements, int nCount)
{
    _ASSERT( ( nCount == 0 ||
               SPIsValidAddress( pElements, nCount * sizeof(TYPE), TRUE  ) ) );
    pElements;  // not used
    nCount; // not used

    // default does nothing
}

inline HRESULT SPCopyElementsVoid(void* pDest, const void* pSrc, size_t sizeof_TYPE, int nCount)
{
    HRESULT hr = S_OK;
    _ASSERT( ( nCount == 0 ||
               SPIsValidAddress( pDest, nCount * (UINT) sizeof_TYPE, TRUE  )) );
    _ASSERT( ( nCount == 0 ||
               SPIsValidAddress( pSrc, nCount * (UINT) sizeof_TYPE, FALSE  )) );

    // default is bit-wise copy
    memcpy(pDest, pSrc, nCount * sizeof_TYPE);
    return hr;
}

template<class TYPE>
inline HRESULT SPCopyElements(TYPE* pDest, const TYPE* pSrc, int nCount)
{
    HRESULT hr = S_OK;
    _ASSERT( ( nCount == 0 ||
               SPIsValidAddress( pDest, nCount * sizeof(TYPE), TRUE  )) );
    _ASSERT( ( nCount == 0 ||
               SPIsValidAddress( pSrc, nCount * sizeof(TYPE), FALSE  )) );

    // default is bit-wise copy
    memcpy(pDest, pSrc, nCount * sizeof(TYPE));
    return hr;
}

template<class TYPE, class ARG_TYPE>
BOOL SPCompareElements(const TYPE* pElement1, const ARG_TYPE* pElement2)
{
    _ASSERT( SPIsValidAddress( pElement1, sizeof(TYPE), FALSE ) );
    _ASSERT( SPIsValidAddress( pElement2, sizeof(ARG_TYPE), FALSE ) );
    return *pElement1 == *pElement2;
}

template<class ARG_KEY>
inline UINT SPHashKey(ARG_KEY key)
{
    // default identity hash - works for most primitive values
    return ((UINT)(DWORD_PTR)key) >> 4;
}

/////////////////////////////////////////////////////////////////////////////
// CSPPlex

struct CSPPlex    // warning variable length structure
{
    CSPPlex* pNext;
    UINT nMax;
    UINT nCur;
    /* BYTE data[maxNum*elementSize]; */
    void* data() { return this+1; }

    static CSPPlex* PASCAL Create( CSPPlex*& pHead, UINT nMax, UINT cbElement )
    {
	CSPPlex* p = NULL;
	UINT cbSize;
	if (SUCCEEDED(UIntMult(nMax, cbElement, &cbSize)) && SUCCEEDED(UIntAdd(cbSize, sizeof(CSPPlex), &cbSize)))
	{
	    p = (CSPPlex*) new BYTE[cbSize];
	}
        if (p != NULL)
        {
            p->nMax = nMax;
            p->nCur = 0;
            p->pNext = pHead;
            pHead = p;  // change head (adds in reverse order for simplicity)
        }
        return p;
    }

    void FreeDataChain()
    {
        CSPPlex* p = this;
        while (p != NULL)
        {
            BYTE* bytes = (BYTE*) p;
            CSPPlex* pNext = p->pNext;
            delete[] bytes;
            p = pNext;
        }
    }
};


/////////////////////////////////////////////////////////////////////////////
// CSPArray<TYPE, ARG_TYPE>

class CSPArrayVoid // non-template base worked class for template CSPArray
{
public:
// Construction
    CSPArrayVoid();

// Attributes
    int GetSize() const;
    int GetUpperBound() const;
    HRESULT SetSize(int nNewSize, int nGrowBy = -1);

    // Clean up
    void FreeExtra();
    void RemoveAll();

    // Operations that move elements around
    void    RemoveAt(int nIndex, int nCount = 1);
    void    Sort(int (__cdecl *compare )(const void *elem1, const void *elem2 ));

// Implementation
protected:
    void*  m_pData;          // the actual array of data
    int    m_nSize;          // # of elements (upperBound - 1)
    int    m_nMaxSize;       // max allocated
    int    m_nGrowBy;        // grow amount
    size_t m_sizeofTYPE;     // size of TYPE in template class
    
public:
    ~CSPArrayVoid();
#ifdef _DEBUG
    void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CSPArrayVoid implementation

inline int CSPArrayVoid::GetSize() const
    { return m_nSize; }
inline int CSPArrayVoid::GetUpperBound() const
    { return m_nSize-1; }
inline void CSPArrayVoid::RemoveAll()
    { SetSize(0, -1); }

inline CSPArrayVoid::CSPArrayVoid()
{
    m_pData = NULL;
    m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

inline CSPArrayVoid::~CSPArrayVoid()
{
    SPASSERT_VALID( this );

    if (m_pData != NULL)
    {
        SPDestructElementsVoid(m_pData, m_sizeofTYPE, m_nSize);
        delete[] (BYTE*)m_pData;
    }
}

inline HRESULT CSPArrayVoid::SetSize(int nNewSize, int nGrowBy)
{
    SPASSERT_VALID( this );
    _ASSERT( nNewSize >= 0 );
    HRESULT hr = S_OK;

    if (nGrowBy != -1)
        m_nGrowBy = nGrowBy;  // set new size

    if (nNewSize == 0)
    {
        // shrink to nothing
        if (m_pData != NULL)
        {
            SPDestructElementsVoid(m_pData, m_sizeofTYPE, m_nSize);
            delete[] (BYTE*)m_pData;
            m_pData = NULL;
        }
        m_nSize = m_nMaxSize = 0;
    }
    else if (m_pData == NULL)
    {
        // create one with exact size
#ifdef SIZE_T_MAX
        _ASSERT( (UINT)nNewSize <= SIZE_T_MAX/m_sizeofTYPE );    // no overflow
#endif
        m_pData = (void *)new BYTE[nNewSize * m_sizeofTYPE];
        if( m_pData )
        {
            hr = SPConstructElementsVoid(m_pData, m_sizeofTYPE, nNewSize);
            if( SUCCEEDED( hr ) )
            {
                m_nSize = m_nMaxSize = nNewSize;
            }
            else
            {
                delete[] (BYTE*)m_pData;
                m_pData = NULL;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else if (nNewSize <= m_nMaxSize)
    {
        // it fits
        if (nNewSize > m_nSize)
        {
            // initialize the new elements
            hr = SPConstructElementsVoid((BYTE *)m_pData+m_nSize*m_sizeofTYPE, m_sizeofTYPE, nNewSize-m_nSize);
        }
        else if (m_nSize > nNewSize)
        {
            // destroy the old elements
            SPDestructElementsVoid((BYTE *)m_pData+nNewSize*m_sizeofTYPE, m_sizeofTYPE, m_nSize-nNewSize);
        }

        if( SUCCEEDED( hr ) )
        {
            m_nSize = nNewSize;
        }
    }
    else
    {
        // otherwise, grow array
        nGrowBy = m_nGrowBy;
        if (nGrowBy == 0)
        {
            // heuristically determe growth when nGrowBy == 0
            //  (this avoids heap fragmentation in many situations)
            nGrowBy = min(1024, max(4, m_nSize / 8));
        }
        int nNewMax;
        if (nNewSize < m_nMaxSize + nGrowBy)
            nNewMax = m_nMaxSize + nGrowBy;  // granularity
        else
            nNewMax = nNewSize;  // no slush

        _ASSERT( nNewMax >= m_nMaxSize );  // no wrap around
#ifdef SIZE_T_MAX
        _ASSERT( (UINT)nNewMax <= SIZE_T_MAX/m_sizeofTYPE ); // no overflow
#endif
        void* pNewData = (void *)new BYTE[nNewMax * m_sizeofTYPE];

        if( pNewData )
        {
            // copy new data from old
            memcpy(pNewData, m_pData, m_nSize * m_sizeofTYPE);

            // construct remaining elements
            _ASSERT( nNewSize > m_nSize );
            hr = SPConstructElementsVoid((BYTE *)pNewData+m_nSize*m_sizeofTYPE, m_sizeofTYPE, nNewSize-m_nSize);

            // get rid of old stuff (note: no destructors called)
            delete[] (BYTE*)m_pData;
            m_pData = pNewData;
            m_nSize = nNewSize;
            m_nMaxSize = nNewMax;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

inline void CSPArrayVoid::FreeExtra()
{
    SPASSERT_VALID( this );

    if (m_nSize != m_nMaxSize)
    {
        // shrink to desired size
#ifdef SIZE_T_MAX
        _ASSERT( (UINT)m_nSize <= SIZE_T_MAX/m_sizeofTYPE); // no overflow
#endif
        void* pNewData = NULL;
        if (m_nSize != 0)
        {
            pNewData =  (void *)new BYTE[m_nSize * m_sizeofTYPE];
            _ASSERT(pNewData);
            // copy new data from old
            memcpy(pNewData, m_pData, m_nSize * m_sizeofTYPE);
        }

        // get rid of old stuff (note: no destructors called)
        delete[] (BYTE*)m_pData;
        m_pData = pNewData;
        m_nMaxSize = m_nSize;
    }
}

inline void CSPArrayVoid::RemoveAt(int nIndex, int nCount)
{
    SPASSERT_VALID( this );
    _ASSERT( nIndex >= 0 );
    _ASSERT( nCount >= 0 );
    _ASSERT( nIndex + nCount <= m_nSize );

    // just remove a range
    int nMoveCount = m_nSize - (nIndex + nCount);
    SPDestructElementsVoid((BYTE *)m_pData + nIndex*m_sizeofTYPE, m_sizeofTYPE, nCount);
    if (nMoveCount)
        memcpy((BYTE *)m_pData + nIndex*m_sizeofTYPE, (BYTE *)m_pData + (nIndex + nCount)*m_sizeofTYPE,
            nMoveCount * m_sizeofTYPE);
    m_nSize -= nCount;
}

inline void CSPArrayVoid::Sort(int (__cdecl *compare )(const void *elem1, const void *elem2 ))
{
    SPASSERT_VALID( this );
    _ASSERT( m_pData != NULL );

    qsort( m_pData, m_nSize, m_sizeofTYPE, compare );
}

#ifdef _DEBUG
inline void CSPArrayVoid::AssertValid() const
{
    if (m_pData == NULL)
    {
        _ASSERT( m_nSize == 0 );
        _ASSERT( m_nMaxSize == 0 );
    }
    else
    {
        _ASSERT( m_nSize >= 0 );
        _ASSERT( m_nMaxSize >= 0 );
        _ASSERT( m_nSize <= m_nMaxSize );
        _ASSERT( SPIsValidAddress(m_pData, m_nMaxSize * (UINT) m_sizeofTYPE, TRUE ) );
    }
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// now for the derived template class

template<class TYPE, class ARG_TYPE>
class CSPArray : public CSPArrayVoid
{
public:
// Construction
    CSPArray();

// Attributes
//    int GetSize() const;       // now in base class
//    int GetUpperBound() const; // now in base class

// Operations
    // Clean up
//    void FreeExtra();          // now in base class
//    void RemoveAll();          // now in base class

    // Accessing elements
    TYPE GetAt(int nIndex) const;
    void SetAt(int nIndex, ARG_TYPE newElement);
    TYPE& ElementAt(int nIndex);

    // Direct Access to the element data (may return NULL)
    const TYPE* GetData() const;
    TYPE* GetData();

    // Potentially growing the array
    HRESULT SetAtGrow(int nIndex, ARG_TYPE newElement);

    // the helper method add will call SetAtGrow and return the original size of the array (essentially the index of the entry you just added)
    int Add(ARG_TYPE newElement);
    // AddHR is the same as Add except it returns a HRESULT instead of the new index. Essentially the same as SetAtGrow but without requiring the target index
    HRESULT AddHR(ARG_TYPE newElement);
    int Append(const CSPArray& src);
    HRESULT Copy(const CSPArray& src);

    // overloaded operator helpers
    TYPE operator[](int nIndex) const;
    TYPE& operator[](int nIndex);

    // Operations that move elements around
    HRESULT InsertAt(int nIndex, ARG_TYPE newElement, int nCount = 1);
//    void    RemoveAt(int nIndex, int nCount = 1); // now in base class
    HRESULT InsertAt(int nStartIndex, CSPArray* pNewArray);
//    void    Sort(int (__cdecl *compare )(const void *elem1, const void *elem2 )); // now in base class

public:
    ~CSPArray() {};
#ifdef _DEBUG
//  void Dump(CDumpContext&) const;
    void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CSPArray<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline TYPE CSPArray<TYPE, ARG_TYPE>::GetAt(int nIndex) const
    { _ASSERT( (nIndex >= 0 && nIndex < m_nSize) );
        return ((TYPE *)m_pData)[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline void CSPArray<TYPE, ARG_TYPE>::SetAt(int nIndex, ARG_TYPE newElement)
    { _ASSERT( (nIndex >= 0 && nIndex < m_nSize) );
        ((TYPE *)m_pData)[nIndex] = newElement; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CSPArray<TYPE, ARG_TYPE>::ElementAt(int nIndex)
    { _ASSERT( (nIndex >= 0 && nIndex < m_nSize) );
        return ((TYPE *)m_pData)[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline const TYPE* CSPArray<TYPE, ARG_TYPE>::GetData() const
    { return (const TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline TYPE* CSPArray<TYPE, ARG_TYPE>::GetData()
    { return (TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline int CSPArray<TYPE, ARG_TYPE>::Add(ARG_TYPE newElement)
    { int nIndex = m_nSize;
        SetAtGrow(nIndex, newElement);
        return nIndex; }
template<class TYPE, class ARG_TYPE>
inline HRESULT CSPArray<TYPE, ARG_TYPE>::AddHR(ARG_TYPE newElement)
    {   return SetAtGrow(m_nSize, newElement); }
template<class TYPE, class ARG_TYPE>
inline TYPE CSPArray<TYPE, ARG_TYPE>::operator[](int nIndex) const
    { return GetAt(nIndex); }
template<class TYPE, class ARG_TYPE>
inline TYPE& CSPArray<TYPE, ARG_TYPE>::operator[](int nIndex)
    { return ElementAt(nIndex); }

/////////////////////////////////////////////////////////////////////////////
// CSPArray<TYPE, ARG_TYPE> out-of-line functions

template<class TYPE, class ARG_TYPE>
inline CSPArray<TYPE, ARG_TYPE>::CSPArray()
{
    m_sizeofTYPE = sizeof(TYPE);
}

template<class TYPE, class ARG_TYPE>
int CSPArray<TYPE, ARG_TYPE>::Append(const CSPArray& src)
{
    SPASSERT_VALID( this );
    _ASSERT( this != &src );   // cannot append to itself

    int nOldSize = m_nSize;
    HRESULT hr = SetSize(m_nSize + src.m_nSize);
    if( SUCCEEDED( hr ) )
    {
        hr = SPCopyElements((TYPE *)m_pData + nOldSize, (TYPE *)(src.m_pData), src.m_nSize);
    }
    return ( SUCCEEDED( hr ) )?(nOldSize):(-1);
}

template<class TYPE, class ARG_TYPE>
HRESULT CSPArray<TYPE, ARG_TYPE>::Copy(const CSPArray& src)
{
    SPASSERT_VALID( this );
    _ASSERT( this != &src );   // cannot copy to itself

    HRESULT hr = SetSize(src.m_nSize);
    if( SUCCEEDED( hr ) )
    {
        hr = SPCopyElements((TYPE *)m_pData, (TYPE *)(src.m_pData), src.m_nSize);
    }
    return hr;
}

template<class TYPE, class ARG_TYPE>
HRESULT CSPArray<TYPE, ARG_TYPE>::SetAtGrow(int nIndex, ARG_TYPE newElement)
{
    SPASSERT_VALID( this );
    _ASSERT( nIndex >= 0 );
    HRESULT hr = S_OK;

    if (nIndex >= m_nSize)
    {
        hr = SetSize(nIndex+1, -1);
    }

    if( SUCCEEDED( hr ) )
    {
        ((TYPE *)m_pData)[nIndex] = newElement;
    }
    return hr;
}

template<class TYPE, class ARG_TYPE>
HRESULT CSPArray<TYPE, ARG_TYPE>::InsertAt(int nIndex, ARG_TYPE newElement, int nCount /*=1*/)
{
    SPASSERT_VALID( this );
    _ASSERT( nIndex >= 0 );    // will expand to meet need
    _ASSERT( nCount > 0 );     // zero or negative size not allowed
    HRESULT hr = S_OK;

    if (nIndex >= m_nSize)
    {
        // adding after the end of the array
        hr = SetSize(nIndex + nCount, -1);   // grow so nIndex is valid
    }
    else
    {
        // inserting in the middle of the array
        int nOldSize = m_nSize;
        hr = SetSize(m_nSize + nCount, -1);  // grow it to new size
        if( SUCCEEDED( hr ) )
        {
            // shift old data up to fill gap
            memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
                (nOldSize-nIndex) * sizeof(TYPE));

            // re-init slots we copied from
            hr = SPConstructElements(&m_pData[nIndex], nCount);
        }
    }

    // insert new value in the gap
    if( SUCCEEDED( hr ) )
    {
        _ASSERT( nIndex + nCount <= m_nSize );
        while (nCount--)
            ((TYPE *)m_pData)[nIndex++] = newElement;
    }
    return hr;
}

template<class TYPE, class ARG_TYPE>
HRESULT CSPArray<TYPE, ARG_TYPE>::InsertAt(int nStartIndex, CSPArray* pNewArray)
{
    SPASSERT_VALID( this );
    SPASSERT_VALID( pNewArray );
    _ASSERT( nStartIndex >= 0 );
    HRESULT hr = S_OK;

    if (pNewArray->GetSize() > 0)
    {
        hr = InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
        for (int i = 0; SUCCEEDED( hr )&& (i < pNewArray->GetSize()); i++)
        {
            SetAt(nStartIndex + i, pNewArray->GetAt(i));
        }
    }
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSPList<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CSPList
{
protected:
    struct CNode
    {
        CNode* pNext;
        CNode* pPrev;
        TYPE data;
    };
public:

// Construction
    CSPList(int nBlockSize = 10);

// Attributes (head and tail)
    // count of elements
    int GetCount() const;
    BOOL IsEmpty() const;

    // peek at head or tail
    TYPE& GetHead();
    TYPE GetHead() const;
    TYPE& GetTail();
    TYPE GetTail() const;

// Operations
    // get head or tail (and remove it) - don't call on empty list !
    TYPE RemoveHead();
    TYPE RemoveTail();

    // add before head or after tail
    SPLISTPOS AddHead(ARG_TYPE newElement);
    SPLISTPOS AddTail(ARG_TYPE newElement);

    // add another list of elements before head or after tail
    void AddHead(CSPList* pNewList);
    void AddTail(CSPList* pNewList);

    // remove all elements
    void RemoveAll();

    // iteration
    SPLISTPOS GetHeadPosition() const;
    SPLISTPOS GetTailPosition() const;
    TYPE& GetNext(SPLISTPOS& rPosition); // return *Position++
    TYPE GetNext(SPLISTPOS& rPosition) const; // return *Position++
    TYPE& GetPrev(SPLISTPOS& rPosition); // return *Position--
    TYPE GetPrev(SPLISTPOS& rPosition) const; // return *Position--

    // getting/modifying an element at a given position
    TYPE& GetAt(SPLISTPOS position);
    TYPE GetAt(SPLISTPOS position) const;
    void SetAt(SPLISTPOS pos, ARG_TYPE newElement);
    void RemoveAt(SPLISTPOS position);

    // inserting before or after a given position
    SPLISTPOS InsertBefore(SPLISTPOS position, ARG_TYPE newElement);
    SPLISTPOS InsertAfter(SPLISTPOS position, ARG_TYPE newElement);

    // helper functions (note: O(n) speed)
    SPLISTPOS Find(ARG_TYPE searchValue, SPLISTPOS startAfter = NULL) const;
        // defaults to starting at the HEAD, return NULL if not found
    SPLISTPOS FindIndex(int nIndex) const;
        // get the 'nIndex'th element (may return NULL)

// Implementation
protected:
    CNode* m_pNodeHead;
    CNode* m_pNodeTail;
    int m_nCount;
    CNode* m_pNodeFree;
    struct CSPPlex* m_pBlocks;
    int m_nBlockSize;

    CNode* NewNode(CNode* pPrev, CNode* pNext)
    {
        if (m_pNodeFree == NULL)
        {
            // add another block
            CSPPlex* pNewBlock = CSPPlex::Create(m_pBlocks, m_nBlockSize,sizeof(CNode));
            if (pNewBlock != NULL)
            {
                // chain them into free list
                CNode* pNode = (CNode*) pNewBlock->data();
                // free in reverse order to make it easier to debug
                pNode += m_nBlockSize - 1;
                for (int i = m_nBlockSize-1; i >= 0; i--, pNode--)
                {
                    pNode->pNext = m_pNodeFree;
                    m_pNodeFree = pNode;
                }
            }
        }

        CNode* pNode = m_pNodeFree;
        if( pNode )
        {
            if( SUCCEEDED( SPConstructElements(&pNode->data, 1) ) )
            {
                m_pNodeFree  = m_pNodeFree->pNext;
                pNode->pPrev = pPrev;
                pNode->pNext = pNext;
                m_nCount++;
                _ASSERT( m_nCount > 0 );  // make sure we don't overflow
            }
        }
        return pNode;
    }
    void FreeNode(CNode* pNode)
    {
        SPDestructElements(&pNode->data, 1);
        pNode->pNext = m_pNodeFree;
        m_pNodeFree = pNode;
        m_nCount--;
        _ASSERT( m_nCount >= 0 );  // make sure we don't underflow
    }

public:
    ~CSPList();
#ifdef _DEBUG
    void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CSPList<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CSPList<TYPE, ARG_TYPE>::GetCount() const
    { return m_nCount; }
template<class TYPE, class ARG_TYPE>
inline BOOL CSPList<TYPE, ARG_TYPE>::IsEmpty() const
    { return m_nCount == 0; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CSPList<TYPE, ARG_TYPE>::GetHead()
    {   _ASSERT( m_pNodeHead != NULL );
        return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CSPList<TYPE, ARG_TYPE>::GetHead() const
    {   _ASSERT( m_pNodeHead != NULL );
        return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CSPList<TYPE, ARG_TYPE>::GetTail()
    {   _ASSERT( m_pNodeTail != NULL );
        return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CSPList<TYPE, ARG_TYPE>::GetTail() const
    {   _ASSERT( m_pNodeTail != NULL );
        return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline SPLISTPOS CSPList<TYPE, ARG_TYPE>::GetHeadPosition() const
    { return (SPLISTPOS) m_pNodeHead; }
template<class TYPE, class ARG_TYPE>
inline SPLISTPOS CSPList<TYPE, ARG_TYPE>::GetTailPosition() const
    { return (SPLISTPOS) m_pNodeTail; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CSPList<TYPE, ARG_TYPE>::GetNext(SPLISTPOS& rPosition) // return *Position++
    {   CNode* pNode = (CNode*) rPosition;
        _ASSERT( SPIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        rPosition = (SPLISTPOS) pNode->pNext;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CSPList<TYPE, ARG_TYPE>::GetNext(SPLISTPOS& rPosition) const // return *Position++
    {   CNode* pNode = (CNode*) rPosition;
        _ASSERT( SPIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        rPosition = (SPLISTPOS) pNode->pNext;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CSPList<TYPE, ARG_TYPE>::GetPrev(SPLISTPOS& rPosition) // return *Position--
    {   CNode* pNode = (CNode*) rPosition;
        _ASSERT( SPIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        rPosition = (SPLISTPOS) pNode->pPrev;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CSPList<TYPE, ARG_TYPE>::GetPrev(SPLISTPOS& rPosition) const // return *Position--
    {   CNode* pNode = (CNode*) rPosition;
        _ASSERT( SPIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        rPosition = (SPLISTPOS) pNode->pPrev;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CSPList<TYPE, ARG_TYPE>::GetAt(SPLISTPOS position)
    {   CNode* pNode = (CNode*) position;
        _ASSERT( SPIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CSPList<TYPE, ARG_TYPE>::GetAt(SPLISTPOS position) const
    {   CNode* pNode = (CNode*) position;
        _ASSERT( SPIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline void CSPList<TYPE, ARG_TYPE>::SetAt(SPLISTPOS pos, ARG_TYPE newElement)
    {   CNode* pNode = (CNode*) pos;
        _ASSERT( SPIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        pNode->data = newElement; }

/////////////////////////////////////////////////////////////////////////////
// CSPList<TYPE, ARG_TYPE> out-of-line functions

template<class TYPE, class ARG_TYPE>
CSPList<TYPE, ARG_TYPE>::CSPList( int nBlockSize )
{
    _ASSERT( nBlockSize > 0 );

    m_nCount = 0;
    m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
    m_pBlocks = NULL;
    m_nBlockSize = nBlockSize;
}

template<class TYPE, class ARG_TYPE>
void CSPList<TYPE, ARG_TYPE>::RemoveAll()
{
    SPASSERT_VALID( this );

    // destroy elements
    CNode* pNode;
    for (pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
        SPDestructElements(&pNode->data, 1);

    m_nCount = 0;
    m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
    
    if (m_pBlocks != NULL)
    {
        m_pBlocks->FreeDataChain();
        m_pBlocks = NULL;
    }
}

template<class TYPE, class ARG_TYPE>
CSPList<TYPE, ARG_TYPE>::~CSPList()
{
    RemoveAll();
    _ASSERT( m_nCount == 0 );
}

/////////////////////////////////////////////////////////////////////////////
// Node helpers
//
// Implementation note: CNode's are stored in CSPPlex blocks and
//  chained together. Free blocks are maintained in a singly linked list
//  using the 'pNext' member of CNode with 'm_pNodeFree' as the head.
//  Used blocks are maintained in a doubly linked list using both 'pNext'
//  and 'pPrev' as links and 'm_pNodeHead' and 'm_pNodeTail'
//   as the head/tail.
//
// We never free a CSPPlex block unless the List is destroyed or RemoveAll()
//  is used - so the total number of CSPPlex blocks may grow large depending
//  on the maximum past size of the list.
//

template<class TYPE, class ARG_TYPE>
SPLISTPOS CSPList<TYPE, ARG_TYPE>::AddHead(ARG_TYPE newElement)
{
    SPASSERT_VALID( this );

    CNode* pNewNode = NewNode(NULL, m_pNodeHead);
    if( pNewNode )
    {
        pNewNode->data = newElement;
        if (m_pNodeHead != NULL)
            m_pNodeHead->pPrev = pNewNode;
        else
            m_pNodeTail = pNewNode;
        m_pNodeHead = pNewNode;
    }
    return (SPLISTPOS) pNewNode;
}

template<class TYPE, class ARG_TYPE>
SPLISTPOS CSPList<TYPE, ARG_TYPE>::AddTail(ARG_TYPE newElement)
{
    SPASSERT_VALID( this );

    CNode* pNewNode = NewNode(m_pNodeTail, NULL);
    if( pNewNode )
    {
        pNewNode->data = newElement;
        if (m_pNodeTail != NULL)
            m_pNodeTail->pNext = pNewNode;
        else
            m_pNodeHead = pNewNode;
        m_pNodeTail = pNewNode;
    }
    return (SPLISTPOS) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CSPList<TYPE, ARG_TYPE>::AddHead(CSPList* pNewList)
{
    SPASSERT_VALID( this );
    SPASSERT_VALID( pNewList );

    // add a list of same elements to head (maintain order)
    SPLISTPOS pos = pNewList->GetTailPosition();
    while (pos != NULL)
        AddHead(pNewList->GetPrev(pos));
}

template<class TYPE, class ARG_TYPE>
void CSPList<TYPE, ARG_TYPE>::AddTail(CSPList* pNewList)
{
    SPASSERT_VALID( this );
    SPASSERT_VALID( pNewList );

    // add a list of same elements
    SPLISTPOS pos = pNewList->GetHeadPosition();
    while (pos != NULL)
        AddTail(pNewList->GetNext(pos));
}

template<class TYPE, class ARG_TYPE>
TYPE CSPList<TYPE, ARG_TYPE>::RemoveHead()
{
    SPASSERT_VALID( this );
    _ASSERT( m_pNodeHead != NULL );  // don't call on empty list !!!
    _ASSERT( SPIsValidAddress(m_pNodeHead, sizeof(CNode), TRUE ) );

    CNode* pOldNode = m_pNodeHead;
    TYPE returnValue = pOldNode->data;

    m_pNodeHead = pOldNode->pNext;
    if (m_pNodeHead != NULL)
        m_pNodeHead->pPrev = NULL;
    else
        m_pNodeTail = NULL;
    FreeNode(pOldNode);
    return returnValue;
}

template<class TYPE, class ARG_TYPE>
TYPE CSPList<TYPE, ARG_TYPE>::RemoveTail()
{
    SPASSERT_VALID( this );
    _ASSERT( m_pNodeTail != NULL );  // don't call on empty list !!!
    _ASSERT( SPIsValidAddress(m_pNodeTail, sizeof(CNode), TRUE ) );

    CNode* pOldNode = m_pNodeTail;
    TYPE returnValue = pOldNode->data;

    m_pNodeTail = pOldNode->pPrev;
    if (m_pNodeTail != NULL)
        m_pNodeTail->pNext = NULL;
    else
        m_pNodeHead = NULL;
    FreeNode(pOldNode);
    return returnValue;
}

template<class TYPE, class ARG_TYPE>
SPLISTPOS CSPList<TYPE, ARG_TYPE>::InsertBefore(SPLISTPOS position, ARG_TYPE newElement)
{
    SPASSERT_VALID( this );

    if (position == NULL)
        return AddHead(newElement); // insert before nothing -> head of the list

    // Insert it before position
    CNode* pOldNode = (CNode*) position;
    CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
    if( pNewNode )
    {
        pNewNode->data = newElement;

        if (pOldNode->pPrev != NULL)
        {
            _ASSERT( SPIsValidAddress(pOldNode->pPrev, sizeof(CNode), TRUE ) );
            pOldNode->pPrev->pNext = pNewNode;
        }
        else
        {
            _ASSERT( pOldNode == m_pNodeHead );
            m_pNodeHead = pNewNode;
        }
        pOldNode->pPrev = pNewNode;
    }
    return (SPLISTPOS) pNewNode;
}

template<class TYPE, class ARG_TYPE>
SPLISTPOS CSPList<TYPE, ARG_TYPE>::InsertAfter(SPLISTPOS position, ARG_TYPE newElement)
{
    SPASSERT_VALID( this );

    if (position == NULL)
        return AddTail(newElement); // insert after nothing -> tail of the list

    // Insert it before position
    CNode* pOldNode = (CNode*) position;
    _ASSERT( SPIsValidAddress(pOldNode, sizeof(CNode), TRUE ));
    CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
    if( pNewNode )
    {
        pNewNode->data = newElement;

        if (pOldNode->pNext != NULL)
        {
            _ASSERT( SPIsValidAddress(pOldNode->pNext, sizeof(CNode), TRUE ));
            pOldNode->pNext->pPrev = pNewNode;
        }
        else
        {
            _ASSERT( pOldNode == m_pNodeTail );
            m_pNodeTail = pNewNode;
        }
        pOldNode->pNext = pNewNode;
    }
    return (SPLISTPOS) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CSPList<TYPE, ARG_TYPE>::RemoveAt(SPLISTPOS position)
{
    SPASSERT_VALID( this );

    CNode* pOldNode = (CNode*) position;
    _ASSERT( SPIsValidAddress(pOldNode, sizeof(CNode), TRUE ) );

    // remove pOldNode from list
    if (pOldNode == m_pNodeHead)
    {
        m_pNodeHead = pOldNode->pNext;
    }
    else
    {
        _ASSERT( SPIsValidAddress(pOldNode->pPrev, sizeof(CNode), TRUE ) );
        pOldNode->pPrev->pNext = pOldNode->pNext;
    }
    if (pOldNode == m_pNodeTail)
    {
        m_pNodeTail = pOldNode->pPrev;
    }
    else
    {
        _ASSERT( SPIsValidAddress(pOldNode->pNext, sizeof(CNode), TRUE ) );
        pOldNode->pNext->pPrev = pOldNode->pPrev;
    }
    FreeNode(pOldNode);
}

template<class TYPE, class ARG_TYPE>
SPLISTPOS CSPList<TYPE, ARG_TYPE>::FindIndex(int nIndex) const
{
    SPASSERT_VALID( this );
    _ASSERT( nIndex >= 0 );

    if (nIndex >= m_nCount)
        return NULL;  // went too far

    CNode* pNode = m_pNodeHead;
    while (nIndex--)
    {
        _ASSERT( SPIsValidAddress(pNode, sizeof(CNode), TRUE ));
        pNode = pNode->pNext;
    }
    return (SPLISTPOS) pNode;
}

template<class TYPE, class ARG_TYPE>
SPLISTPOS CSPList<TYPE, ARG_TYPE>::Find(ARG_TYPE searchValue, SPLISTPOS startAfter) const
{
    SPASSERT_VALID( this );

    CNode* pNode = (CNode*) startAfter;
    if (pNode == NULL)
    {
        pNode = m_pNodeHead;  // start at head
    }
    else
    {
        _ASSERT( SPIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        pNode = pNode->pNext;  // start after the one specified
    }

    for (; pNode != NULL; pNode = pNode->pNext)
        if (SPCompareElements(&pNode->data, &searchValue))
            return (SPLISTPOS)pNode;
    return NULL;
}

#ifdef _DEBUG
template<class TYPE, class ARG_TYPE>
void CSPList<TYPE, ARG_TYPE>::AssertValid() const
{
    if (m_nCount == 0)
    {
        // empty list
        _ASSERT( m_pNodeHead == NULL );
        _ASSERT( m_pNodeTail == NULL );
    }
    else
    {
        // non-empty list
        _ASSERT( SPIsValidAddress(m_pNodeHead, sizeof(CNode), TRUE ));
        _ASSERT( SPIsValidAddress(m_pNodeTail, sizeof(CNode), TRUE ));
    }
}
#endif //_DEBUG


#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\spddkhlp.h ===
/*******************************************************************************
// Copyright Microsoft Corporation. All Rights Reserved. 
* SPDDKHLP.h *
*------------*
*   Description:
*       This is the header file for core helper functions implementation.
*
*
*******************************************************************************/
#ifndef SPDDKHLP_h
#define SPDDKHLP_h

#include <tchar.h>

#ifndef SPHelper_h
#include <sphelper.h>
#endif

#include <sapiddk.h>

//=== Constants ==============================================================
#define sp_countof(x) ((sizeof(x) / sizeof(*(x))))

#define SP_IS_BAD_WRITE_PTR(p)     ( !(p) || SPIsBadWritePtr( p, sizeof(*(p)) ))
#define SP_IS_BAD_READ_PTR(p)      ( !(p) || SPIsBadReadPtr(  p, sizeof(*(p)) ))
#define SP_IS_BAD_CODE_PTR(p)      ( (FARPROC)(p) == 0 )
#define SP_IS_BAD_INTERFACE_PTR(p) ( SPIsBadInterfacePtr( (p) )  )
#define SP_IS_BAD_VARIANT_PTR(p)   ( SPIsBadVARIANTPtr( (p) ) )
#define SP_IS_BAD_STRING_PTR(p)    ( SPIsBadStringPtr( (p) ) )

#define SP_IS_BAD_OPTIONAL_WRITE_PTR(p)     ((p) && SPIsBadWritePtr( p, sizeof(*(p)) ))
#define SP_IS_BAD_OPTIONAL_READ_PTR(p)      ((p) && SPIsBadReadPtr(  p, sizeof(*(p)) ))
#define SP_IS_BAD_OPTIONAL_INTERFACE_PTR(p) ((p) && SPIsBadInterfacePtr(p))
#define SP_IS_BAD_OPTIONAL_STRING_PTR(p)    ((p) && SPIsBadStringPtr(p))

#define SP_IS_BAD_READ_ARRAY(p,cElements)     ( SPIsBadReadArray( p, cElements, sizeof(*p) ) )
#define SP_IS_BAD_WRITE_ARRAY(p,cElements)     ( SPIsBadWriteArray( p, cElements, sizeof(*p) ) )

#define SP_DOES_PTR_ADDITION_WRAP(p)    ( SPDoesPtrAdditionWrap( p, sizeof(*p) ) )
#define SP_IS_PTR_OUT_OF_BOUNDS(p,pBound)    ( SPIsPtrOutOfBounds( p, sizeof(*p), pBound ) )

#define sp_sgn(x) ( (x) == 0 ? 0 : ( (x)>0 ? 1 : -1 ) )

//=== Class, Enum, Struct, Template, and Union Declarations ==================

//=== Inlines ================================================================

/*** Pointer validation functions
*/

inline BOOL SPIsBadStringPtr( const WCHAR * psz, ULONG cMaxChars = 0xFFFFF )
{
    return ((psz == NULL) || (wcslen(psz) + 1 > cMaxChars));
}

inline BOOL SPIsBadReadPtr( __in_bcount(Size) const void* pMem, size_t Size )
{
    return (pMem == NULL) && (Size != 0);
}

inline BOOL SPIsBadWritePtr( __in_bcount(Size) void* pMem, size_t Size )
{
    return (pMem == NULL) && (Size != 0);
}

inline BOOL SPIsBadInterfacePtr( const IUnknown* pUnknown )
{
    return (pUnknown == NULL);
}

inline BOOL SPIsBadVARIANTPtr( const VARIANT* pVar )
{
    return (pVar == NULL);
}

inline BOOL SPDoesPtrAdditionWrap( __in_bcount(Size) const void* pMem, size_t Size )
{
    return ((const BYTE*)pMem + Size) < (const BYTE*)pMem;
}

inline BOOL SPIsBadReadArray( const void* pMem, ULONG cElementCount, size_t cBytesPerElement)
{
    size_t cByteCount = cBytesPerElement * cElementCount;

    if ( // Does the multiplication operation overflow?
         ( ( cByteCount / cBytesPerElement ) != cElementCount ) ||
         // Does the pointer addition wrap?
         ( SPDoesPtrAdditionWrap ( pMem, cByteCount ) ) ||
         // Can we read from the pointer?
         ( SPIsBadReadPtr ( pMem, cByteCount ) ) )
    {
        // One of the preconditions didn't hold.
        // YES, this IS a BAD Read array.
        return TRUE;
    }
    else
    {
        // NO, this is NOT a BAD Read array.
        return FALSE;
    }
}

inline BOOL SPIsBadWriteArray( void* pMem, ULONG cElementCount, size_t cBytesPerElement)
{
    size_t cByteCount = cBytesPerElement * cElementCount;

    if ( // Did the multiplication operation overflow?
         ( ( cByteCount / cBytesPerElement ) != cElementCount ) ||
         // Does the pointer addition wrap?
         ( SPDoesPtrAdditionWrap ( pMem, cByteCount ) ) ||
         // Can we write to this pointer?
         ( SPIsBadWritePtr ( pMem, cByteCount ) ) )
    {
        // One of the preconditions didn't hold.
        // YES, this IS a BAD Write array.
        return TRUE;
    }
    else
    {
        // NO, this is NOT a BAD Write array.
        return FALSE;
    }
}

/************************************************************************
* SPIsPtrOutOfBounds     *
* -------------------------------*
* Description:
*   Ensures that ( n_pStart + n_cBytes ) doesn't wrap/overflow, and
*   doesn't scroll up to or past n_pBound. 
*
*   Returns:
*   FALSE               Memory block is in bounds
*   TRUE                Pointer arithmetic overflow, or
*                         ( n_pStart + n_cBytes ) >= n_pBound
*   
************************************************************** mishav ***/
inline BOOL SPIsPtrOutOfBounds(__in_bcount(n_cBytes) const void* n_pStart,
                                  size_t n_cBytes, 
                                  const void* n_pBound)
{
    const void* pEnd = (const BYTE*)n_pStart + n_cBytes;

    // In order to be valid, the pointers MUST be arranged
    // in the following order:
    // n_pStart <= pEnd < n_pBound.

    if ( ( n_pStart <= pEnd ) &&
         ( pEnd <= n_pBound) )
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}


inline BOOL SPIsArrayOutOfBounds(const void* n_pStart,
                                 ULONG n_cElements,
                                 size_t n_cBytesPerElement,
                                 const void* n_pBound)
{
    // Perform and check the multiplication
    size_t cBytesTotal = n_cElements * n_cBytesPerElement;
    if ( ( cBytesTotal / n_cElements ) != n_cBytesPerElement )
    {
        return FALSE;
    }
    else
    {
        return SPIsPtrOutOfBounds(n_pStart, cBytesTotal, n_pBound);
    }
}

inline BOOL SPIsStringOutOfBounds(const WCHAR* n_pwcszString,
                                  const void* n_pBound = NULL,
                                  const void* n_pLowerBound = NULL)
{
    BOOL br = FALSE;
    
    const WCHAR* pwcszBound = (const WCHAR*)n_pBound;
    const WCHAR* pwcszLowerBound = (const WCHAR*)n_pLowerBound;

    // Pointers must be in the following order: 
    // Lower bound, String, Upper bound
    if ( (pwcszLowerBound && (pwcszLowerBound > n_pwcszString) ) ||
         (pwcszBound && (n_pwcszString >= pwcszBound) ) ||
         SP_IS_BAD_STRING_PTR(n_pwcszString) )
    {
        br = TRUE;
    }
    else if (pwcszBound)
    {
        const size_t cStrMaxLen = pwcszBound - n_pwcszString;
        const size_t cStrActualLen = wcslen(n_pwcszString);

        if (cStrActualLen > cStrMaxLen)
        {
            br = TRUE;
        }
    }
    else
    {
        br = FALSE;
    }

    return br;
}

/************************************************************
* SpSafePtrAdd   *
*----------------*
* Description:
*   Advances the n_ppBase pointer by n_cBytes bytes.
* Returns E_INVALIDARG on pointer wraparound or if
* the pointer exceeds the bound (presuming the bound
* is specified).
******************************************* mishav *********/

template <class _C>
inline HRESULT SpSafePtrAdd (_C** n_ppBase, size_t n_cBytes, const void* n_pBound = NULL)
{
    HRESULT hr = S_OK;

    // Perform the addition
    const BYTE* pByteCast = (const BYTE*)(*n_ppBase);
    const BYTE* pByteAdded = pByteCast + n_cBytes;

    // Check for wrapping
    // Check for a bound having been specified, and make sure it doesn't exceed it.
    if ( (pByteAdded < pByteCast) ||
         (n_pBound!=NULL && pByteAdded>n_pBound) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        *n_ppBase = (_C*)(pByteAdded);    
    }

    return hr;
}

/************************************************************
* SpSafePtrMultiplyAdd   *
*---------------------*
* Description:
*   Advances the n_ppBase pointer by (n_cElements * n_cBytesPerElement) bytes.
* Returns E_INVALIDARG on pointer wraparound or if
* the pointer exceeds the bound (presuming the bound
* is specified).
******************************************* mishav *********/

template <class _C>
inline HRESULT SpSafePtrMultiplyAdd (_C** n_ppBase, 
                                     ULONG n_cElements,
                                     size_t n_cBytesPerElement, 
                                     const void* n_pBound = NULL)
{
    HRESULT hr = S_OK;

    // Perform and check the multiplication
    ULONG cBytesTotal = n_cElements * n_cBytesPerElement;
    if ( ( cBytesTotal / n_cElements ) != n_cBytesPerElement )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = SpSafePtrAdd(n_ppBase, cBytesTotal, n_pBound);
    }

    return hr;
}




#ifdef __ATLCOM_H__     //--- Only enable these if ATL is being used

//
//  Helper functions can be used to implement GetObjectToken/SetObjectToken for objects that 
//  support ISpObjectWithToken
//
inline HRESULT SpGenericSetObjectToken(ISpObjectToken * pCallersToken, CComPtr<ISpObjectToken> & cpObjToken)
{
    HRESULT hr = S_OK;
    if (SP_IS_BAD_INTERFACE_PTR(pCallersToken))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if (cpObjToken)
        {
            hr = SPERR_ALREADY_INITIALIZED;
        }
        else
        {
            cpObjToken = pCallersToken;
        }
    }
    return hr;
}


inline HRESULT SpGenericGetObjectToken(ISpObjectToken ** ppCallersToken, CComPtr<ISpObjectToken> & cpObjToken)
{
    HRESULT hr = S_OK;
    if (SP_IS_BAD_WRITE_PTR(ppCallersToken))
    {
        hr = E_POINTER;
    }
    else
    {
        *ppCallersToken = cpObjToken;
        if (*ppCallersToken)
        {
            (*ppCallersToken)->AddRef();
        }
        else
        {
            hr = S_FALSE;
        }
    }
    return hr;
}

#endif  // __ATLCOM_H__


//
//  Helper class for SPSTATEINFO sturcture automatically initializes and cleans up
//  the structure + provides a few helper functions.
//
class CSpStateInfo : public SPSTATEINFO
{
public:
    CSpStateInfo()
    {
        cAllocatedEntries = NULL;
        pTransitions = NULL;
    }
    ~CSpStateInfo()
    {
        ::CoTaskMemFree(pTransitions);
    }
    SPTRANSITIONENTRY * FirstEpsilon()
    {
        return pTransitions;
    }
    SPTRANSITIONENTRY * FirstRule()
    {
        return pTransitions + cEpsilons;
    }
    SPTRANSITIONENTRY * FirstWord()
    {
        return pTransitions + cEpsilons + cRules;
    }
    SPTRANSITIONENTRY * FirstSpecialTransition()
    {
        return pTransitions + cEpsilons + cRules + cWords;
    }
};


//
//  This basic queue implementation can be used to maintin linked lists of classes.  The class T
//  must contain the member m_pNext which is used by this template to point to the next element.
//  If the bPurgeWhenDeleted is TRUE then all of the elements in the queue will be deleted
//  when the queue is deleted, otherwise they will not.
//  If bMaintainCount is TRUE then a running count will be maintained, and GetCount() will be
//  efficent.  If it is FALSE then a running count will not be maintained, and GetCount() will
//  be an order N operation.  If you do not require a count, then 
//

template <class T, BOOL bPurgeWhenDeleted> class CSpBasicList;

template <class T, BOOL bPurgeWhenDeleted = TRUE, BOOL bMaintainCount = FALSE>
class CSpBasicQueue
{
public:
    T     * m_pHead;
    T     * m_pTail;
    ULONG   m_cElements;    // Warning!  Use GetCount() -- Not maintained if bMaintainCount is FALSE.

    CSpBasicQueue() 
    {
        m_pHead = NULL;
        if (bMaintainCount)
        {
            m_cElements = 0;
        }
    }

    ~CSpBasicQueue()
    {
        if (bPurgeWhenDeleted)
        {
            Purge();
        }
    }

    HRESULT CreateNode(T ** ppNode)
    {
        *ppNode = new T;
        if (*ppNode)
        {
            return S_OK;
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }

    T * GetNext(const T * pNode)
    {
        return pNode->m_pNext;
    }


    T * Item(ULONG i)
    {
        T * pNode = m_pHead;
        while (pNode && i)
        {
            i--;
            pNode = pNode->m_pNext;
        }
        return pNode;
    }

    void InsertAfter(T * pPrev, T * pNewNode)
    {
        if (pPrev)
        {
            pNewNode->m_pNext = pPrev->m_pNext;
            pPrev->m_pNext = pNewNode;
            if (pNewNode->m_pNext == NULL)
            {
                m_pTail = pNewNode;
            }
            if (bMaintainCount) ++m_cElements;
        }
        else
        {
            InsertHead(pNewNode);
        }
    }

    void InsertTail(T * pNode)
    {
        pNode->m_pNext = NULL;
        if (m_pHead)
        {
            m_pTail->m_pNext = pNode;
        }
        else
        {
            m_pHead = pNode;
        }
        m_pTail = pNode;
        if (bMaintainCount) ++m_cElements;
    }

    void InsertHead(T * pNode)
    {
        pNode->m_pNext = m_pHead;
        if (m_pHead == NULL)
        {
            m_pTail = pNode;
        }
        m_pHead = pNode;
        if (bMaintainCount) ++m_cElements;
    }

    T * RemoveHead()
    {
        T * pNode = m_pHead;
        if (pNode)
        {
            m_pHead = pNode->m_pNext;
            if (bMaintainCount) --m_cElements;
        }
        return pNode;
    }

    T * RemoveTail()
    {
        T * pNode = m_pHead;
        if (pNode)
        {
            if (pNode == m_pTail)
            {
                m_pHead = NULL;
            }
            else
            {
                T * pPrev;
                do
                {
                    pPrev = pNode;
                    pNode = pNode->m_pNext;
                } while ( pNode != m_pTail );
                pPrev->m_pNext = NULL;
                m_pTail = pPrev;
            }
            if (bMaintainCount) --m_cElements;
        }
        return pNode;
    }

    void Purge()
    {
        while (m_pHead)
        {
            T * pDie = m_pHead;
            m_pHead = pDie->m_pNext;
            delete pDie;
        }
        if (bMaintainCount) m_cElements = 0;
    }

    void ExplicitPurge()
    {
        T * pDie;
        BYTE * pb;

        while (m_pHead)
        {
            pDie = m_pHead;
            m_pHead = pDie->m_pNext;

            pDie->~T();

            pb = reinterpret_cast<BYTE *>(pDie);
            delete [] pb;
        }
        if (bMaintainCount) m_cElements = 0;
    }


    T * GetTail() const
    {
        if (m_pHead)
        {
            return m_pTail;
        }
        return NULL;
    }

    T * GetHead() const
    {
        return m_pHead;
    }

    BOOL IsEmpty() const
    {
        return m_pHead == NULL; 
    }

    BOOL Remove(T * pNode)
    {
        if (m_pHead == pNode)
        {
            m_pHead = pNode->m_pNext;
            if (bMaintainCount) --m_cElements;
            return TRUE;
        }
        else
        {
            T * pCur = m_pHead;
            while (pCur)
            {
                T * pNext = pCur->m_pNext;
                if (pNext == pNode)
                {
                    if ((pCur->m_pNext = pNode->m_pNext) == NULL)
                    {
                        m_pTail = pCur;
                    }
                    if (bMaintainCount) --m_cElements;
                    return TRUE;
                }
                pCur = pNext;
            }
        }
        return FALSE;
    }

    void MoveAllToHeadOf(CSpBasicQueue & DestQueue)
    {
        if (m_pHead)
        {
            m_pTail->m_pNext = DestQueue.m_pHead;
            if (DestQueue.m_pHead == NULL)
            {
                DestQueue.m_pTail = m_pTail;
            }
            DestQueue.m_pHead = m_pHead;
            m_pHead = NULL;
            if (bMaintainCount)
            {
                DestQueue.m_cElements += m_cElements;
                m_cElements = 0;
            }
        }
    }

    void MoveAllToList(CSpBasicList<T, bPurgeWhenDeleted> & List)
    {
        if (m_pHead)
        {
            m_pTail->m_pNext = List.m_pFirst;
            List.m_pFirst = m_pHead;
            m_pHead = NULL;
        }
        if (bMaintainCount)
        {
            m_cElements = 0;
        }
    }

    BOOL MoveToList(T * pNode, CSpBasicList<T, bPurgeWhenDeleted> & List)
    {
        BOOL bFound = Remove(pNode);
        if (bFound)
        {
            List.AddNode(pNode);
        }
        return bFound;
    }

    ULONG GetCount() const
    {
        if (bMaintainCount)
        {
            return m_cElements;
        }
        else
        {
            ULONG c = 0;
            for (T * pNode = m_pHead;
                 pNode;
                 pNode = pNode->m_pNext, c++) {}
            return c;
        }
    }

    //
    //  The following functions require the class T to implement a static function:
    //
    //      LONG Compare(const T * pElem1, const T * pElem2)
    //
    //  which returns < 0 if pElem1 is less than pElem2, 0 if they are equal, and > 0 if
    //  pElem1 is greater than pElem2.
    //
    void InsertSorted(T * pNode)
    {
        if (m_pHead)
        {
            if (T::Compare(pNode, m_pTail) >= 0)
            {
                pNode->m_pNext = NULL;
                m_pTail->m_pNext = pNode;
                m_pTail = pNode;
            }
            else
            {
                //
                //  We don't have to worry about walking off of the end of the list here since
                //  we have already checked the tail.
                //
                T ** ppNext = &m_pHead;
                while (T::Compare(pNode, *ppNext) >= 0)
                {
                    ppNext = &((*ppNext)->m_pNext);
                }
                pNode->m_pNext = *ppNext;
                *ppNext = pNode;
            }
        }
        else
        {
            pNode->m_pNext = NULL;
            m_pHead = m_pTail = pNode;
        }
        if (bMaintainCount) ++m_cElements;
    }

    HRESULT InsertSortedUnique(T * pNode)
    {
        HRESULT hr = S_OK;
        if (m_pHead)
        {
            if (T::Compare(pNode, m_pTail) > 0)
            {
                pNode->m_pNext = NULL;
                m_pTail->m_pNext = pNode;
                m_pTail = pNode;
            }
            else
            {
                //
                //  We don't have to worry about walking off of the end of the list here since
                //  we have already checked the tail.
                //
                T ** ppNext = &m_pHead;
                while (T::Compare(pNode, *ppNext) > 0)
                {
                    ppNext = &((*ppNext)->m_pNext);
                }
                if (T::Compare(pNode, *ppNext) != 0)
                {
                    pNode->m_pNext = *ppNext;
                    *ppNext = pNode;
                }
                else
                {
                    delete pNode;
                    hr = S_FALSE;
                }
            }
        }
        else
        {
            pNode->m_pNext = NULL;
            m_pHead = m_pTail = pNode;
        }
        if (bMaintainCount) ++m_cElements;
        return hr;
    }

    //
    //  These functions must support the "==" operator for the TFIND type.
    //
    template <class TFIND> 
    T * Find(TFIND & FindVal) const 
    {
        T * pNode = m_pHead;
        for (; pNode && (!(*pNode == FindVal)); pNode = pNode->m_pNext)
        {}
        return pNode;
    }

    template <class TFIND> 
    T * FindNext(const T * pCurNode, TFIND & FindVal) const 
    {
        for (T * pNode = pCurNode->m_pNext; pNode && (!(*pNode == FindVal)); pNode = pNode->m_pNext)
        {}
        return pNode;
    }

    //
    //  Searches for and removes a single list element
    //  
    template <class TFIND> 
    T * FindAndRemove(TFIND & FindVal)
    {
        T * pNode = m_pHead;
        if (pNode)
        {
            if (*pNode == FindVal)
            {
                m_pHead = pNode->m_pNext;
                if (bMaintainCount) --m_cElements;
            }
            else
            {
                T * pPrev = pNode;
                for (pNode = pNode->m_pNext;
                     pNode;
                     pPrev = pNode, pNode = pNode->m_pNext)
                {
                    if (*pNode == FindVal)
                    {
                        pPrev->m_pNext = pNode->m_pNext;
                        if (pNode->m_pNext == NULL)
                        {
                            m_pTail = pPrev;
                        }
                        if (bMaintainCount) --m_cElements;
                        break;
                    }
                }
            }
        }
        return pNode;
    }

    //
    //  Searches for and deletes all list elements that match
    //  
    template <class TFIND> 
    void FindAndDeleteAll(TFIND & FindVal)
    {
        T * pNode = m_pHead;
        while (pNode && *pNode == FindVal)
        {
            m_pHead = pNode->m_pNext;
            delete pNode;
            if (bMaintainCount) --m_cElements;
            pNode = m_pHead;
        }
        T * pPrev = pNode;
        while (pNode)
        {
            T * pNext = pNode->m_pNext;
            if (*pNode == FindVal)
            {
                pPrev->m_pNext = pNext;
                delete pNode;
                if (bMaintainCount) --m_cElements;
            }
            else
            {
                pPrev = pNode;
            }
            pNode = pNext;
        }
        m_pTail = pPrev;    // Just always set it in case we removed the tail.
    }


};

template <class T, BOOL bPurgeWhenDeleted = TRUE>
class CSpBasicList
{
public:
    T * m_pFirst;
    CSpBasicList() : m_pFirst(NULL) {}
    ~CSpBasicList()
    {
        if (bPurgeWhenDeleted)
        {
            Purge();
        }
    }

    void Purge()
    {
        while (m_pFirst)
        {
            T * pNext = m_pFirst->m_pNext;
            delete m_pFirst;
            m_pFirst = pNext;
        }
    }

    void ExplicitPurge()
    {
        T * pDie;
        BYTE * pb;

        while (m_pFirst)
        {
            pDie = m_pFirst;
            m_pFirst = pDie->m_pNext;

            pDie->~T();

            pb = reinterpret_cast<BYTE *>(pDie);
            delete [] pb;
        }
    }

    HRESULT RemoveFirstOrAllocateNew(T ** ppNode)
    {
        if (m_pFirst)
        {
            *ppNode = m_pFirst;
            m_pFirst = m_pFirst->m_pNext;
        }
        else
        {
            *ppNode = new T;
            if (*ppNode == NULL)
            {
                return E_OUTOFMEMORY;
            }
        }
        return S_OK;
    }

    void AddNode(T * pNode)
    {
        pNode->m_pNext = m_pFirst;
        m_pFirst = pNode;
    }
    T * GetFirst()
    {
        return m_pFirst;
    }
    T * RemoveFirst()
    {
        T * pNode = m_pFirst;
        if (pNode)
        {
            m_pFirst = pNode->m_pNext;
        }
        return pNode;
    }
};

#define STACK_ALLOC(TYPE, COUNT) (TYPE *)_alloca(sizeof(TYPE) * (COUNT))
#define STACK_ALLOC_AND_ZERO(TYPE, COUNT) (TYPE *)memset(_alloca(sizeof(TYPE) * (COUNT)), 0, (sizeof(TYPE) * (COUNT)))
#define STACK_ALLOC_AND_COPY(TYPE, COUNT, SOURCE) (TYPE *)memcpy(_alloca(sizeof(TYPE) * (COUNT)), (SOURCE), (sizeof(TYPE) * (COUNT)))

inline HRESULT SpGetSubTokenFromToken(
    ISpObjectToken * pToken,
    const WCHAR * pszSubKeyName,
    ISpObjectToken ** ppToken,
    BOOL fCreateIfNotExist = FALSE)
{

    HRESULT hr = S_OK;

    if (SP_IS_BAD_INTERFACE_PTR(pToken) ||
        SP_IS_BAD_STRING_PTR(pszSubKeyName) ||
        SP_IS_BAD_WRITE_PTR(ppToken))
    {
        hr = E_POINTER;
    }

    // First, either create or open the datakey for the new token
    CComPtr<ISpDataKey> cpDataKeyForNewToken;
    if (SUCCEEDED(hr))
    {
        if (fCreateIfNotExist)
        {
            hr = pToken->CreateKey(pszSubKeyName, &cpDataKeyForNewToken);
        }
        else
        {
            hr = pToken->OpenKey(pszSubKeyName, &cpDataKeyForNewToken);
        }
    }

    // The sub token's category will be the token id of it's parent token
    CSpDynamicString dstrCategoryId;
    if (SUCCEEDED(hr))
    {
        hr = pToken->GetId(&dstrCategoryId);
    }

    // The sub token's token id will be it's category id + "\\" the key name
    CSpDynamicString dstrTokenId;
    if (SUCCEEDED(hr))
    {
        dstrTokenId = dstrCategoryId;
        dstrTokenId.Append2(L"\\", pszSubKeyName);
    }

    // Now create the token and initalize it
    CComPtr<ISpObjectTokenInit> cpTokenInit;
    if (SUCCEEDED(hr))
    {
        hr = cpTokenInit.CoCreateInstance(CLSID_SpObjectToken);
    }

    if (SUCCEEDED(hr))
    {
        hr = cpTokenInit->InitFromDataKey(dstrCategoryId, dstrTokenId, cpDataKeyForNewToken);
    }

    if (SUCCEEDED(hr))
    {
        *ppToken = cpTokenInit.Detach();
    }

    return hr;
}

template<class T>
HRESULT SpCreateObjectFromSubToken(ISpObjectToken * pToken, const WCHAR * pszSubKeyName, T ** ppObject,
                       IUnknown * pUnkOuter = NULL, DWORD dwClsCtxt = CLSCTX_ALL)
{

    HRESULT hr;

    CComPtr<ISpObjectToken> cpSubToken;
    hr = SpGetSubTokenFromToken(pToken, pszSubKeyName, &cpSubToken);
    
    if (SUCCEEDED(hr))
    {
        hr = SpCreateObjectFromToken(cpSubToken, ppObject, pUnkOuter, dwClsCtxt);
    }

    return hr;
}


__inline HRESULT GetObjectToken(const WCHAR* pszTokenCat, 
                       const WCHAR* pszTokenName, 
                       CComPtr<ISpObjectToken> &cpToken)
{
    cpToken = NULL;

    CComPtr<IEnumSpObjectTokens> cpEnum;
    ISpObjectToken* pToken      = NULL;

    if (SUCCEEDED(SpEnumTokens(pszTokenCat, NULL, NULL, &cpEnum)))
    {
        while (cpEnum->Next(1, &pToken, NULL) == S_OK)
        {
            CSpDynamicString dstrDesc;
            if (SUCCEEDED(SpGetDescription(pToken, &dstrDesc)))
            {
                if (! wcscmp(dstrDesc.m_psz, pszTokenName))
                {
                    cpToken = pToken;
                    goto Exit;
                }
            }

            if (pToken)
            {
                pToken->Release();
                pToken = NULL;
            }
        }
    }

Exit:
    if (pToken)
    {
        pToken->Release();
    }

    if (cpToken == NULL)
    {
        return E_FAIL;
    }

    return S_OK;
}

// Return a token enumerator containing all tokens that match the primary language
// of a particular language id. pszRequiredAttributes can be used to specify additional attributes all tokens must have.
inline HRESULT SpEnumTokensMatchingPrimaryLangID(const LPCWSTR pszCategoryId, LANGID priLangID, LPCWSTR pszRequiredAtts,
                                                 IEnumSpObjectTokens **ppEnum)
{
    HRESULT hr = S_OK;

    // First enumerate the tokens using pszRequiredAtts.
    CComPtr<ISpObjectTokenCategory> cpCategory;
    hr = SpGetCategoryFromId(pszCategoryId, &cpCategory);
    
    CComPtr<IEnumSpObjectTokens> cpEnum;
    if (SUCCEEDED(hr))
    {
        hr = cpCategory->EnumTokens(pszRequiredAtts, NULL, &cpEnum);
    }

    ULONG ulTokens;
    if (SUCCEEDED(hr))
    {
        hr = cpEnum->GetCount(&ulTokens);
    }

    // Create enumerator to store new tokens.
    CComPtr<ISpObjectTokenEnumBuilder> cpBuilder;
    if (SUCCEEDED(hr))
    {
        hr = cpBuilder.CoCreateInstance(CLSID_SpObjectTokenEnum);
    }
    if (SUCCEEDED(hr))
    {
        hr = cpBuilder->SetAttribs(NULL, NULL);
    }

    // Now, for each token, check language string to see if it matches.
    for (ULONG ul = 0; SUCCEEDED(hr) && ul < ulTokens; ul++)
    {
        LANGID tokenLangID;
        CComPtr<ISpObjectToken> cpToken;
        hr = cpEnum->Item(ul, &cpToken);
        if (SUCCEEDED(hr))
        {
            // Just look at the first language id
            hr = SpGetLanguageFromToken(cpToken, &tokenLangID);
        }

        if (SUCCEEDED(hr) && PRIMARYLANGID(tokenLangID) == PRIMARYLANGID(priLangID))
        {
            // Add to builder
            hr = cpBuilder->AddTokens(1, &(cpToken.p));
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = cpBuilder->Reset();
    }
    if (SUCCEEDED(hr))
    {
        *ppEnum = cpBuilder.Detach();
    }

    return hr;
}




#endif /* This must be the last line in the file */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\Smx.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**          Copyright(c) Microsoft Corporation 1992 - 1999          **/
/**********************************************************************/

/*
    smx.h
    This file contains the common messages, manifests, types, and
    structures used by Server Manager Extensions.

    NOTE:  You must include windows.h and lmcons.h *before* this file.
*/



#ifndef _SMX_H_
#define _SMX_H_



//
//  This is the maximum length allowed for an extension menu item.
//

#define MENU_TEXT_LEN                   50



//
//  This is the current version number of the extension interface.
//

#define SME_VERSION                     0



//
//  These are the messages sent from the extension to the
//  Server Manager application.
//
//      SM_GETSELCOUNT
//
//              Purpose - Retrieves the number of selected items in
//                        the specified listbox.
//
//              wParam  - Listbox index.  This 0-based index specifies
//                        the listbox to query.  For the Server Manager,
//                        this must always be zero.
//
//              lParam  - Points to an SMS_GETSELCOUNT structure.
//
//              Returns - TRUE  if successful, FALSE if unsuccessful.
//
//
//      SM_GETSERVERSEL[A]
//
//              Purpose - Retrieves a particular selection.
//
//              wParam  - Selection index.  This 0-based index specifies
//                        the selected item to query.  This is useful
//                        for muliple-select listboxes.  Since the Server
//                        manager uses a single-select listbox, this
//                        value must always be zero.
//
//              lParam  - Points to an SMS_GETSERVERSEL[AW] structure.
//
//              Returns - TRUE  if successful, FALSE if unsuccessful.
//
//      SM_GETCURFOCUS[AW]
//
//              Purpose - Retrieves the current application focus.
//
//              wParam  - Must be zero.
//
//              lParam  - Points to a SMS_GETCURFOCUS structure.
//
//              Returns - TRUE if successful, FALSE if unsuccessful.
//
//
//      SM_GETOPTIONS
//
//              Purpose - Retrieves the current option settings
//
//              wParam  - Must be zero.
//
//              lParam  - Points to a SMS_GETOPTIONS structure.
//
//              Returns - TRUE if successful, FALSE if unsuccessful.
//

#define SM_GETSELCOUNT                  (WM_USER + 1000)
#define SM_GETSERVERSELA                (WM_USER + 1001)
#define SM_GETSERVERSELW                (WM_USER + 1002)
#define SM_GETCURFOCUSA                 (WM_USER + 1003)
#define SM_GETCURFOCUSW                 (WM_USER + 1004)
#define SM_GETOPTIONS                   (WM_USER + 1005)

#ifdef UNICODE
#define SM_GETSERVERSEL                 SM_GETSERVERSELW
#define SM_GETCURFOCUS                  SM_GETCURFOCUSW
#else   // !UNICODE
#define SM_GETSERVERSEL                 SM_GETSERVERSELA
#define SM_GETCURFOCUS                  SM_GETCURFOCUSA
#endif  // UNICODE



//
//  These structures are used when the extension is
//  communicating with the application.
//


//
//  The SMS_LOADMENU[AW] structure is passed to the extension's
//  SMELoadMenu[AW] entrypoint when the extension is loaded.
//
//      dwVersion       - On entry to SMELoadMenu[AW], this will
//                        contain the maximum extension version
//                        supported by the Server Manager.  If the
//                        extension supports a lower version, it
//                        should set this field appropriately before
//                        returning.  The Server Manager will use
//                        the returned value to determine the
//                        capabilities of the extension.
//
//      szMenuName      - The name of the menu item that is to appear
//                        in the app's main menu.  This value will also
//                        appear in the "Help On Extensions" submene and
//                        the "View" menu.
//
//      hMenu           - A valid HMENU for the popup-menu to be inserted
//                        into the app's main menu.  Ownership of this
//                        handle transfers to the Server Manager.  The
//                        extension should *not* destroy this handle.
//
//      szHelpFileName  - The name of the help file associated with this
//                        extension.  This file will be used for the
//                        "Help On Extensions" menu.  This will also be
//                        used when the user presses [F1] while the
//                        extension's menu is dropped.
//
//      dwServerType    - A bitmask containing the appropriate server type
//                        bit associated with the extension.  It is
//                        assumed that each extension will be associated
//                        with a unique server type.  For example,
//                        SV_TYPE_WFW represents Windows for Workgroups
//                        servers.
//
//      dwMenuDelta     - The Server Manager will apply this delta
//                        to each menu ID present in hMenu.  This is
//                        to prevent conflicts with other extension's
//                        menu IDs.
//

typedef struct _SMS_LOADMENUA
{
    DWORD       dwVersion;
    CHAR        szMenuName[MENU_TEXT_LEN + 1];
    HMENU       hMenu;
    CHAR        szHelpFileName[MAX_PATH];
    DWORD       dwServerType;
    DWORD       dwMenuDelta;

} SMS_LOADMENUA, * PSMS_LOADMENUA;

typedef struct _SMS_LOADMENUW
{
    DWORD       dwVersion;
    WCHAR       szMenuName[MENU_TEXT_LEN + 1];
    HMENU       hMenu;
    WCHAR       szHelpFileName[MAX_PATH];
    DWORD       dwServerType;
    DWORD       dwMenuDelta;

} SMS_LOADMENUW, * PSMS_LOADMENUW;

#ifdef UNICODE
#define SMS_LOADMENU                    SMS_LOADMENUW
#define PSMS_LOADMENU                   PSMS_LOADMENUW
#else   // !UNICODE
#define SMS_LOADMENU                    SMS_LOADMENUA
#define PSMS_LOADMENU                   PSMS_LOADMENUA
#endif  // UNICODE


//
//  The SMS_GETSERVERSEL[AW] structure is filled in by the
//  Server Manager when it handles SM_GETSERVERSEL[AW] messages.
//  This is used to return the current selection to the extension.
//
//      szServerName    - Will receive the UNC name of the selected
//                        server.
//
//      dwServerType    - Will receive the server type mask associated
//                        with the server.  This field may be 0 if
//                        the type is unknown.
//

typedef struct _SMS_GETSERVERSELA
{
    CHAR        szServerName[MAX_PATH];
    DWORD       dwServerType;

} SMS_GETSERVERSELA, * PSMS_GETSERVERSELA;

typedef struct _SMS_GETSERVERSELW
{
    WCHAR       szServerName[MAX_PATH];
    DWORD       dwServerType;

} SMS_GETSERVERSELW, * PSMS_GETSERVERSELW;

#ifdef UNICODE
#define SMS_GETSERVERSEL                SMS_GETSERVERSELW
#define PSMS_GETSERVERSEL               PSMS_GETSERVERSELW
#else   // !UNICODE
#define SMS_GETSERVERSEL                SMS_GETSERVERSELA
#define PSMS_GETSERVERSEL               PSMS_GETSERVERSELA
#endif  // UNICODE


//
//  The SMS_GETSELCOUNT structure is filled in by the Server Manager
//  when it handles the SM_GETSELCOUNT message.  This is used to
//  return the number of selected items to the extension.  In the
//  current implementation, this will be either 0 (empty listbox)
//  or 1 (single selection).
//
//      dwItems         - The number of selected items in the listbox.
//

typedef struct _SMS_GETSELCOUNT
{
    DWORD       dwItems;
} SMS_GETSELCOUNT, * PSMS_GETSELCOUNT;


//
//  The SMS_GETCURFOCUS[AW] structure is filled in by the Server Manager
//  when it handles the SM_GETCURFOCUS message.  This is used to
//  return the current focus of the User Manager application.
//
//      szFocus         - The domain name or server name of the current
//                        focus.  Server names can be distinguished
//                        by the leading backslashes, or by dwFocusType.
//
//      dwFocusType     - This is the type of focus, either
//                        SM_FOCUS_TYPE_NT_DOMAIN
//                        SM_FOCUS_TYPE_LM_DOMAIN
//                        SM_FOCUS_TYPE_UNKNOWN_DOMAIN
//                        SM_FOCUS_TYPE_NT_SERVER
//                        SM_FOCUS_TYPE_LM_SERVER
//                        SM_FOCUS_TYPE_WFW_SERVER
//                        SM_FOCUS_TYPE_UNKNOWN_SERVER
//

#define SM_FOCUS_TYPE_NT_DOMAIN         1
#define SM_FOCUS_TYPE_LM_DOMAIN         2
#define SM_FOCUS_TYPE_UNKNOWN_DOMAIN    3
#define SM_FOCUS_TYPE_NT_SERVER         4
#define SM_FOCUS_TYPE_LM_SERVER         5
#define SM_FOCUS_TYPE_WFW_SERVER        6
#define SM_FOCUS_TYPE_UNKNOWN_SERVER    7

typedef struct _SMS_GETCURFOCUSA
{
    CHAR        szFocus[MAX_PATH];
    DWORD       dwFocusType;

} SMS_GETCURFOCUSA, * PSMS_GETCURFOCUSA;

typedef struct _SMS_GETCURFOCUSW
{
    WCHAR       szFocus[MAX_PATH];
    DWORD       dwFocusType;

} SMS_GETCURFOCUSW, * PSMS_GETCURFOCUSW;

#ifdef UNICODE
#define SMS_GETCURFOCUS             SMS_GETCURFOCUSW
#define PSMS_GETCURFOCUS            PSMS_GETCURFOCUSW
#else   // UNICODE
#define SMS_GETCURFOCUS             SMS_GETCURFOCUSA
#define PSMS_GETCURFOCUS            PSMS_GETCURFOCUSA
#endif  // UNICODE


//
//  The SMS_GETOPTIONS structure is filled in by the Server Manager
//  when it handles the SM_GETOPTIONS message.  This is used to
//  return the current option settings of the Server Manager
//  application.
//
//      fSaveSettingsOnExit     - Should Server Manager settings be saved
//                                on exit?
//
//      fConfirmation           - Should permanent and/or dangerous
//                                actions be confirmed?  In the current
//                                Server Manager implementation, this
//                                will always be TRUE.
//

typedef struct _SMS_GETOPTIONS
{
    BOOL        fSaveSettingsOnExit;
    BOOL        fConfirmation;

} SMS_GETOPTIONS, * PSMS_GETOPTIONS;


//
//  The SMS_VALIDATE[AW] structure is passed between the Server Manager
//  application and the extension to validate a particular "alien"
//  (non-LANMan) server.
//
//      pszServer       - The (UNC) name of the server to validate.  This
//                        is filled in by the Server Manager.
//
//      pszType         - The type string to display in the Server Manager's
//                        main window.  This is filled in by the extension.
//
//      pszComment      - The comment to display in the Server Manager's
//                        main window.  This is filled in by the extension.
//

typedef struct _SMS_VALIDATEA
{
    const CHAR * pszServer;
    CHAR       * pszType;
    CHAR       * pszComment;

} SMS_VALIDATEA, * PSMS_VALIDATEA;

typedef struct _SMS_VALIDATEW
{
    const WCHAR * pszServer;
    WCHAR       * pszType;
    WCHAR       * pszComment;

} SMS_VALIDATEW, * PSMS_VALIDATEW;

#ifdef UNICODE
#define SMS_VALIDATE                SMS_VALIDATEW
#define PSMS_VALIDATE               PSMS_VALIDATEW
#else   // UNICODE
#define SMS_VALIDATE                SMS_VALIDATEA
#define PSMS_VALIDATE               PSMS_VALIDATEA
#endif  // UNICODE



//
//  These are the names of the extension entrypoints.
//

#define SZ_SME_UNLOADMENU               "SMEUnloadMenu"
#define SZ_SME_INITIALIZEMENU           "SMEInitializeMenu"
#define SZ_SME_REFRESH                  "SMERefresh"
#define SZ_SME_MENUACTION               "SMEMenuAction"

#define SZ_SME_LOADMENUW                "SMELoadMenuW"
#define SZ_SME_GETEXTENDEDERRORSTRINGW  "SMEGetExtendedErrorStringW"
#define SZ_SME_VALIDATEW                "SMEValidateW"

#define SZ_SME_LOADMENUA                "SMELoadMenuA"
#define SZ_SME_GETEXTENDEDERRORSTRINGA  "SMEGetExtendedErrorStringA"
#define SZ_SME_VALIDATEA                "SMEValidateA"

#ifdef UNICODE
#define SZ_SME_LOADMENU                 SZ_SME_LOADMENUW
#define SZ_SME_GETEXTENDEDERRORSTRING   SZ_SME_GETEXTENDEDERRORSTRINGW
#define SZ_SME_VALIDATE                 SZ_SME_VALIDATEW
#else   // !UNICODE
#define SZ_SME_LOADMENU                 SZ_SME_LOADMENUA
#define SZ_SME_GETEXTENDEDERRORSTRING   SZ_SME_GETEXTENDEDERRORSTRINGA
#define SZ_SME_VALIDATE                 SZ_SME_VALIDATEA
#endif  // UNICODE



//
//  Typedefs for the extension entrypoints.
//

typedef DWORD (PASCAL * PSMX_LOADMENU)( HWND          hWnd,
                                        PSMS_LOADMENU psmsload );

typedef LPTSTR (PASCAL * PSMX_GETEXTENDEDERRORSTRING)( VOID );

typedef VOID (PASCAL * PSMX_UNLOADMENU)( VOID );

typedef VOID (PASCAL * PSMX_INITIALIZEMENU)( VOID );

typedef VOID (PASCAL * PSMX_REFRESH)( HWND hwndParent );

typedef VOID (PASCAL * PSMX_MENUACTION)( HWND hwndParent, DWORD dwEventId );

typedef BOOL (PASCAL * PSMX_VALIDATE)( PSMS_VALIDATE psmsvalidate );



//
//  Prototypes for the extension entrypoints.
//

DWORD PASCAL SMELoadMenuA( HWND           hWnd,
                           PSMS_LOADMENUA psmsload );

DWORD PASCAL SMELoadMenuW( HWND           hWnd,
                           PSMS_LOADMENUW psmsload );

LPSTR  PASCAL SMEGetExtendedErrorStringA( VOID );

LPWSTR PASCAL SMEGetExtendedErrorStringW( VOID );

VOID PASCAL SMEUnloadMenu( VOID );

VOID PASCAL SMEInitializeMenu( VOID );

VOID PASCAL SMERefresh( HWND hwndParent );

VOID PASCAL SMEMenuAction( HWND hwndParent, DWORD dwEventId );

BOOL PASCAL SMEValidateA( PSMS_VALIDATEA psmsValidate );

BOOL PASCAL SMEValidateW( PSMS_VALIDATEW psmsValidate );



#endif  // _SMX_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\SpOrder.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    sporder.h

Abstract:

    This header prototypes the 32-Bit Windows functions that are used
    to change the order or WinSock2 transport service providers and
    name space providers.

Revision History:

--*/

#ifndef __SPORDER_H__
#define __SPORDER_H__

#if _MSC_VER > 1000
#pragma once
#endif


#ifdef __cplusplus
extern "C" {
#endif

int
WSPAPI
WSCWriteProviderOrder (
    IN LPDWORD lpwdCatalogEntryId,
    IN DWORD dwNumberOfEntries
    );

typedef
int
(WSPAPI * LPWSCWRITEPROVIDERORDER)(
    IN LPDWORD lpwdCatalogEntryId,
    IN DWORD dwNumberOfEntries
    );

#if(_WIN32_WINNT >= 0x0501)
#ifdef _WIN64
int
WSPAPI
WSCWriteProviderOrder32 (
    IN LPDWORD lpwdCatalogEntryId,
    IN DWORD dwNumberOfEntries
    );
#endif //_WIN64
#endif //_WIN32_WINNT >= 0x0501

int
WSPAPI
WSCWriteNameSpaceOrder (
    IN LPGUID lpProviderId,
    IN DWORD dwNumberOfEntries
    );

typedef 
int
(WSPAPI * LPWSCWRITENAMESPACEORDER)(
    IN LPGUID lpProviderId,
    IN DWORD dwNumberOfEntries
    );

#if(_WIN32_WINNT >= 0x0501)
#ifdef _WIN64
int
WSPAPI
WSCWriteNameSpaceOrder32 (
    IN LPGUID lpProviderId,
    IN DWORD dwNumberOfEntries
    );
#endif //_WIN64
#endif //_WIN32_WINNT >= 0x0501

#ifdef __cplusplus
}
#endif

#endif      // __SPORDER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\spuihelp.h ===
/*******************************************************************************
// Copyright Microsoft Corporation. All Rights Reserved. 
* SPUIHelp.h *
*------------*
*   Description:
*       This is the header file for user-interface helper functions.  Note that
*       unlike SpHelper.H, this file requires the use of ATL.
*-------------------------------------------------------------------------------
*******************************************************************************/

#ifndef SPUIHelp_h
#define SPUIHelp_h

#ifndef __sapi_h__
#include <sapi.h>
#endif

#ifndef SPError_h
#include <SPError.h>
#endif

#ifndef SPHelper_h
#include <SPHelper.h>
#endif

#ifndef __ATLBASE_H__
#include <ATLBASE.h>
#endif

#ifndef __ATLCONV_H__
#include <ATLCONV.H>
#endif

/****************************************************************************
* 
*
*
*****************************************************************************/

//
//  Dont call this function directly.  Use SpInitTokenComboBox or SpInitTokenListBox.
//
inline HRESULT SpInitTokenList(UINT MsgAddString, UINT MsgSetItemData, UINT MsgSetCurSel,
                               HWND hwnd, const WCHAR * pszCatName,
                               const WCHAR * pszRequiredAttrib, const WCHAR * pszOptionalAttrib)
{
    HRESULT hr;
    ISpObjectToken * pToken;        // NOTE:  Not a CComPtr!  Be Careful.
    CComPtr<IEnumSpObjectTokens> cpEnum;
    hr = SpEnumTokens(pszCatName, pszRequiredAttrib, pszOptionalAttrib, &cpEnum);
    if (hr == S_OK)
    {
        bool fSetDefault = false;
        while (cpEnum->Next(1, &pToken, NULL) == S_OK)
        {
            CSpDynamicString dstrDesc;
            hr = SpGetDescription(pToken, &dstrDesc);
            if (SUCCEEDED(hr))
            {
                LRESULT i = ::SendMessageW(hwnd, MsgAddString, 0, (LPARAM)dstrDesc.m_psz);
                if (i == CB_ERR || i == CB_ERRSPACE)    // Note:  CB_ and LB_ errors are identical values...
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    ::SendMessageW(hwnd, MsgSetItemData, i, (LPARAM)pToken);
                    if (!fSetDefault)
                    {
                        ::SendMessageW(hwnd, MsgSetCurSel, i, 0);
                        fSetDefault = true;
                    }
                }
            }
            if (FAILED(hr))
            {
                pToken->Release();
            }
        }
    }
    else
    {
        hr = SPERR_NO_MORE_ITEMS;
    }
    return hr;
}

inline HRESULT SpInitTokenComboBox(HWND hwnd, const WCHAR * pszCatName,
                                   const WCHAR * pszRequiredAttrib = NULL, const WCHAR * pszOptionalAttrib = NULL)
{
    return SpInitTokenList(CB_ADDSTRING, CB_SETITEMDATA, CB_SETCURSEL, hwnd, pszCatName, pszRequiredAttrib, pszOptionalAttrib);
}

inline HRESULT SpInitTokenListBox(HWND hwnd, const WCHAR * pszCatName,
                                   const WCHAR * pszRequiredAttrib = NULL, const WCHAR * pszOptionalAttrib = NULL)
{
    return SpInitTokenList(LB_ADDSTRING, LB_SETITEMDATA, LB_SETCURSEL, hwnd, pszCatName, pszRequiredAttrib, pszOptionalAttrib);
}

//
//  Dont call this function directly.  Use SpDestoyTokenComboBox or SpDestroyTokenListBox.
//
inline void SpDestroyTokenList(UINT MsgGetCount, UINT MsgGetItemData, HWND hwnd)
{
    LRESULT c = ::SendMessageW(hwnd, MsgGetCount, 0, 0);
    for (LRESULT i = 0; i < c; i++)
    {
        IUnknown * pUnkObj = (IUnknown *)::SendMessageW(hwnd, MsgGetItemData, i, 0);
        if (pUnkObj)
        {
            pUnkObj->Release();
        }
    }
}

inline void SpDestroyTokenComboBox(HWND hwnd)
{
    SpDestroyTokenList(CB_GETCOUNT, CB_GETITEMDATA, hwnd);
}

inline void SpDestroyTokenListBox(HWND hwnd)
{
    SpDestroyTokenList(LB_GETCOUNT, LB_GETITEMDATA, hwnd);
}


inline ISpObjectToken * SpGetComboBoxToken(HWND hwnd, WPARAM Index)
{
    return (ISpObjectToken *)::SendMessageW(hwnd, CB_GETITEMDATA, Index, 0);
}

inline ISpObjectToken * SpGetListBoxToken(HWND hwnd, WPARAM Index)
{
    return (ISpObjectToken *)::SendMessageW(hwnd, LB_GETITEMDATA, Index, 0);
}

inline ISpObjectToken * SpGetCurSelComboBoxToken(HWND hwnd)
{
    LRESULT i = ::SendMessageW(hwnd, CB_GETCURSEL, 0, 0);
    return (i == CB_ERR) ? NULL : SpGetComboBoxToken(hwnd, i);
}

inline ISpObjectToken * SpGetCurSelListBoxToken(HWND hwnd)
{
    LRESULT i = ::SendMessageW(hwnd, LB_GETCURSEL, 0, 0);
    return (i == LB_ERR) ? NULL : SpGetListBoxToken(hwnd, i);
}

//
//  Don't call this directly.  Use SpUpdateCurSelComboBoxToken or SpUpdateCurSelListBoxToken
//
inline HRESULT SpUpdateCurSelToken(UINT MsgDelString, UINT MsgInsertString, UINT MsgGetItemData, UINT MsgSetItemData, UINT MsgGetCurSel, UINT MsgSetCurSel,
                                   HWND hwnd)
{
    HRESULT hr = S_OK;
    LRESULT i = ::SendMessageW(hwnd, MsgGetCurSel, 0, 0);
    if (i != CB_ERR)
    {
        ISpObjectToken * pToken = (ISpObjectToken *)::SendMessageW(hwnd, MsgGetItemData, i, 0);
        CSpDynamicString dstrDesc;
        hr = SpGetDescription(pToken, &dstrDesc);
        if (SUCCEEDED(hr))
        {
            ::SendMessageW(hwnd, MsgDelString, i, 0);
            ::SendMessageW(hwnd, MsgInsertString, i, (LPARAM)dstrDesc.m_psz);
            ::SendMessageW(hwnd, MsgSetItemData, i, (LPARAM)pToken);
            ::SendMessageW(hwnd, MsgSetCurSel, i, 0);
        }
    }
    return hr;
}

inline HRESULT SpUpdateCurSelComboBoxToken(HWND hwnd)
{
    return SpUpdateCurSelToken(CB_DELETESTRING, CB_INSERTSTRING, CB_GETITEMDATA, CB_SETITEMDATA, CB_GETCURSEL, CB_SETCURSEL, hwnd);
}

inline HRESULT SpUpdateCurSelListBoxToken(HWND hwnd)
{
    return SpUpdateCurSelToken(LB_DELETESTRING, LB_INSERTSTRING, LB_GETITEMDATA, LB_SETITEMDATA, LB_GETCURSEL, LB_SETCURSEL, hwnd);
}

inline HRESULT SpAddTokenToList(UINT MsgAddString, UINT MsgSetItemData, UINT MsgSetCurSel, HWND hwnd, ISpObjectToken * pToken)
{
    CSpDynamicString dstrDesc;
    HRESULT hr = SpGetDescription(pToken, &dstrDesc);
    if (SUCCEEDED(hr))
    {
        LRESULT i = ::SendMessageW(hwnd, MsgAddString, 0, (LPARAM)dstrDesc.m_psz);
        if (i == CB_ERR || i == CB_ERRSPACE)    // Note:  CB_ and LB_ errors are identical values...
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            ::SendMessageW(hwnd, MsgSetItemData, i, (LPARAM)pToken);
            ::SendMessageW(hwnd, MsgSetCurSel, i, 0);
            pToken->AddRef();
        }
    }
    return hr;
}

inline HRESULT SpAddTokenToComboBox(HWND hwnd, ISpObjectToken * pToken)
{
    return SpAddTokenToList(CB_ADDSTRING, CB_SETITEMDATA, CB_SETCURSEL, hwnd, pToken);
}

inline HRESULT SpAddTokenToListBox(HWND hwnd, ISpObjectToken * pToken)
{
    return SpAddTokenToList(LB_ADDSTRING, LB_SETITEMDATA, LB_SETCURSEL, hwnd, pToken);
}


inline HRESULT SpDeleteCurSelToken(UINT MsgGetCurSel, UINT MsgSetCurSel, UINT MsgGetItemData, UINT MsgDeleteString, HWND hwnd)
{
    HRESULT hr = S_OK;
    LRESULT i = ::SendMessageW(hwnd, MsgGetCurSel, 0, 0);
    if (i == CB_ERR)
    {
        hr = S_FALSE;
    }
    else
    {
        ISpObjectToken * pToken = (ISpObjectToken *)::SendMessageW(hwnd, MsgGetItemData, i, 0);
        if (pToken)
        {
            pToken->Release();
        }
        ::SendMessageW(hwnd, MsgDeleteString, i, 0);
        ::SendMessageW(hwnd, MsgSetCurSel, i, 0);
    }
    return hr;
}

inline HRESULT SpDeleteCurSelComboBoxToken(HWND hwnd)
{
    return SpDeleteCurSelToken(CB_GETCURSEL, CB_SETCURSEL, CB_GETITEMDATA, CB_DELETESTRING, hwnd);
}

inline HRESULT SpDeleteCurSelListBoxToken(HWND hwnd)
{
    return SpDeleteCurSelToken(LB_GETCURSEL, CB_SETCURSEL, LB_GETITEMDATA, LB_DELETESTRING, hwnd);
}

#endif /* #ifndef SPUIHelp_h -- This must be the last line in the file */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\specstrings_undef.h ===
#if defined(_MSC_EXTENSIONS) || defined(_PREFAST_) || defined(OACR)
#undef __$adt_add_prop
#undef __$adt_prop
#undef __$adt_remove_prop
#undef __$adt_transfer_prop
#undef __$adt_type_props
#undef __$nonvolatile
#undef __$possibly_notnulltermiated
#undef __$volatile
#endif
#undef __allocator
#undef __analysis_assert
#undef __analysis_assume
#undef __analysis_hint
#undef __assume_ValidCompNameA
#undef __assume_ValidCompNameW
#undef __assume_bound
#undef __assume_validated
#undef __bcount
#undef __bcount_opt
#undef __blocksOn
#undef __bound
#undef __byte_readableTo
#undef __byte_writableTo
#undef __callback
#undef __checkReturn
#undef __class_code_content
#undef __control_entrypoint
#undef __data_entrypoint
#undef __deref
#undef __deref_bcount
#undef __deref_bcount_opt
#undef __deref_ecount
#undef __deref_ecount_opt
#undef __deref_in
#undef __deref_in_bcount
#undef __deref_in_bcount_opt
#undef __deref_in_ecount
#undef __deref_in_ecount_opt
#undef __deref_in_opt
#undef __deref_in_range
#undef __deref_in_xcount
#undef __deref_in_xcount_opt
#undef __deref_inout
#undef __deref_inout_bcount
#undef __deref_inout_bcount_full
#undef __deref_inout_bcount_full_opt
#undef __deref_inout_bcount_nz
#undef __deref_inout_bcount_nz_opt
#undef __deref_inout_bcount_opt
#undef __deref_inout_bcount_part
#undef __deref_inout_bcount_part_opt
#undef __deref_inout_bcount_z
#undef __deref_inout_bcount_z_opt
#undef __deref_inout_ecount
#undef __deref_inout_ecount_full
#undef __deref_inout_ecount_full_opt
#undef __deref_inout_ecount_nz
#undef __deref_inout_ecount_nz_opt
#undef __deref_inout_ecount_opt
#undef __deref_inout_ecount_part
#undef __deref_inout_ecount_part_opt
#undef __deref_inout_ecount_z
#undef __deref_inout_ecount_z_opt
#undef __deref_inout_nz
#undef __deref_inout_nz_opt
#undef __deref_inout_opt
#undef __deref_inout_xcount
#undef __deref_inout_xcount_full
#undef __deref_inout_xcount_full_opt
#undef __deref_inout_xcount_opt
#undef __deref_inout_xcount_part
#undef __deref_inout_xcount_part_opt
#undef __deref_inout_z
#undef __deref_inout_z_opt
#undef __deref_nonvolatile
#undef __deref_opt_bcount
#undef __deref_opt_bcount_opt
#undef __deref_opt_ecount
#undef __deref_opt_ecount_opt
#undef __deref_opt_in
#undef __deref_opt_in_bcount
#undef __deref_opt_in_bcount_opt
#undef __deref_opt_in_ecount
#undef __deref_opt_in_ecount_opt
#undef __deref_opt_in_opt
#undef __deref_opt_in_xcount
#undef __deref_opt_in_xcount_opt
#undef __deref_opt_inout
#undef __deref_opt_inout_bcount
#undef __deref_opt_inout_bcount_full
#undef __deref_opt_inout_bcount_full_opt
#undef __deref_opt_inout_bcount_nz
#undef __deref_opt_inout_bcount_nz_opt
#undef __deref_opt_inout_bcount_opt
#undef __deref_opt_inout_bcount_part
#undef __deref_opt_inout_bcount_part_opt
#undef __deref_opt_inout_bcount_z
#undef __deref_opt_inout_bcount_z_opt
#undef __deref_opt_inout_ecount
#undef __deref_opt_inout_ecount_full
#undef __deref_opt_inout_ecount_full_opt
#undef __deref_opt_inout_ecount_nz
#undef __deref_opt_inout_ecount_nz_opt
#undef __deref_opt_inout_ecount_opt
#undef __deref_opt_inout_ecount_part
#undef __deref_opt_inout_ecount_part_opt
#undef __deref_opt_inout_ecount_z
#undef __deref_opt_inout_ecount_z_opt
#undef __deref_opt_inout_nz
#undef __deref_opt_inout_nz_opt
#undef __deref_opt_inout_opt
#undef __deref_opt_inout_xcount
#undef __deref_opt_inout_xcount_full
#undef __deref_opt_inout_xcount_full_opt
#undef __deref_opt_inout_xcount_opt
#undef __deref_opt_inout_xcount_part
#undef __deref_opt_inout_xcount_part_opt
#undef __deref_opt_inout_z
#undef __deref_opt_inout_z_opt
#undef __deref_opt_out
#undef __deref_opt_out_bcount
#undef __deref_opt_out_bcount_full
#undef __deref_opt_out_bcount_full_opt
#undef __deref_opt_out_bcount_nz_opt
#undef __deref_opt_out_bcount_opt
#undef __deref_opt_out_bcount_part
#undef __deref_opt_out_bcount_part_opt
#undef __deref_opt_out_bcount_z_opt
#undef __deref_opt_out_ecount
#undef __deref_opt_out_ecount_full
#undef __deref_opt_out_ecount_full_opt
#undef __deref_opt_out_ecount_nz_opt
#undef __deref_opt_out_ecount_opt
#undef __deref_opt_out_ecount_part
#undef __deref_opt_out_ecount_part_opt
#undef __deref_opt_out_ecount_z_opt
#undef __deref_opt_out_nz_opt
#undef __deref_opt_out_opt
#undef __deref_opt_out_xcount
#undef __deref_opt_out_xcount_full
#undef __deref_opt_out_xcount_full_opt
#undef __deref_opt_out_xcount_opt
#undef __deref_opt_out_xcount_part
#undef __deref_opt_out_xcount_part_opt
#undef __deref_opt_out_z_opt
#undef __deref_opt_xcount
#undef __deref_opt_xcount_opt
#undef __deref_out
#undef __deref_out_bcount
#undef __deref_out_bcount_full
#undef __deref_out_bcount_full_opt
#undef __deref_out_bcount_nz
#undef __deref_out_bcount_nz_opt
#undef __deref_out_bcount_opt
#undef __deref_out_bcount_part
#undef __deref_out_bcount_part_opt
#undef __deref_out_bcount_z
#undef __deref_out_bcount_z_opt
#undef __deref_out_bound
#undef __deref_out_ecount
#undef __deref_out_ecount_full
#undef __deref_out_ecount_full_opt
#undef __deref_out_ecount_nz
#undef __deref_out_ecount_nz_opt
#undef __deref_out_ecount_opt
#undef __deref_out_ecount_part
#undef __deref_out_ecount_part_opt
#undef __deref_out_ecount_z
#undef __deref_out_ecount_z_opt
#undef __deref_out_nz
#undef __deref_out_nz_opt
#undef __deref_out_opt
#undef __deref_out_range
#undef __deref_out_range
#undef __deref_out_xcount
#undef __deref_out_xcount
#undef __deref_out_xcount_full
#undef __deref_out_xcount_full_opt
#undef __deref_out_xcount_opt
#undef __deref_out_xcount_part
#undef __deref_out_xcount_part_opt
#undef __deref_out_z
#undef __deref_out_z_opt
#undef __deref_volatile
#undef __deref_xcount
#undef __deref_xcount_opt
#undef __ecount
#undef __ecount_opt
#undef __elem_readableTo
#undef __elem_writableTo
#undef __encoded_array
#undef __encoded_pointer
#undef __exceptthat
#undef __fallthrough
#undef __field_bcount
#undef __field_bcount_full
#undef __field_bcount_full_opt
#undef __field_bcount_opt
#undef __field_bcount_part
#undef __field_bcount_part_opt
#undef __field_data_source
#undef __field_ecount
#undef __field_ecount_full
#undef __field_ecount_full_opt
#undef __field_ecount_opt
#undef __field_ecount_part
#undef __field_ecount_part_opt
#undef __field_encoded_array
#undef __field_encoded_pointer
#undef __field_range
#undef __field_xcount
#undef __field_xcount_full
#undef __field_xcount_full_opt
#undef __field_xcount_opt
#undef __field_xcount_part
#undef __field_xcount_part_opt
#undef __file_parser
#undef __file_parser_class
#undef __file_parser_library
#undef __format_string
#undef __format_string
#undef __gdi_entry
#undef __in
#undef __in_awcount
#undef __in_bcount
#undef __in_bcount_nz
#undef __in_bcount_nz_opt
#undef __in_bcount_opt
#undef __in_bcount_z
#undef __in_bcount_z_opt
#undef __in_bound
#undef __in_data_source
#undef __in_ecount
#undef __in_ecount_nz
#undef __in_ecount_nz_opt
#undef __in_ecount_opt
#undef __in_ecount_z
#undef __in_ecount_z_opt
#undef __in_nz
#undef __in_nz_opt
#undef __in_opt
#undef __in_range
#undef __in_xcount
#undef __in_xcount_opt
#undef __in_z
#undef __in_z_opt
#undef __inexpressible_readableTo
#undef __inexpressible_writableTo
#undef __inner_assume_bound
#undef __inner_assume_bound_dec
#undef __inner_assume_validated
#undef __inner_assume_validated_dec
#undef __inner_blocksOn
#undef __inner_bound
#undef __inner_callback
#undef __inner_checkReturn
#undef __inner_control_entrypoint
#undef __inner_data_entrypoint
#undef __inner_data_source
#undef __inner_encoded
#undef __inner_fallthrough
#undef __inner_fallthrough_dec
#undef __inner_out_validated
#undef __inner_override
#undef __inner_range
#undef __inner_success
#undef __inner_transfer
#undef __inner_typefix
#undef __inout
#undef __inout_bcount
#undef __inout_bcount_full
#undef __inout_bcount_full_opt
#undef __inout_bcount_nz
#undef __inout_bcount_nz_opt
#undef __inout_bcount_opt
#undef __inout_bcount_part
#undef __inout_bcount_part_opt
#undef __inout_bcount_z
#undef __inout_bcount_z_opt
#undef __inout_ecount
#undef __inout_ecount_full
#undef __inout_ecount_full_opt
#undef __inout_ecount_nz
#undef __inout_ecount_nz_opt
#undef __inout_ecount_opt
#undef __inout_ecount_part
#undef __inout_ecount_part_opt
#undef __inout_ecount_z
#undef __inout_ecount_z_opt
#undef __inout_ecount_z_opt
#undef __inout_nz
#undef __inout_nz_opt
#undef __inout_opt
#undef __inout_xcount
#undef __inout_xcount_full
#undef __inout_xcount_full_opt
#undef __inout_xcount_opt
#undef __inout_xcount_part
#undef __inout_xcount_part_opt
#undef __inout_z
#undef __inout_z_opt
#undef __kernel_entry
#undef __maybenull
#undef __maybereadonly
#undef __maybevalid
#undef __nonvolatile
#undef __notnull
#undef __notreadonly
#undef __notvalid
#undef __null
#undef __nullnullterminated
#undef __nullterminated
#undef __out
#undef __out_awcount
#undef __out_bcount
#undef __out_bcount_full
#undef __out_bcount_full_opt
#undef __out_bcount_nz
#undef __out_bcount_nz_opt
#undef __out_bcount_opt
#undef __out_bcount_part
#undef __out_bcount_part_opt
#undef __out_bcount_z
#undef __out_bcount_z_opt
#undef __out_bound
#undef __out_data_source
#undef __out_ecount
#undef __out_ecount_full
#undef __out_ecount_full_opt
#undef __out_ecount_nz
#undef __out_ecount_nz_opt
#undef __out_ecount_opt
#undef __out_ecount_part
#undef __out_ecount_part_opt
#undef __out_ecount_z
#undef __out_ecount_z_opt
#undef __out_has_adt_prop
#undef __out_has_type_adt_props
#undef __out_not_has_adt_prop
#undef __out_nz
#undef __out_nz_opt
#undef __out_opt
#undef __out_range
#undef __out_transfer_adt_prop
#undef __out_validated
#undef __out_xcount
#undef __out_xcount_full
#undef __out_xcount_full_opt
#undef __out_xcount_opt
#undef __out_xcount_part
#undef __out_xcount_part_opt
#undef __out_z
#undef __override
#undef __possibly_notnulltermiated
#undef __post
#undef __postcond
#undef __pre
#undef __precond
#undef __range
#undef __readableTo
#undef __readonly
#undef __refparam
#undef __reserved
#undef __rpc_entry
#undef __source_code_content
#undef __struct_bcount
#undef __struct_xcount
#undef __success
#undef __this_out_data_source
#undef __this_out_validated
#undef __transfer
#undef __type_has_adt_prop
#undef __typefix
#undef __valid
#undef __volatile
#undef __writableTo
#undef __xcount
#undef __xcount_opt
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\sperror.h ===
/*******************************************************************************
// Copyright Microsoft Corporation. All Rights Reserved. 
* SPError.h *
*-----------*
*   Description:
*       This header file contains the custom error codes specific to SAPI5
*-------------------------------------------------------------------------------
*******************************************************************************/
#ifndef SPError_h
#define SPError_h

#ifndef _WINERROR_
#include <winerror.h>
#endif

#define FACILITY_SAPI      FACILITY_ITF
#define SAPI_ERROR_BASE    0x5000

#define MAKE_SAPI_HRESULT(sev, err)    MAKE_HRESULT(sev, FACILITY_SAPI, err)
#define MAKE_SAPI_ERROR(err)           MAKE_SAPI_HRESULT(SEVERITY_ERROR, err + SAPI_ERROR_BASE)
#define MAKE_SAPI_SCODE(scode)         MAKE_SAPI_HRESULT(SEVERITY_SUCCESS, scode + SAPI_ERROR_BASE)

/*** SPERR_UNINITIALIZED                                   0x80045001    -2147201023
*   The object has not been properly initialized.
*/
#define SPERR_UNINITIALIZED                                MAKE_SAPI_ERROR(0x001)

/*** SPERR_ALREADY_INITIALIZED                             0x80045002    -2147201022
*   The object has already been initialized.
*/
#define SPERR_ALREADY_INITIALIZED                          MAKE_SAPI_ERROR(0x002)

/*** SPERR_UNSUPPORTED_FORMAT                              0x80045003    -2147201021
*   The caller has specified an unsupported format.
*/
#define SPERR_UNSUPPORTED_FORMAT                           MAKE_SAPI_ERROR(0x003)

/*** SPERR_INVALID_FLAGS                                   0x80045004    -2147201020
*   The caller has specified invalid flags for this operation.
*/
#define SPERR_INVALID_FLAGS                                MAKE_SAPI_ERROR(0x004)

/*** SP_END_OF_STREAM                                      0x00045005    282629
*   The operation has reached the end of stream.
*/
#define SP_END_OF_STREAM                                   MAKE_SAPI_SCODE(0x005)

/*** SPERR_DEVICE_BUSY                                     0x80045006    -2147201018
*   The wave device is busy.
*/
#define SPERR_DEVICE_BUSY                                  MAKE_SAPI_ERROR(0x006)

/*** SPERR_DEVICE_NOT_SUPPORTED                            0x80045007    -2147201017
*   The wave device is not supported.
*/
#define SPERR_DEVICE_NOT_SUPPORTED                         MAKE_SAPI_ERROR(0x007)

/*** SPERR_DEVICE_NOT_ENABLED                              0x80045008    -2147201016
*   The wave device is not enabled.
*/
#define SPERR_DEVICE_NOT_ENABLED                           MAKE_SAPI_ERROR(0x008)

/*** SPERR_NO_DRIVER                                       0x80045009    -2147201015
*   There is no wave driver installed.
*/
#define SPERR_NO_DRIVER                                    MAKE_SAPI_ERROR(0x009)

/*** SPERR_FILEMUSTBEUNICODE                               0x8004500a    -2147201014
*   The file must be Unicode.
*/
#define SPERR_FILE_MUST_BE_UNICODE                         MAKE_SAPI_ERROR(0x00a)

/*** SP_INSUFFICIENTDATA                                   0x0004500b    282635
*
*/
#define SP_INSUFFICIENT_DATA                               MAKE_SAPI_SCODE(0x00b)

/*** SPERR_INVALID_PHRASE_ID                               0x8004500c    -2147201012
*   The phrase ID specified does not exist or is out of range.
*/
#define SPERR_INVALID_PHRASE_ID                            MAKE_SAPI_ERROR(0x00c)

/*** SPERR_BUFFER_TOO_SMALL                                0x8004500d    -2147201011
*   The caller provided a buffer too small to return a result.
*/
#define SPERR_BUFFER_TOO_SMALL                             MAKE_SAPI_ERROR(0x00d)

/*** SPERR_FORMAT_NOT_SPECIFIED                            0x8004500e    -2147201010
*   Caller did not specify a format prior to opening a stream.
*/
#define SPERR_FORMAT_NOT_SPECIFIED                         MAKE_SAPI_ERROR(0x00e)

/*** SPERR_AUDIO_STOPPED                                   0x8004500f    -2147201009
*   This method is deprecated. Use SP_AUDIO_STOPPED instead.
*/
#define SPERR_AUDIO_STOPPED                                MAKE_SAPI_ERROR(0x00f)

/*** SP_AUDIO_PAUSED                                       0x00045010    282640
*   This will be returned only on input (read) streams when the stream is paused.  Reads on
*   paused streams will not block, and this return code indicates that all of the data has been
*   removed from the stream.
*/
#define SP_AUDIO_PAUSED                                    MAKE_SAPI_SCODE(0x010)

/*** SPERR_RULE_NOT_FOUND                                  0x80045011    -2147201007
*   Invalid rule name passed to ActivateGrammar.
*/
#define SPERR_RULE_NOT_FOUND                               MAKE_SAPI_ERROR(0x011)

/*** SPERR_TTS_ENGINE_EXCEPTION                            0x80045012    -2147201006
*   An exception was raised during a call to the current TTS driver.
*/
#define SPERR_TTS_ENGINE_EXCEPTION                         MAKE_SAPI_ERROR(0x012)

/*** SPERR_TTS_NLP_EXCEPTION                               0x80045013    -2147201005
*   An exception was raised during a call to an application sentence filter.
*/
#define SPERR_TTS_NLP_EXCEPTION                            MAKE_SAPI_ERROR(0x013)

/*** SPERR_ENGINE_BUSY                                     0x80045014    -2147201004
*   In speech recognition, the current method can not be performed while
*   a grammar rule is active.
*/
#define SPERR_ENGINE_BUSY                                  MAKE_SAPI_ERROR(0x014)

/*** SP_AUDIO_CONVERSION_ENABLED                           0x00045015    282645
*   The operation was successful, but only with automatic stream format conversion.
*/
#define SP_AUDIO_CONVERSION_ENABLED                        MAKE_SAPI_SCODE(0x015)

/*** SP_NO_HYPOTHESIS_AVAILABLE                            0x00045016    282646
*   There is currently no hypothesis recognition available.
*/
#define SP_NO_HYPOTHESIS_AVAILABLE                         MAKE_SAPI_SCODE(0x016)

/*** SPERR_CANT_CREATE                                     0x80045017    -2147201001
*   Can not create a new object instance for the specified object category.
*/
#define SPERR_CANT_CREATE                                  MAKE_SAPI_ERROR(0x017)

/*** SP_ALREADY_IN_LEX                                     0x00045018    282648
*   The word, pronunciation, or POS pair being added is already in lexicon.
*/
#define SP_ALREADY_IN_LEX                                  MAKE_SAPI_SCODE(0x018)

/*** SPERR_NOT_IN_LEX                                      0x80045019    -2147200999
*   The word does not exist in the lexicon.
*/
#define SPERR_NOT_IN_LEX                                   MAKE_SAPI_ERROR(0x019)

/*** SP_LEX_NOTHING_TO_SYNC                                0x0004501a    282650
*   The client is currently synced with the lexicon.
*/
#define SP_LEX_NOTHING_TO_SYNC                             MAKE_SAPI_SCODE(0x01a)

/*** SPERR_LEX_VERY_OUT_OF_SYNC                            0x8004501b    -2147200997
*   The client is excessively out of sync with the lexicon. Mismatches may not be incrementally sync'd.
*/
#define SPERR_LEX_VERY_OUT_OF_SYNC                         MAKE_SAPI_ERROR(0x01b)

/*** SPERR_UNDEFINED_FORWARD_RULE_REF                      0x8004501c    -2147200996
*   A rule reference in a grammar was made to a named rule that was never defined.
*/
#define SPERR_UNDEFINED_FORWARD_RULE_REF                   MAKE_SAPI_ERROR(0x01c)

/*** SPERR_EMPTY_RULE                                      0x8004501d    -2147200995
*   A non-dynamic grammar rule that has no body.
*/
#define SPERR_EMPTY_RULE                                   MAKE_SAPI_ERROR(0x01d)

/*** SPERR_GRAMMAR_COMPILER_INTERNAL_ERROR                 0x8004501e    -2147200994
*   The grammar compiler failed due to an internal state error.
*/
#define SPERR_GRAMMAR_COMPILER_INTERNAL_ERROR              MAKE_SAPI_ERROR(0x01e)

/*** SPERR_RULE_NOT_DYNAMIC                                0x8004501f    -2147200993
*   An attempt was made to modify a non-dynamic rule.
*/
#define SPERR_RULE_NOT_DYNAMIC                             MAKE_SAPI_ERROR(0x01f)

/*** SPERR_DUPLICATE_RULE_NAME                             0x80045020    -2147200992
*   A rule name was duplicated.
*/
#define SPERR_DUPLICATE_RULE_NAME                          MAKE_SAPI_ERROR(0x020)

/*** SPERR_DUPLICATE_RESOURCE_NAME                         0x80045021    -2147200991
*   A resource name was duplicated for a given rule.
*/
#define SPERR_DUPLICATE_RESOURCE_NAME                      MAKE_SAPI_ERROR(0x021)

/*** SPERR_TOO_MANY_GRAMMARS                               0x80045022    -2147200990
*   Too many grammars have been loaded.
*/
#define SPERR_TOO_MANY_GRAMMARS                            MAKE_SAPI_ERROR(0x022)

/*** SPERR_CIRCULAR_REFERENCE                              0x80045023    -2147200989
*   Circular reference in import rules of grammars.
*/
#define SPERR_CIRCULAR_REFERENCE                           MAKE_SAPI_ERROR(0x023)

/*** SPERR_INVALID_IMPORT                                  0x80045024    -2147200988
*   A rule reference to an imported grammar that could not be resolved.
*/
#define SPERR_INVALID_IMPORT                               MAKE_SAPI_ERROR(0x024)

/*** SPERR_INVALID_WAV_FILE                                0x80045025    -2147200987
*   The format of the WAV file is not supported.
*/
#define SPERR_INVALID_WAV_FILE                             MAKE_SAPI_ERROR(0x025)

/*** SP_REQUEST_PENDING                                    0x00045026    282662
*   This success code indicates that an SR method called with the SPRIF_ASYNC flag is
*   being processed.  When it has finished processing, an SPFEI_ASYNC_COMPLETED event will be generated.
*/
#define SP_REQUEST_PENDING                                 MAKE_SAPI_SCODE(0x026)

/*** SPERR_ALL_WORDS_OPTIONAL                              0x80045027    -2147200985
*   A grammar rule was defined with a null path through the rule.  That is, it is possible
*   to satisfy the rule conditions with no words.
*/
#define SPERR_ALL_WORDS_OPTIONAL                           MAKE_SAPI_ERROR(0x027)

/*** SPERR_INSTANCE_CHANGE_INVALID                         0x80045028    -2147200984
*   It is not possible to change the current engine or input.  This occurs in the
*   following cases:
*
*       1) SelectEngine called while a recognition context exists, or
*       2) SetInput called in the shared instance case.
*/
#define SPERR_INSTANCE_CHANGE_INVALID                      MAKE_SAPI_ERROR(0x028)

/*** SPERR_RULE_NAME_ID_CONFLICT                          0x80045029    -2147200983
*   A rule exists with matching IDs (names) but different names (IDs).  
*/
#define SPERR_RULE_NAME_ID_CONFLICT                        MAKE_SAPI_ERROR(0x029)

/*** SPERR_NO_RULES                                       0x8004502a    -2147200982
*   A grammar contains no top-level, dynamic, or exported rules.  There is no possible
*   way to activate or otherwise use any rule in this grammar.
*/
#define SPERR_NO_RULES                                     MAKE_SAPI_ERROR(0x02a)

/*** SPERR_CIRCULAR_RULE_REF                              0x8004502b    -2147200981
*   Rule 'A' refers to a second rule 'B' which, in turn, refers to rule 'A'. 
*/
#define SPERR_CIRCULAR_RULE_REF                            MAKE_SAPI_ERROR(0x02b)

/*** SP_NO_PARSE_FOUND                                    0x0004502c    282668
*   Parse path cannot be parsed given the currently active rules.
*/
#define SP_NO_PARSE_FOUND                                  MAKE_SAPI_SCODE(0x02c)

/*** SPERR_NO_PARSE_FOUND                                 0x8004502d    -2147200979
*   Parse path cannot be parsed given the currently active rules.
*/
#define SPERR_INVALID_HANDLE                               MAKE_SAPI_ERROR(0x02d)

/*** SPERR_REMOTE_CALL_TIMED_OUT                          0x8004502e    -2147200978
*   A marshaled remote call failed to respond.
*/
#define SPERR_REMOTE_CALL_TIMED_OUT                        MAKE_SAPI_ERROR(0x02e)

/*** SPERR_AUDIO_BUFFER_OVERFLOW                           0x8004502f    -2147200977
*   This will only be returned on input (read) streams when the stream is paused because
*   the SR driver has not retrieved data recently.
*/
#define SPERR_AUDIO_BUFFER_OVERFLOW                        MAKE_SAPI_ERROR(0x02f)

/*** SPERR_NO_AUDIO_DATA                                   0x80045030    -2147200976
*   The result does not contain any audio, nor does the portion of the element chain of the result
*   contain any audio.
*/
#define SPERR_NO_AUDIO_DATA                                MAKE_SAPI_ERROR(0x030)

/*** SPERR_DEAD_ALTERNATE                                  0x80045031    -2147200975
*   This alternate is no longer a valid alternate to the result it was obtained from.
*   Returned from ISpPhraseAlt methods.
*/
#define SPERR_DEAD_ALTERNATE                               MAKE_SAPI_ERROR(0x031)

/*** SPERR_HIGH_LOW_CONFIDENCE                             0x80045032    -2147200974
*   The result does not contain any audio, nor does the portion of the element chain of the result
*   contain any audio.  Returned from ISpResult::GetAudio and ISpResult::SpeakAudio.
*/
#define SPERR_HIGH_LOW_CONFIDENCE                          MAKE_SAPI_ERROR(0x032)

/*** SPERR_INVALID_FORMAT_STRING                           0x80045033    -2147200973
*   The XML format string for this RULEREF is invalid, e.g. not a GUID or REFCLSID.
*/
#define SPERR_INVALID_FORMAT_STRING                        MAKE_SAPI_ERROR(0x033)

/*** SP_UNSUPPORTED_ON_STREAM_INPUT                        0x00045034    282676
*   The operation is not supported for stream input.
*/
#define SP_UNSUPPORTED_ON_STREAM_INPUT                     MAKE_SAPI_SCODE(0x034)

/*** SPERR_APPLEX_READ_ONLY                                0x80045035    -2147200971
*   The operation is invalid for all but newly created application lexicons.
*/
#define SPERR_APPLEX_READ_ONLY                             MAKE_SAPI_ERROR(0x035)

/*** SPERR_NO_TERMINATING_RULE_PATH                        0x80045036    -2147200970
*
*/

#define SPERR_NO_TERMINATING_RULE_PATH                     MAKE_SAPI_ERROR(0x036)

/*** SP_WORD_EXISTS_WITHOUT_PRONUNCIATION                  0x00045037    282679
*   The word exists but without pronunciation.
*/
#define SP_WORD_EXISTS_WITHOUT_PRONUNCIATION               MAKE_SAPI_SCODE(0x037)

/*** SPERR_STREAM_CLOSED                                   0x80045038    -2147200968
*   An operation was attempted on a stream object that has been closed.
*/
#define SPERR_STREAM_CLOSED                                MAKE_SAPI_ERROR(0x038)

// --- The following error codes are taken directly from WIN32  ---

/*** SPERR_NO_MORE_ITEMS                                   0x80045039    -2147200967
*   When enumerating items, the requested index is greater than the count of items.
*/
#define SPERR_NO_MORE_ITEMS                                MAKE_SAPI_ERROR(0x039)

/*** SPERR_NOT_FOUND                                       0x8004503a    -2147200966
*   The requested data item (data key, value, etc.) was not found.
*/
#define SPERR_NOT_FOUND                                    MAKE_SAPI_ERROR(0x03a)

/*** SPERR_INVALID_AUDIO_STATE                             0x8004503b    -2147200965
*   Audio state passed to SetState() is invalid.
*/
#define SPERR_INVALID_AUDIO_STATE                          MAKE_SAPI_ERROR(0x03b)

/*** SPERR_GENERIC_MMSYS_ERROR                             0x8004503c    -2147200964
*   A generic MMSYS error not caught by _MMRESULT_TO_HRESULT.
*/
#define SPERR_GENERIC_MMSYS_ERROR                          MAKE_SAPI_ERROR(0x03c)

/*** SPERR_MARSHALER_EXCEPTION                             0x8004503d    -2147200963
*   An exception was raised during a call to the marshaling code.
*/
#define SPERR_MARSHALER_EXCEPTION                          MAKE_SAPI_ERROR(0x03d)

/*** SPERR_NOT_DYNAMIC_GRAMMAR                             0x8004503e    -2147200962
*   Attempt was made to manipulate a non-dynamic grammar.
*/
#define SPERR_NOT_DYNAMIC_GRAMMAR                          MAKE_SAPI_ERROR(0x03e)

/*** SPERR_AMBIGUOUS_PROPERTY                              0x8004503f    -2147200961
*   Cannot add ambiguous property.
*/
#define SPERR_AMBIGUOUS_PROPERTY                           MAKE_SAPI_ERROR(0x03f)

/*** SPERR_INVALID_REGISTRY_KEY                            0x80045040    -2147200960
*   The key specified is invalid.
*/
#define SPERR_INVALID_REGISTRY_KEY                         MAKE_SAPI_ERROR(0x040)

/*** SPERR_INVALID_TOKEN_ID                                0x80045041    -2147200959
*   The token specified is invalid.
*/
#define SPERR_INVALID_TOKEN_ID                             MAKE_SAPI_ERROR(0x041)

/*** SPERR_XML_BAD_SYNTAX                                  0x80045042    -2147200958
*   The xml parser failed due to bad syntax.
*/
#define SPERR_XML_BAD_SYNTAX                               MAKE_SAPI_ERROR(0x042)

/*** SPERR_XML_RESOURCE_NOT_FOUND                          0x80045043    -2147200957
*   The xml parser failed to load a required resource (e.g., voice, phoneconverter, etc.).
*/
#define SPERR_XML_RESOURCE_NOT_FOUND                       MAKE_SAPI_ERROR(0x043)

/*** SPERR_TOKEN_IN_USE                                    0x80045044    -2147200956
*   Attempted to remove registry data from a token that is already in use elsewhere.
*/
#define SPERR_TOKEN_IN_USE                                 MAKE_SAPI_ERROR(0x044)

/*** SPERR_TOKEN_DELETED                                   0x80045045    -2147200955
*   Attempted to perform an action on an object token that has had associated registry key deleted.
*/
#define SPERR_TOKEN_DELETED                                MAKE_SAPI_ERROR(0x045)

/*** SPERR_MULTI_LINGUAL_NOT_SUPPORTED                     0x80045046    -2147200954
*   The selected voice was registered as multi-lingual. SAPI does not support multi-lingual registration. 
*/
#define SPERR_MULTI_LINGUAL_NOT_SUPPORTED                  MAKE_SAPI_ERROR(0x046)

/*** SPERR_EXPORT_DYNAMIC_RULE                             0x80045047    -2147200953
*   Exported rules cannot refer directly or indirectly to a dynamic rule.
*/
#define SPERR_EXPORT_DYNAMIC_RULE                          MAKE_SAPI_ERROR(0x047)

/*** SPERR_STGF_ERROR                                      0x80045048    -2147200952
*   Error parsing the SAPI Text Grammar Format (XML grammar).
*/
#define SPERR_STGF_ERROR                                   MAKE_SAPI_ERROR(0x048)

/*** SPERR_WORDFORMAT_ERROR                                0x80045049    -2147200951
*   Incorrect word format, probably due to incorrect pronunciation string.
*/
#define SPERR_WORDFORMAT_ERROR                             MAKE_SAPI_ERROR(0x049)

/*** SPERR_STREAM_NOT_ACTIVE                               0x8004504a    -2147200950
*   Methods associated with active audio stream cannot be called unless stream is active.
*/
#define SPERR_STREAM_NOT_ACTIVE                            MAKE_SAPI_ERROR(0x04a)

/*** SPERR_ENGINE_RESPONSE_INVALID                         0x8004504b    -2147200949
*   Arguments or data supplied by the engine are in an invalid format or are inconsistent.
*/
#define SPERR_ENGINE_RESPONSE_INVALID                      MAKE_SAPI_ERROR(0x04b)

/*** SPERR_SR_ENGINE_EXCEPTION                             0x8004504c    -2147200948
*   An exception was raised during a call to the current SR engine.
*/
#define SPERR_SR_ENGINE_EXCEPTION                          MAKE_SAPI_ERROR(0x04c)

/*** SPERR_STREAM_POS_INVALID                              0x8004504d    -2147200947
*   Stream position information supplied from engine is inconsistent.
*/
#define SPERR_STREAM_POS_INVALID                           MAKE_SAPI_ERROR(0x04d)

/*** SP_RECOGNIZER_INACTIVE                                0x0004504e    282702
*   Operation could not be completed because the recognizer is inactive. It is inactive either
*   because the recognition state is currently inactive or because no rules are active .
*/
#define SP_RECOGNIZER_INACTIVE                             MAKE_SAPI_SCODE(0x04e)

/*** SPERR_REMOTE_CALL_ON_WRONG_THREAD                     0x8004504f    -2147200945
*   When making a remote call to the server, the call was made on the wrong thread.
*/
#define SPERR_REMOTE_CALL_ON_WRONG_THREAD                  MAKE_SAPI_ERROR(0x04f)

/*** SPERR_REMOTE_PROCESS_TERMINATED                       0x80045050    -2147200944
*   The remote process terminated unexpectedly.
*/
#define SPERR_REMOTE_PROCESS_TERMINATED                    MAKE_SAPI_ERROR(0x050)

/*** SPERR_REMOTE_PROCESS_ALREADY_RUNNING                  0x80045051    -2147200943
*   The remote process is already running; it cannot be started a second time.
*/
#define SPERR_REMOTE_PROCESS_ALREADY_RUNNING               MAKE_SAPI_ERROR(0x051)

/*** SPERR_LANGID_MISMATCH                                 0x80045052    -2147200942
*   An attempt to load a CFG grammar with a LANGID different than other loaded grammars.
*/
#define SPERR_LANGID_MISMATCH                              MAKE_SAPI_ERROR(0x052)

/*** SP_PARTIAL_PARSE_FOUND                               0x00045053    282707
*   A grammar-ending parse has been found that does not use all available words.
*/
#define SP_PARTIAL_PARSE_FOUND                             MAKE_SAPI_SCODE(0x053)

/*** SPERR_NOT_TOPLEVEL_RULE                              0x80045054    -2147200940
*   An attempt to deactivate or activate a non-toplevel rule.
*/
#define SPERR_NOT_TOPLEVEL_RULE                            MAKE_SAPI_ERROR(0x054)

/*** SP_NO_RULE_ACTIVE                                    0x00045055    282709
*   An attempt to parse when no rule was active.
*/
#define SP_NO_RULE_ACTIVE                                  MAKE_SAPI_SCODE(0x055)

/*** SPERR_LEX_REQUIRES_COOKIE                            0x80045056    -2147200938
*   An attempt to ask a container lexicon for all words at once.
*/
#define SPERR_LEX_REQUIRES_COOKIE                          MAKE_SAPI_ERROR(0x056)

/*** SP_STREAM_UNINITIALIZED                              0x00045057    282711
*   An attempt to activate a rule/dictation/etc without calling SetInput 
*   first in the inproc case.
*/
#define SP_STREAM_UNINITIALIZED                            MAKE_SAPI_SCODE(0x057)


// Error x058 is not used in SAPI 5.0


/*** SPERR_UNSUPPORTED_LANG                               0x80045059    -2147200935
*   The requested language is not supported.
*/
#define SPERR_UNSUPPORTED_LANG                             MAKE_SAPI_ERROR(0x059)

/*** SPERR_VOICE_PAUSED                                   0x8004505a    -2147200934
*   The operation cannot be performed because the voice is currently paused.
*/
#define SPERR_VOICE_PAUSED                                 MAKE_SAPI_ERROR(0x05a)

/*** SPERR_AUDIO_BUFFER_UNDERFLOW                          0x8004505b    -2147200933
*   This will only be returned on input (read) streams when the real time audio device
*   stops returning data for a long period of time.
*/
#define SPERR_AUDIO_BUFFER_UNDERFLOW                       MAKE_SAPI_ERROR(0x05b)

/*** SPERR_AUDIO_STOPPED_UNEXPECTEDLY                     0x8004505c    -2147200932
*   An audio device stopped returning data from the Read() method even though it was in
*   the run state.  This error is only returned in the END_SR_STREAM event.
*/
#define SPERR_AUDIO_STOPPED_UNEXPECTEDLY                   MAKE_SAPI_ERROR(0x05c)

/*** SPERR_NO_WORD_PRONUNCIATION                           0x8004505d    -2147200931
*   The SR engine is unable to add this word to a grammar. The application may need to supply 
*   an explicit pronunciation for this word.
*/
#define SPERR_NO_WORD_PRONUNCIATION                        MAKE_SAPI_ERROR(0x05d)

/*** SPERR_ALTERNATES_WOULD_BE_INCONSISTENT                0x8004505e    -2147200930
*   An attempt to call ScaleAudio on a recognition result having previously
*   called GetAlternates. Allowing the call to succeed would result in
*   the previously created alternates located in incorrect audio stream positions.
*/
#define SPERR_ALTERNATES_WOULD_BE_INCONSISTENT             MAKE_SAPI_ERROR(0x05e)

/*** SPERR_NOT_SUPPORTED_FOR_SHARED_RECOGNIZER             0x8004505f    -2147200929
*   The method called is not supported for the shared recognizer.
*   For example, ISpRecognizer::GetInputStream().
*/
#define SPERR_NOT_SUPPORTED_FOR_SHARED_RECOGNIZER          MAKE_SAPI_ERROR(0x05f)

/*** SPERR_TIMEOUT                                         0x80045060    -2147200928
*   A task could not complete because the SR engine had timed out.
*/
#define SPERR_TIMEOUT                                      MAKE_SAPI_ERROR(0x060)

/*** SPERR_REENTER_SYNCHRONIZE                             0x80045061    -2147200927
*   A SR engine called synchronize while inside of a synchronize call.
*/
#define SPERR_REENTER_SYNCHRONIZE                          MAKE_SAPI_ERROR(0x061)

/*** SPERR_STATE_WITH_NO_ARCS                              0x80045062    -2147200926
*   The grammar contains a node no arcs.
*/
#define SPERR_STATE_WITH_NO_ARCS                           MAKE_SAPI_ERROR(0x062)

/*** SPERR_NOT_ACTIVE_SESSION                              0x80045063    -2147200925
*   Neither audio output and input is supported for non-active console sessions.
*/
#define SPERR_NOT_ACTIVE_SESSION                           MAKE_SAPI_ERROR(0x063)

/*** SPERR_ALREADY_DELETED                                 0x80045064    -2147200924
*   The object is a stale reference and is invalid to use.
*   For example having a ISpeechGrammarRule object reference and then calling 
*   ISpeechRecoGrammar::Reset() will cause the rule object to be invalidated.
*   Calling any methods after this will result in this error.
*/
#define SPERR_ALREADY_DELETED                              MAKE_SAPI_ERROR(0x064)

/*** SP_AUDIO_STOPPED                                      0x00045065    282725
*   This can be returned from Read or Write calls audio streams when the stream is stopped.
*/
#define SP_AUDIO_STOPPED                                   MAKE_SAPI_SCODE(0x065)

/*** SPERR_RECOXML_GENERATION_FAIL                             0x80045066    -2147200922
*   The Recognition Parse Tree couldn't be genrated.
*   For example, that the rule name begins with a digit.
*   XML parser doesn't allow element name beginning with a digit.
*/
#define SPERR_RECOXML_GENERATION_FAIL                      MAKE_SAPI_ERROR(0x066)

/*** SPERR_SML_GENERATION_FAIL                             0x80045067    -2147200921
*   The SML couldn't be genrated.
*   For example, the transformation xslt template is not well formed.
*/
#define SPERR_SML_GENERATION_FAIL                          MAKE_SAPI_ERROR(0x067)

/*** SPERR_NOT_PROMPT_VOICE                                0x80045068   -2147200920
*   The current voice is not a prompt voice, so the ISpPromptVoice
*   functions don't work.
*/
#define SPERR_NOT_PROMPT_VOICE                             MAKE_SAPI_ERROR(0x068)

/*** SPERR_ROOTRULE_ALREADY_DEFINED                        0x80045069   -2147200919
*   There is already a root rule for this grammar
*   Defining another root rule will fail.
*/
#define SPERR_ROOTRULE_ALREADY_DEFINED                     MAKE_SAPI_ERROR(0x069)

/*** SPERR_SCRIPT_DISALLOWED                               0x80045070   -2147200912
*   Support for embedded script not supported because browser security settings have disabled it
*/
#define SPERR_SCRIPT_DISALLOWED                            MAKE_SAPI_ERROR(0x070)

/*** SPERR_REMOTE_CALL_TIMED_OUT_START                     0x80045071    -2147200911
*   A time out occurred starting the sapi server
*/
#define SPERR_REMOTE_CALL_TIMED_OUT_START                  MAKE_SAPI_ERROR(0x071)

/*** SPERR_REMOTE_CALL_TIMED_OUT_CONNECT                   0x80045072    -2147200910
*   A timeout occurred obtaining the lock for starting or connecting to sapi server 
*/
#define SPERR_REMOTE_CALL_TIMED_OUT_CONNECT                MAKE_SAPI_ERROR(0x072)

/*** SPERR_SECMGR_CHANGE_NOT_ALLOWED                       0x80045073    -2147200909
*   When there is a cfg grammar loaded, we don't allow changing the security manager
*/
#define SPERR_SECMGR_CHANGE_NOT_ALLOWED                    MAKE_SAPI_ERROR(0x073)

/*** SP_COMPLETE_BUT_EXTENDABLE                            0x00045074    282740
*   Parse is valid but could be extendable (internal use only)
*/
#define SP_COMPLETE_BUT_EXTENDABLE                         MAKE_SAPI_SCODE(0x074)

/*** SPERR_FAILED_TO_DELETE_FILE                           0x80045075    -2147200907
*   Tried and failed to delete an existing file.
*/
#define SPERR_FAILED_TO_DELETE_FILE                        MAKE_SAPI_ERROR(0x075)

/*** SPERR_SHARED_ENGINE_DISABLED                          0x80045076    -2147200906
*   The user has chosen to disable speech from running on the machine, or the 
*   system is not set up to run speech {e.g. initial setup and tutorial has not been run}.    
*/
#define SPERR_SHARED_ENGINE_DISABLED                       MAKE_SAPI_ERROR(0x076)

/*** SPERR_RECOGNIZER_NOT_FOUND                            0x80045077    -2147200905
*   No recognizer is installed.    
*/
#define SPERR_RECOGNIZER_NOT_FOUND                         MAKE_SAPI_ERROR(0x077)

/*** SPERR_AUDIO_NOT_FOUND                                 0x80045078    -2147200904
*   No audio device is installed.    
*/
#define SPERR_AUDIO_NOT_FOUND                              MAKE_SAPI_ERROR(0x078)

/*** SPERR_NO_VOWEL                                        0x80045079    -2147200903
*   No Vowel in a word 
*/
#define SPERR_NO_VOWEL                                     MAKE_SAPI_ERROR(0x079)

/*** SPERR_UNSUPPORTED_PHONEME                             0x8004507A    -2147200902
*   Unknown phoneme
*/
#define SPERR_UNSUPPORTED_PHONEME                          MAKE_SAPI_ERROR(0x07A)

/*** SP_NO_RULES_TO_ACTIVATE                               0x0004507B    282747
*   The grammar does not have any root or top-level active rules to activate.
*/
#define SP_NO_RULES_TO_ACTIVATE                            MAKE_SAPI_SCODE(0x07B)

/*** SP_NO_WORD_ENTRY_TABLE                                0x0004507C    282748
*   The engine does not need SAPI word entry handles for this grammar
*/
#define SP_NO_WORDENTRY_NOTIFICATION                       MAKE_SAPI_SCODE(0x07C)


/*** SPERR_WORD_NEEDS_NORMALIZATION                        0x8004507D    -2147200899
*   The word passed to the GetPronunciations interface needs normalizing first
*/
#define SPERR_WORD_NEEDS_NORMALIZATION			           MAKE_SAPI_ERROR(0x07D)

/*** SPERR_CANNOT_NORMALIZE                                0x8004507E    -2147200898
*   The word passed to the normalize interface cannot be normalized
*/
#define SPERR_CANNOT_NORMALIZE				               MAKE_SAPI_ERROR(0x07E)

/*** S_LIMIT_REACHED                     0x8004507F    -2147200897
*   The word being normalized has generated more than the maximum number of allowed normalized results
*   Indicates that returned list is not exhaustive, but contains as many alternatives as the engine is willing to provide.
*/
#define S_LIMIT_REACHED                                    MAKE_SAPI_SCODE(0x07F)

/*** S_NOTSUPPORTED                     0x80045080    -2147200896
*   We currently don't support this combination of function call + input
*/
#define S_NOTSUPPORTED                                    MAKE_SAPI_SCODE(0x080)

/*** SPERR_TOPIC_NOT_ADAPTABLE                            0x80045081    -2147200895
*   This topic is not adaptable
*/
#define SPERR_TOPIC_NOT_ADAPTABLE                         MAKE_SAPI_ERROR(0x081)

/*** SPERR_PHONEME_CONVERSION                            0x80045082    -2147200894
*   Cannot convert the phonemes to the specified phonetic alphabet.
*/
#define SPERR_PHONEME_CONVERSION                         MAKE_SAPI_ERROR(0x082)

/*** SPERR_NOT_SUPPORTED_FOR_INPROC_RECOGNIZER           0x80045083    -2147200893
*   The method called is not supported for the in-process recognizer.
*   For example: SetTextFeedback
*/
#define SPERR_NOT_SUPPORTED_FOR_INPROC_RECOGNIZER         MAKE_SAPI_ERROR(0x083)

/*** SPERR_OVERLOAD                 0x80045084         -2147200892
*   The operation cannot be carried out due to overload and should be attempted again.
*/
#define SPERR_OVERLOAD                              MAKE_SAPI_ERROR(0x084)

/*** SPERR_LEX_INVALID_DATA         0x80045085         -2147200891
*   The lexicon data is invalid or corrupted.
*/
#define SPERR_LEX_INVALID_DATA                              MAKE_SAPI_ERROR(0x085)

#endif  //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\specstrings_strict.h ===
/************************************************************************* 
*  This file documents all the macros approved for use in windows source
*  code. It includes some experimental macros which should only be used by
*  experts.
*
*  DO NOT include this file directly.  This file is include after
*  specstrings.h. So we can undefine every possible old definition including
*  private internal macros people should not be using, as well as macros from
*  sal.h.  Macros are redefined here in a way to cause syntax errors when used
*  incorrectly during a normal build when specstrings.h is included and
*  __SPECSTRINGS_STRICT_LEVEL is defined.
*
*  There are several levels of strictness, each level includes the behavior of
*  all previous levels.
*
*  0 - Disable strict checking 
*  1 - Break on unapproved macros and misuse of statement 
*      macros such as __fallthrough (default)
*  2 - Deprecated some old macros that should not be used
*  3 - Use VS 2005 Source Annotation to make sure every macro 
*      is used in the right context. For example placing __in on a return 
*      parameter will result in an error.
************************************************************************/
#ifndef __SPECSTRINGS_STRICT_LEVEL
#define __SPECSTRINGS_STRICT_LEVEL 1
#endif
/************************************************************************
*  Introduction
*
*  specstrings.h provides a set of annotations to describe how a function uses
*  its parameters - the assumptions it makes about them, and the guarantees it
*  makes upon finishing.
* 
*  Annotations must be placed before a function parameter's type or its return
*  type. There are two basic classes of common annotations buffer annotations
*  and advanced annotations.  Buffer annotations describe how functions use
*  their pointer parameters, and advanced annotations either describe
*  complex/unusual buffer behavior, or provide additional information about a
*  parameter that is not otherwise expressible.
* 
*  Buffer Annotations
* 
*  The most important annotations in SpecStrings.h provide a consistent way to
*  annotate buffer parameters or return values for a function. Each of these
*  annotations describes a single buffer (which could be a string, a
*  fixed-length or variable-length array, or just a pointer) that the function
*  interacts with: where it is, how large it is, how much is initialized, and
*  what the function does with it.
* 
*  The appropriate macro for a given buffer can be constructed using the table
*  below.  Just pick the appropriate values from each category, and combine
*  them together with a leading underscore. Some combinations of values do not
*  make sense as buffer annotations. Only meaningful annotations can be added
*  to your code; for a list of these, see the buffer annotation definitions
*  section.
* 
*  Only a single buffer annotation should be used for each parameter.
* 
*  |------------|------------|---------|--------|----------|---------------|
*  |   Level    |   Usage    |  Size   | Output | Optional |  Parameters   |
*  |------------|------------|---------|--------|----------|---------------|
*  | <>         | <>         | <>      | <>     | <>       | <>            |
*  | _deref     | _in        | _ecount | _full  | _opt     | (size)        |
*  | _deref_opt | _out       | _bcount | _part  |          | (size,length) |
*  |            | _inout     |         |        |          |               |
*  |            |            |         |        |          |               |
*  |------------|------------|---------|--------|----------|---------------|
*
*  Note: "<>" represents the empty string.
* 
*  Level: Describes the buffer pointer's level of indirection from the
*  parameter or return value 'p'.
* 
*  <>         : p is the buffer pointer.
*  _deref     : *p is the buffer pointer. p must not be NULL.
*  _deref_opt : *p may be the buffer pointer. p may be NULL, in which case the 
*               rest of the annotation is ignored.
* 
*  Usage: Describes how the function uses the buffer.
* 
*  <> : The buffer is not accessed. If used on the return value or with
*  _deref, the function will provide the buffer, and it will be uninitialized
*  at exit.  Otherwise, the caller must provide the buffer. This should only
*  be used for alloc and free functions.
*
*  _in : The function will only read from the buffer. The caller must provide
*  the buffer and initialize it.
*
*  _out : The function will only write to the buffer. If used on the return
*  value or with _deref, the function will provide the buffer and initialize
*  it.  Otherwise, the caller must provide the buffer, and the function will
*  initialize it.
*
*  _inout : The function may freely read from and write to the buffer. The
*  caller must provide the buffer and initialize it. If used with _deref, the
*  buffer may be reallocated by the function.
*
*  Size: Describes the total size of the buffer. This may be less than the
*  space actually allocated for the buffer, in which case it describes the
*  accessible amount.
* 
*  <> : No buffer size is given. If the type specifies the buffer size (such
*  as with LPSTR and LPWSTR), that amount is used. Otherwise, the buffer is
*  one element long. Must be used with _in, _out, or _inout.
*
*  _ecount : The buffer size is an explicit element count.
*
*  _bcount : The buffer size is an explicit byte count.
* 
*  Output: Describes how much of the buffer will be initialized by the
*  function. For _inout buffers, this also describes how much is initialized
*  at entry. Omit this category for _in buffers; they must be fully
*  initialized by the caller.
* 
*  <> : The type specifies how much is initialized. For instance, a function
*  initializing an LPWSTR must NULL-terminate the string.
*
*  _full : The function initializes the entire buffer.
*
*  _part : The function initializes part of the buffer, and explicitly
*  indicates how much.
* 
*  Optional: Describes if the buffer itself is optional.
* 
*  <>   : The pointer to the buffer must not be NULL.
*
*  _opt : The pointer to the buffer might be NULL. It will be checked before
*  being dereferenced.
* 
*  Parameters: Gives explicit counts for the size and length of the buffer.
* 
*  <> : There is no explicit count. Use when neither _ecount nor _bcount is
*  used.
*
*  (size) : Only the buffer's total size is given. Use with _ecount or _bcount
*  but not _part.
*
*  (size,length) : The buffer's total size and initialized length are
*  given. Use with _ecount_part and _bcount_part.
* 
*  ----------------------------------------------------------------------------
*  Buffer Annotation Examples
* 
*  LWSTDAPI_(BOOL) StrToIntExA(
*      LPCSTR pszString,  //  No annotation required, const implies __in.
*      DWORD dwFlags,
*      __out int *piRet   // A pointer whose dereference will be filled in.
*  );
* 
*  void MyPaintingFunction(
*      __in HWND hwndControl,     //  An initialized read-only parameter.
*      __in_opt HDC hdcOptional,  //  An initialized read-only parameter that 
*                                 //  might be NULL.
*      __inout IPropertyStore *ppsStore // An initialized parameter that 
*                                       // may be freely used and modified.
*  );
* 
*  LWSTDAPI_(BOOL) PathCompactPathExA(
*      __out_ecount(cchMax) LPSTR pszOut, //  A string buffer with cch elements
*                                         //  that will be '\0' terminated 
*                                         //  on exit.
*      LPCSTR pszSrc,                     //  No annotation required, 
*                                         //  const implies __in.
*      UINT cchMax,                              
*      DWORD dwFlags
*  );
* 
*  HRESULT SHLocalAllocBytes(
*      size_t cb,
*      __deref_bcount(cb) T **ppv //  A pointer whose dereference will be set
*                                 //  to an uninitialized buffer with cb bytes.
*  );
* 
*  __inout_bcount_full(cb) : A buffer with cb elements that is fully
*  initialized at entry and exit, and may be written to by this function.
* 
*  __out_ecount_part(count, *countOut) : A buffer with count elements that
*  will be partially initialized by this function. The function indicates how
*  much it initialized by setting *countOut.
* 
************************************************************************/
#if (_MSC_VER >= 1400) && !defined(__midl) && !defined(_PREFAST_) && (__SPECSTRINGS_STRICT_LEVEL > 0)
#pragma once
#include <specstrings_undef.h>
#define __ecount(size)                                __allowed(on_return)
#define __bcount(size)                                __allowed(on_return)
#define __xcount(size)                                __allowed(on_return)
#define __in                                          __allowed(on_parameter)
#define __in_ecount(size)                             __allowed(on_parameter)
#define __in_bcount(size)                             __allowed(on_parameter)
#define __in_xcount(size)                             __allowed(on_parameter)
#define __in_z                                        __allowed(on_parameter)
#define __in_ecount_z(size)                           __allowed(on_parameter)
#define __in_bcount_z(size)                           __allowed(on_parameter)
#define __out                                         __allowed(on_parameter)
#define __out_ecount(size)                            __allowed(on_parameter)
#define __out_bcount(size)                            __allowed(on_parameter)
#define __out_xcount(size)                            __allowed(on_parameter)
#define __out_ecount_part(size,len)                   __allowed(on_parameter)
#define __out_bcount_part(size,len)                   __allowed(on_parameter)
#define __out_xcount_part(size,len)                   __allowed(on_parameter)
#define __out_ecount_full(size)                       __allowed(on_parameter)
#define __out_bcount_full(size)                       __allowed(on_parameter)
#define __out_xcount_full(size)                       __allowed(on_parameter)
#define __out_z				              __allowed(on_parameter)
#define __out_ecount_z(size)                          __allowed(on_parameter)
#define __out_bcount_z(size)                          __allowed(on_parameter)
#define __inout                                       __allowed(on_parameter)
#define __inout_ecount(size)                          __allowed(on_parameter)
#define __inout_bcount(size)                          __allowed(on_parameter)
#define __inout_xcount(size)                          __allowed(on_parameter)
#define __inout_ecount_part(size,len)                 __allowed(on_parameter)
#define __inout_bcount_part(size,len)                 __allowed(on_parameter)
#define __inout_xcount_part(size,len)                 __allowed(on_parameter)
#define __inout_ecount_full(size)                     __allowed(on_parameter)
#define __inout_bcount_full(size)                     __allowed(on_parameter)
#define __inout_xcount_full(size)                     __allowed(on_parameter)
#define __inout_z                                     __allowed(on_parameter)
#define __inout_ecount_z(size)                        __allowed(on_parameter)
#define __inout_bcount_z(size)                        __allowed(on_parameter)
#define __ecount_opt(size)                            __allowed(on_parameter)
#define __bcount_opt(size)                            __allowed(on_parameter)
#define __xcount_opt(size)                            __allowed(on_parameter)
#define __in_opt                                      __allowed(on_parameter)
#define __in_ecount_opt(size)                         __allowed(on_parameter)
#define __in_bcount_opt(size)                         __allowed(on_parameter)
#define __in_z_opt                                    __allowed(on_parameter)
#define __in_ecount_z_opt(size)                       __allowed(on_parameter)
#define __in_bcount_z_opt(size)                       __allowed(on_parameter)
#define __in_xcount_opt(size)                         __allowed(on_parameter)
#define __out_opt                                     __allowed(on_parameter)
#define __out_ecount_opt(size)                        __allowed(on_parameter)
#define __out_bcount_opt(size)                        __allowed(on_parameter)
#define __out_xcount_opt(size)                        __allowed(on_parameter)
#define __out_ecount_part_opt(size,len)               __allowed(on_parameter)
#define __out_bcount_part_opt(size,len)               __allowed(on_parameter)
#define __out_xcount_part_opt(size,len)               __allowed(on_parameter)
#define __out_ecount_full_opt(size)                   __allowed(on_parameter)
#define __out_bcount_full_opt(size)                   __allowed(on_parameter)
#define __out_xcount_full_opt(size)                   __allowed(on_parameter)
#define __out_ecount_z_opt(size)                      __allowed(on_parameter)
#define __out_bcount_z_opt(size)                      __allowed(on_parameter)
#define __inout_opt                                   __allowed(on_parameter)
#define __inout_ecount_opt(size)                      __allowed(on_parameter)
#define __inout_bcount_opt(size)                      __allowed(on_parameter)
#define __inout_xcount_opt(size)                      __allowed(on_parameter)
#define __inout_ecount_part_opt(size,len)             __allowed(on_parameter)
#define __inout_bcount_part_opt(size,len)             __allowed(on_parameter)
#define __inout_xcount_part_opt(size,len)             __allowed(on_parameter)
#define __inout_ecount_full_opt(size)                 __allowed(on_parameter)
#define __inout_bcount_full_opt(size)                 __allowed(on_parameter)
#define __inout_xcount_full_opt(size)                 __allowed(on_parameter)
#define __inout_z_opt                                 __allowed(on_parameter)
#define __inout_ecount_z_opt(size)                    __allowed(on_parameter)
#define __inout_ecount_z_opt(size)                    __allowed(on_parameter)
#define __inout_bcount_z_opt(size)                    __allowed(on_parameter)
#define __deref_ecount(size)                          __allowed(on_parameter)
#define __deref_bcount(size)                          __allowed(on_parameter)
#define __deref_xcount(size)                          __allowed(on_parameter)
#define __deref_in                                    __allowed(on_parameter)
#define __deref_in_ecount(size)                       __allowed(on_parameter)
#define __deref_in_bcount(size)                       __allowed(on_parameter)
#define __deref_in_xcount(size)                       __allowed(on_parameter)
#define __deref_out                                   __allowed(on_parameter)
#define __deref_out_ecount(size)                      __allowed(on_parameter)
#define __deref_out_bcount(size)                      __allowed(on_parameter)
#define __deref_out_xcount(size)                      __allowed(on_parameter)
#define __deref_out_ecount_part(size,len)             __allowed(on_parameter)
#define __deref_out_bcount_part(size,len)             __allowed(on_parameter)
#define __deref_out_xcount_part(size,len)             __allowed(on_parameter)
#define __deref_out_ecount_full(size)                 __allowed(on_parameter)
#define __deref_out_bcount_full(size)                 __allowed(on_parameter)
#define __deref_out_xcount_full(size)                 __allowed(on_parameter)
#define __deref_out_z                                 __allowed(on_parameter)
#define __deref_out_ecount_z(size)                    __allowed(on_parameter)
#define __deref_out_bcount_z(size)                    __allowed(on_parameter)
#define __deref_out_xcount(size)                      __allowed(on_parameter)
#define __deref_inout                                 __allowed(on_parameter)
#define __deref_inout_ecount(size)                    __allowed(on_parameter)
#define __deref_inout_bcount(size)                    __allowed(on_parameter)
#define __deref_inout_xcount(size)                    __allowed(on_parameter)
#define __deref_inout_ecount_part(size,len)           __allowed(on_parameter)
#define __deref_inout_bcount_part(size,len)           __allowed(on_parameter)
#define __deref_inout_xcount_part(size,len)           __allowed(on_parameter)
#define __deref_inout_ecount_full(size)               __allowed(on_parameter)
#define __deref_inout_bcount_full(size)               __allowed(on_parameter)
#define __deref_inout_xcount_full(size)               __allowed(on_parameter)
#define __deref_inout_z                               __allowed(on_parameter)
#define __deref_inout_ecount_z(size)                  __allowed(on_parameter)
#define __deref_inout_bcount_z(size)                  __allowed(on_parameter)
#define __deref_ecount_opt(size)                      __allowed(on_parameter)
#define __deref_bcount_opt(size)                      __allowed(on_parameter)
#define __deref_xcount_opt(size)                      __allowed(on_parameter)
#define __deref_in_opt                                __allowed(on_parameter)
#define __deref_in_ecount_opt(size)                   __allowed(on_parameter)
#define __deref_in_bcount_opt(size)                   __allowed(on_parameter)
#define __deref_in_xcount_opt(size)                   __allowed(on_parameter)
#define __deref_out_opt                               __allowed(on_parameter)
#define __deref_out_ecount_opt(size)                  __allowed(on_parameter)
#define __deref_out_bcount_opt(size)                  __allowed(on_parameter)
#define __deref_out_xcount_opt(size)                  __allowed(on_parameter)
#define __deref_out_ecount_part_opt(size,len)         __allowed(on_parameter)
#define __deref_out_bcount_part_opt(size,len)         __allowed(on_parameter)
#define __deref_out_xcount_part_opt(size,len)         __allowed(on_parameter)
#define __deref_out_ecount_full_opt(size)             __allowed(on_parameter)
#define __deref_out_bcount_full_opt(size)             __allowed(on_parameter)
#define __deref_out_xcount_full_opt(size)             __allowed(on_parameter)
#define __deref_out_z_opt                             __allowed(on_parameter)
#define __deref_out_ecount_z_opt(size)                __allowed(on_parameter)
#define __deref_out_bcount_z_opt(size)                __allowed(on_parameter)
#define __deref_inout_opt                             __allowed(on_parameter)
#define __deref_inout_ecount_opt(size)                __allowed(on_parameter)
#define __deref_inout_bcount_opt(size)                __allowed(on_parameter)
#define __deref_inout_xcount_opt(size)                __allowed(on_parameter)
#define __deref_inout_ecount_part_opt(size,len)       __allowed(on_parameter)
#define __deref_inout_bcount_part_opt(size,len)       __allowed(on_parameter)
#define __deref_inout_xcount_part_opt(size,len)       __allowed(on_parameter)
#define __deref_inout_ecount_full_opt(size)           __allowed(on_parameter)
#define __deref_inout_bcount_full_opt(size)           __allowed(on_parameter)
#define __deref_inout_xcount_full_opt(size)           __allowed(on_parameter)
#define __deref_inout_z_opt                           __allowed(on_parameter)
#define __deref_inout_ecount_z_opt(size)              __allowed(on_parameter)
#define __deref_inout_bcount_z_opt(size)              __allowed(on_parameter)
#define __deref_opt_ecount(size)                      __allowed(on_parameter)
#define __deref_opt_bcount(size)                      __allowed(on_parameter)
#define __deref_opt_xcount(size)                      __allowed(on_parameter)
#define __deref_opt_in                                __allowed(on_parameter)
#define __deref_opt_in_ecount(size)                   __allowed(on_parameter)
#define __deref_opt_in_bcount(size)                   __allowed(on_parameter)
#define __deref_opt_in_xcount(size)                   __allowed(on_parameter)
#define __deref_opt_out                               __allowed(on_parameter)
#define __deref_opt_out_ecount(size)                  __allowed(on_parameter)
#define __deref_opt_out_bcount(size)                  __allowed(on_parameter)
#define __deref_opt_out_xcount(size)                  __allowed(on_parameter)
#define __deref_opt_out_ecount_part(size,len)         __allowed(on_parameter)
#define __deref_opt_out_bcount_part(size,len)         __allowed(on_parameter)
#define __deref_opt_out_xcount_part(size,len)         __allowed(on_parameter)
#define __deref_opt_out_ecount_full(size)             __allowed(on_parameter)
#define __deref_opt_out_bcount_full(size)             __allowed(on_parameter)
#define __deref_opt_out_xcount_full(size)             __allowed(on_parameter)
#define __deref_opt_inout                             __allowed(on_parameter)
#define __deref_opt_inout_ecount(size)                __allowed(on_parameter)
#define __deref_opt_inout_bcount(size)                __allowed(on_parameter)
#define __deref_opt_inout_xcount(size)                __allowed(on_parameter)
#define __deref_opt_inout_ecount_part(size,len)       __allowed(on_parameter)
#define __deref_opt_inout_bcount_part(size,len)       __allowed(on_parameter)
#define __deref_opt_inout_xcount_part(size,len)       __allowed(on_parameter)
#define __deref_opt_inout_ecount_full(size)           __allowed(on_parameter)
#define __deref_opt_inout_bcount_full(size)           __allowed(on_parameter)
#define __deref_opt_inout_xcount_full(size)           __allowed(on_parameter)
#define __deref_opt_inout_z                           __allowed(on_parameter)
#define __deref_opt_inout_ecount_z(size)              __allowed(on_parameter)
#define __deref_opt_inout_bcount_z(size)              __allowed(on_parameter)
#define __deref_opt_ecount_opt(size)                  __allowed(on_parameter)
#define __deref_opt_bcount_opt(size)                  __allowed(on_parameter)
#define __deref_opt_xcount_opt(size)                  __allowed(on_parameter)
#define __deref_opt_in_opt                            __allowed(on_parameter)
#define __deref_opt_in_ecount_opt(size)               __allowed(on_parameter)
#define __deref_opt_in_bcount_opt(size)               __allowed(on_parameter)
#define __deref_opt_in_xcount_opt(size)               __allowed(on_parameter)
#define __deref_opt_out_opt                           __allowed(on_parameter)
#define __deref_opt_out_ecount_opt(size)              __allowed(on_parameter)
#define __deref_opt_out_bcount_opt(size)              __allowed(on_parameter)
#define __deref_opt_out_xcount_opt(size)              __allowed(on_parameter)
#define __deref_opt_out_ecount_part_opt(size,len)     __allowed(on_parameter)
#define __deref_opt_out_bcount_part_opt(size,len)     __allowed(on_parameter)
#define __deref_opt_out_xcount_part_opt(size,len)     __allowed(on_parameter)
#define __deref_opt_out_ecount_full_opt(size)         __allowed(on_parameter)
#define __deref_opt_out_bcount_full_opt(size)         __allowed(on_parameter)
#define __deref_opt_out_xcount_full_opt(size)         __allowed(on_parameter)  
#define __deref_opt_out_z_opt                         __allowed(on_parameter)
#define __deref_opt_out_ecount_z_opt(size)            __allowed(on_parameter)
#define __deref_opt_out_bcount_z_opt(size)            __allowed(on_parameter)
#define __deref_opt_inout_opt                         __allowed(on_parameter)
#define __deref_opt_inout_ecount_opt(size)            __allowed(on_parameter)
#define __deref_opt_inout_bcount_opt(size)            __allowed(on_parameter)
#define __deref_opt_inout_xcount_opt(size)            __allowed(on_parameter)
#define __deref_opt_inout_ecount_part_opt(size,len)   __allowed(on_parameter) 
#define __deref_opt_inout_bcount_part_opt(size,len)   __allowed(on_parameter)
#define __deref_opt_inout_xcount_part_opt(size,len)   __allowed(on_parameter)
#define __deref_opt_inout_ecount_full_opt(size)       __allowed(on_parameter)
#define __deref_opt_inout_bcount_full_opt(size)       __allowed(on_parameter)
#define __deref_opt_inout_xcount_full_opt(size)       __allowed(on_parameter)
#define __deref_opt_inout_z_opt                       __allowed(on_parameter)
#define __deref_opt_inout_ecount_z_opt(size)          __allowed(on_parameter)
#define __deref_opt_inout_bcount_z_opt(size)          __allowed(on_parameter)
/************************************************************************
*  Advanced Annotations
* 
*  Advanced annotations describe behavior that is not expressible with the
*  regular buffer macros. These may be used either to annotate buffer
*  parameters that involve complex or conditional behavior, or to enrich
*  existing annotations with additional information.
* 
*  __success(expr) T f() : <expr> indicates whether function f succeeded or
*  not. If <expr> is true at exit, all the function's guarantees (as given
*  by other annotations) must hold. If <expr> is false at exit, the caller
*  should not expect any of the function's guarantees to hold. If not used,
*  the function must always satisfy its guarantees. Added automatically to
*  functions that indicate success in standard ways, such as by returning an
*  HRESULT.
* 
*  __out_awcount(expr, size) T *p : Pointer p is a buffer whose size may be
*  given in either bytes or elements. If <expr> is true, this acts like
*  __out_bcount. If <expr> is false, this acts like __out_ecount. This
*  should only be used to annotate old APIs.
* 
*  __in_awcount(expr, size) T* p : Pointer p is a buffer whose size may be given
*  in either bytes or elements. If <expr> is true, this acts like
*  __in_bcount. If <expr> is false, this acts like __in_ecount. This should
*  only be used to annotate old APIs.
* 
*  __nullterminated T* p : Pointer p is a buffer that may be read or written
*  up to and including the first '\0' character or pointer. May be used on
*  typedefs, which marks valid (properly initialized) instances of that type
*  as being null-terminated.
* 
*  __nullnullterminated T* p : Pointer p is a buffer that may be read or
*  written up to and including the first sequence of two '\0' characters or
*  pointers. May be used on typedefs, which marks valid instances of that
*  type as being double-null terminated.
* 
*  __reserved T v : Value v must be 0/NULL, reserved for future use.
* 
*  __checkReturn T f(); : Return value of f must not be ignored by callers
*  of this function.
* 
*  __typefix(ctype) T v : Value v should be treated as an instance of ctype,
*  rather than its declared type when considering validity.
* 
*  __override T f(); : Specify C#-style 'override' behaviour for overriding
*  virtual methods.
* 
*  __callback T f(); : Function f can be used as a function pointer.
* 
*  __format_string T p : Pointer p is a string that contains % markers in
*  the style of printf.
* 
*  __blocksOn(resource) f(); : Function f blocks on the resource 'resource'.
* 
*  __fallthrough : Annotates switch statement labels where fall-through is
*  desired, to distinguish from forgotten break statements.
* 
*  __range(low_bnd, up_bnd) int f(): The return from the function "f" must
*  be in the inclusive numeric range [low_bnd, up_bnd].
*
*  __in_range(low_bnd, up_bnd) int i : Precondition that integer i must be
*  in the inclusive numeric range [low_bnd, up_bnd].
* 
*  __out_range(low_bnd, up_bnd) int i : Postcondition that integer i must be
*  in the inclusive numeric range [low_bnd, up_bnd].
* 
*  __deref_in_range(low_bnd, up_bnd) int* pi : Precondition that integer *pi
*  must be in the inclusive numeric range [low_bnd, up_bnd].
*
*  __deref_out_range(low_bnd, up_bnd) int* pi : Postcondition that integer
*  *pi must be in the inclusive numeric range [low_bnd, up_bnd].
*
*  The first argument of a range macro may also be a C relational operator
*  (<,>,!=, ==, <=, >=).
*  
*  __range(rel_op, j) int f(): Postcondition that "f() rel_op j" must be
*  true.  Note that j may be a expression known only at runtime.
*
*  __in_range(rel_op, j) int i : Precondition that "i rel_op j" must be
*  true.  Note that j may be a expression known only at runtime.
* 
*  __out_range(rel_op, j) int i : Postcondition that integer "i rel_op j"
*  must be true.  Note that j may be a expression known only at runtime.
* 
*  __deref_in_range(rel_op, j) int *pi : Precondition that "*pi rel_op j"
*  must be true.  Note that j may be a expression known only at runtime.
*
*  __deref_out_range(rel_op, j) int *pi : Postcondition that "*pi rel_op j"
*  must be true.  Note that j may be a expression known only at runtime.
*
*  __in_bound int i : Precondition that integer i must be bound, but the
*  exact range can't be specified at compile time.  __in_range should be
*  used if the range can be explicitly stated.
*
*  __out_bound int i : Postcondition that integer i must be bound, but the
*  exact range can't be specified at compile time.  __out_range should be
*  used if the range can be explicitly stated.
* 
*  __deref_out_bound int pi : Postcondition that integer *pi must be bound,
*  but the exact range can't be specified at compile time.
*  __deref_out_range should be used if the range can be explicitly stated.
* 
*  __assume_bound(expr); : Assume that the expression is bound to some known
*  range. This can be used to suppress integer overflow warnings on integral
*  expressions that are known to be bound due to reasons not explicit in the
*  code. Use as a statement in the body of a function.
* 
*  __allocator void f(): Function allocates memory using an integral size
*  argument
*
*  ----------------------------------------------------------------------------
*  Advanced Annotation Examples
* 
*  __success(return == TRUE) LWSTDAPI_(BOOL) 
*  PathCanonicalizeA(__out_ecount(MAX_PATH) LPSTR pszBuf, LPCSTR pszPath);
*  //  pszBuf is only guaranteed to be null-terminated when TRUE is returned.
* 
*  // Initialized LPWSTRs are null-terminated strings.
*  typedef __nullterminated WCHAR* LPWSTR;
* 
*  __out_ecount(cch) __typefix(LPWSTR) void *psz;
*  // psz is a buffer parameter which will be a null-terminated WCHAR string 
*  // at exit, and which initially contains cch WCHARs.
* 
************************************************************************/
#define __success(expr)          __allowed(on_function_or_typedecl)
#define __out_awcount(expr,size) __allowed(on_parameter) 
#define __in_awcount(expr,size)  __allowed(on_parameter)   
#define __nullterminated         __allowed(on_typedecl)
#define __nullnullterminated     __allowed(on_typedecl)
#define __reserved               __allowed(on_parameter)
#define __checkReturn            __allowed(on_function)
#define __typefix(ctype)         __allowed(on_parameter_or_return) 
#define __override               __allowed(on_function) 
#define __callback               __allowed(on_function) 
#define __format_string          __allowed(on_parameter_or_return) 
#define __blocksOn(resource)     __allowed(on_function) 
#define __fallthrough            __allowed(as_statement)
#define __range(lb,ub)           __allowed(on_return) 
#define __in_range(lb,ub)        __allowed(on_parameter) 
#define __out_range(lb,ub)       __allowed(on_parameter) 
#define __deref_in_range(lb,ub)  __allowed(on_parameter) 
#define __deref_out_range(lb,ub) __allowed(on_parameter) 
#define __field_range(lb,ub)     __allowed(on_field)
#define __bound                  __allowed(on_return) 
#define __in_bound               __allowed(on_parameter) 
#define __out_bound              __allowed(on_parameter) 
#define __deref_out_bound        __allowed(on_parameter) 
#define __assume_bound(i)        __allowed(as_statement_with_arg(i))
#define __allocator              __allowed(on_function) 
/*************************************************************************** 
* Expert Macros
***************************************************************************/
#define __null                  __allowed(on_typedecl)
#define __notnull               __allowed(on_typedecl)
#define __maybenull             __allowed(on_typedecl)
#define __exceptthat            __allowed(on_typedecl)
/*************************************************************************** 
* Macros to classify fields of structures.
*                          Structure Annotations
*
*   The buffer annotations are a convenient way of describing
*   relationships between buffers and their size on a function by
*   function basis. Very often struct or class data members have similar
*   invariants, which can be expressed directly on the type.
*
*   Similar to our buffer annotations we can summarize all the various
*   structure annotations by one choosing an element from each column of
*   this table to build a composite annotation.
*
*           +--------------------------------------------------+
*           | Selector |  Units  |    Size/Init     | Optional |
*           |----------+---------+------------------+----------|
*           | __field  | _ecount | (size)           | empty    |
*           |----------+---------+------------------+----------|
*           | __struct | _bcount | _full(size)      | _opt     |
*           |----------+---------+------------------+----------|
*           |          | _xcount | _part(size,init) |          |
*           +--------------------------------------------------+
*
*   Note that empty represents the empty string. Sometime arguments need
*   to be "floated" to the left to give us a valid annotation name. For
*   example the naive combination __field_ecount(size)_opt is actually
*   written as __field_ecount_opt(size). Not all possible combinations
*   are currently supported or sensible. See specstrings_strict.h for
*   the currently supported set. Those that are supported are documented
*   below.
*
*Summary of Elements
*
*   Selector
*
*                __field
*                        The annotation should only be placed in front
*                        of data members of structures and classes. The
*                        data members are pointers to a block of data.
*                        The annotations describe properties about the
*                        size of the block of data. This can be used for
*
*                __struct
*                        The annotation should only be placed at the
*                        beginning of the definition of a structure or
*                        class. These annotations are used when a struct
*                        or class is used as a "header" that is
*                        allocated inline with a block of data and there
*                        is no apparent field that represents the tail
*                        end of the structure.
*
*   Units
*
*                _ecount
*                        All size and initialization values are in terms
*                        of elements of the appropriate type
*
*                _bcount
*                        All size and initialization values are in terms
*                        of raw byte sizes.
*
*                _xcount
*                        The size or initialization values cannot be
*                        properly expressed as a simple byte or element
*                        count, and instead a place holder is used to
*                        document the relationship.
*
*   Size/Init
*           All the size/init expressions can contain references to
*           other fields in the struct or class.
*
*                (size)
*                        The size of the buffer is determined by the
*                        expression size. Unless, the type of the buffer
*                        provides more information nothing is know about
*                        how much of this data is initialized. For
*                        example, if the data member happens to be a
*                        string type such as LPSTR. It is assumed that
*                        the data is initialized to the first '\0'.
*
*                _full(size)
*                        The size of the buffer is determined by the
*                        expression size and all the data in the buffer
*                        is guaranteed to be initialized.
*
*                _part(size,init)
*                        The size of the buffer is determined by the
*                        expression size and all the data in the buffer
*                        is guaranteed to be initialized up to init
*                        elements or bytes.
*
*   Optional
*
*                empty
*                        The pointer to the block of memory is never
*                        NULL
*
*                _opt
*                        The pointer to the block of memory is may be
*                        NULL
*
*     
*   // Basic Usage of Struct Annotations                         
*   #include <stdio.h>                                           
*   #include <stdlib.h>                                          
*   struct buf_s {                                               
*    int sz;                                                     
*    __field_bcount_full(sz)                                     
*    char *buf;                                                  
*   };                                                           
*   void InitBuf(__out struct *buf_s b,int sz) {                 
*        b->buf = calloc(sz,sizeof(char));                       
*        b->sz = sz;                                             
*   }                                                            
*   void WriteBuf(__in FILE *fp,__in struct *buf_s b) {          
*     fwrite(b->buf,b->sz,sizeof(char),fp);                      
*   }                                                            
*   void ReadBuf(__in FILE *fp,__inout struct *buf_s b) {        
*     fread(b->buf,b->sz,sizeof(char),fp);                       
*   }                                                            
*                                                                 
*                                                                 
*                                                                 
*   // Inline Allocated Buffer                                   
*   struct buf_s {                                               
*    int sz;                                                     
*    __field_bcount(sz)                                          
*    char buf[1];                                                
*   };                                                           
*   void WriteBuf(__in FILE *fp,__in struct *buf_s b) {          
*     fwrite(&(b->buf),b->sz,sizeof(char),fp);                   
*   }                                                            
*   void ReadBuf(__in FILE *fp,__inout struct *buf_s b) {        
*     fread(&(b->buf),b->sz,sizeof(char),fp);                    
*   }                                                            
*                                                                 
*                                                                 
*                                                                 
*   // Embedded Header Structure                                 
*   __struct_bcount(sz)                                          
*   struct buf_s {                                               
*    int sz;                                                     
*   };                                                           
*   void WriteBuf(__in FILE *fp,__in struct *buf_s b) {          
*     fwrite(&b,b->sz,sizeof(char),fp);                          
*   }                                                            
*   void ReadBuf(__in FILE *fp,__inout struct *buf_s b) {        
*     fread(&b,b->sz,sizeof(char),fp);                           
*   }                                                            
*
*
****************************************************************************/
#define __field_ecount(size)               __allowed(on_field)
#define __field_bcount(size)               __allowed(on_field)
#define __field_xcount(size)               __allowed(on_field)
#define __field_ecount_opt(size)           __allowed(on_field)
#define __field_bcount_opt(size)           __allowed(on_field)
#define __field_xcount_opt(size)           __allowed(on_field)
#define __field_ecount_part(size,init)     __allowed(on_field)
#define __field_bcount_part(size,init)     __allowed(on_field)
#define __field_xcount_part(size,init)     __allowed(on_field)
#define __field_ecount_part_opt(size,init) __allowed(on_field)
#define __field_bcount_part_opt(size,init) __allowed(on_field)
#define __field_xcount_part_opt(size,init) __allowed(on_field)
#define __field_ecount_full(size)          __allowed(on_field)
#define __field_bcount_full(size)          __allowed(on_field)
#define __field_xcount_full(size)          __allowed(on_field)
#define __field_ecount_full_opt(size)      __allowed(on_field)
#define __field_bcount_full_opt(size)      __allowed(on_field) 
#define __field_xcount_full_opt(size)      __allowed(on_field)
#define __struct_bcount(size)              __allowed(on_struct) 
#define __struct_xcount(size)              __allowed(on_struct) 

/*************************************************************************** 
* Macros to classify the entrypoints and indicate their category.
*
* Pre-defined control point categories include: RPC, KERNEL, GDI.
*
* Pre-defined control point macros include:
*  __rpc_entry, __kernel_entry, __gdi_entry.
***************************************************************************/
#define __control_entrypoint(category)     __allowed(on_function) 
#define __rpc_entry                        __allowed(on_function) 
#define __kernel_entry                     __allowed(on_function) 
#define __gdi_entry                        __allowed(on_function)  

/*************************************************************************** 
* Macros to track untrusted data and their validation. The list of untrusted
* sources include:
*
* FILE                     - File reading stream or API
* NETWORK                  - Socket readers
* INTERNET                 - WinInet and WinHttp readers
* USER_REGISTRY            - HKCU portions of the registry
* USER_MODE                - Parameters to kernel entry points
* RPC                      - Parameters to RPC entry points 
* DRIVER                   - Device driver 
***************************************************************************/
#define __in_data_source(src_sym)       __allowed(on_parameter) 
#define __out_data_source(src_sym)      __allowed(on_parameter) 
#define __field_data_source(src_sym)    __allowed(on_field)
#define __this_out_data_source(src_syn) __allowed(on_function)

/************************************************************************** 
* Macros to tag file parsing code. Predefined formats include:
*  PNG                     - Portable Network Graphics
*  JPEG                    - Joint Photographic Experts Group
*  BMP                     - Bitmap
*  RC_BMP                  - Resource bitmap
*  WMF                     - Windows Metafile
*  EMF                     - Windows Enhanced Metafile
*  GIF                     - Graphics Interchange Format
*  MIME_TYPE               - MIME type from header tokens
*  MAIL_MONIKER            - MAIL information refered by URL moniker
*  HTML                    - HyperText Markup Language
*  WMPHOTO                 - Windows media photo
*  OE_VCARD                - Outlook Express virtual card
*  OE_CONTACT              - Outlook Express contact
*  MIDI                    - Musical Instrument Digital Interface
*  LDIF                    - LDAP Data Interchange Format
*  AVI                     - Audio Visual Interchange
*  ACM                     - Audio Compression Manager
**************************************************************************/
#define __out_validated(filetype_sym)         __allowed(on_parameter) 
#define __this_out_validated(filetype_sym)    __allowed(on_function)   
#define __file_parser(filetype_sym)           __allowed(on_function) 
#define __file_parser_class(filetype_sym)     __allowed(on_struct)  
#define __file_parser_library(filetype_sym)   __allowed(as_global_decl)  

/*************************************************************************** 
* Macros to track the code content in the file. The type of code
* contents currently tracked:
*
* NDIS_DRIVER                   - NDIS Device driver 
***************************************************************************/
#define __source_code_content(codetype_sym)     __allowed(as_global_decl) 

/*************************************************************************** 
* Macros to track the code content in the class. The type of code
* contents currently tracked:
*
* DCOM                          - Class implementing DCOM
***************************************************************************/
#define __class_code_content(codetype_sym)    __allowed(on_struct) 

/*************************************************************************
* Macros to tag encoded function pointers
**************************************************************************/
#define __encoded_pointer                 
#define __encoded_array                   
#define __field_encoded_pointer           __allowed(on_field)
#define __field_encoded_array             __allowed(on_field)

#define __transfer(formal)                __allowed(on_parameter_or_return) 
#define __assume_validated(exp)           __allowed(as_statement_with_arg(exp))

/************************************************************************* 
* __analysis_assume(expr) : Expert macro use only when directed. Use this to
* tell static analysis tools like PREfix and PREfast about a non-coded
* assumption that you wish the tools to assume. The assumption will be
* understood by those tools. By default there is no dynamic checking or
* static checking of the assumption in any build.
*
* To obtain dynamic checking wrap this macro in your local version of a debug
* assert.
* Please do not put function calls in the expression because this is not
* supported by all tools:
*  __analysis_assume(GetObject () != NULL); // DO NOT DO THIS
*
*************************************************************************/
#define __analysis_assume(expr) __allowed(as_statement_with_arg(expr))
#define __analysis_assert(expr) __allowed(as_statement_with_arg(expr))

/************************************************************************* 
* __analysis_hint(hint_sym) : Expert macro use only when
* directed. Use this to influence certain analysis heuristics
* used by the tools. These hints do not describe the semantics
* of functions but simply direct the tools to act in a certain
* way.
*
* Current hints that are supported are:
*
* INLINE   - inline this function during analysis overrides any
*            default heuristics 
* NOINLINE - do not inline this function during analysis overrides 
*            and default heuristics
*************************************************************************/
#define __analysis_hint(hint) __allowed(on_function)

/************************************************************************* 
* Macros to encode abstract properties of values. Used by SALadt.h
*************************************************************************/
#define __type_has_adt_prop(adt,prop)     __allowed(on_typdecl)
#define __out_has_adt_prop(adt,prop)      __allowed(on_parameter)
#define __out_not_has_adt_prop(adt,prop)  __allowed(on_parameter)
#define __out_transfer_adt_prop(arg)      __allowed(on_parameter)
#define __out_has_type_adt_props(typ)     __allowed(on_parameter)
#define __assume_ValidCompNameA(expr)     __allowed(as_statement_with_arg(expr))
#define __assume_ValidCompNameW(expr)     __allowed(as_statement_with_arg(expr))

/************************************************************************* 
* Macros used by Prefast for Drivers 
* 
*  __possibly_notnulltermiated :
*
*  Used for return values of parameters or functions that do not
*  guarantee nullterimination in all cases.
*
*************************************************************************/
#define __possibly_notnulltermiated     __allowed(on_parameter_or_return)

/************************************************************************* 
* Advanced macros
* 
*  __volatile 
* The __volatile annotation identifies a global variable or
* structure field that: 
*   1) is not declared volatile; 
*   2) is accessed concurrently by multiple threads.
*
* The __deref_volatile annotation identifies a global variable
* or structure field that stores a pointer to some data that:
*   1) is not declared volatile; 
*   2) is accessed concurrently by multiple threads.
*
* Prefast uses these annotations to find patterns of code that
* may result in unexpected re-fetching of the global variable
* into a local variable.
*
* We also provide two complimentary annotations __nonvolatile
* and __deref_nonvolatile that could be used to suppress Prefast
*
* re-fetching warnings on variables that are known either:
*   1) not to be in danger of being re-fetched or,
*   2) not to lead to incorrect results if they are re-fetched
*
*************************************************************************/
#define __volatile                       __allowed(on_global_or_field)
#define __deref_volatile                 __allowed(on_global_or_field)
#define __nonvolatile                    __allowed(on_global_or_field)
#define __deref_nonvolatile              __allowed(on_global_or_field)

/************************************************************************* 
* Macros deprecated with strict level greater then 1.
**************************************************************************/
#if (__SPECSTRINGS_STRICT_LEVEL > 1)
/* Must come before macro defintions */
#pragma deprecated(__in_nz)
#pragma deprecated(__in_ecount_nz)
#pragma deprecated(__in_bcount_nz)
#pragma deprecated(__out_nz)
#pragma deprecated(__out_nz_opt)
#pragma deprecated(__out_ecount_nz)
#pragma deprecated(__out_bcount_nz)
#pragma deprecated(__inout_nz)
#pragma deprecated(__inout_ecount_nz)
#pragma deprecated(__inout_bcount_nz)
#pragma deprecated(__in_nz_opt)          
#pragma deprecated(__in_ecount_nz_opt)
#pragma deprecated(__in_bcount_nz_opt)
#pragma deprecated(__out_ecount_nz_opt)
#pragma deprecated(__out_bcount_nz_opt)
#pragma deprecated(__inout_nz_opt)       
#pragma deprecated(__inout_ecount_nz_opt)
#pragma deprecated(__inout_bcount_nz_opt)
#pragma deprecated(__deref_out_nz)                 
#pragma deprecated(__deref_out_ecount_nz)
#pragma deprecated(__deref_out_bcount_nz)
#pragma deprecated(__deref_inout_nz)               
#pragma deprecated(__deref_inout_ecount_nz)
#pragma deprecated(__deref_inout_bcount_nz)
#pragma deprecated(__deref_out_nz_opt)             
#pragma deprecated(__deref_out_ecount_nz_opt)
#pragma deprecated(__deref_out_bcount_nz_opt)
#pragma deprecated(__deref_inout_nz_opt)           
#pragma deprecated(__deref_inout_ecount_nz_opt)
#pragma deprecated(__deref_inout_bcount_nz_opt)
#pragma deprecated(__deref_opt_inout_nz)           
#pragma deprecated(__deref_opt_inout_ecount_nz)
#pragma deprecated(__deref_opt_inout_bcount_nz)
#pragma deprecated(__deref_opt_out_nz_opt)         
#pragma deprecated(__deref_opt_out_ecount_nz_opt)
#pragma deprecated(__deref_opt_out_bcount_nz_opt)
#pragma deprecated(__deref_opt_inout_nz_opt)       
#pragma deprecated(__deref_opt_inout_ecount_nz_opt)
#pragma deprecated(__deref_opt_inout_bcount_nz_opt)
#pragma deprecated(__deref)
#pragma deprecated(__pre)
#pragma deprecated(__post)
#pragma deprecated(__readableTo)
#pragma deprecated(__writableTo)
#pragma deprecated(__maybevalid)
#pragma deprecated(__data_entrypoint)
#pragma deprecated(__inexpressible_readableTo)
#pragma deprecated(__readonly)
#pragma deprecated(__byte_writableTo)
#pragma deprecated(__byte_readableTo)
#pragma deprecated(__elem_readableTo)
#pragma deprecated(__elem_writableTo)
#pragma deprecated(__valid)
#pragma deprecated(__notvalid)
#pragma deprecated(__refparam)
#pragma deprecated(__precond)
#endif
/* Define soon to be deprecated macros to nops. */
#define __in_nz                                       
#define __in_ecount_nz(size)                          
#define __in_bcount_nz(size)                          
#define __out_nz                                      
#define __out_nz_opt                                  
#define __out_ecount_nz(size)                         
#define __out_bcount_nz(size)                         
#define __inout_nz                                    
#define __inout_ecount_nz(size)                       
#define __inout_bcount_nz(size)                       
#define __in_nz_opt                                   
#define __in_ecount_nz_opt(size)                      
#define __in_bcount_nz_opt(size)                      
#define __out_ecount_nz_opt(size)                     
#define __out_bcount_nz_opt(size)                     
#define __inout_nz_opt                                
#define __inout_ecount_nz_opt(size)                   
#define __inout_bcount_nz_opt(size)                   
#define __deref_out_nz                                
#define __deref_out_ecount_nz(size)                   
#define __deref_out_bcount_nz(size)                   
#define __deref_inout_nz                              
#define __deref_inout_ecount_nz(size)                 
#define __deref_inout_bcount_nz(size)                 
#define __deref_out_nz_opt                            
#define __deref_out_ecount_nz_opt(size)               
#define __deref_out_bcount_nz_opt(size)               
#define __deref_inout_nz_opt                          
#define __deref_inout_ecount_nz_opt(size)             
#define __deref_inout_bcount_nz_opt(size)             
#define __deref_opt_inout_nz                          
#define __deref_opt_inout_ecount_nz(size)             
#define __deref_opt_inout_bcount_nz(size)             
#define __deref_opt_out_nz_opt                        
#define __deref_opt_out_ecount_nz_opt(size)           
#define __deref_opt_out_bcount_nz_opt(size)           
#define __deref_opt_inout_nz_opt                      
#define __deref_opt_inout_ecount_nz_opt(size)         
#define __deref_opt_inout_bcount_nz_opt(size)         
#define __deref             
#define __pre               
#define __post              
#define __readableTo(count) 
#define __writableTo(count) 
#define __maybevalid        
#define __inexpressible_readableTo(string) 
#define __data_entrypoint(category)
#define __readonly
#define __byte_writableTo(count)
#define __byte_readableTo(count)
#define __elem_readableTo(count)
#define __elem_writableTo(count)
#define __valid
#define __notvalid
#define __refparam
#define __precond(condition)

/************************************************************************* 
* Definitions to force a compile error when macros are used improperly.
* Relies on VS 2005 source annotations.
*************************************************************************/
#if !defined(_MSC_EXTENSIONS) && !defined(_PREFAST_) && !defined(OACR)
#define __allowed(p) /* nothing */
#else
#define __allowed(p) __$allowed_##p
#define __$allowed_as_global_decl /* empty */
#define __$allowed_as_statement_with_arg(x) \
    __pragma(warning(push)) __pragma(warning(disable : 4548)) \
        do {__noop(x);} while((0,0) __pragma(warning(pop)) )
#define __$allowed_as_statement __$allowed_as_statement_with_arg(1)

/**************************************************************************
*  This should go away. It's only for __success which we should split into.
*  __success and __typdecl_sucess
***************************************************************************/
#define __$allowed_on_function_or_typedecl /* empty */
#if (__SPECSTRINGS_STRICT_LEVEL == 1) || (__SPECSTRINGS_STRICT_LEVEL == 2)
#define __$allowed_on_typedecl /* empty */
#define __$allowed_on_return /* empty */
#define __$allowed_on_parameter /* empty */
#define __$allowed_on_function /* empty */
#define __$allowed_on_struct /* empty */
#define __$allowed_on_field /* empty */
#define __$allowed_on_parameter_or_return /* empty */
#define __$allowed_on_global_or_field /* empty */
#elif __SPECSTRINGS_STRICT_LEVEL == 3
#define __$allowed_on_typedecl /* empty */
/* Define dummy source attributes. Still needs more testing */
#define __$allowed_on_return [returnvalue: OnReturnOnly]
#define __$allowed_on_parameter [OnParameterOnly]
#define __$allowed_on_function [method: OnFunctionOnly]
#define __$allowed_on_struct [OnStructOnly]
#define __$allowed_on_field [OnFieldOnly]
#define __$allowed_on_parameter_or_return [OnParameterOrReturnOnly] 
#define __$allowed_on_global_or_field /* empty */
#pragma push_macro( "DECL_SA" )
#pragma push_macro( "SA" )
#ifdef __cplusplus
#define SA(x) x
#define DECL_SA(name,loc) \
  [repeatable] \
  [source_annotation_attribute( loc )] \
  struct name##Attribute { name##Attribute(); const char* ignored; }; 
#else
#define SA(x) SA_##x
#define DECL_SA(name,loc) \
  [source_annotation_attribute( loc )] \
  struct name { const char* ignored; };\
  typedef struct name name;
#endif  /* #endif  __cplusplus */
DECL_SA(OnParameterOnly,SA(Parameter));
DECL_SA(OnReturnOnly,SA(ReturnValue));
DECL_SA(OnFunctionOnly,SA(Method));
DECL_SA(OnStructOnly,SA(Struct));
DECL_SA(OnFieldOnly,SA(Field));
DECL_SA(OnParameterOrReturnOnly,SA(Parameter) | SA(ReturnValue));
#pragma pop_macro( "SA" )
#pragma pop_macro( "DECL_SA" )
#endif 
#endif 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\speventq.h ===
/*******************************************************************************
// Copyright Microsoft Corporation. All Rights Reserved. 
* SPEventQ.h *
*------------*
*   Description:
*       This is the header file for the SAPI5 event queue implementation.
*-------------------------------------------------------------------------------
*******************************************************************************/
#ifndef SPEventQ_h
#define SPEventQ_h

#ifndef SPHelper_h
#include <SPHelper.h>
#endif

#ifdef SOFTWARE_TRACING
#include <speventq.tmh>
#endif

//=== Inline helpers for copying and deleting events ============================


//=== Class definition ==========================================================




// This class wraps the SPEVENTEX structure providing a next pointer to allow it to be used in queues;
// and helper methods to serialize and deserialize.
// This has some similar code to CSpEvent in sphelper.h, but that method is public and not based on
// SPEVENTEX.
class CSpEventExNode : public SPEVENTEX
{
public:
    CSpEventExNode()
    {
        memset(this, 0, sizeof(SPEVENTEX));
    }
    ~CSpEventExNode()
    {
        Clear();
    }

    CSpEventExNode    * m_pNext;

    static LONG Compare(const CSpEventExNode * p1, const CSpEventExNode *p2)
    {
        // Assumes offsets DO or DO NOT reset when stream number changes
        if (p1->ulStreamNum < p2->ulStreamNum)
        {
            return -1;
        }
        else if (p1->ulStreamNum > p2->ulStreamNum)
        {
            return 1;
        }
        else if (p1->ullAudioStreamOffset < p2->ullAudioStreamOffset)
        {
            return -1;
        }
        else if (p1->ullAudioStreamOffset > p2->ullAudioStreamOffset)
        {
            return 1;
        }
        return 0;
    }

    // Clears the event and releases associated memory
    void Clear()
    {
        if (elParamType != SPEI_UNDEFINED)
        {
            if (elParamType == SPET_LPARAM_IS_POINTER ||
                elParamType == SPET_LPARAM_IS_STRING)
            {
                ::CoTaskMemFree((void *)lParam);
            }
            else if (elParamType == SPET_LPARAM_IS_TOKEN ||
                elParamType == SPET_LPARAM_IS_OBJECT)
            {
                ((IUnknown*)lParam)->Release();
            }
        }
        memset(this, 0, sizeof(SPEVENTEX));
    }

    // Copy data from this class to an SPEVENTEX, making new copies of associated memory
    HRESULT CopyTo(SPEVENTEX * pDestEvent) const
    {
        memcpy(pDestEvent, this, sizeof(*pDestEvent));
        if ((elParamType == SPET_LPARAM_IS_POINTER) && lParam)
        {
            _ASSERT(wParam && (wParam < 0x100000));    // this is too big!
            pDestEvent->lParam = (LPARAM)::CoTaskMemAlloc(wParam);
            if (pDestEvent->lParam)
            {
                memcpy((void *)pDestEvent->lParam, (void *)lParam, wParam);
            }
            else
            {
                pDestEvent->eEventId = SPEI_UNDEFINED;
                return E_OUTOFMEMORY;
            }
        }
        else if (elParamType == SPET_LPARAM_IS_STRING && lParam != NULL)
        {
			size_t cbLen = (wcslen((WCHAR*)lParam) + 1) * sizeof(WCHAR);
            pDestEvent->lParam = (LPARAM)::CoTaskMemAlloc(cbLen);
            if (pDestEvent->lParam)
            {
                StringCbCopyW ((WCHAR*)pDestEvent->lParam, cbLen, (WCHAR*)lParam);
            }
            else
            {
                pDestEvent->eEventId = SPEI_UNDEFINED;
                return E_OUTOFMEMORY;
            }
        }
        else if (elParamType == SPET_LPARAM_IS_TOKEN ||
               elParamType == SPET_LPARAM_IS_OBJECT)
        {
            ((IUnknown*)lParam)->AddRef();
        }
        return S_OK;
    }

    // Initialize this object from an existing SPEVENTEX, copying associated memory
    HRESULT CopyFrom(const SPEVENTEX * pSrcEvent)
    {
        Clear();
        return static_cast<const CSpEventExNode *>(pSrcEvent)->CopyTo(this);
    }

    // Finds the additional size of data needed to be appended to the end of the event when serializing
    ULONG ExtraDataSize() const
    {
        ULONG ulSize = 0;

        if( ( elParamType == SPET_LPARAM_IS_POINTER ) && lParam )
        {
            ulSize += ULONG(wParam);
        }
        else if ((elParamType == SPET_LPARAM_IS_STRING) && lParam != NULL)
        {
            // Would be better to check for overflow of string length.
            ulSize += ((ULONG) wcslen((WCHAR*)lParam) + 1) * sizeof( WCHAR );
        }
        else if( elParamType == SPET_LPARAM_IS_TOKEN )
        {
            CSpDynamicString dstrObjectId;
            if( ((ISpObjectToken*)(lParam))->GetId( &dstrObjectId ) == S_OK )
            {
                ulSize += (dstrObjectId.Length() + 1) * sizeof( WCHAR );
            }
            else
            {
                return (ULONG)-1;
            }
        }
        // Round up to nearest DWORD
        ulSize += 3;
        ulSize -= ulSize % 4;
        return ulSize;
    }

    // Size of SPSERIALIZEDEVENT64 with ullAudioTimeOffset appended
    ULONG SerializeSizeEx() const
    {
        ULONG ulSize = ExtraDataSize();
        return (ulSize == (ULONG)-1) ? 0 : sizeof(SPSERIALIZEDEVENT64) + ulSize + sizeof(ULONGLONG);
    }

    // Size of regular 32 bit SPSERIALIZEDEVENT
    ULONG SerializeSize() const
    {
        ULONG ulSize = ExtraDataSize();
        return (ulSize == (ULONG)-1) ? 0 : sizeof(SPSERIALIZEDEVENT) + ulSize;
    }

    // Call this method with either SPSERIALIZEDEVENT or SPSERIALIZEDEVENT64
    template <class T>
    HRESULT Serialize(T * pSerEvent) const
    {
        HRESULT hr = S_OK;

        _ASSERT(elParamType != SPET_LPARAM_IS_OBJECT);
        pSerEvent->eEventId = this->eEventId;
        pSerEvent->elParamType = this->elParamType;
        pSerEvent->ulStreamNum = this->ulStreamNum;
        pSerEvent->ullAudioStreamOffset = this->ullAudioStreamOffset;
        SerializeParams(pSerEvent);
        if (lParam)
        {
            switch(elParamType)
            {
            case SPET_LPARAM_IS_POINTER:
                memcpy(pSerEvent + 1, (void *)lParam, wParam);
                pSerEvent->SerializedlParam = sizeof(T);
                break;

            case SPET_LPARAM_IS_STRING:
                StringCchCopyW ((WCHAR *)(pSerEvent + 1), wcslen ((WCHAR*) lParam) + 1, (WCHAR*)lParam);

                pSerEvent->SerializedlParam = sizeof(T);
                break;

            case SPET_LPARAM_IS_TOKEN:
                {
                    CSpDynamicString dstrObjectId;
                    hr = ((ISpObjectToken*)lParam)->GetId( &dstrObjectId );
                    if( SUCCEEDED( hr ) )
                    {
                        pSerEvent->SerializedwParam = (dstrObjectId.Length() + 1) * sizeof( WCHAR );;
                        memcpy( pSerEvent + 1, (void *)dstrObjectId.m_psz, static_cast<ULONG>(pSerEvent->SerializedwParam) );
                    }
                    pSerEvent->SerializedlParam = sizeof(T);
                }
                break;

            default:
                break;
            }
        }
        return hr;
    }

    void SerializeParams(__unaligned SPSERIALIZEDEVENT * pSerEvent) const
    {
        pSerEvent->SerializedwParam = (ULONG)this->wParam;
        pSerEvent->SerializedlParam = (LONG)this->lParam;
    }

    void SerializeParams(__unaligned SPSERIALIZEDEVENT64 * pSerEvent) const
    {
        pSerEvent->SerializedwParam = (ULONGLONG)this->wParam;
        pSerEvent->SerializedlParam = (LONGLONG)this->lParam;
    }

    // Serialize into an SPSERIALIZEDEVENT64 structure. The ullAudioTimeOffset field is appended at 
    // the end of the other serialized data. This is to make this structure binary compatible with SAPI 5.1
    // code trying to deserialize it.
    HRESULT SerializeEx(SPSERIALIZEDEVENT64* pSerEvent) const
    {
        ULONG ulSize = SerializeSizeEx();
        if (ulSize == 0) 
        {
            return E_FAIL;
        }
        *(UNALIGNED ULONGLONG*)((BYTE*)pSerEvent + ulSize - sizeof(ULONGLONG)) = ullAudioTimeOffset;
        return Serialize(pSerEvent);
    }

    // Deserialize into this class, assuming ullAudioTimeOffset included
    HRESULT DeserializeEx(const SPSERIALIZEDEVENT64 *pSerEvent, ULONG cbSize)
    {
        Clear();
        HRESULT hr = S_OK;
        const UNALIGNED SPSERIALIZEDEVENT64 * pTemp = pSerEvent;
        if (cbSize < sizeof(*pTemp) + sizeof(ULONGLONG))
        {
            return E_INVALIDARG;
        }
        size_t cbExtraSize = cbSize - sizeof(*pTemp) - sizeof(ULONGLONG);

        this->eEventId = pTemp->eEventId;
        this->elParamType = pTemp->elParamType;
        this->ulStreamNum = pTemp->ulStreamNum;
        this->ullAudioStreamOffset = pTemp->ullAudioStreamOffset;
        this->wParam = static_cast<WPARAM>(pTemp->SerializedwParam);
        this->lParam = static_cast<LPARAM>(pTemp->SerializedlParam);
        size_t cbAlloc = 0;

        if (pTemp->SerializedlParam)
        {
            switch (pTemp->elParamType)
            {
            case SPET_LPARAM_IS_POINTER:
                cbAlloc = static_cast<ULONG>(wParam);
                if (cbAlloc > cbExtraSize)
                {
                    hr = E_INVALIDARG;
                }
                break;

            case SPET_LPARAM_IS_STRING:
                hr = CheckStringSizeBytes((WCHAR *)(pTemp + 1), cbExtraSize, &cbAlloc);
                break;

            case SPET_LPARAM_IS_TOKEN:
                {
                    hr = CheckStringSizeBytes((WCHAR *)(pTemp + 1), cbExtraSize, NULL);
                    if (SUCCEEDED(hr))
                    {
                        hr = SpGetTokenFromId( (const WCHAR*)(pTemp + 1), (ISpObjectToken **)&lParam );
                        wParam = 0;
                    }
                }
                break;
            case SPET_LPARAM_IS_UNDEFINED:
                break;
            case SPET_LPARAM_IS_OBJECT:
                hr = E_INVALIDARG;
                break;
            default:
                hr = E_INVALIDARG;
                break;
            }

            if (SUCCEEDED(hr) && cbAlloc)
            {
                void * pvBuff = ::CoTaskMemAlloc(cbAlloc);
                this->lParam = (LPARAM)pvBuff;
                if (pvBuff)
                {
                    memcpy(pvBuff, pTemp + 1, cbAlloc);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            ullAudioTimeOffset = *(UNALIGNED ULONGLONG*)((BYTE*)pTemp + cbSize - sizeof(ULONGLONG));
            _ASSERT(cbSize == SerializeSizeEx());
        }
        else
        {
            memset(this, 0, sizeof(*this));
        }

        return hr;
    }
};



typedef CSpBasicQueue<CSpEventExNode, TRUE, TRUE> CSpEventList;

#define DECLARE_SPNOTIFYSOURCE_METHODS(T) \
STDMETHODIMP SetNotifySink(ISpNotifySink * pNotifySink) \
{ return T._SetNotifySink(pNotifySink); } \
STDMETHODIMP SetNotifyWindowMessage(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam) \
{ return T._SetNotifyWindowMessage(hWnd, Msg, wParam, lParam); } \
STDMETHODIMP SetNotifyCallbackFunction(SPNOTIFYCALLBACK * pfnCallback, WPARAM wParam, LPARAM lParam) \
{ return T._SetNotifyCallbackFunction(pfnCallback, wParam, lParam); } \
STDMETHODIMP SetNotifyCallbackInterface(ISpNotifyCallback * pSpCallback, WPARAM wParam, LPARAM lParam) \
{ return T._SetNotifyCallbackInterface(pSpCallback, wParam, lParam); } \
STDMETHODIMP SetNotifyWin32Event() \
{ return T._SetNotifyWin32Event(); } \
STDMETHODIMP WaitForNotifyEvent(DWORD dwMilliseconds) \
{ return T._WaitForNotifyEvent(dwMilliseconds); } \
STDMETHODIMP_(HANDLE) GetNotifyEventHandle() \
{ return T._GetNotifyEventHandle(); } 

#define DECLARE_SPEVENTSOURCE_METHODS(T) \
DECLARE_SPNOTIFYSOURCE_METHODS(T) \
STDMETHODIMP SetInterest(ULONGLONG ullEventInterest, ULONGLONG ullQueuedInterest) \
{ return T._SetInterest(ullEventInterest, ullQueuedInterest); } \
STDMETHODIMP GetEvents(ULONG ulCount, SPEVENT* pEventArray, ULONG * pulFetched) \
{ return T._GetEvents(ulCount, pEventArray, pulFetched); } \
STDMETHODIMP GetInfo(SPEVENTSOURCEINFO *pInfo) \
{ return T._GetInfo(pInfo); }



class CSpEventSource 
{
  public:
    CSpEventSource(CComObjectRootEx<CComMultiThreadModel> * pParent, bool fSortEvents = true) :
        m_pParent(pParent),
        m_fSortEvents(fSortEvents)
    {
        m_ullEventInterest = 0; m_ullQueuedInterest = 0;
        m_ulStreamNum = 0;
    }
    HRESULT _SetNotifySink(ISpNotifySink * pNotifySink);
    HRESULT _SetNotifyWindowMessage(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
    HRESULT _SetNotifyCallbackFunction(SPNOTIFYCALLBACK * pfnCallback, WPARAM wParam, LPARAM lParam);
    HRESULT _SetNotifyCallbackInterface(ISpNotifyCallback * pSpCallback, WPARAM wParam, LPARAM lParam);
    HRESULT _SetNotifyWin32Event();
    HRESULT _WaitForNotifyEvent(DWORD dwMilliseconds);
    HANDLE  _GetNotifyEventHandle();

    HRESULT _SetInterest(ULONGLONG ullEventInterest , ULONGLONG ullQueuedInterest);

    template <class T>
    inline HRESULT _GetEvents( ULONG ulCount, T* pEventArray, ULONG *pulFetched )
    {
        HRESULT hr = S_OK;
        m_pParent->Lock();
        if( SPIsBadWritePtr( pEventArray, sizeof(T) * ulCount ) ||
            SP_IS_BAD_OPTIONAL_WRITE_PTR(pulFetched) )
        {
            hr = E_INVALIDARG;
        }
        else 
        {
            ULONG ulCopied = 0;
            ULONG ulRemaining = ulCount;
            CSpEventExNode * pCur = m_CompletedList.m_pHead;
            CSpEventExNode * pLastCopied = NULL;
            while (ulRemaining && pCur)
            {
#ifdef SOFTWARE_TRACING
                if(pCur->eEventId == SPEI_RECOGNITION || pCur->eEventId == SPEI_FALSE_RECOGNITION || pCur->eEventId == SPEI_RECOGNITION_ALL)
                {
                    DoTraceMessage(Trace_Verbose, "CpEventSource::Removed event with offset %I64u and Id %u from queue",pCur->ullAudioStreamOffset,pCur->eEventId);
                }
#endif

                // Detach the event into the passed in array and clear our copy
                memcpy(pEventArray + ulCopied, pCur, sizeof(T));
                memset((SPEVENTEX*)pCur, 0, sizeof(SPEVENTEX));

                pLastCopied = pCur;
                ulCopied++;
                pCur = pCur->m_pNext;
                ulRemaining--;
            }
            if (ulCopied)
            {
                if (m_FreeList.m_pHead == NULL)
                {
                    m_FreeList.m_pTail = pLastCopied;
                }
                pLastCopied->m_pNext = m_FreeList.m_pHead;
                m_FreeList.m_pHead = m_CompletedList.m_pHead;
                m_CompletedList.m_pHead = pCur;
                m_CompletedList.m_cElements -= ulCopied;
                m_FreeList.m_cElements += ulCopied;
            }
            if (ulCopied < ulCount)
            {
                hr = S_FALSE;
            }
            if (pulFetched) 
            {
                *pulFetched = ulCopied;
            }
        }
        m_pParent->Unlock();
        return hr;
    }


    HRESULT _GetInfo(SPEVENTSOURCEINFO *pInfo );

    /*--- Non interface methods ---*/
    HRESULT _CompleteEvents( ULONGLONG ullPos = 0xFFFFFFFFFFFFFFFF );
    inline void _MoveAllToFreeList(CSpEventList * pList);
    inline void _RemoveAllEvents();
    inline HRESULT _AddEvent(const SPEVENTEX & Event);
    inline HRESULT _AddEvents(const SPEVENT* pEventArray, ULONG ulCount);
    inline HRESULT _AddEvents(const SPEVENTEX* pEventArray, ULONG ulCount);
    inline HRESULT _GetStreamNumber(const ULONGLONG ullAudioOffset, ULONG *pulStreamNum);
    //=== Data members ==============================
  public:
    ULONGLONG                   m_ullEventInterest;
    ULONGLONG                   m_ullQueuedInterest;
    ULONG                       m_ulStreamNum;
    CSpEventList                m_PendingList;
    CSpEventList                m_CompletedList;
    CSpEventList                m_FreeList;
    CComPtr<ISpNotifySink>      m_cpNotifySink;
    CComPtr<ISpNotifyTranslator> m_cpEventTranslator;   // If non-NULL then Win32 events being used
    CComObjectRootEx<CComMultiThreadModel> * m_pParent;
    CComAutoCriticalSection     m_NotifyObjChangeCrit;  // Critical section used to make sure that
                                                        // the notify object (m_cpNotifySink) not changed
                                                        // while waiting on it.
  private:
    bool                        m_fSortEvents;

};


//
//=== Inlines =========================================================
//

//
//  WARNING:  If this logic changes, you will need to change the logic in SetNotifyWin32Event also.
//
inline HRESULT CSpEventSource::_SetNotifySink(ISpNotifySink * pNotifySink)
{
    if (SP_IS_BAD_OPTIONAL_INTERFACE_PTR(pNotifySink))
    {
        return E_INVALIDARG;
    }
    else
    {
        m_pParent->Lock();
        m_NotifyObjChangeCrit.Lock();
        m_cpEventTranslator.Release();
        m_cpNotifySink = pNotifySink;
        if (m_cpNotifySink && m_CompletedList.GetHead())
        {
            m_cpNotifySink->Notify();
        }
        m_NotifyObjChangeCrit.Unlock();
        m_pParent->Unlock();
        return S_OK;
    }
}

/****************************************************************************
* CSpEventSource::_SetNotifyWindowMessage *
*-----------------------------------------*
*   Description:
*
*   Returns:
*
*****************************************************************************/

inline HRESULT CSpEventSource::_SetNotifyWindowMessage(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{

    HRESULT hr = S_OK;
    CComPtr<ISpNotifyTranslator> cpTranslator;
    hr = cpTranslator.CoCreateInstance(CLSID_SpNotifyTranslator);
    if (SUCCEEDED(hr))
    {
        hr = cpTranslator->InitWindowMessage(hWnd, Msg, wParam, lParam);
    }
    if (SUCCEEDED(hr))
    {
        hr = _SetNotifySink(cpTranslator);
    }
    return hr;
}
/****************************************************************************
* CSpEventSource::_SetNotifyCallbackFunction *
*--------------------------------------------*
*   Description:
*
*   Returns:
*
*****************************************************************************/

inline HRESULT CSpEventSource::_SetNotifyCallbackFunction(SPNOTIFYCALLBACK * pfnCallback, WPARAM wParam, LPARAM lParam)
{

    HRESULT hr = S_OK;
    CComPtr<ISpNotifyTranslator> cpTranslator;
    hr = cpTranslator.CoCreateInstance(CLSID_SpNotifyTranslator);
    if (SUCCEEDED(hr))
    {
        hr = cpTranslator->InitCallback(pfnCallback, wParam, lParam);
    }
    if (SUCCEEDED(hr))
    {
        hr = _SetNotifySink(cpTranslator);
    }
    return hr;
}
/****************************************************************************
* CSpEventSource::_SetNotifyCallbackInterface *
*---------------------------------------------*
*   Description:
*
*   Returns:
*
*****************************************************************************/

inline HRESULT CSpEventSource::_SetNotifyCallbackInterface(ISpNotifyCallback * pSpCallback, WPARAM wParam, LPARAM lParam)
{

    HRESULT hr = S_OK;
    CComPtr<ISpNotifyTranslator> cpTranslator;
    hr = cpTranslator.CoCreateInstance(CLSID_SpNotifyTranslator);
    if (SUCCEEDED(hr))
    {
        hr = cpTranslator->InitSpNotifyCallback(pSpCallback, wParam, lParam);
    }
    if (SUCCEEDED(hr))
    {
        hr = _SetNotifySink(cpTranslator);
    }
    return hr;
}
/****************************************************************************
* CSpEventSource::_SetNotifyWin32Event *
*--------------------------------------*
*   Description:
*
*   Returns:
*
*****************************************************************************/

inline HRESULT CSpEventSource::_SetNotifyWin32Event(void)
{

    HRESULT hr = S_OK;
    CComPtr<ISpNotifyTranslator> cpTranslator;
    hr = cpTranslator.CoCreateInstance(CLSID_SpNotifyTranslator);
    if (SUCCEEDED(hr))
    {
        hr = cpTranslator->InitWin32Event(NULL, TRUE);
    }
    if (SUCCEEDED(hr))
    {
        //
        //  In this case we do NOT call _SetNotify sink since we want to set the cpEventTranslator
        //
        m_pParent->Lock();
        m_NotifyObjChangeCrit.Lock();
        m_cpEventTranslator = cpTranslator;
        m_cpNotifySink = cpTranslator;
        if (m_cpNotifySink && m_CompletedList.GetHead())
        {
            m_cpNotifySink->Notify();
        }
        m_NotifyObjChangeCrit.Unlock();
        m_pParent->Unlock();
    }
    return hr;
}
/****************************************************************************
* CSpEventSource::_WaitForNotifyEvent *
*-------------------------------------*
*   Description:
*
*   Returns:
*
*****************************************************************************/

inline HRESULT CSpEventSource::_WaitForNotifyEvent(DWORD dwMilliseconds)
{

    HRESULT hr = S_OK;
    m_NotifyObjChangeCrit.Lock();
    if (m_cpEventTranslator)
    {
        hr = m_cpEventTranslator->Wait(dwMilliseconds);
    }
    else
    {
        if (m_cpNotifySink)
        {
            hr = SPERR_ALREADY_INITIALIZED;
        }
        else
        {
            hr = _SetNotifyWin32Event();
            if (SUCCEEDED(hr))
            {
                hr = m_cpEventTranslator->Wait(dwMilliseconds);
            }
        }
    }
    m_NotifyObjChangeCrit.Unlock();
    return hr;
}
/****************************************************************************
* CSpEventSource::_GetNotifyEventHandle *
*---------------------------------------*
*   Description:
*
*   Returns:
*
*****************************************************************************/

inline HANDLE CSpEventSource::_GetNotifyEventHandle()
{
    HANDLE h = NULL;

    m_NotifyObjChangeCrit.Lock();
    if (!m_cpNotifySink)
    {
        _SetNotifyWin32Event();
    }
    if (m_cpEventTranslator)
    {
        h = m_cpEventTranslator->GetEventHandle();
    }
    m_NotifyObjChangeCrit.Unlock();
    return h;
}


inline HRESULT CSpEventSource::_SetInterest( ULONGLONG ullEventInterest, ULONGLONG ullQueuedInterest )
{
    HRESULT hr = S_OK;
    m_pParent->Lock();

    if(ullEventInterest && SPFEI_FLAGCHECK != (ullEventInterest & SPFEI_FLAGCHECK))
    {
        hr = E_INVALIDARG;
    }
    else if(ullQueuedInterest && SPFEI_FLAGCHECK != (ullQueuedInterest & SPFEI_FLAGCHECK))
    {
        hr = E_INVALIDARG;
    }
    else if ((ullQueuedInterest | ullEventInterest) != ullEventInterest)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        m_ullEventInterest = ullEventInterest;
        m_ullQueuedInterest = ullQueuedInterest;
    }
    m_pParent->Unlock();
    return hr;
}


//
//  Same as AddEvents except:  No param validation, and caller must take the critical section
//  prior to calling.
//
inline HRESULT CSpEventSource::_AddEvents( const SPEVENT* pEventArray, ULONG ulCount )
{
    HRESULT hr = S_OK;
    for( ULONG i = 0; i < ulCount && SUCCEEDED(hr); ++i )
    {
        SPEVENTEX EventEx;
        memcpy(&EventEx, pEventArray + i, sizeof(SPEVENT));
        EventEx.ullAudioTimeOffset = 0; // We set the audio time to zero if no information available
        hr = _AddEvent(EventEx);
    }
    return hr;
}

inline HRESULT CSpEventSource::_AddEvents( const SPEVENTEX* pEventArray, ULONG ulCount )
{
    HRESULT hr = S_OK;
    for( ULONG i = 0; i < ulCount && SUCCEEDED(hr = _AddEvent(pEventArray[i])); ++i ) {}
    return hr;
}

inline HRESULT CSpEventSource::_AddEvent(const SPEVENTEX & Event)
{
    _ASSERT(Event.eEventId < 64);
    _ASSERT(Event.elParamType == SPET_LPARAM_IS_UNDEFINED ||
                 Event.elParamType == SPET_LPARAM_IS_TOKEN ||
                 Event.elParamType == SPET_LPARAM_IS_OBJECT ||
                 Event.elParamType == SPET_LPARAM_IS_POINTER ||
                 Event.elParamType == SPET_LPARAM_IS_STRING);
#ifdef _DEBUG
    if (Event.eEventId == SPEI_VOICE_CHANGE)
    {
        _ASSERT(Event.elParamType == SPET_LPARAM_IS_TOKEN);
    }
    else if (Event.eEventId == SPEI_RECOGNITION || Event.eEventId == SPEI_FALSE_RECOGNITION || Event.eEventId == SPEI_HYPOTHESIS)
    {
        _ASSERT(Event.elParamType == SPET_LPARAM_IS_OBJECT);
    }
    else if (Event.eEventId ==SPEI_REQUEST_UI || Event.eEventId == SPEI_TTS_BOOKMARK)
    {
        _ASSERT(Event.elParamType == SPET_LPARAM_IS_STRING);
    }
#endif

    if ( (1i64 << Event.eEventId) & m_ullEventInterest )
    {
        CSpEventExNode *pNode = m_FreeList.RemoveHead();
        if (pNode == NULL)
        {
            pNode = new CSpEventExNode();
            if (pNode == NULL)
            {
                return E_OUTOFMEMORY;
            }
        }
        pNode->CopyFrom(&Event);
        if (m_fSortEvents)
        {
            m_PendingList.InsertSorted(pNode);
        }
        else
        {
            m_PendingList.InsertTail(pNode);
        }
    }
    return S_OK;
}


inline HRESULT CSpEventSource::_GetInfo( SPEVENTSOURCEINFO * pInfo )
{
    HRESULT hr = S_OK;
    m_pParent->Lock();    
    if( SP_IS_BAD_WRITE_PTR( pInfo ) )
    {
        hr = E_POINTER;
    }
    else
    {
        pInfo->ulCount = m_CompletedList.GetCount();
        pInfo->ullEventInterest = m_ullEventInterest;
        pInfo->ullQueuedInterest= m_ullQueuedInterest;
    }
    m_pParent->Unlock();
    return hr;
}



//
//  The caller must call this function with the critical section owned
//
inline HRESULT CSpEventSource::_CompleteEvents( ULONGLONG ullPos )
{
    HRESULT hr = S_OK;

    if (m_PendingList.m_pHead && m_PendingList.m_pHead->ullAudioStreamOffset <= ullPos)
    {
        BOOL bNotify = FALSE;
        while (m_PendingList.m_pHead &&
               m_PendingList.m_pHead->ullAudioStreamOffset <= ullPos)
        {
            CSpEventExNode *pNode = m_PendingList.RemoveHead();
            if(pNode->ulStreamNum != m_ulStreamNum)
            {
                m_ulStreamNum = pNode->ulStreamNum;
            }
            if ( (1i64 << pNode->eEventId) & m_ullEventInterest )
            {
                bNotify = TRUE;
                //
                //  NOTE:  If we're forwarding events to an event sink then we'll only
                //  pay attention to the Interest flags.  If we're going to notify, then
                //  we'll only queue completed events that the user has explicitly asked
                //  us to store as completed events.
                //
                if ( (1i64 << pNode->eEventId) & m_ullQueuedInterest )
                {
                    if (m_fSortEvents)
                    {
                        m_CompletedList.InsertSorted(pNode);
                    }
                    else
                    {
                        m_CompletedList.InsertTail(pNode);
                    }
#ifdef SOFTWARE_TRACING
                    if(pNode->eEventId == SPEI_RECOGNITION || pNode->eEventId == SPEI_FALSE_RECOGNITION || pNode->eEventId == SPEI_RECOGNITION_ALL)
                    {
                        DoTraceMessage(Trace_Verbose, "CpEventSource::Added reco event with offset %I64u and event id %u to queue",pNode->ullAudioStreamOffset,pNode->eEventId);
                    }
#endif
                }
                else
                {
                    pNode->Clear();
                    m_FreeList.InsertHead(pNode);
                }
            }
            else
            {
                pNode->Clear();
                m_FreeList.InsertHead(pNode);
            }
        }    
        if (bNotify && m_cpNotifySink)
        {
            hr = m_cpNotifySink->Notify();
        }
    }
    return hr;
};


inline void CSpEventSource::_MoveAllToFreeList(CSpEventList * pList)
{
    CSpEventExNode * pNode;
    while ((pNode = pList->RemoveHead()) != NULL)
    {
        pNode->Clear();
        m_FreeList.InsertHead(pNode);
    }
}
inline void CSpEventSource::_RemoveAllEvents( )
{
    m_pParent->Lock();

    _MoveAllToFreeList(&m_CompletedList);
    _MoveAllToFreeList(&m_PendingList);
    m_pParent->Unlock();
}

inline HRESULT CSpEventSource::_GetStreamNumber(const ULONGLONG ullAudioOffset, ULONG *pulStreamNum)
{
    CSpEventExNode *pNode = m_PendingList.m_pHead;
    *pulStreamNum = m_ulStreamNum;
    for(;pNode && pNode->ullAudioStreamOffset <= ullAudioOffset; pNode = pNode->m_pNext)
    {
        *pulStreamNum = pNode->ulStreamNum;
    }
    return S_OK;
}



#endif //--- This must be the last line in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\specstrings_adt.h ===
#pragma once
/*************************************************************************
* DEFINITIONS OF NEW TYPES 
*************************************************************************/
#if !defined(__midl)
#if defined(_MSC_EXTENSIONS) || defined(_PREFAST_) || defined(OACR)
#define __$compname_props \
        __type_has_adt_prop(compname,nullterminated) \
        __type_has_adt_prop(compname,valid_schars) \
        __type_has_adt_prop(compname,correct_len) \
        __nullterminated
#if defined(UNICODE) || defined(_UNICODE)
#define  __$TCHAR unsigned short
#else
#define  __$TCHAR char
#endif
typedef __$compname_props char* ValidCompNameA;
typedef __$compname_props unsigned short* ValidCompNameW;
typedef __$compname_props const unsigned short* ConstValidCompNameW;
typedef __$compname_props  __$TCHAR* SAL_ValidCompNameT;
typedef __$compname_props const  __$TCHAR* SAL_ConstValidCompNameT;
#undef __$compname_props
#undef __$TCHAR
#else
#define SAL_ConstValidCompNameT /* nothing */
#endif
#endif

/*************************************************************************
* DEFINITIONS OF INLINE FUNCTIONS FOR CASTING TO THE NEW TYPES : USER
*************************************************************************/
#if (_MSC_VER >= 1000) && !defined(__midl) && defined(_PREFAST_)
#ifdef  __cplusplus
extern "C" {
#endif
void __inline __nothrow __SAL_ValidCompNameA(__out_has_type_adt_props(ValidCompNameA) const void *expr) { expr;}
void __inline __nothrow __SAL_ValidCompNameW(__out_has_type_adt_props(ValidCompNameW) const void *expr) { expr;}
#ifdef  __cplusplus
}
#endif
#define __assume_ValidCompNameA(expr) __SAL_ValidCompNameA(expr)
#define __assume_ValidCompNameW(expr) __SAL_ValidCompNameW(expr)
#else
#define __assume_ValidCompNameA(expr) 
#define __assume_ValidCompNameW(expr)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\sqltypes.h ===
//-----------------------------------------------------------------------------
// File:			sqltypes.h
//
// Copyright:		Copyright (c) Microsoft Corporation
//
// Contents: 		This file defines the types used in ODBC
//
// Comments:
//
//-----------------------------------------------------------------------------

#ifndef __SQLTYPES
#define __SQLTYPES

/* if ODBCVER is not defined, assume version 3.51 */
#ifndef ODBCVER
#define ODBCVER	0x0351
#endif  /* ODBCVER */

#ifdef __cplusplus
extern "C" { 			/* Assume C declarations for C++   */
#endif  /* __cplusplus */

/* environment specific definitions */
#ifndef EXPORT
#define EXPORT
#endif

#ifdef WIN32
#define SQL_API  __stdcall
#else
#define SQL_API
#endif

#ifndef RC_INVOKED

/* API declaration data types */
typedef unsigned char   SQLCHAR;
#if (ODBCVER >= 0x0300)
typedef signed char     SQLSCHAR;
typedef unsigned char   SQLDATE;
typedef unsigned char   SQLDECIMAL;
typedef double          SQLDOUBLE;
typedef double          SQLFLOAT;
#endif
typedef long            SQLINTEGER;
typedef unsigned long   SQLUINTEGER;

#ifdef _WIN64
typedef INT64           SQLLEN;
typedef UINT64          SQLULEN;
typedef UINT64          SQLSETPOSIROW;
#else
#define SQLLEN          SQLINTEGER
#define SQLULEN         SQLUINTEGER
#define SQLSETPOSIROW   SQLUSMALLINT
#endif

//For Backward compatibility
#ifdef WIN32
typedef SQLULEN			SQLROWCOUNT;
typedef SQLULEN			SQLROWSETSIZE;
typedef SQLULEN			SQLTRANSID;
typedef SQLLEN			SQLROWOFFSET;
#endif

#if (ODBCVER >= 0x0300)
typedef unsigned char   SQLNUMERIC;
#endif
typedef void *          SQLPOINTER;
#if (ODBCVER >= 0x0300)
typedef float           SQLREAL;
#endif
typedef short           SQLSMALLINT;
typedef unsigned short  SQLUSMALLINT;
#if (ODBCVER >= 0x0300)
typedef unsigned char   SQLTIME;
typedef unsigned char   SQLTIMESTAMP;
typedef unsigned char   SQLVARCHAR;
#endif

/* function return type */
typedef SQLSMALLINT     SQLRETURN;

/* generic data structures */
#if (ODBCVER >= 0x0300)
#if defined(WIN32) || defined(_WIN64)
typedef void*					SQLHANDLE;
#else
typedef SQLINTEGER              SQLHANDLE;
#endif	/* defined(WIN32) || defined(_WIN64) */
typedef SQLHANDLE               SQLHENV;
typedef SQLHANDLE               SQLHDBC;
typedef SQLHANDLE               SQLHSTMT;
typedef SQLHANDLE               SQLHDESC;
#else //ODBCVER < 0x0300
#if defined(WIN32) || defined(_WIN64)
typedef void*					SQLHENV;
typedef void*					SQLHDBC;
typedef void*					SQLHSTMT;
#else
typedef SQLINTEGER              SQLHENV;
typedef SQLINTEGER              SQLHDBC;
typedef SQLINTEGER              SQLHSTMT;
#endif  /* defined(WIN32) || defined(_WIN64) */
#endif /* ODBCVER >= 0x0300 */

/* SQL portable types for C */
typedef unsigned char           UCHAR;
typedef signed char             SCHAR;
typedef SCHAR                   SQLSCHAR;
typedef long int                SDWORD;
typedef short int               SWORD;
typedef unsigned long int       UDWORD;
typedef unsigned short int      UWORD;
#ifndef _WIN64
typedef UDWORD                  SQLUINTEGER;
#endif

typedef signed long             SLONG;
typedef signed short            SSHORT;
typedef unsigned long           ULONG;
typedef unsigned short          USHORT;
typedef double                  SDOUBLE;
typedef double            		LDOUBLE;
typedef float                   SFLOAT;

typedef void*              		PTR;

typedef void*              		HENV;
typedef void*              		HDBC;
typedef void*              		HSTMT;

typedef signed short            RETCODE;

#if defined(WIN32) || defined(OS2)
typedef HWND                    SQLHWND;
#elif defined (UNIX)
typedef Widget                  SQLHWND;
#else
/* placehold for future O/S GUI window handle definition */
typedef SQLPOINTER              SQLHWND;
#endif

#ifndef	__SQLDATE
#define	__SQLDATE
/* transfer types for DATE, TIME, TIMESTAMP */
typedef struct tagDATE_STRUCT
{
        SQLSMALLINT    year;
        SQLUSMALLINT   month;
        SQLUSMALLINT   day;
} DATE_STRUCT;

#if (ODBCVER >= 0x0300)
typedef DATE_STRUCT	SQL_DATE_STRUCT;
#endif  /* ODBCVER >= 0x0300 */

typedef struct tagTIME_STRUCT
{
        SQLUSMALLINT   hour;
        SQLUSMALLINT   minute;
        SQLUSMALLINT   second;
} TIME_STRUCT;

#if (ODBCVER >= 0x0300)
typedef TIME_STRUCT	SQL_TIME_STRUCT;
#endif /* ODBCVER >= 0x0300 */

typedef struct tagTIMESTAMP_STRUCT
{
        SQLSMALLINT    year;
        SQLUSMALLINT   month;
        SQLUSMALLINT   day;
        SQLUSMALLINT   hour;
        SQLUSMALLINT   minute;
        SQLUSMALLINT   second;
        SQLUINTEGER    fraction;
} TIMESTAMP_STRUCT;

#if (ODBCVER >= 0x0300)
typedef TIMESTAMP_STRUCT	SQL_TIMESTAMP_STRUCT;
#endif  /* ODBCVER >= 0x0300 */


/*
 * enumerations for DATETIME_INTERVAL_SUBCODE values for interval data types
 * these values are from SQL-92
 */

#if (ODBCVER >= 0x0300)
typedef enum
{
	SQL_IS_YEAR						= 1,
	SQL_IS_MONTH					= 2,
	SQL_IS_DAY						= 3,
	SQL_IS_HOUR						= 4,
	SQL_IS_MINUTE					= 5,
	SQL_IS_SECOND					= 6,
	SQL_IS_YEAR_TO_MONTH			= 7,
	SQL_IS_DAY_TO_HOUR				= 8,
	SQL_IS_DAY_TO_MINUTE			= 9,
	SQL_IS_DAY_TO_SECOND			= 10,
	SQL_IS_HOUR_TO_MINUTE			= 11,
	SQL_IS_HOUR_TO_SECOND			= 12,
	SQL_IS_MINUTE_TO_SECOND			= 13
} SQLINTERVAL;

#endif  /* ODBCVER >= 0x0300 */

#if (ODBCVER >= 0x0300)
typedef struct tagSQL_YEAR_MONTH
{
		SQLUINTEGER		year;
		SQLUINTEGER		month;
} SQL_YEAR_MONTH_STRUCT;

typedef struct tagSQL_DAY_SECOND
{
		SQLUINTEGER		day;
		SQLUINTEGER		hour;
		SQLUINTEGER		minute;
		SQLUINTEGER		second;
		SQLUINTEGER		fraction;
} SQL_DAY_SECOND_STRUCT;

typedef struct tagSQL_INTERVAL_STRUCT
{
	SQLINTERVAL		interval_type;
	SQLSMALLINT		interval_sign;
	union {
		SQL_YEAR_MONTH_STRUCT		year_month;
		SQL_DAY_SECOND_STRUCT		day_second;
	} intval;

} SQL_INTERVAL_STRUCT;

#endif  /* ODBCVER >= 0x0300 */

#endif	/* __SQLDATE	*/

/* the ODBC C types for SQL_C_SBIGINT and SQL_C_UBIGINT */
#if (ODBCVER >= 0x0300)
#if (_MSC_VER >= 900)
#define ODBCINT64	__int64
#endif

/* If using other compilers, define ODBCINT64 to the
	approriate 64 bit integer type */
#ifdef ODBCINT64
typedef ODBCINT64	SQLBIGINT;
typedef unsigned ODBCINT64	SQLUBIGINT;
#endif
#endif  /* ODBCVER >= 0x0300 */

/* internal representation of numeric data type */
#if (ODBCVER >= 0x0300)
#define SQL_MAX_NUMERIC_LEN		16
typedef struct tagSQL_NUMERIC_STRUCT
{
	SQLCHAR		precision;
	SQLSCHAR	scale;
	SQLCHAR		sign;	/* 1 if positive, 0 if negative */
	SQLCHAR		val[SQL_MAX_NUMERIC_LEN];
} SQL_NUMERIC_STRUCT;
#endif  /* ODBCVER >= 0x0300 */

#if (ODBCVER >= 0x0350)
#ifdef GUID_DEFINED
typedef GUID	SQLGUID;
#else
/* size is 16 */
typedef struct  tagSQLGUID
{
    DWORD Data1;
    WORD Data2;
    WORD Data3;
    BYTE Data4[ 8 ];
} SQLGUID;
#endif  /* GUID_DEFINED */
#endif  /* ODBCVER >= 0x0350 */

typedef SQLULEN         BOOKMARK;

#ifdef _WCHAR_T_DEFINED
typedef wchar_t SQLWCHAR;
#else
typedef unsigned short SQLWCHAR;
#endif

#ifdef UNICODE
typedef SQLWCHAR        SQLTCHAR;
#else
typedef SQLCHAR         SQLTCHAR;
#endif  /* UNICODE */


#endif     /* RC_INVOKED */


#ifdef __cplusplus
}                                    /* End of extern "C" { */
#endif  /* __cplusplus */

#endif /* #ifndef __SQLTYPES */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\Sql_1.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    SQL_1.H

Abstract:

    Level 1 Syntax SQL Parser

History:

--*/

#ifndef _SQL_1_H_
#define _SQL_1_H_

struct SQL_LEVEL_1_TOKEN
{
    enum { OP_EXPRESSION = 1, TOKEN_AND, TOKEN_OR, TOKEN_NOT };
    enum { IFUNC_NONE = 0, IFUNC_UPPER = 1, IFUNC_LOWER = 2 };

    int nTokenType; //  OP_EXPRESSION,TOKEN_AND, TOKEN_OR, TOKEN_NOT
    

    // If the field is a OP_EXPRESSION, then the following are used.
    enum { OP_EQUAL = 1, OP_NOT_EQUAL, OP_EQUALorGREATERTHAN,
		       OP_EQUALorLESSTHAN, OP_LESSTHAN, OP_GREATERTHAN, OP_LIKE };
    
    BSTR    pPropertyName;		// Name of the property on which the operator is applied
    int     nOperator;			// Operator that is applied on property
    BOOL	bConstIsStrNumeric;	// True if the vConstValue is a BSTR and is a UINT32 or any 64bit number
	VARIANT vConstValue;		// Value applied by operator
    BSTR    pPropName2;         // Property compared to.

    DWORD   dwPropertyFunction; // 0=no instrinsic function applied
    DWORD   dwConstFunction;    // "
    
    SQL_LEVEL_1_TOKEN();
    SQL_LEVEL_1_TOKEN(SQL_LEVEL_1_TOKEN&);
   ~SQL_LEVEL_1_TOKEN(); 
    SQL_LEVEL_1_TOKEN& operator=(SQL_LEVEL_1_TOKEN &Src);
    
    void Dump(FILE *);
};


// Contains RPN version of expression.
// ===================================

struct SQL_LEVEL_1_RPN_EXPRESSION
{
    int nNumTokens;
    int nCurSize;
    SQL_LEVEL_1_TOKEN *pArrayOfTokens;
    BSTR bsClassName;

	int nNumberOfProperties;          // Zero means all properties selected
    int nCurPropSize;
	__field_ecount_part(nCurPropSize, nNumberOfProperties) BSTR *pbsRequestedPropertyNames;  // Array of property names which values are to be returned if
    
    SQL_LEVEL_1_RPN_EXPRESSION();
   ~SQL_LEVEL_1_RPN_EXPRESSION();
   
   //Note: this method deletes the token it is passed as an argument
    void AddToken(SQL_LEVEL_1_TOKEN *pTok);
    void AddToken(SQL_LEVEL_1_TOKEN &pTok);
    void AddProperty(__in LPWSTR pProp);
    void Dump(const char *pszTextFile);
};


class SQL1_Parser
{
    CGenLexer *m_pLexer;
    int        m_nLine;
    wchar_t*   m_pTokenText;
    int        m_nCurrentToken;
    SQL_LEVEL_1_RPN_EXPRESSION* m_pExpression;

	//Cleanup used by d'tor and SetSource
	void Cleanup();

	//Init used by c'tor and SetSource
	void Init(__in CGenLexSource *pSrc);

    // Semantic transfer variables.
    // ============================
    VARIANT    m_vTypedConst;
    int        m_nRelOp;
    DWORD      m_dwConstFunction;
    DWORD      m_dwPropFunction;
    LPWSTR     m_pIdent;
    LPWSTR     m_pPropComp;
	BOOL       m_bConstIsStrNumeric;
        
    // Parsing functions.
    // ==================
    BOOL Next();
    
    int parse();

    int prop_list();
    int class_name();
    int opt_where();
    int expr();
    int property_name();
    int prop_list_2();
    int term();
    int expr2();
    int simple_expr();
    int term2();
    int leading_ident_expr();
    int finalize();
    int rel_operator();
    int equiv_operator();
    int comp_operator();
    int is_operator();
    int trailing_prop_expr();
    int trailing_prop_expr2();
    int trailing_or_null();
    int trailing_const_expr();
    int unknown_func_expr();
    int typed_constant();

public:
    enum { 
        SUCCESS,
        SYNTAX_ERROR,
        LEXICAL_ERROR,
        FAILED,
        BUFFER_TOO_SMALL
        };

    SQL1_Parser(__in CGenLexSource *pSrc);
   ~SQL1_Parser();

    int GetQueryClass(__out_ecount_opt(nBufLen) LPWSTR pDestBuf, int nBufLen);
       
    int Parse(__deref_out SQL_LEVEL_1_RPN_EXPRESSION **pOutput);
        // use operator delete on pOutput
            
    int CurrentLine() { return m_nLine; }
    LPWSTR CurrentToken() { return m_pTokenText; }
	void SetSource(CGenLexSource *pSrc);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\specstrings.h ===
#ifndef SPECSTRINGS_H
#define SPECSTRINGS_H
/*************************************************************************
* See specstrings_strict.h for documentation of all user visible macros.
*************************************************************************/
#if _MSC_VER
#pragma once
#endif
#include <sal.h>  

#ifndef __SAL_H_FULL_VER
#define __SAL_H_FULL_VER 140050727
#endif

#ifdef  __cplusplus
extern "C" {
#endif 

/* version specific fixes to bring sal.h upto date */
#if __SAL_H_FULL_VER <= 140050727

/* Missing from RTM sal.h */
#if !defined(__midl) && defined(_PREFAST_) && _MSC_VER >= 1000

#define __inexpressible_readableTo(size)  __declspec("SAL_readableTo(inexpressibleCount('" SPECSTRINGIZE(size) "'))")
#define __inexpressible_writableTo(size)  __declspec("SAL_writableTo(inexpressibleCount('" SPECSTRINGIZE(size) "'))")
#define __inner_bound                     __declspec("SAL_bound")
#define __inner_range(lb,ub)              __declspec("SAL_range(" SPECSTRINGIZE(lb) "," SPECSTRINGIZE(ub) ")")
#define __inner_assume_bound_dec          __inline __nothrow void __AssumeBoundInt(__post __inner_bound int i) {i;}
#define __inner_assume_bound(i)           __AssumeBoundInt(i);
#define __inner_allocator                 __declspec("SAL_allocator")
#else 
#define __inexpressible_readableTo(size)
#define __inexpressible_writableTo(size)
#define __inner_bound
#define __inner_range(lb,ub)
#define __inner_assume_bound_dec
#define __inner_assume_bound(i)
#define __inner_allocator
#endif

#define __xcount(size)                                          __notnull __inexpressible_writableTo(size)
#define __in_xcount(size)                                       __in __pre __inexpressible_readableTo(size)
#define __out_xcount(size)                                      __xcount(size) __post __valid __refparam
#define __out_xcount_part(size,length)                          __out_xcount(size) __post __inexpressible_readableTo(length)
#define __out_xcount_full(size)                                 __out_xcount_part(size,size)
#define __inout_xcount(size)                                    __out_xcount(size) __pre __valid
#define __inout_xcount_part(size,length)                        __out_xcount_part(size,length) __pre __valid __pre __inexpressible_readableTo(length)
#define __inout_xcount_full(size)                               __inout_xcount_part(size,size)
#define __xcount_opt(size)                                      __xcount(size)                              __exceptthat __maybenull
#define __in_xcount_opt(size)                                   __in_xcount(size)                           __exceptthat __maybenull
#define __out_xcount_opt(size)                                  __out_xcount(size)                          __exceptthat __maybenull
#define __out_xcount_part_opt(size,length)                      __out_xcount_part(size,length)              __exceptthat __maybenull
#define __out_xcount_full_opt(size)                             __out_xcount_full(size)                     __exceptthat __maybenull
#define __inout_xcount_opt(size)                                __inout_xcount(size)                        __exceptthat __maybenull
#define __inout_xcount_part_opt(size,length)                    __inout_xcount_part(size,length)            __exceptthat __maybenull
#define __inout_xcount_full_opt(size)                           __inout_xcount_full(size)                   __exceptthat __maybenull
#define __deref_xcount(size)                                    __ecount(1) __post __elem_readableTo(1) __post __deref __notnull __post __deref __inexpressible_writableTo(size)
#define __deref_in                                              __in __pre __deref __deref __readonly
#define __deref_in_ecount(size)                                 __deref_in __pre __deref __elem_readableTo(size)
#define __deref_in_bcount(size)                                 __deref_in __pre __deref __byte_readableTo(size)
#define __deref_in_xcount(size)                                 __deref_in __pre __deref __inexpressible_readableTo(size)
#define __deref_out_xcount(size)                                __deref_xcount(size) __post __deref __valid __refparam
#define __deref_out_xcount_part(size,length)                    __deref_out_xcount(size) __post __deref __inexpressible_readableTo(length)
#define __deref_out_xcount_full(size)                           __deref_out_xcount_part(size,size)
#define __deref_out_xcount(size)                                __deref_xcount(size) __post __deref __valid __refparam
#define __inout_xcount_opt(size)                                __inout_xcount(size)                        __exceptthat __maybenull
#define __inout_xcount_part_opt(size,length)                    __inout_xcount_part(size,length)            __exceptthat __maybenull
#define __inout_xcount_full_opt(size)                           __inout_xcount_full(size)                   __exceptthat __maybenull
#define __deref_xcount(size)                                    __ecount(1) __post __elem_readableTo(1) __post __deref __notnull __post __deref __inexpressible_writableTo(size)
#define __deref_in                                              __in __pre __deref __deref __readonly
#define __deref_in_ecount(size)                                 __deref_in __pre __deref __elem_readableTo(size)
#define __deref_in_bcount(size)                                 __deref_in __pre __deref __byte_readableTo(size)
#define __deref_in_xcount(size)                                 __deref_in __pre __deref __inexpressible_readableTo(size)
#define __deref_out_xcount(size)                                __deref_xcount(size) __post __deref __valid __refparam
#define __deref_out_xcount_part(size,length)                    __deref_out_xcount(size) __post __deref __inexpressible_readableTo(length)
#define __deref_out_xcount_full(size)                           __deref_out_xcount_part(size,size)
#define __deref_out_xcount(size)                                __deref_xcount(size) __post __deref __valid __refparam
#define __deref_inout_xcount(size)                              __deref_inout __pre __deref __inexpressible_writableTo(size) __post __deref __inexpressible_writableTo(size)
#define __deref_inout_xcount_part(size,length)                  __deref_inout_xcount(size) __pre __deref __inexpressible_readableTo(length) __post __deref __inexpressible_readableTo(length)
#define __deref_inout_xcount_full(size)                         __deref_inout_xcount_part(size,size)
#define __deref_xcount_opt(size)                                __deref_xcount(size)                        __post __deref __exceptthat __maybenull
#define __deref_in_opt                                          __deref_in                                  __pre __deref __exceptthat __maybenull
#define __deref_in_ecount_opt(size)                             __deref_in_ecount(size)                     __pre __deref __exceptthat __maybenull
#define __deref_in_bcount_opt(size)                             __deref_in_bcount(size)                     __pre __deref __exceptthat __maybenull
#define __deref_in_xcount_opt(size)                             __deref_in_xcount(size)                     __pre __deref __exceptthat __maybenull
#define __deref_out_xcount_opt(size)                            __deref_out_xcount(size)                    __post __deref __exceptthat __maybenull
#define __deref_out_xcount_part_opt(size,length)                __deref_out_xcount_part(size,length)        __post __deref __exceptthat __maybenull
#define __deref_out_xcount_full_opt(size)                       __deref_out_xcount_full(size)               __post __deref __exceptthat __maybenull
#define __deref_inout_xcount_opt(size)                          __deref_inout_xcount(size)                  __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull
#define __deref_inout_xcount_part_opt(size,length)              __deref_inout_xcount_part(size,length)      __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull
#define __deref_inout_xcount_full_opt(size)                     __deref_inout_xcount_full(size)             __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull
#define __deref_opt_xcount(size)                                __deref_xcount(size)                        __exceptthat __maybenull
#define __deref_opt_in                                          __deref_in                                  __exceptthat __maybenull
#define __deref_opt_in_ecount(size)                             __deref_in_ecount(size)                     __exceptthat __maybenull
#define __deref_opt_in_bcount(size)                             __deref_in_bcount(size)                     __exceptthat __maybenull
#define __deref_opt_in_xcount(size)                             __deref_in_xcount(size)                     __exceptthat __maybenull
#define __deref_opt_out_xcount(size)                            __deref_out_xcount(size)                    __exceptthat __maybenull
#define __deref_opt_out_xcount_part(size,length)                __deref_out_xcount_part(size,length)        __exceptthat __maybenull
#define __deref_opt_out_xcount_full(size)                       __deref_out_xcount_full(size)               __exceptthat __maybenull
#define __deref_opt_inout_xcount(size)                          __deref_inout_xcount(size)                  __exceptthat __maybenull
#define __deref_opt_inout_xcount_part(size,length)              __deref_inout_xcount_part(size,length)      __exceptthat __maybenull
#define __deref_opt_inout_xcount_full(size)                     __deref_inout_xcount_full(size)             __exceptthat __maybenull
#define __deref_opt_xcount_opt(size)                            __deref_xcount_opt(size)                    __exceptthat __maybenull
#define __deref_opt_in_opt                                      __deref_in_opt                              __exceptthat __maybenull
#define __deref_opt_in_ecount_opt(size)                         __deref_in_ecount_opt(size)                 __exceptthat __maybenull
#define __deref_opt_in_bcount_opt(size)                         __deref_in_bcount_opt(size)                 __exceptthat __maybenull
#define __deref_opt_in_xcount_opt(size)                         __deref_in_xcount_opt(size)                 __exceptthat __maybenull
#define __deref_opt_out_xcount_opt(size)                        __deref_out_xcount_opt(size)                __exceptthat __maybenull
#define __deref_opt_out_xcount_part_opt(size,length)            __deref_out_xcount_part_opt(size,length)    __exceptthat __maybenull
#define __deref_opt_out_xcount_full_opt(size)                   __deref_out_xcount_full_opt(size)           __exceptthat __maybenull
#define __deref_opt_inout_xcount_opt(size)                      __deref_inout_xcount_opt(size)              __exceptthat __maybenull
#define __deref_opt_inout_xcount_part_opt(size,length)          __deref_inout_xcount_part_opt(size,length)  __exceptthat __maybenull
#define __deref_opt_inout_xcount_full_opt(size)                 __deref_inout_xcount_full_opt(size)         __exceptthat __maybenull
/* Must protect redfinitions of macros to workaround rc.exe issues. */
#ifndef RC_INVOKED
#undef __nullnullterminated
#define __nullnullterminated __xcount("string terminated by two nulls")
#undef __checkReturn
#define __checkReturn __post __inner_checkReturn
#endif
#endif  //__SAL_H_FULL_VER <= 140050727

/************************************************************************
 New extensions to sal.h follow here.
*************************************************************************/

#if (_MSC_VER >= 1000) && !defined(__midl) && defined(_PREFAST_)
#define __file_parser(typ)                  __declspec("SAL_file_parser(function, " #typ ")")    
#define __file_parser_class(typ)            __declspec("SAL_file_parser(class, " #typ ")")
#define __file_parser_library(typ)          extern int __declspec("SAL_file_parser(library, " #typ ")") __iSALFileParserLibrary##typ;
#define __source_code_content(typ)          extern int __declspec("SAL_source_code_content(" #typ ")") __iSAL_Source_Code_Content##typ;
#define __class_code_content(typ)           __declspec("SAL_class_code_content(" #typ ")")
#define __analysis_assert(e)                __assume(e)
#define __analysis_hint(hint)               __declspec("SAL_analysisHint(" #hint ")")   
/* Internal defintions */
#define __inner_data_source(src_raw)        __declspec("SAL_untrusted_data_source(" src_raw ")")
#define __inner_this_data_source(src_raw)   __declspec("SAL_untrusted_data_source_this(" src_raw ")")
#define __inner_out_validated(typ_raw)      __declspec("SAL_post") __declspec("SAL_validated(" typ_raw ")") 
#define __inner_this_out_validated(typ_raw) __declspec("SAL_validated_this(" typ_raw ")") 
#define __inner_assume_validated_dec        __inline __nothrow void __AssumeValidated(__inner_out_validated("BY_DESIGN") const void *p) {p;}
#define __inner_assume_validated(p)         __AssumeValidated(p)
#define __inner_transfer(formal)            __declspec("SAL_transfer_adt_property_from(" SPECSTRINGIZE(formal) ")")
#define __inner_encoded                     __declspec("SAL_encoded")

#if defined(_MSC_EXTENSIONS) || defined(_PREFAST_) || defined(OACR)
#define __$adt_prop(adt,prop)               __declspec("SAL_adt("#adt","#prop")")
#define __$adt_add_prop(adt,prop)           __declspec("SAL_add_adt_property("#adt","#prop")")
#define __$adt_remove_prop(adt,prop)        __declspec("SAL_remove_adt_property("#adt","#prop")")
#define __$adt_transfer_prop(arg)           __declspec("SAL_transfer_adt_property_from("#arg")")
#define __$adt_type_props(typ)              __declspec("SAL_post_type("#typ")")
#define __$volatile                         __declspec("SAL_volatile")
#define __$nonvolatile                      __declspec("SAL_nonvolatile")
#define __$possibly_notnulltermiated        __declspec("SAL_RequiresZeroTermination(sometimes)")
#endif
#else
#define __file_parser(typ)
#define __file_parser_class(typ)
#define __file_parser_library(typ)
#define __source_code_content(typ)
#define __class_code_content(typ)
#define __analysis_assert(e)
#define __analysis_hint(hint)
/* Internal defintions */
#define __inner_data_source(src_raw)
#define __inner_this_data_source(src_raw)
#define __inner_out_validated(typ_raw)
#define __inner_this_out_validated(typ_raw)
#define __inner_assume_validated_dec
#define __inner_assume_validated(p)
#define __inner_transfer(formal)
#define __inner_encoded
#if defined(_MSC_EXTENSIONS) || defined(_PREFAST_) || defined(OACR)
#define __$adt_prop(adt,prop)   
#define __$adt_add_prop(adt,prop)   
#define __$adt_remove_prop(adt,prop)   
#define __$adt_transfer_prop(arg)   
#define __$adt_type_props(typ)   
#define __$volatile 
#define __$nonvolatile 
#define __$possibly_notnulltermiated 
#endif
#endif // #if (_MSC_VER >= 1000) && !defined(__midl) && defined(_PREFAST_)

#define __field_ecount(size)                __notnull __elem_writableTo(size)
#define __field_bcount(size)                __notnull __byte_writableTo(size)
#define __field_xcount(size)                __notnull __inexpressible_writableTo(size)

#define __field_ecount_opt(size)            __maybenull __elem_writableTo(size)
#define __field_bcount_opt(size)            __maybenull __byte_writableTo(size)
#define __field_xcount_opt(size)            __maybenull __inexpressible_writableTo(size)

#define __field_ecount_part(size,init)      __notnull __elem_writableTo(size) __elem_readableTo(init)
#define __field_bcount_part(size,init)      __notnull __byte_writableTo(size) __byte_readableTo(init)
#define __field_xcount_part(size,init)      __notnull __inexpressible_writableTo(size) __inexpressible_readableTo(init)

#define __field_ecount_part_opt(size,init)  __maybenull __elem_writableTo(size) __elem_readableTo(init)
#define __field_bcount_part_opt(size,init)  __maybenull __byte_writableTo(size) __byte_readableTo(init)
#define __field_xcount_part_opt(size,init)  __maybenull __inexpressible_writableTo(size) __inexpressible_readableTo(init)

#define __field_ecount_full(size)           __field_ecount_part(size,size)  
#define __field_bcount_full(size)           __field_bcount_part(size,size)  
#define __field_xcount_full(size)           __field_xcount_part(size,size)      

#define __field_ecount_full_opt(size)       __field_ecount_part_opt(size,size)  
#define __field_bcount_full_opt(size)       __field_bcount_part_opt(size,size)  
#define __field_xcount_full_opt(size)       __field_xcount_part_opt(size,size)      

#define __struct_bcount(size)               __field_bcount(size)
#define __struct_xcount(size)               __field_xcount(size)

#define __out_awcount(expr,size)            __pre __notnull \
					    __byte_writableTo((expr) ? (size) : (size) * 2) \
                                            __post __valid __refparam
#define __in_awcount(expr,size)             __pre __valid \
                                            __pre __deref __readonly \
				            __byte_readableTo((expr) ? (size) : (size) * 2)

/* integer related macros */
#define __allocator                         __inner_allocator
#define __bound                             __inner_bound
#define __range(lb,ub)                      __inner_range(lb,ub)
#define __in_bound                          __pre __inner_bound
#define __out_bound                         __post __inner_bound
#define __deref_out_bound                   __post __deref __inner_bound
#define __in_range(lb,ub)                   __pre __inner_range(lb,ub)
#define __out_range(lb,ub)                  __post __inner_range(lb,ub)
#define __deref_in_range(lb,ub)             __pre __deref __inner_range(lb,ub)
#define __deref_out_range(lb,ub)            __post __deref __inner_range(lb,ub)
#define __field_range(lb,ub)                __range(lb,ub)
#define __field_data_source(src_sym)        __inner_data_source(#src_sym)

/* Pentraion review macros */
#define __in_data_source(src_sym)           __pre __inner_data_source(#src_sym)
#define __out_data_source(src_sym)          __post __inner_data_source(#src_sym)
#define __out_validated(typ_sym)            __inner_out_validated(#typ_sym)
#define __this_out_data_source(src_sym)     __inner_this_data_source(#src_sym)
#define __this_out_validated(typ_sym)       __inner_this_out_validated(#typ_sym)
#define __transfer(formal)                  __post __inner_transfer(formal)
#define __rpc_entry                         __inner_control_entrypoint(RPC)
#define __kernel_entry                      __inner_control_entrypoint(UserToKernel)   
#define __gdi_entry                         __inner_control_entrypoint(GDI)
#define __encoded_pointer                   __inner_encoded
#define __encoded_array                     __inner_encoded
#define __field_encoded_pointer             __inner_encoded
#define __field_encoded_array               __inner_encoded
#if defined(_MSC_EXTENSIONS) || defined(_PREFAST_) || defined(OACR)
#define __type_has_adt_prop(adt,prop)       __$adt_prop(adt,prop)
#define __out_has_adt_prop(adt,prop)        __post __$adt_add_prop(adt,prop)
#define __out_not_has_adt_prop(adt,prop)    __post __$adt_remove_prop(adt,prop)
#define __out_transfer_adt_prop(arg)        __post __$adt_transfer_prop(arg)
#define __out_has_type_adt_props(typ)       __post __$adt_type_props(typ)

/* useful PFD related macros */
#define __possibly_notnulltermiated         __post __$possibly_notnulltermiated

/* Windows Internal */
#define __volatile                          __$volatile
#define __nonvolatile                       __$nonvolatile
#else
#define __out_has_type_adt_props(typ)       /* nothing */
#endif
#define __deref_volatile                    __deref __volatile
#define __deref_nonvolatile                 __deref __nonvolatile

/* declare stub functions for macros */
__inner_assume_validated_dec 
__inner_assume_bound_dec 

#define __assume_validated(p) __inner_assume_validated(p)
#define __assume_bound(i) __inner_assume_bound(i)
#ifdef  __cplusplus
}
#endif
#include <specstrings_adt.h>
#ifdef _PREFIX_
/**************************************************************************
* Defintion of __pfx_assume and __pfx_assert. Thse should be the only
* defintions of these functions.  
***************************************************************************/
#if __cplusplus
extern "C" void __pfx_assert(bool, const char *);
extern "C" void __pfx_assume(bool, const char *);
#else
void __pfx_assert(int, const char *);
void __pfx_assume(int, const char *);
#endif
/**************************************************************************
* Redefintion of __analysis_assume and __analysis_assert for PREFIX build
**************************************************************************/
#undef  __analysis_assume
#undef  __analysis_assert
#define __analysis_assume(e) (__pfx_assume(e,"pfx_assume"),__assume(e));
#define __analysis_assert(e) (__pfx_assert(e,"pfx_assert"),__assume(e));
#endif /* ifdef _PREFIX_ */

/**************************************************************************
* This include should always be the last thing in this file. 
* Must avoid redfinitions of macros to workaround rc.exe issues. 
***************************************************************************/
#if !(defined(RC_INVOKED) || defined(SORTPP_PASS))
#include <specstrings_strict.h>
#endif /* if !(defined(RC_INVOKED) || defined(SORTPP_PASS)) */
#endif /* #ifndef SPECSTRINGS_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\SrRestorePtApi.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    SRRestorePtAPI.h

Abstract:
    This file contains the declarations for the SRRESTOREPT_API

******************************************************************************/

#if !defined( _SRRESTOREPTAPI_H )
#define _SRRESTOREPTAPI_H

//
// Type of Event
//

#define MIN_EVENT                        100
#define BEGIN_SYSTEM_CHANGE              100
#define END_SYSTEM_CHANGE                101
#define BEGIN_NESTED_SYSTEM_CHANGE       102    // for Whistler only - use this to prevent nested restore pts
#define END_NESTED_SYSTEM_CHANGE         103    // for Whistler only - use this to prevent nested restore pts
#define BEGIN_NESTED_SYSTEM_CHANGE_NORP  104
#define END_NESTED_SYSTEM_CHANGE_NORP    END_NESTED_SYSTEM_CHANGE
#define MAX_EVENT                        104

//
// Type of Restore Points
//

#define MIN_RPT                 0
#define APPLICATION_INSTALL     0
#define APPLICATION_UNINSTALL   1
#define DESKTOP_SETTING         2    /* Not implemented */
#define ACCESSIBILITY_SETTING   3    /* Not implemented */
#define OE_SETTING              4    /* Not implemented */
#define APPLICATION_RUN         5    /* Not implemented */
#define RESTORE                 6
#define CHECKPOINT              7
#define WINDOWS_SHUTDOWN        8    /* Not implemented */
#define WINDOWS_BOOT            9    /* Not implemented */
#define DEVICE_DRIVER_INSTALL   10
#define FIRSTRUN                11
#define MODIFY_SETTINGS         12
#define CANCELLED_OPERATION     13   /* Only valid for END_SYSTEM_CHANGE */
#define BACKUP_RECOVERY         14
#define MANUAL_CHECKPOINT       16
#define MAX_RPT                 16


#define MAX_DESC                64
#define MAX_DESC_W              256   // longer for Whistler

//
// for Millennium compatibility
//

#pragma pack(push, srrestoreptapi_include)
#pragma pack(1)

//
// Restore point information
//

typedef struct _RESTOREPTINFOA {
    DWORD   dwEventType;                // Type of Event - Begin or End
    DWORD   dwRestorePtType;            // Type of Restore Point - App install/uninstall
    INT64   llSequenceNumber;           // Sequence Number - 0 for begin
    CHAR    szDescription[MAX_DESC];    // Description - Name of Application / Operation
} RESTOREPOINTINFOA, *PRESTOREPOINTINFOA;

typedef struct _RESTOREPTINFOW {
    DWORD   dwEventType;
    DWORD   dwRestorePtType;
    INT64   llSequenceNumber;
    WCHAR   szDescription[MAX_DESC_W];
} RESTOREPOINTINFOW, *PRESTOREPOINTINFOW;

typedef struct _RESTOREPTINFOEX {
    FILETIME ftCreation;
    DWORD    dwEventType;
    DWORD    dwRestorePtType;
    DWORD    dwRPNum;
    WCHAR    szDescription[MAX_DESC_W];
} RESTOREPOINTINFOEX, *PRESTOREPOINTINFOEX;


//
// Status returned by System Restore
//

typedef struct _SMGRSTATUS {
    DWORD   nStatus;            // Status returned by State Manager Process
    INT64   llSequenceNumber;   // Sequence Number for the restore point
} STATEMGRSTATUS, *PSTATEMGRSTATUS;

#pragma pack(pop, srrestoreptapi_include)


#ifdef __cplusplus
extern "C" {
#endif

//
// RPC call to set a restore point
//
// Return value  TRUE if the call was a success
//               FALSE if the call failed
//
// If pSmgrStatus nStatus field is set as follows
//
// ERROR_SUCCESS              If the call succeeded (return value will be TRUE)
//
// ERROR_TIMEOUT              If the call timed out due to a wait on a mutex for
//                            for setting restore points.
//
// ERROR_INVALID_DATA         If the cancel restore point is called with an invalid
//                            sequence number
//
// ERROR_INTERNAL_ERROR       If there are internal failures.
//
// ERROR_BAD_ENVIRONMENT      If the API is called in SafeMode
//
// ERROR_SERVICE_DISABLED     If SystemRestore is Disabled.
//
// ERROR_DISK_FULL            If System Restore is frozen (Windows Whistler only)
//
// ERROR_ALREADY_EXISTS       If this is a nested restore point

BOOL __stdcall
SRSetRestorePointA(
                  __in PRESTOREPOINTINFOA  pRestorePtSpec,// [in] Restore Point specification
                  __out PSTATEMGRSTATUS     pSMgrStatus   // [out] Status returned
                  );


BOOL __stdcall
SRSetRestorePointW(
                  __in PRESTOREPOINTINFOW pRestorePtSpec,
                  __out PSTATEMGRSTATUS   pSMgrStatus
                  );

BOOL __stdcall
SRSetRestorePointInternal(
                  __in PRESTOREPOINTINFOW pRestorePtSpec,
                  __out PSTATEMGRSTATUS   pSMgrStatus,
                  __in BOOL           fForceSurrogate
                  );

DWORD __stdcall
SRRemoveRestorePoint(DWORD dwRPNum);

#ifdef __cplusplus
}
#endif


#ifdef UNICODE
#define RESTOREPOINTINFO        RESTOREPOINTINFOW
#define PRESTOREPOINTINFO       PRESTOREPOINTINFOW
#define SRSetRestorePoint       SRSetRestorePointW
#else
#define RESTOREPOINTINFO        RESTOREPOINTINFOA
#define PRESTOREPOINTINFO       PRESTOREPOINTINFOA
#define SRSetRestorePoint       SRSetRestorePointA
#endif


#endif // !defined( _RESTOREPTAPI_H )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\SspGuid.h ===
/*++

Copyright (C) Microsoft Corporation 1999

Module Name:

    sspguid

Abstract:

    CLSID definitions from the scardssp project.

Author:

    Doug Barlow (dbarlow) 6/28/1999

Remarks:

    ?Remarks?

Notes:

    ?Notes?

--*/

#ifndef _SSPGUID_H_
#define _SSPGUID_H_

#define IID_DEFINED

#include "scardssp_i.c"

#ifndef CLSCTX_LOCAL
#define CLSCTX_LOCAL            (CLSCTX_INPROC_SERVER| \
                                 CLSCTX_INPROC_HANDLER| \
                                 CLSCTX_LOCAL_SERVER)
#endif

#endif // _SSPGUID_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\SspsErr.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    SspsErr

Abstract:

    This header file describes the error codes that are generated by
    the Microsoft Smartcard Service Provider (SSP).

Author:

    Michael Gallagher (a-mgalla) 10/21/1996

Environment:

    Win32

Revision History:

    Mike Gallagher (a-mgalla) 12/19/1996

Notes:

--*/


#ifndef __SSPSERR_H__
#define __SSPSERR_H__

/////////////////////////////////////////////////////////////////////////////
//
// Includes
//

#ifndef SCARD_S_SUCCESS
#include "scarderr.h"
#endif
#ifdef _DEBUG
#pragma message("sspserr.h is obsolete.")
#endif


/////////////////////////////////////////////////////////////////////////////

#endif  // __SSPSERR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\stgprop.h ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1993-1999.
//
//  File:       stgprop.h
//
//  Contents:   Standard storage provider property definitions;
//
//  History:    Jul-9-93       robertfe
//
//----------------------------------------------------------------------------

#ifndef _STGPROP_H_
#define _STGPROP_H_

#if _MSC_VER > 1000
#pragma once
#endif

#define PSGUID_STORAGE  { 0xb725f130,           \
                          0x47ef, 0x101a,       \
                          { 0xa5, 0xf1, 0x02, 0x60, 0x8c, 0x9e, 0xeb, 0xac } }

//#define PID_STG_DICTIONARY            ((PROPID) 0x00000000) //reserved
//#define PID_STG_CODEPAGE              ((PROPID) 0x00000001) //reserved

#define PID_STG_DIRECTORY               ((PROPID) 0x00000002)

#define PID_STG_CLASSID                 ((PROPID) 0x00000003)
#define PID_STG_STORAGETYPE             ((PROPID) 0x00000004)

#define PID_STG_VOLUME_ID               ((PROPID) 0x00000005)
#define PID_STG_PARENT_WORKID           ((PROPID) 0x00000006)
#define PID_STG_SECONDARYSTORE          ((PROPID) 0x00000007)

#define PID_STG_FILEINDEX               ((PROPID) 0x00000008)
#define PID_STG_LASTCHANGEUSN           ((PROPID) 0x00000009)
#define PID_STG_NAME                    ((PROPID) 0x0000000a)
#define PID_STG_PATH                    ((PROPID) 0x0000000b)

#define PID_STG_SIZE                    ((PROPID) 0x0000000c)
#define PID_STG_ATTRIBUTES              ((PROPID) 0x0000000d)
#define PID_STG_WRITETIME               ((PROPID) 0x0000000e)
#define PID_STG_CREATETIME              ((PROPID) 0x0000000f)
#define PID_STG_ACCESSTIME              ((PROPID) 0x00000010)
#define PID_STG_CHANGETIME              ((PROPID) 0x00000011)
#define PID_STG_ALLOCSIZE               ((PROPID) 0x00000012)

#define PID_STG_CONTENTS                ((PROPID) 0x00000013)
#define PID_STG_SHORTNAME               ((PROPID) 0x00000014)

#define PID_STG_FRN                     ((PROPID) 0x00000015)
#define PID_STG_SCOPE                   ((PROPID) 0x00000016)

#define PID_STG_MAX                     PID_STG_SCOPE

#define CSTORAGEPROPERTY                0x17

#endif _STGPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\sqloledb.h ===
//--------------------------------------------------------------------
// Microsoft OLE DB Provider for SQL Server
// (C) Copyright 1997 By Microsoft Corporation.
//
// @doc
//
// @module SQLOLEDB.H | Provider Specific definitions
//
//--------------------------------------------------------------------

#ifndef  _SQLOLEDB_H_
#define  _SQLOLEDB_H_

#ifndef	 __oledb_h__
#include "oledb.h"
#endif	/* __oledb_h__	*/

//----------------------------------------------------------------------------
// Provider-specific Class Ids
// Provider CLSID 		{0C7FF16C-38E3-11d0-97AB-00C04FC2AD98}
extern const GUID OLEDBDECLSPEC CLSID_SQLOLEDB          = {0xc7ff16cL,0x38e3,0x11d0,0x97,0xab,0x0,0xc0,0x4f,0xc2,0xad,0x98};
// Error Lookup CLSID 		{C0932C62-38E5-11d0-97AB-00C04FC2AD98}
extern const GUID OLEDBDECLSPEC CLSID_SQLOLEDB_ERROR    = {0xc0932c62L,0x38e5,0x11d0,0x97,0xab,0x0,0xc0,0x4f,0xc2,0xad,0x98};
// Enumerator CLSID 		{DFA22B8E-E68D-11d0-97E4-00C04FC2AD98}
extern const GUID OLEDBDECLSPEC CLSID_SQLOLEDB_ENUMERATOR = {0xdfa22b8eL,0xe68d,0x11d0,0x97,0xe4,0x0,0xc0,0x4f,0xc2,0xad,0x98};

//----------------------------------------------------------------------------
// Provider-specific Interface Ids
extern const GUID OLEDBDECLSPEC IID_ISQLServerErrorInfo = {0x5cf4ca12,0xef21,0x11d0,0x97,0xe7,0x0,0xc0,0x4f,0xc2,0xad,0x98};
extern const GUID OLEDBDECLSPEC IID_IRowsetFastLoad     = {0x5cf4ca13,0xef21,0x11d0,0x97,0xe7,0x0,0xc0,0x4f,0xc2,0xad,0x98};
extern const GUID OLEDBDECLSPEC IID_IUMSInitialize      = {0x5cf4ca14,0xef21,0x11d0,0x97,0xe7,0x0,0xc0,0x4f,0xc2,0xad,0x98};
// {4C2389FB-2511-11d4-B258-00C04F7971CE}
extern const GUID OLEDBDECLSPEC IID_ISchemaLock         = {0x4c2389fb,0x2511,0x11d4,0xb2,0x58,0x0,0xc0,0x4f,0x79,0x71,0xce};
extern const GUID OLEDBDECLSPEC DBGUID_MSSQLXML         = {0x5d531cb2L,0xe6ed,0x11d2,0xb2,0x52,0x00,0xc0,0x4f,0x68,0x1b,0x71};
extern const GUID OLEDBDECLSPEC DBGUID_XPATH            = {0xec2a4293L,0xe898,0x11d2,0xb1,0xb7,0x00,0xc0,0x4f,0x68,0x0c,0x56};
// This IID_ICommandStream definition is available in later versions of 
// UUID.LIB.  It is also already an extern defined in oledb.h.
//
#if _MSC_VER < 1300
extern const GUID OLEDBDECLSPEC IID_ICommandStream      = {0x0c733abfL,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d};
#endif // _MSC_VER
extern const GUID OLEDBDECLSPEC IID_ISQLXMLHelper       = {0xd22a7678L,0xf860,0x40cd,0xa5,0x67,0x15,0x63,0xde,0xb4,0x6d,0x49};

//----------------------------------------------------------------------------
// Provider-specific schema rowsets
extern const GUID OLEDBDECLSPEC DBSCHEMA_LINKEDSERVERS  = {0x9093caf4,0x2eac,0x11d1,0x98,0x9,0x0,0xc0,0x4f,0xc2,0xad,0x98};

//----------------------------------------------------------------------------
// Provider-specific property sets
extern const GUID OLEDBDECLSPEC DBPROPSET_SQLSERVERDATASOURCE = {0x28efaee4,0x2d2c,0x11d1,0x98,0x7,0x0,0xc0,0x4f,0xc2,0xad,0x98};
extern const GUID OLEDBDECLSPEC DBPROPSET_SQLSERVERDATASOURCEINFO = {0xdf10cb94,0x35f6,0x11d2,0x9c,0x54,0x0,0xc0,0x4f,0x79,0x71,0xd3};
extern const GUID OLEDBDECLSPEC DBPROPSET_SQLSERVERDBINIT   = {0x5cf4ca10,0xef21,0x11d0,0x97,0xe7,0x0,0xc0,0x4f,0xc2,0xad,0x98};
extern const GUID OLEDBDECLSPEC DBPROPSET_SQLSERVERROWSET   = {0x5cf4ca11,0xef21,0x11d0,0x97,0xe7,0x0,0xc0,0x4f,0xc2,0xad,0x98};
extern const GUID OLEDBDECLSPEC DBPROPSET_SQLSERVERSESSION  = {0x28efaee5,0x2d2c,0x11d1,0x98,0x7,0x0,0xc0,0x4f,0xc2,0xad,0x98};
extern const GUID OLEDBDECLSPEC DBPROPSET_SQLSERVERCOLUMN   = {0x3b63fb5e,0x3fbb,0x11d3,0x9f,0x29,0x0,0xc0,0x4f,0x8e,0xe9,0xdc};
extern const GUID OLEDBDECLSPEC DBPROPSET_SQLSERVERSTREAM   = {0x9f79c073,0x8a6d,0x4bca,0xa8,0xa8,0xc9,0xb7,0x9a,0x9b,0x96,0x2d};

//----------------------------------------------------------------------------
// Provider-specific columns for IColumnsRowset
extern const DBID OLEDBDECLSPEC DBCOLUMN_SS_COMPFLAGS       = {0x627bd890,0xed54,0x11d2,0xb9,0x94,0x0,0xc0,0x4f,0x8c,0xa8,0x2c, DBKIND_GUID_PROPID, (LPOLESTR)100};
extern const DBID OLEDBDECLSPEC DBCOLUMN_SS_SORTID          = {0x627bd890,0xed54,0x11d2,0xb9,0x94,0x0,0xc0,0x4f,0x8c,0xa8,0x2c, DBKIND_GUID_PROPID, (LPOLESTR)101};
extern const DBID OLEDBDECLSPEC DBCOLUMN_BASETABLEINSTANCE  = {0x627bd890,0xed54,0x11d2,0xb9,0x94,0x0,0xc0,0x4f,0x8c,0xa8,0x2c, DBKIND_GUID_PROPID, (LPOLESTR)102};
extern const DBID OLEDBDECLSPEC DBCOLUMN_SS_TDSCOLLATION    = {0x627bd890,0xed54,0x11d2,0xb9,0x94,0x0,0xc0,0x4f,0x8c,0xa8,0x2c, DBKIND_GUID_PROPID, (LPOLESTR)103};

#define CRESTRICTIONS_DBSCHEMA_LINKEDSERVERS	1

//----------------------------------------------------------------------------
// PropIds for DBPROP_INIT_GENERALTIMEOUT
#if ( OLEDBVER == 0x0210 )
#define DBPROP_INIT_GENERALTIMEOUT		0x11cL
#endif

//----------------------------------------------------------------------------
// PropIds for DBPROPSET_SQLSERVERDATASOURCE
#define SSPROP_ENABLEFASTLOAD			2

//----------------------------------------------------------------------------
// PropIds for DBPROPSET_SQLSERVERDATASOURCEINFO
#define SSPROP_UNICODELCID				2
#define SSPROP_UNICODECOMPARISONSTYLE	3
#define SSPROP_COLUMNLEVELCOLLATION     4
#define SSPROP_CHARACTERSET				5
#define	SSPROP_SORTORDER				6
#define SSPROP_CURRENTCOLLATION			7
//----------------------------------------------------------------------------
// PropIds for DBPROPSET_SQLSERVERDBINIT 
#define SSPROP_INIT_CURRENTLANGUAGE		4
#define SSPROP_INIT_NETWORKADDRESS		5
#define SSPROP_INIT_NETWORKLIBRARY		6
#define SSPROP_INIT_USEPROCFORPREP		7
#define SSPROP_INIT_AUTOTRANSLATE		8
#define SSPROP_INIT_PACKETSIZE			9
#define SSPROP_INIT_APPNAME			10
#define SSPROP_INIT_WSID			11
#define SSPROP_INIT_FILENAME			12
#define SSPROP_INIT_ENCRYPT             13 
#define SSPROP_AUTH_REPL_SERVER_NAME	14
#define SSPROP_INIT_TAGCOLUMNCOLLATION	15

//-----------------------------------------------------------------------------
// Values for SSPROP_USEPROCFORPREP
#define SSPROPVAL_USEPROCFORPREP_OFF		0
#define SSPROPVAL_USEPROCFORPREP_ON			1
#define SSPROPVAL_USEPROCFORPREP_ON_DROP	2

//----------------------------------------------------------------------------
// PropIds for DBPROPSET_SQLSERVERSESSION
#define SSPROP_QUOTEDCATALOGNAMES		2
#define SSPROP_ALLOWNATIVEVARIANT		3
#define SSPROP_SQLXMLXPROGID			4

//----------------------------------------------------------------------------
// PropIds for DBPROPSET_SQLSERVERROWSET 
#define SSPROP_MAXBLOBLENGTH			8
#define SSPROP_FASTLOADOPTIONS			9
#define SSPROP_FASTLOADKEEPNULLS		10
#define SSPROP_FASTLOADKEEPIDENTITY		11
#define SSPROP_CURSORAUTOFETCH			12
#define SSPROP_DEFERPREPARE				13
#define SSPROP_IRowsetFastLoad			14

//----------------------------------------------------------------------------
// PropIds for DBPROPSET_SQLSERVERCOLUMN
#define SSPROP_COL_COLLATIONNAME		14

//----------------------------------------------------------------------------
// PropIds for DBPROPSET_SQLSERVERSTREAM
#define SSPROP_STREAM_MAPPINGSCHEMA     15
#define SSPROP_STREAM_XSL               16
#define SSPROP_STREAM_BASEPATH          17
#define SSPROP_STREAM_COMMANDTYPE       18
#define SSPROP_STREAM_XMLROOT           19
#define SSPROP_STREAM_FLAGS             20
#define SSPROP_STREAM_CONTENTTYPE       23

//----------------------------------------------------------------------------
// Possible values for SSPROP_STREAM_FLAGS
#define STREAM_FLAGS_DISALLOW_URL           0x00000001
#define STREAM_FLAGS_DISALLOW_ABSOLUTE_PATH 0x00000002
#define STREAM_FLAGS_DISALLOW_QUERY         0x00000004
#define STREAM_FLAGS_DONTCACHEMAPPINGSCHEMA 0x00000008
#define STREAM_FLAGS_DONTCACHETEMPLATE      0x00000010
#define STREAM_FLAGS_DONTCACHEXSL           0x00000020
#define STREAM_FLAGS_DISALLOW_UPDATEGRAMS   0x00000040
#define STREAM_FLAGS_RESERVED               0xffff0000

// Values for SSPROPVAL_COMMANDTYPE

#define SSPROPVAL_COMMANDTYPE_REGULAR   21
#define SSPROPVAL_COMMANDTYPE_BULKLOAD  22

//-------------------------------------------------------------------
// Variant Access macros, similar to ole automation.
//-------------------------------------------------------------------

#define V_SS_VT(X)         ((X)->vt)
#define V_SS_UNION(X, Y)   ((X)->Y)

#define V_SS_UI1(X)				V_SS_UNION(X, bTinyIntVal)
#define V_SS_I2(X)				V_SS_UNION(X, sShortIntVal)
#define V_SS_I4(X)				V_SS_UNION(X, lIntVal)
#define V_SS_I8(X)				V_SS_UNION(X, llBigIntVal)

#define V_SS_R4(X)				V_SS_UNION(X, fltRealVal)
#define V_SS_R8(X)				V_SS_UNION(X, dblFloatVal)
#define V_SS_UI4(X)			    V_SS_UNION(X, ulVal)

#define V_SS_MONEY(X)			V_SS_UNION(X, cyMoneyVal)
#define V_SS_SMALLMONEY(X)		V_SS_UNION(X, cyMoneyVal)

#define V_SS_WSTRING(X)			V_SS_UNION(X, NCharVal)
#define V_SS_WVARSTRING(X)		V_SS_UNION(X, NCharVal)

#define V_SS_STRING(X)			V_SS_UNION(X, CharVal)
#define V_SS_VARSTRING(X)		V_SS_UNION(X, CharVal)

#define V_SS_BIT(X)				V_SS_UNION(X, fBitVal)
#define V_SS_GUID(X)			V_SS_UNION(X, rgbGuidVal)

#define V_SS_NUMERIC(X)			V_SS_UNION(X, numNumericVal)
#define V_SS_DECIMAL(X)			V_SS_UNION(X, numNumericVal)

#define V_SS_BINARY(X)			V_SS_UNION(X, BinaryVal)
#define V_SS_VARBINARY(X)		V_SS_UNION(X, BinaryVal)

#define V_SS_DATETIME(X)		V_SS_UNION(X, tsDateTimeVal)
#define V_SS_SMALLDATETIME(X)	V_SS_UNION(X, tsDateTimeVal)

#define V_SS_UNKNOWN(X)	V_SS_UNION(X, UnknownType)

//For next release.
#define V_SS_IMAGE(X)	V_SS_UNION(X, ImageVal)
#define V_SS_TEXT(X)	V_SS_UNION(X, TextVal)
#define V_SS_NTEXT(X)	V_SS_UNION(X, NTextVal)

//-------------------------------------------------------------------
// define SQL Server Spefific Variant Type
//-------------------------------------------------------------------
#define DBTYPE_SQLVARIANT   144

enum SQLVARENUM
    {	
	VT_SS_EMPTY = DBTYPE_EMPTY,
	VT_SS_NULL = DBTYPE_NULL,
	VT_SS_UI1 = DBTYPE_UI1,
	VT_SS_I2 = DBTYPE_I2,
	VT_SS_I4 = DBTYPE_I4,
	VT_SS_I8 = DBTYPE_I8,

	//Floats
	VT_SS_R4  = DBTYPE_R4,
	VT_SS_R8 = DBTYPE_R8,

	//Money
	VT_SS_MONEY = DBTYPE_CY,
	VT_SS_SMALLMONEY  = 200,
	
	//Strings
	VT_SS_WSTRING		= 201,
	VT_SS_WVARSTRING	= 202,
	
	VT_SS_STRING	=203,
	VT_SS_VARSTRING	=204,
	
	//Bit
	VT_SS_BIT		=DBTYPE_BOOL,
	
	//Guid
	VT_SS_GUID		=DBTYPE_GUID,

	//Exact precision
	VT_SS_NUMERIC	=DBTYPE_NUMERIC,
	VT_SS_DECIMAL	=205,

	//Datetime
	VT_SS_DATETIME		= DBTYPE_DBTIMESTAMP,
	VT_SS_SMALLDATETIME =206,

	//Binary
	VT_SS_BINARY =207,
	VT_SS_VARBINARY =208,
	//Future
	VT_SS_UNKNOWN	= 209,
    };

typedef unsigned short SSVARTYPE;


//Hungarian : ssv (Sql Server Variant)
struct SSVARIANT
	{
		SSVARTYPE vt;
		DWORD dwReserved1;
		DWORD dwReserved2;
        union 
            {
			BYTE bTinyIntVal;
			SHORT sShortIntVal;
            LONG lIntVal;
            LONGLONG llBigIntVal;
            
            FLOAT fltRealVal;
            DOUBLE dblFloatVal;
			
			CY cyMoneyVal;

			struct _NCharVal
				{
				SHORT sActualLength;
				SHORT sMaxLength;
				WCHAR * pwchNCharVal;
				BYTE rgbReserved[5];
				DWORD dwReserved;
				WCHAR * pwchReserved;
				} NCharVal;


			struct _CharVal
				{
				SHORT sActualLength;
				SHORT sMaxLength;
				CHAR  * pchCharVal;
				BYTE rgbReserved[5];
				DWORD dwReserved;
				WCHAR * pwchReserved;
				} CharVal;
			
			VARIANT_BOOL  fBitVal;
			BYTE  rgbGuidVal [16];
			
			DB_NUMERIC numNumericVal;		

			struct _BinaryVal
				{
				SHORT sActualLength;
				SHORT sMaxLength;
				BYTE  * prgbBinaryVal;
				DWORD dwReserved;
				} BinaryVal;

			DBTIMESTAMP  tsDateTimeVal;

			struct _UnknownType
				{
				DWORD dwActualLength;
				BYTE rgMetadata [16];
				BYTE * pUnknownData;					
				} UnknownType;
				            
			struct _BLOBType
				{
				DBOBJECT dbobj;
				IUnknown * pUnk; 
				} BLOBType;
			};

    };


#if defined(__cplusplus) && !defined(CINTERFACE)

//-----------------------------------------------------------------
// Class Factory Interface used to initialize pointer to UMS. 
//
interface IUMSInitialize : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE Initialize (VOID * pUMS) = 0;
};


//-----------------------------------------------------------------
// Interface used to communicate with UMS.
//
interface IUMS
{
public:
    virtual VOID STDMETHODCALLTYPE SqlUmsSuspend (ULONG ticks) = 0;
	virtual VOID STDMETHODCALLTYPE SqlUmsYield (ULONG ticks) = 0;
	virtual VOID STDMETHODCALLTYPE SqlUmsSwitchPremptive () = 0;
	virtual VOID STDMETHODCALLTYPE SqlUmsSwitchNonPremptive() = 0;
	virtual BOOL STDMETHODCALLTYPE SqlUmsFIsPremptive() = 0;
};

#endif

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.03.0110 */
/* at Tue May 09 16:41:59 2000
 */
/* Compiler settings for sqloledb.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __sqloledb_h__
#define __sqloledb_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ISQLServerErrorInfo_FWD_DEFINED__
#define __ISQLServerErrorInfo_FWD_DEFINED__
typedef interface ISQLServerErrorInfo ISQLServerErrorInfo;
#endif 	/* __ISQLServerErrorInfo_FWD_DEFINED__ */


#ifndef __IRowsetFastLoad_FWD_DEFINED__
#define __IRowsetFastLoad_FWD_DEFINED__
typedef interface IRowsetFastLoad IRowsetFastLoad;
#endif 	/* __IRowsetFastLoad_FWD_DEFINED__ */


#ifndef __ISchemaLock_FWD_DEFINED__
#define __ISchemaLock_FWD_DEFINED__
typedef interface ISchemaLock ISchemaLock;
#endif 	/* __ISchemaLock_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

__post __maybenull
__post __writableTo(byteCount(size))  
void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t size);
void __RPC_USER MIDL_user_free(__inout void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_sqloledb_0000
 * at Tue May 09 16:41:59 2000
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 


// the structure returned by  ISQLServerErrorInfo::GetSQLServerInfo
typedef struct  tagSSErrorInfo
    {
    LPOLESTR pwszMessage;
    LPOLESTR pwszServer;
    LPOLESTR pwszProcedure;
    LONG lNative;
    BYTE bState;
    BYTE bClass;
    WORD wLineNumber;
    }	SSERRORINFO;



extern RPC_IF_HANDLE __MIDL_itf_sqloledb_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sqloledb_0000_v0_0_s_ifspec;

#ifndef __ISQLServerErrorInfo_INTERFACE_DEFINED__
#define __ISQLServerErrorInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISQLServerErrorInfo
 * at Tue May 09 16:41:59 2000
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][object][local][uuid] */ 



EXTERN_C const IID IID_ISQLServerErrorInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5CF4CA12-EF21-11d0-97E7-00C04FC2AD98")
    ISQLServerErrorInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetErrorInfo( 
            /* [out] */ SSERRORINFO __RPC_FAR *__RPC_FAR *ppErrorInfo,
            __deref_out
            /* [out] */ OLECHAR __RPC_FAR *__RPC_FAR *ppStringsBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISQLServerErrorInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISQLServerErrorInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISQLServerErrorInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISQLServerErrorInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetErrorInfo )( 
            ISQLServerErrorInfo __RPC_FAR * This,
            /* [out] */ SSERRORINFO __RPC_FAR *__RPC_FAR *ppErrorInfo,
            __deref_out
            /* [out] */ OLECHAR __RPC_FAR *__RPC_FAR *ppStringsBuffer);
        
        END_INTERFACE
    } ISQLServerErrorInfoVtbl;

    interface ISQLServerErrorInfo
    {
        CONST_VTBL struct ISQLServerErrorInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISQLServerErrorInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISQLServerErrorInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISQLServerErrorInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISQLServerErrorInfo_GetErrorInfo(This,ppErrorInfo,ppStringsBuffer)	\
    (This)->lpVtbl -> GetErrorInfo(This,ppErrorInfo,ppStringsBuffer)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISQLServerErrorInfo_GetErrorInfo_Proxy( 
    ISQLServerErrorInfo __RPC_FAR * This,
    /* [out] */ SSERRORINFO __RPC_FAR *__RPC_FAR *ppErrorInfo,
    __deref_out
    /* [out] */ OLECHAR __RPC_FAR *__RPC_FAR *ppStringsBuffer);


void __RPC_STUB ISQLServerErrorInfo_GetErrorInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISQLServerErrorInfo_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_sqloledb_0006
 * at Tue May 09 16:41:59 2000
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 

#ifdef _WIN64
typedef ULONG_PTR HACCESSOR;
#else
typedef ULONG HACCESSOR;
#endif


extern RPC_IF_HANDLE __MIDL_itf_sqloledb_0006_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sqloledb_0006_v0_0_s_ifspec;

#ifndef __IRowsetFastLoad_INTERFACE_DEFINED__
#define __IRowsetFastLoad_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRowsetFastLoad
 * at Tue May 09 16:41:59 2000
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][object][local][uuid] */ 



EXTERN_C const IID IID_IRowsetFastLoad;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5CF4CA13-EF21-11d0-97E7-00C04FC2AD98")
    IRowsetFastLoad : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InsertRow( 
            /* [in] */ HACCESSOR hAccessor,
            /* [in] */ void __RPC_FAR *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( 
            /* [in] */ BOOL fDone) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRowsetFastLoadVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRowsetFastLoad __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRowsetFastLoad __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRowsetFastLoad __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InsertRow )( 
            IRowsetFastLoad __RPC_FAR * This,
            /* [in] */ HACCESSOR hAccessor,
            /* [in] */ void __RPC_FAR *pData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Commit )( 
            IRowsetFastLoad __RPC_FAR * This,
            /* [in] */ BOOL fDone);
        
        END_INTERFACE
    } IRowsetFastLoadVtbl;

    interface IRowsetFastLoad
    {
        CONST_VTBL struct IRowsetFastLoadVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRowsetFastLoad_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRowsetFastLoad_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRowsetFastLoad_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRowsetFastLoad_InsertRow(This,hAccessor,pData)	\
    (This)->lpVtbl -> InsertRow(This,hAccessor,pData)

#define IRowsetFastLoad_Commit(This,fDone)	\
    (This)->lpVtbl -> Commit(This,fDone)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRowsetFastLoad_InsertRow_Proxy( 
    IRowsetFastLoad __RPC_FAR * This,
    /* [in] */ HACCESSOR hAccessor,
    /* [in] */ void __RPC_FAR *pData);


void __RPC_STUB IRowsetFastLoad_InsertRow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowsetFastLoad_Commit_Proxy( 
    IRowsetFastLoad __RPC_FAR * This,
    /* [in] */ BOOL fDone);


void __RPC_STUB IRowsetFastLoad_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRowsetFastLoad_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_sqloledb_0007
 * at Tue May 09 16:41:59 2000
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 

typedef DWORD LOCKMODE;

enum LOCKMODEENUM
    {	LOCKMODE_INVALID	= 0,
	LOCKMODE_EXCLUSIVE	= LOCKMODE_INVALID + 1,
	LOCKMODE_SHARED	= LOCKMODE_EXCLUSIVE + 1
    };

extern RPC_IF_HANDLE __MIDL_itf_sqloledb_0007_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sqloledb_0007_v0_0_s_ifspec;

#ifndef __ISchemaLock_INTERFACE_DEFINED__
#define __ISchemaLock_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISchemaLock
 * at Tue May 09 16:41:59 2000
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][object][local][uuid] */ 



EXTERN_C const IID IID_ISchemaLock;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4C2389FB-2511-11d4-B258-00C04F7971CE")
    ISchemaLock : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSchemaLock( 
            /* [in] */ DBID __RPC_FAR *pTableID,
            /* [in] */ LOCKMODE lmMode,
            /* [out] */ HANDLE __RPC_FAR *phLockHandle,
            /* [out] */ ULONGLONG __RPC_FAR *pTableVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseSchemaLock( 
            /* [in] */ HANDLE hLockHandle) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISchemaLockVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISchemaLock __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISchemaLock __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISchemaLock __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSchemaLock )( 
            ISchemaLock __RPC_FAR * This,
            /* [in] */ DBID __RPC_FAR *pTableID,
            /* [in] */ LOCKMODE lmMode,
            /* [out] */ HANDLE __RPC_FAR *phLockHandle,
            /* [out] */ ULONGLONG __RPC_FAR *pTableVersion);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleaseSchemaLock )( 
            ISchemaLock __RPC_FAR * This,
            /* [in] */ HANDLE hLockHandle);
        
        END_INTERFACE
    } ISchemaLockVtbl;

    interface ISchemaLock
    {
        CONST_VTBL struct ISchemaLockVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISchemaLock_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISchemaLock_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISchemaLock_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISchemaLock_GetSchemaLock(This,pTableID,lmMode,phLockHandle,pTableVersion)	\
    (This)->lpVtbl -> GetSchemaLock(This,pTableID,lmMode,phLockHandle,pTableVersion)

#define ISchemaLock_ReleaseSchemaLock(This,hLockHandle)	\
    (This)->lpVtbl -> ReleaseSchemaLock(This,hLockHandle)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISchemaLock_GetSchemaLock_Proxy( 
    ISchemaLock __RPC_FAR * This,
    /* [in] */ DBID __RPC_FAR *pTableID,
    /* [in] */ LOCKMODE lmMode,
    /* [out] */ HANDLE __RPC_FAR *phLockHandle,
    /* [out] */ ULONGLONG __RPC_FAR *pTableVersion);


void __RPC_STUB ISchemaLock_GetSchemaLock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISchemaLock_ReleaseSchemaLock_Proxy( 
    ISchemaLock __RPC_FAR * This,
    /* [in] */ HANDLE hLockHandle);


void __RPC_STUB ISchemaLock_ReleaseSchemaLock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISchemaLock_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif

#endif //_SQLOLEDB_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\sqlext.h ===
//-----------------------------------------------------------------------------
// File:            sqlext.h
//
// Copyright:       Copyright (c) Microsoft Corporation
//
// Contents:        This is the include for applications using the Microsoft SQL Extensions
//
// Comments:
//
//-----------------------------------------------------------------------------

#ifndef __SQLEXT
#define __SQLEXT

#ifndef __SQL
#include "sql.h"
#endif

#ifdef __cplusplus
extern "C" {                         /* Assume C declarations for C++ */
#endif  /* __cplusplus */

/* generally useful constants */
#define SQL_SPEC_MAJOR     3        /* Major version of specification  */
#define SQL_SPEC_MINOR     52       /* Minor version of specification  */
#define SQL_SPEC_STRING   "03.52"   /* String constant for version */

#define SQL_SQLSTATE_SIZE   5   /* size of SQLSTATE */

typedef SQLTCHAR SQLSTATE[SQL_SQLSTATE_SIZE+1];

#define SQL_MAX_DSN_LENGTH  32  /* maximum data source name size */

#define SQL_MAX_OPTION_STRING_LENGTH    256

/* return code SQL_NO_DATA_FOUND is the same as SQL_NO_DATA */
#if (ODBCVER < 0x0300)
#define SQL_NO_DATA_FOUND   100
#else
#define SQL_NO_DATA_FOUND   SQL_NO_DATA
#endif

/* an end handle type */
#if (ODBCVER >= 0x0300)
#define SQL_HANDLE_SENV     5
#endif  /* ODBCVER >= 0x0300 */

/* env attribute */
#if (ODBCVER >= 0x0300)
#define SQL_ATTR_ODBC_VERSION               200
#define SQL_ATTR_CONNECTION_POOLING         201
#define SQL_ATTR_CP_MATCH                   202
#endif  /* ODBCVER >= 0x0300 */

#if (ODBCVER >= 0x0300)
/* values for SQL_ATTR_CONNECTION_POOLING */
#define SQL_CP_OFF                          0UL
#define SQL_CP_ONE_PER_DRIVER               1UL
#define SQL_CP_ONE_PER_HENV                 2UL
#define SQL_CP_DEFAULT                      SQL_CP_OFF

/* values for SQL_ATTR_CP_MATCH */
#define SQL_CP_STRICT_MATCH                 0UL
#define SQL_CP_RELAXED_MATCH                1UL
#define SQL_CP_MATCH_DEFAULT                SQL_CP_STRICT_MATCH

/* values for SQL_ATTR_ODBC_VERSION */
#define SQL_OV_ODBC2                        2UL
#define SQL_OV_ODBC3                        3UL
#endif  /* ODBCVER >= 0x0300 */

/* connection attributes */
#define SQL_ACCESS_MODE                 101
#define SQL_AUTOCOMMIT                  102
#define SQL_LOGIN_TIMEOUT               103
#define SQL_OPT_TRACE                   104
#define SQL_OPT_TRACEFILE               105
#define SQL_TRANSLATE_DLL               106
#define SQL_TRANSLATE_OPTION            107
#define SQL_TXN_ISOLATION               108
#define SQL_CURRENT_QUALIFIER           109
#define SQL_ODBC_CURSORS                110
#define SQL_QUIET_MODE                  111
#define SQL_PACKET_SIZE                 112

/* connection attributes with new names */
#if (ODBCVER >= 0x0300)
#define SQL_ATTR_ACCESS_MODE        SQL_ACCESS_MODE
#define SQL_ATTR_AUTOCOMMIT         SQL_AUTOCOMMIT
#define SQL_ATTR_CONNECTION_TIMEOUT 113
#define SQL_ATTR_CURRENT_CATALOG    SQL_CURRENT_QUALIFIER
#define SQL_ATTR_DISCONNECT_BEHAVIOR    114
#define SQL_ATTR_ENLIST_IN_DTC      1207
#define SQL_ATTR_ENLIST_IN_XA       1208
#define SQL_ATTR_LOGIN_TIMEOUT      SQL_LOGIN_TIMEOUT
#define SQL_ATTR_ODBC_CURSORS       SQL_ODBC_CURSORS
#define SQL_ATTR_PACKET_SIZE        SQL_PACKET_SIZE
#define SQL_ATTR_QUIET_MODE         SQL_QUIET_MODE
#define SQL_ATTR_TRACE              SQL_OPT_TRACE
#define SQL_ATTR_TRACEFILE          SQL_OPT_TRACEFILE
#define SQL_ATTR_TRANSLATE_LIB      SQL_TRANSLATE_DLL
#define SQL_ATTR_TRANSLATE_OPTION   SQL_TRANSLATE_OPTION
#define SQL_ATTR_TXN_ISOLATION      SQL_TXN_ISOLATION
#endif  /* ODBCVER >= 0x0300 */

#define SQL_ATTR_CONNECTION_DEAD    1209    /* GetConnectAttr only */

#if (ODBCVER >= 0x0351)
/*  ODBC Driver Manager sets this connection attribute to a unicode driver
    (which supports SQLConnectW) when the application is an ANSI application
    (which calls SQLConnect, SQLDriverConnect, or SQLBrowseConnect).
    This is SetConnectAttr only and application does not set this attribute
    This attribute was introduced because some unicode driver's some APIs may
    need to behave differently on ANSI or Unicode applications. A unicode
    driver, which  has same behavior for both ANSI or Unicode applications,
    should return SQL_ERROR when the driver manager sets this connection
    attribute. When a unicode driver returns SQL_SUCCESS on this attribute,
    the driver manager treates ANSI and Unicode connections differently in
    connection pooling.
*/
#define SQL_ATTR_ANSI_APP           115
#endif

/* SQL_CONNECT_OPT_DRVR_START is not meaningful for 3.0 driver */
#if (ODBCVER < 0x0300)
#define SQL_CONNECT_OPT_DRVR_START      1000
#endif  /* ODBCVER < 0x0300 */

#if (ODBCVER < 0x0300)
#define SQL_CONN_OPT_MAX                SQL_PACKET_SIZE
#define SQL_CONN_OPT_MIN                SQL_ACCESS_MODE
#endif /* ODBCVER < 0x0300 */

/* SQL_ACCESS_MODE options */
#define SQL_MODE_READ_WRITE             0UL
#define SQL_MODE_READ_ONLY              1UL
#define SQL_MODE_DEFAULT                SQL_MODE_READ_WRITE

/* SQL_AUTOCOMMIT options */
#define SQL_AUTOCOMMIT_OFF              0UL
#define SQL_AUTOCOMMIT_ON               1UL
#define SQL_AUTOCOMMIT_DEFAULT          SQL_AUTOCOMMIT_ON

/* SQL_LOGIN_TIMEOUT options */
#define SQL_LOGIN_TIMEOUT_DEFAULT       15UL

/* SQL_OPT_TRACE options */
#define SQL_OPT_TRACE_OFF               0UL
#define SQL_OPT_TRACE_ON                1UL
#define SQL_OPT_TRACE_DEFAULT           SQL_OPT_TRACE_OFF
#define SQL_OPT_TRACE_FILE_DEFAULT      "\\SQL.LOG"

/* SQL_ODBC_CURSORS options */
#define SQL_CUR_USE_IF_NEEDED           0UL
#define SQL_CUR_USE_ODBC                1UL
#define SQL_CUR_USE_DRIVER              2UL
#define SQL_CUR_DEFAULT                 SQL_CUR_USE_DRIVER

#if (ODBCVER >= 0x0300)
/* values for SQL_ATTR_DISCONNECT_BEHAVIOR */
#define SQL_DB_RETURN_TO_POOL           0UL
#define SQL_DB_DISCONNECT               1UL
#define SQL_DB_DEFAULT                  SQL_DB_RETURN_TO_POOL

/* values for SQL_ATTR_ENLIST_IN_DTC */
#define SQL_DTC_DONE                    0L
#endif  /* ODBCVER >= 0x0300 */

/* values for SQL_ATTR_CONNECTION_DEAD */
#define SQL_CD_TRUE                 1L      /* Connection is closed/dead */
#define SQL_CD_FALSE                0L      /* Connection is open/available */

/* values for SQL_ATTR_ANSI_APP */
#if (ODBCVER >= 0x0351)
#define SQL_AA_TRUE                 1L  /* the application is an ANSI app */
#define SQL_AA_FALSE                    0L  /* the application is a Unicode app */
#endif

/* statement attributes */
#define SQL_QUERY_TIMEOUT       0
#define SQL_MAX_ROWS            1
#define SQL_NOSCAN              2
#define SQL_MAX_LENGTH          3
#define SQL_ASYNC_ENABLE        4   /* same as SQL_ATTR_ASYNC_ENABLE */
#define SQL_BIND_TYPE           5
#define SQL_CURSOR_TYPE         6
#define SQL_CONCURRENCY         7
#define SQL_KEYSET_SIZE         8
#define SQL_ROWSET_SIZE         9
#define SQL_SIMULATE_CURSOR     10
#define SQL_RETRIEVE_DATA       11
#define SQL_USE_BOOKMARKS       12
#define SQL_GET_BOOKMARK        13      /*      GetStmtOption Only */
#define SQL_ROW_NUMBER          14      /*      GetStmtOption Only */

/* statement attributes for ODBC 3.0 */
#if (ODBCVER >= 0x0300)
#define SQL_ATTR_ASYNC_ENABLE               4
#define SQL_ATTR_CONCURRENCY                SQL_CONCURRENCY
#define SQL_ATTR_CURSOR_TYPE                SQL_CURSOR_TYPE
#define SQL_ATTR_ENABLE_AUTO_IPD            15
#define SQL_ATTR_FETCH_BOOKMARK_PTR         16
#define SQL_ATTR_KEYSET_SIZE                SQL_KEYSET_SIZE
#define SQL_ATTR_MAX_LENGTH                 SQL_MAX_LENGTH
#define SQL_ATTR_MAX_ROWS                   SQL_MAX_ROWS
#define SQL_ATTR_NOSCAN                     SQL_NOSCAN
#define SQL_ATTR_PARAM_BIND_OFFSET_PTR      17
#define SQL_ATTR_PARAM_BIND_TYPE            18
#define SQL_ATTR_PARAM_OPERATION_PTR        19
#define SQL_ATTR_PARAM_STATUS_PTR           20
#define SQL_ATTR_PARAMS_PROCESSED_PTR       21
#define SQL_ATTR_PARAMSET_SIZE              22
#define SQL_ATTR_QUERY_TIMEOUT              SQL_QUERY_TIMEOUT
#define SQL_ATTR_RETRIEVE_DATA              SQL_RETRIEVE_DATA
#define SQL_ATTR_ROW_BIND_OFFSET_PTR        23
#define SQL_ATTR_ROW_BIND_TYPE              SQL_BIND_TYPE
#define SQL_ATTR_ROW_NUMBER                 SQL_ROW_NUMBER      /*GetStmtAttr*/
#define SQL_ATTR_ROW_OPERATION_PTR          24
#define SQL_ATTR_ROW_STATUS_PTR             25
#define SQL_ATTR_ROWS_FETCHED_PTR           26
#define SQL_ATTR_ROW_ARRAY_SIZE             27
#define SQL_ATTR_SIMULATE_CURSOR            SQL_SIMULATE_CURSOR
#define SQL_ATTR_USE_BOOKMARKS              SQL_USE_BOOKMARKS

#endif  /* ODBCVER >= 0x0300 */

#if (ODBCVER < 0x0300)
#define SQL_STMT_OPT_MAX                SQL_ROW_NUMBER
#define SQL_STMT_OPT_MIN    SQL_QUERY_TIMEOUT
#endif      /* ODBCVER < 0x0300 */

/* New defines for SEARCHABLE column in SQLGetTypeInfo */

#if (ODBCVER >= 0x0300)
#define SQL_COL_PRED_CHAR       SQL_LIKE_ONLY
#define SQL_COL_PRED_BASIC      SQL_ALL_EXCEPT_LIKE
#endif /* ODBCVER >= 0x0300 */



/* whether an attribute is a pointer or not */
#if (ODBCVER >= 0x0300)
#define SQL_IS_POINTER                          (-4)
#define SQL_IS_UINTEGER                         (-5)
#define SQL_IS_INTEGER                          (-6)
#define SQL_IS_USMALLINT                        (-7)
#define SQL_IS_SMALLINT                         (-8)
#endif  /* ODBCVER >= 0x0300 */

/* the value of SQL_ATTR_PARAM_BIND_TYPE */
#if (ODBCVER >= 0x0300)
#define SQL_PARAM_BIND_BY_COLUMN            0UL
#define SQL_PARAM_BIND_TYPE_DEFAULT         SQL_PARAM_BIND_BY_COLUMN
#endif  /* ODBCVER >= 0x0300 */

/* SQL_QUERY_TIMEOUT options */
#define SQL_QUERY_TIMEOUT_DEFAULT       0UL

/* SQL_MAX_ROWS options */
#define SQL_MAX_ROWS_DEFAULT            0UL

/* SQL_NOSCAN options */
#define SQL_NOSCAN_OFF                  0UL     /*      1.0 FALSE */
#define SQL_NOSCAN_ON                   1UL     /*      1.0 TRUE */
#define SQL_NOSCAN_DEFAULT              SQL_NOSCAN_OFF

/* SQL_MAX_LENGTH options */
#define SQL_MAX_LENGTH_DEFAULT          0UL

/* values for SQL_ATTR_ASYNC_ENABLE */
#define SQL_ASYNC_ENABLE_OFF            0UL
#define SQL_ASYNC_ENABLE_ON             1UL
#define SQL_ASYNC_ENABLE_DEFAULT        SQL_ASYNC_ENABLE_OFF

/* SQL_BIND_TYPE options */
#define SQL_BIND_BY_COLUMN              0UL
#define SQL_BIND_TYPE_DEFAULT           SQL_BIND_BY_COLUMN  /* Default value */

/* SQL_CONCURRENCY options */
#define SQL_CONCUR_READ_ONLY            1
#define SQL_CONCUR_LOCK                 2
#define SQL_CONCUR_ROWVER               3
#define SQL_CONCUR_VALUES               4
#define SQL_CONCUR_DEFAULT              SQL_CONCUR_READ_ONLY /* Default value */

/* SQL_CURSOR_TYPE options */
#define SQL_CURSOR_FORWARD_ONLY         0UL
#define SQL_CURSOR_KEYSET_DRIVEN        1UL
#define SQL_CURSOR_DYNAMIC              2UL
#define SQL_CURSOR_STATIC               3UL
#define SQL_CURSOR_TYPE_DEFAULT         SQL_CURSOR_FORWARD_ONLY /* Default value */

/* SQL_ROWSET_SIZE options */
#define SQL_ROWSET_SIZE_DEFAULT         1UL

/* SQL_KEYSET_SIZE options */
#define SQL_KEYSET_SIZE_DEFAULT         0UL

/* SQL_SIMULATE_CURSOR options */
#define SQL_SC_NON_UNIQUE               0UL
#define SQL_SC_TRY_UNIQUE               1UL
#define SQL_SC_UNIQUE                   2UL

/* SQL_RETRIEVE_DATA options */
#define SQL_RD_OFF                      0UL
#define SQL_RD_ON                       1UL
#define SQL_RD_DEFAULT                  SQL_RD_ON

/* SQL_USE_BOOKMARKS options */
#define SQL_UB_OFF                      0UL
#define SQL_UB_ON                       01UL
#define SQL_UB_DEFAULT                  SQL_UB_OFF

/* New values for SQL_USE_BOOKMARKS attribute */
#if (ODBCVER >= 0x0300)
#define SQL_UB_FIXED                    SQL_UB_ON
#define SQL_UB_VARIABLE                 2UL
#endif  /* ODBCVER >= 0x0300 */

/* extended descriptor field */
#if (ODBCVER >= 0x0300)
#define SQL_DESC_ARRAY_SIZE                     20
#define SQL_DESC_ARRAY_STATUS_PTR               21
#define SQL_DESC_AUTO_UNIQUE_VALUE              SQL_COLUMN_AUTO_INCREMENT
#define SQL_DESC_BASE_COLUMN_NAME               22
#define SQL_DESC_BASE_TABLE_NAME                23
#define SQL_DESC_BIND_OFFSET_PTR                24
#define SQL_DESC_BIND_TYPE                      25
#define SQL_DESC_CASE_SENSITIVE                 SQL_COLUMN_CASE_SENSITIVE
#define SQL_DESC_CATALOG_NAME                   SQL_COLUMN_QUALIFIER_NAME
#define SQL_DESC_CONCISE_TYPE                   SQL_COLUMN_TYPE
#define SQL_DESC_DATETIME_INTERVAL_PRECISION    26
#define SQL_DESC_DISPLAY_SIZE                   SQL_COLUMN_DISPLAY_SIZE
#define SQL_DESC_FIXED_PREC_SCALE               SQL_COLUMN_MONEY
#define SQL_DESC_LABEL                          SQL_COLUMN_LABEL
#define SQL_DESC_LITERAL_PREFIX                 27
#define SQL_DESC_LITERAL_SUFFIX                 28
#define SQL_DESC_LOCAL_TYPE_NAME                29
#define SQL_DESC_MAXIMUM_SCALE                  30
#define SQL_DESC_MINIMUM_SCALE                  31
#define SQL_DESC_NUM_PREC_RADIX                 32
#define SQL_DESC_PARAMETER_TYPE                 33
#define SQL_DESC_ROWS_PROCESSED_PTR             34
#if (ODBCVER >= 0x0350)
#define SQL_DESC_ROWVER                         35
#endif /* ODBCVER >= 0x0350 */
#define SQL_DESC_SCHEMA_NAME                    SQL_COLUMN_OWNER_NAME
#define SQL_DESC_SEARCHABLE                     SQL_COLUMN_SEARCHABLE
#define SQL_DESC_TYPE_NAME                      SQL_COLUMN_TYPE_NAME
#define SQL_DESC_TABLE_NAME                     SQL_COLUMN_TABLE_NAME
#define SQL_DESC_UNSIGNED                       SQL_COLUMN_UNSIGNED
#define SQL_DESC_UPDATABLE                      SQL_COLUMN_UPDATABLE
#endif /* ODBCVER >= 0x0300 */


/* defines for diagnostics fields */
#if (ODBCVER >= 0x0300)
#define SQL_DIAG_CURSOR_ROW_COUNT           (-1249)
#define SQL_DIAG_ROW_NUMBER                 (-1248)
#define SQL_DIAG_COLUMN_NUMBER              (-1247)
#endif /* ODBCVER >= 0x0300 */

/* SQL extended datatypes */
#define SQL_DATE                                9
#if (ODBCVER >= 0x0300)
#define SQL_INTERVAL                            10
#endif  /* ODBCVER >= 0x0300 */
#define SQL_TIME                                10
#define SQL_TIMESTAMP                           11
#define SQL_LONGVARCHAR                         (-1)
#define SQL_BINARY                              (-2)
#define SQL_VARBINARY                           (-3)
#define SQL_LONGVARBINARY                       (-4)
#define SQL_BIGINT                              (-5)
#define SQL_TINYINT                             (-6)
#define SQL_BIT                                 (-7)
#if (ODBCVER >= 0x0350)
#define SQL_GUID                (-11)
#endif  /* ODBCVER >= 0x0350 */

#if (ODBCVER >= 0x0300)
/* interval code */
#define SQL_CODE_YEAR               1
#define SQL_CODE_MONTH              2
#define SQL_CODE_DAY                3
#define SQL_CODE_HOUR               4
#define SQL_CODE_MINUTE             5
#define SQL_CODE_SECOND             6
#define SQL_CODE_YEAR_TO_MONTH          7
#define SQL_CODE_DAY_TO_HOUR            8
#define SQL_CODE_DAY_TO_MINUTE          9
#define SQL_CODE_DAY_TO_SECOND          10
#define SQL_CODE_HOUR_TO_MINUTE         11
#define SQL_CODE_HOUR_TO_SECOND         12
#define SQL_CODE_MINUTE_TO_SECOND       13

#define SQL_INTERVAL_YEAR                   (100 + SQL_CODE_YEAR)
#define SQL_INTERVAL_MONTH                  (100 + SQL_CODE_MONTH)
#define SQL_INTERVAL_DAY                    (100 + SQL_CODE_DAY)
#define SQL_INTERVAL_HOUR                   (100 + SQL_CODE_HOUR)
#define SQL_INTERVAL_MINUTE                 (100 + SQL_CODE_MINUTE)
#define SQL_INTERVAL_SECOND                 (100 + SQL_CODE_SECOND)
#define SQL_INTERVAL_YEAR_TO_MONTH          (100 + SQL_CODE_YEAR_TO_MONTH)
#define SQL_INTERVAL_DAY_TO_HOUR            (100 + SQL_CODE_DAY_TO_HOUR)
#define SQL_INTERVAL_DAY_TO_MINUTE          (100 + SQL_CODE_DAY_TO_MINUTE)
#define SQL_INTERVAL_DAY_TO_SECOND          (100 + SQL_CODE_DAY_TO_SECOND)
#define SQL_INTERVAL_HOUR_TO_MINUTE         (100 + SQL_CODE_HOUR_TO_MINUTE)
#define SQL_INTERVAL_HOUR_TO_SECOND         (100 + SQL_CODE_HOUR_TO_SECOND)
#define SQL_INTERVAL_MINUTE_TO_SECOND       (100 + SQL_CODE_MINUTE_TO_SECOND)

#else
#define SQL_INTERVAL_YEAR                       (-80)
#define SQL_INTERVAL_MONTH                      (-81)
#define SQL_INTERVAL_YEAR_TO_MONTH              (-82)
#define SQL_INTERVAL_DAY                        (-83)
#define SQL_INTERVAL_HOUR                       (-84)
#define SQL_INTERVAL_MINUTE                     (-85)
#define SQL_INTERVAL_SECOND                     (-86)
#define SQL_INTERVAL_DAY_TO_HOUR                (-87)
#define SQL_INTERVAL_DAY_TO_MINUTE              (-88)
#define SQL_INTERVAL_DAY_TO_SECOND              (-89)
#define SQL_INTERVAL_HOUR_TO_MINUTE             (-90)
#define SQL_INTERVAL_HOUR_TO_SECOND             (-91)
#define SQL_INTERVAL_MINUTE_TO_SECOND           (-92)
#endif  /* ODBCVER >= 0x0300 */


#if (ODBCVER <= 0x0300)
#define SQL_UNICODE                             (-95)
#define SQL_UNICODE_VARCHAR                     (-96)
#define SQL_UNICODE_LONGVARCHAR                 (-97)
#define SQL_UNICODE_CHAR                        SQL_UNICODE
#else
/* The previous definitions for SQL_UNICODE_ are historical and obsolete */

#define SQL_UNICODE             SQL_WCHAR

#define SQL_UNICODE_VARCHAR     SQL_WVARCHAR
#define SQL_UNICODE_LONGVARCHAR SQL_WLONGVARCHAR
#define SQL_UNICODE_CHAR        SQL_WCHAR
#endif

#if (ODBCVER < 0x0300)
#define SQL_TYPE_DRIVER_START                   SQL_INTERVAL_YEAR
#define SQL_TYPE_DRIVER_END                     SQL_UNICODE_LONGVARCHAR
#endif  /* ODBCVER < 0x0300 */

/* C datatype to SQL datatype mapping      SQL types
                                           ------------------- */
#define SQL_C_CHAR    SQL_CHAR             /* CHAR, VARCHAR, DECIMAL, NUMERIC */
#define SQL_C_LONG    SQL_INTEGER          /* INTEGER                      */
#define SQL_C_SHORT   SQL_SMALLINT         /* SMALLINT                     */
#define SQL_C_FLOAT   SQL_REAL             /* REAL                         */
#define SQL_C_DOUBLE  SQL_DOUBLE           /* FLOAT, DOUBLE                */
#if (ODBCVER >= 0x0300)
#define SQL_C_NUMERIC       SQL_NUMERIC
#endif  /* ODBCVER >= 0x0300 */
#define SQL_C_DEFAULT 99

#define SQL_SIGNED_OFFSET       (-20)
#define SQL_UNSIGNED_OFFSET     (-22)

/* C datatype to SQL datatype mapping */
#define SQL_C_DATE       SQL_DATE
#define SQL_C_TIME       SQL_TIME
#define SQL_C_TIMESTAMP  SQL_TIMESTAMP
#if (ODBCVER >= 0x0300)
#define SQL_C_TYPE_DATE                 SQL_TYPE_DATE
#define SQL_C_TYPE_TIME                 SQL_TYPE_TIME
#define SQL_C_TYPE_TIMESTAMP            SQL_TYPE_TIMESTAMP
#define SQL_C_INTERVAL_YEAR             SQL_INTERVAL_YEAR
#define SQL_C_INTERVAL_MONTH            SQL_INTERVAL_MONTH
#define SQL_C_INTERVAL_DAY              SQL_INTERVAL_DAY
#define SQL_C_INTERVAL_HOUR             SQL_INTERVAL_HOUR
#define SQL_C_INTERVAL_MINUTE           SQL_INTERVAL_MINUTE
#define SQL_C_INTERVAL_SECOND           SQL_INTERVAL_SECOND
#define SQL_C_INTERVAL_YEAR_TO_MONTH    SQL_INTERVAL_YEAR_TO_MONTH
#define SQL_C_INTERVAL_DAY_TO_HOUR      SQL_INTERVAL_DAY_TO_HOUR
#define SQL_C_INTERVAL_DAY_TO_MINUTE    SQL_INTERVAL_DAY_TO_MINUTE
#define SQL_C_INTERVAL_DAY_TO_SECOND    SQL_INTERVAL_DAY_TO_SECOND
#define SQL_C_INTERVAL_HOUR_TO_MINUTE   SQL_INTERVAL_HOUR_TO_MINUTE
#define SQL_C_INTERVAL_HOUR_TO_SECOND   SQL_INTERVAL_HOUR_TO_SECOND
#define SQL_C_INTERVAL_MINUTE_TO_SECOND SQL_INTERVAL_MINUTE_TO_SECOND
#endif  /* ODBCVER >= 0x0300 */
#define SQL_C_BINARY     SQL_BINARY
#define SQL_C_BIT        SQL_BIT
#if (ODBCVER >= 0x0300)
#define SQL_C_SBIGINT   (SQL_BIGINT+SQL_SIGNED_OFFSET)     /* SIGNED BIGINT */
#define SQL_C_UBIGINT   (SQL_BIGINT+SQL_UNSIGNED_OFFSET)   /* UNSIGNED BIGINT */
#endif  /* ODBCVER >= 0x0300 */
#define SQL_C_TINYINT    SQL_TINYINT
#define SQL_C_SLONG      (SQL_C_LONG+SQL_SIGNED_OFFSET)    /* SIGNED INTEGER  */
#define SQL_C_SSHORT     (SQL_C_SHORT+SQL_SIGNED_OFFSET)   /* SIGNED SMALLINT */
#define SQL_C_STINYINT   (SQL_TINYINT+SQL_SIGNED_OFFSET)   /* SIGNED TINYINT  */
#define SQL_C_ULONG      (SQL_C_LONG+SQL_UNSIGNED_OFFSET)  /* UNSIGNED INTEGER*/
#define SQL_C_USHORT     (SQL_C_SHORT+SQL_UNSIGNED_OFFSET) /* UNSIGNED SMALLINT*/
#define SQL_C_UTINYINT   (SQL_TINYINT+SQL_UNSIGNED_OFFSET) /* UNSIGNED TINYINT*/

#ifdef _WIN64
#define SQL_C_BOOKMARK   SQL_C_UBIGINT                     /* BOOKMARK        */
#else
#define SQL_C_BOOKMARK   SQL_C_ULONG                       /* BOOKMARK        */
#endif

#if (ODBCVER >= 0x0350)
#define SQL_C_GUID  SQL_GUID
#endif  /* ODBCVER >= 0x0350 */

#define SQL_TYPE_NULL                   0
#if (ODBCVER < 0x0300)
#define SQL_TYPE_MIN                    SQL_BIT
#define SQL_TYPE_MAX                    SQL_VARCHAR
#endif

#if (ODBCVER >= 0x0300)
#define SQL_C_VARBOOKMARK       SQL_C_BINARY
#endif  /* ODBCVER >= 0x0300 */

/* define for SQL_DIAG_ROW_NUMBER and SQL_DIAG_COLUMN_NUMBER */
#if (ODBCVER >= 0x0300)
#define SQL_NO_ROW_NUMBER                       (-1)
#define SQL_NO_COLUMN_NUMBER                    (-1)
#define SQL_ROW_NUMBER_UNKNOWN                  (-2)
#define SQL_COLUMN_NUMBER_UNKNOWN               (-2)
#endif

/* SQLBindParameter extensions */
#define SQL_DEFAULT_PARAM            (-5)
#define SQL_IGNORE                   (-6)
#if (ODBCVER >= 0x0300)
#define SQL_COLUMN_IGNORE           SQL_IGNORE
#endif  /* ODBCVER >= 0x0300 */
#define SQL_LEN_DATA_AT_EXEC_OFFSET  (-100)
#define SQL_LEN_DATA_AT_EXEC(length) (-(length)+SQL_LEN_DATA_AT_EXEC_OFFSET)

/* binary length for driver specific attributes */
#define SQL_LEN_BINARY_ATTR_OFFSET   (-100)
#define SQL_LEN_BINARY_ATTR(length)  (-(length)+SQL_LEN_BINARY_ATTR_OFFSET)

/* Defines used by Driver Manager when mapping SQLSetParam to SQLBindParameter
*/
#define SQL_PARAM_TYPE_DEFAULT           SQL_PARAM_INPUT_OUTPUT
#define SQL_SETPARAM_VALUE_MAX           (-1L)

/* SQLColAttributes defines */
#define SQL_COLUMN_COUNT                0
#define SQL_COLUMN_NAME                 1
#define SQL_COLUMN_TYPE                 2
#define SQL_COLUMN_LENGTH               3
#define SQL_COLUMN_PRECISION            4
#define SQL_COLUMN_SCALE                5
#define SQL_COLUMN_DISPLAY_SIZE         6
#define SQL_COLUMN_NULLABLE             7
#define SQL_COLUMN_UNSIGNED             8
#define SQL_COLUMN_MONEY                9
#define SQL_COLUMN_UPDATABLE            10
#define SQL_COLUMN_AUTO_INCREMENT       11
#define SQL_COLUMN_CASE_SENSITIVE       12
#define SQL_COLUMN_SEARCHABLE           13
#define SQL_COLUMN_TYPE_NAME            14
#define SQL_COLUMN_TABLE_NAME           15
#define SQL_COLUMN_OWNER_NAME           16
#define SQL_COLUMN_QUALIFIER_NAME       17
#define SQL_COLUMN_LABEL                18
#define SQL_COLATT_OPT_MAX              SQL_COLUMN_LABEL
#if (ODBCVER < 0x0300)
#define SQL_COLUMN_DRIVER_START         1000
#endif  /* ODBCVER < 0x0300 */

#define SQL_COLATT_OPT_MIN              SQL_COLUMN_COUNT

/* SQLColAttributes subdefines for SQL_COLUMN_UPDATABLE */
#define SQL_ATTR_READONLY               0
#define SQL_ATTR_WRITE                  1
#define SQL_ATTR_READWRITE_UNKNOWN      2

/* SQLColAttributes subdefines for SQL_COLUMN_SEARCHABLE */
/* These are also used by SQLGetInfo                     */
#define SQL_UNSEARCHABLE                0
#define SQL_LIKE_ONLY                   1
#define SQL_ALL_EXCEPT_LIKE             2
#define SQL_SEARCHABLE                  3
#define SQL_PRED_SEARCHABLE             SQL_SEARCHABLE


/* Special return values for SQLGetData */
#define SQL_NO_TOTAL                    (-4)

/********************************************/
/* SQLGetFunctions: additional values for   */
/* fFunction to represent functions that    */
/* are not in the X/Open spec.              */
/********************************************/

#if (ODBCVER >= 0x0300)
#define SQL_API_SQLALLOCHANDLESTD   73
#define SQL_API_SQLBULKOPERATIONS   24
#endif /* ODBCVER >= 0x0300 */
#define SQL_API_SQLBINDPARAMETER    72
#define SQL_API_SQLBROWSECONNECT    55
#define SQL_API_SQLCOLATTRIBUTES    6
#define SQL_API_SQLCOLUMNPRIVILEGES 56
#define SQL_API_SQLDESCRIBEPARAM    58
#define SQL_API_SQLDRIVERCONNECT    41
#define SQL_API_SQLDRIVERS          71
#define SQL_API_SQLEXTENDEDFETCH    59
#define SQL_API_SQLFOREIGNKEYS      60
#define SQL_API_SQLMORERESULTS      61
#define SQL_API_SQLNATIVESQL        62
#define SQL_API_SQLNUMPARAMS        63
#define SQL_API_SQLPARAMOPTIONS     64
#define SQL_API_SQLPRIMARYKEYS      65
#define SQL_API_SQLPROCEDURECOLUMNS 66
#define SQL_API_SQLPROCEDURES       67
#define SQL_API_SQLSETPOS           68
#define SQL_API_SQLSETSCROLLOPTIONS 69
#define SQL_API_SQLTABLEPRIVILEGES  70

/*-------------------------------------------*/
/* SQL_EXT_API_LAST is not useful with ODBC  */
/* version 3.0 because some of the values    */
/* from X/Open are in the 10000 range.       */
/*-------------------------------------------*/

#if (ODBCVER < 0x0300)
#define SQL_EXT_API_LAST            SQL_API_SQLBINDPARAMETER
#define SQL_NUM_FUNCTIONS           23
#define SQL_EXT_API_START           40
#define SQL_NUM_EXTENSIONS (SQL_EXT_API_LAST-SQL_EXT_API_START+1)
#endif

/*--------------------------------------------*/
/* SQL_API_ALL_FUNCTIONS returns an array     */
/* of 'booleans' representing whether a       */
/* function is implemented by the driver.     */
/*                                            */
/* CAUTION: Only functions defined in ODBC    */
/* version 2.0 and earlier are returned, the  */
/* new high-range function numbers defined by */
/* X/Open break this scheme.   See the new    */
/* method -- SQL_API_ODBC3_ALL_FUNCTIONS      */
/*--------------------------------------------*/

#define SQL_API_ALL_FUNCTIONS       0       /* See CAUTION above */

/*----------------------------------------------*/
/* 2.X drivers export a dummy function with     */
/* ordinal number SQL_API_LOADBYORDINAL to speed*/
/* loading under the windows operating system.  */
/*                      */
/* CAUTION: Loading by ordinal is not supported */
/* for 3.0 and above drivers.           */
/*----------------------------------------------*/

#define SQL_API_LOADBYORDINAL       199     /* See CAUTION above */

/*----------------------------------------------*/
/* SQL_API_ODBC3_ALL_FUNCTIONS                  */
/* This returns a bitmap, which allows us to    */
/* handle the higher-valued function numbers.   */
/* Use  SQL_FUNC_EXISTS(bitmap,function_number) */
/* to determine if the function exists.         */
/*----------------------------------------------*/


#if (ODBCVER >= 0x0300)
#define SQL_API_ODBC3_ALL_FUNCTIONS 999
#define SQL_API_ODBC3_ALL_FUNCTIONS_SIZE    250     /* array of 250 words */

#define SQL_FUNC_EXISTS(pfExists, uwAPI) \
                ((*(((UWORD*) (pfExists)) + ((uwAPI) >> 4)) \
                    & (1 << ((uwAPI) & 0x000F)) \
                 ) ? SQL_TRUE : SQL_FALSE \
                )
#endif  /* ODBCVER >= 0x0300 */


/************************************************/
/* Extended definitions for SQLGetInfo          */
/************************************************/

/*---------------------------------*/
/* Values in ODBC 2.0 that are not */
/* in the X/Open spec              */
/*---------------------------------*/

#define SQL_INFO_FIRST                       0
#define SQL_ACTIVE_CONNECTIONS               0  /* MAX_DRIVER_CONNECTIONS */
#define SQL_ACTIVE_STATEMENTS                1  /* MAX_CONCURRENT_ACTIVITIES */
#define SQL_DRIVER_HDBC                      3
#define SQL_DRIVER_HENV                      4
#define SQL_DRIVER_HSTMT                     5
#define SQL_DRIVER_NAME                      6
#define SQL_DRIVER_VER                       7
#define SQL_ODBC_API_CONFORMANCE             9
#define SQL_ODBC_VER                        10
#define SQL_ROW_UPDATES                     11
#define SQL_ODBC_SAG_CLI_CONFORMANCE        12
#define SQL_ODBC_SQL_CONFORMANCE            15
#define SQL_PROCEDURES                      21
#define SQL_CONCAT_NULL_BEHAVIOR            22
#define SQL_CURSOR_ROLLBACK_BEHAVIOR        24
#define SQL_EXPRESSIONS_IN_ORDERBY          27
#define SQL_MAX_OWNER_NAME_LEN              32  /* MAX_SCHEMA_NAME_LEN */
#define SQL_MAX_PROCEDURE_NAME_LEN          33
#define SQL_MAX_QUALIFIER_NAME_LEN          34  /* MAX_CATALOG_NAME_LEN */
#define SQL_MULT_RESULT_SETS                36
#define SQL_MULTIPLE_ACTIVE_TXN             37
#define SQL_OUTER_JOINS                     38
#define SQL_OWNER_TERM                      39
#define SQL_PROCEDURE_TERM                  40
#define SQL_QUALIFIER_NAME_SEPARATOR        41
#define SQL_QUALIFIER_TERM                  42
#define SQL_SCROLL_OPTIONS                  44
#define SQL_TABLE_TERM                      45
#define SQL_CONVERT_FUNCTIONS               48
#define SQL_NUMERIC_FUNCTIONS               49
#define SQL_STRING_FUNCTIONS                50
#define SQL_SYSTEM_FUNCTIONS                51
#define SQL_TIMEDATE_FUNCTIONS              52
#define SQL_CONVERT_BIGINT                  53
#define SQL_CONVERT_BINARY                  54
#define SQL_CONVERT_BIT                     55
#define SQL_CONVERT_CHAR                    56
#define SQL_CONVERT_DATE                    57
#define SQL_CONVERT_DECIMAL                 58
#define SQL_CONVERT_DOUBLE                  59
#define SQL_CONVERT_FLOAT                   60
#define SQL_CONVERT_INTEGER                 61
#define SQL_CONVERT_LONGVARCHAR             62
#define SQL_CONVERT_NUMERIC                 63
#define SQL_CONVERT_REAL                    64
#define SQL_CONVERT_SMALLINT                65
#define SQL_CONVERT_TIME                    66
#define SQL_CONVERT_TIMESTAMP               67
#define SQL_CONVERT_TINYINT                 68
#define SQL_CONVERT_VARBINARY               69
#define SQL_CONVERT_VARCHAR                 70
#define SQL_CONVERT_LONGVARBINARY           71
#define SQL_ODBC_SQL_OPT_IEF                73      /* SQL_INTEGRITY */
#define SQL_CORRELATION_NAME                74
#define SQL_NON_NULLABLE_COLUMNS            75
#define SQL_DRIVER_HLIB                     76
#define SQL_DRIVER_ODBC_VER                 77
#define SQL_LOCK_TYPES                      78
#define SQL_POS_OPERATIONS                  79
#define SQL_POSITIONED_STATEMENTS           80
#define SQL_BOOKMARK_PERSISTENCE            82
#define SQL_STATIC_SENSITIVITY              83
#define SQL_FILE_USAGE                      84
#define SQL_COLUMN_ALIAS                    87
#define SQL_GROUP_BY                        88
#define SQL_KEYWORDS                        89
#define SQL_OWNER_USAGE                     91
#define SQL_QUALIFIER_USAGE                 92
#define SQL_QUOTED_IDENTIFIER_CASE          93
#define SQL_SUBQUERIES                      95
#define SQL_UNION                           96
#define SQL_MAX_ROW_SIZE_INCLUDES_LONG      103
#define SQL_MAX_CHAR_LITERAL_LEN            108
#define SQL_TIMEDATE_ADD_INTERVALS          109
#define SQL_TIMEDATE_DIFF_INTERVALS         110
#define SQL_NEED_LONG_DATA_LEN              111
#define SQL_MAX_BINARY_LITERAL_LEN          112
#define SQL_LIKE_ESCAPE_CLAUSE              113
#define SQL_QUALIFIER_LOCATION              114

#if (ODBCVER >= 0x0201 && ODBCVER < 0x0300)
#define SQL_OJ_CAPABILITIES         65003  /* Temp value until ODBC 3.0 */
#endif  /* ODBCVER >= 0x0201 && ODBCVER < 0x0300 */

/*----------------------------------------------*/
/* SQL_INFO_LAST and SQL_INFO_DRIVER_START are  */
/* not useful anymore, because  X/Open has      */
/* values in the 10000 range.   You             */
/* must contact X/Open directly to get a range  */
/* of numbers for driver-specific values.       */
/*----------------------------------------------*/

#if (ODBCVER < 0x0300)
#define SQL_INFO_LAST                       SQL_QUALIFIER_LOCATION
#define SQL_INFO_DRIVER_START               1000
#endif /* ODBCVER < 0x0300 */

/*-----------------------------------------------*/
/* ODBC 3.0 SQLGetInfo values that are not part  */
/* of the X/Open standard at this time.   X/Open */
/* standard values are in sql.h.                 */
/*-----------------------------------------------*/

#if (ODBCVER >= 0x0300)
#define SQL_ACTIVE_ENVIRONMENTS                 116
#define SQL_ALTER_DOMAIN                        117

#define SQL_SQL_CONFORMANCE                     118
#define SQL_DATETIME_LITERALS                   119

#define SQL_ASYNC_MODE                          10021   /* new X/Open spec */
#define SQL_BATCH_ROW_COUNT                     120
#define SQL_BATCH_SUPPORT                       121
#define SQL_CATALOG_LOCATION                    SQL_QUALIFIER_LOCATION
#define SQL_CATALOG_NAME_SEPARATOR              SQL_QUALIFIER_NAME_SEPARATOR
#define SQL_CATALOG_TERM                        SQL_QUALIFIER_TERM
#define SQL_CATALOG_USAGE                       SQL_QUALIFIER_USAGE
#define SQL_CONVERT_WCHAR                       122
#define SQL_CONVERT_INTERVAL_DAY_TIME           123
#define SQL_CONVERT_INTERVAL_YEAR_MONTH         124
#define SQL_CONVERT_WLONGVARCHAR                125
#define SQL_CONVERT_WVARCHAR                    126
#define SQL_CREATE_ASSERTION                    127
#define SQL_CREATE_CHARACTER_SET                128
#define SQL_CREATE_COLLATION                    129
#define SQL_CREATE_DOMAIN                       130
#define SQL_CREATE_SCHEMA                       131
#define SQL_CREATE_TABLE                        132
#define SQL_CREATE_TRANSLATION                  133
#define SQL_CREATE_VIEW                         134
#define SQL_DRIVER_HDESC                        135
#define SQL_DROP_ASSERTION                      136
#define SQL_DROP_CHARACTER_SET                  137
#define SQL_DROP_COLLATION                      138
#define SQL_DROP_DOMAIN                         139
#define SQL_DROP_SCHEMA                         140
#define SQL_DROP_TABLE                          141
#define SQL_DROP_TRANSLATION                    142
#define SQL_DROP_VIEW                           143
#define SQL_DYNAMIC_CURSOR_ATTRIBUTES1          144
#define SQL_DYNAMIC_CURSOR_ATTRIBUTES2          145
#define SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES1     146
#define SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES2     147
#define SQL_INDEX_KEYWORDS                      148
#define SQL_INFO_SCHEMA_VIEWS                   149
#define SQL_KEYSET_CURSOR_ATTRIBUTES1           150
#define SQL_KEYSET_CURSOR_ATTRIBUTES2           151
#define SQL_MAX_ASYNC_CONCURRENT_STATEMENTS     10022   /* new X/Open spec */
#define SQL_ODBC_INTERFACE_CONFORMANCE          152
#define SQL_PARAM_ARRAY_ROW_COUNTS              153
#define SQL_PARAM_ARRAY_SELECTS                 154
#define SQL_SCHEMA_TERM                         SQL_OWNER_TERM
#define SQL_SCHEMA_USAGE                        SQL_OWNER_USAGE
#define SQL_SQL92_DATETIME_FUNCTIONS            155
#define SQL_SQL92_FOREIGN_KEY_DELETE_RULE       156
#define SQL_SQL92_FOREIGN_KEY_UPDATE_RULE       157
#define SQL_SQL92_GRANT                         158
#define SQL_SQL92_NUMERIC_VALUE_FUNCTIONS       159
#define SQL_SQL92_PREDICATES                    160
#define SQL_SQL92_RELATIONAL_JOIN_OPERATORS     161
#define SQL_SQL92_REVOKE                        162
#define SQL_SQL92_ROW_VALUE_CONSTRUCTOR         163
#define SQL_SQL92_STRING_FUNCTIONS              164
#define SQL_SQL92_VALUE_EXPRESSIONS             165
#define SQL_STANDARD_CLI_CONFORMANCE            166
#define SQL_STATIC_CURSOR_ATTRIBUTES1           167
#define SQL_STATIC_CURSOR_ATTRIBUTES2           168

#define SQL_AGGREGATE_FUNCTIONS                 169
#define SQL_DDL_INDEX                           170
#define SQL_DM_VER                              171
#define SQL_INSERT_STATEMENT                    172
#define SQL_CONVERT_GUID                        173
#define SQL_UNION_STATEMENT                     SQL_UNION
#endif  /* ODBCVER >= 0x0300 */

#define SQL_DTC_TRANSITION_COST                 1750

/* SQL_ALTER_TABLE bitmasks */
#if (ODBCVER >= 0x0300)
/* the following 5 bitmasks are defined in sql.h
*#define SQL_AT_ADD_COLUMN                      0x00000001L
*#define SQL_AT_DROP_COLUMN                     0x00000002L
*#define SQL_AT_ADD_CONSTRAINT                  0x00000008L
*/
#define SQL_AT_ADD_COLUMN_SINGLE                0x00000020L
#define SQL_AT_ADD_COLUMN_DEFAULT               0x00000040L
#define SQL_AT_ADD_COLUMN_COLLATION             0x00000080L
#define SQL_AT_SET_COLUMN_DEFAULT               0x00000100L
#define SQL_AT_DROP_COLUMN_DEFAULT              0x00000200L
#define SQL_AT_DROP_COLUMN_CASCADE              0x00000400L
#define SQL_AT_DROP_COLUMN_RESTRICT             0x00000800L
#define SQL_AT_ADD_TABLE_CONSTRAINT             0x00001000L
#define SQL_AT_DROP_TABLE_CONSTRAINT_CASCADE    0x00002000L
#define SQL_AT_DROP_TABLE_CONSTRAINT_RESTRICT   0x00004000L
#define SQL_AT_CONSTRAINT_NAME_DEFINITION       0x00008000L
#define SQL_AT_CONSTRAINT_INITIALLY_DEFERRED    0x00010000L
#define SQL_AT_CONSTRAINT_INITIALLY_IMMEDIATE   0x00020000L
#define SQL_AT_CONSTRAINT_DEFERRABLE            0x00040000L
#define SQL_AT_CONSTRAINT_NON_DEFERRABLE        0x00080000L
#endif  /* ODBCVER >= 0x0300 */

/* SQL_CONVERT_*  return value bitmasks */

#define SQL_CVT_CHAR                        0x00000001L
#define SQL_CVT_NUMERIC                     0x00000002L
#define SQL_CVT_DECIMAL                     0x00000004L
#define SQL_CVT_INTEGER                     0x00000008L
#define SQL_CVT_SMALLINT                    0x00000010L
#define SQL_CVT_FLOAT                       0x00000020L
#define SQL_CVT_REAL                        0x00000040L
#define SQL_CVT_DOUBLE                      0x00000080L
#define SQL_CVT_VARCHAR                     0x00000100L
#define SQL_CVT_LONGVARCHAR                 0x00000200L
#define SQL_CVT_BINARY                      0x00000400L
#define SQL_CVT_VARBINARY                   0x00000800L
#define SQL_CVT_BIT                         0x00001000L
#define SQL_CVT_TINYINT                     0x00002000L
#define SQL_CVT_BIGINT                      0x00004000L
#define SQL_CVT_DATE                        0x00008000L
#define SQL_CVT_TIME                        0x00010000L
#define SQL_CVT_TIMESTAMP                   0x00020000L
#define SQL_CVT_LONGVARBINARY               0x00040000L
#if (ODBCVER >= 0x0300)
#define SQL_CVT_INTERVAL_YEAR_MONTH         0x00080000L
#define SQL_CVT_INTERVAL_DAY_TIME           0x00100000L
#define SQL_CVT_WCHAR                       0x00200000L
#define SQL_CVT_WLONGVARCHAR                0x00400000L
#define SQL_CVT_WVARCHAR                    0x00800000L
#define SQL_CVT_GUID                        0x01000000L

#endif  /* ODBCVER >= 0x0300 */


/* SQL_CONVERT_FUNCTIONS functions */
#define SQL_FN_CVT_CONVERT                  0x00000001L
#if (ODBCVER >= 0x0300)
#define SQL_FN_CVT_CAST                     0x00000002L
#endif  /* ODBCVER >= 0x0300 */


/* SQL_STRING_FUNCTIONS functions */

#define SQL_FN_STR_CONCAT                   0x00000001L
#define SQL_FN_STR_INSERT                   0x00000002L
#define SQL_FN_STR_LEFT                     0x00000004L
#define SQL_FN_STR_LTRIM                    0x00000008L
#define SQL_FN_STR_LENGTH                   0x00000010L
#define SQL_FN_STR_LOCATE                   0x00000020L
#define SQL_FN_STR_LCASE                    0x00000040L
#define SQL_FN_STR_REPEAT                   0x00000080L
#define SQL_FN_STR_REPLACE                  0x00000100L
#define SQL_FN_STR_RIGHT                    0x00000200L
#define SQL_FN_STR_RTRIM                    0x00000400L
#define SQL_FN_STR_SUBSTRING                0x00000800L
#define SQL_FN_STR_UCASE                    0x00001000L
#define SQL_FN_STR_ASCII                    0x00002000L
#define SQL_FN_STR_CHAR                     0x00004000L
#define SQL_FN_STR_DIFFERENCE               0x00008000L
#define SQL_FN_STR_LOCATE_2                 0x00010000L
#define SQL_FN_STR_SOUNDEX                  0x00020000L
#define SQL_FN_STR_SPACE                    0x00040000L
#if (ODBCVER >= 0x0300)
#define SQL_FN_STR_BIT_LENGTH               0x00080000L
#define SQL_FN_STR_CHAR_LENGTH              0x00100000L
#define SQL_FN_STR_CHARACTER_LENGTH         0x00200000L
#define SQL_FN_STR_OCTET_LENGTH             0x00400000L
#define SQL_FN_STR_POSITION                 0x00800000L
#endif  /* ODBCVER >= 0x0300 */

/* SQL_SQL92_STRING_FUNCTIONS */
#if (ODBCVER >= 0x0300)
#define SQL_SSF_CONVERT                     0x00000001L
#define SQL_SSF_LOWER                       0x00000002L
#define SQL_SSF_UPPER                       0x00000004L
#define SQL_SSF_SUBSTRING                   0x00000008L
#define SQL_SSF_TRANSLATE                   0x00000010L
#define SQL_SSF_TRIM_BOTH                   0x00000020L
#define SQL_SSF_TRIM_LEADING                0x00000040L
#define SQL_SSF_TRIM_TRAILING               0x00000080L
#endif /* ODBCVER >= 0x0300 */

/* SQL_NUMERIC_FUNCTIONS functions */

#define SQL_FN_NUM_ABS                      0x00000001L
#define SQL_FN_NUM_ACOS                     0x00000002L
#define SQL_FN_NUM_ASIN                     0x00000004L
#define SQL_FN_NUM_ATAN                     0x00000008L
#define SQL_FN_NUM_ATAN2                    0x00000010L
#define SQL_FN_NUM_CEILING                  0x00000020L
#define SQL_FN_NUM_COS                      0x00000040L
#define SQL_FN_NUM_COT                      0x00000080L
#define SQL_FN_NUM_EXP                      0x00000100L
#define SQL_FN_NUM_FLOOR                    0x00000200L
#define SQL_FN_NUM_LOG                      0x00000400L
#define SQL_FN_NUM_MOD                      0x00000800L
#define SQL_FN_NUM_SIGN                     0x00001000L
#define SQL_FN_NUM_SIN                      0x00002000L
#define SQL_FN_NUM_SQRT                     0x00004000L
#define SQL_FN_NUM_TAN                      0x00008000L
#define SQL_FN_NUM_PI                       0x00010000L
#define SQL_FN_NUM_RAND                     0x00020000L
#define SQL_FN_NUM_DEGREES                  0x00040000L
#define SQL_FN_NUM_LOG10                    0x00080000L
#define SQL_FN_NUM_POWER                    0x00100000L
#define SQL_FN_NUM_RADIANS                  0x00200000L
#define SQL_FN_NUM_ROUND                    0x00400000L
#define SQL_FN_NUM_TRUNCATE                 0x00800000L

/* SQL_SQL92_NUMERIC_VALUE_FUNCTIONS */
#if (ODBCVER >= 0x0300)
#define SQL_SNVF_BIT_LENGTH                 0x00000001L
#define SQL_SNVF_CHAR_LENGTH                0x00000002L
#define SQL_SNVF_CHARACTER_LENGTH           0x00000004L
#define SQL_SNVF_EXTRACT                    0x00000008L
#define SQL_SNVF_OCTET_LENGTH               0x00000010L
#define SQL_SNVF_POSITION                   0x00000020L
#endif  /* ODBCVER >= 0x0300 */

/* SQL_TIMEDATE_FUNCTIONS functions */

#define SQL_FN_TD_NOW                       0x00000001L
#define SQL_FN_TD_CURDATE                   0x00000002L
#define SQL_FN_TD_DAYOFMONTH                0x00000004L
#define SQL_FN_TD_DAYOFWEEK                 0x00000008L
#define SQL_FN_TD_DAYOFYEAR                 0x00000010L
#define SQL_FN_TD_MONTH                     0x00000020L
#define SQL_FN_TD_QUARTER                   0x00000040L
#define SQL_FN_TD_WEEK                      0x00000080L
#define SQL_FN_TD_YEAR                      0x00000100L
#define SQL_FN_TD_CURTIME                   0x00000200L
#define SQL_FN_TD_HOUR                      0x00000400L
#define SQL_FN_TD_MINUTE                    0x00000800L
#define SQL_FN_TD_SECOND                    0x00001000L
#define SQL_FN_TD_TIMESTAMPADD              0x00002000L
#define SQL_FN_TD_TIMESTAMPDIFF             0x00004000L
#define SQL_FN_TD_DAYNAME                   0x00008000L
#define SQL_FN_TD_MONTHNAME                 0x00010000L
#if (ODBCVER >= 0x0300)
#define SQL_FN_TD_CURRENT_DATE              0x00020000L
#define SQL_FN_TD_CURRENT_TIME              0x00040000L
#define SQL_FN_TD_CURRENT_TIMESTAMP         0x00080000L
#define SQL_FN_TD_EXTRACT                   0x00100000L
#endif  /* ODBCVER >= 0x0300 */

/* SQL_SQL92_DATETIME_FUNCTIONS */
#if (ODBCVER >= 0x0300)
#define SQL_SDF_CURRENT_DATE                0x00000001L
#define SQL_SDF_CURRENT_TIME                0x00000002L
#define SQL_SDF_CURRENT_TIMESTAMP           0x00000004L
#endif /* ODBCVER >= 0x0300 */

/* SQL_SYSTEM_FUNCTIONS functions */

#define SQL_FN_SYS_USERNAME                 0x00000001L
#define SQL_FN_SYS_DBNAME                   0x00000002L
#define SQL_FN_SYS_IFNULL                   0x00000004L

/* SQL_TIMEDATE_ADD_INTERVALS and SQL_TIMEDATE_DIFF_INTERVALS functions */

#define SQL_FN_TSI_FRAC_SECOND              0x00000001L
#define SQL_FN_TSI_SECOND                   0x00000002L
#define SQL_FN_TSI_MINUTE                   0x00000004L
#define SQL_FN_TSI_HOUR                     0x00000008L
#define SQL_FN_TSI_DAY                      0x00000010L
#define SQL_FN_TSI_WEEK                     0x00000020L
#define SQL_FN_TSI_MONTH                    0x00000040L
#define SQL_FN_TSI_QUARTER                  0x00000080L
#define SQL_FN_TSI_YEAR                     0x00000100L

/* bitmasks for SQL_DYNAMIC_CURSOR_ATTRIBUTES1,
 * SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES1,
 * SQL_KEYSET_CURSOR_ATTRIBUTES1, and SQL_STATIC_CURSOR_ATTRIBUTES1
 */
#if (ODBCVER >= 0x0300)
/* supported SQLFetchScroll FetchOrientation's */
#define SQL_CA1_NEXT                        0x00000001L
#define SQL_CA1_ABSOLUTE                    0x00000002L
#define SQL_CA1_RELATIVE                    0x00000004L
#define SQL_CA1_BOOKMARK                    0x00000008L

/* supported SQLSetPos LockType's */
#define SQL_CA1_LOCK_NO_CHANGE              0x00000040L
#define SQL_CA1_LOCK_EXCLUSIVE              0x00000080L
#define SQL_CA1_LOCK_UNLOCK                 0x00000100L

/* supported SQLSetPos Operations */
#define SQL_CA1_POS_POSITION                0x00000200L
#define SQL_CA1_POS_UPDATE                  0x00000400L
#define SQL_CA1_POS_DELETE                  0x00000800L
#define SQL_CA1_POS_REFRESH                 0x00001000L

/* positioned updates and deletes */
#define SQL_CA1_POSITIONED_UPDATE           0x00002000L
#define SQL_CA1_POSITIONED_DELETE           0x00004000L
#define SQL_CA1_SELECT_FOR_UPDATE           0x00008000L

/* supported SQLBulkOperations operations */
#define SQL_CA1_BULK_ADD                    0x00010000L
#define SQL_CA1_BULK_UPDATE_BY_BOOKMARK     0x00020000L
#define SQL_CA1_BULK_DELETE_BY_BOOKMARK     0x00040000L
#define SQL_CA1_BULK_FETCH_BY_BOOKMARK      0x00080000L
#endif  /* ODBCVER >= 0x0300 */

/* bitmasks for SQL_DYNAMIC_CURSOR_ATTRIBUTES2,
 * SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES2,
 * SQL_KEYSET_CURSOR_ATTRIBUTES2, and SQL_STATIC_CURSOR_ATTRIBUTES2
 */
#if (ODBCVER >= 0x0300)
/* supported values for SQL_ATTR_SCROLL_CONCURRENCY */
#define SQL_CA2_READ_ONLY_CONCURRENCY       0x00000001L
#define SQL_CA2_LOCK_CONCURRENCY            0x00000002L
#define SQL_CA2_OPT_ROWVER_CONCURRENCY      0x00000004L
#define SQL_CA2_OPT_VALUES_CONCURRENCY      0x00000008L

/* sensitivity of the cursor to its own inserts, deletes, and updates */
#define SQL_CA2_SENSITIVITY_ADDITIONS       0x00000010L
#define SQL_CA2_SENSITIVITY_DELETIONS       0x00000020L
#define SQL_CA2_SENSITIVITY_UPDATES         0x00000040L

/* semantics of SQL_ATTR_MAX_ROWS */
#define SQL_CA2_MAX_ROWS_SELECT             0x00000080L
#define SQL_CA2_MAX_ROWS_INSERT             0x00000100L
#define SQL_CA2_MAX_ROWS_DELETE             0x00000200L
#define SQL_CA2_MAX_ROWS_UPDATE             0x00000400L
#define SQL_CA2_MAX_ROWS_CATALOG            0x00000800L
#define SQL_CA2_MAX_ROWS_AFFECTS_ALL        (SQL_CA2_MAX_ROWS_SELECT | \
                    SQL_CA2_MAX_ROWS_INSERT | SQL_CA2_MAX_ROWS_DELETE | \
                    SQL_CA2_MAX_ROWS_UPDATE | SQL_CA2_MAX_ROWS_CATALOG)

/* semantics of SQL_DIAG_CURSOR_ROW_COUNT */
#define SQL_CA2_CRC_EXACT                   0x00001000L
#define SQL_CA2_CRC_APPROXIMATE             0x00002000L

/* the kinds of positioned statements that can be simulated */
#define SQL_CA2_SIMULATE_NON_UNIQUE         0x00004000L
#define SQL_CA2_SIMULATE_TRY_UNIQUE         0x00008000L
#define SQL_CA2_SIMULATE_UNIQUE             0x00010000L
#endif  /* ODBCVER >= 0x0300 */

/* SQL_ODBC_API_CONFORMANCE values */

#define SQL_OAC_NONE                        0x0000
#define SQL_OAC_LEVEL1                      0x0001
#define SQL_OAC_LEVEL2                      0x0002

/* SQL_ODBC_SAG_CLI_CONFORMANCE values */

#define SQL_OSCC_NOT_COMPLIANT              0x0000
#define SQL_OSCC_COMPLIANT                  0x0001

/* SQL_ODBC_SQL_CONFORMANCE values */

#define SQL_OSC_MINIMUM                     0x0000
#define SQL_OSC_CORE                        0x0001
#define SQL_OSC_EXTENDED                    0x0002


/* SQL_CONCAT_NULL_BEHAVIOR values */

#define SQL_CB_NULL                         0x0000
#define SQL_CB_NON_NULL                     0x0001

/* SQL_SCROLL_OPTIONS masks */

#define SQL_SO_FORWARD_ONLY                 0x00000001L
#define SQL_SO_KEYSET_DRIVEN                0x00000002L
#define SQL_SO_DYNAMIC                      0x00000004L
#define SQL_SO_MIXED                        0x00000008L
#define SQL_SO_STATIC                       0x00000010L

/* SQL_FETCH_DIRECTION masks */

/* SQL_FETCH_RESUME is no longer supported
#define SQL_FD_FETCH_RESUME                 0x00000040L
*/
#define SQL_FD_FETCH_BOOKMARK               0x00000080L

/* SQL_TXN_ISOLATION_OPTION masks */
/* SQL_TXN_VERSIONING is no longer supported
#define SQL_TXN_VERSIONING                  0x00000010L
*/

/* SQL_CORRELATION_NAME values */

#define SQL_CN_NONE                         0x0000
#define SQL_CN_DIFFERENT                    0x0001
#define SQL_CN_ANY                          0x0002

/* SQL_NON_NULLABLE_COLUMNS values */

#define SQL_NNC_NULL                        0x0000
#define SQL_NNC_NON_NULL                    0x0001

/* SQL_NULL_COLLATION values */

#define SQL_NC_START                        0x0002
#define SQL_NC_END                          0x0004

/* SQL_FILE_USAGE values */

#define SQL_FILE_NOT_SUPPORTED              0x0000
#define SQL_FILE_TABLE                      0x0001
#define SQL_FILE_QUALIFIER                  0x0002
#define SQL_FILE_CATALOG                    SQL_FILE_QUALIFIER  // ODBC 3.0


/* SQL_GETDATA_EXTENSIONS values */

#define SQL_GD_BLOCK                        0x00000004L
#define SQL_GD_BOUND                        0x00000008L

/* SQL_POSITIONED_STATEMENTS masks */

#define SQL_PS_POSITIONED_DELETE            0x00000001L
#define SQL_PS_POSITIONED_UPDATE            0x00000002L
#define SQL_PS_SELECT_FOR_UPDATE            0x00000004L

/* SQL_GROUP_BY values */

#define SQL_GB_NOT_SUPPORTED                0x0000
#define SQL_GB_GROUP_BY_EQUALS_SELECT       0x0001
#define SQL_GB_GROUP_BY_CONTAINS_SELECT     0x0002
#define SQL_GB_NO_RELATION                  0x0003
#if (ODBCVER >= 0x0300)
#define SQL_GB_COLLATE                      0x0004

#endif  /* ODBCVER >= 0x0300 */

/* SQL_OWNER_USAGE masks */

#define SQL_OU_DML_STATEMENTS               0x00000001L
#define SQL_OU_PROCEDURE_INVOCATION         0x00000002L
#define SQL_OU_TABLE_DEFINITION             0x00000004L
#define SQL_OU_INDEX_DEFINITION             0x00000008L
#define SQL_OU_PRIVILEGE_DEFINITION         0x00000010L

/* SQL_SCHEMA_USAGE masks */
#if (ODBCVER >= 0x0300)
#define SQL_SU_DML_STATEMENTS           SQL_OU_DML_STATEMENTS
#define SQL_SU_PROCEDURE_INVOCATION     SQL_OU_PROCEDURE_INVOCATION
#define SQL_SU_TABLE_DEFINITION         SQL_OU_TABLE_DEFINITION
#define SQL_SU_INDEX_DEFINITION         SQL_OU_INDEX_DEFINITION
#define SQL_SU_PRIVILEGE_DEFINITION     SQL_OU_PRIVILEGE_DEFINITION
#endif  /* ODBCVER >= 0x0300 */

/* SQL_QUALIFIER_USAGE masks */

#define SQL_QU_DML_STATEMENTS               0x00000001L
#define SQL_QU_PROCEDURE_INVOCATION         0x00000002L
#define SQL_QU_TABLE_DEFINITION             0x00000004L
#define SQL_QU_INDEX_DEFINITION             0x00000008L
#define SQL_QU_PRIVILEGE_DEFINITION         0x00000010L

#if (ODBCVER >= 0x0300)
/* SQL_CATALOG_USAGE masks */
#define SQL_CU_DML_STATEMENTS           SQL_QU_DML_STATEMENTS
#define SQL_CU_PROCEDURE_INVOCATION     SQL_QU_PROCEDURE_INVOCATION
#define SQL_CU_TABLE_DEFINITION         SQL_QU_TABLE_DEFINITION
#define SQL_CU_INDEX_DEFINITION         SQL_QU_INDEX_DEFINITION
#define SQL_CU_PRIVILEGE_DEFINITION     SQL_QU_PRIVILEGE_DEFINITION
#endif  /* ODBCVER >= 0x0300 */

/* SQL_SUBQUERIES masks */

#define SQL_SQ_COMPARISON                   0x00000001L
#define SQL_SQ_EXISTS                       0x00000002L
#define SQL_SQ_IN                           0x00000004L
#define SQL_SQ_QUANTIFIED                   0x00000008L
#define SQL_SQ_CORRELATED_SUBQUERIES        0x00000010L

/* SQL_UNION masks */

#define SQL_U_UNION                         0x00000001L
#define SQL_U_UNION_ALL                     0x00000002L

/* SQL_BOOKMARK_PERSISTENCE values */

#define SQL_BP_CLOSE                        0x00000001L
#define SQL_BP_DELETE                       0x00000002L
#define SQL_BP_DROP                         0x00000004L
#define SQL_BP_TRANSACTION                  0x00000008L
#define SQL_BP_UPDATE                       0x00000010L
#define SQL_BP_OTHER_HSTMT                  0x00000020L
#define SQL_BP_SCROLL                       0x00000040L

/* SQL_STATIC_SENSITIVITY values */

#define SQL_SS_ADDITIONS                    0x00000001L
#define SQL_SS_DELETIONS                    0x00000002L
#define SQL_SS_UPDATES                      0x00000004L

/* SQL_VIEW values */
#define SQL_CV_CREATE_VIEW                  0x00000001L
#define SQL_CV_CHECK_OPTION                 0x00000002L
#define SQL_CV_CASCADED                     0x00000004L
#define SQL_CV_LOCAL                        0x00000008L

/* SQL_LOCK_TYPES masks */

#define SQL_LCK_NO_CHANGE                   0x00000001L
#define SQL_LCK_EXCLUSIVE                   0x00000002L
#define SQL_LCK_UNLOCK                      0x00000004L

/* SQL_POS_OPERATIONS masks */

#define SQL_POS_POSITION                    0x00000001L
#define SQL_POS_REFRESH                     0x00000002L
#define SQL_POS_UPDATE                      0x00000004L
#define SQL_POS_DELETE                      0x00000008L
#define SQL_POS_ADD                         0x00000010L

/* SQL_QUALIFIER_LOCATION values */

#define SQL_QL_START                        0x0001
#define SQL_QL_END                          0x0002

/* Here start return values for ODBC 3.0 SQLGetInfo */

#if (ODBCVER >= 0x0300)
/* SQL_AGGREGATE_FUNCTIONS bitmasks */
#define SQL_AF_AVG                      0x00000001L
#define SQL_AF_COUNT                    0x00000002L
#define SQL_AF_MAX                      0x00000004L
#define SQL_AF_MIN                      0x00000008L
#define SQL_AF_SUM                      0x00000010L
#define SQL_AF_DISTINCT                 0x00000020L
#define SQL_AF_ALL                      0x00000040L

/* SQL_SQL_CONFORMANCE bit masks */
#define SQL_SC_SQL92_ENTRY              0x00000001L
#define SQL_SC_FIPS127_2_TRANSITIONAL   0x00000002L
#define SQL_SC_SQL92_INTERMEDIATE       0x00000004L
#define SQL_SC_SQL92_FULL               0x00000008L

/* SQL_DATETIME_LITERALS masks */
#define SQL_DL_SQL92_DATE                       0x00000001L
#define SQL_DL_SQL92_TIME                       0x00000002L
#define SQL_DL_SQL92_TIMESTAMP                  0x00000004L
#define SQL_DL_SQL92_INTERVAL_YEAR              0x00000008L
#define SQL_DL_SQL92_INTERVAL_MONTH             0x00000010L
#define SQL_DL_SQL92_INTERVAL_DAY               0x00000020L
#define SQL_DL_SQL92_INTERVAL_HOUR              0x00000040L
#define SQL_DL_SQL92_INTERVAL_MINUTE            0x00000080L
#define SQL_DL_SQL92_INTERVAL_SECOND            0x00000100L
#define SQL_DL_SQL92_INTERVAL_YEAR_TO_MONTH     0x00000200L
#define SQL_DL_SQL92_INTERVAL_DAY_TO_HOUR       0x00000400L
#define SQL_DL_SQL92_INTERVAL_DAY_TO_MINUTE     0x00000800L
#define SQL_DL_SQL92_INTERVAL_DAY_TO_SECOND     0x00001000L
#define SQL_DL_SQL92_INTERVAL_HOUR_TO_MINUTE    0x00002000L
#define SQL_DL_SQL92_INTERVAL_HOUR_TO_SECOND    0x00004000L
#define SQL_DL_SQL92_INTERVAL_MINUTE_TO_SECOND  0x00008000L

/* SQL_CATALOG_LOCATION values */
#define SQL_CL_START                        SQL_QL_START
#define SQL_CL_END                          SQL_QL_END

/* values for SQL_BATCH_ROW_COUNT */
#define SQL_BRC_PROCEDURES          0x0000001
#define SQL_BRC_EXPLICIT            0x0000002
#define SQL_BRC_ROLLED_UP           0x0000004

/* bitmasks for SQL_BATCH_SUPPORT */
#define SQL_BS_SELECT_EXPLICIT              0x00000001L
#define SQL_BS_ROW_COUNT_EXPLICIT           0x00000002L
#define SQL_BS_SELECT_PROC                  0x00000004L
#define SQL_BS_ROW_COUNT_PROC               0x00000008L

/* Values for SQL_PARAM_ARRAY_ROW_COUNTS getinfo */
#define SQL_PARC_BATCH      1
#define SQL_PARC_NO_BATCH   2

/* values for SQL_PARAM_ARRAY_SELECTS */
#define SQL_PAS_BATCH               1
#define SQL_PAS_NO_BATCH            2
#define SQL_PAS_NO_SELECT           3

/* Bitmasks for SQL_INDEX_KEYWORDS */
#define SQL_IK_NONE                         0x00000000L
#define SQL_IK_ASC                          0x00000001L
#define SQL_IK_DESC                         0x00000002L
#define SQL_IK_ALL                          (SQL_IK_ASC | SQL_IK_DESC)

/* Bitmasks for SQL_INFO_SCHEMA_VIEWS */

#define SQL_ISV_ASSERTIONS                  0x00000001L
#define SQL_ISV_CHARACTER_SETS              0x00000002L
#define SQL_ISV_CHECK_CONSTRAINTS           0x00000004L
#define SQL_ISV_COLLATIONS                  0x00000008L
#define SQL_ISV_COLUMN_DOMAIN_USAGE         0x00000010L
#define SQL_ISV_COLUMN_PRIVILEGES           0x00000020L
#define SQL_ISV_COLUMNS                     0x00000040L
#define SQL_ISV_CONSTRAINT_COLUMN_USAGE     0x00000080L
#define SQL_ISV_CONSTRAINT_TABLE_USAGE      0x00000100L
#define SQL_ISV_DOMAIN_CONSTRAINTS          0x00000200L
#define SQL_ISV_DOMAINS                     0x00000400L
#define SQL_ISV_KEY_COLUMN_USAGE            0x00000800L
#define SQL_ISV_REFERENTIAL_CONSTRAINTS     0x00001000L
#define SQL_ISV_SCHEMATA                    0x00002000L
#define SQL_ISV_SQL_LANGUAGES               0x00004000L
#define SQL_ISV_TABLE_CONSTRAINTS           0x00008000L
#define SQL_ISV_TABLE_PRIVILEGES            0x00010000L
#define SQL_ISV_TABLES                      0x00020000L
#define SQL_ISV_TRANSLATIONS                0x00040000L
#define SQL_ISV_USAGE_PRIVILEGES            0x00080000L
#define SQL_ISV_VIEW_COLUMN_USAGE           0x00100000L
#define SQL_ISV_VIEW_TABLE_USAGE            0x00200000L
#define SQL_ISV_VIEWS                       0x00400000L

/* Bitmasks for SQL_ASYNC_MODE */

#define SQL_AM_NONE         0
#define SQL_AM_CONNECTION   1
#define SQL_AM_STATEMENT    2

/* Bitmasks for SQL_ALTER_DOMAIN */
#define SQL_AD_CONSTRAINT_NAME_DEFINITION           0x00000001L
#define SQL_AD_ADD_DOMAIN_CONSTRAINT                0x00000002L
#define SQL_AD_DROP_DOMAIN_CONSTRAINT               0x00000004L
#define SQL_AD_ADD_DOMAIN_DEFAULT                   0x00000008L
#define SQL_AD_DROP_DOMAIN_DEFAULT                  0x00000010L
#define SQL_AD_ADD_CONSTRAINT_INITIALLY_DEFERRED    0x00000020L
#define SQL_AD_ADD_CONSTRAINT_INITIALLY_IMMEDIATE   0x00000040L
#define SQL_AD_ADD_CONSTRAINT_DEFERRABLE            0x00000080L
#define SQL_AD_ADD_CONSTRAINT_NON_DEFERRABLE        0x00000100L


/* SQL_CREATE_SCHEMA bitmasks */
#define SQL_CS_CREATE_SCHEMA                0x00000001L
#define SQL_CS_AUTHORIZATION                0x00000002L
#define SQL_CS_DEFAULT_CHARACTER_SET        0x00000004L

/* SQL_CREATE_TRANSLATION bitmasks */
#define SQL_CTR_CREATE_TRANSLATION          0x00000001L

/* SQL_CREATE_ASSERTION bitmasks */
#define SQL_CA_CREATE_ASSERTION                 0x00000001L
#define SQL_CA_CONSTRAINT_INITIALLY_DEFERRED    0x00000010L
#define SQL_CA_CONSTRAINT_INITIALLY_IMMEDIATE   0x00000020L
#define SQL_CA_CONSTRAINT_DEFERRABLE            0x00000040L
#define SQL_CA_CONSTRAINT_NON_DEFERRABLE        0x00000080L

/* SQL_CREATE_CHARACTER_SET bitmasks */
#define SQL_CCS_CREATE_CHARACTER_SET        0x00000001L
#define SQL_CCS_COLLATE_CLAUSE              0x00000002L
#define SQL_CCS_LIMITED_COLLATION           0x00000004L

/* SQL_CREATE_COLLATION bitmasks */
#define SQL_CCOL_CREATE_COLLATION           0x00000001L

/* SQL_CREATE_DOMAIN bitmasks */
#define SQL_CDO_CREATE_DOMAIN                   0x00000001L
#define SQL_CDO_DEFAULT                         0x00000002L
#define SQL_CDO_CONSTRAINT                      0x00000004L
#define SQL_CDO_COLLATION                       0x00000008L
#define SQL_CDO_CONSTRAINT_NAME_DEFINITION      0x00000010L
#define SQL_CDO_CONSTRAINT_INITIALLY_DEFERRED   0x00000020L
#define SQL_CDO_CONSTRAINT_INITIALLY_IMMEDIATE  0x00000040L
#define SQL_CDO_CONSTRAINT_DEFERRABLE           0x00000080L
#define SQL_CDO_CONSTRAINT_NON_DEFERRABLE       0x00000100L

/* SQL_CREATE_TABLE bitmasks */
#define SQL_CT_CREATE_TABLE                     0x00000001L
#define SQL_CT_COMMIT_PRESERVE                  0x00000002L
#define SQL_CT_COMMIT_DELETE                    0x00000004L
#define SQL_CT_GLOBAL_TEMPORARY                 0x00000008L
#define SQL_CT_LOCAL_TEMPORARY                  0x00000010L
#define SQL_CT_CONSTRAINT_INITIALLY_DEFERRED    0x00000020L
#define SQL_CT_CONSTRAINT_INITIALLY_IMMEDIATE   0x00000040L
#define SQL_CT_CONSTRAINT_DEFERRABLE            0x00000080L
#define SQL_CT_CONSTRAINT_NON_DEFERRABLE        0x00000100L
#define SQL_CT_COLUMN_CONSTRAINT                0x00000200L
#define SQL_CT_COLUMN_DEFAULT                   0x00000400L
#define SQL_CT_COLUMN_COLLATION                 0x00000800L
#define SQL_CT_TABLE_CONSTRAINT                 0x00001000L
#define SQL_CT_CONSTRAINT_NAME_DEFINITION       0x00002000L

/* SQL_DDL_INDEX bitmasks */
#define SQL_DI_CREATE_INDEX                     0x00000001L
#define SQL_DI_DROP_INDEX                       0x00000002L

/* SQL_DROP_COLLATION bitmasks */
#define SQL_DC_DROP_COLLATION                   0x00000001L

/* SQL_DROP_DOMAIN bitmasks */
#define SQL_DD_DROP_DOMAIN                      0x00000001L
#define SQL_DD_RESTRICT                         0x00000002L
#define SQL_DD_CASCADE                          0x00000004L

/* SQL_DROP_SCHEMA bitmasks */
#define SQL_DS_DROP_SCHEMA                      0x00000001L
#define SQL_DS_RESTRICT                         0x00000002L
#define SQL_DS_CASCADE                          0x00000004L

/* SQL_DROP_CHARACTER_SET bitmasks */
#define SQL_DCS_DROP_CHARACTER_SET              0x00000001L

/* SQL_DROP_ASSERTION bitmasks */
#define SQL_DA_DROP_ASSERTION                   0x00000001L

/* SQL_DROP_TABLE bitmasks */
#define SQL_DT_DROP_TABLE                       0x00000001L
#define SQL_DT_RESTRICT                         0x00000002L
#define SQL_DT_CASCADE                          0x00000004L

/* SQL_DROP_TRANSLATION bitmasks */
#define SQL_DTR_DROP_TRANSLATION                0x00000001L

/* SQL_DROP_VIEW bitmasks */
#define SQL_DV_DROP_VIEW                        0x00000001L
#define SQL_DV_RESTRICT                         0x00000002L
#define SQL_DV_CASCADE                          0x00000004L

/* SQL_INSERT_STATEMENT bitmasks */
#define SQL_IS_INSERT_LITERALS                  0x00000001L
#define SQL_IS_INSERT_SEARCHED                  0x00000002L
#define SQL_IS_SELECT_INTO                      0x00000004L

/* SQL_ODBC_INTERFACE_CONFORMANCE values */
#define SQL_OIC_CORE                            1UL
#define SQL_OIC_LEVEL1                          2UL
#define SQL_OIC_LEVEL2                          3UL

/* SQL_SQL92_FOREIGN_KEY_DELETE_RULE bitmasks */
#define SQL_SFKD_CASCADE                        0x00000001L
#define SQL_SFKD_NO_ACTION                      0x00000002L
#define SQL_SFKD_SET_DEFAULT                    0x00000004L
#define SQL_SFKD_SET_NULL                       0x00000008L

/* SQL_SQL92_FOREIGN_KEY_UPDATE_RULE bitmasks */
#define SQL_SFKU_CASCADE                        0x00000001L
#define SQL_SFKU_NO_ACTION                      0x00000002L
#define SQL_SFKU_SET_DEFAULT                    0x00000004L
#define SQL_SFKU_SET_NULL                       0x00000008L

/* SQL_SQL92_GRANT  bitmasks */
#define SQL_SG_USAGE_ON_DOMAIN                  0x00000001L
#define SQL_SG_USAGE_ON_CHARACTER_SET           0x00000002L
#define SQL_SG_USAGE_ON_COLLATION               0x00000004L
#define SQL_SG_USAGE_ON_TRANSLATION             0x00000008L
#define SQL_SG_WITH_GRANT_OPTION                0x00000010L
#define SQL_SG_DELETE_TABLE                     0x00000020L
#define SQL_SG_INSERT_TABLE                     0x00000040L
#define SQL_SG_INSERT_COLUMN                    0x00000080L
#define SQL_SG_REFERENCES_TABLE                 0x00000100L
#define SQL_SG_REFERENCES_COLUMN                0x00000200L
#define SQL_SG_SELECT_TABLE                     0x00000400L
#define SQL_SG_UPDATE_TABLE                     0x00000800L
#define SQL_SG_UPDATE_COLUMN                    0x00001000L

/* SQL_SQL92_PREDICATES bitmasks */
#define SQL_SP_EXISTS                           0x00000001L
#define SQL_SP_ISNOTNULL                        0x00000002L
#define SQL_SP_ISNULL                           0x00000004L
#define SQL_SP_MATCH_FULL                       0x00000008L
#define SQL_SP_MATCH_PARTIAL                    0x00000010L
#define SQL_SP_MATCH_UNIQUE_FULL                0x00000020L
#define SQL_SP_MATCH_UNIQUE_PARTIAL             0x00000040L
#define SQL_SP_OVERLAPS                         0x00000080L
#define SQL_SP_UNIQUE                           0x00000100L
#define SQL_SP_LIKE                             0x00000200L
#define SQL_SP_IN                               0x00000400L
#define SQL_SP_BETWEEN                          0x00000800L
#define SQL_SP_COMPARISON                       0x00001000L
#define SQL_SP_QUANTIFIED_COMPARISON            0x00002000L

/* SQL_SQL92_RELATIONAL_JOIN_OPERATORS bitmasks */
#define SQL_SRJO_CORRESPONDING_CLAUSE           0x00000001L
#define SQL_SRJO_CROSS_JOIN                     0x00000002L
#define SQL_SRJO_EXCEPT_JOIN                    0x00000004L
#define SQL_SRJO_FULL_OUTER_JOIN                0x00000008L
#define SQL_SRJO_INNER_JOIN                     0x00000010L
#define SQL_SRJO_INTERSECT_JOIN                 0x00000020L
#define SQL_SRJO_LEFT_OUTER_JOIN                0x00000040L
#define SQL_SRJO_NATURAL_JOIN                   0x00000080L
#define SQL_SRJO_RIGHT_OUTER_JOIN               0x00000100L
#define SQL_SRJO_UNION_JOIN                     0x00000200L

/* SQL_SQL92_REVOKE bitmasks */
#define SQL_SR_USAGE_ON_DOMAIN                  0x00000001L
#define SQL_SR_USAGE_ON_CHARACTER_SET           0x00000002L
#define SQL_SR_USAGE_ON_COLLATION               0x00000004L
#define SQL_SR_USAGE_ON_TRANSLATION             0x00000008L
#define SQL_SR_GRANT_OPTION_FOR                 0x00000010L
#define SQL_SR_CASCADE                          0x00000020L
#define SQL_SR_RESTRICT                         0x00000040L
#define SQL_SR_DELETE_TABLE                     0x00000080L
#define SQL_SR_INSERT_TABLE                     0x00000100L
#define SQL_SR_INSERT_COLUMN                    0x00000200L
#define SQL_SR_REFERENCES_TABLE                 0x00000400L
#define SQL_SR_REFERENCES_COLUMN                0x00000800L
#define SQL_SR_SELECT_TABLE                     0x00001000L
#define SQL_SR_UPDATE_TABLE                     0x00002000L
#define SQL_SR_UPDATE_COLUMN                    0x00004000L

/* SQL_SQL92_ROW_VALUE_CONSTRUCTOR bitmasks */
#define SQL_SRVC_VALUE_EXPRESSION               0x00000001L
#define SQL_SRVC_NULL                           0x00000002L
#define SQL_SRVC_DEFAULT                        0x00000004L
#define SQL_SRVC_ROW_SUBQUERY                   0x00000008L

/* SQL_SQL92_VALUE_EXPRESSIONS bitmasks */
#define SQL_SVE_CASE                            0x00000001L
#define SQL_SVE_CAST                            0x00000002L
#define SQL_SVE_COALESCE                        0x00000004L
#define SQL_SVE_NULLIF                          0x00000008L

/* SQL_STANDARD_CLI_CONFORMANCE bitmasks */
#define SQL_SCC_XOPEN_CLI_VERSION1              0x00000001L
#define SQL_SCC_ISO92_CLI                       0x00000002L

/* SQL_UNION_STATEMENT bitmasks */
#define SQL_US_UNION                            SQL_U_UNION
#define SQL_US_UNION_ALL                        SQL_U_UNION_ALL

#endif  /* ODBCVER >= 0x0300 */

/* SQL_DTC_TRANSITION_COST bitmasks */
#define SQL_DTC_ENLIST_EXPENSIVE                0x00000001L
#define SQL_DTC_UNENLIST_EXPENSIVE              0x00000002L

/* additional SQLDataSources fetch directions */
#if (ODBCVER >= 0x0300)
#define SQL_FETCH_FIRST_USER                31
#define SQL_FETCH_FIRST_SYSTEM              32
#endif  /* ODBCVER >= 0x0300 */


/* Defines for SQLSetPos */
#define SQL_ENTIRE_ROWSET            0

/* Operations in SQLSetPos */
#define SQL_POSITION                 0               /*      1.0 FALSE */
#define SQL_REFRESH                  1               /*      1.0 TRUE */
#define SQL_UPDATE                   2
#define SQL_DELETE                   3

/* Operations in SQLBulkOperations */
#define SQL_ADD                      4
#define SQL_SETPOS_MAX_OPTION_VALUE         SQL_ADD
#if (ODBCVER >= 0x0300)
#define SQL_UPDATE_BY_BOOKMARK       5
#define SQL_DELETE_BY_BOOKMARK       6
#define SQL_FETCH_BY_BOOKMARK        7

#endif /*  ODBCVER >= 0x0300 */

/* Lock options in SQLSetPos */
#define SQL_LOCK_NO_CHANGE           0               /*      1.0 FALSE */
#define SQL_LOCK_EXCLUSIVE           1               /*      1.0 TRUE */
#define SQL_LOCK_UNLOCK              2

#define SQL_SETPOS_MAX_LOCK_VALUE       SQL_LOCK_UNLOCK

/* Macros for SQLSetPos */
#define SQL_POSITION_TO(hstmt,irow) SQLSetPos(hstmt,irow,SQL_POSITION,SQL_LOCK_NO_CHANGE)
#define SQL_LOCK_RECORD(hstmt,irow,fLock) SQLSetPos(hstmt,irow,SQL_POSITION,fLock)
#define SQL_REFRESH_RECORD(hstmt,irow,fLock) SQLSetPos(hstmt,irow,SQL_REFRESH,fLock)
#define SQL_UPDATE_RECORD(hstmt,irow) SQLSetPos(hstmt,irow,SQL_UPDATE,SQL_LOCK_NO_CHANGE)
#define SQL_DELETE_RECORD(hstmt,irow) SQLSetPos(hstmt,irow,SQL_DELETE,SQL_LOCK_NO_CHANGE)
#define SQL_ADD_RECORD(hstmt,irow) SQLSetPos(hstmt,irow,SQL_ADD,SQL_LOCK_NO_CHANGE)

/* Column types and scopes in SQLSpecialColumns.  */
#define SQL_BEST_ROWID                  1
#define SQL_ROWVER                      2

/* Defines for SQLSpecialColumns (returned in the result set)
   SQL_PC_UNKNOWN and SQL_PC_PSEUDO are defined in sql.h */
#define SQL_PC_NOT_PSEUDO               1

/* Defines for SQLStatistics */
#define SQL_QUICK                       0
#define SQL_ENSURE                      1

/* Defines for SQLStatistics (returned in the result set)
   SQL_INDEX_CLUSTERED, SQL_INDEX_HASHED, and SQL_INDEX_OTHER are
   defined in sql.h */
#define SQL_TABLE_STAT                  0


/* Defines for SQLTables */
#if (ODBCVER >= 0x0300)
#define SQL_ALL_CATALOGS                "%"
#define SQL_ALL_SCHEMAS                 "%"
#define SQL_ALL_TABLE_TYPES             "%"
#endif  /* ODBCVER >= 0x0300 */

/* Options for SQLDriverConnect */
#define SQL_DRIVER_NOPROMPT             0
#define SQL_DRIVER_COMPLETE             1
#define SQL_DRIVER_PROMPT               2
#define SQL_DRIVER_COMPLETE_REQUIRED    3

#ifndef RC_INVOKED

SQLRETURN SQL_API SQLDriverConnect(
    SQLHDBC            hdbc,
    SQLHWND            hwnd,
    SQLCHAR           *szConnStrIn,
    SQLSMALLINT        cbConnStrIn,
    SQLCHAR           *szConnStrOut,
    SQLSMALLINT        cbConnStrOutMax,
    SQLSMALLINT       *pcbConnStrOut,
    SQLUSMALLINT       fDriverCompletion);

#endif /* RC_INVOKED */

/* Level 2 Functions                             */

/* SQLExtendedFetch "fFetchType" values */
#define SQL_FETCH_BOOKMARK               8

/* SQLExtendedFetch "rgfRowStatus" element values */
#define SQL_ROW_SUCCESS                  0
#define SQL_ROW_DELETED                  1
#define SQL_ROW_UPDATED                  2
#define SQL_ROW_NOROW                    3
#define SQL_ROW_ADDED                    4
#define SQL_ROW_ERROR                    5
#if (ODBCVER >= 0x0300)
#define SQL_ROW_SUCCESS_WITH_INFO        6
#define SQL_ROW_PROCEED                  0
#define SQL_ROW_IGNORE                   1
#endif

/* value for SQL_DESC_ARRAY_STATUS_PTR */
#if (ODBCVER >= 0x0300)
#define SQL_PARAM_SUCCESS               0
#define SQL_PARAM_SUCCESS_WITH_INFO     6
#define SQL_PARAM_ERROR                 5
#define SQL_PARAM_UNUSED                7
#define SQL_PARAM_DIAG_UNAVAILABLE      1

#define SQL_PARAM_PROCEED               0
#define SQL_PARAM_IGNORE                1
#endif  /* ODBCVER >= 0x0300 */

/* Defines for SQLForeignKeys (UPDATE_RULE and DELETE_RULE) */
#define SQL_CASCADE                      0
#define SQL_RESTRICT                     1
#define SQL_SET_NULL                     2
#if (ODBCVER >= 0x0250)
#define SQL_NO_ACTION            3
#define SQL_SET_DEFAULT          4
#endif  /* ODBCVER >= 0x0250 */

#if (ODBCVER >= 0x0300)
/* Note that the following are in a different column of SQLForeignKeys than */
/* the previous #defines.   These are for DEFERRABILITY.                    */

#define SQL_INITIALLY_DEFERRED          5
#define SQL_INITIALLY_IMMEDIATE         6
#define SQL_NOT_DEFERRABLE          7

#endif  /* ODBCVER >= 0x0300 */

/* Defines for SQLBindParameter and
                           SQLProcedureColumns (returned in the result set) */
#define SQL_PARAM_TYPE_UNKNOWN           0
#define SQL_PARAM_INPUT                  1
#define SQL_PARAM_INPUT_OUTPUT           2
#define SQL_RESULT_COL                   3
#define SQL_PARAM_OUTPUT                 4
#define SQL_RETURN_VALUE                 5

/* Defines for SQLProcedures (returned in the result set) */
#define SQL_PT_UNKNOWN                   0
#define SQL_PT_PROCEDURE                 1
#define SQL_PT_FUNCTION                  2

#ifndef RC_INVOKED

/*      This define is too large for RC */
#define SQL_ODBC_KEYWORDS \
"ABSOLUTE,ACTION,ADA,ADD,ALL,ALLOCATE,ALTER,AND,ANY,ARE,AS,"\
"ASC,ASSERTION,AT,AUTHORIZATION,AVG,"\
"BEGIN,BETWEEN,BIT,BIT_LENGTH,BOTH,BY,CASCADE,CASCADED,CASE,CAST,CATALOG,"\
"CHAR,CHAR_LENGTH,CHARACTER,CHARACTER_LENGTH,CHECK,CLOSE,COALESCE,"\
"COLLATE,COLLATION,COLUMN,COMMIT,CONNECT,CONNECTION,CONSTRAINT,"\
"CONSTRAINTS,CONTINUE,CONVERT,CORRESPONDING,COUNT,CREATE,CROSS,CURRENT,"\
"CURRENT_DATE,CURRENT_TIME,CURRENT_TIMESTAMP,CURRENT_USER,CURSOR,"\
"DATE,DAY,DEALLOCATE,DEC,DECIMAL,DECLARE,DEFAULT,DEFERRABLE,"\
"DEFERRED,DELETE,DESC,DESCRIBE,DESCRIPTOR,DIAGNOSTICS,DISCONNECT,"\
"DISTINCT,DOMAIN,DOUBLE,DROP,"\
"ELSE,END,END-EXEC,ESCAPE,EXCEPT,EXCEPTION,EXEC,EXECUTE,"\
"EXISTS,EXTERNAL,EXTRACT,"\
"FALSE,FETCH,FIRST,FLOAT,FOR,FOREIGN,FORTRAN,FOUND,FROM,FULL,"\
"GET,GLOBAL,GO,GOTO,GRANT,GROUP,HAVING,HOUR,"\
"IDENTITY,IMMEDIATE,IN,INCLUDE,INDEX,INDICATOR,INITIALLY,INNER,"\
"INPUT,INSENSITIVE,INSERT,INT,INTEGER,INTERSECT,INTERVAL,INTO,IS,ISOLATION,"\
"JOIN,KEY,LANGUAGE,LAST,LEADING,LEFT,LEVEL,LIKE,LOCAL,LOWER,"\
"MATCH,MAX,MIN,MINUTE,MODULE,MONTH,"\
"NAMES,NATIONAL,NATURAL,NCHAR,NEXT,NO,NONE,NOT,NULL,NULLIF,NUMERIC,"\
"OCTET_LENGTH,OF,ON,ONLY,OPEN,OPTION,OR,ORDER,OUTER,OUTPUT,OVERLAPS,"\
"PAD,PARTIAL,PASCAL,PLI,POSITION,PRECISION,PREPARE,PRESERVE,"\
"PRIMARY,PRIOR,PRIVILEGES,PROCEDURE,PUBLIC,"\
"READ,REAL,REFERENCES,RELATIVE,RESTRICT,REVOKE,RIGHT,ROLLBACK,ROWS"\
"SCHEMA,SCROLL,SECOND,SECTION,SELECT,SESSION,SESSION_USER,SET,SIZE,"\
"SMALLINT,SOME,SPACE,SQL,SQLCA,SQLCODE,SQLERROR,SQLSTATE,SQLWARNING,"\
"SUBSTRING,SUM,SYSTEM_USER,"\
"TABLE,TEMPORARY,THEN,TIME,TIMESTAMP,TIMEZONE_HOUR,TIMEZONE_MINUTE,"\
"TO,TRAILING,TRANSACTION,TRANSLATE,TRANSLATION,TRIM,TRUE,"\
"UNION,UNIQUE,UNKNOWN,UPDATE,UPPER,USAGE,USER,USING,"\
"VALUE,VALUES,VARCHAR,VARYING,VIEW,WHEN,WHENEVER,WHERE,WITH,WORK,WRITE,"\
"YEAR,ZONE"

SQLRETURN SQL_API SQLBrowseConnect(
    SQLHDBC            hdbc,
    SQLCHAR           *szConnStrIn,
    SQLSMALLINT        cbConnStrIn,
    SQLCHAR           *szConnStrOut,
    SQLSMALLINT        cbConnStrOutMax,
    SQLSMALLINT       *pcbConnStrOut);

#if (ODBCVER >= 0x0300)
SQLRETURN   SQL_API SQLBulkOperations(
    SQLHSTMT            StatementHandle,
    SQLSMALLINT         Operation);
#endif  /* ODBCVER >= 0x0300 */

SQLRETURN SQL_API SQLColAttributes(
    SQLHSTMT           hstmt,
    SQLUSMALLINT       icol,
    SQLUSMALLINT       fDescType,
    SQLPOINTER         rgbDesc,
    SQLSMALLINT        cbDescMax,
    SQLSMALLINT       *pcbDesc,
    SQLLEN            * pfDesc);

SQLRETURN SQL_API SQLColumnPrivileges(
    SQLHSTMT           hstmt,
    SQLCHAR           *szCatalogName,
    SQLSMALLINT        cbCatalogName,
    SQLCHAR           *szSchemaName,
    SQLSMALLINT        cbSchemaName,
    SQLCHAR           *szTableName,
    SQLSMALLINT        cbTableName,
    SQLCHAR           *szColumnName,
    SQLSMALLINT        cbColumnName);

SQLRETURN SQL_API SQLDescribeParam(
    SQLHSTMT           hstmt,
    SQLUSMALLINT       ipar,
    SQLSMALLINT       *pfSqlType,
    SQLULEN           *pcbParamDef,
    SQLSMALLINT       *pibScale,
    SQLSMALLINT       *pfNullable);

SQLRETURN SQL_API SQLExtendedFetch(
    SQLHSTMT           hstmt,
    SQLUSMALLINT       fFetchType,
    SQLLEN             irow,
    SQLULEN           *pcrow,
    SQLUSMALLINT      *rgfRowStatus);

SQLRETURN SQL_API SQLForeignKeys(
    SQLHSTMT           hstmt,
    SQLCHAR           *szPkCatalogName,
    SQLSMALLINT        cbPkCatalogName,
    SQLCHAR           *szPkSchemaName,
    SQLSMALLINT        cbPkSchemaName,
    SQLCHAR           *szPkTableName,
    SQLSMALLINT        cbPkTableName,
    SQLCHAR           *szFkCatalogName,
    SQLSMALLINT        cbFkCatalogName,
    SQLCHAR           *szFkSchemaName,
    SQLSMALLINT        cbFkSchemaName,
    SQLCHAR           *szFkTableName,
    SQLSMALLINT        cbFkTableName);

SQLRETURN SQL_API SQLMoreResults(
    SQLHSTMT           hstmt);

SQLRETURN SQL_API SQLNativeSql
(
    SQLHDBC            hdbc,
    __in_ecount(cchSqlStrIn) SQLCHAR* szSqlStrIn,
    SQLINTEGER  cchSqlStrIn,
    __out_ecount_opt(cchSqlStrMax) SQLCHAR* szSqlStr,
    SQLINTEGER         cchSqlStrMax,
    SQLINTEGER        *pcbSqlStr
);

SQLRETURN SQL_API SQLNumParams(
    SQLHSTMT           hstmt,
    SQLSMALLINT       *pcpar);

SQLRETURN SQL_API SQLParamOptions(
    SQLHSTMT           hstmt,
    SQLULEN            crow,
    SQLULEN            *pirow);

SQLRETURN SQL_API SQLPrimaryKeys(
    SQLHSTMT           hstmt,
    SQLCHAR           *szCatalogName,
    SQLSMALLINT        cbCatalogName,
    SQLCHAR           *szSchemaName,
    SQLSMALLINT        cbSchemaName,
    SQLCHAR           *szTableName,
    SQLSMALLINT        cbTableName);

SQLRETURN SQL_API SQLProcedureColumns(
    SQLHSTMT           hstmt,
    SQLCHAR           *szCatalogName,
    SQLSMALLINT        cbCatalogName,
    SQLCHAR           *szSchemaName,
    SQLSMALLINT        cbSchemaName,
    SQLCHAR           *szProcName,
    SQLSMALLINT        cbProcName,
    SQLCHAR           *szColumnName,
    SQLSMALLINT        cbColumnName);

SQLRETURN SQL_API SQLProcedures(
    SQLHSTMT           hstmt,
    SQLCHAR           *szCatalogName,
    SQLSMALLINT        cbCatalogName,
    SQLCHAR           *szSchemaName,
    SQLSMALLINT        cbSchemaName,
    SQLCHAR           *szProcName,
    SQLSMALLINT        cbProcName);



SQLRETURN SQL_API SQLSetPos(
    SQLHSTMT           hstmt,
    SQLSETPOSIROW      irow,
    SQLUSMALLINT       fOption,
    SQLUSMALLINT       fLock);

SQLRETURN SQL_API SQLTablePrivileges(
    SQLHSTMT           hstmt,
    SQLCHAR           *szCatalogName,
    SQLSMALLINT        cbCatalogName,
    SQLCHAR           *szSchemaName,
    SQLSMALLINT        cbSchemaName,
    SQLCHAR           *szTableName,
    SQLSMALLINT        cbTableName);

SQLRETURN SQL_API SQLDrivers(
    SQLHENV            henv,
    SQLUSMALLINT       fDirection,
    SQLCHAR           *szDriverDesc,
    SQLSMALLINT        cbDriverDescMax,
    SQLSMALLINT       *pcbDriverDesc,
    SQLCHAR           *szDriverAttributes,
    SQLSMALLINT        cbDrvrAttrMax,
    SQLSMALLINT       *pcbDrvrAttr);

SQLRETURN SQL_API SQLBindParameter(
    SQLHSTMT           hstmt,
    SQLUSMALLINT       ipar,
    SQLSMALLINT        fParamType,
    SQLSMALLINT        fCType,
    SQLSMALLINT        fSqlType,
    SQLULEN            cbColDef,
    SQLSMALLINT        ibScale,
    SQLPOINTER         rgbValue,
    SQLLEN             cbValueMax,
    SQLLEN             *pcbValue);


#endif /* RC_INVOKED */

/*---------------------------------------------------------*/
/* SQLAllocHandleStd is implemented to make SQLAllocHandle */
/* compatible with X/Open standard.  an application should */
/* not call SQLAllocHandleStd directly                     */
/*---------------------------------------------------------*/
#ifdef ODBC_STD
#define SQLAllocHandle  SQLAllocHandleStd
#define SQLAllocEnv(phenv)  SQLAllocHandleStd(SQL_HANDLE_ENV, SQL_NULL_HANDLE, phenv)

/* Internal type subcodes */
#define SQL_YEAR                        SQL_CODE_YEAR
#define SQL_MONTH                       SQL_CODE_MONTH
#define SQL_DAY                         SQL_CODE_DAY
#define SQL_HOUR                        SQL_CODE_HOUR
#define SQL_MINUTE                      SQL_CODE_MINUTE
#define SQL_SECOND                      SQL_CODE_SECOND
#define SQL_YEAR_TO_MONTH               SQL_CODE_YEAR_TO_MONTH
#define SQL_DAY_TO_HOUR                 SQL_CODE_DAY_TO_HOUR
#define SQL_DAY_TO_MINUTE               SQL_CODE_DAY_TO_MINUTE
#define SQL_DAY_TO_SECOND               SQL_CODE_DAY_TO_SECOND
#define SQL_HOUR_TO_MINUTE              SQL_CODE_HOUR_TO_MINUTE
#define SQL_HOUR_TO_SECOND              SQL_CODE_HOUR_TO_SECOND
#define SQL_MINUTE_TO_SECOND            SQL_CODE_MINUTE_TO_SECOND
#endif /* ODBC_STD */

#if (ODBCVER >= 0x0300)
#ifndef RC_INVOKED
SQLRETURN SQL_API SQLAllocHandleStd(
    SQLSMALLINT     fHandleType,
    SQLHANDLE       hInput,
    SQLHANDLE      *phOutput);
#endif /* RC_INVOKED */
#endif

/*      Deprecated defines from prior versions of ODBC */
#define SQL_DATABASE_NAME               16    /* Use SQLGetConnectOption/SQL_CURRENT_QUALIFIER */
#define SQL_FD_FETCH_PREV               SQL_FD_FETCH_PRIOR
#define SQL_FETCH_PREV                  SQL_FETCH_PRIOR
#define SQL_CONCUR_TIMESTAMP            SQL_CONCUR_ROWVER
#define SQL_SCCO_OPT_TIMESTAMP          SQL_SCCO_OPT_ROWVER
#define SQL_CC_DELETE                   SQL_CB_DELETE
#define SQL_CR_DELETE                   SQL_CB_DELETE
#define SQL_CC_CLOSE                    SQL_CB_CLOSE
#define SQL_CR_CLOSE                    SQL_CB_CLOSE
#define SQL_CC_PRESERVE                 SQL_CB_PRESERVE
#define SQL_CR_PRESERVE                 SQL_CB_PRESERVE
/* SQL_FETCH_RESUME is not supported by 2.0+ drivers
#define SQL_FETCH_RESUME                7
*/
#define SQL_SCROLL_FORWARD_ONLY         0L    /*-SQL_CURSOR_FORWARD_ONLY */
#define SQL_SCROLL_KEYSET_DRIVEN        (-1L) /*-SQL_CURSOR_KEYSET_DRIVEN */
#define SQL_SCROLL_DYNAMIC              (-2L) /*-SQL_CURSOR_DYNAMIC */
#define SQL_SCROLL_STATIC               (-3L) /*-SQL_CURSOR_STATIC */

/*      Deprecated functions from prior versions of ODBC */
#ifndef RC_INVOKED

SQLRETURN SQL_API SQLSetScrollOptions(    /*      Use SQLSetStmtOptions */
    SQLHSTMT           hstmt,
    SQLUSMALLINT       fConcurrency,
    SQLLEN             crowKeyset,
    SQLUSMALLINT       crowRowset);

/* Tracing section */

#define     TRACE_VERSION   1000        /* Version of trace API */

// open a trace log file
RETCODE SQL_API TraceOpenLogFile
(
    __in_opt                        LPWSTR szFileName,
    __out_bcount_opt(cbOutputMsg)   LPWSTR lpwszOutputMsg,
    __in                            DWORD  cbOutputMsg
);

RETCODE SQL_API TraceCloseLogFile();            // Request to close a trace log
VOID    SQL_API TraceReturn(RETCODE,RETCODE);   // Processes trace after FN is called
DWORD   SQL_API TraceVersion();                 // Returns trace API version

/* Functions for Visual Studio Analyzer*/
/* to turn on/off tracing or VS events, call TraceVSControl by setting or clearing the following bits  */
#define TRACE_ON            0x00000001L
#define TRACE_VS_EVENT_ON   0x00000002L

RETCODE SQL_API TraceVSControl(DWORD);

/* Functions for setting the connection pooling failure detection code */
/* The "TryWait" value is the time (in seconds) that the DM will wait  */
/* between detecting that a connection is dead (using                  */
/* SQL_ATTR_CONNECTION_DEAD) and retrying the connection.  During that */
/* interval, connection requests will get "The server appears to be    */
/* dead" error returns.                                                */


BOOL SQL_API    ODBCSetTryWaitValue(DWORD dwValue); /* In seconds */
DWORD SQL_API   ODBCGetTryWaitValue();          /* In Milliseconds(!) */


/* the flags in ODBC_VS_ARGS */
#define ODBC_VS_FLAG_UNICODE_ARG    0x00000001L /* the argument is unicode */
#define ODBC_VS_FLAG_UNICODE_COR    0x00000002L /* the correlation is unicode */
#define ODBC_VS_FLAG_RETCODE        0x00000004L /* RetCode field is set */
#define ODBC_VS_FLAG_STOP       0x00000008L /* Stop firing visual studio analyzer events */

typedef struct tagODBC_VS_ARGS {
    const GUID  *pguidEvent;    /* the GUID for event */
    DWORD   dwFlags;        /* flags for the call */
    union {
        WCHAR   *wszArg;
        CHAR    *szArg;
    };
    union {
        WCHAR   *wszCorrelation;
        CHAR    *szCorrelation;
    };
    RETCODE RetCode;
} ODBC_VS_ARGS, *PODBC_VS_ARGS;
VOID    SQL_API FireVSDebugEvent(PODBC_VS_ARGS);

#endif /* RC_INVOKED */


#ifdef __cplusplus
}                                     /* End of extern "C" { */
#endif  /* __cplusplus */

#if defined(WIN32) || defined(_WIN64)
#include "sqlucode.h"
#endif

#endif /* __SQLEXT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\sphelper.h ===
/*******************************************************************************
// Copyright Microsoft Corporation. All Rights Reserved. 
* SPHelper.h *
*------------*
*   Description:
*       This is the header file for core helper functions implementation.
*-------------------------------------------------------------------------------
*******************************************************************************/
#ifndef SPHelper_h
#define SPHelper_h

#ifndef _INC_MALLOC
#include <malloc.h>
#endif

#ifndef _INC_CRTDBG
#include <crtdbg.h>
#endif

#ifndef __sapi_h__
#include <sapi.h>
#endif

#ifndef __sapiddk_h__
#include <sapiddk.h>
#endif

#ifndef SPError_h
#include <SPError.h>
#endif

#ifndef _INC_LIMITS
#include <limits.h>
#endif

#ifndef _INC_MMSYSTEM
#include <mmsystem.h>
#endif

#ifndef __comcat_h__
#include <comcat.h>
#endif

#ifndef _INC_MMREG
#include <mmreg.h>
#endif

#ifndef __ATLBASE_H__
#include <atlbase.h>
#endif

#include <wchar.h>
#include <tchar.h>

#include <strsafe.h>
#include <intsafe.h>

#ifndef _PREFAST_ 
#pragma warning(disable:4068) 
#endif


//=== Constants ==============================================================
#define sp_countof(x) ((sizeof(x) / sizeof(*(x))))

/*** CSpDynamicString helper class
*
*/
class CSpDynamicString 
{
public:

    WCHAR *     m_psz;
    CSpDynamicString()
    {
        m_psz = NULL;
    }
    CSpDynamicString(ULONG cchReserve)
    {
        ULONGLONG ullAllocSize = (ULONGLONG) cchReserve * sizeof(WCHAR);
        if ((ullAllocSize > cchReserve) && ((ULONG) ullAllocSize == ullAllocSize))
        {
            m_psz = (WCHAR *)::CoTaskMemAlloc((ULONG)ullAllocSize);
        }
    }
    WCHAR * operator=(const CSpDynamicString& src)
    {
        if(this != &src)
        {
            _ASSERT((m_psz == NULL) || (m_psz != src.m_psz));
            ::CoTaskMemFree(m_psz);
            m_psz = src.Copy();
        }
        return m_psz;
    }
    WCHAR * operator=(const WCHAR * pSrc)
    {
        if(pSrc != m_psz)
        {
            Clear();
            if (pSrc)
            {
                size_t cbNeeded = (wcslen(pSrc) + 1) * sizeof(WCHAR);
                
                if (cbNeeded == (ULONG) cbNeeded)
                {
                    m_psz = (WCHAR *)::CoTaskMemAlloc(cbNeeded);
                    if (m_psz == NULL)
                    {
                        SetLastError(ERROR_OUTOFMEMORY);
                    }
                    else
                    {
                        memcpy(m_psz, pSrc, cbNeeded);
                    }
                }
            }
        }
        return m_psz;
    }

    WCHAR * operator=(const char * pSrc)
    {
        Clear();
        if (pSrc)
        {
            size_t cbNeeded = (lstrlenA(pSrc) + 1) * sizeof(WCHAR);
            if ((ULONG) cbNeeded == cbNeeded)
            {
                m_psz = (WCHAR *)::CoTaskMemAlloc(cbNeeded);
                if (m_psz == NULL)
                {
                    SetLastError(ERROR_OUTOFMEMORY);
                }
                else
                {
                    ::MultiByteToWideChar(CP_ACP, 0, pSrc, -1, m_psz, (ULONG) cbNeeded/sizeof(WCHAR));
                }
            }
        }
        return m_psz;
    }

    WCHAR * operator=(REFGUID rguid)
    {
        Clear();
        ::StringFromCLSID(rguid, &m_psz);
        return m_psz;
    }


    /*explicit*/ CSpDynamicString(const WCHAR * pSrc)
    {
        m_psz = NULL;
        operator=(pSrc);
    }
    /*explicit*/ CSpDynamicString(const char * pSrc)
    {
        m_psz = NULL;
        operator=(pSrc);
    }
    /*explicit*/ CSpDynamicString(const CSpDynamicString& src)
    {
        m_psz = src.Copy();
    }
    /*explicit*/ CSpDynamicString(REFGUID rguid)
    {
        ::StringFromCLSID(rguid, &m_psz);
    }


    ~CSpDynamicString()
    {
        ::CoTaskMemFree(m_psz);
    }
    unsigned int Length() const
    {
        if (m_psz == NULL)
            return 0;
        
        size_t cch = wcslen(m_psz);

        if ((unsigned int) cch != cch)
        {
            _ASSERT((unsigned int) cch == cch);    // Too long
            SetLastError(ERROR_ARITHMETIC_OVERFLOW);
            return MAXDWORD;
        }

        return (unsigned int) cch;
    }

    operator WCHAR * () const
    {
        return m_psz;
    }
    //The assert on operator& usually indicates a bug.  If this is really
    //what is needed, however, take the address of the m_psz member explicitly.
    WCHAR ** operator&()
    {
        _ASSERT(m_psz == NULL);
        return &m_psz;
    }

    // Versions of Append that return HRESULT
    HRESULT AppendHR(const WCHAR * pszSrc, const ULONG lenSrc)
    {
        HRESULT hr = S_OK;
        if (pszSrc && lenSrc)
        {
            ULONG lenMe = Length();
            ULONGLONG ullcbNew = ((ULONGLONG) lenMe + lenSrc + 1) * sizeof(WCHAR);

            if (ullcbNew > ((ULONGLONG)lenMe + lenSrc + 1) && ((ULONG) ullcbNew == ullcbNew))
            {
                WCHAR *pszNew = (WCHAR *)::CoTaskMemAlloc((ULONG)ullcbNew);
                if (pszNew)
                {
                    if (m_psz)  // Could append to an empty string so check...
                    {
                        if (lenMe)
                        {
                            memcpy(pszNew, m_psz, lenMe * sizeof(WCHAR));
                        }
                        ::CoTaskMemFree(m_psz);
                    }
                    memcpy(pszNew + lenMe, pszSrc, lenSrc * sizeof(WCHAR));
                    *(pszNew + lenMe + lenSrc) = L'\0';
                    m_psz = pszNew;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                hr = E_INVALIDARG;
            }
        }
        return hr;
    }

    HRESULT AppendHR(const WCHAR * pszSrc)
    {
        HRESULT hr = S_OK;
        if (pszSrc)
        {
            size_t lenSrc = wcslen(pszSrc);
            if ((ULONG) lenSrc != lenSrc)
                return E_OUTOFMEMORY;
            
            hr = AppendHR(pszSrc, (ULONG) lenSrc);
        }
        return hr;
    }

    // Original versions of Append that do not return HRESULTs
    WCHAR * Append(const WCHAR * pszSrc)
    {
        if(pszSrc && FAILED(AppendHR(pszSrc)))
        {
            _ASSERT(FALSE);
        }
        return m_psz;
    }

    WCHAR * Append(const WCHAR * pszSrc, const ULONG lenSrc)
    {
        if(FAILED(AppendHR(pszSrc, lenSrc)))
        {
            _ASSERT(FALSE);
        }
        return m_psz;
    }

    // Version of Append2 that returns HRESULT
    HRESULT Append2HR(const WCHAR * pszSrc1, const WCHAR * pszSrc2)
    {
        HRESULT hr = S_OK;
        size_t lenSrc1 = pszSrc1 ? wcslen(pszSrc1) : 0;
        size_t lenSrc2 = pszSrc2 ? wcslen(pszSrc2) : 0;

        if (lenSrc1 || lenSrc2)
        {
            ULONG lenMe = Length();
            size_t cbNew = (lenMe + lenSrc1 + lenSrc2 + 1) * sizeof(WCHAR);
            if ((ULONG) cbNew != cbNew)
                return E_OUTOFMEMORY;
            
            WCHAR *pszNew = (WCHAR *)::CoTaskMemAlloc(cbNew);
            if (pszNew)
            {
                if (m_psz)  // Could append to an empty string so check...
                {
                    if (lenMe)
                    {
                        memcpy(pszNew, m_psz, lenMe * sizeof(WCHAR));
                    }
                    ::CoTaskMemFree(m_psz);
                }
                // In both of these cases, we copy the trailing NULL so that we're sure it gets
                // there (if lenSrc2 is 0 then we better copy it from pszSrc1).
                if (lenSrc1)
                {
                    memcpy(pszNew + lenMe, pszSrc1, (lenSrc1 + 1) * sizeof(WCHAR));
                }
                if (lenSrc2)
                {
                    memcpy(pszNew + lenMe + lenSrc1, pszSrc2, (lenSrc2 + 1) * sizeof(WCHAR));
                }
                m_psz = pszNew;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        return hr;
    }

    // Original version of Append2 that does not return HRESULT
    WCHAR * Append2(const WCHAR * pszSrc1, const WCHAR * pszSrc2)
    {
        if(FAILED(Append2HR(pszSrc1, pszSrc2)))
        {
            _ASSERT(FALSE);
        }
        return m_psz;
    }

    WCHAR * Copy() const
    {
        if (m_psz)
        {
            CSpDynamicString szNew(m_psz);
            return szNew.Detach();
        }
        return NULL;
    }
    CHAR * CopyToChar() const
    {
        if (m_psz)
        {
            CHAR* psz;
            ULONG cbNeeded = ::WideCharToMultiByte(CP_ACP, 0, m_psz, -1, NULL, NULL, NULL, NULL);
            psz = (CHAR *)::CoTaskMemAlloc(cbNeeded);
            if (psz == NULL)
            {
                SetLastError(ERROR_OUTOFMEMORY);
            }
            else
            {
                ::WideCharToMultiByte(CP_ACP, 0, m_psz, -1, psz, cbNeeded/sizeof(CHAR), NULL, NULL);
            }
            return psz;
        }
        return NULL;
    }
    void Attach(WCHAR __in * pszSrc)
    {
        _ASSERT(m_psz == NULL);
        m_psz = pszSrc;
    }
    WCHAR * Detach()
    {
        WCHAR * s = m_psz;
        m_psz = NULL;
        return s;
    }
    void Clear()
    {
        ::CoTaskMemFree(m_psz);
        m_psz = NULL;
    }
    bool operator!() const
    {
        return (m_psz == NULL);
    }
    HRESULT CopyToBSTR(BSTR * pbstr)
    {
        if (m_psz)
        {
            *pbstr = ::SysAllocString(m_psz);
            if (*pbstr == NULL)
            {
                return E_OUTOFMEMORY;
            }
        }
        else
        {
            *pbstr = NULL;
        }
        return S_OK;
    }
    void TrimToSize(ULONG ulNumChars)
    {
        if (m_psz && ulNumChars < Length())
        {
            m_psz[ulNumChars] = 0;
        }
    }
    WCHAR * Compact()
    {
        if (m_psz)
        {
            ULONG cch = (ULONG) wcslen(m_psz);
            m_psz = (WCHAR *)::CoTaskMemRealloc(m_psz, (cch + 1) * sizeof(WCHAR));
        }
        return m_psz;
    }
    WCHAR * ClearAndGrowTo(ULONG cch)
    {
        if (m_psz)
        {
            Clear();
        }
        
        ULONGLONG ullcbNew = (ULONGLONG) cch * sizeof(WCHAR);
        if ((ullcbNew > cch) && ((ULONG) ullcbNew == ullcbNew))
        {
            m_psz = (WCHAR *)::CoTaskMemAlloc((ULONG)ullcbNew);
            if (m_psz)
            {
            	memset(m_psz, 0, (ULONG)ullcbNew);
            }
        }
        
        return m_psz;
    }
    WCHAR * LTrim()
    {
        if (m_psz)
        {
            WCHAR * pszRead = m_psz;
            while (iswspace(*pszRead))
            {
                pszRead++;
            }
            if (pszRead != m_psz)
            {
                WCHAR * pszWrite = m_psz;
                size_t length = wcslen(pszWrite);
                StringCchCopyW(pszWrite, length +1, pszRead);
            }
        }
        return m_psz;
    }
    WCHAR * RTrim()
    {
        if (m_psz)
        {
            WCHAR * pszTail = m_psz + wcslen(m_psz);
            WCHAR * pszZeroTerm = pszTail;
            while (pszZeroTerm > m_psz && iswspace(pszZeroTerm[-1]))
            {
                pszZeroTerm--;
            }
            if (pszZeroTerm != pszTail)
            {
                *pszZeroTerm = '\0';
            }
        }
        return m_psz;        
    }
    WCHAR * TrimBoth()
    {
        RTrim();
        return LTrim();
    }
};



//
//  Simple inline function converts a ulong to a hex string.
//
inline void SpHexFromUlong(__out_ecount (9) WCHAR * psz, ULONG ul)
{
    // If for some reason we cannot convert a number, set it to 0
    if (_ultow_s(ul, psz, 9, 16))
    {
        psz[0] = L'0';
        psz[1] = 0;
    }
}


inline HRESULT SpULongFromHex(const WCHAR *psz, unsigned *pResult)
{
	HRESULT hr = S_OK;
	*pResult = 0;
	size_t cLen = wcslen (psz);

	if (cLen > 8)
	{
		hr = E_FAIL;
	}

	if (SUCCEEDED(hr))
	{
		// Convert the token to its numeral form in a WCHAR
		bool fFirst = true;

		for (size_t i = 0; i < cLen; i++)
		{
			int k = tolower (*psz);
			if (k >= L'a')
			{
				k = 10 + k - L'a';
			}
			else
			{
				if (k <= L'9')
				{
					k -= L'0';
				}
				else
				{
					// character in the range ':' .. '@'
					k = -1;
				}
			}

			if (k < 0 || k > 15)
			{
				hr = E_FAIL;
				break;
			}
			if (fFirst)
				fFirst = false;
			else
				*pResult <<= 4;

			*pResult += (unsigned) k;
			psz++;
		}
	}

	return hr;
} 

//=== Token helpers

inline HRESULT SpGetTokenFromId(
    const WCHAR * pszTokenId, 
    ISpObjectToken ** ppToken,
    BOOL fCreateIfNotExist = FALSE)
{
    HRESULT hr;
    
    CComPtr<ISpObjectToken> cpToken;
    hr = cpToken.CoCreateInstance(CLSID_SpObjectToken);
    
    if (SUCCEEDED(hr))
    {
        hr = cpToken->SetId(NULL, pszTokenId, fCreateIfNotExist);
    }
    
    if (SUCCEEDED(hr))
    {
        *ppToken = cpToken.Detach();
    }
    
    return hr;
}

inline HRESULT SpGetCategoryFromId(
    const WCHAR * pszCategoryId,
    ISpObjectTokenCategory ** ppCategory,
    BOOL fCreateIfNotExist = FALSE)
{
    HRESULT hr;
    
    CComPtr<ISpObjectTokenCategory> cpTokenCategory;
    hr = cpTokenCategory.CoCreateInstance(CLSID_SpObjectTokenCategory);
    
    if (SUCCEEDED(hr))
    {
        hr = cpTokenCategory->SetId(pszCategoryId, fCreateIfNotExist);
    }
    
    if (SUCCEEDED(hr))
    {
        *ppCategory = cpTokenCategory.Detach();
    }
    
    return hr;
}

inline HRESULT SpGetDefaultTokenIdFromCategoryId(
    const WCHAR * pszCategoryId,
    __deref_out WCHAR ** ppszTokenId)
{
    HRESULT hr;

    CComPtr<ISpObjectTokenCategory> cpCategory;
    hr = SpGetCategoryFromId(pszCategoryId, &cpCategory);
    
    if (SUCCEEDED(hr))
    {
        hr = cpCategory->GetDefaultTokenId(ppszTokenId);
    }

    return hr;
}

inline HRESULT SpSetDefaultTokenIdForCategoryId(
    const WCHAR * pszCategoryId,
    const WCHAR * pszTokenId)
{
    HRESULT hr;

    CComPtr<ISpObjectTokenCategory> cpCategory;
    hr = SpGetCategoryFromId(pszCategoryId, &cpCategory);
    
    if (SUCCEEDED(hr))
    {
        hr = cpCategory->SetDefaultTokenId(pszTokenId);
    }

    return hr;
}

inline HRESULT SpGetDefaultTokenFromCategoryId(
    const WCHAR * pszCategoryId,
    ISpObjectToken ** ppToken,
    BOOL fCreateCategoryIfNotExist = TRUE)
{
    HRESULT hr;

    CComPtr<ISpObjectTokenCategory> cpCategory;
    hr = SpGetCategoryFromId(pszCategoryId, &cpCategory, fCreateCategoryIfNotExist);

    if (SUCCEEDED(hr))
    {
        WCHAR * pszTokenId;
        hr = cpCategory->GetDefaultTokenId(&pszTokenId);
        if (SUCCEEDED(hr))
        {
            hr = SpGetTokenFromId(pszTokenId, ppToken);
            ::CoTaskMemFree(pszTokenId);
        }
    }

    return hr;
}

inline HRESULT SpSetDefaultTokenForCategoryId(
    const WCHAR * pszCategoryId,
    ISpObjectToken * pToken)
{
    HRESULT hr;

    WCHAR * pszTokenId;
    hr = pToken->GetId(&pszTokenId);

    if (SUCCEEDED(hr))
    {
        hr = SpSetDefaultTokenIdForCategoryId(pszCategoryId, pszTokenId);
        ::CoTaskMemFree(pszTokenId);
    }

    return hr;
}

inline HRESULT SpSetCommonTokenData(
    ISpObjectToken * pToken,
    const CLSID * pclsid,
    const WCHAR * pszLangIndependentName,
    LANGID langid,
    const WCHAR * pszLangDependentName,
    ISpDataKey ** ppDataKeyAttribs)
{
    HRESULT hr = S_OK;
    
    // Set the new token's CLSID (if specified)
    if (SUCCEEDED(hr) && pclsid)
    {
        CSpDynamicString dstrClsid;
        hr = StringFromCLSID(*pclsid, &dstrClsid);
    
        if (SUCCEEDED(hr))
        {
            hr = pToken->SetStringValue(SPTOKENVALUE_CLSID, dstrClsid);
        }
    }

    // Set the token's lang independent name
    if (SUCCEEDED(hr) && pszLangIndependentName)
    {
        hr = pToken->SetStringValue(NULL, pszLangIndependentName);
    }

    // Set the token's lang dependent name
    if (SUCCEEDED(hr) && pszLangDependentName)
    {
        WCHAR szLangId[10];
        StringCbPrintfW (szLangId, sizeof (szLangId), L"%x", langid);

        hr = pToken->SetStringValue(szLangId, pszLangDependentName);
    }

    // Open the attributes key if requested
    if (SUCCEEDED(hr) && ppDataKeyAttribs)
    {
        hr = pToken->CreateKey(L"Attributes", ppDataKeyAttribs);
    }

    return hr;
}

inline HRESULT SpCreateNewToken(
    const WCHAR * pszTokenId,
    ISpObjectToken ** ppToken)
{
    HRESULT hr;

    // Forcefully create the token
    hr = SpGetTokenFromId(pszTokenId, ppToken, TRUE);
    
    return hr;
}

inline HRESULT SPCoCreateGuid(GUID *pGuid)
{
    HRESULT hr = S_OK;

    hr = CoCreateGuid(pGuid);
    return hr;
}

inline HRESULT SpCreateNewToken(
    const WCHAR * pszCategoryId,
    const WCHAR * pszTokenKeyName,
    ISpObjectToken ** ppToken)
{
    HRESULT hr;

    // Forcefully create the category
    CComPtr<ISpObjectTokenCategory> cpCategory;
    hr = SpGetCategoryFromId(pszCategoryId, &cpCategory, TRUE);

    // Come up with a token key name if one wasn't specified
    CSpDynamicString dstrTokenKeyName;
    if (SUCCEEDED(hr))
    {
        if (pszTokenKeyName == NULL)
        {
            GUID guidTokenKeyName;
            hr = SPCoCreateGuid(&guidTokenKeyName);

            if (SUCCEEDED(hr))
            {
                hr = StringFromCLSID(guidTokenKeyName, &dstrTokenKeyName);
            }

            if (SUCCEEDED(hr))
            {
                pszTokenKeyName = dstrTokenKeyName;
            }
        }
    }

    // Build the token id
    CSpDynamicString dstrTokenId;
    if (SUCCEEDED(hr))
    {
        dstrTokenId = pszCategoryId;
        dstrTokenId.Append2(L"\\Tokens\\", pszTokenKeyName);
    }

    // Forcefully create the token
    if (SUCCEEDED(hr))
    {
        hr = SpGetTokenFromId(dstrTokenId, ppToken, TRUE);
    }
    
    return hr;
}

inline HRESULT SpCreateNewTokenEx(
    const WCHAR * pszCategoryId,
    const WCHAR * pszTokenKeyName,
    const CLSID * pclsid,
    const WCHAR * pszLangIndependentName,
    LANGID langid,
    const WCHAR * pszLangDependentName,
    ISpObjectToken ** ppToken,
    ISpDataKey ** ppDataKeyAttribs)
{
    HRESULT hr;

    // Create the new token
    hr = SpCreateNewToken(pszCategoryId, pszTokenKeyName, ppToken);

    // Now set the extra data
    if (SUCCEEDED(hr))
    {
        hr = SpSetCommonTokenData(
                    *ppToken, 
                    pclsid, 
                    pszLangIndependentName, 
                    langid, 
                    pszLangDependentName, 
                    ppDataKeyAttribs);
    }
    
    return hr;
}

inline HRESULT SpCreateNewTokenEx(
    const WCHAR * pszTokenId,
    const CLSID * pclsid,
    const WCHAR * pszLangIndependentName,
    LANGID langid,
    const WCHAR * pszLangDependentName,
    ISpObjectToken ** ppToken,
    ISpDataKey ** ppDataKeyAttribs)
{
    HRESULT hr;

    // Create the new token
    hr = SpCreateNewToken(pszTokenId, ppToken);

    // Now set the extra data
    if (SUCCEEDED(hr))
    {
        hr = SpSetCommonTokenData(
                    *ppToken, 
                    pclsid, 
                    pszLangIndependentName, 
                    langid, 
                    pszLangDependentName, 
                    ppDataKeyAttribs);
    }
    
    return hr;
}

inline HRESULT SpEnumTokens(
    const WCHAR * pszCategoryId, 
    const WCHAR * pszReqAttribs, 
    const WCHAR * pszOptAttribs, 
    IEnumSpObjectTokens ** ppEnum)
{
    HRESULT hr = S_OK;
    
    CComPtr<ISpObjectTokenCategory> cpCategory;
    hr = SpGetCategoryFromId(pszCategoryId, &cpCategory);
    
    if (SUCCEEDED(hr))
    {
        hr = cpCategory->EnumTokens(
                    pszReqAttribs,
                    pszOptAttribs,
                    ppEnum);
    }
    
    return hr;
}

inline HRESULT SpFindBestToken(
    const WCHAR * pszCategoryId, 
    const WCHAR * pszReqAttribs, 
    const WCHAR * pszOptAttribs, 
    ISpObjectToken **ppObjectToken)
{
    HRESULT hr = S_OK;
    
    const WCHAR *pszVendorPreferred = L"VendorPreferred";
    const ULONG ulLenVendorPreferred = (ULONG) wcslen(pszVendorPreferred);

    // append VendorPreferred to the end of pszOptAttribs to force this preference
    ULONG ulLen;
    if (pszOptAttribs)
    {
        hr = ULongAdd((ULONG)wcslen(pszOptAttribs), ulLenVendorPreferred, &ulLen);
        if (SUCCEEDED(hr))
        {
            hr = ULongAdd(ulLen, 1 + 1, &ulLen); // including 1 char here for null terminator
        }
    }
    else
    {
        hr = ULongAdd(ulLenVendorPreferred, 1, &ulLen); // including 1 char here for null terminator
    }
    if (FAILED(hr))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        WCHAR *pszOptAttribsVendorPref = new WCHAR[ulLen];
        if (pszOptAttribsVendorPref)
        {
            if (pszOptAttribs)
            {
                StringCchCopyW (pszOptAttribsVendorPref, ulLen, pszOptAttribs);
                StringCchCatW (pszOptAttribsVendorPref, ulLen, L";");
                StringCchCatW (pszOptAttribsVendorPref, ulLen, pszVendorPreferred);
            }
            else
            {
                StringCchCopyW (pszOptAttribsVendorPref, ulLen, pszVendorPreferred);
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        CComPtr<IEnumSpObjectTokens> cpEnum;
        if (SUCCEEDED(hr))
        {
            hr = SpEnumTokens(pszCategoryId, pszReqAttribs, pszOptAttribsVendorPref, &cpEnum);
        }

        delete[] pszOptAttribsVendorPref;

        if (SUCCEEDED(hr))
        {
            hr = cpEnum->Next(1, ppObjectToken, NULL);
            if (hr == S_FALSE)
            {
                *ppObjectToken = NULL;
                hr = SPERR_NOT_FOUND;
            }
        }
    }

    return hr;
}

template<class T>
HRESULT SpCreateObjectFromToken(ISpObjectToken * pToken, T ** ppObject,
                       IUnknown * pUnkOuter = NULL, DWORD dwClsCtxt = CLSCTX_ALL)
{
    HRESULT hr;

    hr = pToken->CreateInstance(pUnkOuter, dwClsCtxt, __uuidof(T), (void **)ppObject);
    
    return hr;
}

template<class T>
HRESULT SpCreateObjectFromTokenId(const WCHAR * pszTokenId, T ** ppObject,
                       IUnknown * pUnkOuter = NULL, DWORD dwClsCtxt = CLSCTX_ALL)
{
    
    ISpObjectToken * pToken;
    HRESULT hr = SpGetTokenFromId(pszTokenId, &pToken);
    if (SUCCEEDED(hr))
    {
        hr = SpCreateObjectFromToken(pToken, ppObject, pUnkOuter, dwClsCtxt);
        pToken->Release();
    }

    return hr;
}

template<class T>
HRESULT SpCreateDefaultObjectFromCategoryId(const WCHAR * pszCategoryId, T ** ppObject,
                       IUnknown * pUnkOuter = NULL, DWORD dwClsCtxt = CLSCTX_ALL)
{
   
    ISpObjectToken * pToken;
    HRESULT hr = SpGetDefaultTokenFromCategoryId(pszCategoryId, &pToken);
    if (SUCCEEDED(hr))
    {
        hr = SpCreateObjectFromToken(pToken, ppObject, pUnkOuter, dwClsCtxt);
        pToken->Release();
    }

    return hr;
}

template<class T>
HRESULT SpCreateBestObject(
    const WCHAR * pszCategoryId, 
    const WCHAR * pszReqAttribs, 
    const WCHAR * pszOptAttribs, 
    T ** ppObject,
    IUnknown * pUnkOuter = NULL, 
    DWORD dwClsCtxt = CLSCTX_ALL)
{
    HRESULT hr;
    
    CComPtr<ISpObjectToken> cpToken;
    hr = SpFindBestToken(pszCategoryId, pszReqAttribs, pszOptAttribs, &cpToken);

    if (SUCCEEDED(hr))
    {
        hr = SpCreateObjectFromToken(cpToken, ppObject, pUnkOuter, dwClsCtxt);
    }

    return hr;
}

inline HRESULT SpCreatePhoneConverter(
    LANGID LangID,
    const WCHAR * pszReqAttribs,
    const WCHAR * pszOptAttribs,
    ISpPhoneConverter ** ppPhoneConverter)
{
    HRESULT hr = SPERR_NOT_FOUND;

    // If not IPA or UPS
    if (LangID != 0)
    {
        CSpDynamicString dstrReqAttribs;
        if (pszReqAttribs)
        {
            dstrReqAttribs = pszReqAttribs;
            dstrReqAttribs.Append(L";");
        }

        WCHAR szLang[MAX_PATH];

        SpHexFromUlong(szLang, LangID);

        WCHAR szLangCondition[MAX_PATH];
        StringCchCopyW(szLangCondition, MAX_PATH, L"Language=");
        StringCchCatW(szLangCondition, MAX_PATH, szLang);

        dstrReqAttribs.Append(szLangCondition);

        hr = SpCreateBestObject(SPCAT_PHONECONVERTERS, dstrReqAttribs, pszOptAttribs, ppPhoneConverter);
    }

#if _SAPI_VER >= 0x053
    // If we cannot find a phone converter, use the Universal Phone Converter as default
    if (hr == SPERR_NOT_FOUND)
    {
        hr =  CoCreateInstance(CLSID_SpPhoneConverter, NULL, CLSCTX_ALL, IID_ISpPhoneConverter, (LPVOID*)ppPhoneConverter);

        if (SUCCEEDED(hr))
        {
            ISpPhoneticAlphabetSelection * pAlphabetSelection = NULL;
            hr = (*ppPhoneConverter)->QueryInterface(IID_ISpPhoneticAlphabetSelection, (LPVOID*) &pAlphabetSelection);
            if (SUCCEEDED(hr))
            {
                hr = pAlphabetSelection->SetAlphabetToUPS(TRUE);
                pAlphabetSelection->Release();
            }
            else
            {
                // We cannot query for the new interface, reset the error code
                hr = SPERR_NOT_FOUND;
            }

            if (FAILED(hr))
            {
                (*ppPhoneConverter)->Release();
                *ppPhoneConverter = NULL;
            }
        }
    }
#endif
    return hr;
}

inline HRESULT SpGetLanguageFromToken(ISpObjectToken * pToken, LANGID * plangid)
{
    HRESULT hr = S_OK;
    CComPtr<ISpDataKey> cpDataKeyAttribs;
    hr = pToken->OpenKey(SPTOKENKEY_ATTRIBUTES, &cpDataKeyAttribs);

    CSpDynamicString dstrLanguage;
    if (SUCCEEDED(hr))
    {
        hr = cpDataKeyAttribs->GetStringValue(L"Language", &dstrLanguage);
    }

    if (SUCCEEDED(hr))
    {
        const WCHAR *pszLangId = dstrLanguage;
        WCHAR achHexNumber [5]; // LangIds cannot be more than 4 characters longs

        // check if the langid is in the format "409;9" - extract the "409" in this case
        const WCHAR *pSemiColon = wcschr (pszLangId, L';');
        if (pSemiColon)
        {
            size_t cLen = pSemiColon - dstrLanguage;
            if (cLen <= 4)
            {
                StringCbCopyNW (achHexNumber, sizeof (achHexNumber), dstrLanguage, cLen * sizeof (achHexNumber [0]));
                pszLangId = achHexNumber;
            }
        }
        unsigned langid;
        if (FAILED (SpULongFromHex(pszLangId, &langid)))
        {
            hr = SPERR_INVALID_TOKEN_ID;
        }
        else
        {
            *plangid = (LANGID) langid;
        }
    }

    return hr;
}

inline HRESULT SpGetLanguageFromVoiceToken(ISpObjectToken * pToken, LANGID * plangid)
{
    return SpGetLanguageFromToken(pToken, plangid);
}


/****************************************************************************
* SpHrFromWin32 *
*---------------*
*   Description:
*       This inline function works around a basic problem with the macro
*   HRESULT_FROM_WIN32.  The macro forces the expresion in ( ) to be evaluated
*   two times.  By using this inline function, the expression will only be
*   evaluated once.
*
*   Returns:
*       HRESULT of converted Win32 error code
*
*****************************************************************************/

inline HRESULT SpHrFromWin32(DWORD dwErr)
{
    return HRESULT_FROM_WIN32(dwErr);
}


/****************************************************************************
* SpHrFromLastWin32Error *
*------------------------*
*   Description:
*       This simple inline function is used to return a converted HRESULT
*   from the Win32 function ::GetLastError.  Note that using HRESULT_FROM_WIN32
*   will evaluate the error code twice so we don't want to use:
*
*       HRESULT_FROM_WIN32(::GetLastError()) 
*
*   since that will call GetLastError twice.
*
*   Returns:
*       HRESULT for ::GetLastError(). If the HRESULT is a success code, this 
*       function will return E_FAIL to guarantee an error return code.
*
*****************************************************************************/

inline HRESULT SpHrFromLastWin32Error()
{
    HRESULT hr = SpHrFromWin32(::GetLastError());
    return FAILED(hr) ? hr : E_FAIL;
}


/****************************************************************************
* SpGetUserDefaultUILanguage *
*----------------------------*
*   Description:
*       Now that we only support XP & Above, this is a straight call to
*       GetUserDefaultUILanguage
*
*   Returns:
*       Default UI language
*
*****************************************************************************/

inline LANGID SpGetUserDefaultUILanguage(void) 
{
    return GetUserDefaultUILanguage() ;
}

inline HRESULT SpGetDescription(ISpObjectToken * pObjToken, __deref_out WCHAR ** ppszDescription, LANGID Language = SpGetUserDefaultUILanguage())
{
    WCHAR szLangId[10];
    HRESULT hr = S_OK;

#if _SAPI_VER >= 0x053
    WCHAR* pRegKeyPath = 0;
    WCHAR* pszTemp = 0;
    HKEY   Handle = NULL;

    // Windows Vista does not encourage localized strings in the registry
    // When running on Windows Vista query the localized engine name from a resource dll
    OSVERSIONINFO ver;
    ver.dwOSVersionInfoSize = sizeof( ver );

    if (ppszDescription == NULL)
    {
        return E_POINTER;
    }
    *ppszDescription = NULL;

    if( ( ::GetVersionEx( &ver ) == TRUE ) && ( ver.dwMajorVersion >= 6 ) )
    {
        // If we reach this code we are running under Windows Vista
        HMODULE hmodAdvapi32Dll = NULL;
        typedef HRESULT (WINAPI* LPFN_RegLoadMUIStringW)(HKEY, LPCWSTR, LPWSTR, DWORD, LPDWORD, DWORD, LPCWSTR);
        LPFN_RegLoadMUIStringW pfnRegLoadMUIStringW = NULL;
                
        // Delay bind with RegLoadMUIStringW since this function is not supported on previous versions of advapi32.dll
        // RegLoadMUIStringW is supported only on advapi32.dll that ships with Windows Vista  and above
        // Calling RegLoadMUIStringW directly makes the loader try to resolve the function reference at load time which breaks,
        // hence we manually load advapi32.dll, query for the function pointer and invoke it.
        hmodAdvapi32Dll = ::LoadLibrary(TEXT("advapi32.dll"));
        if(hmodAdvapi32Dll)
        {
            pfnRegLoadMUIStringW = (LPFN_RegLoadMUIStringW) ::GetProcAddress(hmodAdvapi32Dll, "RegLoadMUIStringW");
            if (!pfnRegLoadMUIStringW)
            {
                // This should not happen in Vista
                _ASSERT (pfnRegLoadMUIStringW);
                hr = TYPE_E_DLLFUNCTIONNOTFOUND;
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_DLL_NOT_FOUND);
        }
        
        if (SUCCEEDED(hr))
        {
            hr = pObjToken->GetId(&pszTemp);
        }

        if (SUCCEEDED(hr))
        {
            LONG   lErrorCode = ERROR_SUCCESS;

            pRegKeyPath = wcschr(pszTemp, L'\\');   // Find the first occurance of '\\' in the absolute registry key path
            if(pRegKeyPath)
            {
                *pRegKeyPath = L'\0';
                pRegKeyPath++;                         // pRegKeyPath now points to the path to the recognizer token under the HKLM or HKCR hive
                *ppszDescription = 0;

                // Open the registry key for read and get the handle
                if (wcsncmp(pszTemp, L"HKEY_LOCAL_MACHINE", MAX_PATH) == 0)
                {
                    lErrorCode = RegOpenKeyExW(HKEY_LOCAL_MACHINE, pRegKeyPath, 0, KEY_QUERY_VALUE, &Handle);
                }
                else if (wcsncmp(pszTemp, L"HKEY_CURRENT_USER", MAX_PATH) == 0)
                {
                    lErrorCode = RegOpenKeyExW(HKEY_CURRENT_USER, pRegKeyPath, 0, KEY_QUERY_VALUE, &Handle);
                }
                else
                {
                    lErrorCode = ERROR_BAD_ARGUMENTS;
                }
                
                // Use MUI RegLoadMUIStringW API to load the localized string
                if(ERROR_SUCCESS == lErrorCode)
                {
                    *ppszDescription = (WCHAR*) CoTaskMemAlloc(MAX_PATH * sizeof(WCHAR)); // This should be enough memory to allocate the localized Engine Name
                    lErrorCode = (*pfnRegLoadMUIStringW) (Handle, SR_LOCALIZED_DESCRIPTION, *ppszDescription, MAX_PATH * sizeof(WCHAR), NULL, REG_MUI_STRING_TRUNCATE, NULL);
                }
            }
            else
            {
                // pRegKeyPath should never be 0 if we are querying for relative hkey path
                lErrorCode = ERROR_BAD_ARGUMENTS;
            }

            hr = HRESULT_FROM_WIN32(lErrorCode);
        }

        // Close registry key handle
        if(Handle)
        {
            RegCloseKey(Handle);
        }
        // Free memory allocated to locals
        if(pszTemp)
        {
            CoTaskMemFree(pszTemp);
        }
        if (hmodAdvapi32Dll)
        {
            ::FreeLibrary(hmodAdvapi32Dll);
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
    }

    _ASSERT(FAILED(hr) || *ppszDescription != NULL);
    // If running on OSes released before Windows Vista query the localized string from the registry
    // If RegLoadMUIStringW failed to retrieved the localized Engine name retrieve the localized string from the fallback (Default) attribute
#else
    hr = E_FAIL;
#endif // _SAPI_VER >= 0x053
    if (FAILED(hr))
    {
        // Free memory allocated above if necessary
        if (*ppszDescription != NULL)
        {
            CoTaskMemFree(*ppszDescription);
            *ppszDescription = NULL;
        }

        SpHexFromUlong(szLangId, Language);
        hr = pObjToken->GetStringValue(szLangId, ppszDescription);
        if (hr == SPERR_NOT_FOUND)
        {
            hr = pObjToken->GetStringValue(NULL, ppszDescription);
        }
    }

    return hr;
}


inline HRESULT SpSetDescription(ISpObjectToken * pObjToken, const WCHAR * pszDescription, LANGID Language = SpGetUserDefaultUILanguage(), BOOL fSetLangIndependentId = TRUE)
{
    WCHAR szLangId[10];
    SpHexFromUlong(szLangId, Language);
    HRESULT hr = pObjToken->SetStringValue(szLangId, pszDescription);
    if (SUCCEEDED(hr) && fSetLangIndependentId)
    {
        hr = pObjToken->SetStringValue(NULL, pszDescription);
    }
    return hr;
}

/****************************************************************************
* SpConvertStreamFormatEnum *
*---------------------------*
*   Description:
*       This method converts the specified stream format into a wave format
*   structure.
*
*****************************************************************************/
inline HRESULT SpConvertStreamFormatEnum(SPSTREAMFORMAT eFormat, GUID * pFormatId, WAVEFORMATEX ** ppCoMemWaveFormatEx)
{
    HRESULT hr = S_OK;

    if(pFormatId==NULL || ppCoMemWaveFormatEx==NULL)
    {
        return E_INVALIDARG;
    }

    const GUID * pFmtGuid = &GUID_NULL;     // Assume failure case
    if( eFormat >= SPSF_8kHz8BitMono && eFormat <= SPSF_48kHz16BitStereo )
    {
        WAVEFORMATEX * pwfex = (WAVEFORMATEX *)::CoTaskMemAlloc(sizeof(WAVEFORMATEX));
        *ppCoMemWaveFormatEx = pwfex;
        if (pwfex)
        {
            DWORD dwIndex = eFormat - SPSF_8kHz8BitMono;
            BOOL bIsStereo = dwIndex & 0x1;
            BOOL bIs16 = dwIndex & 0x2;
            DWORD dwKHZ = (dwIndex & 0x3c) >> 2;
            static const DWORD adwKHZ[] = { 8000, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000 };
            pwfex->wFormatTag = WAVE_FORMAT_PCM;
            pwfex->nChannels = pwfex->nBlockAlign = (WORD)(bIsStereo ? 2 : 1);
            pwfex->nSamplesPerSec = (dwKHZ < sizeof(adwKHZ)/sizeof(adwKHZ[0])) ? adwKHZ[dwKHZ] : adwKHZ[0];
            pwfex->wBitsPerSample = 8;
            if (bIs16)
            {
                pwfex->wBitsPerSample *= 2;
                pwfex->nBlockAlign *= 2;
            }
                pwfex->nAvgBytesPerSec = pwfex->nSamplesPerSec * pwfex->nBlockAlign;
            pwfex->cbSize = 0;
            pFmtGuid = &SPDFID_WaveFormatEx;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else if( eFormat == SPSF_TrueSpeech_8kHz1BitMono )
    {
        int NumBytes = sizeof( WAVEFORMATEX ) + 32;
        WAVEFORMATEX * pwfex = (WAVEFORMATEX *)::CoTaskMemAlloc( NumBytes );
        *ppCoMemWaveFormatEx = pwfex;
        if( pwfex )
        {
            memset( pwfex, 0, NumBytes );
            pwfex->wFormatTag      = WAVE_FORMAT_DSPGROUP_TRUESPEECH;
            pwfex->nChannels       = 1;
            pwfex->nSamplesPerSec  = 8000;
            pwfex->nAvgBytesPerSec = 1067;
            pwfex->nBlockAlign     = 32;
            pwfex->wBitsPerSample  = 1;
            pwfex->cbSize          = 32;
            BYTE* pExtra = ((BYTE*)pwfex) + sizeof( WAVEFORMATEX );
            pExtra[0] = 1;
            pExtra[2] = 0xF0;
            pFmtGuid = &SPDFID_WaveFormatEx;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else if( (eFormat >= SPSF_CCITT_ALaw_8kHzMono    ) &&
             (eFormat <= SPSF_CCITT_ALaw_44kHzStereo ) )
    {
        WAVEFORMATEX * pwfex = (WAVEFORMATEX *)::CoTaskMemAlloc( sizeof(WAVEFORMATEX) );
        *ppCoMemWaveFormatEx = pwfex;
        if( pwfex )
        {
            memset( pwfex, 0, sizeof(WAVEFORMATEX) );
            DWORD dwIndex = eFormat - SPSF_CCITT_ALaw_8kHzMono;
            DWORD dwKHZ = dwIndex / 2;
            static const DWORD adwKHZ[] = { 8000, 11025, 22050, 44100 };
            BOOL bIsStereo    = dwIndex & 0x1;
            pwfex->wFormatTag = WAVE_FORMAT_ALAW;
            pwfex->nChannels  = pwfex->nBlockAlign = (WORD)(bIsStereo ? 2 : 1);
            pwfex->nSamplesPerSec = (dwKHZ < sizeof(adwKHZ)/sizeof(adwKHZ[0])) ? adwKHZ[dwKHZ] : adwKHZ[0];
            pwfex->wBitsPerSample  = 8;
            pwfex->nAvgBytesPerSec = pwfex->nSamplesPerSec * pwfex->nBlockAlign;
            pwfex->cbSize          = 0;
            pFmtGuid = &SPDFID_WaveFormatEx;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else if( (eFormat >= SPSF_CCITT_uLaw_8kHzMono    ) &&
             (eFormat <= SPSF_CCITT_uLaw_44kHzStereo ) )
    {
        WAVEFORMATEX * pwfex = (WAVEFORMATEX *)::CoTaskMemAlloc( sizeof(WAVEFORMATEX) );
        *ppCoMemWaveFormatEx = pwfex;
        if( pwfex )
        {
            memset( pwfex, 0, sizeof(WAVEFORMATEX) );
            DWORD dwIndex = eFormat - SPSF_CCITT_uLaw_8kHzMono;
            DWORD dwKHZ = dwIndex / 2;
            static const DWORD adwKHZ[] = { 8000, 11025, 22050, 44100 };
            BOOL bIsStereo    = dwIndex & 0x1;
            pwfex->wFormatTag = WAVE_FORMAT_MULAW;
            pwfex->nChannels  = pwfex->nBlockAlign = (WORD)(bIsStereo ? 2 : 1);
            pwfex->nSamplesPerSec = (dwKHZ < sizeof(adwKHZ)/sizeof(adwKHZ[0])) ? adwKHZ[dwKHZ] : adwKHZ[0];
            pwfex->wBitsPerSample  = 8;
            pwfex->nAvgBytesPerSec = pwfex->nSamplesPerSec * pwfex->nBlockAlign;
            pwfex->cbSize          = 0;
            pFmtGuid = &SPDFID_WaveFormatEx;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else if( (eFormat >= SPSF_ADPCM_8kHzMono    ) &&
             (eFormat <= SPSF_ADPCM_44kHzStereo ) )
    {
        int NumBytes = sizeof( WAVEFORMATEX ) + 32;
        WAVEFORMATEX * pwfex = (WAVEFORMATEX *)::CoTaskMemAlloc( NumBytes );
        *ppCoMemWaveFormatEx = pwfex;
        if( pwfex )
        {
            //--- Some of these values seem odd. We used what the codec told us.
            static const DWORD adwKHZ[] = { 8000, 11025, 22050, 44100 };
            static const DWORD BytesPerSec[] = { 4096, 8192, 5644, 11289, 11155, 22311, 22179, 44359 };
            static const DWORD BlockAlign[]  = { 256, 256, 512, 1024 };
            static const BYTE Extra811[32] =
            {
                0xF4, 0x01, 0x07, 0x00, 0x00, 0x01, 0x00, 0x00,
                0x00, 0x02, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00,
                0xC0, 0x00, 0x40, 0x00, 0xF0, 0x00, 0x00, 0x00,
                0xCC, 0x01, 0x30, 0xFF, 0x88, 0x01, 0x18, 0xFF
            };

            static const BYTE Extra22[32] =
            {
                0xF4, 0x03, 0x07, 0x00, 0x00, 0x01, 0x00, 0x00,
                0x00, 0x02, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00,
                0xC0, 0x00, 0x40, 0x00, 0xF0, 0x00, 0x00, 0x00,
                0xCC, 0x01, 0x30, 0xFF, 0x88, 0x01, 0x18, 0xFF
            };

            static const BYTE Extra44[32] =
            {
                0xF4, 0x07, 0x07, 0x00, 0x00, 0x01, 0x00, 0x00,
                0x00, 0x02, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00,
                0xC0, 0x00, 0x40, 0x00, 0xF0, 0x00, 0x00, 0x00,
                0xCC, 0x01, 0x30, 0xFF, 0x88, 0x01, 0x18, 0xFF
            };

            static const BYTE* Extra[4] = { Extra811, Extra811, Extra22, Extra44 };
            memset( pwfex, 0, NumBytes );
            DWORD dwIndex  = eFormat - SPSF_ADPCM_8kHzMono;
            DWORD dwKHZ    = dwIndex / 2;
            BOOL bIsStereo = dwIndex & 0x1;
            pwfex->wFormatTag      = WAVE_FORMAT_ADPCM;
            pwfex->nChannels       = (WORD)(bIsStereo ? 2 : 1);
            pwfex->nSamplesPerSec =  (dwKHZ < sizeof(adwKHZ)/sizeof(adwKHZ[0])) ? adwKHZ[dwKHZ] : adwKHZ[0];
            pwfex->nAvgBytesPerSec = (dwIndex < sizeof(BytesPerSec)/sizeof(BytesPerSec[0])) ? BytesPerSec[dwIndex] : BytesPerSec[0];
            pwfex->nBlockAlign     = (WORD)(((dwKHZ < sizeof(BlockAlign)/sizeof(BlockAlign[0])) ? BlockAlign[dwKHZ] : BlockAlign[0]) * pwfex->nChannels);
            pwfex->wBitsPerSample  = 4;
            pwfex->cbSize          = 32;
            BYTE* pExtra = ((BYTE*)pwfex) + sizeof( WAVEFORMATEX );
            memcpy( pExtra, (dwKHZ < sizeof(Extra)/sizeof(Extra[0])) ? Extra[dwKHZ] : Extra[0], 32 );
            pFmtGuid = &SPDFID_WaveFormatEx;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else if( (eFormat >= SPSF_GSM610_8kHzMono    ) &&
             (eFormat <= SPSF_GSM610_44kHzMono ) )
    {
        int NumBytes = sizeof( WAVEFORMATEX ) + 2;
        WAVEFORMATEX * pwfex = (WAVEFORMATEX *)::CoTaskMemAlloc( NumBytes );
        *ppCoMemWaveFormatEx = pwfex;
        if( pwfex )
        {
            //--- Some of these values seem odd. We used what the codec told us.
            static const DWORD adwKHZ[] = { 8000, 11025, 22050, 44100 };
            static const DWORD BytesPerSec[] = { 1625, 2239, 4478, 8957 };
            memset( pwfex, 0, NumBytes );
            DWORD dwIndex          = eFormat - SPSF_GSM610_8kHzMono;
            pwfex->wFormatTag      = WAVE_FORMAT_GSM610;
            pwfex->nChannels       = 1;
            pwfex->nSamplesPerSec = (dwIndex < sizeof(adwKHZ)/sizeof(adwKHZ[0])) ? adwKHZ[dwIndex] : adwKHZ[0];
            pwfex->nAvgBytesPerSec = BytesPerSec[dwIndex];
            pwfex->nBlockAlign     = 65;
            pwfex->wBitsPerSample  = 0;
            pwfex->cbSize          = 2;
            BYTE* pExtra = ((BYTE*)pwfex) + sizeof( WAVEFORMATEX );
            pExtra[0] = 0x40;
            pExtra[1] = 0x01;
            pFmtGuid = &SPDFID_WaveFormatEx;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        *ppCoMemWaveFormatEx = NULL;
        switch (eFormat)
        {
        case SPSF_NoAssignedFormat:
            break;
        case SPSF_Text:
            pFmtGuid = &SPDFID_Text;
            break;
        default:
            hr = E_INVALIDARG;
            break;
        }
    }
    *pFormatId = *pFmtGuid;
    return hr;
}

class CSpStreamFormat
{
public:
    GUID            m_guidFormatId;
    WAVEFORMATEX  * m_pCoMemWaveFormatEx; 


    static HRESULT CoMemCopyWFEX(const WAVEFORMATEX * pSrc, WAVEFORMATEX ** ppCoMemWFEX)
    {
        if (pSrc == NULL ||
            pSrc->nAvgBytesPerSec == 0 ||
            pSrc->nBlockAlign == 0 ||
            pSrc->nChannels == 0) // There are other fields like wBitsPerSample but these can be zero in some formats.
        {
            return E_INVALIDARG;
        }

        ULONG cb = sizeof(WAVEFORMATEX);
        if (pSrc->wFormatTag != WAVE_FORMAT_PCM)
        {
            // Add the extra data size in but ignore for WAVE_FORMAT_PCM {accoring to MSDN this should be ignored}.
            cb += pSrc->cbSize;
            if (cb < pSrc->cbSize)
            {
                return E_INVALIDARG;
            }
        }

        *ppCoMemWFEX = (WAVEFORMATEX *)::CoTaskMemAlloc(cb);
        if (*ppCoMemWFEX)
        {
            memcpy(*ppCoMemWFEX, pSrc, cb);
            if ((*ppCoMemWFEX)->wFormatTag == WAVE_FORMAT_PCM)
            {
                (*ppCoMemWFEX)->cbSize = 0; // Always set cbSize to zero for WAVE_FORMAT_PCM.
            }
            return S_OK;
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }


    CSpStreamFormat()
    {
        m_guidFormatId = GUID_NULL;
        m_pCoMemWaveFormatEx = NULL;
    }

    CSpStreamFormat(SPSTREAMFORMAT eFormat, HRESULT * phr)
    {
        *phr = SpConvertStreamFormatEnum(eFormat, &m_guidFormatId, &m_pCoMemWaveFormatEx);
    }

    CSpStreamFormat(const WAVEFORMATEX * pWaveFormatEx, HRESULT * phr)
    {
        _ASSERT(pWaveFormatEx);
        *phr = CoMemCopyWFEX(pWaveFormatEx, &m_pCoMemWaveFormatEx);
        m_guidFormatId = SUCCEEDED(*phr) ? SPDFID_WaveFormatEx : GUID_NULL;
    }

    ~CSpStreamFormat()
    {
        ::CoTaskMemFree(m_pCoMemWaveFormatEx);
    }

    void Clear()
    {
        ::CoTaskMemFree(m_pCoMemWaveFormatEx);
        m_pCoMemWaveFormatEx = NULL;
        memset(&m_guidFormatId, 0, sizeof(m_guidFormatId));
    }

    const GUID & FormatId() const 
    {
        return m_guidFormatId;
    }

    const WAVEFORMATEX * WaveFormatExPtr() const
    {
        return m_pCoMemWaveFormatEx;
    }


    HRESULT AssignFormat(SPSTREAMFORMAT eFormat)
    {
        ::CoTaskMemFree(m_pCoMemWaveFormatEx);    
        return SpConvertStreamFormatEnum(eFormat, &m_guidFormatId, &m_pCoMemWaveFormatEx);
    }

    HRESULT AssignFormat(ISpStreamFormat * pStream)
 